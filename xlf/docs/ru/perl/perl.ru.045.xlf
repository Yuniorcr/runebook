<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="ea689de74e82f416fbcbf4ee9e4cea8733686d01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$_&lt;/code&gt; является псевдонимом значения списка, поэтому его можно использовать для изменения элементов LIST. Хотя это полезно и поддерживается, это может привести к странным результатам, если элементы LIST не являются переменными. В большинстве случаев &lt;code&gt;foreach&lt;/code&gt; для этой цели обычный цикл foreach . См. Также &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; для массива, состоящего из тех элементов исходного списка, для которых BLOCK или EXPR оцениваются как истинные.</target>
        </trans-unit>
        <trans-unit id="e54794d0f40f1a8695668c788a3a5c6d8b245de4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$_&lt;/code&gt; является псевдонимом значения списка, поэтому его можно использовать для изменения элементов LIST. Хотя это полезно и поддерживается, это может привести к странным результатам, если элементы LIST не являются переменными. В большинстве случаев &lt;code&gt;foreach&lt;/code&gt; для этой цели обычный цикл foreach . См. Также &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; для массива, состоящего из тех элементов исходного списка, для которых BLOCK или EXPR оцениваются как истинные.</target>
        </trans-unit>
        <trans-unit id="ff224648e7f90554d343ed0de97c9efcc8456e37" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$processed&lt;/code&gt; может быть пустым (когда &lt;code&gt;$normalized&lt;/code&gt; содержит стартера или начинается с последнего стартера), и тогда &lt;code&gt;$unprocessed&lt;/code&gt; должно быть равно полному &lt;code&gt;$normalized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2dca7ba63a68f9fddd9b7ac309791bf8abd311e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f1dc26add5ebccf190f8ef66eb27e1f5723ef3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt;, the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2098e1cc9941a87eb89bbdff478cb887098142a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(?[ ])&lt;/code&gt; is a regex-compile-time construct. Any attempt to use something which isn't knowable at the time the containing regular expression is compiled is a fatal error. In practice, this means just three limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd09559e1981494f86fde1566facece3e2639305" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--opt value&lt;/code&gt; is still accepted, even though GNU getopt_long() doesn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc9bdd2d79f09af0f88913bcc31f66fb74dccd1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-register&lt;/code&gt; is a global setting that applies to the entire program; it cannot be applied only for certain callers, removed, or limited by lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd002d9c23fd4dcc51fd0e853c891c09f321ec46" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;-s/a/b/&lt;/code&gt; не выполняет замену с отрицанием. Однако выражение &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; прежнему работает должным образом: только отдельные буквы, следующие за минусом, интерпретируются как проверки файлов.</target>
        </trans-unit>
        <trans-unit id="dd375a04334c45f998942d7896c30f702e8152ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;-s/a/b/&lt;/code&gt; не выполняет замену с отрицанием. Однако выражение &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; прежнему работает должным образом: только отдельные буквы, следующие за минусом, интерпретируются как проверки файлов.</target>
        </trans-unit>
        <trans-unit id="e3f960c753f2dbcaaba10ddc75d049f8c367286e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-exp($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bc3a755225cb163af628efdd36b7e99bf599a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt; , as in:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;:constants256&lt;/code&gt; не включает другие константы, поэтому, если вы хотите смешать обе, вам также необходимо включить &lt;code&gt;:constants&lt;/code&gt; . Вы можете явно импортировать как минимум &lt;code&gt;RESET&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="e353e5ca3a012a60bd40d8c3d650a30fa181791c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt;, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a3c31d64bd9d3852dee2165f0cdbe3c7fd1617" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; - это итоги статусов ожидания и выхода каждого из тестов. Эти значения суммируются только для получения истинного значения, если любое из них не равно нулю.</target>
        </trans-unit>
        <trans-unit id="9173a2f0f306c97db5af943fc6a5b25c88ebded1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; не указаны выше. Если они вызываются как методы объекта Time :: Piece, они действуют как конструкторы, возвращая новый объект Time :: Piece для текущего времени. Другими словами: они бесполезны как методы.</target>
        </trans-unit>
        <trans-unit id="9ce1c937ab3425a64de9dbc02778e5245a104b13" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; возвращает последний символ. Чтобы вернуть все символы, кроме последнего, используйте &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37ddc1b7985e6cde1bfecc807084dd2439da4505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; не будет вызывать ваши блоки &lt;code&gt;END&lt;/code&gt; и не будет вызывать методы &lt;code&gt;DESTROY&lt;/code&gt; для ваших объектов.</target>
        </trans-unit>
        <trans-unit id="a60dfdd6e65097f6c305737073a8bc35fe255a7e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; вызывает исключение, если используется на машине, которая не реализует fcntl (2). См. Модуль Fcntl или справочную страницу fcntl (2), чтобы узнать, какие функции доступны в вашей системе.</target>
        </trans-unit>
        <trans-unit id="dfb2038f7135091071546cb9a6d373bb9a56e94d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; обычно не требуется при использовании обычных файловых дескрипторов; он предоставляется для того, чтобы при необходимости вы могли управлять вводом-выводом в существующие файлы со структурой записей. Вы можете также использовать &lt;code&gt;vmsfopen&lt;/code&gt; функцию расширения VMS :: STDIO , чтобы получить более тонкий контроль ввода / вывода файлов и устройств с различными структурами записей.</target>
        </trans-unit>
        <trans-unit id="bb9b28a9d5d46f3c748ef4753fd4b0b26da11633" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; возвращает последний символ. Чтобы вернуть все символы, кроме последнего, используйте &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2886ca2fd4621ed375e17bc5caf418ae86a77d6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; не будет вызывать ваши блоки &lt;code&gt;END&lt;/code&gt; и не будет вызывать методы &lt;code&gt;DESTROY&lt;/code&gt; для ваших объектов.</target>
        </trans-unit>
        <trans-unit id="f249c4d8b204567737cd31f8ec07948c8d5ac294" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; вызывает исключение, если используется на машине, которая не реализует fcntl (2). См. Модуль Fcntl или справочную страницу fcntl (2), чтобы узнать, какие функции доступны в вашей системе.</target>
        </trans-unit>
        <trans-unit id="d7d9c1784c1fe9a279665a4571e3c21c04751dcb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; разбивает свои аргументы на пробелы и обрабатывает каждый сегмент как отдельный образец. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; соответствует всем файлам с</target>
        </trans-unit>
        <trans-unit id="dd0f76b7382c19ee434e95709a48f61a31e19d7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; не работает с текущей версией EMX.</target>
        </trans-unit>
        <trans-unit id="d132135000cd2c7bd9f4aab4e6bdef7ae41bf7a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; зависит от библиотечной функции fdopen () C. Во многих системах Unix известно, что fdopen () завершается ошибкой, когда файловые дескрипторы превышают определенное значение, обычно 255. Если вам нужно больше файловых дескрипторов, рассмотрите возможность использования функции POSIX :: open ().</target>
        </trans-unit>
        <trans-unit id="967dccf72de487894a0bc580911ae2819ad24053" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; utility. If you want to map strings between lower/upper cases, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; and &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, and in general consider using the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; operator if you need regular expressions. The &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; will not (except sometimes on legacy 7-bit data).</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; вовсе &lt;b&gt;не&lt;/b&gt; делать регулярные занятия выражением характера , такие как &lt;code&gt;\d&lt;/code&gt; или &lt;code&gt;\pL&lt;/code&gt; . Оператор &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; не эквивалентен утилите &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; . Если вы хотите отображать строки между нижним и верхним регистрами, см. &lt;a href=&quot;functions/lc&quot;&gt;Lc&lt;/a&gt; и &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt; , и вообще рассмотрите возможность использования оператора &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , если вам нужны регулярные выражения. &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , а &lt;code&gt;\l&lt;/code&gt; строка-интерполяция побеги на правой стороне оператора замещения будет выполнять правильные тематические отображения, но &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; не будет (кроме случаев, когда используются устаревшие 7-битные данные).</target>
        </trans-unit>
        <trans-unit id="1a25e1352e6c84bdaa3b67f15d7d22519e3dc2fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;\U&lt;/code&gt; в интерполированных строках переводится в верхний регистр, тогда как &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;\u&lt;/code&gt; в интерполированных строках переводится в titlecase в языках, которые делают различие (что эквивалентно прописным буквам в языках без различия).</target>
        </trans-unit>
        <trans-unit id="f7309bf49e0287f1d8c15ab22ef310f10a5d4bd7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; разбивает свои аргументы на пробелы и обрабатывает каждый сегмент как отдельный образец. Таким образом, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; соответствует всем файлам с</target>
        </trans-unit>
        <trans-unit id="986549b394dff5a5a4195bbc3a0e0761106da86b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; зависит от библиотечной функции fdopen () C. Во многих системах Unix известно, что fdopen () завершается ошибкой, когда файловые дескрипторы превышают определенное значение, обычно 255. Если вам нужно больше файловых дескрипторов, рассмотрите возможность использования функции POSIX :: open ().</target>
        </trans-unit>
        <trans-unit id="f9b1a84ba3ae7615ac251b965f25b6f6929c148a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; requires &lt;code&gt;DECC$FILENAME_UNIX_NO_VERSION&lt;/code&gt; because the conversion routine cannot differentiate whether the last &lt;code&gt;.&lt;/code&gt; of a Unix specification is delimiting a version, or is just part of a file specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f5400ae4c62646c847435cddda21b4c40e3a93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Dump&lt;/code&gt; will not report</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Dump&lt;/code&gt; не сообщает</target>
        </trans-unit>
        <trans-unit id="14efce4f98a6d3ded52ecf9f7ef2c0c61f9e5d1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">Обратите внимание, что блоки кода &lt;code&gt;END&lt;/code&gt; &lt;b&gt;не&lt;/b&gt; выполняются в конце строки &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; : если какие-либо блоки кода &lt;code&gt;END&lt;/code&gt; созданы в строке &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; , они будут выполняться так же, как любой другой блок кода &lt;code&gt;END&lt;/code&gt; этого пакета в порядке LIFO, просто до выхода из интерпретатора.</target>
        </trans-unit>
        <trans-unit id="87d3d5579888e295497dd30ab3df3385d0ee5915" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;eval()&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;eval()&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4c9a20647174655acdade54ceb924854974320" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; and &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; set the global variables, and thus &lt;b&gt;any&lt;/b&gt; newly created number will be subject to the global rounding &lt;b&gt;immediately&lt;/b&gt;. This means that in the examples above, the &lt;code&gt;3&lt;/code&gt; as argument to &lt;code&gt;bdiv()&lt;/code&gt; will also get an accuracy of &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; и &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; установить глобальные переменные, и , таким образом , &lt;b&gt;любой&lt;/b&gt; вновь созданный номер будет зависеть от глобального округления &lt;b&gt;немедленно&lt;/b&gt; . Это означает, что в приведенных выше примерах точность &lt;code&gt;3&lt;/code&gt; as для &lt;code&gt;bdiv()&lt;/code&gt; также будет равна &lt;b&gt;5&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d2356c11b794082befde64b563384a96e7b0173c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;NULL&lt;/code&gt; является допустимым &lt;code&gt;proto&lt;/code&gt; и всегда будет возвращать &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="199f2f9c1f354b6dfdfcfb899b79a41c177c2dfa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb94a8fcace7106b0c7ce3250a66c0e461c261b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STDERR&lt;/code&gt; WILL NOT be changed, regardless.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;STDERR&lt;/code&gt; НЕ БУДЕТ изменен, в любом случае.</target>
        </trans-unit>
        <trans-unit id="3dc8a38e3cc3af9d760a1ed60a8a353aa279d10b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TAP::Parser&lt;/code&gt; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &lt;code&gt;TAP::Parser::*&lt;/code&gt; namespace.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;TAP::Parser&lt;/code&gt; разработан как центральный &amp;laquo;производитель&amp;raquo;, то есть: он отвечает за создание большинства новых объектов в пространстве имен &lt;code&gt;TAP::Parser::*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4f8d4428f9f4403397e153eb6c9a469d63599ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt; 's MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;UNIVERSAL&lt;/code&gt; (и любые члены MRO &lt;code&gt;UNIVERSAL&lt;/code&gt; ) не являются частью MRO класса, даже если все классы неявно наследуют методы &lt;code&gt;UNIVERSAL&lt;/code&gt; и его родителей.</target>
        </trans-unit>
        <trans-unit id="d2ebe68731e3dfdbe752ef6caa15931a10fc553d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt;'s MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd56e1e046b5a0f876bfdbc7dc77a2bed0822bc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, it matches the character or character sequence whose name is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40891c11dca9d7b7c3291116c4d74a2cf45b3046" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{NAME}&lt;/code&gt; , it matches the character or character sequence whose name is &lt;code&gt;NAME&lt;/code&gt; ; and similarly when of the form &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt;, it matches the character whose Unicode code point is</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N&lt;/code&gt; имеет два значения. Когда имеет форму &lt;code&gt;\N{NAME}&lt;/code&gt; , он соответствует символу или последовательности символов, имя которой - &lt;code&gt;NAME&lt;/code&gt; ; и аналогично, когда он имеет форму &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt; , он соответствует символу, чья кодовая точка Unicode -</target>
        </trans-unit>
        <trans-unit id="6fec90a9c83208c9ab833401f72e3ba22b8885c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; can mean a &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;named or numbered character &lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N{...}&lt;/code&gt; может означать &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;именованный или нумерованный символ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c272dee08a4ec0d279e74b44ce54c8507ca63ec0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt; . If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N{...}&lt;/code&gt; - время компиляции; это особая форма строковой константы, используемая внутри строк, заключенных в двойные кавычки; это означает, что вы не можете использовать переменные внутри &lt;code&gt;\N{...}&lt;/code&gt; . Если вам нужна аналогичная функциональность во время выполнения, используйте &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ceeaecdecef4fbab384a44465508a20a199dce2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt;. If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd4812fc895b96b92cb32be1e45c1db5eaf35e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt;, where the</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="591330d2defbab5242891eb86fdca8e3950ac9ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\c\&lt;/code&gt; alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; means &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; for all characters</source>
          <target state="translated">Обратите внимание, что один &lt;code&gt;\c\&lt;/code&gt; в конце регулярного выражения (или строки в двойных кавычках) недопустим. За обратной косой чертой должен следовать другой символ. То есть &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; означает &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; для всех символов</target>
        </trans-unit>
        <trans-unit id="e1ebc62194ed9270f2f0ded9d5873b50990282bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;binmode&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0564917393e190d68550cf153ec3fa749f8ef1c2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;blessed($thing)&lt;/code&gt; will also return false if &lt;code&gt;$thing&lt;/code&gt; has been blessed into a class named &quot;0&quot;. This is a possible, but quite pathological. Don't create a class named &quot;0&quot; unless you know what you're doing.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;blessed($thing)&lt;/code&gt; также вернет false, если &lt;code&gt;$thing&lt;/code&gt; был благословлен в класс с именем &quot;0&quot;. Это возможно, но довольно патологично. Не создавайте класс с именем &amp;laquo;0&amp;raquo;, если вы не знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="e26f8bbaa602bc77ce825cb115ea483aef29de1d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cx_pushblock()&lt;/code&gt; sets two new floors: for the args stack (to &lt;code&gt;MARK&lt;/code&gt;) and the temps stack (to &lt;code&gt;PL_tmps_ix&lt;/code&gt;). While executing at this scope level, every &lt;code&gt;nextstate&lt;/code&gt; (amongst others) will reset the args and tmps stack levels to these floors. Note that since &lt;code&gt;cx_pushblock&lt;/code&gt; uses the current value of &lt;code&gt;PL_tmps_ix&lt;/code&gt; rather than it being passed as an arg, this dictates at what point &lt;code&gt;cx_pushblock&lt;/code&gt; should be called. In particular, any new mortals which should be freed only on scope exit (rather than at the next &lt;code&gt;nextstate&lt;/code&gt;) should be created first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a119dbc9113a7d44b6376d76a949b8d8575c309d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt; . That name may still be used, but is now deprecated.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;gen_delimited_pat&lt;/code&gt; ранее назывался &lt;code&gt;delimited_pat&lt;/code&gt; . Это имя все еще можно использовать, но оно устарело.</target>
        </trans-unit>
        <trans-unit id="72d7884266eebfa7e1a24e791ad9ea94730bed68" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt;. That name may still be used, but is now deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a865bc718b78b08d20efdc599ac6b3675ef080" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;kill -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd7dada581d4f39d8fce5c8c1d0ecbac2ea1218" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;localtime&lt;/code&gt; and &lt;code&gt;gmtime&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0da4f2ba6d0cf36f2dd51c6be576bdda729bf43" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make_source&lt;/code&gt; &amp;amp; &lt;code&gt;make_perl_source&lt;/code&gt; have been</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;make_source&lt;/code&gt; и &lt;code&gt;make_perl_source&lt;/code&gt; были</target>
        </trans-unit>
        <trans-unit id="cb4cf0c7c42248024c78a0bb26a98cce7a24f07e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;openlog()&lt;/code&gt; теперь принимает три аргумента, как и &lt;code&gt;openlog(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="107847c03394449c5b753c11d610306353b4ed86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20aeb476985aacd52e5f965fd1bbff8fbe0c7c39" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;pad_findlex()&lt;/code&gt; is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in &lt;code&gt;xpadn_low&lt;/code&gt; the index into the parent pad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3174509a7760d68363f8a3d59612b5b0d75c608" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt; -terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;size&lt;/code&gt; - это полный размер целевого буфера, и результат гарантированно будет &lt;code&gt;NUL&lt;/code&gt; - завершен, если есть место. Обратите внимание, что место для &lt;code&gt;NUL&lt;/code&gt; должно быть включено в &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eb316f8ef59a8e93ddd67dae614660ddbd436c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt;-terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8099742523782e905e75bc531c5f7ea28d83c88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort_by&lt;/code&gt; affects all the plain hashes in the data structure. If you need finer control, &lt;code&gt;tie&lt;/code&gt; necessary hashes with a module that implements ordered hash (such as &lt;a href=&quot;Hash::Ordered&quot;&gt;Hash::Ordered&lt;/a&gt; and &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt;). &lt;code&gt;canonical&lt;/code&gt; and &lt;code&gt;sort_by&lt;/code&gt; don't affect the key order in &lt;code&gt;tie&lt;/code&gt;d hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ee97366e8a29ba82d524849876bc9dc36688aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are</source>
          <target state="translated">Обратите внимание , что &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="c694dbb84b91dadc0270b7093942a49dccfcd18d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297cb2762357bcbc37087b287127235df664073c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to &lt;code&gt;SvREADONLY&lt;/code&gt; SVs, and add more than one instance of the same &lt;code&gt;how&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a3ab354ef3e6d59f72d20cd807dd1f627a195f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to SvREADONLY SVs, and add more than one instance of the same 'how'.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;sv_magicext&lt;/code&gt; разрешит то, &lt;code&gt;sv_magic&lt;/code&gt; не может sv_magic . В частности, вы можете добавить магию в SVREADONLY SV и добавить более одного экземпляра одного и того же &amp;laquo;как&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d17fdc7c9d347932f15c81a113739f79e8f9e848" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pv&lt;/code&gt; copies the pointer while this copies the string.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;sv_setref_pv&lt;/code&gt; копирует указатель, а это - строку.</target>
        </trans-unit>
        <trans-unit id="5b6169277ca527d5391cec9228283f0ee301bda5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pvn&lt;/code&gt; copies the string while this copies the pointer.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;sv_setref_pvn&lt;/code&gt; копирует строку, а это копирует указатель.</target>
        </trans-unit>
        <trans-unit id="ca9054fd02ce103d72fc003e486b493405a56eb5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tr&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt;. The &lt;code&gt;tr&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;a href=&quot;http://man.he.net/man1/tr&quot;&gt;tr(1)&lt;/a&gt;&lt;/code&gt; utility. &lt;code&gt;tr[a-z][A-Z]&lt;/code&gt; will uppercase the 26 letters &quot;a&quot; through &quot;z&quot;, but for case changing not confined to ASCII, use &lt;a href=&quot;perlfunc#lc&quot;&gt;&lt;code&gt;lc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#uc&quot;&gt;&lt;code&gt;uc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#lcfirst&quot;&gt;&lt;code&gt;lcfirst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ucfirst&quot;&gt;&lt;code&gt;ucfirst&lt;/code&gt;&lt;/a&gt; (all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;), or the &lt;a href=&quot;#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;substitution operator &lt;code&gt;s/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;i&gt;REPLACEMENT&lt;/i&gt;/&lt;/code&gt;&lt;/a&gt; (with &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968eb220f1920402825447b300d7614d04828e7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;uc()&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;ucfirst&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40c8f91ea36b67ee3cfa45c32946c2ec3844b33" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqint&lt;/code&gt; are well-behaved as integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf172390d0d301f41e881eb119b5f9d655cba59" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqnum&lt;/code&gt; are well-behaved as numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1438af20c640a879b280a807cfcb4c4b1f563f7c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other string operations treat it; it compares equal to the empty string but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into an empty string, so that the entire list of values returned by &lt;code&gt;uniqstr&lt;/code&gt; are well-behaved as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b9e5c8595e30b3314518789be3e0f347c198b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;utf8::downgrade()&lt;/code&gt; can fail if the string contains characters that don't fit into a byte.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;utf8::downgrade()&lt;/code&gt; может завершиться ошибкой, если строка содержит символы, которые не помещаются в байт.</target>
        </trans-unit>
        <trans-unit id="244a344737b42f7a4dc0804c6a1816a678ff0765" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa060ed1a78be536ec85c38f0f18576d3c573522" translate="yes" xml:space="preserve">
          <source>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</source>
          <target state="translated">Обратите внимание,что команды =end должны совпадать с текущей открытой командой =begin.То есть,они должны правильно гнездиться.Например,это допустимо:</target>
        </trans-unit>
        <trans-unit id="eaeb65853d186efa2ac24ebd60591d6679af5af8" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%22%5Cc%25c%22-is-more-clearly-written-simply-as-%22%25s%22&quot;&gt;&quot;&quot;\c%c&quot; is more clearly written simply as &quot;%s&quot;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f1f8d502ed33af80a815e01f2ba72fc747d301" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\c%c is more clearly written simply as %s&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что символы ASCII, которые не сопоставляются с управляющими символами, не приветствуются и будут генерировать предупреждение (если включено) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\ c% c более четко записывается как% s&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f696f805b3c072e83294d03b83db4d7aa8d5f2f" translate="yes" xml:space="preserve">
          <source>Note that E&amp;lt;number&amp;gt;</source>
          <target state="translated">Обратите внимание, что E &amp;lt;число&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b2805b17d2c93e101d429684bf1e4cc0ec6e9bf" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt; . If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что GNU tar до версии 1.14 плохо справляется с &lt;code&gt;POSIX header prefix&lt;/code&gt; . Если вы используете такую ​​версию, подумайте о том, чтобы установить для переменной &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1703b14dd9d7aca1f4b440f1de3dd5da07ea976" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt;. If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41555ab0bf65d38958a3f14aeb7171b1e0133dfc" translate="yes" xml:space="preserve">
          <source>Note that GNU's gzip/gunzip is not the same as Info-ZIP's zip/unzip package. The former is a simple compression tool; the latter permits creation of multi-file archives.</source>
          <target state="translated">Обратите внимание,что пакет GNU gzip/gunzip не то же самое,что пакет Info-ZIP zip/unzip.Первый-простой инструмент сжатия;второй позволяет создавать многофайловые архивы.</target>
        </trans-unit>
        <trans-unit id="622ccc1f7f386f33bcd0fe7e88ec0737a974a63d" translate="yes" xml:space="preserve">
          <source>Note that Hash Quality Score would be 1 for an ideal hash, numbers close to and below 1 indicate good hashing, and number significantly above indicate a poor score. In practice it should be around 0.95 to 1.05. It is defined as:</source>
          <target state="translated">Обратите внимание,что оценка качества хэша была бы 1 для идеального хэша,цифры,близкие к 1 и ниже,указывают на хорошее хэширование,а цифры значительно выше-на плохую оценку.На практике она должна быть около 0,95-1,05.Определяется как:</target>
        </trans-unit>
        <trans-unit id="5fc2a35e63a8ddebfc4d138e20ffc7c6e9a57238" translate="yes" xml:space="preserve">
          <source>Note that I could not run successful smokes when initiated by the Synology Task Scheduler. I resorted to initiating the smokes via a cron job run on another system, using ssh:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b4524e41048103b895691d929d6149e5d9f22f" translate="yes" xml:space="preserve">
          <source>Note that ISO-8859-1-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0bd34cdc923419eb75f34bbc27c1a38f42a083" translate="yes" xml:space="preserve">
          <source>Note that META files are expected to be in UTF-8 encoding, only. When converted string data, it must first be decoded from UTF-8.</source>
          <target state="translated">Обратите внимание,что META-файлы должны быть только в кодировке UTF-8.При преобразовании строковых данных они должны быть сначала декодированы в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="9d701eb861ec485b89d355a1ef6df2a9826d0960" translate="yes" xml:space="preserve">
          <source>Note that MakeMaker actually emits makefiles with different syntax depending on what 'make' it thinks you are using. Therefore, it is important that one of the following values appears in Config.pm:</source>
          <target state="translated">Обратите внимание,что MakeMaker на самом деле испускает makefiles с различным синтаксисом в зависимости от того,что 'make' он думает,что вы используете.Поэтому важно,чтобы одно из следующих значений появилось в Config.pm:</target>
        </trans-unit>
        <trans-unit id="e57e92f05abaff6b44fad917e7a4948606c4c50b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</source>
          <target state="translated">Обратите внимание, что Perl может быть скомпилирован и запущен как под ASCII, так и под EBCDIC (см. &lt;a href=&quot;perlebcdic&quot;&gt;Perlebcdic&lt;/a&gt; ). Большая часть документации (и даже комментариев в коде) игнорирует возможность EBCDIC. Почти для всех целей различия прозрачны. Например, в EBCDIC вместо UTF-8 используется UTF-EBCDIC для кодирования строк Unicode, и поэтому всякий раз, когда эта документация ссылается на &lt;code&gt;utf8&lt;/code&gt; (и варианты этого имени, включая имена функций), он также (по сути прозрачно) означает &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . Но порядковые номера символов в кодировках ASCII, EBCDIC и UTF различаются, а строка, закодированная в UTF-EBCDIC, может занимать больше байтов, чем в UTF-8.</target>
        </trans-unit>
        <trans-unit id="1e8390b60c04725a0174dd4b5588a54acdd18f9b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt;. But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy a different number of bytes than in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cd527588221d4d537c9d16a7ea7760668b37e5" translate="yes" xml:space="preserve">
          <source>Note that Perl considers grapheme clusters to be separate characters, so for example</source>
          <target state="translated">Обратите внимание,что Perl считает графемные кластеры отдельными символами,так что например</target>
        </trans-unit>
        <trans-unit id="29139db0e01423398a38202c816ab0163a1e630a" translate="yes" xml:space="preserve">
          <source>Note that Perl does Full case-folding in matching, not Simple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab78c95236503996e3835788eca975544654d36" translate="yes" xml:space="preserve">
          <source>Note that Perl doesn't use COMSPEC for this purpose because COMSPEC has a high degree of variability among users, leading to portability concerns. Besides, Perl can use a shell that may not be fit for interactive use, and setting COMSPEC to such a shell may interfere with the proper functioning of other programs (which usually look in COMSPEC to find a shell fit for interactive use).</source>
          <target state="translated">Обратите внимание,что Perl не использует КОМСПЕК для этой цели,потому что КОМСПЕК имеет высокую степень вариабельности среди пользователей,что приводит к проблемам переносимости.Кроме того,Perl может использовать оболочку,которая может не подходить для интерактивного использования,и настройка COMSPEC под такую оболочку может помешать нормальной работе других программ (которые обычно ищут в COMSPEC оболочку,подходящую для интерактивного использования).</target>
        </trans-unit>
        <trans-unit id="0b9723f4ea6f4a0b6aceb296908b35e0318ba34c" translate="yes" xml:space="preserve">
          <source>Note that Perl supports passing of up to only 14 arguments to your syscall, which in practice should (usually) suffice.</source>
          <target state="translated">Обратите внимание,что Perl поддерживает передачу до 14 аргументов в ваш системный звонок,чего на практике должно (обычно)быть достаточно.</target>
        </trans-unit>
        <trans-unit id="fc038a57f3e25b6eadeaf90180f1c3439e440f0b" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">Обратите внимание, что Perl начнет искать сценарии только в том случае, если OS / 2 не может запустить указанное приложение, поэтому &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; не будет искать сценарий, если есть исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="44957b723edd6e235f882ee4085c7777338d3275" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;system 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fa96b82144dedf82260fa9f38047e79dd27888" translate="yes" xml:space="preserve">
          <source>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&amp;lt;text|name&amp;gt;&quot; (and so on for L&amp;lt;text|/&quot;sec&quot;&amp;gt;).</source>
          <target state="translated">Обратите внимание, что авторы Pod могут использовать коды форматирования внутри &amp;laquo;текстовой&amp;raquo; части &amp;laquo;L &amp;lt;text | name&amp;gt;&amp;raquo; (и так далее для L &amp;lt;text | / &amp;laquo;sec&amp;raquo;&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="e78fad76e523eb715d0d0985d903052e1c5e94f3" translate="yes" xml:space="preserve">
          <source>Note that RFC 1951 data is not a good choice of compression format to use in isolation, especially if you want to auto-detect it.</source>
          <target state="translated">Обратите внимание,что данные RFC 1951 не являются хорошим выбором формата сжатия,который можно использовать изолированно,особенно если вы хотите автоматически обнаружить их.</target>
        </trans-unit>
        <trans-unit id="9c1a2afa5425cbbe8c2645f8ed66553e6e705923" translate="yes" xml:space="preserve">
          <source>Note that SHA-1 and SHA-2 use</source>
          <target state="translated">Обратите внимание,что SHA-1 и SHA-2 используют</target>
        </trans-unit>
        <trans-unit id="5e739101966d2d75e1e2a13b96e1acfc17a54320" translate="yes" xml:space="preserve">
          <source>Note that TODO tests</source>
          <target state="translated">Обратите внимание,что тесты TODO</target>
        </trans-unit>
        <trans-unit id="40402ed7efd78d7a86f48194a3b6516e77f57a23" translate="yes" xml:space="preserve">
          <source>Note that Test::Builder ensures that any diagnostics end in a \n and it in earlier versions of Test::Tester it was essential that you have the final \n in your expected diagnostics. From version 0.10 onward, Test::Tester will add the \n if you forgot it. It will not add a \n if you are expecting no diagnostics. See below for help tracking down hard to find space and tab related problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf90b14f7079e4b164d5f4781cb0955f5b8199b" translate="yes" xml:space="preserve">
          <source>Note that Tie::File will only close any filehandles that it opened internally. If you passed it a filehandle as above, you &quot;own&quot; the filehandle, and are responsible for closing it after you have untied the @array.</source>
          <target state="translated">Обратите внимание,что Tie::File закрывает только те файловые дескрипторы,которые были открыты внутри него.Если вы передали ему файловый дескриптор,как описано выше,вы &quot;владеете&quot; этим дескриптором и отвечаете за его закрытие после того,как развяжете @массив.</target>
        </trans-unit>
        <trans-unit id="0bba5758898958160c86aa3ac20956cb9f092bfd" translate="yes" xml:space="preserve">
          <source>Note that Vietnamese is listed above. Also read &quot;Encoding vs Charset&quot; below. Also note that these are implemented in distinct modules by countries, due to the size concerns (simplified Chinese is mapped to 'CN', continental China, while traditional Chinese is mapped to 'TW', Taiwan). Please refer to their respective documentation pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6817ce7211b8227d70ebd744addb1493f99a5309" translate="yes" xml:space="preserve">
          <source>Note that [= =] and [. .] are not currently implemented; they are simply placeholders for future extensions and will cause fatal errors. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4afe4a651bf63522c9809fb7b99b7a958e429b1d" translate="yes" xml:space="preserve">
          <source>Note that a &quot;=begin</source>
          <target state="translated">Обратите внимание,что &quot;=начало</target>
        </trans-unit>
        <trans-unit id="8b724b26e18550406b5e1585fe304e6c44d42b0e" translate="yes" xml:space="preserve">
          <source>Note that a blank line must have no blanks in it. Thus &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; is one paragraph, but &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; is two.</source>
          <target state="translated">Обратите внимание, что в пустой строке не должно быть пробелов. Таким образом, &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; - это один абзац, а &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; - два.</target>
        </trans-unit>
        <trans-unit id="06686ad7be28b42e56c1b53fdf5f7299621f801d" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; can be used to effect an early exit out of such a block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6af33f5ad0150d9ac083cf6a5c7a2b96b3db24b" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will exit such a block early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98374e4e319a2a54ea762e6c2ec205f5e2e7d62" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488f211edef26ffffb5b05c7e2b69aaf3b6426c8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; может быть использован для раннего выхода из такого блока.</target>
        </trans-unit>
        <trans-unit id="ca2f98d2c44647b8c6e794a001b57317b63f04d1" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; выйдет из такого блока раньше.</target>
        </trans-unit>
        <trans-unit id="d2013e8e837998ea5b5ded0d68af26e9b66d75ac" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; внутри такого блока эффективно превратит его в конструкцию цикла.</target>
        </trans-unit>
        <trans-unit id="69d8a2b47ed12c267af9de16d301feaa50d0b140" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; может быть использован для раннего выхода из такого блока.</target>
        </trans-unit>
        <trans-unit id="b7cf9f9549146f3e33d4f74b132eb49835f491f8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; выйдет из такого блока раньше.</target>
        </trans-unit>
        <trans-unit id="0597bd4ffb228a1e2d68cc747265b06bb6260752" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">Обратите внимание, что сам по себе блок семантически идентичен циклу, который выполняется один раз. Таким образом, &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; внутри такого блока эффективно превратит его в конструкцию цикла.</target>
        </trans-unit>
        <trans-unit id="3807425ae34b529f2149724bf4de6b8be9e97ec8" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">Обратите внимание,что символ,выраженный как восьмеричный беглец,рассматривается регекс-движком как символ,не имеющий особого значения,и будет соответствовать &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="45cc111c1e3b21172f0f2335e1ae7306a7eb5e16" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">Обратите внимание,что персонаж,выраженный как один из этих выходок,считается персонажем без особого значения регекс-движком и будет соответствовать &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="093e11c1b10d3b91cf6120aba258f5fb6f25eb07" translate="yes" xml:space="preserve">
          <source>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">Обратите внимание,что символ или последовательность символов,выраженная в виде именованного или пронумерованного символа,считается символом без особого значения регекс-движком и будет соответствовать &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="1aed6736ceb1599c4759de82b494ba581fec4d4a" translate="yes" xml:space="preserve">
          <source>Note that a comment can go just about anywhere, except in the middle of an escape sequence. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8eb289741baff1763a39069ed3ea0111511da4" translate="yes" xml:space="preserve">
          <source>Note that a format begins with the letter &quot;a&quot; if and only the property it is for requires adjustments by adding the offsets in multi-element ranges. For all these properties, an entry should be adjusted only if the map is a scalar which is an integer. That is, it must match the regular expression:</source>
          <target state="translated">Обратите внимание,что формат начинается с буквы &quot;а&quot;,если и только свойство,для которого он предназначен,требует корректировки путем добавления смещений в многоэлементные диапазоны.Для всех этих свойств запись должна быть скорректирована только в том случае,если карта является скаляром,представляющим собой целое число.То есть она должна соответствовать регулярному выражению:</target>
        </trans-unit>
        <trans-unit id="1afc508afbed8c0f7ac0e4b478337da8478bd121" translate="yes" xml:space="preserve">
          <source>Note that a parser is not expected to distinguish between something that looks like pod, but is in a quoted string, such as a here document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277e9c9ef26afafa8762a7902fac38086141ef72" translate="yes" xml:space="preserve">
          <source>Note that a scalar can be made to have both string and numeric content through numeric operations:</source>
          <target state="translated">Обратите внимание,что скаляр может иметь как строковое,так и числовое содержимое с помощью числовых операций:</target>
        </trans-unit>
        <trans-unit id="7e66da593ccdd13e9412f5c3278043542df9a102" translate="yes" xml:space="preserve">
          <source>Note that a server that is also a domain controller is reported as PRODUCTTYPE 2 (Domaincontroller) and not PRODUCTTYPE 3 (Server).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba4f70f6b75455ad6abeb4c11f3ab4b74ce3ab3" translate="yes" xml:space="preserve">
          <source>Note that a shared variable guarantees that if two or more threads try to modify it at the same time, the internal state of the variable will not become corrupted. However, there are no guarantees beyond this, as explained in the next section.</source>
          <target state="translated">Обратите внимание,что общая переменная гарантирует,что если два или более потока попытаются изменить ее одновременно,внутреннее состояние переменной не будет повреждено.Тем не менее,нет никаких гарантий за пределами этого,как поясняется в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="cbf633a93711ea65ac990e0ec5a96e4eb2db906d" translate="yes" xml:space="preserve">
          <source>Note that a side-effect of the above is that &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; are no longer exported at all. This is due to the way the &lt;code&gt;Exporter&lt;/code&gt; module works. If you are migrating a codebase to use the new interface, you will have to list everything explicitly. But that's just good practice anyway.</source>
          <target state="translated">Обратите внимание, что побочным эффектом вышеизложенного является то, что &lt;code&gt;mkpath&lt;/code&gt; и &lt;code&gt;rmtree&lt;/code&gt; больше не экспортируются. Это связано с тем, как работает модуль &lt;code&gt;Exporter&lt;/code&gt; . Если вы переносите кодовую базу для использования нового интерфейса, вам придется все явно перечислить. Но в любом случае это просто хорошая практика.</target>
        </trans-unit>
        <trans-unit id="fabccca2b124b57df72b15874578f07ff3f430bb" translate="yes" xml:space="preserve">
          <source>Note that according to the POSIX 1003.1-1996 the FILENAME may have any number of trailing slashes. Some operating and filesystems do not get this right, so Perl automatically removes all trailing slashes to keep everyone happy.</source>
          <target state="translated">Обратите внимание,что в соответствии с POSIX 1003.1-1996 ФИЛЕНАМА может иметь любое количество трейлинговых слэшей.В некоторых операционных и файловых системах это неправильно,поэтому Perl автоматически удаляет все трейлинговые слэши,чтобы все были довольны.</target>
        </trans-unit>
        <trans-unit id="128d061a1fa86fd129c7cba87a1e4d16eaa8deb7" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83be315fcf65b1854e9827d37b7aa0e643910e0c" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">Обратите внимание, что все программы на C (включая интерпретатор Perl, написанный на C) всегда имеют базовый языковой стандарт. Этот языковой стандарт является языковым стандартом &quot;C&quot;, если он не изменен вызовом &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale ()&lt;/a&gt; . Когда Perl запускается, он меняет базовый языковой стандарт на тот, который указан &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ОКРУЖЕНИЕМ&lt;/a&gt; . При использовании модуля &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; или написании кода XS важно иметь в виду, что базовая локаль может быть чем-то другим, кроме &amp;laquo;C&amp;raquo;, даже если программа не изменила его явно.</target>
        </trans-unit>
        <trans-unit id="9ab24412bb95107f3eb55078583c0a90d9214b85" translate="yes" xml:space="preserve">
          <source>Note that all Perl API global variables must be referenced with the &lt;code&gt;PL_&lt;/code&gt; prefix. Again, those not listed here are not to be used by extension writers, and can be changed or removed without notice; same with macros. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</source>
          <target state="translated">Обратите внимание, что все глобальные переменные Perl API должны иметь префикс &lt;code&gt;PL_&lt;/code&gt; . Опять же, те, которые здесь не перечислены, не должны использоваться разработчиками расширений и могут быть изменены или удалены без предварительного уведомления; то же самое с макросами. Некоторые макросы предоставлены для совместимости со старыми, неприукрашенными именами, но эта поддержка может быть отключена в будущем выпуске.</target>
        </trans-unit>
        <trans-unit id="89aa7734c4b74b60a4c1310b623d823298b487c6" translate="yes" xml:space="preserve">
          <source>Note that all access is read-only. You cannot modify the internals by using this module. Also, note that the B::OP and B::SV objects created by this module are only valid for as long as the underlying objects exist; their creation doesn't increase the reference counts of the underlying objects. Trying to access the fields of a freed object will give incomprehensible results, or worse.</source>
          <target state="translated">Обратите внимание,что весь доступ предоставляется только для чтения.Вы не можете модифицировать внутреннюю часть с помощью этого модуля.Также обратите внимание,что объекты B::OP и B::SV,созданные этим модулем,действительны только до тех пор,пока существуют лежащие в основе объекты;их создание не увеличивает количество ссылок на лежащие в основе объекты.Попытка получить доступ к полям освобожденного объекта даст непонятный результат или даже хуже.</target>
        </trans-unit>
        <trans-unit id="8decf89662be3764b31363ba5ddb1483e12ddabb" translate="yes" xml:space="preserve">
          <source>Note that all non-essential underscores are removed in the display of the short names below.</source>
          <target state="translated">Обратите внимание,что все несущественные знаки подчеркивания удаляются при отображении коротких имен внизу.</target>
        </trans-unit>
        <trans-unit id="cbd6c5b0c5e74d46b9b73ec517d66ec65461aeb4" translate="yes" xml:space="preserve">
          <source>Note that all of the above are overridden within the scope of &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;; but you should be using this pragma only for debugging.</source>
          <target state="translated">Обратите внимание, что все вышеперечисленное переопределяется в пределах объема &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; ; но вы должны использовать эту прагму только для отладки.</target>
        </trans-unit>
        <trans-unit id="205ec32f1130d522301c48a5f23e3282ae5c3cdd" translate="yes" xml:space="preserve">
          <source>Note that all updates of the %result are additive, the hash will not be cleared before use, thus allowing status results of many installs to be easily aggregated.</source>
          <target state="translated">Обратите внимание,что все обновления %-результата являются аддитивами,хэш не будет очищен перед использованием,что позволяет легко агрегировать результаты состояния многих установок.</target>
        </trans-unit>
        <trans-unit id="36cc92c47c9f292a67886537ca085ec97a646fe9" translate="yes" xml:space="preserve">
          <source>Note that all we have described here in this quick overview is the simplest most straightforward use of &lt;b&gt;Pod::Parser&lt;/b&gt; to do stream-based parsing. It is also possible to use the &lt;b&gt;Pod::Parser::parse_text&lt;/b&gt; function to do more sophisticated tree-based parsing. See &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;TREE-BASED PARSING&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что все, что мы описали здесь в этом кратком обзоре, - это простейшее и понятное использование &lt;b&gt;Pod :: Parser&lt;/b&gt; для анализа на основе потоков. Также можно использовать функцию &lt;b&gt;Pod :: Parser :: parse_text&lt;/b&gt; для более сложного синтаксического анализа на основе дерева. См. &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;РАЗБОР НА ОСНОВЕ ДЕРЕВО&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31e72345bf22d6545d4882f14a8418945d8ea12a" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. But there are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt;, &lt;code&gt;Lowercase_Letter&lt;/code&gt;, and &lt;code&gt;Titlecase_Letter&lt;/code&gt;, all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt;, &lt;code&gt;Lowercase&lt;/code&gt;, and &lt;code&gt;Titlecase&lt;/code&gt;, all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt;, but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt;s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt;s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt;, both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b40f1346b332774a6bbe4756105b2451b5aa080" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt; s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; , both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что почти все свойства невосприимчивы к сопоставлению без учета регистра. То есть добавление модификатора регулярного выражения &lt;code&gt;/i&lt;/code&gt; не меняет то, что они соответствуют. Затронуты два набора. Первый набор &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; и &lt;code&gt;Titlecase_Letter&lt;/code&gt; , все из которых соответствуют &lt;code&gt;Cased_Letter&lt;/code&gt; под &lt;code&gt;/i&lt;/code&gt; соответствия. Второй набор - это &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; и &lt;code&gt;Titlecase&lt;/code&gt; , которые соответствуют &lt;code&gt;Cased&lt;/code&gt; при сопоставлении &lt;code&gt;/i&lt;/code&gt; . (Разница между этими наборами состоит в том, что некоторые элементы, например римские цифры, могут быть как в верхнем, так и в нижнем регистре, поэтому они &lt;code&gt;Cased&lt;/code&gt; , но не считаются буквами, поэтому они не являются &lt;code&gt;Cased_Letter&lt;/code&gt; s. На самом деле это &lt;code&gt;Letter_Number&lt;/code&gt; s.) Этот набор также включает подмножества &lt;code&gt;PosixUpper&lt;/code&gt; и &lt;code&gt;PosixLower&lt;/code&gt; , оба из которых под &lt;code&gt;/i&lt;/code&gt; соответствуют &lt;code&gt;PosixAlpha&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="410bccdb373a09459be0a143786fbdbb58b254bf" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be a dual-valued variable, it is actually implemented as a magical variable inside the interpreter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7c4807ae2f9f37a6e187d7bd38a50b276ee8ea" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be dual-valued variable, it is actually implemented using a tied scalar:</source>
          <target state="translated">Обратите внимание, что хотя &lt;code&gt;$!&lt;/code&gt; кажется двузначной переменной, на самом деле она реализована с использованием связанного скаляра:</target>
        </trans-unit>
        <trans-unit id="606458ff6017524382f12a8fd94125b35d1b63bc" translate="yes" xml:space="preserve">
          <source>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</source>
          <target state="translated">Обратите внимание,что &quot;=over&quot; ...&quot;=обратный&quot; регион должен иметь некоторое содержание.То есть у авторов не должно быть пустого региона,как этот:</target>
        </trans-unit>
        <trans-unit id="8f873ccce2134d828b1fb4400b87f6f3fdbeb512" translate="yes" xml:space="preserve">
          <source>Note that an INVARIANT character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="translated">Обратите внимание,что ИНВАРИАНТНЫЙ символ (т.е.ASCII на машинах,не относящихся к EBCDIC)является действительным символом UTF-8.</target>
        </trans-unit>
        <trans-unit id="587e23eccc6cff27f015e2a6ec6c9aa159cb0d1a" translate="yes" xml:space="preserve">
          <source>Note that an exit() or die() that is compiled 'hushed' because of &quot;use vmsish&quot; is not un-hushed by calling vmsish::hushed(0) at runtime.</source>
          <target state="translated">Обратите внимание,что exit()или die(),скомпилированные 'hushed' из-за &quot;use vmsish&quot;,не хэшируются вызовом vmsish::hushed(0)во время выполнения.</target>
        </trans-unit>
        <trans-unit id="81d903b0a8613702e9500c6611625b2061527ec5" translate="yes" xml:space="preserve">
          <source>Note that an implication of this form is that there are identifiers only legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, and vice-versa, for example the identifier &lt;code&gt;$&amp;eacute;tat&lt;/code&gt; is legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, but is otherwise considered to be the single character variable &lt;code&gt;$&amp;eacute;&lt;/code&gt; followed by the bareword &lt;code&gt;&quot;tat&quot;&lt;/code&gt;, the combination of which is a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51bafab03bc7a99a9ff353e9d7023e5249a4ecb" translate="yes" xml:space="preserve">
          <source>Note that any &lt;code&gt;()&lt;/code&gt; constructs enclosed within this one will still capture unless the &lt;code&gt;/n&lt;/code&gt; modifier is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d96be8f0f46d40e0807e85460543821cad6f82" translate="yes" xml:space="preserve">
          <source>Note that any filehandle being printed to under UTF-8 must be expecting UTF-8 in order to get good results and avoid Wide-character warnings. One way to do this for typical filehandles is to invoke perl with the &lt;code&gt;-C&lt;/code&gt;&amp;gt; parameter. (See &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;-C [number/list]&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2477a9523ad15c5452b9aa241b6f568c4bd6177" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this document (or in &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">Обратите внимание, что любые переменные и функции, которые не задокументированы в этом документе (или в &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; ), рассматриваются только для внутреннего использования и, как таковые, могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="a6b66f44f204ce59d376598daa611217f2bbd286" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this manpages (or in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">Обратите внимание, что любые переменные и функции, которые не задокументированы на этих страницах руководства (или в &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; ), рассматриваются только для внутреннего использования и, как таковые, могут быть изменены без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="ce41211a36e2b403696bfe4a4b1fe54c951c0f65" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt; , regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt; . Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; . Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание , что все внутри &lt;code&gt;\Q...\E&lt;/code&gt; остается не помеха &lt;code&gt;/x&lt;/code&gt; . И обратите внимание, что &lt;code&gt;/x&lt;/code&gt; не влияет на интерпретацию пробелов в одной многосимвольной конструкции. Например, в &lt;code&gt;\x{...}&lt;/code&gt; , независимо от модификатора &lt;code&gt;/x&lt;/code&gt; , не может быть пробелов. То же самое для &lt;a href=&quot;#Quantifiers&quot;&gt;квантификатора,&lt;/a&gt; такого как &lt;code&gt;{3}&lt;/code&gt; или &lt;code&gt;{5,}&lt;/code&gt; . Точно так же &lt;code&gt;(?:...)&lt;/code&gt; не может иметь пробелов между &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; И &lt;code&gt;:&lt;/code&gt; . В пределах любых разделителей для такой конструкции разрешенные пробелы не зависят от &lt;code&gt;/x&lt;/code&gt; и зависят от конструкции. Например, &lt;code&gt;\x{...}&lt;/code&gt; не может иметь пробелов, потому что в шестнадцатеричных числах нет пробелов. Но свойства Unicode могут иметь пробелы, поэтому в &lt;code&gt;\p{...}&lt;/code&gt; могут быть пробелы, соответствующие правилам Unicode, для которых см. &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Свойства, доступные через \ p {} и \ P {} в perluniprops&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f395c3581775a33605e1a803ed3454f86e6d0f9b" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt;, regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt;. Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;?&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:&quot;&lt;/code&gt;. Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fdc0e788793ca02998116be1ca2d6034cbab69c" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;../charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что начиная с Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; будет вставлять названную последовательность в строки, &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; в двойные кавычки, а charnames :: string_vianame (&amp;laquo;KATAKANA LETTER AINU P&amp;raquo;) вернет ту же строку, что и эта функция, но будет также работают с именами символов, которые не являются именованными последовательностями, без необходимости знать, какие из них есть. См. &lt;a href=&quot;../charnames&quot;&gt;Имена символов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27d84df2d91f0e561094d3cfef990178b71accb1" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e472cfdb1b217c8839b9da7d68aebc2ef451ccc9" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.20, literal control characters in variable names are deprecated; and as of Perl 5.22, any other non-graphic characters are also deprecated.</source>
          <target state="translated">Обратите внимание,что начиная с версии Perl 5.20 буквенные управляющие символы в именах переменных устаревают;а начиная с версии Perl 5.22 устаревают и любые другие неграфические символы.</target>
        </trans-unit>
        <trans-unit id="4a675b15092aa8c87c6f30bd02df31fd70694188" translate="yes" xml:space="preserve">
          <source>Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">Обратите внимание,что atan2(0,0)плохо определен.</target>
        </trans-unit>
        <trans-unit id="8fbf5b8aea29a3936ba6fef9526fd98f6b5784c6" translate="yes" xml:space="preserve">
          <source>Note that attribute handlers that are scheduled for the &lt;code&gt;BEGIN&lt;/code&gt; phase are handled as soon as the attribute is detected (i.e. before any subsequently defined &lt;code&gt;BEGIN&lt;/code&gt; blocks are executed).</source>
          <target state="translated">Обратите внимание, что обработчики атрибутов, запланированные для фазы &lt;code&gt;BEGIN&lt;/code&gt; , обрабатываются, как только атрибут обнаруживается (т. Е. До того, как будут выполнены какие-либо определенные впоследствии блоки &lt;code&gt;BEGIN&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0f24e592f4d8a1a531dda62544ac7d2f7b1bf174" translate="yes" xml:space="preserve">
          <source>Note that because &lt;b&gt;-i&lt;/b&gt; renames or deletes the original file before creating a new file of the same name, Unix-style soft and hard links will not be preserved.</source>
          <target state="translated">Обратите внимание: поскольку &lt;b&gt;-i&lt;/b&gt; переименовывает или удаляет исходный файл перед созданием нового файла с тем же именем, программные и жесткие ссылки в стиле Unix не сохраняются.</target>
        </trans-unit>
        <trans-unit id="b8849f4f72b8ea78a7d87446400823a7e27b0cb3" translate="yes" xml:space="preserve">
          <source>Note that because how the floating point formats work out, on the most common platforms signaling payload of zero is best avoided, since it might end up being identical to &lt;code&gt;+Inf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49723b78c25f9f94694a955ddf0fb169c3bb02b1" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt; , even if all its fields will be &lt;code&gt;0&lt;/code&gt; , so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">Обратите внимание: поскольку несколько расширений могут использовать &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; или &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; , важно, чтобы расширения проявляли особую осторожность, чтобы избежать конфликтов. Обычно достаточно использовать магию только для объектов, относящихся к тому же классу, что и расширение. Для магии &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; обычно хорошей идеей является определение &lt;code&gt;MGVTBL&lt;/code&gt; , даже если все его поля будут равны &lt;code&gt;0&lt;/code&gt; , чтобы отдельные указатели &lt;code&gt;MAGIC&lt;/code&gt; можно было идентифицировать как особый вид магии, используя их виртуальную волшебную таблицу. &lt;code&gt;mg_findext&lt;/code&gt; предоставляет простой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="cd112df3b0c7a62a90b0cf37e126e846a5257960" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt;, even if all its fields will be &lt;code&gt;0&lt;/code&gt;, so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2432f753e906c1dd9f81b56a7cfbeac9aa989c16" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt; , thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt; . As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">Обратите внимание, что из-за глупых ограничений OS / 2 полный путь к сценарию perl недоступен, когда вы используете &lt;code&gt;extproc&lt;/code&gt; , поэтому вы вынуждены использовать переключатель &lt;code&gt;-S&lt;/code&gt; perl, и ваш сценарий должен находиться в &lt;code&gt;PATH&lt;/code&gt; . В качестве положительного момента, если вы знаете полный путь к вашему скрипту, вы все равно можете запустить его с</target>
        </trans-unit>
        <trans-unit id="c787f61f07dfdba933460c5bff80047d250cdab7" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt;, thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt;. As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5dd4afa174c9cef5b24c559737823b7753c820" translate="yes" xml:space="preserve">
          <source>Note that because this rendering was done on a non-threaded perl, the PADOPs in the previous examples are now SVOPs, and some (but not all) of the square brackets have been replaced by round ones. This is a subtle feature to provide some visual distinction between renderings on threaded and un-threaded perls.</source>
          <target state="translated">Обратите внимание,что поскольку этот рендеринг был сделан на непоточном perl,PADOPs в предыдущих примерах теперь являются SVOPs,и некоторые (но не все)квадратные скобки были заменены на круглые.Это тонкая функция,позволяющая визуально различать рендеринг на потоковом и непоточном perl.</target>
        </trans-unit>
        <trans-unit id="e6d44ccabe09fa1f4e596936119e58147bb0fd41" translate="yes" xml:space="preserve">
          <source>Note that because we are operating on approximations of real numbers, these errors can happen when merely `too close' to the singularities listed above.</source>
          <target state="translated">Обратите внимание,что поскольку мы работаем с аппроксимациями реальных чисел,такие ошибки могут возникать,когда просто `чтобы приблизиться` к перечисленным выше сингулярностям.</target>
        </trans-unit>
        <trans-unit id="3cac802226be8e6c597ab4225af3fcdf654d037f" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in Perl are implemented directly using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in C. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) is in force then signed C integers are used, else unsigned C integers are used. Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; в Perl реализуются напрямую с использованием &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; в C. Если &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (см. &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленная арифметика&lt;/a&gt; ), то используются целые числа C со знаком, в противном случае используются целые числа C. В любом случае реализация не будет генерировать результаты, превышающие размер целочисленного типа, с которым был создан Perl (32 или 64 бита).</target>
        </trans-unit>
        <trans-unit id="04cf68d9424884dadb0aa2996784eb6ff505962d" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt; , which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">Обратите внимание, что и &lt;code&gt;hv_store&lt;/code&gt; , и &lt;code&gt;hv_store_ent&lt;/code&gt; не увеличивают счетчик ссылок сохраненного значения &lt;code&gt;val&lt;/code&gt; , за что отвечает вызывающий. Если эти функции возвращают значение NULL, вызывающей стороне обычно приходится уменьшать счетчик ссылок &lt;code&gt;val&lt;/code&gt; , чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="621c69fc1e5d56916169e38ace21016b25be56a4" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt;, which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a9256e12aa22e857528719131785d55699987c" translate="yes" xml:space="preserve">
          <source>Note that both paths are assumed to have a notation that distinguishes a directory path (with trailing ':') from a file path (without trailing ':').</source>
          <target state="translated">Обратите внимание,что предполагается,что оба пути имеют примечание,которое отличает путь каталога (с трейлингом ':')от пути файла (без трейлинга ':').</target>
        </trans-unit>
        <trans-unit id="faee99938a7847d18bb03c4600be6dd36dc0274e" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8fd56db9f2f95bb2076209ba3c59af9c411003" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the zip filename header field.</source>
          <target state="translated">Обратите внимание, что параметры &lt;code&gt;CanonicalName&lt;/code&gt; и &lt;code&gt;FilterName&lt;/code&gt; могут изменять значение, используемое для поля заголовка имени файла zip-архива.</target>
        </trans-unit>
        <trans-unit id="b4c874fe97ef7da4bd4b4b5db7330a5fe9438bed" translate="yes" xml:space="preserve">
          <source>Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour by not considering &lt;code&gt;ENOENT&lt;/code&gt; and &lt;code&gt;ENOTDIR&lt;/code&gt; as errors - bsd_glob() will continue processing despite those errors, unless the &lt;code&gt;GLOB_ERR&lt;/code&gt; flag is set.</source>
          <target state="translated">Обратите внимание, что bsd_glob () отличается от поведения POSIX и FreeBSD glob (3), не рассматривая &lt;code&gt;ENOENT&lt;/code&gt; и &lt;code&gt;ENOTDIR&lt;/code&gt; как ошибки - bsd_glob () продолжит обработку, несмотря на эти ошибки, если не &lt;code&gt;GLOB_ERR&lt;/code&gt; флаг GLOB_ERR .</target>
        </trans-unit>
        <trans-unit id="bacd6d900d14ad3f25c92e37f8d7ca4d2e6dc3f9" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;perlfunc#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; on array values is strongly discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c998cb784e028342e5006462f8a42c5345c1974" translate="yes" xml:space="preserve">
          <source>Note that calls to the platform's underlying &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function may block. If &lt;code&gt;IO::Socket::IP&lt;/code&gt; has to perform this lookup, the constructor will block even when in non-blocking mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b82a298fa226e67135978079ffa22b87e99940" translate="yes" xml:space="preserve">
          <source>Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; would not be defined even though &lt;code&gt;$+{NAME}&lt;/code&gt; would be.</source>
          <target state="translated">Обратите внимание, что группы захвата, сопоставленные внутри рекурсии, недоступны после возврата из рекурсии, поэтому необходим дополнительный уровень групп захвата. Таким образом, &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; не будет определен, хотя &lt;code&gt;$+{NAME}&lt;/code&gt; будет.</target>
        </trans-unit>
        <trans-unit id="bc76dc97a1c19045dc8a76b9a6b2095a51024d2b" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; , and &lt;code&gt;Inf**0&lt;/code&gt; . Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">Обратите внимание, что некоторые выражения возведения в степень не определены: они включают &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; и &lt;code&gt;Inf**0&lt;/code&gt; . Не ждите особых результатов от этих особых случаев, результаты зависят от платформы.</target>
        </trans-unit>
        <trans-unit id="3494a62839407764105a4d292aa5c1e195c2757d" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt;, &lt;code&gt;1**Inf&lt;/code&gt;, and &lt;code&gt;Inf**0&lt;/code&gt;. Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae568ca1008d1cccb4f94c7517bbb753d06bd905" translate="yes" xml:space="preserve">
          <source>Note that characters from 128 to 255 (inclusive) are by default internally not encoded as UTF-8 for backward compatibility reasons.</source>
          <target state="translated">Обратите внимание,что символы от 128 до 255 (включительно)по умолчанию внутренне не закодированы как UTF-8 по причинам обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="8a46ebdf91483bc350551ae23b26255499157816" translate="yes" xml:space="preserve">
          <source>Note that checking for a &lt;code&gt;%DOES&lt;/code&gt; hash is an &lt;code&gt;autodie&lt;/code&gt;-only short-cut. Other modules do not use this mechanism for checking roles, although you can use the &lt;code&gt;Class::DOES&lt;/code&gt; module from the CPAN to allow it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20fe49f9b13e959950bbe4e0a6e4e652aef94a09" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что клиенты, которые не поддерживают функцию &lt;code&gt;GNU Extended Header&lt;/code&gt; , не смогут читать эти архивы. К таким клиентам относятся tars в &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; и &lt;code&gt;AIX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aae32a0db7b8c17096153a5cf305d70abda69477" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt;, &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fce890d3f4b569eee4d4fb3d808316a6c987e62" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">Обратите внимание,что коды 6 (быстрое мигание)и 9 (забастовка)указаны в ANSI X3.64 и ECMA-048,но обычно не поддерживаются большинством дисплеев и эмуляторов и поэтому не поддерживаются данным модулем в настоящее время.ECMA-048 также указывает большое количество других атрибутов,в том числе последовательность атрибутов для изменения шрифта,символы фрактура,двойные подчёркивания,кадрирование,обводка и подчёркивание.Поскольку ни один из этих атрибутов не поддерживается и не является полезным,в настоящее время они также не поддерживаются данным модулем.</target>
        </trans-unit>
        <trans-unit id="d50e349cf31b07ee4610e705d5521fb0f229097d" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701f822191abdf1e19724503033550d3adb9a3d3" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt; , then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что преобразование произвольного скаляра в простой PV потенциально лишит его полезных данных. Например, если SV был &lt;code&gt;SvROK&lt;/code&gt; , то счетчик ссылок референта будет уменьшен, а сам SV может быть преобразован в скаляр &lt;code&gt;SvPOK&lt;/code&gt; со строковым буфером, содержащим такое значение, как &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a47c04c6a9f8c8144c760b18adcdfe977bf88a30" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt;, then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c860f546e898e4ab8af10e9688384776e80d8690" translate="yes" xml:space="preserve">
          <source>Note that connected() considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, connected() does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than undef, in either case. Thus, in general, connected() cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls shutdown() or close(); only at that point does connected() return undef.</source>
          <target state="translated">Обратите внимание, что connected () считает, что полуоткрытый TCP-сокет находится &amp;laquo;в подключенном состоянии&amp;raquo;. В частности, connected () не различает состояния TCP &lt;b&gt;ESTABLISHED&lt;/b&gt; и &lt;b&gt;CLOSE-WAIT&lt;/b&gt; ; в любом случае он возвращает адрес однорангового узла, а не undef. Таким образом, как правило, connected () не может использоваться для надежного определения, инициировал ли партнер плавное завершение работы, потому что в большинстве случаев (см. Ниже) локальный конечный автомат TCP остается в состоянии &lt;b&gt;CLOSE-WAIT,&lt;/b&gt; пока локальное приложение не вызовет shutdown () или close (); только в этот момент connected () возвращает undef.</target>
        </trans-unit>
        <trans-unit id="4c163cf186643a94245d42938672412776fa5e48" translate="yes" xml:space="preserve">
          <source>Note that currently some test scripts may fail when run in parallel (most notably</source>
          <target state="translated">Обратите внимание,что в настоящее время некоторые тестовые скрипты могут давать сбои при параллельном выполнении (особенно это касается</target>
        </trans-unit>
        <trans-unit id="fab55f641e790811b170e8b9128a927c617d8c7b" translate="yes" xml:space="preserve">
          <source>Note that define_alias() will not be able to override the canonical name of encodings. Encodings are first looked up by canonical name before potential aliases are tried.</source>
          <target state="translated">Обратите внимание,что функция define_alias()не сможет переопределить каноническое имя кодировок.Кодировки сначала просматриваются по каноническим именам,а затем пробуются потенциальные псевдонимы.</target>
        </trans-unit>
        <trans-unit id="da1de0e37193fb693b5c5e6bff7827d4423ee163" translate="yes" xml:space="preserve">
          <source>Note that despite the existence of this optag a memory resource attack may still be possible using only :base_core ops.</source>
          <target state="translated">Обратите внимание,что несмотря на существование данного оптага,атака на ресурсы памяти все равно возможна с использованием только :base_core ops.</target>
        </trans-unit>
        <trans-unit id="8256313554b42c8373b7bc367151c3b74d8cc5fc" translate="yes" xml:space="preserve">
          <source>Note that dot (</source>
          <target state="translated">Обратите внимание,что точка (</target>
        </trans-unit>
        <trans-unit id="765abb42fa3dbbf2af93a7f1e80231e5f09ac37f" translate="yes" xml:space="preserve">
          <source>Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION isn't true (the default is false), then the messages are printed on STDERR, and the processing continues after the messages are printed. This being the opposite of the standard-conforming behaviour, it is strongly recommended to set $Getopt::Std::STANDARD_HELP_VERSION to true.</source>
          <target state="translated">Обратите внимание,что из-за чрезмерной паранойи,если $Getopt::Std::STANDARD_HELP_VERSION не равен true (по умолчанию false),то сообщения распечатываются на STDERR,и обработка продолжается после распечатки сообщений.Поскольку это противоположно стандартному поведению,настоятельно рекомендуется установить значение переменной $Getopt::Std::STANDARD_HELP_VERSION равным true.</target>
        </trans-unit>
        <trans-unit id="f123bfd592be78aee28a3c608d5e5a65fa7978a4" translate="yes" xml:space="preserve">
          <source>Note that due to how &lt;code&gt;%^H&lt;/code&gt; works, some of these utilities are only useful during the compilation phase of a perl module and relies on the internals of how perl handles references in &lt;code&gt;%^H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbc11a7c1c533941b49be5f36414035e1261338" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; , retrieves the return op from it, and returns it.</source>
          <target state="translated">Обратите внимание, что каждая функция &lt;code&gt;pp_&lt;/code&gt; должна возвращать указатель на следующую операцию. Вызовы подпрограмм Perl (и блоков eval) обрабатываются в одном и том же цикле runops и не занимают лишнего места в стеке C. Например, &lt;code&gt;pp_entersub&lt;/code&gt; и &lt;code&gt;pp_entertry&lt;/code&gt; просто &lt;code&gt;CxSUB&lt;/code&gt; &lt;code&gt;CxEVAL&lt;/code&gt; блока CxSUB или CxEVAL в стек контекста, который содержит адрес операции, следующей за подвызовом или eval. Затем они возвращают первую операцию этой подпрограммы или блока eval, и поэтому выполнение этой подпрограммы или блока продолжается. Позже &lt;code&gt;pp_leavesub&lt;/code&gt; или &lt;code&gt;pp_leavetry&lt;/code&gt; извлекает &lt;code&gt;CxSUB&lt;/code&gt; или &lt;code&gt;CxEVAL&lt;/code&gt; , извлекает из нее операцию возврата и возвращает ее.</target>
        </trans-unit>
        <trans-unit id="88c1f48b446d24b42913aa2c3b31a8759cf531cc" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt;, retrieves the return op from it, and returns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420d7847072074bbd6eaf28b4c7884f7445e96dd" translate="yes" xml:space="preserve">
          <source>Note that each of these return &lt;code&gt;$self&lt;/code&gt; when you call them as &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt;. That's so that you can chain together set-attribute calls like this:</source>
          <target state="translated">Обратите внимание, что каждый из них возвращает &lt;code&gt;$self&lt;/code&gt; когда вы вызываете их как &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt; . Это так, чтобы вы могли связать вместе вызовы set-attribute следующим образом:</target>
        </trans-unit>
        <trans-unit id="51d2022d4221c4239f7b2040e5d01a22869c3e3c" translate="yes" xml:space="preserve">
          <source>Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.</source>
          <target state="translated">Обратите внимание,что несмотря на бинарную совместимость SunOS и Solaris,эти значения отличаются.Поехали.</target>
        </trans-unit>
        <trans-unit id="8c3fc5526126d228e7dc152e5bae2056ec1d2dd9" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">Обратите внимание, что неудачные операции изменения регистра, выполненные в результате нечувствительного к регистру сопоставления регулярных выражений &lt;code&gt;/i&lt;/code&gt; , будут отображаться в этом предупреждении как имеющие операцию &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (поскольку это то, что обработчик регулярных выражений вызывает за кулисами).</target>
        </trans-unit>
        <trans-unit id="50700c4c785fb49bbf6b2d46cdd32517f497bd69" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;fc&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8661f786e43fee3fd71c6daeb5a91a3c5f42f424" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt; ) or when you want to create a</source>
          <target state="translated">Обратите внимание, что сброс может серьезно ухудшить степень сжатия, поэтому его следует использовать только для завершения декомпрессии (с использованием &lt;code&gt;Z_FINISH&lt;/code&gt; ) или когда вы хотите создать</target>
        </trans-unit>
        <trans-unit id="4b30f403949fb025e96fa50a8f6344798f310af3" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt;) or when you want to create a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95fd032f7a2402cab6502921fb63c15d3283b35" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt; ), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">Обратите внимание, что для управляющих символов ( &lt;code&gt;Gc=cc&lt;/code&gt; ) файлы данных Unicode имеют строку &amp;laquo; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &amp;raquo;, но настоящее имя каждого из этих символов - пустая строка. Эта функция возвращает это настоящее имя, пустую строку. (У этих символов есть имена, но они считаются псевдонимами, а не именем свойства Name, и содержатся в свойстве &lt;code&gt;Name_Alias&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="f8932792e5f906f3f8b41da393da4b0b602a3cd6" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt;), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt;&quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc65a24a4a2d5395b160b7910a7ec94be07f4893" translate="yes" xml:space="preserve">
          <source>Note that for example the Series 60 2.0 VC SDK installation talks about ActivePerl build 518, which does no more (as of mid-2005) exist at the ActiveState website. The ActivePerl 5.8.4 build 810 was used successfully for compiling Perl on Symbian. The 5.6.x ActivePerls do not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed7cbcc3a273da5d5e361c4e690dfc2af7612b3" translate="yes" xml:space="preserve">
          <source>Note that for internal reasons, all precompiled regexps (&lt;code&gt;qr/.../&lt;/code&gt;) are blessed references; thus &lt;code&gt;ref()&lt;/code&gt; returns the package name string &lt;code&gt;&quot;Regexp&quot;&lt;/code&gt; on these but &lt;code&gt;reftype()&lt;/code&gt; will return the underlying C structure type of &lt;code&gt;&quot;REGEXP&quot;&lt;/code&gt; in all capitals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b4cbb1ed8f855f79ca32bff7fc152fc5c21ab5" translate="yes" xml:space="preserve">
          <source>Note that for larger bit-strings, it's more efficient to use the two-argument version</source>
          <target state="translated">Обратите внимание,что для больших битовых строк более эффективно использовать двухпараметрическую версию.</target>
        </trans-unit>
        <trans-unit id="a191f82c0a0eecf7bccec0288b197819c9c21ed4" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что для более простых требований к тестированию часто можно заменить приведенный выше код одним вызовом &lt;code&gt;runtests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d204c8dce6be8d36767ba5943e30dba9a432c61" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6a50ca77c83bd7639e6227860f0a0332790a2f" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity and not-a-number) the definition of &quot;numeric&quot; is somewhat unusual: the strings themselves (like &quot;Inf&quot;) are considered numeric, and anything following them is considered non-numeric.</source>
          <target state="translated">Обратите внимание, что для &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; (бесконечность и не число) определение &amp;laquo;числовой&amp;raquo; несколько необычно: сами строки (например, &amp;laquo;Inf&amp;raquo;) считаются числовыми, а все, что следует за ними, считается нечисловым.</target>
        </trans-unit>
        <trans-unit id="de25d3b42b2818ebeccffadf90f915562d81e76b" translate="yes" xml:space="preserve">
          <source>Note that formats are treated as anon subs, and are cloned each time write is called (if necessary).</source>
          <target state="translated">Обратите внимание,что форматы рассматриваются как anon subs,и клонируются каждый раз при записи вызываются (если необходимо).</target>
        </trans-unit>
        <trans-unit id="be9d64d44ec51b213716f420b24aa9198bccd3c7" translate="yes" xml:space="preserve">
          <source>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</source>
          <target state="translated">Обратите внимание,что замораживание структуры объекта и ее немедленное размораживание на самом деле приводит к глубокому клонированию этой структуры:</target>
        </trans-unit>
        <trans-unit id="692f49a79ca8c218f709da74928c335686702cff" translate="yes" xml:space="preserve">
          <source>Note that from &lt;a href=&quot;../bigint&quot;&gt;Math::BigInt&lt;/a&gt; v1.76 onwards, FastCalc will be loaded automatically, if possible.</source>
          <target state="translated">Обратите внимание, что начиная с &lt;a href=&quot;../bigint&quot;&gt;Math :: BigInt&lt;/a&gt; v1.76 и далее FastCalc будет загружаться автоматически, если это возможно.</target>
        </trans-unit>
        <trans-unit id="8d38bae54b038eb6f174267d0d214d08b91f6765" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over large DBM files. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cded70f7d04a11712cae33c05ba272338aaac47b" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over such. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a562b762d80b1c79a4a2e57ae06efed1d20b20" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими файлами DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для перебора больших файлов DBM. Пример:</target>
        </trans-unit>
        <trans-unit id="744885e641d2306d4fbe957365af5d32ac0b76f3" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими объектами, такими как файлы DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для итерации по такому. Пример:</target>
        </trans-unit>
        <trans-unit id="72ffa6aa03e0b04398c1553e4a97b08735d3745c" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими файлами DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для перебора больших файлов DBM. Пример:</target>
        </trans-unit>
        <trans-unit id="a1b483511502689b9e22b000546db0922817c2d1" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">Обратите внимание, что такие функции, как &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; могут возвращать огромные списки при использовании с большими объектами, такими как файлы DBM. Вы можете предпочесть использовать функцию &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; для итерации по такому. Пример:</target>
        </trans-unit>
        <trans-unit id="ae8752600c3751f3c52b44262525865199cca383" translate="yes" xml:space="preserve">
          <source>Note that functions such as keys() and values() may return huge lists when used on large objects, like DBM files. You may prefer to use the each() function to iterate over such. Example:</source>
          <target state="translated">Обратите внимание,что такие функции,как keys()и value()могут возвращать огромные списки при использовании на больших объектах,например,в DBM-файлах.Вы можете предпочесть использовать функцию each()для итераций,а не таких.Пример:</target>
        </trans-unit>
        <trans-unit id="d8b624d4598897ef720d34e8f550c09e63657b83" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; и т. Д. Содержат ошибки до версии glibc 2.17. Они не позволят формату &lt;code&gt;%.s&lt;/code&gt; с точностью создать строку, которая не является допустимой UTF-8, если текущая базовая локаль программы - UTF-8. Происходит то, что &lt;code&gt;%s&lt;/code&gt; и его операнд просто пропускаются без какого-либо уведомления. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b12e74f81fc8b09d013b39d154bb46d47ab07cc" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;sprintf()&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622115f32e89cdb0d30c0373c6c70d90996631c4" translate="yes" xml:space="preserve">
          <source>Note that globbing only lists directories explicitly asked for, for example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be regarded as a bug that may be changed in some future version.</source>
          <target state="translated">Обратите внимание,что globbing только списки каталогов,явно запрашиваемых,например,FOO/*,не будут списывать FOO/bar/Acme-Sthg-n.n.tar.gz.Это может быть расценено как ошибка,которая может быть изменена в некоторых будущих версиях.</target>
        </trans-unit>
        <trans-unit id="608b43e88fa71f94e1e6a28718931116afacd602" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; needs external data for it to work, no subroutine call is possible without it. As an example, the standard debugger's &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; depends on the &lt;code&gt;$DB::deep&lt;/code&gt; variable (it defines how many levels of recursion deep into the debugger you can go before a mandatory break). If &lt;code&gt;$DB::deep&lt;/code&gt; is not defined, subroutine calls are not possible, even though &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; exists.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; требуются внешние данные для работы, без них невозможно вызвать подпрограмму. Например, стандартный отладчик &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; зависит от переменной &lt;code&gt;$DB::deep&lt;/code&gt; (она определяет, сколько уровней рекурсии глубоко в отладчике вы можете пройти до обязательного перерыва). Если &lt;code&gt;$DB::deep&lt;/code&gt; не определен, вызовы подпрограмм невозможны, даже если существует &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac18f8ca65d2ef342faed7220894d625a0f93e79" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;CanonicalName&lt;/code&gt; is enabled, a normalized filename will be passed to the sub.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;CanonicalName&lt;/code&gt; включен, в подпрограмму будет передано нормализованное имя файла.</target>
        </trans-unit>
        <trans-unit id="5f3c24624d3659de7e4c912e62eae398eab95882" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt; , it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">Обратите внимание, что если шаблон, скомпилированный в &lt;code&gt;'strict'&lt;/code&gt; , перекомпилируется, например, путем интерполяции в другой шаблон, за пределами &lt;code&gt;'strict'&lt;/code&gt; , он не проверяется снова на строгость. Это потому, что если он работает под строгим контролем, он должен работать под нестрогим.</target>
        </trans-unit>
        <trans-unit id="5ee9a3d19116b2071dbcf7039492ca7c1889754a" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt;, it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308556457296cab4f486eee25acd00edabad2290" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; , it will be considered an option on itself.</source>
          <target state="translated">Обратите внимание, что если строковый аргумент начинается с &lt;code&gt;-&lt;/code&gt; или &lt;code&gt;--&lt;/code&gt; , он будет считаться опцией сам по себе.</target>
        </trans-unit>
        <trans-unit id="b48bf5ef9d46bdb5c44d53b224dcfec68d33eb04" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, it will be considered an option on itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c44aba0e7ff586bf06544855993dee92b7ebfb4" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt; , the following problem will be reported:</source>
          <target state="translated">Обратите внимание, что если в &lt;code&gt;@INC&lt;/code&gt; добавлена ​​испорченная строка, будет сообщено о следующей проблеме:</target>
        </trans-unit>
        <trans-unit id="a96ea078157000b1da678edf47d2488720c25a67" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt;, the following problem will be reported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab97fe678be0eb16cdcbc59a7f09857930450fc" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. &lt;code&gt;chdir()&lt;/code&gt; out of the directory first before calling &lt;code&gt;cleanup()&lt;/code&gt;. (For the cleanup at program exit when the CLEANUP flag is set, this happens automatically.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afccffdaaa8763c6bff65d340b0383eec4b2bf1" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. C</source>
          <target state="translated">Обратите внимание,что если временный каталог является вашим текущим каталогом,он не может быть удален.C</target>
        </trans-unit>
        <trans-unit id="e3273fcdfd70332486252bf4b49416cc8786a3a4" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">Обратите внимание: если вместо этого используется инициализированная скалярная переменная, результат будет другим: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; эквивалентен &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; запрещает такую ​​практику.</target>
        </trans-unit>
        <trans-unit id="fa54ff84091944bfa52d0352fb337bc37692f612" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;my $fh='zzz'; open($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;open( *{'zzz'}, ...)&lt;/code&gt;. &lt;code&gt;use strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd8bc012a0b5fd862eb29b81c0bd7a1843836fc" translate="yes" xml:space="preserve">
          <source>Note that if multiple files are parsed for a single POD document (perhaps the result of some future &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain initializations once per document, then you should use &lt;b&gt;begin_pod()&lt;/b&gt;.</source>
          <target state="translated">Обратите внимание, что если несколько файлов анализируются для одного документа POD (возможно, в результате какой-то директивы future &lt;code&gt;=include&lt;/code&gt; ), этот метод вызывается для каждого анализируемого файла. Если вы хотите выполнить определенные инициализации один раз для каждого документа, вам следует использовать &lt;b&gt;begin_pod ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="826d10bf58e0edead500c1a2f5a6d8c68eb347e0" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occured.</source>
          <target state="translated">Обратите внимание: если ошибок не обнаружено, &lt;code&gt;$err&lt;/code&gt; будет ссылаться на пустой массив. Это означает, что &lt;code&gt;$err&lt;/code&gt; всегда будет иметь значение ИСТИНА; поэтому вам нужно проверить &lt;code&gt;@$err&lt;/code&gt; чтобы определить, произошли ли ошибки.</target>
        </trans-unit>
        <trans-unit id="9bfefb6d862aaaa4bec0b5f0b65d69bbc80cc525" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1324e5c55e1f48c00e9179366ddca7ad4be15ea2" translate="yes" xml:space="preserve">
          <source>Note that if tests have a trailing plan, it is not possible to set this property for unplanned tests as we do not know it's unplanned until the plan is reached:</source>
          <target state="translated">Обратите внимание,что если у тестов есть трейлинговый план,невозможно установить это свойство для незапланированных тестов,так как мы не знаем,что он незапланирован до тех пор,пока план не будет достигнут:</target>
        </trans-unit>
        <trans-unit id="58bd8c74c7de485d278dd761f4ec5c815966b6fe" translate="yes" xml:space="preserve">
          <source>Note that if the cache is a tied hash, &lt;code&gt;flush_cache&lt;/code&gt; will attempt to invoke the &lt;code&gt;CLEAR&lt;/code&gt; method on the hash. If there is no &lt;code&gt;CLEAR&lt;/code&gt; method, this will cause a run-time error.</source>
          <target state="translated">Обратите внимание, что если кеш является связанным хешем, &lt;code&gt;flush_cache&lt;/code&gt; попытается вызвать метод &lt;code&gt;CLEAR&lt;/code&gt; для хеша. Если метод &lt;code&gt;CLEAR&lt;/code&gt; отсутствует , это вызовет ошибку времени выполнения.</target>
        </trans-unit>
        <trans-unit id="9c084f4d82be664fcc79d00bcef732fc1be8ca28" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если дескриптор файла был помечен как &lt;code&gt;:utf8&lt;/code&gt; , символы Unicode читаются вместо байтов (LENGTH, OFFSET и возвращаемое значение sysread () находятся в символах Unicode). Уровень &lt;code&gt;:encoding(...)&lt;/code&gt; неявно представляет уровень &lt;code&gt;:utf8&lt;/code&gt; . См. &lt;a href=&quot;#binmode&quot;&gt;Binmode&lt;/a&gt; , &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt; и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a528a8e216af2d3ed813e217add7c3fe0518eef" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если дескриптор файла был помечен как &lt;code&gt;:utf8&lt;/code&gt; , символы Unicode читаются вместо байтов (LENGTH, OFFSET и возвращаемое значение sysread () находятся в символах Unicode). Уровень &lt;code&gt;:encoding(...)&lt;/code&gt; неявно представляет уровень &lt;code&gt;:utf8&lt;/code&gt; . См. &lt;a href=&quot;binmode&quot;&gt;Binmode&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; и &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64c93021972ce0767115d7755bbd49afcf9ee53b" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;sysread&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14b0f714c8a186567b6c90a5e0bc13fd3099264" translate="yes" xml:space="preserve">
          <source>Note that if the hostname resolves to multiple address candidates, the same timeout will apply to each connection attempt individually, rather than to the operation as a whole. Further note that the timeout does not apply to the initial hostname resolve operation, if connecting by hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0908e03d8ce40c7005e83d17332e47cd6f9ef387" translate="yes" xml:space="preserve">
          <source>Note that if the input text is a read-only string (i.e. a literal), no attempt is made to remove the extracted text.</source>
          <target state="translated">Обратите внимание,что если вводимый текст является строкой,доступной только для чтения (т.е.литералом),попытка удалить извлеченный текст не предпринимается.</target>
        </trans-unit>
        <trans-unit id="34c9b253a358e643fbf719eebaacbe9ee361bc74" translate="yes" xml:space="preserve">
          <source>Note that if the platform doesn't have &lt;code&gt;LC_NUMERIC&lt;/code&gt; and/or &lt;code&gt;LC_MONETARY&lt;/code&gt; available or enabled, the corresponding elements of the hash will be missing.</source>
          <target state="translated">Обратите внимание, что если платформа не имеет доступных или включенных &lt;code&gt;LC_NUMERIC&lt;/code&gt; и / или &lt;code&gt;LC_MONETARY&lt;/code&gt; , соответствующие элементы хэша будут отсутствовать.</target>
        </trans-unit>
        <trans-unit id="c9c7ab75927f08e77cc4898e73b8aeda27cc0c9a" translate="yes" xml:space="preserve">
          <source>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</source>
          <target state="translated">Обратите внимание,что если регулярное выражение является запятнанным,то Perl умрет,вместо того,чтобы вызывать подпрограмму,когда имя подпрограммы будет определено по запятнанным данным.</target>
        </trans-unit>
        <trans-unit id="fe055d833210baa880117658e3debc03ef9f92ae" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5d364aee605b39052a767be97bf595da7e180a" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2dc5e51258adfa883882440e13a3cae6f294a4" translate="yes" xml:space="preserve">
          <source>Note that if the version of the PM module is an NV (a floating point number), it will be stringified with a possible loss of precision (currently chopping to nine decimal places) so that it may not match the version of the XS module anymore. Quoting the $VERSION declaration to make it a string is recommended if long version numbers are used.</source>
          <target state="translated">Обратите внимание,что если версия модуля PM является NV (число с плавающей точкой),то она будет строиться с возможной потерей точности (в настоящее время измельчение до девяти знаков после запятой),так что она может больше не совпадать с версией модуля XS.При использовании длинных номеров версий рекомендуется цитировать декларацию $VERSION,чтобы сделать ее строкой.</target>
        </trans-unit>
        <trans-unit id="6c6048c09fbd601d5bded4c49f7b53cc961721c5" translate="yes" xml:space="preserve">
          <source>Note that if there was a subroutine call between us and line 29, and we wanted to &lt;b&gt;single-step&lt;/b&gt; through it, we could use the '&lt;b&gt;s&lt;/b&gt;' command, and to step over it we would use '&lt;b&gt;n&lt;/b&gt;' which would execute the sub, but not descend into it for inspection. In this case though, we simply continue down to line 29:</source>
          <target state="translated">Обратите внимание, что если бы между нами и строкой 29 был вызов подпрограммы, и мы хотели бы &lt;b&gt;пройти&lt;/b&gt; через нее &lt;b&gt;пошагово&lt;/b&gt; , мы могли бы использовать команду ' &lt;b&gt;s&lt;/b&gt; ', а для перехода через нее мы использовали бы ' &lt;b&gt;n&lt;/b&gt; ', которая будет выполнять подпрограмму, но не спускаться в нее для осмотра. В этом случае мы просто продолжаем до строки 29:</target>
        </trans-unit>
        <trans-unit id="59c2ff6ec5006b141610e96d370fba70e324be70" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;next EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;next LABEL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3dd1e37239e5e6990e5357970b72eac4a59098" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что если бы на указанном выше был блок &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , он выполнялся бы даже на отброшенных строках. Если LABEL опущен, команда обращается к самому внутреннему охватывающему циклу. &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; форма доступна как в Perl 5.18.0, позволяет имя метки быть вычислена во время выполнения, будучи в противном случае идентичен &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ee3cf42536d2e0cc61b8039c6f1a0a75072a6a" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; one-time matches:</source>
          <target state="translated">Обратите внимание, что если бы в приведенном выше коде был блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , он бы выполнялся только на строках, отброшенных регулярным выражением (поскольку при повторном выполнении блок продолжения пропускается). Блок продолжения часто используется для сброса счетчиков строк или &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; разовые матчи:</target>
        </trans-unit>
        <trans-unit id="03cca16cecaf26d400e510c53bbfbaac8d0326bf" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что если бы на указанном выше был блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , он выполнялся бы даже на отброшенных строках. Если LABEL опущен, команда обращается к самому внутреннему охватывающему циклу. &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; форма доступна как в Perl 5.18.0, позволяет имя метки быть вычислена во время выполнения, будучи в противном случае идентичен &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d89a8bc172fcf3b8db606f977ce516e0ca56f06e" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;continue&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;m?pat?&lt;/code&gt; one-time matches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c5d18d3d9efa0c0b12037ddf03239e4ec1d14" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">Обратите внимание, что если этот модуль импортируется, когда &lt;a href=&quot;../threads&quot;&gt;потоки&lt;/a&gt; еще не загружены, все эти функции перестают работать. Это позволяет писать модули, которые будут работать как в поточной, так и в непоточной среде.</target>
        </trans-unit>
        <trans-unit id="5fb1ed53a6e66a00d38de3c7beb368af62d0f805" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67c2908702a6cdf59ca28b987d8e4a389fc1fa9" translate="yes" xml:space="preserve">
          <source>Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &lt;code&gt;(*PRUNE)&lt;/code&gt; operator.</source>
          <target state="translated">Обратите внимание, что если этот оператор используется, а НЕ внутри чередования, он действует точно так же, как оператор &lt;code&gt;(*PRUNE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc2bfbf6748eacea8c87035966d754d0f68c5a3" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; , and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">Обратите внимание, что при использовании gcc, начиная с Perl 5.9.5, файлы исходного кода ядра Perl (те, которые находятся на верхнем уровне распределения исходного кода, но не, например, расширения в ext /) автоматически компилируются с максимально возможным количеством файлов &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; и набор флагов &lt;code&gt;-W&lt;/code&gt; (см. cflags.SH).</target>
        </trans-unit>
        <trans-unit id="ae719f393d44a0bc8f5885617f97e53f1b2edd48" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt;, &lt;code&gt;-ansi&lt;/code&gt;, &lt;code&gt;-pedantic&lt;/code&gt;, and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe5b081a33f6efff2f505814c3590456b24ec50" translate="yes" xml:space="preserve">
          <source>Note that if you do not have Module::Signature installed, no signature checks will be performed at all.</source>
          <target state="translated">Обратите внимание,что если у вас не установлен модуль Module::Signature,проверка подписи не будет производиться вообще.</target>
        </trans-unit>
        <trans-unit id="7890360c193f0760d43a2add9be2d600e6cb6a32" translate="yes" xml:space="preserve">
          <source>Note that if you do not plan to build the perl itself, it may be possible to fool EMX to truncate file names. This is not supported, read EMX docs to see how to do it.</source>
          <target state="translated">Обратите внимание,что если вы не планируете собирать сам perl,то можно обмануть EMX,чтобы усечь имена файлов.Это не поддерживается,прочитайте EMX-документы,чтобы узнать,как это сделать.</target>
        </trans-unit>
        <trans-unit id="7074505ed79917df5e0904da32c456ed53b1b35d" translate="yes" xml:space="preserve">
          <source>Note that if you have</source>
          <target state="translated">Обратите внимание,что если у вас есть</target>
        </trans-unit>
        <trans-unit id="16452a0ac87813870c05c7095ba75ee11a8d9c6d" translate="yes" xml:space="preserve">
          <source>Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; will be unhappy since the bytes are most probably not well-formed UTF-X. If you want to have such bytes under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что если у вас есть байты с восьмым битом в вашем скрипте (например, встроенный Latin-1 в ваши строковые литералы), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; будет неудовлетворительным, поскольку байты, скорее всего, не являются правильно сформированным UTF-X. Если вы хотите, чтобы такие байты &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , вы можете отключить эту директиву до конца блока (или файла, если он находится на верхнем уровне) с помощью &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c4aa42b29cc2c2cbee7d6400738523e5bb46393" translate="yes" xml:space="preserve">
          <source>Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from File::Path::rmtree().</source>
          <target state="translated">Обратите внимание,что если у вас есть chdir'ed во временном каталоге и он впоследствии очищается (либо в блоке END,либо как часть уничтожения объектов),то вы получите предупреждение от File::Path::rmtree().</target>
        </trans-unit>
        <trans-unit id="b2acb4728d0e1f7a70ad075cf5c70995a564c7a8" translate="yes" xml:space="preserve">
          <source>Note that if you have non-ASCII, non-UTF-8 bytes in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;use utf8&lt;/code&gt; will be unhappy. If you want to have such bytes under &lt;code&gt;use utf8&lt;/code&gt;, you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;no utf8;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f635910faf20c1937408464313d28376fda868a1" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">Обратите внимание: если вам нужно искать строки, которые вы не знаете до выполнения, вы можете построить весь цикл как строку и &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы избежать постоянной перекомпиляции всех ваших шаблонов. Вместе с неопределением &lt;code&gt;$/&lt;/code&gt; для ввода целых файлов как одной записи это может быть довольно быстро, часто быстрее, чем специализированные программы, такие как fgrep (1). Следующее сканирует список файлов ( &lt;code&gt;@files&lt;/code&gt; ) на предмет списка слов ( &lt;code&gt;@words&lt;/code&gt; ) и распечатывает имена тех файлов, которые содержат совпадения:</target>
        </trans-unit>
        <trans-unit id="563eabb7ceca135c66cd9da9fa7638ecd48fe576" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">Обратите внимание: если вам нужно искать строки, которые вы не знаете до выполнения, вы можете построить весь цикл как строку и &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , чтобы избежать постоянной перекомпиляции всех ваших шаблонов. Вместе с неопределением &lt;code&gt;$/&lt;/code&gt; для ввода целых файлов как одной записи это может быть довольно быстро, часто быстрее, чем специализированные программы, такие как fgrep (1). Следующее сканирует список файлов ( &lt;code&gt;@files&lt;/code&gt; ) на предмет списка слов ( &lt;code&gt;@words&lt;/code&gt; ) и распечатывает имена тех файлов, которые содержат совпадения:</target>
        </trans-unit>
        <trans-unit id="472f29cb35dcdd9e0bdaee6718ec77f646cf840a" translate="yes" xml:space="preserve">
          <source>Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.</source>
          <target state="translated">Обратите внимание,что если вы берете копию скаляра с ослабленной ссылкой,то копия будет сильной ссылкой.</target>
        </trans-unit>
        <trans-unit id="0e444f4b856d65b2f09fb19cd71f6f782807ee73" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;Pod::Simple::HTMLBatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a0c1fef1effc8f82cf7edc96e6b440867de0be" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что если вы хотите выполнить пакетное преобразование большого количества документов Pod в HTML, вы должны увидеть модуль &lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bef8dc28c2922471f2bbf667ac531cc355fd0094" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), you must have loaded this module first.</source>
          <target state="translated">Обратите внимание, что если вы хотите включить категорию предупреждений, зарегистрированную модулем (например, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), вы должны сначала загрузить этот модуль.</target>
        </trans-unit>
        <trans-unit id="5e4f1270136e80fe4169f2c75c88690d42981098" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;use warnings 'File::Find'&lt;/code&gt;), you must have loaded this module first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5645d5d10ea8883aafab68e6dc7420fa5396f224" translate="yes" xml:space="preserve">
          <source>Note that if you want to pass on any elements of the C-local environ array to a subprocess which isn't started by fork/exec, or isn't running a C program, you can &quot;promote&quot; them to logical names in the current process, which will then be inherited by all subprocesses, by saying</source>
          <target state="translated">Обратите внимание,что если вы хотите передать какие-либо элементы массива среды C-local подпроцессу,который не запущен fork/exec,или не запущен программой на C,то вы можете &quot;продвинуть&quot; их в текущем процессе по логическим именам,которые затем будут унаследованы всеми подпроцессами,говоря</target>
        </trans-unit>
        <trans-unit id="438e992f414c0fb7d0ae67132225f8fb511bf800" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">Обратите внимание: если вы используете Windows, решение этой неприятной проблемы невозможно. Несмотря на то, что Perl эмулирует &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; , вы все равно застрянете, потому что в Windows нет API в стиле argc / argv.</target>
        </trans-unit>
        <trans-unit id="1aa1a6be319ce084016212a914b567d8abc1a457" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;fork()&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631593fdac38ac18af70717272a4671c53190f39" translate="yes" xml:space="preserve">
          <source>Note that if your forked child inherits system file descriptors like STDIN and STDOUT that are actually connected by a pipe or socket, even if you exit, then the remote server (such as, say, a CGI script or a backgrounded job launched from a remote shell) won't think you're done. You should reopen those to</source>
          <target state="translated">Обратите внимание,что если ваш дочерний процесс наследует системные файловые дескрипторы,такие как STDIN и STDOUT,которые на самом деле подключены через трубу или сокет,даже если вы выйдете,то удаленный сервер (например,CGI скрипт или фоновая работа,запущенная из удаленной оболочки)не подумает,что вы закончили.Вы должны открыть их заново,чтобы</target>
        </trans-unit>
        <trans-unit id="70eb4fc52446e8c7cd71ef0fc3bcc0bd68008c67" translate="yes" xml:space="preserve">
          <source>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</source>
          <target state="translated">Обратите внимание,что в Perl 5.17.3 и более ранних версиях для каретных вариантов переменных также использовались три последние константы.</target>
        </trans-unit>
        <trans-unit id="8b6ec9401ff25a7e7f20f8f508c8e573ab6cef28" translate="yes" xml:space="preserve">
          <source>Note that in Perl version prior to 5.18 inheritance of the &lt;code&gt;fallback&lt;/code&gt; key was not governed by the above rules. The value of &lt;code&gt;fallback&lt;/code&gt; in the first overloaded ancestor was used. This was fixed in 5.18 to follow the usual rules of inheritance.</source>
          <target state="translated">Обратите внимание, что в версии Perl до 5.18 наследование &lt;code&gt;fallback&lt;/code&gt; ключа не регулировалось приведенными выше правилами. Было использовано значение &lt;code&gt;fallback&lt;/code&gt; в первом перегруженном предке. Это было исправлено в 5.18, чтобы соответствовать обычным правилам наследования.</target>
        </trans-unit>
        <trans-unit id="7dadc679f5466d79da0156797f6b8d65ca1758f1" translate="yes" xml:space="preserve">
          <source>Note that in a few cases this translation can't be perfectly carried back into the source code -- if the loop's initializer declares a my variable, for instance, it won't have the correct scope outside of the loop.</source>
          <target state="translated">Обратите внимание,что в некоторых случаях эта трансляция не может быть идеально перенесена обратно в исходный код --если инициализатор цикла объявит,например,мою переменную,то она не будет иметь корректной области видимости за пределами цикла.</target>
        </trans-unit>
        <trans-unit id="5bedfdd7af45ab7b673c4a8860ff4cc65683c959" translate="yes" xml:space="preserve">
          <source>Note that in a list context, the contents of the original input text (the first argument) are not modified in any way.</source>
          <target state="translated">Обратите внимание,что в контексте списка содержимое исходного входного текста (первый аргумент)никак не изменяется.</target>
        </trans-unit>
        <trans-unit id="19da40726b3583f6544a1c2e542496723da7a424" translate="yes" xml:space="preserve">
          <source>Note that in all cases of &quot;E&amp;lt;whatever&amp;gt;&quot;,</source>
          <target state="translated">Обратите внимание, что во всех случаях &amp;laquo;E &amp;lt;whatever&amp;gt;&amp;raquo;,</target>
        </trans-unit>
        <trans-unit id="6ce30555742bc236d7228f5681b0d8b9d5625260" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;&quot;EXAMPLE 1&quot;&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;&quot;EXAMPLE 2&quot;&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;&quot;EXAMPLE 3&quot;&lt;/a&gt;, this description does not contain the actual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e72d3882d1c9bd4efe9fc3533a3f5c9da90ccbc" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;a href=&quot;#EXAMPLE-1&quot;&gt;ПРИМЕРА 1&lt;/a&gt; , &lt;a href=&quot;#EXAMPLE-2&quot;&gt;ПРИМЕРА 2&lt;/a&gt; и &lt;a href=&quot;#EXAMPLE-3&quot;&gt;ПРИМЕРА 3&lt;/a&gt; , это описание не содержит фактических</target>
        </trans-unit>
        <trans-unit id="cc47544345a2ab281008488b23e05567f0a20d81" translate="yes" xml:space="preserve">
          <source>Note that in older versions of this module, the &lt;code&gt;error()&lt;/code&gt; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &lt;code&gt;Archive::Tar&lt;/code&gt; now have separate error strings.</source>
          <target state="translated">Обратите внимание, что в более старых версиях этого модуля метод &lt;code&gt;error()&lt;/code&gt; возвращал эффективное глобальное значение даже при вызове метода экземпляра, как указано выше. С тех пор это было исправлено, и несколько экземпляров &lt;code&gt;Archive::Tar&lt;/code&gt; теперь имеют отдельные строки ошибок.</target>
        </trans-unit>
        <trans-unit id="d8bd3a3217fec8f830ea11bdf3eeaefb81cab80f" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt; , a warning is issued if the argument has to be reset).</source>
          <target state="translated">Обратите внимание, что в контексте scalar и void значение этого аргумента автоматически сбрасывается до 1 (при &lt;code&gt;-w&lt;/code&gt; выдается предупреждение, если аргумент должен быть сброшен).</target>
        </trans-unit>
        <trans-unit id="b672aba9889e3334f6f71797b988ee0e00c12f3a" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt;, a warning is issued if the argument has to be reset).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41929543f660fb86d6970d86dc2f5cfae1674011" translate="yes" xml:space="preserve">
          <source>Note that in the above cases, &lt;code&gt;thing($foo)&lt;/code&gt; and &lt;code&gt;thing($bar)&lt;/code&gt;</source>
          <target state="translated">Обратите внимание, что в приведенных выше случаях &lt;code&gt;thing($foo)&lt;/code&gt; и &lt;code&gt;thing($bar)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="312240e44caf4f031c0d90c515deeb5d10139037" translate="yes" xml:space="preserve">
          <source>Note that in the above example, tests in the first subdirectory will not be run. To run all tests in the intermediary subdirectory preceding the one the test files are in, you need to explicitly note it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e34b6badd14d9162b8051b5a13e0d935b53fb3b" translate="yes" xml:space="preserve">
          <source>Note that install() gives no meaningful return value. See uptodate().</source>
          <target state="translated">Обратите внимание,что функция install()не дает никакого осмысленного возвращаемого значения.См.uptodate().</target>
        </trans-unit>
        <trans-unit id="275e7ac15e1f8f9535995287531c3b4b0bc12858" translate="yes" xml:space="preserve">
          <source>Note that it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8451b3868737fe3b564168fce4efa0bb98f6a4" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt; ) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">Обратите внимание, что попытка повторной отправки любого метода с другим именем является фатальной ошибкой для любого метода (включая &lt;code&gt;AUTOLOAD&lt;/code&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="4c47d269e31ad3d486ed4d3aa4e0693a8502eee1" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt;) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d339e0f582d233719162f7a04439bf08b5fc04" translate="yes" xml:space="preserve">
          <source>Note that it is generally not a good idea to try to build a perl with INST_DRV and INST_TOP set to a path that already exists from a previous build. In particular, this may cause problems with the lib/ExtUtils/t/Embed.t test, which attempts to build a test program and may end up building against the installed perl's lib/CORE directory rather than the one being tested.</source>
          <target state="translated">Обратите внимание,что обычно не стоит пытаться собрать perl с набором INST_DRV и INST_TOP по пути,который уже существует из предыдущей сборки.В частности,это может вызвать проблемы с тестом lib/ExtUtils/t/Embed.t,который пытается собрать тестовую программу и может закончиться сборкой не из тестируемого,а из установленного каталога perl lib/CORE.</target>
        </trans-unit>
        <trans-unit id="d81b2599960bdecb9620115e70e867f7359ae0c4" translate="yes" xml:space="preserve">
          <source>Note that it is illegal to have code points that are larger than what can fit in an IV on the current machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399a43994f597fec22280e4ffa2bc677a89fdfb6" translate="yes" xml:space="preserve">
          <source>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</source>
          <target state="translated">Обратите внимание,что важно процитировать идентификатор __CALLER__::Roo,так как ошибка в perl 5.8 откажет в его разборе и приведет к неизвестной ошибке.</target>
        </trans-unit>
        <trans-unit id="7affed7382c3656cc0a49bfbc4f14899cf69001a" translate="yes" xml:space="preserve">
          <source>Note that it is not advisable to access a file handle within a signal handler where that signal has interrupted an I/O operation on that same handle. While perl will at least try hard not to crash, there are no guarantees of data integrity; for example, some data might get dropped or written twice.</source>
          <target state="translated">Обратите внимание,что не рекомендуется обращаться к файловому дескриптору внутри обработчика сигналов,если этот сигнал прервал операцию ввода/вывода на том же дескрипторе.Хотя perl будет,по крайней мере,стараться не допустить сбоя,гарантии целостности данных отсутствуют;например,некоторые данные могут быть сброшены или записаны дважды.</target>
        </trans-unit>
        <trans-unit id="6d3396c1176b4f12172442de7b35ea46ac2562aa" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to call &lt;code&gt;PUSHMARK&lt;/code&gt; in this instance. This is because</source>
          <target state="translated">Обратите внимание, что в этом случае нет необходимости вызывать &lt;code&gt;PUSHMARK&lt;/code&gt; . Это потому что</target>
        </trans-unit>
        <trans-unit id="2b288b308a1bd032de8fa4a9b9c0a2a922d5b4a8" translate="yes" xml:space="preserve">
          <source>Note that it is okay to create a library which contains a dependent library that is already linked into perl.</source>
          <target state="translated">Обратите внимание,что можно создать библиотеку,содержащую зависимую библиотеку,которая уже скомпонована с perl.</target>
        </trans-unit>
        <trans-unit id="a2ad638116e9353f8a4dbaec6ebfef4f8d3c123f" translate="yes" xml:space="preserve">
          <source>Note that it is possible that the actions of a destructor called directly or indirectly by freeing an element of the array could cause the reference count of the array itself to be reduced (e.g. by deleting an entry in the symbol table). So it is a possibility that the AV could have been freed (or even reallocated) on return from the call unless you hold a reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020e05231aab23e5af6e78f2d08d9849390e5ac0" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt; , but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt; ', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">Обратите внимание, что возможно иметь токены &lt;code&gt;__DATA__&lt;/code&gt; в одном пакете в нескольких файлах, и что последний токен &lt;code&gt;__DATA__&lt;/code&gt; в данном пакете, с которым сталкивается компилятор, является токеном, доступным для дескриптора файла. Это также применимо к &lt;code&gt;__END__&lt;/code&gt; и main, то есть если у &amp;laquo;основной&amp;raquo; программы есть &lt;code&gt;__END__&lt;/code&gt; , но у модуля, 'require'd (_not_' use'd) этой программой, есть 'package main;' объявление, за которым следует ' &lt;code&gt;__DATA__&lt;/code&gt; ', то дескриптор файла &lt;code&gt;DATA&lt;/code&gt; устанавливается для доступа к данным после &lt;code&gt;__DATA__&lt;/code&gt; в модуле, _не_ данных после токена &lt;code&gt;__END__&lt;/code&gt; в 'основной' программе, поскольку компилятор обнаруживает 'require'd файл позже.</target>
        </trans-unit>
        <trans-unit id="7c22ec5e674939ca7dd16521f1a2590b4ddee243" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt;, but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt;', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02a747b9a7a24aeffcddaceb1b0a554d3946c9f" translate="yes" xml:space="preserve">
          <source>Note that it is possible to write portable code for these by specifying things in Unicode numbers, and using a conversion function:</source>
          <target state="translated">Обратите внимание,что для этого можно написать переносимый код,указав вещи в числах Юникода и используя функцию преобразования:</target>
        </trans-unit>
        <trans-unit id="597951c8ec638d515f08de4fa8f2ce8a96e0a9a0" translate="yes" xml:space="preserve">
          <source>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</source>
          <target state="translated">Обратите внимание,что,вероятно,бессмысленно вызывать функции overload::constant()и overload::remove_constant()из любого места,кроме методов import()и unimport().Из этих методов они могут вызываться как</target>
        </trans-unit>
        <trans-unit id="b593f41651d7a872851c870e53e6652c0659531a" translate="yes" xml:space="preserve">
          <source>Note that it isn't a good idea to specify these types of ranges anyway.</source>
          <target state="translated">Обратите внимание,что в любом случае не стоит указывать эти типы диапазонов.</target>
        </trans-unit>
        <trans-unit id="5dd80f85677999c53d6b25deeca079eeb865515a" translate="yes" xml:space="preserve">
          <source>Note that it only confirms the bare minimum structure (so as not to get confused by derived classes which may contain additional hash entries):</source>
          <target state="translated">Обратите внимание,что это только подтверждает минимальную &quot;голую&quot; структуру (чтобы не запутаться в производных классах,которые могут содержать дополнительные записи хэша):</target>
        </trans-unit>
        <trans-unit id="e50d411d2523ee4ff5b0357ec19f1bfed82fa0ca" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly acceptable for some lines to have test numbers and others to not have them. However, when a test number is found, it must be in sequence. The following is also an error:</source>
          <target state="translated">Обратите внимание,что для одних строк вполне допустимо наличие номеров тестов,а для других-их отсутствие.Однако,когда тестовый номер найден,он должен быть последовательным.Следующее также является ошибкой:</target>
        </trans-unit>
        <trans-unit id="9a913045922e1a369e32f6e9094b0a8adfbe43e8" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt; ?) and &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что Perl можно запутать, заставив думать, что &lt;code&gt;//&lt;/code&gt; (пустое регулярное выражение) действительно &lt;code&gt;//&lt;/code&gt; (оператор определенного или). Perl обычно неплохо справляется с этим, но некоторые патологические случаи могут вызвать это, например, &lt;code&gt;$x///&lt;/code&gt; (это &lt;code&gt;($x) / (//)&lt;/code&gt; или &lt;code&gt;$x // /&lt;/code&gt; ?) И &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; ( &lt;code&gt;print $fh(//&lt;/code&gt; или &lt;code&gt;print($fh //&lt;/code&gt; ?). Во всех этих примерах Perl будет предполагать, что вы имели в виду определенное-или. Если вы имели в виду пустое регулярное выражение, просто используйте круглые скобки или пробелы для устранения неоднозначности или даже префикс пустое регулярное выражение с &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (поэтому &lt;code&gt;//&lt;/code&gt; становится &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a12f25b19f578d4ada5cb29c677b041e1603c474" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt;?) and &lt;code&gt;print $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;m&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;m//&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830a684c09bf9bdd212ea3a74c23e24fe820c679" translate="yes" xml:space="preserve">
          <source>Note that just as in C, Perl doesn't define &lt;b&gt;when&lt;/b&gt; the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:</source>
          <target state="translated">Обратите внимание, что, как и в C, Perl не определяет, &lt;b&gt;когда&lt;/b&gt; переменная увеличивается или уменьшается. Вы просто знаете, что это будет сделано где-то до или после возврата значения. Это также означает, что изменение переменной дважды в одном операторе приведет к неопределенному поведению. Избегайте таких заявлений, как:</target>
        </trans-unit>
        <trans-unit id="a43f2c8c90c96b6a2393740d3a2acc243f34fc78" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">Обратите внимание: то, что хеш инициализируется в таком порядке, не означает, что он появляется в этом порядке. См. В разделе &lt;a href=&quot;functions/sort&quot;&gt;Сортировка&lt;/a&gt; примеры того, как организовать порядок вывода.</target>
        </trans-unit>
        <trans-unit id="7f5a81a69fc5b10cd51900312887345ba64586f5" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24181c497b3bc3da696d72d56d3b63ee4e8b425" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt; , only local().</source>
          <target state="translated">Обратите внимание, что, как и все переменные пунктуации, в настоящее время вы не можете использовать my () для &lt;code&gt;$^W&lt;/code&gt; , только local ().</target>
        </trans-unit>
        <trans-unit id="3fe7b7d8a3cbe9873ed0d90c76831403a33df538" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt;, only local().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065e7735efe282ba9a9b62697058bf416b3fcc20" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">Обратите внимание, что макросы &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; и &lt;code&gt;XSRETURN*()&lt;/code&gt; одинаково хорошо работают в разделах CODE: и PPCODE :.</target>
        </trans-unit>
        <trans-unit id="590d78c14b1f30644ceca6febcb1f178361e32a4" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt;, &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14a124574e395835da21cb4f1ebabcb93935e43" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что большинство символов Unicode не имеют разложения, поэтому их тип разложения - &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c45d58bad9499717ca648bdb916a02ec0cb0a26" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de00dbea9481bda931fa7e30e09096749bd42bf3" translate="yes" xml:space="preserve">
          <source>Note that multiple &quot;front-ends&quot; can latch into this debugging API simultaneously. This is intended to facilitate things like debugging with a command line and GUI at the same time, debugging debuggers etc. [Sounds nice, but this needs some serious support -- GSAR]</source>
          <target state="translated">Обратите внимание,что несколько &quot;фронт-ендов&quot; могут одновременно подключаться к этому отладочному API.Это призвано облегчить такие вещи,как отладка с помощью командной строки и графического интерфейса одновременно,отладка отладчиков и т.д.[Звучит неплохо,но это требует серьезной поддержки --GSAR].</target>
        </trans-unit>
        <trans-unit id="e6f8eb704c4d9544e078aafe993c9c4db8549a7e" translate="yes" xml:space="preserve">
          <source>Note that neither the &lt;b&gt;-w&lt;/b&gt; flag or the &lt;code&gt;$^W&lt;/code&gt; can be used to disable/enable default warnings. They are still mandatory in this case.</source>
          <target state="translated">Обратите внимание, что ни флаг &lt;b&gt;-w,&lt;/b&gt; ни &lt;code&gt;$^W&lt;/code&gt; нельзя использовать для отключения / включения предупреждений по умолчанию. В этом случае они по-прежнему обязательны.</target>
        </trans-unit>
        <trans-unit id="1452a217985729ac34f931918ed05a2f231bb7c5" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;siginfo&lt;/code&gt; values make sense simultaneously (some are valid only for certain signals, for example), and not all values make sense from Perl perspective, you should to consult your system's &lt;code&gt;sigaction&lt;/code&gt; and possibly also &lt;code&gt;siginfo&lt;/code&gt; documentation.</source>
          <target state="translated">Обратите внимание, что не все значения &lt;code&gt;siginfo&lt;/code&gt; имеют смысл одновременно (например, некоторые из них действительны только для определенных сигналов), и не все значения имеют смысл с точки зрения Perl, вам следует обратиться к &lt;code&gt;sigaction&lt;/code&gt; вашей системы и, возможно, также &lt;code&gt;siginfo&lt;/code&gt; документации siginfo .</target>
        </trans-unit>
        <trans-unit id="7821dfbc405ad5ec367d208589dca3baa4ef11c2" translate="yes" xml:space="preserve">
          <source>Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences. Dark and faint, italic, blink, and concealed in particular are frequently not implemented.</source>
          <target state="translated">Обратите внимание,что не все атрибуты поддерживаются всеми типами терминалов,и некоторые терминалы могут не поддерживать ни одну из этих последовательностей.Часто не реализованы темные и слабые,курсив,мигание и,в частности,скрытые последовательности.</target>
        </trans-unit>
        <trans-unit id="dd77ba7655fe65f19331164b0a905a5ad5a97693" translate="yes" xml:space="preserve">
          <source>Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so). This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000. They may just be ignored, or they may display as an ESC character followed by some apparent garbage.</source>
          <target state="translated">Обратите внимание,что не все дисплеи соответствуют стандарту ISO 6429 или даже X3.64 (или даже пытаются им соответствовать).Этот модуль не будет работать так,как ожидалось,на дисплеях,которые не соблюдают эти экранирующие последовательности,такие как cmd.exe,4nt.exe и command.com ни под Windows NT,ни под Windows 2000.Их можно просто проигнорировать или отобразить в виде ESC символа,за которым может следовать некоторый явный мусор.</target>
        </trans-unit>
        <trans-unit id="9d7626cfa2c8cb10194e8906a42cfb46307be1b7" translate="yes" xml:space="preserve">
          <source>Note that not all features of Perl are available under these environments. This depends on the features the</source>
          <target state="translated">Обратите внимание,что не все функции Perl доступны в этих средах.Это зависит от возможностей</target>
        </trans-unit>
        <trans-unit id="b41fed2960927bbd3a7a4879e6c7ebbfd5148f75" translate="yes" xml:space="preserve">
          <source>Note that not all folders are defined on all versions of Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4d9996a72da721566e95c9b8f64cec116b411b" translate="yes" xml:space="preserve">
          <source>Note that not all incompatibilities are found.</source>
          <target state="translated">Обратите внимание,что не все несовместимости найдены.</target>
        </trans-unit>
        <trans-unit id="e354090ffbf1edbb380e0fa597ae3be4af6cb16d" translate="yes" xml:space="preserve">
          <source>Note that not all modules will work with on all platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more information on portability issues. Read the documentation to see if the module will work on your system. There are basically three categories of modules that will not work &quot;out of the box&quot; with all platforms (with some possibility of overlap):</source>
          <target state="translated">Обратите внимание, что не все модули будут работать на всех платформах. См. &lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt; для получения дополнительной информации по вопросам переносимости. Прочтите документацию, чтобы узнать, будет ли модуль работать в вашей системе. В основном есть три категории модулей, которые не будут работать &amp;laquo;из коробки&amp;raquo; со всеми платформами (с некоторой вероятностью перекрытия):</target>
        </trans-unit>
        <trans-unit id="8d15a25a2ad944379a4980717687047ae9148ec3" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">Обратите внимание, что не все расширения, доступные в CPAN, могут работать в среде Windows; вам следует проверить информацию на &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/,&lt;/a&gt; прежде чем вкладывать слишком много усилий в портирование модулей, которые нелегко собрать.</target>
        </trans-unit>
        <trans-unit id="b09aa2530ba4d13d5bf9a219720506b2be0033b4" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4084be0514f39566a9c52b9eaf1e3d0173ba9e" translate="yes" xml:space="preserve">
          <source>Note that not all platforms support disabling this option. Some, at least OpenBSD and MirBSD, will fail with &lt;code&gt;EINVAL&lt;/code&gt; if you attempt to disable it. To determine whether it is possible to disable, you may use the class method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6848dffa9b06cabb4c87ddb649c3cc22a5f54c" translate="yes" xml:space="preserve">
          <source>Note that numerical precision has the same meaning as under Perl (so binary to decimal conversion follows the same rules as in Perl, which can differ to other languages). Also, your perl interpreter might expose extensions to the floating point numbers of your platform, such as infinities or NaN's - these cannot be represented in JSON, and it is an error to pass those in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814895e1fc7075770faad339ecd10e73c24fbc5f" translate="yes" xml:space="preserve">
          <source>Note that numf is called by quant for stringifying all quantifying numbers.</source>
          <target state="translated">Обратите внимание,что число вызывается квантом для строки всех количественных чисел.</target>
        </trans-unit>
        <trans-unit id="f0564c5fce02fbef6630b978932f6aa1e763b70b" translate="yes" xml:space="preserve">
          <source>Note that older Pod formatters might not recognize octal or hex numeric escapes, and that many formatters cannot reliably render characters above 255. (Some formatters may even have to use compromised renderings of Latin-1/CP-1252 characters, like rendering &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; as just a plain &quot;e&quot;.)</source>
          <target state="translated">Обратите внимание, что старые программы форматирования Pod могут не распознавать восьмеричные или шестнадцатеричные числовые escape-последовательности, и что многие программы форматирования не могут надежно отображать символы выше 255. (Некоторым средствам форматирования, возможно, даже придется использовать скомпрометированное отображение символов Latin-1 / CP-1252, например, отображение &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; как просто &quot;е&quot;.)</target>
        </trans-unit>
        <trans-unit id="4fe6034079ad6a013e5f8b58c3a64f050566c116" translate="yes" xml:space="preserve">
          <source>Note that on Windows, address space allocation granularity is 64 KB, therefore, setting the stack smaller than that on Win32 Perl will not save any more memory.</source>
          <target state="translated">Обратите внимание,что в Windows гранулярность распределения адресного пространства составляет 64 КБ,поэтому установка стека меньшего размера,чем в Win32 Perl,не сэкономит больше памяти.</target>
        </trans-unit>
        <trans-unit id="9b131d252a3bfc8b5c8ad8d09c7187e733df7c40" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что при вводе (от строки к числу) Perl принимает &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; во многих формах. Регистр игнорируется, и специфичные для Win32 формы, такие как &lt;code&gt;1.#INF&lt;/code&gt; , понимаются, но на выходе значения нормализуются до &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6ea49ea44abd8799ce4dfc75293c4bfcb155f89" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6ba392df3d7fde91ed08ef1f5b7c759eb9d39f" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">Обратите внимание, что в некоторых системах возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически. См. Подробности в &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; и другие примеры.</target>
        </trans-unit>
        <trans-unit id="abc04d7473c212695d1b705a8da3b88080d0bbab" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">Обратите внимание, что в некоторых системах возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически. См. Подробности в &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; и другие примеры.</target>
        </trans-unit>
        <trans-unit id="baef8826a89d43d1f8e9e1ff1d1484160a339674" translate="yes" xml:space="preserve">
          <source>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</source>
          <target state="translated">Обратите внимание,что отменяются только локализованные изменения переменных.Другие побочные эффекты от выполнения выражений кода являются постоянными.Таким образом,</target>
        </trans-unit>
        <trans-unit id="9e8b3ca63f560a2fa0e18c2ef188ef76edc6e881" translate="yes" xml:space="preserve">
          <source>Note that only perl can truly parse Perl, so all such CASE tools fall somewhat short of the mark, especially if you don't program your Perl as a C programmer might.</source>
          <target state="translated">Обратите внимание,что только Perl может по-настоящему разобрать,так что все подобные инструменты CASE несколько не подходят,особенно если вы не программируете свой Perl,как программист на Си.</target>
        </trans-unit>
        <trans-unit id="32ee21a94e6bacfd587283dcf64796ed246e6431" translate="yes" xml:space="preserve">
          <source>Note that op_next is not manipulated, and nodes are not freed; that is the responsibility of the caller. It also won't create a new list op for an empty list etc; use higher-level functions like op_append_elem() for that.</source>
          <target state="translated">Обратите внимание,что op_next не манипулируется и узлы не освобождаются;за это отвечает вызывающий абонент.Он также не будет создавать новый список для пустого списка и т.д.;используйте для этого функции более высокого уровня,такие как op_append_elem().</target>
        </trans-unit>
        <trans-unit id="54c807dda3550fe223a1b1c55cd9bed9ee48d31f" translate="yes" xml:space="preserve">
          <source>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</source>
          <target state="translated">Обратите внимание,что pad_findlex()является рекурсивной функцией;она возвращает вверх по цепочке CV,затем возвращается вниз,добавляя поддельные записи по ходу работы.Это должно быть так,потому что поддельные имена в анонных протоипах должны храниться в xlow индекса в родительском блоке.</target>
        </trans-unit>
        <trans-unit id="131b045dcad1d95b29a85c93d3a6715d69d24db9" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что скобки необходимы, когда вы перевариваете все, что не является простой переменной. Это потому, что &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; интерпретируется как &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , а не как &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; вы могли ожидать. Аналогично, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; интерпретируется как &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; а не как &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="346dbcf702d3c4fdb72e5c159c8678dc946b771c" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что скобки необходимы, когда вы перевариваете все, что не является простой переменной. Это потому, что &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; интерпретируется как &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , а не как &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; вы могли ожидать. Аналогично, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; интерпретируется как &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; а не как &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="018c1697a99aff61964cd62c6350adc2116be64d" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;chomp $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(chomp $cwd) = `pwd`;&lt;/code&gt;, rather than as &lt;code&gt;chomp( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;chomp $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;chomp($a), $b&lt;/code&gt; rather than as &lt;code&gt;chomp($a, $b)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b290990bc28b21efbb6fc62a4d6a7e3869dd2f55" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61028061478cb52a55b53cfd7830a40515024150" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">Обратите внимание, что части этого кода были получены из &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt; с разрешения Адама Кеннеди.</target>
        </trans-unit>
        <trans-unit id="b192f3ab8b3b79b49c3da2be5c05a7696156013b" translate="yes" xml:space="preserve">
          <source>Note that pod translators should look at only paragraphs beginning with a pod directive (it makes parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a paragraph. This means that the following secret stuff will be ignored by both the compiler and the translators.</source>
          <target state="translated">Обратите внимание,что трансляторы pod должны смотреть только на параграфы,начинающиеся с директивы pod (это облегчает синтаксический разбор),в то время как компилятор на самом деле знает,что нужно искать экранирования pod даже в середине параграфа.Это означает,что следующая секретная информация будет проигнорирована и компилятором,и переводчиками.</target>
        </trans-unit>
        <trans-unit id="97f97f44b8a98fafc1d8a756bd8a55c77c58d9e9" translate="yes" xml:space="preserve">
          <source>Note that precision is not accuracy - binary floating point values cannot represent most decimal fractions exactly, and when converting from and to floating point, JSON::PP only guarantees precision up to but not including the least significant bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff72d3ac5b8dd647a96a960672acd7ebcc2f3ccc" translate="yes" xml:space="preserve">
          <source>Note that reports about bugs in old versions of Perl, especially those which indicate you haven't also tested the current stable release of Perl, are likely to receive less attention from the volunteers who build and maintain Perl than reports about bugs in the current release.</source>
          <target state="translated">Обратите внимание,что сообщения об ошибках в старых версиях Perl,особенно те,которые указывают на то,что вы не протестировали текущий стабильный релиз Perl,скорее всего,получат меньше внимания со стороны добровольцев,которые собирают и поддерживают Perl,чем сообщения об ошибках в текущем релизе.</target>
        </trans-unit>
        <trans-unit id="c75bcf48cfe25108045a83673fe9bf46dbdb6cb7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">Обратите внимание, что обращение массива к самому себе (как в &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) по возможности сохраняет несуществующие элементы; т.е. для немагических массивов или для связанных массивов с методами &lt;code&gt;EXISTS&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3279ef396cd3fe9ed1f5c93958f688b3a02be9e7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">Обратите внимание, что обращение массива к самому себе (как в &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) по возможности сохраняет несуществующие элементы; т.е. для немагических массивов или для связанных массивов с методами &lt;code&gt;EXISTS&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cefecfaf8ad606f51bb60e49b8b1e7ead07fd207" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = reverse @a&lt;/code&gt;) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bebc4223d6e9d86efc4ab961e85c3b37f4d12a" translate="yes" xml:space="preserve">
          <source>Note that rewinddir() has a similar limitation on Windows and will not force readdir() to read the directory again either. Only a newly opened directory handle will reflect changes to the directory.</source>
          <target state="translated">Обратите внимание,что rewinddir()имеет аналогичное ограничение на Windows и не будет заставлять readdir()читать каталог снова.Только недавно открытый дескриптор каталога будет отражать изменения в каталоге.</target>
        </trans-unit>
        <trans-unit id="ac3e7d8ec9774f1fc514c0a850fb3669a2dac43e" translate="yes" xml:space="preserve">
          <source>Note that section names might contain markup. I.e., if a section starts with:</source>
          <target state="translated">Обратите внимание,что названия разделов могут содержать разметку.Т.е.,если секция начинается с:</target>
        </trans-unit>
        <trans-unit id="5cd547b6f9a21623648f43fd2d180495971977d8" translate="yes" xml:space="preserve">
          <source>Note that setting precision and accuracy at the same time is not possible.</source>
          <target state="translated">Обратите внимание,что одновременная настройка точности и точности невозможна.</target>
        </trans-unit>
        <trans-unit id="2dfa6206994e5b2e572924979f052b36e73802cd" translate="yes" xml:space="preserve">
          <source>Note that several apps spew crap to stderr every time you connect, which can throw off Configure. You may need to monkeypatch the part of Configure that creates &lt;code&gt;run-ssh&lt;/code&gt; to have it discard stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2489b5c14780b59ec0536b9418bfecf1ef230d00" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.10.0 a // can also be the</source>
          <target state="translated">Обратите внимание,что,поскольку Perl 5.10.0 a //может быть также и</target>
        </trans-unit>
        <trans-unit id="f4f6bc0bb0b72e537a474e9d5b08d81afb1f9c79" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt; ) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">Обратите внимание, что начиная с Perl 5.8.1 v-строки с одним числом (например, &lt;code&gt;v65&lt;/code&gt; ) не являются v-строками перед оператором &lt;code&gt;=&amp;gt;&lt;/code&gt; (который обычно используется для отделения хеш-ключа от хеш-значения); вместо этого они интерпретируются как буквальные строки ('v65'). Это были v-строки от Perl 5.6.0 до Perl 5.8.0, но это вызвало больше путаницы и поломок, чем пользы. V-строки с несколькими &lt;code&gt;v65.66&lt;/code&gt; такие как v65.66 и &lt;code&gt;65.66.67&lt;/code&gt; ,всегда остаются v-строками.</target>
        </trans-unit>
        <trans-unit id="008b6ecd9594a1f31168dc7af3eef7ef69846a54" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt;) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ef149a186b458f11686fd9d31157ce1f5a0ebd" translate="yes" xml:space="preserve">
          <source>Note that since Perl version 5.16 this function has been a no-op, but this might change in a future release.</source>
          <target state="translated">Обратите внимание,что с версии 5.16 для Perl эта функция не работает,но в следующем релизе она может измениться.</target>
        </trans-unit>
        <trans-unit id="6c5b88d706c28965b53567c8427b594ad63f74e3" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt; . Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">Обратите внимание, что пропуск пустого пространства применяется только к внутренней части этой конструкции. Не должно быть пробелов между символами, образующими начальные &lt;code&gt;(?[&lt;/code&gt; . Также не может быть пробелов между закрывающими &lt;code&gt;])&lt;/code&gt; символами.</target>
        </trans-unit>
        <trans-unit id="545af0b2b09ce2f37c97dabd56794edec8a64fad" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt;. Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7426c9a1b07347627eeb1ac1cf62af6a1907ba1a" translate="yes" xml:space="preserve">
          <source>Note that some UNIX mail systems can mess with text attachments containing 'From '. This will fix them up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c060aa4bbf33c5b1f0215edf2ae5f526f55cd18" translate="yes" xml:space="preserve">
          <source>Note that some URLs have hexadecimal ASCII code points in them in an attempt to overcome character or protocol limitation issues. For example the tilde character is not on every keyboard hence a URL of the form:</source>
          <target state="translated">Обратите внимание,что некоторые URL-адреса имеют шестнадцатеричный ASCII-код в попытке преодолеть проблемы с ограничением символов или протоколов.Например,символ тильды находится не на каждой клавиатуре,поэтому URL формы:</target>
        </trans-unit>
        <trans-unit id="b0ec6733c239960d7ab748fd5e743c87866db919" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;b&gt;--release&lt;/b&gt; to the last modified date and &lt;b&gt;--date&lt;/b&gt; to the version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5782148c53cb53f800e7cc24f499baa2f09d812f" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;code&gt;release&lt;/code&gt; to the last modified date and &lt;code&gt;date&lt;/code&gt; to the version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96757558cf943b3af9fec33e5de374cf8022a75a" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt; ), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;LIMITATIONS of -x&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что некоторые типы аргументов / возвращаемых значений для функций могут привести к XSUB-объявлениям / записям typemap, которые требуют редактирования вручную. Такими могут быть объекты, которые нельзя преобразовать из / в указатель (например, &lt;code&gt;long long&lt;/code&gt; ), указатели на функции или массивы. См. Также раздел &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;ОГРАНИЧЕНИЯ -x&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6ea1587e3db14d628357c10f80019ced4d3486b" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt;), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of-x&quot;&gt;&quot;LIMITATIONS of &lt;b&gt;-x&lt;/b&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd18b02b9dc35274d6564c64032ca709a95c4f6" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Обратите внимание, что пробелы в аргументе формата для &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; не обозначают буквальные пробелы. Если у вас есть данные, разделенные пробелами, вы можете вместо этого &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="662d6982ca6578815a4a0f18cc0ec8305ec26773" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;unpack&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;split&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b6650d0cfdddfa7918a6366723469de7b3aca7" translate="yes" xml:space="preserve">
          <source>Note that splitting an EXPR that evaluates to the empty string always produces zero fields, regardless of the LIMIT specified.</source>
          <target state="translated">Обратите внимание,что разделение EXPR,который оценивает пустую строку,всегда приводит к появлению нулевых полей,независимо от указанного LIMIT.</target>
        </trans-unit>
        <trans-unit id="77e878278c2299b62e83869de869a2f9253eaf40" translate="yes" xml:space="preserve">
          <source>Note that starting from Perl 5.7.2 (and consequently 5.8.0) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Обратите внимание,что начиная с версии Perl 5.7.2 (и,следовательно,5.8.0)и AIX 4.3 или более новой версии Perl использует собственный интерфейс динамической загрузки AIX в так называемом режиме runtime link вместо эмулированного интерфейса,который использовался в версии Perl 5.6.1 и более ранней версии или,для версии AIX 4.2 и более ранней версии.Это изменение нарушает обратную совместимость с скомпилированными модулями из более ранних версий Perl.Изменение было сделано для того,чтобы сделать Perl более совместимым с другими приложениями,такими как Apache/mod_perl,использующими родной интерфейс AIX.Это изменение также позволяет использовать C++код со статическими конструкторами и деструкторами в расширениях Perl,что было невозможно при использовании эмулируемого интерфейса.</target>
        </trans-unit>
        <trans-unit id="e00838249311f81e98bfc06fb08536fb7ec9966f" translate="yes" xml:space="preserve">
          <source>Note that starting in Unicode 6.1, many of the block names have shorter synonyms. These are always given in the new style.</source>
          <target state="translated">Обратите внимание,что,начиная с Юникода 6.1,многие названия блоков имеют более короткие синонимы.Они всегда приводятся в новом стиле.</target>
        </trans-unit>
        <trans-unit id="2ad7004d8cad106c4c2f0c2a7d60864d3c8b1736" translate="yes" xml:space="preserve">
          <source>Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(), Atol(), Atoul(). Avoid those, too.</source>
          <target state="translated">Обратите внимание,что strtol()и strtoul()могут быть замаскированы под Strtol(),Strtoul(),Atol(),Atoul().Избегайте их тоже.</target>
        </trans-unit>
        <trans-unit id="1f8d123671f8fe6351f73c10ea6c3fa3f4b1a51f" translate="yes" xml:space="preserve">
          <source>Note that tabs and spaces are compared strictly, meaning 1 tab will not match 8 spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da058756ddccf3047bc3134e13ea20e3af855473" translate="yes" xml:space="preserve">
          <source>Note that testing is finished. If no plan has been set this will generate a Plan event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">Обратите внимание,что</target>
        </trans-unit>
        <trans-unit id="6672243740cead8683b9d1445f8ead3531c13383" translate="yes" xml:space="preserve">
          <source>Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl. The default can be overridden by setting the environment variable PERLIO to a space or colon separated list of layers, however this cannot be used to set layers that require loading modules like &lt;code&gt;:encoding&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94925dc9df0f22c049d74f88d76450a9a690c2cd" translate="yes" xml:space="preserve">
          <source>Note that the 0 index of @{^CAPTURE} is equivalent to $1, the 1 index is equivalent to $2, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f90013b3209e32ef045a540920a533398fa647" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; emulation of &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fcc2fd58a5941d9e57fbe4a6f4e6ca8d35d36f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;perlfunc#select-FILEHANDLE&quot;&gt;&lt;code&gt;select FILEHANDLE&lt;/code&gt;&lt;/a&gt; form is generally portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5879e45ce93c6c3511286267d5813593e72f0a4e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;p&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;&quot;a&quot;&lt;/code&gt;'s) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;use warnings&lt;/code&gt;; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a13e460ac63aeef5172c4e67fabd8f175a93e35" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt; , the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;%a&lt;/code&gt; и &lt;code&gt;%b&lt;/code&gt; , краткие формы дня недели и месяца года, не обязательно могут состоять из трех символов.</target>
        </trans-unit>
        <trans-unit id="c990c52d20bce03cc1931306413c2445b6287df4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; prefixes are &lt;b&gt;not required&lt;/b&gt;, but authors who wish their extensions to be portable to Unix or OS/2 should use the prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">Обратите внимание, что префиксы &lt;code&gt;-L&lt;/code&gt; и &lt;code&gt;-l&lt;/code&gt; &lt;b&gt;не требуются&lt;/b&gt; , но авторы, которые хотят, чтобы их расширения были переносимы в Unix или OS / 2, должны использовать префиксы, поскольку они требуются для версии ext () для Unix-OS / 2.</target>
        </trans-unit>
        <trans-unit id="1fb35d0c6e79a4294b3591fc47c05224b1801d3d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; form is generally portable.</source>
          <target state="translated">Обратите внимание, что форма &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; обычно переносима.</target>
        </trans-unit>
        <trans-unit id="9806508e6a2529870cc2037f1710d22cb6ace5d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker option may be used to add these options to any makefiles generated by MakeMaker.</source>
          <target state="translated">Обратите внимание, что параметр &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker может использоваться для добавления этих параметров в любые файлы сборки, созданные MakeMaker.</target>
        </trans-unit>
        <trans-unit id="86802402b451982daee5eec807ff6ea5529eaefd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;a&lt;/code&gt; 's) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">Обратите внимание, что модификаторы &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;u&lt;/code&gt; являются особенными в том смысле, что они могут быть только включены, но не отключены, а модификаторы &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; и &lt;code&gt;u&lt;/code&gt; являются взаимоисключающими: указание одного отменяет определение других, и максимум один (или два &lt;code&gt;a&lt;/code&gt; &amp;laquo;) может появиться в конструкции. Таким образом, например, &lt;code&gt;(?-p)&lt;/code&gt; будет предупреждать при компиляции с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использовании&lt;/a&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; и &lt;code&gt;(?dl:...)&lt;/code&gt; являются фатальными ошибками.</target>
        </trans-unit>
        <trans-unit id="b75233b2e52c1643f13c545ab5448e1216afde19" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">Обратите внимание, что операция &lt;code&gt;digest&lt;/code&gt; является разрушительной операцией с однократным чтением. После выполнения объект $ ctx автоматически &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; и может использоваться для вычисления другого значения дайджеста. Вызовите $ ctx-&amp;gt; clone-&amp;gt; digest, если вы хотите вычислить дайджест без сброса состояния дайджеста.</target>
        </trans-unit>
        <trans-unit id="ce0a012ac00944b517f4c494f69adcd759afd120" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e408b4bb22ad308085742938ea428bf4e618d3e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">Обратите внимание, что операция &lt;code&gt;digest&lt;/code&gt; - это фактически разрушительная операция с однократным чтением. После выполнения объект &lt;code&gt;Digest::MD5&lt;/code&gt; автоматически &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; и может использоваться для вычисления другого значения дайджеста. Вызовите $ md5-&amp;gt; clone-&amp;gt; digest, если вы хотите вычислить дайджест без сброса состояния дайджеста.</target>
        </trans-unit>
        <trans-unit id="30d1356fb08343a518e41acb4dd7ec7580812f65" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24eeff32ed6f4a19c0009f5d0e023c636e7a94e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; macros in</source>
          <target state="translated">Обратите внимание, что макросы &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; и &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="a2d5c53bebb44c78258b20f3af06f6f909ee7256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; mode will make Pod::Simple (et al) run rather slower, since &amp;amp;Pod::Simple::DEBUG won't be a constant sub anymore, and so Pod::Simple (et al) won't compile with constant-folding.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; режима Pod :: Simple :: Debug (\ $ x, &lt;i&gt;somenum&lt;/i&gt; ) приведет к тому, что Pod :: Simple (и др.) Будет работать медленнее, поскольку &amp;amp; Pod :: Simple :: DEBUG больше не будет константной подпрограммой, и поэтому Pod :: Simple (и др.) не будет компилироваться с свертыванием констант.</target>
        </trans-unit>
        <trans-unit id="20cd55dfd99c6b7ca8f8c3e96afe94485ab2aeca" translate="yes" xml:space="preserve">
          <source>Note that the API described here changed considerably in perl 5.24; prior to that, big macros like &lt;code&gt;PUSHBLOCK&lt;/code&gt; and &lt;code&gt;POPSUB&lt;/code&gt; were used; in 5.24 they were replaced by the inline static functions described below. In addition, the ordering and detail of how these macros/function work changed in many ways, often subtly. In particular they didn't handle saving the savestack and temps stack positions, and required additional &lt;code&gt;ENTER&lt;/code&gt;, &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; compared to the new functions. The old-style macros will not be described further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9551d033cb29a27fd5d6bf1fe4833c6cf7eaf2fe" translate="yes" xml:space="preserve">
          <source>Note that the CPU seconds is the &lt;b&gt;minimum&lt;/b&gt; time: CPU scheduling and other operating system factors may complicate the attempt so that a little bit more time is spent. The benchmark output will, however, also tell the number of &lt;code&gt;$code&lt;/code&gt; runs/second, which should be a more interesting number than the actually spent seconds.</source>
          <target state="translated">Обратите внимание, что секунды ЦП - это &lt;b&gt;минимальное&lt;/b&gt; время: планирование ЦП и другие факторы операционной системы могут усложнить попытку, так что будет потрачено немного больше времени. Однако результаты теста также покажут количество запусков &lt;code&gt;$code&lt;/code&gt; секунду, что должно быть более интересным числом, чем фактически потраченные секунды.</target>
        </trans-unit>
        <trans-unit id="28d680a1e0dab71002ed6eded256a885c900ba34" translate="yes" xml:space="preserve">
          <source>Note that the EXPR can be arbitrarily complicated as long as the final operation is a hash or array key lookup or subroutine name:</source>
          <target state="translated">Обратите внимание,что EXPR может быть произвольно сложным,если конечной операцией является поиск хэша или массива ключей или имя подпрограмм:</target>
        </trans-unit>
        <trans-unit id="f0084fb8a7b9ce4d56aecba3fadc51d825f62ba8" translate="yes" xml:space="preserve">
          <source>Note that the Encode implementation of GSM0338 does not implement the reuse of Latin capital letters as Greek capital letters (for example, the 0x5A is U+005A (LATIN CAPITAL LETTER Z), not U+0396 (GREEK CAPITAL LETTER ZETA).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc125ebc0373a09cca375f9b07fbcd59b2c703e" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что флаг G_KEEPERR не распространяется на внутренние вычисления; они все еще могут установить &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="997492b2704e0f5c940f0988ed8b0f1470e9f2f1" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f14f1b3c2ecac55af54ec64471c279be4e1559f" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что значение MAP_TARGET * должно * иметь расширение &amp;laquo;.exe&amp;raquo;, иначе вы не создадите &amp;laquo;perl.exe&amp;raquo; вместо того, который находится в &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8caaca0bc214aa98766a1940f6cdf2d7b3d021af" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54136d6700549a5defbb3ceccf1ce74752ff9160" translate="yes" xml:space="preserve">
          <source>Note that the MD5 algorithm is not as strong as it used to be. It has since 2005 been easy to generate different messages that produce the same MD5 digest. It still seems hard to generate messages that produce a given digest, but it is probably wise to move to stronger algorithms for applications that depend on the digest to uniquely identify a message.</source>
          <target state="translated">Обратите внимание,что алгоритм MD5 не так силен,как раньше.С 2005 года легко генерировать различные сообщения,которые выдают один и тот же дайджест MD5.Все еще кажется трудным генерировать сообщения,которые производят определенный дайджест,но,вероятно,разумно перейти к более сильным алгоритмам для приложений,которые зависят от дайджеста,чтобы однозначно идентифицировать сообщение.</target>
        </trans-unit>
        <trans-unit id="247c1a806843ed2e2d60424a5f01f9ce095fc287" translate="yes" xml:space="preserve">
          <source>Note that the MinGW build currently requires a MinGW runtime version earlier than 3.21 (check __MINGW32_MAJOR_VERSION and __MINGW32_MINOR_VERSION).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f5d2315ce8efb902a4b01848317f36e6d46300" translate="yes" xml:space="preserve">
          <source>Note that the PerlIO equivalents of &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt; are slightly different from their C library counterparts:</source>
          <target state="translated">Обратите внимание, что эквиваленты PerlIO для &lt;code&gt;fread&lt;/code&gt; и &lt;code&gt;fwrite&lt;/code&gt; немного отличаются от своих аналогов из библиотеки C:</target>
        </trans-unit>
        <trans-unit id="b520e7f3d86206ae6fb132d75305e69c64963146" translate="yes" xml:space="preserve">
          <source>Note that the Script_Extensions property is an improved version of the Script property, and you should probably be using that instead, with the &lt;a href=&quot;#charprop%28%29&quot;&gt;&quot;charprop()&quot;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c898fd225c811d3b33264eb9a5dd3fac5a9a201b" translate="yes" xml:space="preserve">
          <source>Note that the Symbian filesystem is very picky: it strongly prefers the \ instead of the /.</source>
          <target state="translated">Обратите внимание,что файловая система Symbian очень привередлива:она сильно предпочитает \,а не /.</target>
        </trans-unit>
        <trans-unit id="f053db6da6e575d7b066a2e19e4c949dfd7c2c0f" translate="yes" xml:space="preserve">
          <source>Note that the above implementation shuffles an array in place, unlike the &lt;code&gt;List::Util::shuffle()&lt;/code&gt; which takes a list and returns a new shuffled list.</source>
          <target state="translated">Обратите внимание, что вышеупомянутая реализация перемешивает массив на месте, в отличие от &lt;code&gt;List::Util::shuffle()&lt;/code&gt; который принимает список и возвращает новый перемешанный список.</target>
        </trans-unit>
        <trans-unit id="b065a3ad25b4fc5b70a8b34ad20e23ed1b7c3cb3" translate="yes" xml:space="preserve">
          <source>Note that the above two invocations will be very verbose as reachable memory and leak-checking is enabled by default. If you want to just see pure errors, try:</source>
          <target state="translated">Обратите внимание,что два вышеуказанных вызова будут очень многословными,так как по умолчанию включена доступная память и проверка на утечку.Если вы хотите увидеть только чистые ошибки,попробуйте:</target>
        </trans-unit>
        <trans-unit id="64532abb5f09f86d92c621e51038db0bcc100d92" translate="yes" xml:space="preserve">
          <source>Note that the actual meanings of the various fields are not that well standardized, do not expect any great portability. The &lt;code&gt;$sysname&lt;/code&gt; might be the name of the operating system, the &lt;code&gt;$nodename&lt;/code&gt; might be the name of the host, the &lt;code&gt;$release&lt;/code&gt; might be the (major) release number of the operating system, the &lt;code&gt;$version&lt;/code&gt; might be the (minor) release number of the operating system, and the &lt;code&gt;$machine&lt;/code&gt; might be a hardware identifier. Maybe.</source>
          <target state="translated">Обратите внимание, что фактические значения различных полей не так хорошо стандартизированы, не ожидайте большой переносимости. &lt;code&gt;$sysname&lt;/code&gt; может быть названием операционной системы, то &lt;code&gt;$nodename&lt;/code&gt; может быть именем хоста, то &lt;code&gt;$release&lt;/code&gt; может быть (основной) номер версии операционной системы, то &lt;code&gt;$version&lt;/code&gt; может быть (второстепенный) номер версии операционной системы, а &lt;code&gt;$machine&lt;/code&gt; может быть идентификатором оборудования. Может быть.</target>
        </trans-unit>
        <trans-unit id="f2424ff844845a48b6b1b2cd57585ba63cec58ff" translate="yes" xml:space="preserve">
          <source>Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY is not defined until at least the 1.50 release. Please ensure you use the correct EU_INSTALL_ALWAYS_COPY.</source>
          <target state="translated">Обратите внимание,что псевдоним EU_ALWAYS будет поддерживаться,если EU_INSTALL_ALWAYS не будет определен,по крайней мере,до версии 1.50.Пожалуйста,убедитесь,что вы используете правильный псевдоним EU_INSTALL_ALWAYS.</target>
        </trans-unit>
        <trans-unit id="b57c85ca6eca16bd7229db94019acde3ad48fd66" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt; switch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b36cb20c7dae889459ec2f6f9db24992abdb43" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;b&gt;-0&lt;/b&gt; switch:</source>
          <target state="translated">Обратите внимание, что присвоение &lt;code&gt;$\ = $/&lt;/code&gt; выполняется при обработке переключателя, поэтому разделитель входной записи может отличаться от разделителя выходной записи, если за переключателем &lt;b&gt;-l&lt;/b&gt; следует переключатель &lt;b&gt;-0&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="c00bf502c45bde6ba2060e9d911a339007fd5405" translate="yes" xml:space="preserve">
          <source>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: &lt;code&gt;/\\/&lt;/code&gt; matches a single backslash.</source>
          <target state="translated">Обратите внимание, что обратная косая черта является особенной; если вы хотите сопоставить обратную косую черту, вы должны экранировать обратную косую черту с помощью обратной косой черты: &lt;code&gt;/\\/&lt;/code&gt; соответствует одной обратной косой черте.</target>
        </trans-unit>
        <trans-unit id="f6ebed0705c42d69729c70593af8e15098cbc1e9" translate="yes" xml:space="preserve">
          <source>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the redundant string &quot;==&quot; to the result.</source>
          <target state="translated">Обратите внимание,что возвращаемая строка в кодировке base64 не имеет длины,кратной 4 байтам.Если вам нужна функциональная совместимость с другими md5-дайджестами в кодировке base64,то к результату можно добавить избыточную строку &quot;==&quot;.</target>
        </trans-unit>
        <trans-unit id="772992efab68f2396f54e27fdd4bb3868704a8b7" translate="yes" xml:space="preserve">
          <source>Note that the braces are required in Perl, even if you've only got one line in the block. However, there is a clever way of making your one-line conditional blocks more English like:</source>
          <target state="translated">Обратите внимание,что фигурные скобки требуются в Perl,даже если в блоке только одна строчка.Тем не менее,есть умный способ сделать ваши однострочные условные блоки более похожими на английские:</target>
        </trans-unit>
        <trans-unit id="ece9838263d6bf6e2a7db9094c48c8c8ea6e66ec" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7f794be85b20ad885b31b3bd4e8712126125c7" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL.</source>
          <target state="translated">Обратите внимание, что вызывающая сторона отвечает за соответствующее увеличение счетчика ссылок &lt;code&gt;val&lt;/code&gt; перед вызовом и уменьшение его, если функция вернула NULL.</target>
        </trans-unit>
        <trans-unit id="4f5d7bcf37a5b2a38715b73f67483220347ce0f3" translate="yes" xml:space="preserve">
          <source>Note that the code might be broken into multiple segments if there are nested formatting codes inside a &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; sequence. In between the calls to &lt;code&gt;handle_code&lt;/code&gt; other markup tags might have been emitted in that case. The same is true for verbatim sections if the &lt;code&gt;codes_in_verbatim&lt;/code&gt; option is turned on.</source>
          <target state="translated">Обратите внимание, что код может быть разбит на несколько сегментов, если внутри последовательности &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; есть вложенные коды форматирования . В этом случае между вызовами &lt;code&gt;handle_code&lt;/code&gt; могли быть сгенерированы другие теги разметки. То же верно и для дословных разделов, если &lt;code&gt;codes_in_verbatim&lt;/code&gt; опция code_in_verbatim .</target>
        </trans-unit>
        <trans-unit id="8cd0e4a20a7367cc4b5ead8187ea067b769ad671" translate="yes" xml:space="preserve">
          <source>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</source>
          <target state="translated">Обратите внимание,что эффект является компилируемым по времени и неизменяемым после его определения.Однако,подпрограммам передается единственный параметр,который равен 0,если действует case-чувствительное совпадение,и ненулевой,если действует бескорпусное совпадение.Подпрограмма может возвращать различные значения в зависимости от значения флага,и один набор значений будет неизменным для всех регистрочувствительных совпадений,а другой набор-для всех регистронечувствительных совпадений.</target>
        </trans-unit>
        <trans-unit id="82a2a038be5dc98f1cb9f3946ca4a644efda3ae0" translate="yes" xml:space="preserve">
          <source>Note that the effect of &lt;code&gt;binmode&lt;/code&gt; differs from that of the binmode() function on operating systems such as Windows and MSDOS, and is not needed to process most types of file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d0991fa33934053d27ec9e77b0dcc73eda0b3d" translate="yes" xml:space="preserve">
          <source>Note that the embedded single-quotes in the string don't help in this case, since they have not been specified as acceptable delimiters and are therefore treated as non-delimiter characters (and ignored).</source>
          <target state="translated">Обратите внимание,что встроенные одинарные кавычки в строке в данном случае не помогают,так как они не были указаны как допустимые разделители и поэтому рассматриваются как неделимитируемые символы (и игнорируются).</target>
        </trans-unit>
        <trans-unit id="1a60f273853beeeddbd8dccab4c57df4281d7707" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; implements. Most if not all systems implement &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; in terms of &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb58ec9da82570c29bbbb5325581cb00b947ded" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with lockf(3) doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that lockf(3) implements. Most if not all systems implement lockf(3) in terms of fcntl(2) locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">Обратите внимание,что эмуляция,собранная с помощью lockf(3),не предоставляет разделяемых блокировок,и требует,чтобы FILEHANDLE была открыта с намерением записи.Это семантика,которую реализует lockf(3).Большинство,если не все системы,реализуют lockf(3)с точки зрения блокировки fcntl(2),так что различная семантика не должна увлекать слишком много людей.</target>
        </trans-unit>
        <trans-unit id="07238884ca9ae6e9d1b98c9eab9e8272e50d79b1" translate="yes" xml:space="preserve">
          <source>Note that the encoding itself is &lt;b&gt;not&lt;/b&gt; a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.</source>
          <target state="translated">Обратите внимание, что сама кодировка &lt;b&gt;не&lt;/b&gt; является формально допустимым языковым тегом. Также обратите внимание, что в настоящее время вы не можете перейти от кодировки обратно к языковому тегу, кодировке которого она является.</target>
        </trans-unit>
        <trans-unit id="5a48ddc9bb68bd34263110aaa842399866ebadf6" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt; : the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">Обратите внимание, что развернутая форма представляет способ внутренней обработки таких конструкций Perl - эта опция фактически отключает обратное преобразование, которое обычно делает B :: Deparse. С другой стороны, обратите внимание, что &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; не то же самое, что &lt;code&gt;$x = $y&lt;/code&gt; : первый преобразует значение $ y в строку перед выполнением присваивания.</target>
        </trans-unit>
        <trans-unit id="7363f38426987fddbd769148d6ed0f8d3381792d" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt;: the former makes the value of $y into a string before doing the assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6c91a770707b555d66e4a287e39136a3141726" translate="yes" xml:space="preserve">
          <source>Note that the extraction with the stored paths is still necessary (default with unzip, specify &lt;code&gt;-d&lt;/code&gt; to pkunzip). However, you need to know where to extract the files. You need also to manually change entries in</source>
          <target state="translated">Обратите внимание, что извлечение с сохраненными путями по-прежнему необходимо (по умолчанию с unzip, укажите &lt;code&gt;-d&lt;/code&gt; для pkunzip). Однако вам нужно знать, где извлечь файлы. Вам также необходимо вручную изменить записи в</target>
        </trans-unit>
        <trans-unit id="fd97b7e25cb09157d47ba2c7b978a7930b9606b8" translate="yes" xml:space="preserve">
          <source>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">Обратите внимание,что fcntl(2)эмуляция flock(3)требует,чтобы FILEHANDLE была открыта с намерением чтения для использования LOCK_SH и требует,чтобы она была открыта с намерением записи для использования LOCK_EX.</target>
        </trans-unit>
        <trans-unit id="85ef7ad11abd8bc54af52a716405bd9eb2cc5233" translate="yes" xml:space="preserve">
          <source>Note that the file path is relative to &lt;code&gt;$dir&lt;/code&gt; if that is specified. This &lt;b&gt;must not&lt;/b&gt; be used directly for CPAN META &lt;code&gt;provides&lt;/code&gt;. See the &lt;code&gt;provides&lt;/code&gt; method instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe144eb2f290a0a193386ccafda07da2ebb33808" translate="yes" xml:space="preserve">
          <source>Note that the file will not be included twice under the same specified name.</source>
          <target state="translated">Обратите внимание,что файл не будет включен дважды под одним и тем же именем.</target>
        </trans-unit>
        <trans-unit id="7a13c6488a9b380a268109737c1af44124fc53ff" translate="yes" xml:space="preserve">
          <source>Note that the final string may be up to 7 chars longer than pvlim.</source>
          <target state="translated">Обратите внимание,что итоговая строка может быть до 7 символов длиннее,чем pvlim.</target>
        </trans-unit>
        <trans-unit id="cd6cdc78eed59a6e15c0c2c30dcc231f761afe79" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://man.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772ece35cdf290101677cb798018640a9adccf19" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">Обратите внимание, что первый аргумент является обязательным. Номер раздела будет извлечен из него, и если он отсутствует, по умолчанию будет равен 1. Второй аргумент в настоящее время игнорируется, так как &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net в&lt;/a&gt; настоящее время не включает в себя связываемые идентификаторы или имена привязок на своих страницах. Подкласс для ссылки на другой HTTP-сервер справочной страницы.</target>
        </trans-unit>
        <trans-unit id="0926e8149e0f9908feb624f3205e6ac6e35159d1" translate="yes" xml:space="preserve">
          <source>Note that the first of the above returns a Time::Seconds object, so while examining the object will print the number of seconds (because of the overloading), you can also get the number of minutes, hours, days, weeks and years in that delta, using the Time::Seconds API.</source>
          <target state="translated">Обратите внимание,что первый из вышеперечисленных возвращает объект Time::Seconds,поэтому во время осмотра объекта будет выведено количество секунд (из-за перегрузки),вы также можете получить количество минут,часов,дней,недель и лет в этой дельте,используя API Time::Seconds.</target>
        </trans-unit>
        <trans-unit id="533bf74078da55d39eeb6299ea8805b9073e8050" translate="yes" xml:space="preserve">
          <source>Note that the general pattern here is that the accessor-methods read the attribute's value with &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; and set the attribute's value with &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt;. For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.</source>
          <target state="translated">Обратите внимание , что общая картина здесь является то , что аксессоры-метода чтения значения атрибута с &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; и установить значение атрибута с &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt; . Для каждого средства доступа я обычно упоминаю только тот или иной синтаксис, исходя из которого, я думаю, вы, скорее всего, будете использовать его.</target>
        </trans-unit>
        <trans-unit id="9c62e8291c3969aab5799ff59674523f531fd071" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , and is true otherwise.</source>
          <target state="translated">Обратите внимание, что глобальная переменная &lt;code&gt;$B::OP::does_parent&lt;/code&gt; не определена в старых perl, которые не поддерживают &lt;code&gt;parent&lt;/code&gt; метод, определена, но ложна для perl, которые поддерживают метод, но были созданы без &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , и истинна в противном случае.</target>
        </trans-unit>
        <trans-unit id="33122f52d4f72485938536bba048d13bb9c994d8" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt;, and is true otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255f1a96146684091b1e9cb0690908a053fe1866" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">Обратите внимание, что реализация &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; в этом модуле не обеспечивает истинный произвольный доступ к сжатому файлу / буферу. Он работает, распаковывая данные из текущего смещения в файле / буфере до тех пор, пока они не достигнут несжатого смещения, указанного в параметрах для &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; . Для очень маленьких файлов это может быть приемлемым поведением. Для больших файлов это может вызвать недопустимую задержку.</target>
        </trans-unit>
        <trans-unit id="c2278932c41e8894955fd432303661d611324abc" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;seek&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;seek&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f257e1d0eedfe176e0664704a0289bfea4406fc3" translate="yes" xml:space="preserve">
          <source>Note that the initializer for a nested class may be specified as an object of that class, or as a reference to a hash of initializers that are passed on to the nested struct's constructor.</source>
          <target state="translated">Заметим,что инициализатор для вложенного класса может быть указан как объект этого класса,так и как ссылка на хэш инициализаторов,которые передаются конструктору вложенной структуры.</target>
        </trans-unit>
        <trans-unit id="80804b39a5da75cc855890b4a2fe869234b33d17" translate="yes" xml:space="preserve">
          <source>Note that the interaction between alarms and sleeps is unspecified.</source>
          <target state="translated">Обратите внимание,что взаимодействие между сигналами тревоги и сном не определено.</target>
        </trans-unit>
        <trans-unit id="e8783b348067a3189a0f06125d399031ed3fee39" translate="yes" xml:space="preserve">
          <source>Note that the inversion lists returned by this function can possibly include non-Unicode code points, that is anything above 0x10FFFF. Unicode properties are not defined on such code points. You might wish to change the output to not include these. Simply add 0x110000 at the end of the non-empty returned list if it isn't already that value; and pop that value if it is; like:</source>
          <target state="translated">Обратите внимание,что возвращаемые этой функцией инверсионные списки могут содержать точки,не относящиеся к Unicode-коду,т.е.не имеющие значения выше 0x10FFFF.Свойства Юникода на таких точках кода не определены.Возможно,вы захотите изменить вывод,чтобы не включать их.Просто добавьте 0x110000 в конец непустого возвращаемого списка,если это еще не то значение;и всплывёт это значение,если оно есть;например:</target>
        </trans-unit>
        <trans-unit id="b0e71b8ea159a9c2edf24faa2295a4b51fa39394" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold%28%29&quot;&gt;&quot;casefold()&quot;&lt;/a&gt; for these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634311f4edf03951c04e577294ff3bbf805ec5ba" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; for these.</source>
          <target state="translated">Обратите внимание, что карты инверсии, возвращаемые для свойств &lt;code&gt;Case_Folding&lt;/code&gt; и &lt;code&gt;Simple_Case_Folding&lt;/code&gt; , не включают сопоставления тюркского языка. Для этого используйте &lt;a href=&quot;#casefold()&quot;&gt;casefold ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31c86684655a1972f5965e0709faf4f9dbe8bb6a" translate="yes" xml:space="preserve">
          <source>Note that the largest code point in Unicode is U+10FFFF.</source>
          <target state="translated">Обратите внимание,что самой большой точкой кода в Юникоде является U+10FFFF.</target>
        </trans-unit>
        <trans-unit id="19d81e07df642a7406f056019f52ad26601c1b9e" translate="yes" xml:space="preserve">
          <source>Note that the last two of these are actually competing projects both delivering complete gcc toolchain for MS Windows:</source>
          <target state="translated">Обратите внимание,что последние два из них на самом деле являются конкурирующими проектами,оба из которых предоставляют полный набор инструментов gcc для MS Windows:</target>
        </trans-unit>
        <trans-unit id="b9b9a1c26be88f08471aaa216414e6d8395e1d57" translate="yes" xml:space="preserve">
          <source>Note that the leading &quot;:&quot; is removed from the filename, so that</source>
          <target state="translated">Обратите внимание,что ведущий &quot;:&quot; удаляется из имени файла,чтобы</target>
        </trans-unit>
        <trans-unit id="df9faf2f3be99fd79d6a15587ce23e5766dfe648" translate="yes" xml:space="preserve">
          <source>Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</source>
          <target state="translated">Обратите внимание,что,как и обычные ассоциативные массивы,порядок найденных ключей располагается,по-видимому,в случайном порядке.</target>
        </trans-unit>
        <trans-unit id="f7e4be377938ec5b2bd579fa7c5058874b5e3a40" translate="yes" xml:space="preserve">
          <source>Note that the line number of the error/warning may refer to the line number of the start of the paragraph in which the error/warning exists, not the line number that the error/warning is on. This bug is present in errors/warnings related to formatting codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7eb999d3e69609ef8f64d4732450cbda274eea8" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92b7a5bb51e663f2e21cacb04a99284891d33e2" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">Обратите внимание, что по умолчанию строки не печатаются. Смотрите &lt;a href=&quot;#-p&quot;&gt;-p,&lt;/a&gt; чтобы напечатать строки. Если файл, названный аргументом, не может быть открыт по какой-либо причине, Perl предупреждает вас об этом и переходит к следующему файлу.</target>
        </trans-unit>
        <trans-unit id="b32153557293284be92deec6168f3ee23705dad2" translate="yes" xml:space="preserve">
          <source>Note that the list form of exec() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1ea4347f8d164bb526f1210c5912fa3af79feb" translate="yes" xml:space="preserve">
          <source>Note that the list form of system() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e826f7fe166da89c0048f458c19e7bf2982a08" translate="yes" xml:space="preserve">
          <source>Note that the list is not sorted.</source>
          <target state="translated">Обратите внимание,что список не отсортирован.</target>
        </trans-unit>
        <trans-unit id="3e41c72d7fee1ff8c764beabf8a96c567a3b6233" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f163f86087018a673bf93b42c4a0a6c49b0abc8" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of substr() acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">Обратите внимание,что l-значение,возвращаемое трёхпараметрической версией substr(),действует как &quot;волшебная пуля&quot;;каждый раз,когда ей присваивается значение,она запоминает,какая часть исходной строки модифицируется;например:</target>
        </trans-unit>
        <trans-unit id="30652accd17648a773c7cfc6b99b87e2f00a6b4d" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively.</source>
          <target state="translated">Обратите внимание,что отображение-это то,что указано в файлах данных Юникода,и для получения окончательной декомпозиции может потребоваться рекурсивное применение.</target>
        </trans-unit>
        <trans-unit id="41e59b746c6a84ae0b237b2221463c64daa4df44" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively. Unicode in fact discourages use of this property except internally in implementations of the Unicode Normalization Algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a840d21a1adb331df5f502ec5cce875d624189ca" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что минимальные квантификаторы соответствия &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt; , и &lt;code&gt;??&lt;/code&gt; кажутся вложенными квантификаторами, но это не так. См. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b41b3d83f67f68a69236e54f8aeb3e828ab48b2" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2a0ab30039f9b1189b998b4a9e776dc39a1982" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt; : the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">Обратите внимание, что количество цифр экспоненты в экспоненциальной нотации, полученной &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; и &lt;code&gt;%G&lt;/code&gt; для чисел с модулем экспоненты меньше 100, зависит от системы: оно может быть три или меньше (с дополнением нулями как надо). Другими словами, 1,23 умноженное на десять до 99-го числа может быть либо &amp;laquo;1,23e99&amp;raquo;, либо &amp;laquo;1,23e099&amp;raquo;. Аналогично для &lt;code&gt;%a&lt;/code&gt; и &lt;code&gt;%A&lt;/code&gt; : показатель степени или шестнадцатеричные цифры могут плавать: особенно параметр конфигурации Perl &quot;длинные удвоения&quot; может вызвать сюрпризы.</target>
        </trans-unit>
        <trans-unit id="31bcb562562261f56086728520662f93907434b0" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt;: the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7eeec0bff7c89a12579e992fcf86b0716b7245b" translate="yes" xml:space="preserve">
          <source>Note that the only two changes from the normal way of writing an extension is the addition of a &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; before including the Perl headers, followed by a &lt;code&gt;dTHX;&lt;/code&gt; declaration at the start of every function that will call the Perl API. (You'll know which functions need this, because the C compiler will complain that there's an undeclared identifier in those functions.) No changes are needed for the XSUBs themselves, because the XS() macro is correctly defined to pass in the implicit context if needed.</source>
          <target state="translated">Обратите внимание, что единственными двумя &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; от обычного способа написания расширения являются добавление #define PERL_NO_GET_CONTEXT перед включением заголовков Perl, за которым следует &lt;code&gt;dTHX;&lt;/code&gt; объявление в начале каждой функции, которая будет вызывать Perl API. (Вы будете знать, каким функциям это нужно, потому что компилятор C будет жаловаться на необъявленный идентификатор в этих функциях.) Для самих XSUB никаких изменений не требуется, потому что макрос XS () правильно определен для передачи в неявном контексте если нужно.</target>
        </trans-unit>
        <trans-unit id="81cafeed743ff4607118970eeb67b7b39cfee366" translate="yes" xml:space="preserve">
          <source>Note that the opmask doesn't affect the already compiled code, it only affects any</source>
          <target state="translated">Обратите внимание,что опмаска не влияет на уже скомпилированный код,а только на любой</target>
        </trans-unit>
        <trans-unit id="50380a5708cf00fd178289610d3bed5ed2c8b5b4" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt; ), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что терминатор параметров (по умолчанию &lt;code&gt;--&lt;/code&gt; ), если он присутствует, также будет передан в &lt;code&gt;@ARGV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d140eced205e7240d0cac12aab6ec294f45d708" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt;), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b99871b0f7ac49ac26656a96e644a594657e984" translate="yes" xml:space="preserve">
          <source>Note that the outer &lt;code&gt;=over&lt;/code&gt; is a block because it has no &lt;code&gt;=item&lt;/code&gt;s but still has content: the inner &lt;code&gt;=over&lt;/code&gt;. The inner &lt;code&gt;=over&lt;/code&gt;, in turn, is completely empty, and is treated as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34344d5bf3d39aec43cee250c8b0f5cab594ad8e" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in &lt;code&gt;(?=regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; can match arbitrary regexps, but lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width, i.e., a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; is not. The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. They evaluate true if the regexps do</source>
          <target state="translated">Обратите внимание, что круглые скобки в &lt;code&gt;(?=regexp)&lt;/code&gt; и &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; не захватывают, так как это утверждения нулевой ширины. Таким образом, во втором регулярном выражении захваченные подстроки - это подстроки всего регулярного выражения. Предварительный просмотр &lt;code&gt;(?=regexp)&lt;/code&gt; может соответствовать произвольным регулярным выражениям , но предварительный просмотр назад &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; работает только для регулярных выражений фиксированной ширины, т. Е. С фиксированным количеством символов. Таким образом, &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; подходит, а &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; - нет. Инвертированные версии утверждений просмотра вперед и назад обозначаются &lt;code&gt;(?!regexp)&lt;/code&gt; и &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; соответственно. Они оценивают истину, если регулярные выражения</target>
        </trans-unit>
        <trans-unit id="b450a76f799fbd2000fb736a0e284dee87f232b7" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in these are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead can match arbitrary regexps, but lookbehind prior to 5.30 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b12314d048529314e48e1e307c0f68902915bd" translate="yes" xml:space="preserve">
          <source>Note that the perl-mode of emacs will have fits with &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (single quote), and mess up the indentation and highlighting. You are probably using &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; in new Perl code anyway, so this shouldn't be an issue.</source>
          <target state="translated">Обратите внимание, что perl-режим emacs будет соответствовать &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (одинарная кавычка) и испортит отступы и выделение. Вы, вероятно, все равно используете &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; в новом коде Perl, так что это не должно быть проблемой.</target>
        </trans-unit>
        <trans-unit id="f5ca7725b131e21f49d7345fcb2f0711a2a47f63" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">Обратите внимание,что притягательный модификатор квантификатора не может быть совмещен с нежирным модификатором.Это потому,что в этом нет никакого смысла.Рассмотрим следующую таблицу эквивалентности:</target>
        </trans-unit>
        <trans-unit id="05a31604712dc06b57292f7d6e6baf36004c8881" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2853371a63417bfadde728879823337ed5a4d700" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt; ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; whenever possible.</source>
          <target state="translated">Обратите внимание, что процесс будет продолжать расти для каждого используемого файла. Кроме того, могут существовать подпрограммы &lt;code&gt;AUTOLOAD&lt;/code&gt; ed и другие условия, которые вызывают рост таблицы символов Perl. Вы можете добавить некоторую логику, которая отслеживает размер процесса или перезагружается после определенного количества запросов, чтобы минимизировать потребление памяти. Вы также захотите, когда это возможно, охватить свои переменные с помощью &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19133e9511ee15654168135f8179ad57c8de3d7c" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt;ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;perlfunc#my&quot;&gt;&quot;my&quot; in perlfunc&lt;/a&gt; whenever possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2e6d6d10b83461736cd9723d9f047ffdd975d1" translate="yes" xml:space="preserve">
          <source>Note that the properties of the algorithms change over time, as the algorithms are analyzed and machines grow faster. If your application for instance depends on it being &quot;impossible&quot; to generate the same digest for a different message it is wise to make it easy to plug in stronger algorithms as the one used grow weaker. Using the interface documented here should make it easy to change algorithms later.</source>
          <target state="translated">Обратите внимание,что свойства алгоритмов со временем меняются,так как алгоритмы анализируются и машины растут быстрее.Если ваше приложение,например,зависит от того,что &quot;невозможно&quot; сгенерировать один и тот же дайджест для другого сообщения,то разумно сделать так,чтобы было легче подключать более сильные алгоритмы по мере того,как используемый будет слабеть.Использование документированного здесь интерфейса должно облегчить последующую смену алгоритмов.</target>
        </trans-unit>
        <trans-unit id="94680bef919b3e58595e50dc2cef254eecd344d5" translate="yes" xml:space="preserve">
          <source>Note that the reason that keys that start with &quot;_&quot; are immune to _AUTO isn't anything generally magical about the underscore character -- I just wanted a way to have most lexicon keys be autoable, except for possibly a few, and I arbitrarily decided to use a leading underscore as a signal to distinguish those few.</source>
          <target state="translated">Обратите внимание,что причина,по которой ключи,начинающиеся с &quot;_&quot;,невосприимчивы к символу подчеркивания-я просто хотел,чтобы большинство лексических ключей были автоматическими,за исключением,возможно,нескольких,и я произвольно решил использовать ведущий символ подчеркивания в качестве сигнала,чтобы отличить этих немногих.</target>
        </trans-unit>
        <trans-unit id="c52f10e051f2461220787b7a728deb5d7e62b4bd" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">Обратите внимание, что указанный &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; связан неявной областью видимости. В результате любая вновь введенная лексическая переменная или любое измененное содержимое буфера захвата теряется после eval. Отладчик - хорошая среда для изучения Perl, но если вы интерактивно экспериментируете с материалом, который должен быть в той же области, поместите его в одну строку.</target>
        </trans-unit>
        <trans-unit id="471933a1768d0ec6bc98ec34dbc5facf0b071a6f" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;eval&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c5f596ab4d97752de506fd4873b64dd76c61e3" translate="yes" xml:space="preserve">
          <source>Note that the single parameter passed to the</source>
          <target state="translated">Обратите внимание,что единственный параметр,переданный в</target>
        </trans-unit>
        <trans-unit id="a34d0fde03ac911613a011adde756943693a9a07" translate="yes" xml:space="preserve">
          <source>Note that the source code is passed as a single string, so any regex that uses &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to detect line boundaries will need the &lt;code&gt;/m&lt;/code&gt; flag.</source>
          <target state="translated">Обратите внимание, что исходный код передается как одна строка, поэтому для любого регулярного выражения, использующего &lt;code&gt;^&lt;/code&gt; или &lt;code&gt;$&lt;/code&gt; для определения границ строк, потребуется флаг &lt;code&gt;/m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="262f4baab34cdad3f12b64cb0a920818da7a10be" translate="yes" xml:space="preserve">
          <source>Note that the spaces are required around the &lt;code&gt;SVf&lt;/code&gt; in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfabff4ba4038a16af2c755df720dc69793c8b2" translate="yes" xml:space="preserve">
          <source>Note that the special variable &lt;code&gt;$^N&lt;/code&gt; is particularly useful with code blocks to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</source>
          <target state="translated">Обратите внимание, что специальная переменная &lt;code&gt;$^N&lt;/code&gt; особенно полезна с блоками кода для захвата результатов под совпадений в переменных без необходимости отслеживать количество вложенных круглых скобок. Например:</target>
        </trans-unit>
        <trans-unit id="320c096bf4918e52d7bd0e618c2e6a5bc9e4bbc3" translate="yes" xml:space="preserve">
          <source>Note that the specified &lt;code&gt;fail&lt;/code&gt; behaviour applies to nested tags as well.</source>
          <target state="translated">Обратите внимание , что указанный &lt;code&gt;fail&lt;/code&gt; поведения относится к вложенным тегам , а также.</target>
        </trans-unit>
        <trans-unit id="580a625682b8e1814baa151c5f0f7dc24aff6bf1" translate="yes" xml:space="preserve">
          <source>Note that the specified delimiters are automatically quotemeta'd.</source>
          <target state="translated">Обратите внимание,что указанные разделители автоматически являются quotemeta'd.</target>
        </trans-unit>
        <trans-unit id="1f961077ad91e1f5e608c0720760840050533641" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">Обратите внимание, что стек извлекается с использованием &lt;code&gt;POPs&lt;/code&gt; в блоке, где &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; истинно. Это необходимо, потому что всякий раз, когда</target>
        </trans-unit>
        <trans-unit id="710a5c79e66bbfbe96fbdcb6dc7413e03b66071c" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(err_tmp)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6462eb454e096d8a1746fdc113a16165357f8c5b" translate="yes" xml:space="preserve">
          <source>Note that the stringified form of infinity varies between platforms: it can be for example any of</source>
          <target state="translated">Обратите внимание,что строковая форма бесконечности варьируется между платформами:это может быть,например,любая из следующих форм</target>
        </trans-unit>
        <trans-unit id="e2587b73a26222076539535f74b276c7c807272c" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3205ecbbb1a9fb55e62eda6514162f94f7163bfc" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">Обратите внимание, что здесь используется синтаксис &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt; , а не &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt; . Другими словами, в случае кодового выражения нам не нужны лишние круглые скобки вокруг условного выражения.</target>
        </trans-unit>
        <trans-unit id="56d5a14355f9ba6fa06dc53e561fc21f5fed300e" translate="yes" xml:space="preserve">
          <source>Note that the tag names in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; don't have the leading ':'.</source>
          <target state="translated">Обратите внимание, что имена тегов в &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; не имеют в начале &quot;:&quot;.</target>
        </trans-unit>
        <trans-unit id="6d0f8cfa5599a4759e632a786adcd5ca20b3cfca" translate="yes" xml:space="preserve">
          <source>Note that the third argument to &lt;code&gt;open&lt;/code&gt; is a string containing the program name (&lt;code&gt;sort&lt;/code&gt;) plus all its arguments: in this case, &lt;code&gt;-u&lt;/code&gt; to specify unqiue sort, and then a fileglob specifying the files to sort. The resulting filehandle &lt;code&gt;$sort_fh&lt;/code&gt; works just like a read-only (&lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;) filehandle, and your program can subsequently read data from it as if it were opened onto an ordinary, single file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bef6f0ef3eec50d14d3b84a1a8afd14c67d76b" translate="yes" xml:space="preserve">
          <source>Note that the third argument, specifying the command that we wish to pipe to, sets up &lt;code&gt;cat&lt;/code&gt; to redirect its output via that &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; symbol into the file &lt;code&gt;numbered.txt&lt;/code&gt;. This can start to look a little tricky, because that same symbol would have meant something entirely different had it showed it in the second argument to &lt;code&gt;open&lt;/code&gt;! But here in the third argument, it's simply part of the shell command that Perl will open the pipe into, and Perl itself doesn't invest any special meaning to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d43c895066c9d58f40f202a5d66994671522d5e" translate="yes" xml:space="preserve">
          <source>Note that the trailing slash is required. This will result in some harmless warnings as Configure is run:</source>
          <target state="translated">Обратите внимание,что трейлинговая косая черта необходима.Это приведет к некоторым безобидным предупреждениям,так как запущена функция Configure:</target>
        </trans-unit>
        <trans-unit id="4c26505297a31083f6416749d3b93a6af60fd352" translate="yes" xml:space="preserve">
          <source>Note that the trapping of the restricted operations is not atomic: for example</source>
          <target state="translated">Обратите внимание,что ловушка ограниченных операций не является атомарной:например</target>
        </trans-unit>
        <trans-unit id="ec116afd50e96fd07d539738d536a8676b15709b" translate="yes" xml:space="preserve">
          <source>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. &lt;code&gt;['-?]&lt;/code&gt; contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</source>
          <target state="translated">Обратите внимание, что два символа по обе стороны от дефиса не обязательно являются обеими буквами или обеими цифрами. Возможен любой персонаж, но не рекомендуется. &lt;code&gt;['-?]&lt;/code&gt; содержит ряд символов, но большинство людей не знают, какие символы это означает. Кроме того, такие диапазоны могут привести к проблемам с переносимостью, если код должен выполняться на платформе, которая использует другой набор символов, например EBCDIC.</target>
        </trans-unit>
        <trans-unit id="4f3b0de1587236bfef6be06a1e0b5de9990d1475" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">Обратите внимание, что аргументы пользователя также передаются функции &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; вашего плагина в виде списка, например:</target>
        </trans-unit>
        <trans-unit id="b14ba3e78a188703ed0553b34c3137fe88a72a21" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;import()&lt;/code&gt; function as a list, eg:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9f0c91ad407486da2a0bb856a821fce00b3309" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">Обратите внимание, что значение анализируется каждый раз при выполнении &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если EXPR опущен, вычисляет &lt;code&gt;$_&lt;/code&gt; . Эта форма обычно используется для задержки синтаксического анализа и последующего выполнения текста EXPR до времени выполнения.</target>
        </trans-unit>
        <trans-unit id="80c8be42c3096c6bc305f155cfa7b7681593f345" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">Обратите внимание, что значение анализируется каждый раз при выполнении &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если EXPR опущен, вычисляет &lt;code&gt;$_&lt;/code&gt; . Эта форма обычно используется для задержки синтаксического анализа и последующего выполнения текста EXPR до времени выполнения.</target>
        </trans-unit>
        <trans-unit id="2890675e6e5968cd2291073021c2fb93c7f31c50" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt; . This address may change during lifetime of an SV.</source>
          <target state="translated">Обратите внимание, что значение &lt;code&gt;RV&lt;/code&gt; совпадает с числами, которые мы видим при преобразовании $ b в строку. Адреса внутри IV () - это адреса структур &lt;code&gt;X***&lt;/code&gt; которые содержат текущее состояние &lt;code&gt;SV&lt;/code&gt; . Этот адрес может измениться в течение срока службы SV.</target>
        </trans-unit>
        <trans-unit id="66bc2a839853392e6ca68b6e60b0dadd045339b5" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt;. This address may change during lifetime of an SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef677d9c2b3cc466ca9bce864166dbad6ce21bf" translate="yes" xml:space="preserve">
          <source>Note that the values are not copied, which means modifying them will modify the contents of the hash:</source>
          <target state="translated">Обратите внимание,что значения не копируются,что означает,что их изменение приведет к изменению содержимого хэша:</target>
        </trans-unit>
        <trans-unit id="ebcf1c39304e5cedc9f3bd9f293f7823399a8398" translate="yes" xml:space="preserve">
          <source>Note that the values for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa78261a427d9e6af662bdbde0ef46d033f442ef" translate="yes" xml:space="preserve">
          <source>Note that the variables &lt;code&gt;$z0&lt;/code&gt; and &lt;code&gt;$z1&lt;/code&gt; are not substituted when the regexp is compiled, as happens for ordinary variables outside a code expression. Rather, the whole code block is parsed as perl code at the same time as perl is compiling the code containing the literal regexp pattern.</source>
          <target state="translated">Обратите внимание, что переменные &lt;code&gt;$z0&lt;/code&gt; и &lt;code&gt;$z1&lt;/code&gt; не заменяются при компиляции регулярного выражения, как это происходит для обычных переменных вне выражения кода. Скорее, весь блок кода анализируется как код Perl в то же время, когда perl компилирует код, содержащий буквальный шаблон регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="1fe8cdc1e68ec1c1124569f21bcd3994f60be55b" translate="yes" xml:space="preserve">
          <source>Note that there are different &quot;long doubles&quot;: Perl will use whatever the compiler has.</source>
          <target state="translated">Обратите внимание,что существуют различные &quot;длинные двойники&quot;:Perl будет использовать все,что есть у компилятора.</target>
        </trans-unit>
        <trans-unit id="40ec796a3ab0ba742755eb67dcef2d941aab9225" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt; . In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что существуют ограничения для конкретной платформы на максимальную длину в &lt;code&gt;$0&lt;/code&gt; . В самом крайнем случае он может быть ограничен пространством, занимаемым исходным &lt;code&gt;$0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee80c0ec2ca365e28a84cac33edad0345d62e8d" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt;. In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f16f6cc7a1d32290bc8fbd0609f6f10bfa51e1b" translate="yes" xml:space="preserve">
          <source>Note that there are quite a few things that are unaffected by the current locale. Any literal character is the native character for the given platform. Hence 'A' means the character at code point 65 on ASCII platforms, and 193 on EBCDIC. That may or may not be an 'A' in the current locale, if that locale even has an 'A'. Similarly, all the escape sequences for particular characters, &lt;code&gt;\n&lt;/code&gt; for example, always mean the platform's native one. This means, for example, that &lt;code&gt;\N&lt;/code&gt; in regular expressions (every character but new-line) works on the platform character set.</source>
          <target state="translated">Обратите внимание, что текущая локаль не влияет на некоторые вещи. Любой буквальный символ является родным для данной платформы. Следовательно, &amp;laquo;A&amp;raquo; означает символ в кодовой точке 65 на платформах ASCII и 193 на EBCDIC. Это может быть или не быть &amp;laquo;А&amp;raquo; в текущей локали, если в этой локали даже есть &amp;laquo;А&amp;raquo;. Точно так же все escape-последовательности для определенных символов, например &lt;code&gt;\n&lt;/code&gt; , всегда означают собственный код платформы. Это означает, например, что &lt;code&gt;\N&lt;/code&gt; в регулярных выражениях (каждый символ, кроме новой строки) работает с набором символов платформы.</target>
        </trans-unit>
        <trans-unit id="fcd641de5265b4e5cb187918ec80acbf65468caa" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;unlock()&lt;/code&gt; function - the only way to unlock a variable is to allow it to go out of scope.</source>
          <target state="translated">Обратите внимание, что здесь нет функции &lt;code&gt;unlock()&lt;/code&gt; - единственный способ разблокировать переменную - это позволить ей выйти за пределы области видимости.</target>
        </trans-unit>
        <trans-unit id="ee4f05af5f26db870953ddb10f74cf79c107ad1e" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt; , or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the SvPVX field to be valid (for example, if you intend to write to it), then see &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что нет гарантии, что возвращаемое значение &lt;code&gt;SvPV()&lt;/code&gt; равно &lt;code&gt;SvPVX(sv)&lt;/code&gt; , или что &lt;code&gt;SvPVX(sv)&lt;/code&gt; содержит допустимые данные, или что последовательные вызовы &lt;code&gt;SvPV(sv)&lt;/code&gt; будут возвращать одно и то же значение указателя каждый раз. Это связано с тем, как обрабатываются такие вещи, как перегрузка и копирование при записи. В этих случаях возвращаемое значение может указывать на временный буфер или что-то подобное. Если вам абсолютно необходимо, чтобы поле SvPVX было действительным (например, если вы собираетесь писать в него), см. &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7173a3e77270e17008cce0d5bec933c84a84832b" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt;, or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the &lt;code&gt;SvPVX&lt;/code&gt; field to be valid (for example, if you intend to write to it), then see &lt;code&gt;&lt;a href=&quot;#SvPV_force&quot;&gt;&quot;SvPV_force&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e6ff314bcdd26836be58f3e6e1baf7a7a0e0d1" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">Обратите внимание, что больше нет необходимости импортировать модуль Tie :: Cycle - Attribute :: Handlers позаботится об этом автоматически. Вы даже можете передать аргументы подпрограмме &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; модуля , добавив их к имени класса. Например:</target>
        </trans-unit>
        <trans-unit id="7c645ae5150cd4da2a80be90839d213441cd9479" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;import&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0baced4cf34e750c502cd9ad3044c3426673e61e" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the &lt;code&gt;File::Temp&lt;/code&gt; object. The object itself acts as a filehandle. The object isa &lt;code&gt;IO::Handle&lt;/code&gt; and isa &lt;code&gt;IO::Seekable&lt;/code&gt; so all those methods are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371ae6320cc7816e3fbef9a78451aa3acb900b80" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the C&amp;lt;:temp&amp;gt; object. The object itself acts as a filehandle. The object isa C&amp;lt;:handle&amp;gt; and isa C&amp;lt;:seekable&amp;gt; so all those methods are available.</source>
          <target state="translated">Обратите внимание, что не существует способа получить дескриптор файла из объекта C &amp;lt;: temp&amp;gt;. Сам объект действует как дескриптор файла. Это объект C &amp;lt;: handle&amp;gt; и C &amp;lt;: seekable&amp;gt;, поэтому доступны все эти методы.</target>
        </trans-unit>
        <trans-unit id="d7964282b8c77ed0956498c86928309abbe4d836" translate="yes" xml:space="preserve">
          <source>Note that there is no validation to confirm that the handle is a handle or something that can act like one. Passing something that isn't a handle will cause a exception when trying to read from it. The &lt;code&gt;filename&lt;/code&gt; argument is mandatory or undef will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cf101c922aec42258fb611024af08532a1bd0f" translate="yes" xml:space="preserve">
          <source>Note that there's nothing wrong with defining multiple subclasses of a given class. This is both common and safe. For example, we might define &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; and &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; classes to distinguish between different types of mp3 file.</source>
          <target state="translated">Обратите внимание, что нет ничего плохого в определении нескольких подклассов данного класса. Это и распространено, и безопасно. Например, мы могли бы определить классы &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; и &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; чтобы различать разные типы файлов mp3.</target>
        </trans-unit>
        <trans-unit id="cea78bd68a577c917916111e5f8f914537b91ae3" translate="yes" xml:space="preserve">
          <source>Note that these configuration options are only used for generating</source>
          <target state="translated">Обратите внимание,что эти опции конфигурации используются только для генерации</target>
        </trans-unit>
        <trans-unit id="cf6c8c42d064a6c3523dfd07c74fecf239c950de" translate="yes" xml:space="preserve">
          <source>Note that these functions are compatible with *nix, not with the older ports of '94 - 95. The priorities are absolute, go from 32 to -95, lower is quicker. 0 is the default priority.</source>
          <target state="translated">Обратите внимание,что эти функции совместимы с *nix,а не со старыми портами '94-95.Приоритеты абсолютные,переходим от 32 до -95,ниже-быстрее.0 является приоритетом по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d791cddf7ffd40104e97e407e1f26e145041f7de" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">Обратите внимание, что эти функции используют ключи &lt;code&gt;SV*&lt;/code&gt; , что упрощает написание кода расширения, имеющего дело с хэш-структурами. Эти функции также позволяют передавать ключи &lt;code&gt;SV*&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; функций, не заставляя вас связывать ключи (в отличие от предыдущего набора функций).</target>
        </trans-unit>
        <trans-unit id="7cd84224dc690f45347275d943903d70df26fb0c" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;tie&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac690cbf2993a60c5814d129da8fb3bc08b59629" translate="yes" xml:space="preserve">
          <source>Note that these macros will only work together within the</source>
          <target state="translated">Обратите внимание,что эти макросы будут работать вместе только внутри</target>
        </trans-unit>
        <trans-unit id="8a5f32d79f24485d8dc52ccd8880da69d87a4d12" translate="yes" xml:space="preserve">
          <source>Note that these problems should not discourage experimenting, since they have a low probability of affecting small programs.</source>
          <target state="translated">Обратите внимание,что эти проблемы не должны препятствовать экспериментам,так как они имеют низкую вероятность влияния на небольшие программы.</target>
        </trans-unit>
        <trans-unit id="0f02b1ce704f868a5bd6cbc730f85ed167d3d361" translate="yes" xml:space="preserve">
          <source>Note that these routines are</source>
          <target state="translated">Обратите внимание,что эти процедуры</target>
        </trans-unit>
        <trans-unit id="5e158a627cf25fb028df016dfe1afff14abe8a74" translate="yes" xml:space="preserve">
          <source>Note that these statistics are summary only. Actual performance will depend on real hit/miss ratios accessing the hash. If you are concerned by hit ratios you are recommended to &quot;oversize&quot; your hash by using something like:</source>
          <target state="translated">Обратите внимание,что эта статистика является только сводной.Фактическая производительность будет зависеть от реального соотношения хит/мисс доступа к хэшу.Если вас беспокоит соотношение попаданий,рекомендуется &quot;увеличить&quot; размер хэша,используя что-нибудь в этом роде:</target>
        </trans-unit>
        <trans-unit id="614e9c1a8e14a9fc6d986754f7def273a10af2f8" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag is set), as in both cases, 0 is returned, and, depending on the malformation, &lt;code&gt;retlen&lt;/code&gt; may be set to 1. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;s&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt;; if not, the input had an error. Or you can use &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ba985ffd1a15a231f5d43e3ffb4a26ab7bba75" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt; ; if not, the input had an error.</source>
          <target state="translated">Обратите внимание, что этот API требует устранения неоднозначности между успешным декодированием символа &lt;code&gt;NUL&lt;/code&gt; и возвращением ошибки (если не установлен флаг UTF8_CHECK_ONLY), поскольку в обоих случаях возвращается 0. Чтобы устранить неоднозначность, при нулевом возврате проверьте, равен ли также 0 первый байт &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; . Если да, то вход был &lt;code&gt;NUL&lt;/code&gt; ; в противном случае на входе была ошибка.</target>
        </trans-unit>
        <trans-unit id="9e7c1fe94057690a3e15fba2814e3a5b075195c1" translate="yes" xml:space="preserve">
          <source>Note that this a lesser issue now when we do not spawn</source>
          <target state="translated">Обратите внимание,что это меньший вопрос сейчас,когда мы не икрометаем.</target>
        </trans-unit>
        <trans-unit id="b5ca0aab168c321c8270a6107199325edc3cbbd7" translate="yes" xml:space="preserve">
          <source>Note that this behaviour differs from version 1.00 of the Safe module where the root module could be used to change the namespace. That functionality has been withdrawn pending deeper consideration.</source>
          <target state="translated">Обратите внимание,что это поведение отличается от версии 1.00 Safe модуля,где корневой модуль может быть использован для изменения пространства имён.Этот функционал был отозван в ожидании более глубокого рассмотрения.</target>
        </trans-unit>
        <trans-unit id="886c9a49ed86dcbe7c33a66300a271b1c555293b" translate="yes" xml:space="preserve">
          <source>Note that this business of escaping a newline is specific to interactive commands typed into the debugger.</source>
          <target state="translated">Обратите внимание,что этот бизнес экранирования новой строки специфичен для интерактивных команд,вводимых в отладчик.</target>
        </trans-unit>
        <trans-unit id="d9af4c6dbd50132dd9aa57c1076bfc7d75c87275" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . It's meant to be handy for calling from the command line.</source>
          <target state="translated">Обратите внимание, что этот класс также предоставляет (но не экспортирует) функцию Pod :: Simple :: HTMLBatch :: go. По сути, это просто ярлык для &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . Он предназначен для удобного вызова из командной строки.</target>
        </trans-unit>
        <trans-unit id="f83d5136d4b8e93ddca0e990f1293f696287db16" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt;. It's meant to be handy for calling from the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd3cc83f76f664edbfed1f74f0bb7a74cadfcdb" translate="yes" xml:space="preserve">
          <source>Note that this does *not* collapse</source>
          <target state="translated">Обратите внимание,что это не приводит к краху</target>
        </trans-unit>
        <trans-unit id="00224048b57a554f368bf0ab411d2ec7b380142b" translate="yes" xml:space="preserve">
          <source>Note that this does not respect any locale that might be in effect; it matches according to the platform's native character set.</source>
          <target state="translated">Обратите внимание,что при этом не учитывается любая действующая локаль;она совпадает в соответствии с родным набором символов платформы.</target>
        </trans-unit>
        <trans-unit id="c41629303d26db24c4cf7e890ae9d3b978c9901b" translate="yes" xml:space="preserve">
          <source>Note that this example shows the values of the lexicals, whereas the other examples did not (as they're compile-time only).</source>
          <target state="translated">Обратите внимание,что в этом примере показаны значения лексики,в то время как в других примерах-нет (так как они только на этапе компиляции).</target>
        </trans-unit>
        <trans-unit id="750194633912e1b1b2810b4a6624c08076cb7c4d" translate="yes" xml:space="preserve">
          <source>Note that this feature is currently &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt;; using it yields a warning in the &lt;code&gt;experimental::regex_sets&lt;/code&gt; category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">Обратите внимание,что эта функция выполняет</target>
        </trans-unit>
        <trans-unit id="770403ff8ad9becd7464272640adcfe95f14a6a1" translate="yes" xml:space="preserve">
          <source>Note that this function returns FALSE for inputs that would overflow a UV, or have leading zeros. Thus a single &lt;code&gt;0&lt;/code&gt; is accepted, but not &lt;code&gt;00&lt;/code&gt; nor &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;002&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383a0ca4f40d5e081bc8cd1b9b45b6acddf8c873" translate="yes" xml:space="preserve">
          <source>Note that this harness is</source>
          <target state="translated">Обратите внимание,что этот жгут</target>
        </trans-unit>
        <trans-unit id="26765a3c9e68c0777ae5d0fb4a579c61611c0dca" translate="yes" xml:space="preserve">
          <source>Note that this hash does not include numerics (like &quot;64&quot; or &quot;x981c&quot;).</source>
          <target state="translated">Обратите внимание,что этот хэш не включает цифр (например,&quot;64&quot; или &quot;x981c&quot;).</target>
        </trans-unit>
        <trans-unit id="d9c356ba63dd81b549b024d31174e2c723d0a6c7" translate="yes" xml:space="preserve">
          <source>Note that this is a backwards incompatible change from version &lt;code&gt;1.36&lt;/code&gt; and before.</source>
          <target state="translated">Обратите внимание, что это обратно несовместимое изменение по &lt;code&gt;1.36&lt;/code&gt; с версией 1.36 и ранее.</target>
        </trans-unit>
        <trans-unit id="d089b782c3356f4400063cd34b72b66e78bb2e56" translate="yes" xml:space="preserve">
          <source>Note that this is a unary operator, not a list operator.</source>
          <target state="translated">Обратите внимание,что это унарный оператор,а не оператор списка.</target>
        </trans-unit>
        <trans-unit id="dcb3c6a57a75c99d73d6d08c842005a53c2cad92" translate="yes" xml:space="preserve">
          <source>Note that this is an experimental feature which may be changed or removed in a future Perl release.</source>
          <target state="translated">Обратите внимание,что это экспериментальная функция,которая может быть изменена или удалена в будущем релизе Perl.</target>
        </trans-unit>
        <trans-unit id="504d8cb8d0a49d57ae71301eeedf5cb16096e2bb" translate="yes" xml:space="preserve">
          <source>Note that this is not in general possible in shells of more dubious heritage, as the theoretical</source>
          <target state="translated">Отметим,что в целом это невозможно в оболочках более сомнительного наследия,поскольку теоретически</target>
        </trans-unit>
        <trans-unit id="9b1de500fa4baebd7c567a7a827d4c48d84fe735" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">Обратите внимание, что это не то же самое, что &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , которая начинает новую отправку, ограниченную поиском предков текущего класса. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; может возвращаться назад мимо текущего класса - чтобы искать подходящий метод в других предках &lt;code&gt;$self&lt;/code&gt; - тогда как &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; не может.</target>
        </trans-unit>
        <trans-unit id="511522d55453b336eeec0192506af6b8fb160bde" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt;, which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb474ba009e8c7c8d7bdb3779c16f4d2c9b0cba8" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt; -group.</source>
          <target state="translated">Обратите внимание, что это один из редких случаев, когда вы не можете использовать один и тот же шаблон для &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; потому что &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; не может определить счетчик повторов для &lt;code&gt;()&lt;/code&gt; -группы.</target>
        </trans-unit>
        <trans-unit id="31c689cdab9ea9a66fe06d7827f40cae99aad3e2" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; because &lt;code&gt;pack&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt;-group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d289726dbf38f52d7d747a6f498b593946b256" translate="yes" xml:space="preserve">
          <source>Note that this is the</source>
          <target state="translated">Обратите внимание,что это</target>
        </trans-unit>
        <trans-unit id="051c395ae34aa1a11e3b94b0cb470642628b722b" translate="yes" xml:space="preserve">
          <source>Note that this isn't really a word in the English sense; it's just chunks of consecutive non-whitespace characters.</source>
          <target state="translated">Обратите внимание,что это не совсем слово в английском смысле,это просто куски последовательных не белых пробельных символов.</target>
        </trans-unit>
        <trans-unit id="f98a99684b1c3e2bccd26b3c2631a053bdfaf9be" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt; ), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">Обратите внимание, что эта проблема препятствует созданию многих модулей CPAN для Macintosh ( &lt;code&gt;Mac::*&lt;/code&gt; ), поскольку требуемые платформы Apple не обеспечивают поддержку PPC64. Точно так же загрузка из Fink или Darwinports вряд ли обеспечит поддержку 64-битной версии; библиотеки должны быть перестроены из исходного кода с соответствующими флагами компилятора и компоновщика. Для получения дополнительной информации см. Apple</target>
        </trans-unit>
        <trans-unit id="e01d7922e9382b1372af232c43cd56d7c9562fcf" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt;), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf9c28e72f601c60b3c701ee74ca406285e72fe" translate="yes" xml:space="preserve">
          <source>Note that this last example is</source>
          <target state="translated">Обратите внимание,что этот последний пример</target>
        </trans-unit>
        <trans-unit id="d42f0b82dfd8478b8b9451848cff1ed7d60be50b" translate="yes" xml:space="preserve">
          <source>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</source>
          <target state="translated">Обратите внимание,что это означает,что Perl ожидает,что другое программное обеспечение будет работать таким же образом:если Perl был убежден,что STDIN должен быть UTF-8,но STDIN,поступающий от другой команды,не UTF-8,Perl,скорее всего,будет жаловаться на некорректную работу UTF-8.</target>
        </trans-unit>
        <trans-unit id="eb14855fa34c491b4e9b69501367a6f35eac94cc" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt; , etc., to refer to the enclosing pattern's capture groups.) Thus, although</source>
          <target state="translated">Обратите внимание, что это означает, что внутренний шаблон не может ссылаться на группу захвата, определенную снаружи. (Сам кодовый блок может использовать &lt;code&gt;$1&lt;/code&gt; и т. Д. Для ссылки на группы захвата включающего шаблона.) Таким образом, хотя</target>
        </trans-unit>
        <trans-unit id="75120e6f9c48966777ee766b66dc5e5bb92f00ed" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85a4e8b339d0e328effdd49337132425d3cb1dc" translate="yes" xml:space="preserve">
          <source>Note that this method considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, it does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than &lt;code&gt;undef&lt;/code&gt;, in either case. Thus, in general, it cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls &lt;a href=&quot;IO::Socket#shutdown&quot;&gt;&quot;shutdown&quot; in IO::Socket&lt;/a&gt; or &lt;code&gt;close&lt;/code&gt;. Only at that point does this function return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2f7fa1807b6ef282836388add7c29032688f86" translate="yes" xml:space="preserve">
          <source>Note that this method does not write &lt;code&gt;on the fly&lt;/code&gt; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</source>
          <target state="translated">Обратите внимание, что этот метод не пишет &quot; &lt;code&gt;on the fly&lt;/code&gt; ; он по-прежнему считывает все файлы в память перед записью архива. Если это проблема, обратитесь к FAQ ниже.</target>
        </trans-unit>
        <trans-unit id="9ebf1673f6d5cc53332f54347212529a0a096746" translate="yes" xml:space="preserve">
          <source>Note that this method merely returns the comment preceded by a '# '.</source>
          <target state="translated">Обратите внимание,что этот метод просто возвращает комментарий,которому предшествует '#'.</target>
        </trans-unit>
        <trans-unit id="e4bf33faadadb73f5033c17a03e0a21d5d47bf67" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;,&amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">Обратите внимание, что это влияет только на то, как большинство арифметических и реляционных &lt;b&gt;операторов&lt;/b&gt; обрабатывают свои операнды и результаты, а &lt;b&gt;не на то,&lt;/b&gt; как обрабатываются все числа повсюду. В частности, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; означает, что перед вычислением результатов арифметических операторов (+, -, *, /,%, + =, - =, * =, / =,% = и унарный минус) операторы сравнения (&amp;lt;, &amp;lt; =,&amp;gt;,&amp;gt; =, ==,! =, &amp;lt;=&amp;gt;) и поразрядные операторы (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, | =, &amp;amp; =, ^ =, &amp;lt;&amp;lt; =, &amp;gt;&amp;gt; =), дробные части операндов будут обрезаны (или закрыты), и результат также будет обрезан дробной частью. Кроме того, диапазон операндов и результатов ограничен диапазоном знакомых двух дополнительных целых чисел, т.е. - (2 ** 31) .. (2 ** 31-1) на 32-битных архитектурах и - (2 ** 63) .. (2 ** 63-1) на 64-битных архитектурах. Например, этот код</target>
        </trans-unit>
        <trans-unit id="444b0c1a203433a23ae5410357a56dc9fd46182a" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;use integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed01a3c9fe729c5926b4311c21dc0630e4d43559" translate="yes" xml:space="preserve">
          <source>Note that this option alone doesn't cause any debugging information to be output. What it does is stop the normal suppression of execution-related debugging information during the matching portion of the compilation of wildcards. You also have to specify which execution debugging information you want, such as by also including the EXECUTE option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641efca71748ee43843d8c870296735b58cb247a" translate="yes" xml:space="preserve">
          <source>Note that this option is probably not useful when converting multiple POD files at once. The convention for Unix man pages for commands is for the man page title to be in all-uppercase even if the command isn't.</source>
          <target state="translated">Обратите внимание,что эта опция,вероятно,не будет полезна при конвертировании нескольких POD-файлов одновременно.Слово для Unix man-страниц для команд заключается в том,что заголовок man-страницы должен быть в верхнем регистре,даже если это не так.</target>
        </trans-unit>
        <trans-unit id="23d0291a11d0e9160102c369e2e83afde2d6c5ee" translate="yes" xml:space="preserve">
          <source>Note that this option only works with Perl 5.8.4 or better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898ae211ecf9d9481d220ef526611f5faf15a726" translate="yes" xml:space="preserve">
          <source>Note that this section does not document what</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650a0cb19795021c90db4bffb31d952d9b4b0616" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">Обратите внимание,что эта типовая карта не уменьшает счетчик ссылок при возврате AV*.См.также:T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="75948654033e1807460f39019ce055bccbe6d14b" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">Обратите внимание,что эта типовая карта не уменьшает счетчик ссылок при возврате HV*.См.также:T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4c5b3cb2ecd59af3fa9332d1a075ffadbd08c0cb" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning the reference to an SV*. See also: T_SVREF_REFCOUNT_FIXED</source>
          <target state="translated">Обратите внимание,что эта типовая карта не уменьшает счетчик ссылок при возврате ссылки на SV*.См.также:T_SVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="fdb88d672a97dbd887a0e264f45a135e237c14a4" translate="yes" xml:space="preserve">
          <source>Note that this variable was added in Perl 5.14.0. If you want to detect the global destruction phase on older versions of Perl, you can use the &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; module on CPAN.</source>
          <target state="translated">Обратите внимание, что эта переменная была добавлена ​​в Perl 5.14.0. Если вы хотите обнаружить фазу глобального уничтожения в старых версиях Perl, вы можете использовать модуль &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; на CPAN.</target>
        </trans-unit>
        <trans-unit id="79cbc4907067b711c2733dabb85b47c17c625682" translate="yes" xml:space="preserve">
          <source>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</source>
          <target state="translated">Обратите внимание,что этот номер версии не совпадает с номером версии самого модуля Storable.Например,Storable v0.7 создает файлы в формате v2.0 и Storable v2.15 создает файлы в формате v2.7.Номер версии файла увеличивается только при добавлении дополнительных возможностей,которые могут запутать старые версии модуля.</target>
        </trans-unit>
        <trans-unit id="c30cc57c265bdbcc01b87c7faff90971cd8cbcd5" translate="yes" xml:space="preserve">
          <source>Note that this will not apply to distributions that failed tests because of missing dependencies. Also, tests can be run regardless of the history using &quot;force&quot;.</source>
          <target state="translated">Обратите внимание,что это не относится к дистрибутивам,которые не прошли тестирование из-за пропущенных зависимостей.Также,тесты могут быть запущены независимо от истории с использованием &quot;силы&quot;.</target>
        </trans-unit>
        <trans-unit id="4bcf77d3862c68d316c827809d40fa450ae96c79" translate="yes" xml:space="preserve">
          <source>Note that this will not work on uninstalled perls when called with &lt;code&gt;-I/path/to/uninstalled/perl/lib&lt;/code&gt;, but it works when that path is in &lt;code&gt;$PERL5LIB&lt;/code&gt; or in &lt;code&gt;$PERL5OPT&lt;/code&gt;, as paths passed using &lt;code&gt;-I&lt;/code&gt; are not known when the &lt;code&gt;-V&lt;/code&gt; information is collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129dbf47ba2ec65b5d9ac83fd612d686af9cd750" translate="yes" xml:space="preserve">
          <source>Note that this will produce something similar, but it's much harder to read:</source>
          <target state="translated">Обратите внимание,что это даст нечто похожее,но это намного сложнее для чтения:</target>
        </trans-unit>
        <trans-unit id="b8bf897da733e3c7fd8c9b9e480c0bb39918d58f" translate="yes" xml:space="preserve">
          <source>Note that this works only when you &lt;code&gt;decode&lt;/code&gt;. You can set incompatible boolean objects (like &lt;a href=&quot;boolean&quot;&gt;boolean&lt;/a&gt;), but when you &lt;code&gt;encode&lt;/code&gt; a data structure with such boolean objects, you still need to enable &lt;code&gt;convert_blessed&lt;/code&gt; (and add a &lt;code&gt;TO_JSON&lt;/code&gt; method if necessary).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76667870087c43a89a0c134d31da84f873df4c85" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">Обратите внимание, что для создания содержимого &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; должен быть установлен модуль IO :: Compress :: Bzip2 .</target>
        </trans-unit>
        <trans-unit id="c112c0c0f309f422ad0d8ea094e2f892edb8359d" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Bzip2 content when &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is not available.</source>
          <target state="translated">Обратите внимание, что для создания содержимого &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; должен быть установлен модуль IO :: Compress :: Bzip2 . Если вы попытаетесь создать содержимое Bzip2, когда &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; недоступен, произойдет фатальная ошибка .</target>
        </trans-unit>
        <trans-unit id="91dea059c3c6adecb3e060a72157c015c80d8709" translate="yes" xml:space="preserve">
          <source>Note that to create LZMA content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">Обратите внимание, что для создания содержимого LZMA должен быть установлен модуль &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d4a2616c449298e5f9b3c703f0555b52ba58730" translate="yes" xml:space="preserve">
          <source>Note that to create Lzma content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Lzma content when &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; is not available.</source>
          <target state="translated">Обратите внимание, что для создания содержимого &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; должен быть установлен модуль IO :: Compress :: Lzma . Если вы попытаетесь создать содержимое Lzma, когда &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; недоступен, произойдет фатальная ошибка .</target>
        </trans-unit>
        <trans-unit id="59026c8cb18df6e69670873afd609b7b5991b245" translate="yes" xml:space="preserve">
          <source>Note that to delete a breakpoint you use 'B'.</source>
          <target state="translated">Обратите внимание,что для удаления точки останова вы используете 'B'.</target>
        </trans-unit>
        <trans-unit id="ccec21a98f6b093bde7ead086f9b2aa6d9fa5cbe" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что для завершения обработки опций по-прежнему требуется двойной дефис &lt;code&gt;--&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d940f3704d17dd3194fc775422b4ac6a56659d1f" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1f1b6c5624a2d3ed9722ba6d811a877dbe016a" translate="yes" xml:space="preserve">
          <source>Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</source>
          <target state="translated">Обратите внимание,что превращение этого атрибута в true не подавит один или два вида жалоб на редко встречающиеся неустранимые ошибки.</target>
        </trans-unit>
        <trans-unit id="8c769b2bb4c9d14e0051897b1dc06f73914041f2" translate="yes" xml:space="preserve">
          <source>Note that under &lt;code&gt;/i&lt;/code&gt;, a few single characters match two or three other characters. This makes them variable length, and the 255 length applies to the maximum number of characters in the match. For example &lt;code&gt;qr/\N{LATIN SMALL LETTER SHARP S}/i&lt;/code&gt; matches the sequence &lt;code&gt;&quot;ss&quot;&lt;/code&gt;. Your lookbehind assertion could contain 127 Sharp S characters under &lt;code&gt;/i&lt;/code&gt;, but adding a 128th would generate a compilation error, as that could match 256 &lt;code&gt;&quot;s&quot;&lt;/code&gt; characters in a row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b40c66bbd4f3571d75ea521000a6cee32083010" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; depends on the &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; C library function. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the &lt;a href=&quot;posix#open&quot;&gt;&lt;code&gt;POSIX::open&lt;/code&gt;&lt;/a&gt; function. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f7379eb3bd6961a9d597915f1b15a614c4f1c6" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db90d2a3a43a0d1ae1c73a0ecadf4c50a061235" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">Обратите внимание, что в Perls старше 5.8.0 Perl использует fdopen () стандартной библиотеки C для реализации функции &lt;code&gt;=&lt;/code&gt; . Во многих системах Unix fdopen () не работает, когда дескрипторы файлов превышают определенное значение, обычно 255. Для Perls 5.8.0 и более поздних версий PerlIO (чаще всего) используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ab1035410dccd2a93f4a5e17c32c7a15d00a2658" translate="yes" xml:space="preserve">
          <source>Note that under Win32</source>
          <target state="translated">Обратите внимание,что под Win32</target>
        </trans-unit>
        <trans-unit id="914bcfd8302ee9c0b531fac815eb7bd7d964c235" translate="yes" xml:space="preserve">
          <source>Note that under bigint, the result is truncated to an integer.</source>
          <target state="translated">Обратите внимание,что при значении bigint результат усекается до целого числа.</target>
        </trans-unit>
        <trans-unit id="57f113ec30505dad704cf4b4934d930e547970b7" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; , and so on.</source>
          <target state="translated">Обратите внимание, что в некоторых системах, таких как OS / 2, могут быть разные варианты исполняемых файлов Perl, некоторые из которых могут поддерживать fork, а некоторые нет. Попробуйте изменить имя, которое вы называете Perl, на &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="beba1d81b386ec1f5c90abc173f3ea4f03db2d8a" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt;, &lt;code&gt;perl__&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3fb4d37b79c5b47a3b48e544166fc16ead2f30" translate="yes" xml:space="preserve">
          <source>Note that unfortunately none of the above constants are guaranteed to be available on a particular platform. To be on the safe side you can wrap the import in an eval like this:</source>
          <target state="translated">Обратите внимание,что,к сожалению,ни одна из вышеперечисленных констант не гарантируется на определенной платформе.Чтобы быть на всякий случай,вы можете обернуть импорт в оценочный документ,подобный этому:</target>
        </trans-unit>
        <trans-unit id="b70409449e4cf24aa93c5134b0fc7650b311f3ce" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">Обратите внимание, что в отличие от &lt;code&gt;\s&lt;/code&gt; (и &lt;code&gt;\d&lt;/code&gt; и &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; и &lt;code&gt;\v&lt;/code&gt; всегда соответствуют одним и тем же символам, независимо от других факторов, таких как активный языковой стандарт или то, имеет ли исходная строка формат UTF-8.</target>
        </trans-unit>
        <trans-unit id="d708883d1ad8d31236c3f53f155ad26ec2c29df3" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt;), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772ce79a861dd3251a8090941fe7f7a3f1e9ae60" translate="yes" xml:space="preserve">
          <source>Note that unlike most other regex magic variables there is no single letter equivalent to &lt;code&gt;@{^CAPTURE}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3b99648e034c07d6ccefb2454f1a213adb3a01" translate="yes" xml:space="preserve">
          <source>Note that version 1.00 of the Safe module supported a second optional parameter, MASK. That functionality has been withdrawn pending deeper consideration. Use the permit and deny methods described below.</source>
          <target state="translated">Обратите внимание,что версия 1.00 модуля Safe поддерживала второй дополнительный параметр,MASK.Этот функционал был отозван в ожидании более глубокого рассмотрения.Используйте методы разрешения и отказа,описанные ниже.</target>
        </trans-unit>
        <trans-unit id="c573631a77e48c40f9d95496d1ab64657ba98bf8" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">Обратите внимание , что теперь мы должны передать значения задействуя в качестве ссылки на массив, так как &lt;code&gt;autotie&lt;/code&gt; механизм проходит &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; список аргументов в виде списка (как в примере Tie :: Whatever),</target>
        </trans-unit>
        <trans-unit id="5b3c2527a47a822b83bab8f40e829ac7eb6aa7b2" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;tie&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97433e963bcde523d9d0fce2f4cd1302dfe4a201" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">Обратите внимание, что когда указана форма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , которая не включает все категории, Perl игнорирует исключенные категории.</target>
        </trans-unit>
        <trans-unit id="5b47f718523df526f757f6266d1dae38d1cc63ec" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;use locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50a1c7dfac9f6431a51ba8239dc629a049684b8" translate="yes" xml:space="preserve">
          <source>Note that when a module installs from CPAN to a core library directory rather than the site library directories, the user gains no protection from having installed it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5903fec6aa5f11cb69596fd7a3ca663ff0e5fa7" translate="yes" xml:space="preserve">
          <source>Note that when outputting to a file with streaming mode disabled (&lt;code&gt;Stream&lt;/code&gt; is 0), the output file must be seekable.</source>
          <target state="translated">Обратите внимание, что при выводе в файл с отключенным потоковым режимом ( &lt;code&gt;Stream&lt;/code&gt; равен 0) выходной файл должен быть доступен для поиска.</target>
        </trans-unit>
        <trans-unit id="7344bc816db754cd590cf06e917e5573598a9b73" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">Обратите внимание, что когда источники zlib собираются вместе с этим модулем, флаги &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; (биты 24, 25 и 26) следует игнорировать.</target>
        </trans-unit>
        <trans-unit id="726c87af26a5b86094bbbbcff91a0a7370ca0001" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;sprintf&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5df280c1345062d47399d4030c040fff592e61" translate="yes" xml:space="preserve">
          <source>Note that when there is only a section argument the URL will simply be a link to a section in the current document.</source>
          <target state="translated">Обратите внимание,что при наличии только аргумента секции URL будет просто ссылкой на секцию в текущем документе.</target>
        </trans-unit>
        <trans-unit id="71260102fd6d68816796fad6d6c8b41eba351c69" translate="yes" xml:space="preserve">
          <source>Note that when using perl in the default build configuration on Win32 (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the main interpreter will update the process environment seen by strftime.</source>
          <target state="translated">Обратите внимание,что при использовании perl в конфигурации сборки по умолчанию на Win32 (а именно,когда perl собирается с PERL_IMPLICIT_SYS),каждый интерпретатор perl поддерживает свою собственную копию окружения,и только основной интерпретатор будет обновлять процессное окружение,видимое в strftime.</target>
        </trans-unit>
        <trans-unit id="2effebabf11283b202bbac0c8af96deb9da5f75f" translate="yes" xml:space="preserve">
          <source>Note that when using threads and in Linux this is &lt;b&gt;not&lt;/b&gt; a good way to exit a thread because in Linux processes and threads are kind of the same thing (Note: while this is the situation in early 2003 there are projects under way to have threads with more POSIXly semantics in Linux). If you want not to return from a thread, detach the thread.</source>
          <target state="translated">Обратите внимание, что при использовании потоков и в Linux это &lt;b&gt;не&lt;/b&gt; лучший способ выйти из потока, потому что в Linux процессы и потоки - это одно и то же (Примечание: хотя это и была ситуация в начале 2003 г., в настоящее время ведутся проекты с потоками с больше семантики POSIXly в Linux). Если вы не хотите возвращаться из нитки, отсоедините нить.</target>
        </trans-unit>
        <trans-unit id="4736a205597baa102d5326de4253133a227c54d5" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt; or &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; filehandle instead.</source>
          <target state="translated">Обратите внимание, что когда вы передаете дескриптор файла, аргумент сжатия игнорируется, так как все файлы дословно выводятся на ваш дескриптор файла. Если вы хотите включить сжатие с помощью дескрипторов файлов, используйте вместо них дескрипторы файлов &lt;code&gt;IO::Zlib&lt;/code&gt; или &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ec13b11833cba251c4e9511d82658d6fc77550f" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt;, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or &lt;code&gt;IO::Compress::Xz&lt;/code&gt; filehandle instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870efa0c38496f8567ab5707b290598c28081f5a" translate="yes" xml:space="preserve">
          <source>Note that where possible, values should be saved in the context struct rather than on the save stack; it's much faster that way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf20737dd41f077e46c31d590a5ed13707c1390" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec466d7589681ffa02822a2ed4bde47bc9a77f7" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что перезапуск &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; после сигналов (скажем, SIGALRM) зависит от реализации. См. Также &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; для получения информации о переносимости &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="948671b067e6b6895231193e86d7353898979d1b" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что перезапуск &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; после сигналов (скажем, SIGALRM) зависит от реализации. См. Также &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; для получения информации о переносимости &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ffc7e69e46e535688eedc16caabf4a74055bdca" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;prove&lt;/code&gt; accepts a list of tests (or things to be tested), &lt;code&gt;new&lt;/code&gt; has a fairly rich set of arguments. You'll probably want to read over this code carefully to see how all of them are being used.</source>
          <target state="translated">Обратите внимание, что в то время как &lt;code&gt;prove&lt;/code&gt; принимает список тестов (или вещей, которые нужно протестировать), &lt;code&gt;new&lt;/code&gt; имеет довольно богатый набор аргументов. Вы, вероятно, захотите внимательно прочитать этот код, чтобы увидеть, как все они используются.</target>
        </trans-unit>
        <trans-unit id="50e7deab8f4fd86f8154084a7e3b56909e616473" translate="yes" xml:space="preserve">
          <source>Note that while the above category system is presently a strict hierarchy, this should not be assumed.</source>
          <target state="translated">Обратите внимание,что хотя в настоящее время система вышеуказанных категорий представляет собой строгую иерархию,это не следует предполагать.</target>
        </trans-unit>
        <trans-unit id="bc9931d84d19856544f694976f9d6846875a28cb" translate="yes" xml:space="preserve">
          <source>Note that while threads themselves are separate execution threads and Perl data is thread-private unless explicitly shared, the threads can affect process-scope state, affecting all the threads.</source>
          <target state="translated">Обратите внимание,что хотя потоки сами по себе являются отдельными потоками выполнения,а данные Perl являются потоково-частными,если они явно не разделяются,они могут влиять на состояние процесса,затрагивая все потоки.</target>
        </trans-unit>
        <trans-unit id="1aeee605f9778048bf8180ea5497c85eb816a43f" translate="yes" xml:space="preserve">
          <source>Note that while we obtained this value using a nice little script, there is no simple way to</source>
          <target state="translated">Обратите внимание,что хотя мы и получили это значение с помощью хорошего маленького скрипта,нет простого способа</target>
        </trans-unit>
        <trans-unit id="91f5f2f1e7150921d4bad701418dc42005b9e8df" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7977096f1b31f6699d5f208fb012da3a5261f7ca" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">Обратите внимание, что со списком в скобках &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; можно использовать в качестве фиктивного заполнителя, например, чтобы пропустить присвоение начальных значений:</target>
        </trans-unit>
        <trans-unit id="f05ed1d19fb4f3d163934a654b623969a521af79" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">Обратите внимание, что со списком в скобках &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; можно использовать в качестве фиктивного заполнителя, например, чтобы пропустить присвоение начальных значений:</target>
        </trans-unit>
        <trans-unit id="f837139e0f9184e4fee4005308a9ebc6c5173a19" translate="yes" xml:space="preserve">
          <source>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</source>
          <target state="translated">Обратите внимание,что во всех вышеперечисленных случаях можно определить,какой тип &quot;=over&quot; ...&quot;=назад&quot;,изучив первый (не &quot;=вырезать&quot;,не &quot;=под&quot;)абзац под после команды &quot;=over&quot;.</target>
        </trans-unit>
        <trans-unit id="47d723b6fa427f34bf483595a539dcd989378967" translate="yes" xml:space="preserve">
          <source>Note that write is</source>
          <target state="translated">Обратите внимание,что запись</target>
        </trans-unit>
        <trans-unit id="83605b35f7f66a38c8e887a3f52c350d6d00fd1c" translate="yes" xml:space="preserve">
          <source>Note that you</source>
          <target state="translated">Обратите внимание,что вы</target>
        </trans-unit>
        <trans-unit id="f571df233f4fa852ab6d69ef3a354636c953afea" translate="yes" xml:space="preserve">
          <source>Note that you &lt;b&gt;must&lt;/b&gt; quote the version when writing an alpha Decimal version. The stringified form of Decimal versions will always be the same string that was used to initialize the version object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6cd8d5f09bd8fe8bd4f6cd6ec9d1cc03592811" translate="yes" xml:space="preserve">
          <source>Note that you always have to rethrow an exception that has been caught. Using these macros, it is not possible to just catch the exception and ignore it. If you have to ignore the exception, you have to use the &lt;code&gt;call_*&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что вы всегда должны повторно генерировать обнаруженное исключение. Используя эти макросы, невозможно просто поймать исключение и проигнорировать его. Если вам нужно игнорировать исключение, вы должны использовать функцию &lt;code&gt;call_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="294ab6e75ddb8b55c12bca78ca4c1964234fee2f" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt; . For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">Обратите внимание, что вы также можете применить два или несколько фильтров одного типа в одном &lt;code&gt;FILTER_ONLY&lt;/code&gt; . Например, вот простой макрос-препроцессор, который применяется только в регулярных выражениях, с последним проходом отладки, который печатает результирующий исходный код:</target>
        </trans-unit>
        <trans-unit id="2ed5dd8db2d6301ae073b216ad36ce2358ae0947" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt;. For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7b682995e33f0fbc55867b39c415016eb6e0ab" translate="yes" xml:space="preserve">
          <source>Note that you can also call &lt;code&gt;batch_convert&lt;/code&gt; as a class method, like so:</source>
          <target state="translated">Обратите внимание, что вы также можете вызвать &lt;code&gt;batch_convert&lt;/code&gt; как метод класса, например:</target>
        </trans-unit>
        <trans-unit id="fd91cd131ba58a9a28d1ab6ce3c7b99f825d3515" translate="yes" xml:space="preserve">
          <source>Note that you can also use:</source>
          <target state="translated">Обратите внимание,что вы также можете использовать:</target>
        </trans-unit>
        <trans-unit id="7f681263fb98ec8c6eb8d4798ad8027fd4826097" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt; , a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">Обратите внимание , что вы можете в данный момент &lt;b&gt;не&lt;/b&gt; передать &lt;code&gt;gzip&lt;/code&gt; сжатого дескриптора файла, который не открыт &lt;code&gt;IO::Zlib&lt;/code&gt; , в &lt;code&gt;bzip2&lt;/code&gt; сжатом дескрипторе, который не открыт с &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , ни строку , содержащую полную информацию архива (либо сжатый или несжатый). Это полезные функции, но в настоящее время они не реализованы. См. Раздел &lt;code&gt;TODO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36599b3f8142ec45ea2057810c7d1951232a084e" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt;, a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt;, a &lt;code&gt;xz&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::UnXz&lt;/code&gt;, nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d20f2cbb1dd523835c53fe8971ba143f49fe81" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;&quot;User-Defined Character Properties&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e3d8e2902a442515aac1df82a9b27598246cd6" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что вы можете определять свои собственные свойства; см. &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;Свойства определяемых пользователем символов в perlunicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78e5ead015db87b26d2638e6d6d6c409fabb1756" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt;. So &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">Обратите внимание, что вы можете отличить URL-ссылки от всего остального по тому факту, что они соответствуют &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt; . Итак, &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; - это URL, а &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="64a115a0f7c10604758c941480143a80f74b2845" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;m/\A\w+:[^:\s]\S*\z/&lt;/code&gt;. So &lt;code&gt;L&amp;lt;http://www.perl.com&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5601b7465138e046c297f9bd7f032a15e613deb" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using &lt;code&gt;binmode()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe488ce16efed40af87572587352aab8acda941" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using C</source>
          <target state="translated">Обратите внимание,что вы можете изменить кодировку файла,открытого с помощью File::Temp,также используя C</target>
        </trans-unit>
        <trans-unit id="11456d05bc1241402ca1d0ee0660f0d072ab6bd4" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;code&gt;ls&lt;/code&gt; command to get this path listed.</source>
          <target state="translated">Обратите внимание, что вы можете использовать команду &lt;code&gt;ls&lt;/code&gt; , чтобы получить этот путь в списке.</target>
        </trans-unit>
        <trans-unit id="a185692d5c427a3444515426bf12dadcf9d46376" translate="yes" xml:space="preserve">
          <source>Note that you can use this to nest &quot;todo&quot; tests</source>
          <target state="translated">Обратите внимание,что вы можете использовать это для гнездования &quot;todo&quot; тесты</target>
        </trans-unit>
        <trans-unit id="47332c504fbc5ef10c78203997d49e50906b8018" translate="yes" xml:space="preserve">
          <source>Note that you can't reliably block or unblock a signal from its own signal handler if you're using safe signals. Other signals can be blocked or unblocked reliably.</source>
          <target state="translated">Обратите внимание,что вы не можете надежно заблокировать или разблокировать сигнал от собственного обработчика сигналов,если вы используете безопасные сигналы.Другие сигналы могут быть надежно заблокированы или разблокированы.</target>
        </trans-unit>
        <trans-unit id="6eb3e27a2f3b6ca32cee54a3ce38dc4afb062aed" translate="yes" xml:space="preserve">
          <source>Note that you cannot do (de)composition and casing based solely on the</source>
          <target state="translated">Обратите внимание,что вы не можете сделать (де)композицию и оболочку,основанную исключительно на</target>
        </trans-unit>
        <trans-unit id="87645c57d8e0d5210e8d3327ae60dc3fe4c988b7" translate="yes" xml:space="preserve">
          <source>Note that you cannot explicitly unlock a variable; you can only wait for the lock to go out of scope. This is most easily accomplished by locking the variable inside a block.</source>
          <target state="translated">Обратите внимание,что вы не можете явно разблокировать переменную;вы можете только ждать,пока блокировка выйдет за пределы области видимости.Это легче всего сделать,заблокировав переменную внутри блока.</target>
        </trans-unit>
        <trans-unit id="34d896b03c45dc20f0fdc261eccf832e601b1f41" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt; -ness&quot; with</source>
          <target state="translated">Обратите внимание, что вы не можете проверить &quot; &lt;code&gt;NaN&lt;/code&gt; - способность&quot; с</target>
        </trans-unit>
        <trans-unit id="46d548823c2cd0fd3c7dcc027abf5e4fd2f7c713" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt;-ness&quot; with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b60fe993473449a8705a6ef4eab6f9f10003061" translate="yes" xml:space="preserve">
          <source>Note that you cannot use tags in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">Обратите внимание,что нельзя использовать теги @ЭКСПОРТ или @ЭКСПОРТ_ОК.</target>
        </trans-unit>
        <trans-unit id="c1c43451d9784c36057c8528c7269957014b039f" translate="yes" xml:space="preserve">
          <source>Note that you do not have to use wildcards. You can specify explicitly which subdirectories to run tests in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbfbe6c89dd9e56f5bfaf163b06f453c16310bb" translate="yes" xml:space="preserve">
          <source>Note that you don't (re-)specify the method name. It forces you to always use the same method name as the method you started in.</source>
          <target state="translated">Обратите внимание,что вы не (повторно)указываете имя метода.Это заставляет вас всегда использовать одно и то же имя метода,с которого вы начали.</target>
        </trans-unit>
        <trans-unit id="1110cd59b64cb9b7410432e108a9ed2c0c79bda1" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; yourself since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765ef1a0a25cf74eb1b9c1fc6e25a760175b0c75" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">Обратите внимание, что вы не можете обрабатывать ошибки &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; таким образом с помощью дескриптора файла &lt;code&gt;ARGV&lt;/code&gt; . В этом случае вам нужно открыть каждый элемент &lt;code&gt;@ARGV&lt;/code&gt; самостоятельно, поскольку &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; обрабатывает &lt;code&gt;ARGV&lt;/code&gt; по- разному.</target>
        </trans-unit>
        <trans-unit id="1d0c63b615c2a51e338a797bd40525e8af9c8f78" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">Обратите внимание, что вы не можете обрабатывать ошибки &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; таким образом с помощью дескриптора файла &lt;code&gt;ARGV&lt;/code&gt; . В этом случае вам нужно открыть каждый элемент &lt;code&gt;@ARGV&lt;/code&gt; самостоятельно, поскольку &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; обрабатывает &lt;code&gt;ARGV&lt;/code&gt; по- разному.</target>
        </trans-unit>
        <trans-unit id="ef1cce341436113e5004762f8ac2a05ec7a6cdad" translate="yes" xml:space="preserve">
          <source>Note that you may have things stored in a lexicon besides just phrases for output: for example, if your program takes input from the keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You probably also need to know what the equivalents of the answers &quot;y&quot; and &quot;n&quot; are. You can store that information in the lexicon (say, under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where &quot;~&quot; is just an ad-hoc character meant to indicate to programmers/translators that these are not phrases for output).</source>
          <target state="translated">Обратите внимание,что вы можете хранить вещи в лексиконе,кроме фраз для вывода:например,если ваша программа принимает ввод с клавиатуры,задавая вопрос &quot;(Y/N)&quot;,вы,вероятно,должны знать,что эквивалент &quot;Y[es]/N[o]&quot; на любом языке.Скорее всего,вам также нужно знать,каков эквивалент ответов &quot;y&quot; и &quot;n&quot;.Вы можете хранить эту информацию в лексиконе (скажем,под клавишами &quot;~answer_y&quot; и &quot;~answer_n&quot;,а длинные формы &quot;~answer_yes&quot; и &quot;~answer_no&quot;,где &quot;~&quot;-это просто специальный символ,предназначенный для указания программистам/переводчикам,что это не фразы для вывода).</target>
        </trans-unit>
        <trans-unit id="f229bb516b77586e7a9a248bf3e0f062f311444b" translate="yes" xml:space="preserve">
          <source>Note that you may mix directories and (non-directory) files in the list of directories to be searched by the &lt;code&gt;wanted()&lt;/code&gt; function.</source>
          <target state="translated">Обратите внимание, что вы можете смешивать каталоги и (не каталоги) файлы в списке каталогов, в которых будет выполняться поиск с помощью функции &lt;code&gt;wanted()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cfd4a087008bc37d07992fd270addb262fb108e" translate="yes" xml:space="preserve">
          <source>Note that you might find it useful in some cases to override the &lt;code&gt;maketext&lt;/code&gt; method with an &quot;after method&quot;, if you want to translate encodings, or even scripts:</source>
          <target state="translated">Обратите внимание, что в некоторых случаях может оказаться полезным переопределить метод &lt;code&gt;maketext&lt;/code&gt; с помощью &amp;laquo;метода после&amp;raquo;, если вы хотите перевести кодировки или даже сценарии:</target>
        </trans-unit>
        <trans-unit id="253cba6289667637c7fd05a73ad1fdc58ca96c20" translate="yes" xml:space="preserve">
          <source>Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.</source>
          <target state="translated">Обратите внимание,что вы должны указать Unix путь для $new_name,так как по стандарту tar все файлы в архиве должны быть Unix пути.</target>
        </trans-unit>
        <trans-unit id="af5d3ffce4bc0322633d2e85550797429ad732a8" translate="yes" xml:space="preserve">
          <source>Note that you need to install the Module::Signature module to perform this operation.</source>
          <target state="translated">Обратите внимание,что для выполнения этой операции необходимо установить модуль Module::Signature.</target>
        </trans-unit>
        <trans-unit id="349c9f55c28f43dcb8274d29802632751096cca6" translate="yes" xml:space="preserve">
          <source>Note that you should load this module</source>
          <target state="translated">Обратите внимание,что вы должны загрузить этот модуль</target>
        </trans-unit>
        <trans-unit id="50670d23899cdfce7f241f0aebbebf124020da97" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">Обратите внимание: поскольку &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; перехватывает фатальные ошибки, он полезен для определения того, реализована ли конкретная функция (например, &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ). Это также механизм перехвата исключений Perl, в котором оператор die используется для генерации исключений.</target>
        </trans-unit>
        <trans-unit id="b4ffd3921a8026663ffc09712b83a83c559f1527" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">Обратите внимание: поскольку &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; перехватывает фатальные ошибки, он полезен для определения того, реализована ли конкретная функция (например, &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ). Это также механизм перехвата исключений Perl, в котором оператор die используется для генерации исключений.</target>
        </trans-unit>
        <trans-unit id="891df8b540bc28be318d138e0d3e28e333361aa1" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;eval&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;a href=&quot;#socket-SOCKET%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#symlink-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;symlink&lt;/code&gt;&lt;/a&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; operator is used to raise exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5209cab95dd7fa5e49fd362ada61a9529eae4cb7" translate="yes" xml:space="preserve">
          <source>Note that, because the &lt;code&gt;Cycle&lt;/code&gt; attribute receives its arguments in the &lt;code&gt;$data&lt;/code&gt; variable, if the attribute is given a list of arguments, &lt;code&gt;$data&lt;/code&gt; will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</source>
          <target state="translated">Обратите внимание: поскольку атрибут &lt;code&gt;Cycle&lt;/code&gt; получает свои аргументы в переменной &lt;code&gt;$data&lt;/code&gt; , если атрибуту задан список аргументов, &lt;code&gt;$data&lt;/code&gt; будет состоять из единственной ссылки на массив; в противном случае он будет состоять непосредственно из одного аргумента. Поскольку Tie :: Cycle требует, чтобы его циклические значения передавались как ссылка на массив, это означает, что нам нужно обернуть аргументы, не являющиеся ссылками на массив, в конструктор массива:</target>
        </trans-unit>
        <trans-unit id="634d31438b7b96505dfbaf20bfb6d24a32edebe9" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что для исторической совместимости вы также можете использовать &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; вместо &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efb52146528e00d45c6657da7bafa7f9366f782d" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc33ef9021f54e035b56392220cb3acd2d2873be" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; , and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">Обратите внимание, что если у вас есть опции &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; и &lt;code&gt;all&lt;/code&gt; и включена auto_abbrev, возможные аргументы и настройки опции:</target>
        </trans-unit>
        <trans-unit id="49deca6d624d23372bddba3920f15c27d6789299" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt;, and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35db5062a8071a77478be258b823dc93b2df8d08" translate="yes" xml:space="preserve">
          <source>Note that, if you wish to run Configure non-interactively (see the INSTALL document for details), to have it select the correct hint file, you'll need to provide the argument -Dhintfile=riscos on the Configure command-line.</source>
          <target state="translated">Обратите внимание,что если вы хотите запустить программу Configure не интерактивно (подробнее см.документ INSTALL),чтобы она выбрала правильный hint-файл,вам нужно указать аргумент -Dhintfile=riscos в командной строке Configure.</target>
        </trans-unit>
        <trans-unit id="8223fdc89d45104614b40e3adc04b113ea1e11a1" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict
vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что если ваш код работает в соответствии с рекомендуемой &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars , вам нужно будет объявить эти переменные пакета с помощью &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="399039fd0a4c09c727bec9d6e24cc011d4967d80" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;use strict vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;our&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b910d090e427c58d2dd17debf4a1b8bec005d534" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; , failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">Обратите внимание на то, что, в отличие от &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;unless&lt;/code&gt; , не удалось, &lt;code&gt;when&lt;/code&gt; операторы всегда вычисляют пустой список.</target>
        </trans-unit>
        <trans-unit id="b41c93e43651e0e37405584834ec3d27a0bc44f8" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;, failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd6a1e156c7625206e1247c798d73aecaea5a68" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-hexadecimal up to the ending brace is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903c4c2bcdceef7b085f257005c8eb256d0f0ea7" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-octal up to the ending brace is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7888ceb1fb70ed4eb88480b31893c674d725b49f" translate="yes" xml:space="preserve">
          <source>Note the</source>
          <target state="translated">Обратите внимание на</target>
        </trans-unit>
        <trans-unit id="b803d84dee50e438348a270e8179c619e96897b0" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt; s are all 8 bytes. :-)]</source>
          <target state="translated">Обратите внимание на &lt;code&gt;!&lt;/code&gt; после &lt;code&gt;l&lt;/code&gt; : мы хотим убедиться, что мы упаковываем длинное целое число, поскольку оно скомпилировано нашим компилятором C. И даже сейчас это будет работать только для платформ, где компилятор выравнивает вещи, как указано выше. И у кого-то где-то есть платформа, а там ее нет. [Вероятно, Cray, где &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; - 8 байтов. :-)]</target>
        </trans-unit>
        <trans-unit id="0e14a4a995907061486f3bd76c1f023bc121f4f5" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt;: We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt;s, &lt;code&gt;int&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt;s are all 8 bytes. :-)]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b281c2225ddfa8f6c2dd45449bba50edd2d3238" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt; . Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;$]&lt;/code&gt; в приведенном выше значении не является буквальным. Замените любую версию perl, которую вы хотите использовать для этой записи, например &lt;code&gt;5.6.0&lt;/code&gt; . Пути должны быть разделены точкой с запятой, как обычно в Windows.</target>
        </trans-unit>
        <trans-unit id="99261696a47484abd841ec0d1ec91dfef269c276" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt;. Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b760e9a6cdd73c2d052d5f85b1252a43b431d01a" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; expression is surrounded by &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate':</source>
          <target state="translated">Обратите внимание, что выражение &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; заключено в &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt; . Идея, лежащая в основе этого, та же, что и в классической идиоме, которая заставляет &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; &amp;laquo;интерполировать&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="d4596391d7dda5f4358c63110663675e031494da" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt; , being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; ), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">Обратите внимание на &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; s:, где автогенерация приводит к тому, что метод стандартного оператора, который не изменяет ни один из его операндов, например &lt;code&gt;-&lt;/code&gt; , используется для реализации оператора, который изменяет операнд (&amp;laquo;мутаторы&amp;raquo;: здесь &lt;code&gt;--&lt;/code&gt; и &lt;code&gt;-=&lt;/code&gt; ), Perl передает undef в качестве третьего аргумента. Это по-прежнему оценивается как ЛОЖЬ, что соответствует тому факту, что операнды не были переставлены местами, но дает подпрограмме возможность изменить свое поведение в этих случаях.</target>
        </trans-unit>
        <trans-unit id="200da24930e3f664e651210aeef65207c51b5b78" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;tr//&lt;/code&gt; expression is surrounded by &lt;code&gt;qq{}&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;tr///&lt;/code&gt; 'interpolate':</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7ea810ebe5fef24b0b382427a65305a168d9de" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;undef&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt;, being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt;), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db05bb20e1742aeb610b95cb1ced4c32c7213bb5" translate="yes" xml:space="preserve">
          <source>Note the API instability warning in &lt;a href=&quot;#setpayload&quot;&gt;&quot;setpayload&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c6b44fb15bcf48412bfa33391fc2030093296e" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;a href=&quot;#reverse-LIST&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt; to do the reverse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e6d5e5eedfcc869e45b8ad3dc4833107e51623" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">Обратите внимание, что СПИСОК добавляется целиком, а не по одному элементу за раз, поэтому добавленные элементы остаются в том же порядке. Используйте &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; чтобы сделать обратное.</target>
        </trans-unit>
        <trans-unit id="0964c138a8a06a965bf091caaa6b9ea018efcb97" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">Обратите внимание, что СПИСОК добавляется целиком, а не по одному элементу за раз, поэтому добавленные элементы остаются в том же порядке. Используйте &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; чтобы сделать обратное.</target>
        </trans-unit>
        <trans-unit id="ddf2e42d261d53e754661957b5687c8859030118" translate="yes" xml:space="preserve">
          <source>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</source>
          <target state="translated">Обратите внимание на вызовы функции PERL_SET_CONTEXT().Они необходимы для инициализации глобального состояния,которое отслеживает,какой интерпретатор является &quot;текущим&quot; на конкретном процессе или потоке,который может его выполнять.Она всегда должна использоваться,если у вас более одного интерпретатора и вы делаете вызовы perl API на обоих интерпретаторах чередующимся образом.</target>
        </trans-unit>
        <trans-unit id="b5b392e74eb48b0aee9cb28bffd1d6dc73cfac7a" translate="yes" xml:space="preserve">
          <source>Note the early capture of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;old_ss_ix&lt;/code&gt;, which is later passed as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;. In the case of &lt;code&gt;pp_entersub&lt;/code&gt;, this is because, although most values needing saving are stored in fields of the context struct, an extra value needs saving only when the debugger is running, and it doesn't make sense to bloat the struct for this rare case. So instead it is saved on the savestack. Since this value gets calculated and saved before the context is pushed, it is necessary to pass the old value of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;cx_pushblock&lt;/code&gt;, to ensure that the saved value gets freed during scope exit. For most users of &lt;code&gt;cx_pushblock&lt;/code&gt;, where nothing needs pushing on the save stack, &lt;code&gt;PL_savestack_ix&lt;/code&gt; is just passed directly as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c788344d48bbaf6f108e51a7241322de827d97" translate="yes" xml:space="preserve">
          <source>Note the emphasis on bytes: even if the filehandle has been set to operate on characters (for example using the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; I/O layer), the &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek&lt;/code&gt;&lt;/a&gt; family of functions use byte offsets, not character offsets, because seeking to a character offset would be very slow in a UTF-8 file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7596eda7b71ff20655d3bc34a84787b053200c0e" translate="yes" xml:space="preserve">
          <source>Note the gaps marked by &quot;*&quot; before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</source>
          <target state="translated">Обратите внимание на пробелы,отмеченные знаком &quot;*&quot; перед несколькими записями байтов выше.Это вызвано тем,что легальная кодировка UTF-8 избегает не самых коротких кодировок:технически возможно кодировать одну и ту же точку кода разными способами,но это явно запрещено,и всегда следует использовать как можно более короткую кодировку (и это то,что делает Perl).</target>
        </trans-unit>
        <trans-unit id="924291c98e268b7826585c54d3c30b3f0159b622" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">Обратите внимание на точку с запятой. За исключением того, что код внутри не выполняется немедленно, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; - это не столько объявление, сколько оператор, например &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; . (Однако независимо от того, сколько раз вы выполняете эту конкретную строку (если только вы не находитесь в &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt; ), $ coderef все равно будет иметь ссылку на</target>
        </trans-unit>
        <trans-unit id="ba98181394143476434b95cb278177df7d3eab51" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;sub {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;do{}&lt;/code&gt; or &lt;code&gt;eval{}&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;eval(&quot;...&quot;)&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245f27d09730a3956ebd88bb73ed91d5802f1f14" translate="yes" xml:space="preserve">
          <source>Note the two following forms:</source>
          <target state="translated">Обратите внимание на две следующие формы:</target>
        </trans-unit>
        <trans-unit id="08a39ac9f8eb20d1bc0ac7dda6dd75ffb57ed8d8" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;$&lt;/code&gt; instead of &lt;code&gt;\&lt;/code&gt; in the last example. Unlike &lt;b&gt;sed&lt;/b&gt;, we use the \&amp;lt;</source>
          <target state="translated">Обратите внимание на использование &lt;code&gt;$&lt;/code&gt; вместо &lt;code&gt;\&lt;/code&gt; в последнем примере. В отличие от &lt;b&gt;sed&lt;/b&gt; , мы используем \ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="774d755cbcc9927f9bd666b04c889ec17f9ec2e7" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;code&gt;Minimal&lt;/code&gt; option in the code above. When using gzip for Content-Encoding you should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845bd8d10b7b2e89645294c110cfa223e574f5d5" translate="yes" xml:space="preserve">
          <source>Note there are two distinct steps there: 1) You'll have to create Wild.pm and put it in your perl lib directory. 2) You'll need to set the PERL5OPT environment variable. If you want argv expansion to be the default, just set PERL5OPT in your default startup environment.</source>
          <target state="translated">Обратите внимание,что там есть два отдельных шага:1)Вы должны создать Wild.pm и поместить его в каталог perl lib.2)Вам нужно будет установить переменную окружения PERL5OPT.Если вы хотите,чтобы расширение argv было по умолчанию,просто установите переменную PERL5OPT в вашем стартовом окружении по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3aa39411508c2033438cf708df8c04c8a846a8d6" translate="yes" xml:space="preserve">
          <source>Note there is a distinction between a capture buffer which matches the empty string a capture buffer which is optional. Eg, &lt;code&gt;(x?)&lt;/code&gt; and &lt;code&gt;(x)?&lt;/code&gt; The latter may be undef, the former not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c0c7dc0dc0ee1847fe2547270344fd07547c80" translate="yes" xml:space="preserve">
          <source>Note this interface is strongly preferred over &lt;code&gt;gv_stashpvn&lt;/code&gt; for performance reasons.</source>
          <target state="translated">Обратите внимание, что этот интерфейс предпочтительнее &lt;code&gt;gv_stashpvn&lt;/code&gt; по соображениям производительности.</target>
        </trans-unit>
        <trans-unit id="3299aefdb3ce5c9a7bffd6e8e1b69e10b1bc969e" translate="yes" xml:space="preserve">
          <source>Note this is current as of patchlevel 0, and could change at any time.</source>
          <target state="translated">Обратите внимание,что он является текущим на уровне 0 патча и может измениться в любое время.</target>
        </trans-unit>
        <trans-unit id="43dee313ad9b91211c8c801e413c783a1b1c90d4" translate="yes" xml:space="preserve">
          <source>Note this may be also triggered for constructs like:</source>
          <target state="translated">Обратите внимание,что это также может быть вызвано для конструкций типа:</target>
        </trans-unit>
        <trans-unit id="479333dc136e44b8ccb0606732973018c80236a3" translate="yes" xml:space="preserve">
          <source>Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but perl does not prohibit the use of characters within this range. To perl, every one of \x{0000_0000} up to \x{ffff_ffff} (*) is</source>
          <target state="translated">Обратите внимание,что этот шаг превратил \x{D800}-\x{DFFF}в запретную зону,но perl не запрещает использование символов в этом диапазоне.К perl,каждый из \x{0000_0000}до \x{ffff_ffff}.(*)это</target>
        </trans-unit>
        <trans-unit id="64c26fc0bfdd3e67c9ece7008879dc6d1a01b402" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">Примечание для тех, кто все еще использует Perl 5.18 или более раннюю версию: использование &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; или &lt;code&gt;$'&lt;/code&gt; замедлит &lt;b&gt;любое&lt;/b&gt; использование регулярных выражений в вашей программе. Проконсультируйтесь с &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; для &lt;code&gt;@-&lt;/code&gt; чтобы увидеть эквивалентные выражения, которые не вызывают замедления. См. Также &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt; . Начиная с Perl 5.10, вы также можете использовать эквивалентные переменные &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , но для их определения вы должны указать модификатор &lt;code&gt;/p&lt;/code&gt; (сохранить) на вашем регулярное выражение. В Perl 5.20 использование &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; не имеет значения скорости.</target>
        </trans-unit>
        <trans-unit id="58f853df3fafdf36ed80cd1751e4f069c0f1707d" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075a00b6d348d2bde80b54d266bd24c03289e88d" translate="yes" xml:space="preserve">
          <source>Note too that, when using the /x modifier on a regex, any comment containing the current pattern delimiter will cause the regex to be immediately terminated. In other words:</source>
          <target state="translated">Заметьте также,что при использовании модификатора /x в регексе,любой комментарий,содержащий текущий разделитель шаблонов,приведет к немедленному прекращению регекса.Другими словами:</target>
        </trans-unit>
        <trans-unit id="a9418a9be85583539aad52da154ad55780878583" translate="yes" xml:space="preserve">
          <source>Note, however, a &quot;=begin</source>
          <target state="translated">Обратите внимание,однако,на то,что &quot;=начаг</target>
        </trans-unit>
        <trans-unit id="6dfa7aab0d54b245f769489b5d31604d4926ff66" translate="yes" xml:space="preserve">
          <source>Note, however, that (unlike most other OO languages) Perl does not ensure or enforce encapsulation in any way. If you want objects to actually</source>
          <target state="translated">Обратите внимание,однако,что (в отличие от большинства других языков OO)Perl никоим образом не обеспечивает и не принуждает к инкапсуляции.Если вы хотите,чтобы объекты на самом деле</target>
        </trans-unit>
        <trans-unit id="9ee559bf7555e3380e5d318f57cb372ff9af8802" translate="yes" xml:space="preserve">
          <source>Note, however, that formatting codes and Z&amp;lt;&amp;gt;'s can occur in any and all parts of an L&amp;lt;...&amp;gt; (i.e., in</source>
          <target state="translated">Однако обратите внимание, что коды форматирования и Z &amp;lt;&amp;gt; могут встречаться в любой части L &amp;lt;...&amp;gt; (т. Е. В</target>
        </trans-unit>
        <trans-unit id="1ced7964eb00ec0017dbaa24226307b98c43e3bb" translate="yes" xml:space="preserve">
          <source>Note, however, that sometimes the Pod events aren't processed in exactly the same order as the code lines are -- i.e., if you have a file with Pod, then code, then more Pod, sometimes the code will be processed (via whatever you have code_handler call) before the all of the preceding Pod has been processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e68e1c2898e4995bc610c38829131cae377e27c" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not always work for quoting Perl code:</source>
          <target state="translated">Обратите внимание,однако,что это не всегда срабатывает при цитировании Perl-кода:</target>
        </trans-unit>
        <trans-unit id="daa40807202515240a11e4305fe2938d02dab24c" translate="yes" xml:space="preserve">
          <source>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.10.0, with an error</source>
          <target state="translated">Обратите внимание,однако,что это ограничивает локализацию некоторых значений;например,следующее утверждение умирает,начиная с версии 5.10.0,с ошибкой</target>
        </trans-unit>
        <trans-unit id="1d6b51a1f71c0a1abcbedef9280d1a614610364d" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated. That is, you might expect that this bracket group:</source>
          <target state="translated">Обратите внимание, кстати, что элементы в каждой группе разделены запятыми, а не &lt;code&gt;/\s*,\s*/&lt;/code&gt; . То есть можно было ожидать, что эта группа скобок:</target>
        </trans-unit>
        <trans-unit id="c6f16890b60d4dbdb1b39ad263c84c7dffbf2eae" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt;-separated. That is, you might expect that this bracket group:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328da3257aa2be232f47d8215b8ce26d82b79a88" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so use &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">Обратите внимание: версия модуля может быть не указана, в результате чего значение равно &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , поэтому используйте &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; если это то, что вы тестируете.</target>
        </trans-unit>
        <trans-unit id="0424f392af8ee6773275c7a49c920c35add5c370" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;undef&lt;/code&gt;, so use &lt;code&gt;exists $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e4009ec57ba2c9432c9aea5b719c678f3436d3" translate="yes" xml:space="preserve">
          <source>Note, prior to 5.25 this function returned what is now returned by the hv_bucket_ratio() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b95364ddb70e31cf0aeb6a61be710b24d1414c" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что начиная с Perl 5.18, имя &lt;code&gt;BELL&lt;/code&gt; относится к символу Unicode U + 1F514 вместо традиционного U + 0007. Для последнего используйте &lt;code&gt;ALERT&lt;/code&gt; или &lt;code&gt;BEL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="610f3ee797f1ad4a61eeefe27944e6e308608f88" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca239c5c2f598100f4661bdcb782662394e6f1d" translate="yes" xml:space="preserve">
          <source>Note, that in both cases the tilde expansion is done by MakeMaker, not by perl by default, nor by make.</source>
          <target state="translated">Обратите внимание,что в обоих случаях расширение тильды выполняется MakeMaker,а не perl по умолчанию и не make.</target>
        </trans-unit>
        <trans-unit id="557c3756e4a3c96fb446dffbb0c22ffbb956fd7d" translate="yes" xml:space="preserve">
          <source>Note, there is a limitation of this technique. Some compression file formats store extra information along with the compressed data payload. For example, gzip can optionally store the original filename and Zip stores a lot of information about the original file. If the original compressed file contains any of this extra information, it will not be transferred to the new compressed file using the technique above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4993e4338094ef439d0737bf034f424a4d5b79" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="36fe78df4850fd37cfbf75f0174f722ec0a6341e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d62d5837f1b088899c2335c24b7fb00237a5b01e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d3aba16133e84e8f9cf404e250371714dd197ffd" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">Обратите внимание, что эти константы не импортируются &lt;code&gt;IO::Compress::Zip&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d20abe192a9c5b05ecdd8b5a009dcb0d1cc347b5" translate="yes" xml:space="preserve">
          <source>Note, use of &lt;code&gt;gv_stashsv&lt;/code&gt; instead of &lt;code&gt;gv_stashpvn&lt;/code&gt; where possible is strongly recommended for performance reasons.</source>
          <target state="translated">Обратите внимание: по возможности настоятельно рекомендуется использовать &lt;code&gt;gv_stashsv&lt;/code&gt; вместо gv_stashpvn из &lt;code&gt;gv_stashpvn&lt;/code&gt; производительности.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="04e9999aa448d4f7736e19660c8cdd3fdd576ad9" translate="yes" xml:space="preserve">
          <source>Note: 'pinyin' is Han in Latin, 'zhuyin' is Han in Bopomofo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdcc6395bb5bb305f89c21276194ad5f5be7723" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; on directories is not supported on many operating systems. Use &lt;a href=&quot;#rmdir-FILENAME&quot;&gt;&lt;code&gt;rmdir&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858564b8eb505f163537f56838925cbe62eeb857" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Примечание: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не будет пытаться удалить каталоги, если вы не являетесь суперпользователем и для Perl установлен флаг &lt;b&gt;-U&lt;/b&gt; . Даже если эти условия соблюдены, имейте в виду, что отключение каталога может нанести ущерб вашей файловой системе. Наконец, использование &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; для каталогов не поддерживается во многих операционных системах. Вместо этого используйте &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5634cda13018c382b3c15c0bf989c4dea07045c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">Примечание: в этом примере &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; не нужно: &lt;code&gt;strftime()&lt;/code&gt; - это функция POSIX, которая использует стандартную системную функцию &lt;code&gt;libc&lt;/code&gt; , которая всегда подчиняется текущей локали &lt;code&gt;LC_TIME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd71952aea843bf37c94c0e84aec5e1493d8dd4a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">Примечание: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; не показано в некоторых из этих примеров, потому что в этом нет необходимости: &lt;code&gt;strcoll()&lt;/code&gt; и &lt;code&gt;strxfrm()&lt;/code&gt; - это функции POSIX, которые используют стандартные системные функции &lt;code&gt;libc&lt;/code&gt; , которые всегда подчиняются текущей локали &lt;code&gt;LC_COLLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89c514c1b9de7057dea402c8d0f5122402a932ba" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Примечание: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не будет пытаться удалить каталоги, если вы не являетесь суперпользователем и для Perl установлен флаг &lt;b&gt;-U&lt;/b&gt; . Даже если эти условия соблюдены, имейте в виду, что отключение каталога может нанести ущерб вашей файловой системе. Наконец, использование &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; для каталогов не поддерживается во многих операционных системах. Вместо этого используйте &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07397ae9451cf5a436657d9cabd9f8d4563f40ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt; . Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">Примечание: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; будет искать слои для слоя stdio. Если он не может найти его, он вызовет &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; для создания нового stdio &lt;code&gt;FILE&lt;/code&gt; . Пожалуйста, вызывайте &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; если вам нужен</target>
        </trans-unit>
        <trans-unit id="724e5762fee6d350a318fc2fb4b30294baaefc44" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt;. Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f6afd463560b84ea6b975b1be869772594ae4f" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f06e6aec634d9ac607b849e5f22d774716a195" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f614956265c278721bb12432048ff10b5826efd9" translate="yes" xml:space="preserve">
          <source>Note: Be careful not to modify &lt;code&gt;@_&lt;/code&gt; at all before you call export_to_level - or people using your package will get very unexplained results!</source>
          <target state="translated">Примечание: будьте осторожны и не изменяйте &lt;code&gt;@_&lt;/code&gt; вообще перед вызовом export_to_level - иначе люди, использующие ваш пакет, получат очень необъяснимые результаты!</target>
        </trans-unit>
        <trans-unit id="fadfe11234c608cf2899bd38b718e46fd2406590" translate="yes" xml:space="preserve">
          <source>Note: Before 5.21.0, the &quot;missing&quot; lexical warnings category was internally defined to be the same as the &quot;uninitialized&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">Примечание:До версии 5.21.0 категория &quot;отсутствующих&quot; лексических предупреждений внутренне определялась как &quot;неинициализированная&quot;.Теперь она сама по себе является категорией высшего уровня.</target>
        </trans-unit>
        <trans-unit id="78023e67525e4c7a613335c235fa22e549b34845" translate="yes" xml:space="preserve">
          <source>Note: Before Perl 5.8.0, the lexical warnings category &quot;deprecated&quot; was a sub-category of the &quot;syntax&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">Замечание:До версии Perl 5.8.0 категория лексических предупреждений &quot;устарела&quot; была подкатегорией категории &quot;синтаксис&quot;.Теперь это категория высшего уровня.</target>
        </trans-unit>
        <trans-unit id="d209ffe48badd4b3ce623fe1073da3a9d734affc" translate="yes" xml:space="preserve">
          <source>Note: Between XSUB and pure Perl, there is an incompatibility about the interpretation of &lt;code&gt;$code_point&lt;/code&gt; as a decimal number. XSUB converts &lt;code&gt;$code_point&lt;/code&gt; to an unsigned integer, but pure Perl does not. Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5227b82d031bced3044e91e5933630d59be9bc12" translate="yes" xml:space="preserve">
          <source>Note: Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt; .</source>
          <target state="translated">Примечание. Не используйте в &lt;code&gt;$code_point&lt;/code&gt; знак с плавающей запятой или отрицательный знак .</target>
        </trans-unit>
        <trans-unit id="668a585af93a214a0b5974e95d57e4c940a86f77" translate="yes" xml:space="preserve">
          <source>Note: Due to XS issues the block passed may be able to access the outer @_ directly. This is not intentional and will break under debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7d3334d006afa6b870b1e3ad78d323bdbd6bec" translate="yes" xml:space="preserve">
          <source>Note: Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd381c6324e161a3ae5c4a254351b2b3b48d1d8" translate="yes" xml:space="preserve">
          <source>Note: Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d9951c1347109cd3bedbb4bb7306286ad1d212" translate="yes" xml:space="preserve">
          <source>Note: FCC is unique, as well as four normalization forms (NF*).</source>
          <target state="translated">Примечание:FCC уникальна,как и четыре формы нормализации (NF*).</target>
        </trans-unit>
        <trans-unit id="2bf5a1f9c5d972054186d3e42a82b7b324805893" translate="yes" xml:space="preserve">
          <source>Note: FCD is not always unique, then plural forms may be equivalent each other. &lt;code&gt;FCD()&lt;/code&gt; will return one of these equivalent forms.</source>
          <target state="translated">Примечание: FCD не всегда уникален, тогда формы множественного числа могут быть эквивалентны друг другу. &lt;code&gt;FCD()&lt;/code&gt; вернет одну из этих эквивалентных форм.</target>
        </trans-unit>
        <trans-unit id="56040f615b41a7064a5ef1844f423d8b9a40f330" translate="yes" xml:space="preserve">
          <source>Note: For some extensions, Dave Beazley's SWIG system may provide a significantly more convenient mechanism for creating the extension glue code. See &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; for more information.</source>
          <target state="translated">Примечание. Для некоторых расширений система SWIG Дэйва Бизли может предоставить значительно более удобный механизм для создания связующего кода расширения. См. &lt;a href=&quot;http://www.swig.org/&quot;&gt;Http://www.swig.org/&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b1211fe58a903b5165f5edc276c715ceb521df1e" translate="yes" xml:space="preserve">
          <source>Note: From Mac OS X 10.6 &quot;Snow Leopard&quot; onwards, Apple only supports Intel-based hardware. This means you can safely skip this section unless you have an older Apple computer running on ppc or wish to create a perl binary with backwards compatibility.</source>
          <target state="translated">Примечание:Начиная с Mac OS X 10.6 &quot;Snow Leopard&quot;,Apple поддерживает только аппаратное обеспечение на базе Intel.Это означает,что вы можете безопасно пропустить этот раздел,если у вас нет старого компьютера Apple,работающего на ppc,или если вы не хотите создать двоичный файл perl с обратной совместимостью.</target>
        </trans-unit>
        <trans-unit id="743600644f11d3e8a913feb2e46d0252bdc64043" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">Примечание. Если строка не находится в FCD, она не должна входить в FCC. Поэтому &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; должен вернуть &lt;code&gt;NO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c308958e09dd00a6a549fa78fd5e059fbed4455" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b01b3e05bd18ecfe427fbadc48a1cf9f4918f8c" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt; , then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">Примечание: если вы включите &lt;code&gt;Sparseseen&lt;/code&gt; , вы не должны полагаться на содержимое увиденного хэша, поскольку его содержимое будет деталью реализации!</target>
        </trans-unit>
        <trans-unit id="9f446264c9bfae66320393c5089f48ed5b46e500" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt;, then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da841189af3f04f4eb088d72b96bc951d2d81fc" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3278502ab348386cdc09a185533e7816e62b07e" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">Примечание. Многие люди склонны злоупотреблять &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; а затем с удивлением обнаруживают, что число &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; (строка нулевой длины) на самом деле являются определенными значениями. Например, если вы скажете</target>
        </trans-unit>
        <trans-unit id="72cf554b1f74abf911508263cf2a354d76fd9f1a" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">Примечание. Многие люди склонны злоупотреблять &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; а затем с удивлением обнаруживают, что число &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; (строка нулевой длины) на самом деле являются определенными значениями. Например, если вы скажете</target>
        </trans-unit>
        <trans-unit id="a4c4e917877757fb6fc83b2e0f19ffc51d5f6fc8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">Примечание: встроенная функция Perl &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; возвращает четыре значения, измеряемых в секундах.</target>
        </trans-unit>
        <trans-unit id="4f4979746c04c5a2101a3a8cfcb2e0ca83bb94c8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;times()&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193ad56c42c8c5022f417eca20124d2510809ef1" translate="yes" xml:space="preserve">
          <source>Note: Some folks colloquially refer to this bit of punctuation as a &quot;yada-yada&quot; or &quot;triple-dot&quot;, but its true name is actually an ellipsis.</source>
          <target state="translated">Примечание:Некоторые люди в разговорной речи называют этот бит пунктуации &quot;яда-яда&quot; или &quot;тройная точка&quot;,но на самом деле его истинное название-эллипсис.</target>
        </trans-unit>
        <trans-unit id="c9a4ed3733a9eeadde05bd081437b7ba9d5fa627" translate="yes" xml:space="preserve">
          <source>Note: Some modules downloaded from CPAN may require NetWare related API in order to build on NetWare. Other modules may however build smoothly with or without minor changes depending on the type of module.</source>
          <target state="translated">Примечание:Для некоторых модулей,загруженных из CPAN,может потребоваться API,связанный с NetWare,чтобы построить его на основе NetWare.Другие модули,однако,могут собираться плавно,с небольшими изменениями или без них,в зависимости от типа модуля.</target>
        </trans-unit>
        <trans-unit id="e33603b6b52bf5831bfb6cf75b5a9f26f72dc686" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; ) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">Примечание. Некоторые сайты сообщают о проблемах при использовании тестов доступа к файлам ( &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-x&lt;/code&gt; ) для файлов, доступ к которым осуществляется через DFS DEC. В частности, поскольку DFS в настоящее время не предоставляет доступ к расширенному заголовку файлов на удаленных томах, попытки проверки ACL завершаются неудачно, и тесты файлов возвращают false с &lt;code&gt;$!&lt;/code&gt; указывает на то, что файл не существует. Вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; для этих файлов, поскольку он проверяет только защиту на основе UIC, а затем вручную проверяет соответствующие биты, как определено вашим компилятором C</target>
        </trans-unit>
        <trans-unit id="31012ee5baab20630d192eb344f3fbf19e1f0ce3" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;stat&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6f6c7fe8a37aa2c65de3e3c606a0b439080ba4" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt; . Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">Примечание. Некоторые поставщики предоставляют &lt;code&gt;strtod()&lt;/code&gt; и &lt;code&gt;strtol()&lt;/code&gt; но не &lt;code&gt;strtoul()&lt;/code&gt; . Другие поставщики, которые предоставляют &lt;code&gt;strtoul()&lt;/code&gt; анализируют &quot;-1&quot; как допустимое значение.</target>
        </trans-unit>
        <trans-unit id="09354bfd47c342dd837df1ad765f45f04db5692c" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt;. Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41fee180b1c4bc188eb2c171834172ecd8c3be5" translate="yes" xml:space="preserve">
          <source>Note: The functions with names ending in &lt;code&gt;_at_level&lt;/code&gt; were added in Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d1626493358bc3d857173bc6af6ddd2a5fc2da" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) and file test (&lt;code&gt;'-X'&lt;/code&gt; ) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , or &lt;code&gt;'bool'&lt;/code&gt; ) to be interpreted as a glob or filename.</source>
          <target state="translated">Примечание. Операторы итератора ( &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) и проверки файла ( &lt;code&gt;'-X'&lt;/code&gt; ) работают как обычно: если операнд не является благословенным глобусом или ссылкой ввода-вывода, он преобразуется в строку (с использованием метода для &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; или &lt;code&gt;'bool'&lt;/code&gt; ) для интерпретации как глобус или имя файла.</target>
        </trans-unit>
        <trans-unit id="e872c50dbea2dd944dd1795cb2d6b5ca0cb3d48d" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt;) and file test (&lt;code&gt;'-X'&lt;/code&gt;) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, or &lt;code&gt;'bool'&lt;/code&gt;) to be interpreted as a glob or filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a7724723655fcca925e8e2780cbc470ea823e12" translate="yes" xml:space="preserve">
          <source>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</source>
          <target state="translated">Замечание:Ключевое слово 'lib' предупредит,когда запрашиваемая библиотека не может быть загружена.Для подавления предупреждения используйте 'try':</target>
        </trans-unit>
        <trans-unit id="9be19f662c327b39a0c7dc7dd26cac18cf3a2650" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7df03e2ca7476b6f129d5fb49ca21db5f16ee3" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version) can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7834aa58e75e083860df15db52ef81cbd8591c51" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">Примечание: В списке &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; возвращения возникла из текущего Perl и текущая установка.</target>
        </trans-unit>
        <trans-unit id="79a0d5348f570c35ca9be395234112a023471f03" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;require&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e555e53c6f7ef659bcb517427e72585e148bddc" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get.</source>
          <target state="translated">Примечание. Политика использования правил локали для кодовых точек, которые могут умещаться в байтах, и правил Unicode для тех, которые не могут уместиться, не применяется единообразно. До версии 5.12 это было несколько случайно; в v5.12 он довольно последовательно применялся к сопоставлению регулярных выражений, за исключением классов символов в квадратных скобках; в v5.14 он был расширен на все совпадения регулярных выражений; а в v5.16 - к операциям с регистром, таким как &lt;code&gt;\L&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; . Для сопоставления во всех выпусках до сих пор вызывается системная функция &lt;code&gt;strxfrm()&lt;/code&gt; , и все, что она делает, вы получаете.</target>
        </trans-unit>
        <trans-unit id="131995001a6829f0723ee9a84a7ecc32cd05fa54" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;uc()&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get. Starting in v5.26, various bugs are fixed with the way perl uses this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f932c6f37410ce4ebff00172ee521c9f04d25563" translate="yes" xml:space="preserve">
          <source>Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</source>
          <target state="translated">Замечание:Эта функция была представлена в версии 5.57 Exporter,выпущенной на perl 5.8.3.</target>
        </trans-unit>
        <trans-unit id="cd489e52bffb55133a04f9392b0cef79b71a84a0" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Любой другой символ, кроме &lt;code&gt;U+FFFE&lt;/code&gt; , может быть изменен &lt;code&gt;entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="287eea86bd8ed6619f824147ed2c55a69584e9bd" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e524e8ba90f8c2eceff3ee2b4fe18bbc36f721be" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">Примечание. Это эквивалентно &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Любой другой символ, кроме &lt;code&gt;U+FFFF&lt;/code&gt; , может быть изменен &lt;code&gt;entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc676f4776bf9d00f6e8ce3ee423f9f2208472e" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0455de4d41cf68eed0be49449f753fd507ce98c3" translate="yes" xml:space="preserve">
          <source>Note: This method is only available if you are running zlib 1.0.6 or better.</source>
          <target state="translated">Примечание:Этот метод доступен только если вы используете zlib 1.0.6 или лучше.</target>
        </trans-unit>
        <trans-unit id="d780f7fe644c15c8098f2ec3e635333d65dac99d" translate="yes" xml:space="preserve">
          <source>Note: This method was required from Math::BigInt version 1.78, but the required API version number was not incremented, so there are older libraries that support API version 1, but do not support &lt;code&gt;_as_oct()&lt;/code&gt; .</source>
          <target state="translated">Примечание. Этот метод требовался от Math :: BigInt версии 1.78, но требуемый номер версии API не был увеличен, поэтому существуют более старые библиотеки, которые поддерживают API версии 1, но не поддерживают &lt;code&gt;_as_oct()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="274ea739a039d51482491c2164a8ca995639e789" translate="yes" xml:space="preserve">
          <source>Note: This needs Math::BigInt::GMP installed.</source>
          <target state="translated">Примечание:Для этого необходимо установить Math::BigInt::GMP.</target>
        </trans-unit>
        <trans-unit id="4599f377b1aba694d82426f6489f702538a8bb33" translate="yes" xml:space="preserve">
          <source>Note: When $FTP_PASSIVE is true, &lt;code&gt;ncftp&lt;/code&gt; will not be used to fetch files, since passive mode can only be set interactively for this binary</source>
          <target state="translated">Примечание: если $ FTP_PASSIVE истинно, &lt;code&gt;ncftp&lt;/code&gt; не будет использоваться для выборки файлов, так как пассивный режим может быть установлен только интерактивно для этого двоичного файла.</target>
        </trans-unit>
        <trans-unit id="44108fdd62b6b987695d83d0e866909c28a68c2f" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt; . There is no Daylight Saving Time in GMT.</source>
          <target state="translated">Примечание. При вызове в контексте списка $ isdst, последнее значение, возвращаемое gmtime, всегда равно &lt;code&gt;0&lt;/code&gt; . В GMT нет перехода на летнее время.</target>
        </trans-unit>
        <trans-unit id="16d88e8a12adc9d5938fa24b2acb9b6eac47525d" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt;. There is no Daylight Saving Time in GMT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326b015af2e44c2db6ac3ed72580a47dac6e9403" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">Примечание: работает также для подклассов, таких как &lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt; . Каждый класс имеет свои собственные глобальные переменные, отделенные от Math :: BigInt, но можно создать подкласс Math :: BigInt и сделать глобальные переменные псевдонимов подкласса аналогами из Math :: BigInt.</target>
        </trans-unit>
        <trans-unit id="f017c3d2e2508b08d7d59dc7727c02f156768d30" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">Примечание:Работает также для подклассов типа Math::BigFloat.Каждый класс имеет свои глобусы,отделенные от Math::BigInt,но можно сделать подкласс Math::BigInt и сделать глобусы подкласса псевдонимами Math::BigInt.</target>
        </trans-unit>
        <trans-unit id="eb7b6e328c4f81408ff1a139ac8eaf2a380ca671" translate="yes" xml:space="preserve">
          <source>Note: You have to modify your man.conf file to search for manpages in the /ade/lib/perl5/man/man3 directory, or the man pages for the perl library will not be found.</source>
          <target state="translated">Замечание:Вы должны изменить ваш man.conf файл для поиска man-страниц в каталоге /ade/lib/perl5/man/man3,иначе man-страницы для библиотеки perl не будут найдены.</target>
        </trans-unit>
        <trans-unit id="c7379f095d2d22d8a649d49142d79afd3489318b" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; you set the place where to round!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7dc83f4d6c9a8b0d3c0b5924caf0806f95cf13" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">Примечание: вы, вероятно, захотите вместо этого использовать &lt;a href=&quot;#accuracy()&quot;&gt;precision ()&lt;/a&gt; . С &lt;a href=&quot;#accuracy()&quot;&gt;точностью ()&lt;/a&gt; вы установите количество цифр каждый результат должен иметь, с &lt;a href=&quot;#precision()&quot;&gt;точностью ()&lt;/a&gt; вы установили место , где круглый!</target>
        </trans-unit>
        <trans-unit id="d6d84b096f34f15c07402e918e2379728ec1301e" translate="yes" xml:space="preserve">
          <source>Note: choosing anyhing but 'yes' for this option will need Devel::DistnameInfo being installed for taking effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e12b5547fb4733f2385741dc84813859d3dd2e" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;bundling&lt;/code&gt; также отключает &lt;code&gt;bundling_override&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5d46114c3638c4121c26c4c917e18fe48cdbc0" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd410d2fbf3af306729dd64454481dab1a79d72" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;bundling_override&lt;/code&gt; также отключает &lt;code&gt;bundling&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2b48dd6d444bef92ae0ebb4e15997ba10818fb" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d840b005bb09f5240a311bf0713bd815028ba795" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;ignore_case&lt;/code&gt; также отключает &lt;code&gt;ignore_case_always&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57bf189846e7e76bf8482fb5e477ff8f8dfe7b29" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0642b203ace91a0c6c6c1c85ec87408d95d51b9c" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt; .</source>
          <target state="translated">Примечание: отключение &lt;code&gt;ignore_case_always&lt;/code&gt; также отключает &lt;code&gt;ignore_case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1946def9c6cdf88287ce6da335562aa361a54824" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc88cd76d85c82ca33031114b858a78699d8dccf" translate="yes" xml:space="preserve">
          <source>Note: if the &lt;code&gt;applypatch&lt;/code&gt; program is installed and &lt;code&gt;CPAN::Config&lt;/code&gt; knows about it &lt;b&gt;and&lt;/b&gt; a patch is written by the &lt;code&gt;makepatch&lt;/code&gt; program, then &lt;code&gt;CPAN.pm&lt;/code&gt; lets &lt;code&gt;applypatch&lt;/code&gt; apply the patch. Both &lt;code&gt;makepatch&lt;/code&gt; and &lt;code&gt;applypatch&lt;/code&gt; are available from CPAN in the &lt;code&gt;JV/makepatch-*&lt;/code&gt; distribution.</source>
          <target state="translated">Примечание: если &lt;code&gt;applypatch&lt;/code&gt; установлена программа и &lt;code&gt;CPAN::Config&lt;/code&gt; знает об этом &lt;b&gt;и&lt;/b&gt; патч написан &lt;code&gt;makepatch&lt;/code&gt; программы, затем &lt;code&gt;CPAN.pm&lt;/code&gt; позволяет &lt;code&gt;applypatch&lt;/code&gt; применить патч. И &lt;code&gt;makepatch&lt;/code&gt; , и &lt;code&gt;applypatch&lt;/code&gt; доступны на CPAN в дистрибутиве &lt;code&gt;JV/makepatch-*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22e2016ea85ed84ee62e9e8de3756c81d1bdf26a" translate="yes" xml:space="preserve">
          <source>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</source>
          <target state="translated">Замечание:если вычисления дорогие или в хэше много элементов,вы можете посмотреть на преобразование Шварцца для кэширования результатов вычислений.</target>
        </trans-unit>
        <trans-unit id="29df041b4a10cf81a3e0b4f7f89bd122aed969f0" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9aff6bff93b9cbae48137737db8e4d2881dc6a" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">Примечание: в большинстве случаев, особенно в &lt;a href=&quot;#Copy-Constructor&quot;&gt;конструкторе копирования&lt;/a&gt; , такое поведение вряд ли будет подходящим.</target>
        </trans-unit>
        <trans-unit id="1b33df475ae354b7fb1f3b9c4cafb1584ab7a3e6" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9947057045b064f583a71d886808757ed0fa7848" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;).</source>
          <target state="translated">Примечание: поведение, описанное в этом разделе, можно отключить, установив для &lt;code&gt;fallback&lt;/code&gt; значение FALSE (см. &lt;a href=&quot;#fallback&quot;&gt;Откат&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="62b2ca1948759ac7f684eceb704736b180023c07" translate="yes" xml:space="preserve">
          <source>Note: the exact nature of the fancy specifications like &lt;code&gt;&quot;&amp;gt;= 1.2, != 1.5, &amp;lt; 2.0&quot;&lt;/code&gt; is subject to change. Advance notice will be given here. The simple specifications like &lt;code&gt;&quot;1.2&quot;&lt;/code&gt; will not change in format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ca88f5d5dc89450fb8556231f6b8efe29797ea" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4c5c965d1db592391a1881313b9980c7ebcd67" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">Примечание: в предыдущем абзаце описывается, что происходит, когда Perl автоматически генерирует конструктор копирования для объекта на основе скаляра. Для других случаев см. &lt;a href=&quot;#Copy-Constructor&quot;&gt;Конструктор копирования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c92c751ce0bf80febdd6e38233f67cab09e15ef" translate="yes" xml:space="preserve">
          <source>Note: this config variable is deprecated and will be removed in a future version of CPAN.pm. It will be replaced with the conventions around the family of $LANG and $LC_* environment variables.</source>
          <target state="translated">Замечание:эта переменная конфигурации устарела и будет удалена в будущей версии CPAN.pm.Она будет заменена соглашениями вокруг семейства переменных окружения $LANG и $LC_*.</target>
        </trans-unit>
        <trans-unit id="f59653e6422c3ee295a49f06549f34191c33d033" translate="yes" xml:space="preserve">
          <source>Note: this feature is still in alpha state and may change in future versions of CPAN.pm</source>
          <target state="translated">Примечание:эта функция все еще находится в альфа-состоянии и может измениться в будущих версиях CPAN.pm.</target>
        </trans-unit>
        <trans-unit id="fb52a79f4bb85f30f68ef37f28e8e379caceb4dc" translate="yes" xml:space="preserve">
          <source>Note: this function has not been specified by POSIX since 1990 and is included only for backwards compatibility. New code should use &lt;a href=&quot;perlfunc#getlogin&quot;&gt;&lt;code&gt;getlogin()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8ebc616c42eb9b0dd9d07b466e6d2d32bcecea" translate="yes" xml:space="preserve">
          <source>Note: this is a reasonably new addition to the family of socket functions, so all systems may not support this yet. If it is unsupported by the system, an attempt to use this method will abort the program.</source>
          <target state="translated">Примечание:это достаточно новое дополнение к семейству функций сокетов,поэтому все системы могут его пока не поддерживать.Если оно не поддерживается системой,попытка использования этого метода приведет к прерыванию работы программы.</target>
        </trans-unit>
        <trans-unit id="b27494dc8cf34b92a043ab41a4f74f0c9f2a3ea4" translate="yes" xml:space="preserve">
          <source>Note: this mechanism is not used when use_sqlite is on and SQLLite is running.</source>
          <target state="translated">Замечание:этот механизм не используется,когда включена функция use_sqlite и запущен SQLLite.</target>
        </trans-unit>
        <trans-unit id="13c903538586e11c4ad7bb5502c59a872fdcc9eb" translate="yes" xml:space="preserve">
          <source>Note: this method of setting config variables often provides more explanation about the functioning of a variable than the manpage.</source>
          <target state="translated">Замечание:этот метод настройки конфигурационных переменных часто дает больше объяснений о функционировании переменной,чем manpage.</target>
        </trans-unit>
        <trans-unit id="56d243ce60967f77fdfcf106f1d4d7d0a8b3112b" translate="yes" xml:space="preserve">
          <source>Note: using a static or global variable to store the SV isn't thread-safe. You can either use the &lt;code&gt;MY_CXT&lt;/code&gt; mechanism documented in &lt;a href=&quot;perlxs#Safely-Storing-Static-Data-in-XS&quot;&gt;&quot;Safely Storing Static Data in XS&quot; in perlxs&lt;/a&gt; which is fast, or store the values in perl global variables, using get_sv(), which is much slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532592c5b33f1b1b988a3bcb06f60ee822f44348" translate="yes" xml:space="preserve">
          <source>Note: when this field is true, post-configuration prerequisites are not guaranteed to bear any relation whatsoever to those stated in the metadata, and relying on them doing so is an error. See also &lt;a href=&quot;#Prerequisites-for-dynamically-configured-distributions&quot;&gt;&quot;Prerequisites for dynamically configured distributions&quot;&lt;/a&gt; in the implementors' notes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d6330232e8dab848178ce084694142fca2d628" translate="yes" xml:space="preserve">
          <source>Note: you can define up to 20 conversion shortcuts in the gdb section.</source>
          <target state="translated">Примечание:вы можете определить до 20 ярлыков преобразования в разделе gdb.</target>
        </trans-unit>
        <trans-unit id="1f83b80ea2831e263f522f29c3cbd52e6213eb57" translate="yes" xml:space="preserve">
          <source>Noted explicit support for 'perl' in prerequisites</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8922b61958be2a8d272cbf3db875ad134d3a3576" translate="yes" xml:space="preserve">
          <source>Noted that the &lt;a href=&quot;#distribution_type&quot;&gt;&quot;distribution_type&quot;&lt;/a&gt; field is basically meaningless, and shouldn't really be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03baeca66519780c80b0846ea1bac63e81b58e40" translate="yes" xml:space="preserve">
          <source>Notepad++</source>
          <target state="translated">Notepad++</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="87cfdde76898dd31c7d07ddb886016189457f68b" translate="yes" xml:space="preserve">
          <source>Notes for users of Compress::Zlib version 1</source>
          <target state="translated">Примечания для пользователей Compress::Zlib версия 1</target>
        </trans-unit>
        <trans-unit id="60a645effd583025acef3ba80266a7c7168ec1f6" translate="yes" xml:space="preserve">
          <source>Notes on 64-bit Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65415edefc0ebcdd623f3ba5f7c329eeb91e917" translate="yes" xml:space="preserve">
          <source>Notes on Implementing Pod Processors</source>
          <target state="translated">Примечания по внедрению процессоров стручки</target>
        </trans-unit>
        <trans-unit id="8f983f019ad00a2df5935875ac129acc0e4daab6" translate="yes" xml:space="preserve">
          <source>Notes, typically rendered to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="25796957df5d5e9f79fe37e61f8cb9ca4c5a759a" translate="yes" xml:space="preserve">
          <source>Nothing in void context (obviously).</source>
          <target state="translated">Ничего в пустом контексте (очевидно).</target>
        </trans-unit>
        <trans-unit id="945c9d82ead4c25705962fc07336d3f2e51d1d62" translate="yes" xml:space="preserve">
          <source>Nothing is documented.</source>
          <target state="translated">Ничего не задокументировано.</target>
        </trans-unit>
        <trans-unit id="59fb6d9ec5289836c61476dab6f50fac2154944a" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. The following tags can be used to have large sets of symbols exported: &lt;code&gt;&quot;:Func&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncA&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncW&quot;&lt;/code&gt;, &lt;code&gt;&quot;:Misc&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DDD_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DRIVE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_ATTRIBUTE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_SHARE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_TYPE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FS_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FSCTL_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:HANDLE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_STORAGE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_DISK_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:GENERIC_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MOVEFILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SECURITY_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SEM_&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7b42ab74a17af97a37c506518ea42d6cc1e569" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. You must specify which methods to import, or use the ':ALL' tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2dc97487d39ef5241bb9dbe74fe894c19016958" translate="yes" xml:space="preserve">
          <source>Nothing is exported. Use fully qualified variable names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9e54f52e7f7c5402697de9fbd9467e290f0479" translate="yes" xml:space="preserve">
          <source>Nothing too unusual here. You can easily do this if you have a cross-compiler available; A usual Configure invocation when targetting a Solaris x86 looks something like this:</source>
          <target state="translated">Здесь нет ничего необычного.Вы можете легко сделать это,если у вас есть доступный кросс-компилятор;Обычный вызов Configure при нацеливании на Solaris x86 выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="a7b38ed2457b5a248dfea4058e6120cef0a01220" translate="yes" xml:space="preserve">
          <source>Nothing worked - die.</source>
          <target state="translated">Ничего не сработало-умри.</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df845adff4c3af8c8d0292f7522181ec1444d9f8" translate="yes" xml:space="preserve">
          <source>Notice also that the warning is reported at the line where the object is first used.</source>
          <target state="translated">Обратите также внимание,что предупреждение сообщается в строке,где объект впервые используется.</target>
        </trans-unit>
        <trans-unit id="45dd83b2a71782cbd9802b63f62a266f8d43184c" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; , and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">Обратите также внимание на функции &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; и &lt;code&gt;grok_oct&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="49ebd14076be592270a5d4f9b224fa4d4b89d099" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt;, and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0adcbd1247e60edf664089189052bb3a50dcbe1" translate="yes" xml:space="preserve">
          <source>Notice here the LEN is 10. (It may differ on your platform.) Extend the length of the string to one less than 10, and do a substitution:</source>
          <target state="translated">Обратите внимание,что ЛЕН 10.(Она может отличаться на вашей платформе.)Увеличьте длину строки до одного меньше 10 и сделайте замену:</target>
        </trans-unit>
        <trans-unit id="4c9ef71a088f9de85175aa974029dc0d63466c4b" translate="yes" xml:space="preserve">
          <source>Notice how at no point does the value &quot;private&quot; get printed. That's because $var only has that value within the block of the lexical() function, and it is hidden from the called subroutine.</source>
          <target state="translated">Заметьте,как ни в коем случае не печатается значение &quot;частное&quot;.Это потому,что $var имеет это значение только в блоке функции lexical(),и оно скрыто от вызываемой подпрограммы.</target>
        </trans-unit>
        <trans-unit id="77c47c9daa0e34a0be8b051a194ec532aabac71d" translate="yes" xml:space="preserve">
          <source>Notice how both parameters to &lt;code&gt;globmap&lt;/code&gt; are strings that are delimited by &amp;lt;&amp;gt;. This is done to make them look more like file globs - it is just syntactic sugar, but it can be handy when you want the strings to be visually distinctive. The enclosing &amp;lt;&amp;gt; are optional, so you don't have to use them - in fact the first thing globmap will do is remove these delimiters if they are present.</source>
          <target state="translated">Обратите внимание, что оба параметра &lt;code&gt;globmap&lt;/code&gt; представляют собой строки, разделенные &amp;lt;&amp;gt;. Это сделано для того, чтобы они больше походили на файловые глобусы - это просто синтаксический сахар, но это может быть удобно, когда вы хотите, чтобы строки были визуально различимы. Заключительные символы &amp;lt;&amp;gt; являются необязательными, поэтому вам не нужно их использовать - фактически, первое, что сделает globmap, это удалит эти разделители, если они есть.</target>
        </trans-unit>
        <trans-unit id="ad17ed98712f08fde401be783e01fddfe4c94277" translate="yes" xml:space="preserve">
          <source>Notice how the return value from the &lt;code&gt;new&lt;/code&gt; constructor is used as a filehandle in the &lt;code&gt;while&lt;/code&gt; loop? That's what's called an</source>
          <target state="translated">Обратите внимание , как возвращаемое значение из &lt;code&gt;new&lt;/code&gt; конструктора используются в качестве дескриптора в &lt;code&gt;while&lt;/code&gt; цикл? Это то, что называется</target>
        </trans-unit>
        <trans-unit id="ca8aa6acc2aa1f6723f38ec594c204d602c7b4d3" translate="yes" xml:space="preserve">
          <source>Notice how the second substitution stopped matching as soon as it encountered &quot;y &quot;. The &lt;code&gt;*?&lt;/code&gt; quantifier effectively tells the regular expression engine to find a match as quickly as possible and pass control on to whatever is next in line, as you would if you were playing hot potato.</source>
          <target state="translated">Обратите внимание, как вторая подстановка перестала соответствовать, как только встретила &amp;laquo;y&amp;raquo;. &lt;code&gt;*?&lt;/code&gt; quantifier эффективно сообщает механизму регулярных выражений, что нужно как можно быстрее найти совпадение и передать управление тому, что будет следующим в очереди, как если бы вы играли в hot potato.</target>
        </trans-unit>
        <trans-unit id="fa6e91727e4ee365f7ee9460c080c792faaad3e9" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt; . This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">Обратите внимание, что этой (незапрототипированной) функции все равно, переданы ли ей реальные скаляры или массивы. Perl видит все аргументы как один большой, длинный, плоский список параметров в &lt;code&gt;@_&lt;/code&gt; . Это одна из областей, где сияет простой стиль Perl с передачей аргументов. Функция &lt;code&gt;upcase()&lt;/code&gt; будет отлично работать без изменения определения &lt;code&gt;upcase()&lt;/code&gt; даже если мы скармливаем ей что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="8e53ec417cfc4ffd2c3f588c8323f91d879ae5ac" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt;. This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9d5a5851dd2e8a235f599f76ec00c3eeb19104" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;&quot;*&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4444833b9992f40fcab9e968725d8711a413e3d2" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что &amp;laquo;hello&amp;raquo; печатается только один раз, так как, когда Perl видит, что шестая итерация самого внешнего &lt;code&gt;(?:)*&lt;/code&gt; :) * Соответствует строке нулевой длины, он останавливает &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64a5ba33762b8a3df62c02415bc8d0abd71b566d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Dump()&lt;/code&gt; prints only elements 10 through 13 in the above code. The following code will print all of the elements.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Dump()&lt;/code&gt; печатает только элементы с 10 по 13 в приведенном выше коде. Следующий код напечатает все элементы.</target>
        </trans-unit>
        <trans-unit id="e23423f7c29d56c0d20fc2f34471adb3aea96e69" translate="yes" xml:space="preserve">
          <source>Notice that a file glob pattern &lt;code&gt;*.tar.gz&lt;/code&gt; was used to match the &lt;code&gt;.tar.gz&lt;/code&gt; files, then a fairly similar regular expression was used in the substitute to allow the new filename to be created.</source>
          <target state="translated">Обратите внимание , что файл шаблона Glob &lt;code&gt;*.tar.gz&lt;/code&gt; был использован , чтобы соответствовать &lt;code&gt;.tar.gz&lt;/code&gt; файлов, то довольно похоже регулярное выражение было использовано в заменителя , чтобы новое имя файла будет создан.</target>
        </trans-unit>
        <trans-unit id="309a93ea449f47318d5d11f1a3d425f1bac00a22" translate="yes" xml:space="preserve">
          <source>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</source>
          <target state="translated">Обратите внимание,что из-за поведения по умолчанию,заключающегося в том,что при отсутствии слоя по умолчанию при вводе не выполняется ни одно преобразование,легко по ошибке написать код,который продолжает расширять файл,многократно кодируя данные:</target>
        </trans-unit>
        <trans-unit id="45e2138036f16fd01c487cf4e8627bd64352166d" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt; , rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">Обратите внимание, что оба раза &lt;code&gt;put&lt;/code&gt; метод put, индекс записи был указан с использованием переменной &lt;code&gt;$i&lt;/code&gt; , а не самого буквального значения. Это потому, что &lt;code&gt;put&lt;/code&gt; вернет номер записи вставленной строки через этот параметр.</target>
        </trans-unit>
        <trans-unit id="f8652fa23a6a85d8694e8c330d3634e47750ae09" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt;, rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32eeef01ddef5893487334cb249c7d79c61492e" translate="yes" xml:space="preserve">
          <source>Notice that in these new test cases, the argument passed to round was a scalar variable. You might be wondering if you can round a constant or literal. To see what happens, temporarily add the following line to Mytest.t:</source>
          <target state="translated">Обратите внимание,что в этих новых тестовых случаях аргумент,переданный на округление,представлял собой скалярную переменную.Вы можете задаться вопросом,можно ли округлить константу или буквально.Чтобы посмотреть,что произойдет,временно добавьте следующую строку в Mytest.t:</target>
        </trans-unit>
        <trans-unit id="dc0dc28dfd6b3af28d5f3f343ec14d50dc738990" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt; . This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">Обратите внимание, что необходимо было определить переменную &lt;code&gt;ax&lt;/code&gt; . Это потому, что макрос &lt;code&gt;ST&lt;/code&gt; ожидает его существования. Если бы мы были в XSUB, не было бы необходимости определять &lt;code&gt;ax&lt;/code&gt; , поскольку он уже определен для нас.</target>
        </trans-unit>
        <trans-unit id="785ded97619f1dd92d03821ef64bfb7475388f4f" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt;. This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a57f1413b4aba3b4429663d2d0603ce91191839" translate="yes" xml:space="preserve">
          <source>Notice that most of the metacharacters lose their special meaning when they occur in a bracketed character class, except &lt;code&gt;&quot;^&quot;&lt;/code&gt; has a different meaning when it is at the beginning of such a class. And &lt;code&gt;&quot;-&quot;&lt;/code&gt; and &lt;code&gt;&quot;]&quot;&lt;/code&gt; are metacharacters only at restricted positions within bracketed character classes; while &lt;code&gt;&quot;}&quot;&lt;/code&gt; is a metacharacter only when closing a special construct started by &lt;code&gt;&quot;{&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4559301041ec62ea61a8a1fd68eda86e54b3ac68" translate="yes" xml:space="preserve">
          <source>Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this</source>
          <target state="translated">Обратите внимание,что затрагиваются только литералы (строковые или регулярные выражения),имеющие только старые кодовые точки:если вы смешиваете данные так</target>
        </trans-unit>
        <trans-unit id="c0f86b253bff23ee24ee05dba74dabc635ca28ee" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что основное &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; может округляться, а не усекаться. Это означает, что core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; может сообщать время на одну секунду позже, чем &lt;code&gt;gettimeofday()&lt;/code&gt; и &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="786dfe37f34edb4a05a168a69eef1c7edef1b6b6" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;time()&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;time()&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed987720b9a7557460b46e7f6aeb89459c4da26" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt; , which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt; , it's a good bet that you're running a very old (pre-5.6.0) version of Perl.</source>
          <target state="translated">Обратите внимание, что окончательное совпадение соответствует &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;p&lt;/code&gt; , что было бы сделано в случае совпадения без привязки &lt;code&gt;\G&lt;/code&gt; Также обратите внимание, что в финальном матче &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; обновляется только при совпадении a &lt;code&gt;/g&lt;/code&gt; . Если окончательное совпадение действительно соответствует &lt;code&gt;p&lt;/code&gt; , можно поспорить, что вы используете очень старую (до 5.6.0) версию Perl.</target>
        </trans-unit>
        <trans-unit id="6288f2ae31ab09194ff1161b00b4b9878a3f7850" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;q&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt;, which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;pos&lt;/code&gt;. &lt;code&gt;pos&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt;, it's a good bet that you're running an ancient (pre-5.6.0) version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b14f084bcfbcc93f4c728dc8c7063e0ac84985" translate="yes" xml:space="preserve">
          <source>Notice that the outer bracket type has changed, and so our access syntax has also changed. That's because unlike C, in perl you can't freely interchange arrays and references thereto. $ref_to_AoA is a reference to an array, whereas @AoA is an array proper. Likewise, &lt;code&gt;$AoA[2]&lt;/code&gt; is not an array, but an array ref. So how come you can write these:</source>
          <target state="translated">Обратите внимание, что изменился тип внешней скобки, и поэтому наш синтаксис доступа также изменился. Это потому, что, в отличие от C, в perl нельзя свободно обмениваться массивами и ссылками на них. $ ref_to_AoA - это ссылка на массив, тогда как @AoA - это собственно массив. Точно так же &lt;code&gt;$AoA[2]&lt;/code&gt; - это не массив, а ссылка на массив. Так почему же вы можете написать это:</target>
        </trans-unit>
        <trans-unit id="4b4bf711776ec92640c01168664a95c86695d9a1" translate="yes" xml:space="preserve">
          <source>Notice that the programmer must supply the C code necessary to have the real rpcb_gettime() function called and to have the return values properly placed on the argument stack.</source>
          <target state="translated">Обратите внимание,что программист должен предоставить код на языке Си,необходимый для вызова реальной функции rpcb_gettime()и правильного размещения возвращаемых значений на стеке аргументов.</target>
        </trans-unit>
        <trans-unit id="40afcceb911c695d77d20dfe27b09ee506961834" translate="yes" xml:space="preserve">
          <source>Notice that the resulting directions might be somewhat surprising if you are looking at a flat worldmap: in such map projections the great circles quite often do not look like the shortest routes -- but for example the shortest possible routes from Europe or North America to Asia do often cross the polar regions. (The common Mercator projection does &lt;b&gt;not&lt;/b&gt; show great circles as straight lines: straight lines in the Mercator projection are lines of constant bearing.)</source>
          <target state="translated">Обратите внимание, что полученные направления могут быть несколько неожиданными, если вы смотрите на плоскую карту мира: в таких картографических проекциях большие круги довольно часто выглядят не как кратчайшие маршруты - а, например, как кратчайшие возможные маршруты из Европы или Северной Америки в Азию. часто пересекают полярные регионы. (Обычная проекция Меркатора &lt;b&gt;не&lt;/b&gt; показывает большие круги как прямые: прямые в проекции Меркатора - это линии постоянного направления.)</target>
        </trans-unit>
        <trans-unit id="f84d61c644ea07e321b7e96f57efe6473acd064c" translate="yes" xml:space="preserve">
          <source>Notice that the standard utility methods of &lt;code&gt;Locale::Maketext&lt;/code&gt; are irremediably limited because they could not aim to do everything that could be expected from them in different languages, cultures and applications. So extending &lt;code&gt;numf&lt;/code&gt;, &lt;code&gt;quant&lt;/code&gt;, and &lt;code&gt;sprintf&lt;/code&gt; is natural as soon as your needs exceed what the standard ones do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6655a31d0fb590f3023635e120ce3082cf0511" translate="yes" xml:space="preserve">
          <source>Notice that this affects also the return values of the &lt;code&gt;display_format&lt;/code&gt; methods: in list context the whole parameter hash will be returned, as opposed to only the style parameter value. This is a potential incompatibility with earlier versions if you have been calling the &lt;code&gt;display_format&lt;/code&gt; method in list context.</source>
          <target state="translated">Обратите внимание, что это влияет также на возвращаемые значения методов &lt;code&gt;display_format&lt;/code&gt; : в контексте списка будет возвращен весь хэш параметра, а не только значение параметра стиля. Это потенциальная несовместимость с более ранними версиями, если вы &lt;code&gt;display_format&lt;/code&gt; метод display_format в контексте списка.</target>
        </trans-unit>
        <trans-unit id="7d79b02a2f56a81b2e831febdf1350cedb3c1a70" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что этот пример отличается от предыдущего только количеством ссылок. Сравните это со следующим примером, где мы выгружаем &lt;code&gt;$b&lt;/code&gt; вместо &lt;code&gt;$a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5817d7016f97dd4bc8025a72366ab7b19c39f5b7" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666303811970a38b268d6ae06ec62a57190a710e" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt; , which means that the current environment will be used.</source>
          <target state="translated">Обратите внимание, что мы не используем указатель &lt;code&gt;env&lt;/code&gt; . Обычно передается &lt;code&gt;perl_parse&lt;/code&gt; в качестве последнего аргумента, &lt;code&gt;env&lt;/code&gt; здесь заменяется на &lt;code&gt;NULL&lt;/code&gt; , что означает, что будет использоваться текущая среда.</target>
        </trans-unit>
        <trans-unit id="930214e71214bfe57e424495f1f5252084b336e6" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt;, which means that the current environment will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ecce29919a6e670ddbfce3528fa1f7984fab4d" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что когда &lt;code&gt;$z&lt;/code&gt; не равно 0, &lt;code&gt;$rho_c&lt;/code&gt; не равно &lt;code&gt;$rho_s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a5cef6aa9527100171d0d0994226a5b838b3bc" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ec88b4a9dbb1f747340d0b910dcdd339c4815c" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание, что когда &lt;code&gt;$z&lt;/code&gt; не равно 0, &lt;code&gt;$rho_s&lt;/code&gt; не равно &lt;code&gt;$rho_c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01c82dfb0bcf881d438ecf1364082366f27c8820" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d590cf6b82e4392a2e3299e1af99133b75ac011" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , or &lt;code&gt;newSVpv&lt;/code&gt; , or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt; . Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt; , which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">Обратите внимание, что вы можете указать длину строки, которая будет назначена, с помощью &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; или &lt;code&gt;newSVpv&lt;/code&gt; , или вы можете разрешить Perl вычислять длину с помощью &lt;code&gt;sv_setpv&lt;/code&gt; или указав 0 в качестве второго аргумента &lt;code&gt;newSVpv&lt;/code&gt; . Однако имейте в виду , что Perl будет определять длину строки с помощью &lt;code&gt;strlen&lt;/code&gt; , который зависит от строки, заканчивающейся символом &lt;code&gt;NUL&lt;/code&gt; и не содержащей других значений NUL.</target>
        </trans-unit>
        <trans-unit id="8388abb49037aa7a9750fb22bcb53bb337bbb687" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt;, &lt;code&gt;newSVpvn&lt;/code&gt;, or &lt;code&gt;newSVpv&lt;/code&gt;, or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt;. Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt;, which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870ccbb59c66300e9b3ea8f52b5a5f559b3dde16" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;OBJECT&lt;/code&gt; attribute. MakeMaker generates the following variables in</source>
          <target state="translated">Обратите внимание на атрибут &lt;code&gt;OBJECT&lt;/code&gt; . MakeMaker генерирует следующие переменные в</target>
        </trans-unit>
        <trans-unit id="f8aba368fbb68d7c50d7b29b9babed1e8eb186e8" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt;, or filetest.</source>
          <target state="translated">Обратите внимание на &lt;code&gt;_&lt;/code&gt; в приведенном выше &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : &lt;code&gt;_&lt;/code&gt; - это волшебный дескриптор файла, который кэширует информацию из предыдущих &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; или filetest.</target>
        </trans-unit>
        <trans-unit id="3649b7d5b5ec60ffba14ae21c7b1c2a9a411dd9a" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;int(-M _)&lt;/code&gt;: the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;stat()&lt;/code&gt;, &lt;code&gt;lstat()&lt;/code&gt;, or filetest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb3a64dceeceb885b9680e4902401cdf9dc4f74" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt; .</source>
          <target state="translated">Обратите внимание на другой порядок аргументов для &lt;code&gt;Copy&lt;/code&gt; и &lt;code&gt;Move&lt;/code&gt; чем в &lt;code&gt;memcpy&lt;/code&gt; и &lt;code&gt;memmove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cfb16d57b3fc1899ca35729db416deb1a5fcf6d" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679c7845eb58a7c2d0b2d8985266c244821c6fe5" translate="yes" xml:space="preserve">
          <source>Notice the last two: you have an undef value, but a defined key!</source>
          <target state="translated">Обратите внимание на два последних:у вас есть значение undef,но определенный ключ!</target>
        </trans-unit>
        <trans-unit id="448c7dc3dc98fc3fc0f5933ff2892ce9313d9152" translate="yes" xml:space="preserve">
          <source>Notice the two lines commented with &quot;XXXXX&quot;. If you check the first part of the typemap file (or section), you'll see that doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg. Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine. These two functions are explained in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;; we'll talk more later about what that &quot;ST(0)&quot; means in the section on the argument stack.</source>
          <target state="translated">Обратите внимание на две строки с комментарием &amp;laquo;XXXXX&amp;raquo;. Если вы проверите первую часть файла (или раздела) карты типов, вы увидите, что двойники имеют тип T_DOUBLE. В части INPUT карты типов аргумент T_DOUBLE присваивается переменной arg путем вызова подпрограммы SvNV для чего-то, затем преобразования ее в значение double, а затем присваивается переменной arg. Точно так же в разделе OUTPUT, как только arg принимает окончательное значение, оно передается в функцию sv_setnv, чтобы передать ее обратно вызывающей подпрограмме. Эти две функции объяснены в &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; ; мы поговорим позже о том, что означает &amp;laquo;ST (0)&amp;raquo; в разделе о стеке аргументов.</target>
        </trans-unit>
        <trans-unit id="d783d11df518bc5c15566c5aca0ab336d7d1805f" translate="yes" xml:space="preserve">
          <source>Notice the use of GV_ADD as the second parameter. The new variable can now be set, using the routines appropriate to the data type.</source>
          <target state="translated">Обратите внимание на использование GV_ADD в качестве второго параметра.Новая переменная теперь может быть установлена с помощью процедур,соответствующих типу данных.</target>
        </trans-unit>
        <trans-unit id="08b42440fb285e46d8dc9159db458556192da3bc" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/x&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">Обратите внимание на пробелы в этих примерах. В этой конструкции всегда включен модификатор &lt;code&gt;/x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="319e2b5eaf07860409d97b11c5611e8f5cc65281" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/xx&lt;/code&gt; modifier turned on within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd6270a12f8b7eb8c9c200a3723ca7a45c46729" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&quot;Internal Functions&quot; in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf19896e6984078f566d31f89bc10d28920f05df" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">Обратите внимание, что мы используем &lt;code&gt;Perl_pp_add&lt;/code&gt; , а не &lt;code&gt;pp_add&lt;/code&gt; - см. &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Внутренние функции в perlguts&lt;/a&gt; . Установив точку останова, мы можем запустить нашу программу:</target>
        </trans-unit>
        <trans-unit id="49e7942c0e9764eb733db50ae6c6f21e34cbe873" translate="yes" xml:space="preserve">
          <source>Notify an according IPv6 MTU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cb5b7c921fb7ebbe36d3e0607902dde126730c" translate="yes" xml:space="preserve">
          <source>Notify is used to request Delivery Status Notifications (DSNs), but your SMTP/ESMTP service may not respect this request depending upon its version and your site's SMTP configuration.</source>
          <target state="translated">Уведомление используется для запроса Уведомлений о состоянии доставки (Delivery Status Notifications-DSNs),но ваша служба SMTP/ESMTP может не уважать этот запрос в зависимости от его версии и конфигурации SMTP вашего сайта.</target>
        </trans-unit>
        <trans-unit id="da17090b524f51c10e88d0ac9b7049f8740a008e" translate="yes" xml:space="preserve">
          <source>Notify the server that the current message should be sent to all of the addresses given. Each address is sent as a separate command to the server. Should the sending of any address result in a failure then the process is aborted and a</source>
          <target state="translated">Сообщите серверу,что текущее сообщение должно быть отправлено по всем указанным адресам.Каждый адрес отправляется серверу отдельной командой.Если отправка какого-либо адреса приводит к сбою,то процесс прерывается и команда a</target>
        </trans-unit>
        <trans-unit id="9cbb4030243333159ba8734d1c5fd629386f77ad" translate="yes" xml:space="preserve">
          <source>Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.</source>
          <target state="translated">Novell NetWare наследует поведение File::Spec от File::Spec::Win32.</target>
        </trans-unit>
        <trans-unit id="f596d3f268eaea786d51ab55e3200ab8fc6af9a4" translate="yes" xml:space="preserve">
          <source>November 13, 2003</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ef706a9203ebb1532a39a12c049758f080c8c3" translate="yes" xml:space="preserve">
          <source>November 16, 2003</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0d9da26bf041d32a0675226f59b963b86e2fb7" translate="yes" xml:space="preserve">
          <source>November 2006</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6807acb122cd8525edb3b470a139acef9bafbd" translate="yes" xml:space="preserve">
          <source>November, 2007; by Christophe Grosjean: make cmpthese and timestr compute time consistently with style argument, default is 'all' not 'noc' any more.</source>
          <target state="translated">Ноябрь,2007;по словам Кристофа Грошжана:сделайте cmpthese и timestr вычислить время в соответствии с аргументом стиля,по умолчанию 'all' больше не 'noc'.</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="c93d8b194f0c7fe984e291581c08b1052c5f3a15" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; is always 20 plus whatever $n you pass in, whereas &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; is always 555 plus whatever $n you pass in. The $addpiece in the closure sticks around.</source>
          <target state="translated">Теперь &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; всегда равно 20 плюс все, что вы передаете $ n, тогда как &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; всегда 555 плюс все, что вы передаете. $ Addpiece в закрытии остается.</target>
        </trans-unit>
        <trans-unit id="f44dcb817094334da756769457dbdcc2f78729c5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside $re):</source>
          <target state="translated">Теперь &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; позволяет использовать новый escape- код в постоянных регулярных выражениях, т. Е. Без каких-либо интерполяций переменных времени выполнения. Как описано в &lt;a href=&quot;overload&quot;&gt;перегрузке&lt;/a&gt; , это преобразование будет работать только с буквальными частями регулярных выражений. Для &lt;code&gt;\Y|$re\Y|&lt;/code&gt; переменная часть этого регулярного выражения должна быть преобразована явно (но только если особое значение &lt;code&gt;\Y|&lt;/code&gt; должно быть разрешено внутри $ re):</target>
        </trans-unit>
        <trans-unit id="fade66a80437ba60181e3ddce42855f68a77521c" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;use customre&lt;/code&gt; enables the new escape in constant regular expressions,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01a23641a218b7388c86b594decd3175ef90f36" translate="yes" xml:space="preserve">
          <source>Now I can run my tests like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5baf71e7fbf158fd008d8c03a7a8fa212d5b45f" translate="yes" xml:space="preserve">
          <source>Now I'll create a C program,</source>
          <target state="translated">Теперь я создам программу на Си,</target>
        </trans-unit>
        <trans-unit id="2b1360bf75473ee9266121d81e1a06dd9911acef" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">Теперь кажется, что все эти разные функции существуют независимо. Вы можете вызывать red (), RED (), blue (), BLUE (), green () и т. Д. Этот метод экономит время компиляции и использование памяти, а также менее подвержен ошибкам, поскольку проверки синтаксиса выполняются в время компиляции. Очень важно, чтобы любые переменные в анонимной подпрограмме были лексическими, чтобы создать правильное закрытие. Это причины для переменной итерации цикла &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fabedd5297cac1df38e4fa79abf11492e74b2a01" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;my&lt;/code&gt; on the loop iteration variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd34829b18de1627725a95c603c191742b917e4" translate="yes" xml:space="preserve">
          <source>Now all you have to do is make.</source>
          <target state="translated">Теперь все,что тебе нужно сделать,это сделать.</target>
        </trans-unit>
        <trans-unit id="49b5690000abd466cabd2983e572f96822c8ad4b" translate="yes" xml:space="preserve">
          <source>Now an example using G_EVAL. Below is a Perl subroutine which computes the difference of its 2 parameters. If this would result in a negative result, the subroutine calls</source>
          <target state="translated">Теперь пример с использованием G_EVAL.Ниже приведена подпрограмма Perl,которая вычисляет разность своих 2 параметров.Если это приведет к отрицательному результату,то подпрограмма вызовет</target>
        </trans-unit>
        <trans-unit id="0107493cf3f67fc1eae2d61845bafd402e29a874" translate="yes" xml:space="preserve">
          <source>Now being maintained by Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;</source>
          <target state="translated">Сейчас поддерживается Нилом Бауэрсом &amp;lt;neilb@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d0a0f59849b2d6f78aa32cc04ac0bc8777dc3df0" translate="yes" xml:space="preserve">
          <source>Now build an on-the-fly object over a couple of lines (note the backslash):</source>
          <target state="translated">Теперь построим объект &quot;на лету&quot; через пару строк (обратите внимание на обратный слеш):</target>
        </trans-unit>
        <trans-unit id="b18a77ba9bd692a2de2351fc4472b7905512dae7" translate="yes" xml:space="preserve">
          <source>Now change that to call a Perl subroutine instead</source>
          <target state="translated">Теперь измените это,чтобы вместо этого вызвать подпрограмму Perl.</target>
        </trans-unit>
        <trans-unit id="5eed8faf15fe7e07bcc558e5fbc255c10a771276" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt; .</source>
          <target state="translated">Теперь проверьте, истинно ли &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; для некоторого &lt;code&gt;$n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10a01ad64127827e39a88ed3009004d810d71655" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;vec($read,$n,1)&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35cab876c88e9037a6396981d2ddc61575d5495f" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">А теперь самое интересное. Строки в нашей бухгалтерской книге, которые представляют собой только доходы, а не расходы, могут заканчиваться в столбце 46. Следовательно, мы не хотим сообщать нашему шаблону &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , что нам &lt;b&gt;нужно&lt;/b&gt; найти еще 12 символов; мы просто скажем: &amp;laquo;если что-то осталось, бери&amp;raquo;. Как вы могли догадаться по регулярным выражениям, это означает , что &lt;code&gt;*&lt;/code&gt; означает: &amp;laquo;использовать все, что осталось&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2aed8f2583a2025408738c1655ec69d76cbf4265" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;unpack&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3043847bd2200864abd83a13618a02dee8ec6266" translate="yes" xml:space="preserve">
          <source>Now commit your change locally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13bda202e6718f6f18d21a1e47f52cfb3879053" translate="yes" xml:space="preserve">
          <source>Now compile this program (I'll call it</source>
          <target state="translated">Теперь скомпилируйте эту программу (я назову ее</target>
        </trans-unit>
        <trans-unit id="c57d72b147b5753e6d9e423d3502ca9248d5f07f" translate="yes" xml:space="preserve">
          <source>Now compile:</source>
          <target state="translated">Теперь собирай:</target>
        </trans-unit>
        <trans-unit id="f3d2e76534a9f4dbbaafe0b2d7b2922184fb31d5" translate="yes" xml:space="preserve">
          <source>Now consider floating point numbers with exponents. The key observation here is that</source>
          <target state="translated">Теперь рассмотрим числа с плавающей точкой с экспонентами.Ключевое наблюдение здесь заключается в том,что</target>
        </trans-unit>
        <trans-unit id="6e69790285fa3d81bdaeedc9a045cae201d21c12" translate="yes" xml:space="preserve">
          <source>Now consider what the code looks like without &lt;code&gt;InputLength&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2a183c3b41e6c536df243f1dce108cb53ffa0f" translate="yes" xml:space="preserve">
          <source>Now edit the Mytest2.t script and change the number of tests to &quot;4&quot;, and add the following lines to the end of the script:</source>
          <target state="translated">Теперь отредактируйте скрипт Mytest2.t и измените количество тестов на &quot;4&quot;,и добавьте следующие строки в конец скрипта:</target>
        </trans-unit>
        <trans-unit id="2953f00009a89200e277b692ef57868b268aff69" translate="yes" xml:space="preserve">
          <source>Now for an example of dealing with the items returned from a Perl subroutine.</source>
          <target state="translated">Теперь рассмотрим пример работы с предметами,возвращенными из подпрограммы Perl.</target>
        </trans-unit>
        <trans-unit id="0be3c2c5225baac76521af82d8668e34f7dced50" translate="yes" xml:space="preserve">
          <source>Now for something much more complex: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</source>
          <target state="translated">Теперь о чем-то более сложном: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92162dfafb815308e37a13a29bc3866c727f49ac" translate="yes" xml:space="preserve">
          <source>Now if $baz is overloaded like this, then &lt;code&gt;$baz&lt;/code&gt; is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</source>
          <target state="translated">Теперь, если $ baz перегружен таким образом, тогда &lt;code&gt;$baz&lt;/code&gt; является ссылкой на ссылку на промежуточный массив, который хранит ссылку на фактический массив и хэш доступа. Объект tie () для хэша доступа - это ссылка на ссылку на фактический массив, поэтому</target>
        </trans-unit>
        <trans-unit id="442765a41777ec67298b58abdc70ce2f732fb2a5" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt; :</source>
          <target state="translated">Теперь, если мы видим &lt;code&gt;U&lt;/code&gt; , который был в начале строки, мы &lt;code&gt;UTF8&lt;/code&gt; флаг UTF8 для выходного SV, &lt;code&gt;cat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5914acd073f333e4c23a4d84f2aa14b4552e8013" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa71504ceae318c2af66092e17c9a82a7deb8c3" translate="yes" xml:space="preserve">
          <source>Now inner() can only be called from within outer(), because of the temporary assignments of the anonymous subroutine. But when it does, it has normal access to the lexical variable $x from the scope of outer() at the time outer is invoked.</source>
          <target state="translated">Теперь функция inner()может вызываться только изнутри функции outer(),из-за временных назначений анонимной подпрограммы.Но когда она это делает,она имеет нормальный доступ к лексической переменной $x из области видимости outer()в момент вызова outer().</target>
        </trans-unit>
        <trans-unit id="f0dd64db78144735f7994758b886eab3a665aa14" translate="yes" xml:space="preserve">
          <source>Now is the time to build statically linked executable</source>
          <target state="translated">Настало время построить статически привязанный исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="56e8b027d2534e474052d61aa156186a15f1e672" translate="yes" xml:space="preserve">
          <source>Now issue a command all Perl Mongers love:</source>
          <target state="translated">Теперь отдай команду,которую любят все Перл-Монгеры:</target>
        </trans-unit>
        <trans-unit id="5afbbbcc6562eb3dd44ab3aeee5e6e877aac172d" translate="yes" xml:space="preserve">
          <source>Now it always returns &lt;code&gt;NOT_IN_PAD&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a1925328e3fa40f64265288667627705914e38" translate="yes" xml:space="preserve">
          <source>Now it really looks like two-dimensional arrays!</source>
          <target state="translated">Теперь это действительно похоже на двухмерные массивы!</target>
        </trans-unit>
        <trans-unit id="6e306ced46a050d218e4778907f520f756de263d" translate="yes" xml:space="preserve">
          <source>Now it's time to print your data structure out. How are you going to do that? Well, if you want only one of the elements, it's trivial:</source>
          <target state="translated">Теперь пришло время распечатать структуру данных.Как ты собираешься это сделать? Ну,если тебе нужен только один из элементов,это тривиально:</target>
        </trans-unit>
        <trans-unit id="54ce2aa34a908b75653982fdea46ab158bc6415a" translate="yes" xml:space="preserve">
          <source>Now just type in any legal Perl code, and it will be immediately evaluated. You can also examine the symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typically found in symbolic debuggers.</source>
          <target state="translated">Теперь просто введите любой легальный Perl-код,и он будет немедленно оценен.Вы также можете просмотреть таблицу символов,получить обратные стеки,проверить значения переменных,установить точки останова и другие операции,обычно встречающиеся в отладчиках символов.</target>
        </trans-unit>
        <trans-unit id="71eab03d0589285d163e163d02feef9a891122b5" translate="yes" xml:space="preserve">
          <source>Now let's add to our extension a subroutine that will take a single numeric argument as input and return 1 if the number is even or 0 if the number is odd.</source>
          <target state="translated">Теперь добавим в наше расширение подпрограмму,которая примет на вход один числовой аргумент и вернёт 1,если число четное или 0,если число нечетное.</target>
        </trans-unit>
        <trans-unit id="b25fbca1c3ebbbe365fafa21da05b0bf381c9042" translate="yes" xml:space="preserve">
          <source>Now let's go on with the show!</source>
          <target state="translated">А теперь давайте продолжим шоу!</target>
        </trans-unit>
        <trans-unit id="56c9d0bafceed9745ea4a5c37d241ab5110ecbe0" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt; : we take a pattern into &lt;code&gt;pat&lt;/code&gt; , and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt; . Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt; .</source>
          <target state="translated">Теперь давайте посмотрим на &lt;code&gt;pp_pack&lt;/code&gt; : мы берем шаблон в &lt;code&gt;pat&lt;/code&gt; , а затем перебираем шаблон, принимая каждый символ формата по очереди в &lt;code&gt;datum_type&lt;/code&gt; . Затем для каждого возможного символа формата мы поглощаем другие аргументы в шаблоне (ширину поля, звездочку и т. Д.) И преобразуем следующий входной блок в указанный формат, добавляя его в выходной SV &lt;code&gt;cat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72fe90f904deeeb9bda4270aff1109f958440f65" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt;: we take a pattern into &lt;code&gt;pat&lt;/code&gt;, and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt;. Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bfc0dd7ed8b536789ace2adf6482eed3ae9d5d" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt; , which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">Теперь давайте сделаем немного более сложный пример. На этот раз мы хотим вызвать подпрограмму Perl &lt;code&gt;LeftString&lt;/code&gt; , которая будет принимать 2 параметра - строку ($ s) и целое число ($ n). Подпрограмма просто напечатает первые $ n символов строки.</target>
        </trans-unit>
        <trans-unit id="a1cd28db828b3965b5fb8cb34a20f3c4db616851" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt;, which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf057ced369b422ce2c543343cfe6f097b71cc60" translate="yes" xml:space="preserve">
          <source>Now let's see what happens when you try to decode from ISO-2022-JP and the buffer ends in the middle of a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6354d1ac356f03ba53418ed6480c6b835c8d11e3" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt; . We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">Теперь попробуем узор посложнее. Мы добавим квантификатор, так что теперь у нас есть шаблон &lt;code&gt;/foo+/&lt;/code&gt; . Мы увидим , что &lt;code&gt;regbranch()&lt;/code&gt; вызовы &lt;code&gt;regpiece()&lt;/code&gt; дважды.</target>
        </trans-unit>
        <trans-unit id="364c0b15409d7672a94bf5ecd988b5c8a1f0315d" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt;. We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cb79a776cb969edc30e88cc6131bd19fb97fb3" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl 5 Porters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889bc56f5635509a3bf0cc79dcaae69476badde9" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl5 Porters.</source>
          <target state="translated">Теперь обслуживается Perl5 Porters.</target>
        </trans-unit>
        <trans-unit id="2038fc7801848170606c108e5b8808a37af01abf" translate="yes" xml:space="preserve">
          <source>Now numeric value of $c is 5. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; the numeric value of $c becomes 13. To insulate the user of the module add a method</source>
          <target state="translated">Теперь числовое значение $ c равно 5. После &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; числовое значение $ c становится 13. Чтобы изолировать пользователя модуля, добавьте метод</target>
        </trans-unit>
        <trans-unit id="8af21af6d9d9b5497a4644877b2f52927ff73040" translate="yes" xml:space="preserve">
          <source>Now one can access an object using both the array and hash syntax:</source>
          <target state="translated">Теперь можно получить доступ к объекту как с помощью синтаксиса массива,так и с помощью синтаксиса хэша:</target>
        </trans-unit>
        <trans-unit id="0d5501fb3c867cabba9520f061ccb7181169320a" translate="yes" xml:space="preserve">
          <source>Now one can change the last line of the script to</source>
          <target state="translated">Теперь можно изменить последнюю строку скрипта на</target>
        </trans-unit>
        <trans-unit id="36a34b3fdc67a4c118c486e51977f9c88c24fbb9" translate="yes" xml:space="preserve">
          <source>Now one can finish the script by</source>
          <target state="translated">Теперь можно закончить сценарий на</target>
        </trans-unit>
        <trans-unit id="fb12351c6667dd534972c89f66e0ea83ea3b515d" translate="yes" xml:space="preserve">
          <source>Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make.</source>
          <target state="translated">Теперь выполните те же действия,что и раньше,сгенерировав Makefile из файла Makefile.PL и запустив make.</target>
        </trans-unit>
        <trans-unit id="176a110722147c376bebc4313178934ce4ec0c61" translate="yes" xml:space="preserve">
          <source>Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.</source>
          <target state="translated">Теперь процесс &quot;А&quot; обновляет БД и случайно меняет часть данных,хранящихся в исходном буфере.Процесс &quot;А&quot; завершается,все кэшированные данные смываются на диск и освобождается блокировка БД.В этот момент БД на диске будет корректно отражать изменения,сделанные процессом &quot;А&quot;.</target>
        </trans-unit>
        <trans-unit id="ef78e970daca9bfe36844c130043d8db552b721e" translate="yes" xml:space="preserve">
          <source>Now re-run make to rebuild our new shared library.</source>
          <target state="translated">Теперь перезапустите make,чтобы перестроить нашу новую общую библиотеку.</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="translated">Теперь бегите</target>
        </trans-unit>
        <trans-unit id="43d39e890e8ba24fba8997c278066f474d3fd060" translate="yes" xml:space="preserve">
          <source>Now run perl on the top-level Makefile.PL. Notice that it also created a Makefile in the mylib directory. Run make and watch that it does cd into the mylib directory and run make in there as well.</source>
          <target state="translated">Теперь запустите perl на верхнем уровне Makefile.PL.Обратите внимание,что он также создал Makefile в каталоге mylib.Запустите make и посмотрите,что он делает cd в каталоге mylib,а также запустите make там.</target>
        </trans-unit>
        <trans-unit id="9680a56da8828aa80b4fe46f2d0d313dfaabb116" translate="yes" xml:space="preserve">
          <source>Now run:</source>
          <target state="translated">Теперь беги:</target>
        </trans-unit>
        <trans-unit id="431a120b5d4a3c45e45ae8e764d0243bae7f6294" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; , so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">Теперь предположим, что у нас одновременно работает более одного экземпляра интерпретатора. Это возможно, но только если вы использовали параметр Configure &lt;code&gt;-Dusemultiplicity&lt;/code&gt; или параметры &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; при сборке Perl. По умолчанию включение одной из этих опций Configure устанавливает глобальную переменную &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; для каждого интерпретатора в значение &lt;code&gt;1&lt;/code&gt; , поэтому тщательная очистка выполняется автоматически, а переменные интерпретатора инициализируются правильно. Даже если вы не собираетесь запускать два или более интерпретатора одновременно, а запускать их последовательно, как в приведенном выше примере, рекомендуется создавать perl с помощью &lt;code&gt;-Dusemultiplicity&lt;/code&gt; в противном случае некоторые переменные интерпретатора могут быть неправильно инициализированы между последовательными запусками, и ваше приложение может аварийно завершить работу.</target>
        </trans-unit>
        <trans-unit id="f1903abcbcbb8a74636f09d2f5f2bcae4b5c5eed" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49fb62e1176de7722979d95af388dc41f0ee3b3" translate="yes" xml:space="preserve">
          <source>Now switch back to blead and merge your smoke-me branch into it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1ba3c5bd850f498e4d354eafd68e49756fd894" translate="yes" xml:space="preserve">
          <source>Now take a look at your current directory. It should look like this.</source>
          <target state="translated">Теперь посмотрите на свой текущий каталог.Он должен выглядеть так.</target>
        </trans-unit>
        <trans-unit id="bee8b14e16d518df0acbce192d7aea4caa41e326" translate="yes" xml:space="preserve">
          <source>Now that I know how to subclass and replace TAP::Harness I can replace any other part of the harness. To do that I need to know which classes are responsible for which functionality. Here's a brief guided tour; the default class for each component is shown in parentheses. Normally any replacements I write will be subclasses of these default classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb0ec981d97896d9a67b5f9341746480fee45ab" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="translated">Теперь, когда UNTIE существует, разработчик класса может решить, какие части функциональности класса действительно связаны с &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; , а какие с уничтожаемым объектом. Что имеет смысл для данного класса, зависит от того, сохраняются ли внутренние ссылки, чтобы для объекта можно было вызывать методы, не связанные с связями. Но в большинстве случаев, вероятно, имеет смысл перенести функциональность, которая была бы в DESTROY, в метод UNTIE.</target>
        </trans-unit>
        <trans-unit id="7a99ac155b6f06ce4dfb04db2128fc497e50d4a6" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;untie&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6856d572f5c42bc67bf2b06905ca5effd5d4772" translate="yes" xml:space="preserve">
          <source>Now that basic require() and subroutines are tested, you can use the</source>
          <target state="translated">Теперь,когда основные функции require()и подпрограммы протестированы,вы можете воспользоваться функцией</target>
        </trans-unit>
        <trans-unit id="efac8814e4d76977800b30df75313c1fb6bb539a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="translated">Теперь, когда &amp;laquo;собственный&amp;raquo; механизм поддерживается &lt;code&gt;Sys::Syslog&lt;/code&gt; и выбран по умолчанию, использование функции &lt;code&gt;setlogsock()&lt;/code&gt; не рекомендуется, поскольку другие механизмы менее переносимы в операционных системах. Авторам модулей и программ, которые используют эту функцию, особенно ее культовой формы &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , рекомендуется удалять все ее вхождения, если они специально не хотят использовать данный механизм (например, TCP или UDP для подключения к удаленному компьютеру). хост).</target>
        </trans-unit>
        <trans-unit id="d6e5bb6ea11f530904bdc5de7317a278720bcd2a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt;, are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2001533940f7a7dc78b5938ec0ecf76cf899fefd" translate="yes" xml:space="preserve">
          <source>Now that the core of Perl is tested, &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; can and should be used. You can also use the full suite of core modules in the tests.</source>
          <target state="translated">Теперь, когда ядро ​​Perl протестировано, &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; можно и нужно использовать. Вы также можете использовать в тестах полный набор основных модулей.</target>
        </trans-unit>
        <trans-unit id="24ff55bc098331b9dd0a021350302b6152b1136b" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&quot;Reference Counts and Mortality&quot;&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7692728e97a21b18614fd5385fcbfb77d3648e29" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;):</source>
          <target state="translated">Теперь, когда в стеке есть место, значения могут быть &lt;code&gt;PUSHs&lt;/code&gt; него с помощью макроса PUSHs . Передаваемые значения часто должны быть &quot;смертными&quot; (см. &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Подсчет ссылок и смертность&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="db9f415821b5ff335d6377b90972d196cfedc3a0" translate="yes" xml:space="preserve">
          <source>Now that we have everything up to date, we need to create a temporary new branch for these changes and switch into it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30355dc46fa236bc2762d6b874a869adc19e6693" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="translated">Теперь, когда мы увидели &lt;code&gt;P&lt;/code&gt; в действии, мы могли бы с таким же успехом крутить &lt;code&gt;p&lt;/code&gt; . Зачем нам вообще нужен второй шаблонный код для упаковки указателей? Ответ кроется в простом факте, что &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;p&lt;/code&gt; обещает строку с завершающим нулем, начинающуюся с адреса, взятого из буфера, и это подразумевает длину возвращаемого элемента данных:</target>
        </trans-unit>
        <trans-unit id="845be3729f8e1471aa9c19871b5191d2af6f12bb" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;unpack&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3289c147e35201c5816ca81ac2c53e6c21248267" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt; .</source>
          <target state="translated">Теперь, когда у нас есть нотация &lt;code&gt;*foo{THING}&lt;/code&gt; , typeglobs не так часто используются для манипуляций с дескрипторами файлов, хотя они все еще необходимы для передачи новых дескрипторов файлов и каталогов в функции или из функций. Это потому, что &lt;code&gt;*HANDLE{IO}&lt;/code&gt; работает, только если HANDLE уже использовался как дескриптор. Другими словами, &lt;code&gt;*FH&lt;/code&gt; необходимо использовать для создания новых записей таблицы символов; &lt;code&gt;*foo{THING}&lt;/code&gt; не может. В случае сомнений используйте &lt;code&gt;*FH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f7be970c41cd87a6fd574ed69a37113f5eb82d1" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fb438178c3f179a69d1380f1c008b5fe2d33bb" translate="yes" xml:space="preserve">
          <source>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</source>
          <target state="translated">Теперь,когда у нас есть этот шаблон,хранящийся как удобная строка,мы можем почувствовать искушение использовать его как часть какого-нибудь другого шаблона:</target>
        </trans-unit>
        <trans-unit id="e29c91f0a31611481726db8f6cd5987db898348a" translate="yes" xml:space="preserve">
          <source>Now that we know the two token types we want to look for in the parser, let's take the piece of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c183105c83816c48c77d4c827336e4e813e84f27" translate="yes" xml:space="preserve">
          <source>Now that we've covered the basics of threads, it's time for our next topic: Data. Threading introduces a couple of complications to data access that non-threaded programs never need to worry about.</source>
          <target state="translated">Теперь,когда мы рассмотрели основы нитей,пришло время для нашей следующей темы:Данные.Потоки вводят пару осложнений в доступ к данным,о которых не нужно беспокоиться не-потоковым программам.</target>
        </trans-unit>
        <trans-unit id="17f47b8aedf9a1b8e0f108087ca6f763b020db20" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="translated">Теперь, когда вы знаете, в чем проблема, что вы можете сделать, чтобы ее избежать? До введения необязательного метода UNTIE единственным выходом был старый добрый флаг &lt;code&gt;-w&lt;/code&gt; . Это обнаружит любые экземпляры, в которых вы вызываете untie (), и все еще есть действительные ссылки на связанный объект. Если второй сценарий выше этого, рядом с верхним, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; или был запущен с флагом &lt;code&gt;-w&lt;/code&gt; , Perl выводит это предупреждающее сообщение:</target>
        </trans-unit>
        <trans-unit id="9771972202eb1f3782008cf8f55ca4ed0bc679ec" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;use warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c455331af53bbe930455abd94381aad022a312" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks for a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022bdd2be74a4d788e977f99278118a67ba2ad8d" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">Теперь, когда вы понимаете, как &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет файлы с аргументом bareword, за кулисами происходит небольшая дополнительная функциональность. Прежде чем &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет &quot;</target>
        </trans-unit>
        <trans-unit id="597f8013d78df265fd55b188a128a0c6cbbf532e" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">Теперь, когда вы понимаете, как &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет файлы с аргументом bareword, за кулисами происходит небольшая дополнительная функциональность. Прежде чем &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ищет &quot;</target>
        </trans-unit>
        <trans-unit id="b76e84f2c33cd5c972aa524cad0960f89f22f060" translate="yes" xml:space="preserve">
          <source>Now the command line may look like:</source>
          <target state="translated">Теперь командная строка может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="3b566ef89971d6ba2da0e75e174d6b74566a53f9" translate="yes" xml:space="preserve">
          <source>Now the contents of the zip file looks like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70b0be20fc0cb8a073d7d288b92a6e5925d77b2" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Теперь в выводе нет пробелов между элементами, потому что элементы &lt;code&gt;@animals&lt;/code&gt; просто становятся частью списка для &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6712df82bd0b409fccf382c7eb4775322c433e9" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3e5717f93544ac6beb2dcf88b8c55f969febc1" translate="yes" xml:space="preserve">
          <source>Now the output shows that &lt;code&gt;foo&lt;/code&gt; doesn't get the &lt;code&gt;@_&lt;/code&gt; from its caller.</source>
          <target state="translated">Теперь вывод показывает, что &lt;code&gt;foo&lt;/code&gt; не получает &lt;code&gt;@_&lt;/code&gt; от вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="3fcb9eb262daa67d00f7dccd8fa99c81f713a40e" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt; , instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="translated">Теперь этап синтаксического анализа завершен, и готовое дерево представляет операции, которые интерпретатор Perl должен выполнить для выполнения нашей программы. Затем Perl выполняет пробный прогон по дереву в поисках оптимизации: теперь будут вычисляться константные выражения, такие как &lt;code&gt;3 + 4&lt;/code&gt; , и оптимизатор также увидит, можно ли заменить какие-либо несколько операций одной. Например, чтобы получить переменную &lt;code&gt;$foo&lt;/code&gt; , вместо того , чтобы брать glob &lt;code&gt;*foo&lt;/code&gt; и смотреть на скалярный компонент, оптимизатор возится с операционным деревом, чтобы использовать функцию, которая напрямую ищет рассматриваемый скаляр. Главный оптимизатор - &lt;code&gt;peep&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="81df9ba059e2ff0a47a803c9c1c7ea076906b2e7" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt;, instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0d2c80b383fda949460859c7cc860ad47a12c4" translate="yes" xml:space="preserve">
          <source>Now the rpcb_gettime() function can be used from Perl with the following statement.</source>
          <target state="translated">Теперь функцию rpcb_gettime()можно использовать от Perl со следующим утверждением.</target>
        </trans-unit>
        <trans-unit id="9b44a2219a59e7204e7ee350a2cc75af078d1e4b" translate="yes" xml:space="preserve">
          <source>Now think about</source>
          <target state="translated">Теперь подумайте о</target>
        </trans-unit>
        <trans-unit id="c30cd0c985054472ce92540629db69d82b31ed97" translate="yes" xml:space="preserve">
          <source>Now think of each logical connection between the Perl parser and an individual file as a</source>
          <target state="translated">Теперь подумайте о каждой логической связи между парсером Perl и отдельным файлом как о</target>
        </trans-unit>
        <trans-unit id="c36ab80c850235a2a6535979a5e221cbafe139d7" translate="yes" xml:space="preserve">
          <source>Now to use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aed2505c6485cbd9c4824f7162c565df48aa33" translate="yes" xml:space="preserve">
          <source>Now type</source>
          <target state="translated">Now type</target>
        </trans-unit>
        <trans-unit id="69d98bfb814f8df94eddba674df944be471dcc9f" translate="yes" xml:space="preserve">
          <source>Now we also need to create a typemap because the default Perl doesn't currently support the &lt;code&gt;const char *&lt;/code&gt; type. Include a new TYPEMAP section in your XS code before the above function:</source>
          <target state="translated">Теперь нам также нужно создать карту типов, потому что Perl по умолчанию в настоящее время не поддерживает тип &lt;code&gt;const char *&lt;/code&gt; . Включите новый раздел TYPEMAP в свой код XS перед вышеуказанной функцией:</target>
        </trans-unit>
        <trans-unit id="ac3c0b8b639b2123b87b956629756b446c6934e9" translate="yes" xml:space="preserve">
          <source>Now we can have a look at that first ($key) variable:</source>
          <target state="translated">Теперь мы можем взглянуть на эту первую ($key)переменную:</target>
        </trans-unit>
        <trans-unit id="8697ceaf2dd16f4d4adec9ebfeb7ec483f31a8a6" translate="yes" xml:space="preserve">
          <source>Now we can inspect the change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185a7b552e431f4b4b46cbef152d792a78593a6f" translate="yes" xml:space="preserve">
          <source>Now we can match the 'a' and the 't'.</source>
          <target state="translated">Теперь мы можем сопоставить &quot;а&quot; и &quot;т&quot;.</target>
        </trans-unit>
        <trans-unit id="1a6585115684561f6afa96412beafcc752dc7c11" translate="yes" xml:space="preserve">
          <source>Now we can test bunches of dates by just adding them to &lt;code&gt;%ICal_Dates&lt;/code&gt;. Now that it's less work to test with more dates, you'll be inclined to just throw more in as you think of them. Only problem is, every time we add to that we have to keep adjusting the &lt;code&gt;use Test::More tests =&amp;gt; ##&lt;/code&gt; line. That can rapidly get annoying. There are ways to make this work better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd64428bd387110ec5af71e395507d7b42d715c" translate="yes" xml:space="preserve">
          <source>Now we can use the subroutine just as any other built-in function:</source>
          <target state="translated">Теперь мы можем использовать подпрограмму так же,как и любую другую встроенную функцию:</target>
        </trans-unit>
        <trans-unit id="5dd4060fc442a49be75b77cb5ad37ebb6eff79fc" translate="yes" xml:space="preserve">
          <source>Now we have a special case. The &lt;code&gt;EXACT&lt;/code&gt; regop has a &lt;code&gt;regnext&lt;/code&gt; of 0. This is because if it matches it should try to match itself again. The &lt;code&gt;PLUS&lt;/code&gt; regop handles the actual failure of the &lt;code&gt;EXACT&lt;/code&gt; regop and acts appropriately (going to regnode 6 if the &lt;code&gt;EXACT&lt;/code&gt; matched at least once, or failing if it didn't).</source>
          <target state="translated">Теперь у нас есть особый случай. &lt;code&gt;EXACT&lt;/code&gt; regop имеет &lt;code&gt;regnext&lt;/code&gt; 0. Это происходит потому , если он соответствует он должен попытаться соответствовать себя снова. &lt;code&gt;PLUS&lt;/code&gt; regop обрабатывает фактический провал &lt;code&gt;EXACT&lt;/code&gt; regop и действует соответствующим образом (будет regnode 6 , если &lt;code&gt;EXACT&lt;/code&gt; соответствует по крайней мере один раз, или неудачны , если это не так).</target>
        </trans-unit>
        <trans-unit id="9e8623792298834d51348eb8a4e63d54b4322603" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), run the script and we should see the following output:</source>
          <target state="translated">Теперь мы делаем скрипт исполняемым ( &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), запускаем скрипт, и мы должны увидеть следующий результат:</target>
        </trans-unit>
        <trans-unit id="612f354eccf60522636de9e810f79a1b463240fa" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;chmod +x hello&lt;/code&gt;), run the script and we should see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27be17fcef7387e3ac6e2da3084db2de80fc9a40" translate="yes" xml:space="preserve">
          <source>Now we pass Perl the command line options, and tell it to go:</source>
          <target state="translated">Теперь мы передадим Perl параметры командной строки и скажем ему,чтобы он ушел:</target>
        </trans-unit>
        <trans-unit id="ddfe38df65672eb8cb8bb6b4c2a3925df733b91b" translate="yes" xml:space="preserve">
          <source>Now we read that file in paragraph mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619205ae318e9243260c596997993412134beb8d" translate="yes" xml:space="preserve">
          <source>Now we skip another character and pick up the next 7 characters:</source>
          <target state="translated">Теперь мы пропустим еще одного персонажа и подберем следующие 7 символов:</target>
        </trans-unit>
        <trans-unit id="00d5b0ef9c96351760d2c5c765c6707b0214ca3c" translate="yes" xml:space="preserve">
          <source>Now we'll continue down into our subroutine, this time rather than by line number, we'll use the subroutine name, followed by the now familiar 'v':</source>
          <target state="translated">Теперь мы продолжим вниз в нашу подпрограмму,на этот раз,а не по номеру строки,мы будем использовать имя подпрограммы,за которым последует теперь уже знакомая 'v':</target>
        </trans-unit>
        <trans-unit id="cb9e80e524c6f9e9ce8a182f0f81c0eb761fa3d6" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="translated">Теперь запустим &quot; &lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. Это создаст настоящий Makefile, в котором содержатся потребности. Его вывод выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="35f5a06d15d5037b074e44b9f8538d07cbd8815f" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt;&quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de2aee884a419878e3de43e61bda1852424c1b9" translate="yes" xml:space="preserve">
          <source>Now we'll test that we got that space-at-the-beginning business right:</source>
          <target state="translated">Теперь мы проверим,что у нас есть место в начальном бизнесе правильно:</target>
        </trans-unit>
        <trans-unit id="ee9f66c8ea145e68aa8eae836da50bbcb17dec57" translate="yes" xml:space="preserve">
          <source>Now we're finally ready to go: we have compiled Perl byte code, and all that's left to do is run it. The actual execution is done by the &lt;code&gt;runops_standard&lt;/code&gt; function in</source>
          <target state="translated">Теперь мы, наконец, готовы к работе: мы скомпилировали байтовый код Perl, и все, что осталось сделать, это запустить его. Фактическое выполнение выполняется функцией &lt;code&gt;runops_standard&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="952f473e58faf0d44b6ff273d0893bc5ac586a94" translate="yes" xml:space="preserve">
          <source>Now when you run it, perl complains about the 3 undeclared variables and we get four error messages because one variable is referenced twice:</source>
          <target state="translated">Теперь,когда вы его запускаете,perl жалуется на 3 необъявленные переменные,и мы получаем четыре сообщения об ошибках,потому что на одну переменную ссылаются дважды:</target>
        </trans-unit>
        <trans-unit id="fd8037c01a5003f5b294e5c2293670a0337f93e2" translate="yes" xml:space="preserve">
          <source>Now when you run, it's a little different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0876df351c2b288f71557a0b6c1ab72f84bc0972" translate="yes" xml:space="preserve">
          <source>Now you can add new rows. What about adding new columns? If you're dealing with just matrices, it's often easiest to use simple assignment:</source>
          <target state="translated">Теперь вы можете добавлять новые строки.А как насчет добавления новых столбцов? Если Вы имеете дело только с матрицами,то часто проще всего использовать простое задание:</target>
        </trans-unit>
        <trans-unit id="2be97d39881315756923220b5afaca5ad300443e" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="translated">Теперь вы можете проверить, есть ли &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . Возможно, было бы хорошей идеей сначала держать все блюз в кучу.</target>
        </trans-unit>
        <trans-unit id="13e8faf4edbb7badf8e22509c8ca447a6e463db3" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt;. It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
