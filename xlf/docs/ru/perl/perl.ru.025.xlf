<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="fb785a40ce237466b61cf74c58f19b12f7daa54a" translate="yes" xml:space="preserve">
          <source>Also note that there's no value for UNITCHECK-blocks. That's because those are run for each compilation unit individually, and therefore is not a global interpreter phase.</source>
          <target state="translated">Также обратите внимание,что нет никакого значения для блоков UNITCHECK.Это связано с тем,что они запускаются для каждой единицы компиляции в отдельности,и поэтому не являются глобальной фазой интерпретации.</target>
        </trans-unit>
        <trans-unit id="8af529a7344d9be72e889a1f3967799ba9dc98d6" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt; , you can substitute &lt;code&gt;perl Makefile.PL
PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">Также обратите внимание, что эти инструкции предназначены для установки модуля в системный репозиторий модулей Perl, но вы можете установить модули в любой каталог, который пожелаете. Например, когда я говорю &lt;code&gt;perl Makefile.PL&lt;/code&gt; , вы можете заменить &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; чтобы установить модули в</target>
        </trans-unit>
        <trans-unit id="981eced70a1fd7e3f9ca6ea4e94af48969947ff9" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt;, you can substitute &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736913cda9c361fafb5f7987b822471b70893809" translate="yes" xml:space="preserve">
          <source>Also note that this does not (yet) work with all configurations, it is known to fail with 64-bit versions of GCC.</source>
          <target state="translated">Также обратите внимание,что это (пока)работает не со всеми конфигурациями,известно,что это не работает с 64-битными версиями GCC.</target>
        </trans-unit>
        <trans-unit id="1ab79db4a65e3d1bcd26f59f38af2eeb810bbb25" translate="yes" xml:space="preserve">
          <source>Also note that under the current implementation, shared variables use a little more memory and are a little slower than ordinary variables.</source>
          <target state="translated">Также обратите внимание,что при текущей реализации общие переменные используют немного больше памяти и немного медленнее,чем обычные переменные.</target>
        </trans-unit>
        <trans-unit id="df7301891c8738a820a79c945053b0568b895b92" translate="yes" xml:space="preserve">
          <source>Also note that whether enums are implicitly morphable to ints varies between compilers, you might need to (int).</source>
          <target state="translated">Также обратите внимание на то,что в разных компиляторах перечисления неявно морфируются в инты,вам может понадобиться (int).</target>
        </trans-unit>
        <trans-unit id="3fe91d0953fd134d385ab62185c6773cb118c04f" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt;), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt;), or for any cryptographic applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971b7944044758dad02956ec65121b0bd485f6a2" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), or for any cryptographic applications.</source>
          <target state="translated">Также обратите внимание, что хотя порядок элементов хеша может быть случайным, этот &amp;laquo;псевдоупорядочение&amp;raquo; &lt;b&gt;не&lt;/b&gt; следует использовать для таких приложений, как случайное перемешивание списка (для этого используйте &lt;code&gt;List::Util::shuffle()&lt;/code&gt; , см. &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; , стандартный базовый модуль начиная с Perl 5.8.0; или модуль CPAN &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), или для генерации перестановок (используйте, например, модули CPAN &lt;code&gt;Algorithm::Permute&lt;/code&gt; или &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), или для любых криптографических приложений .</target>
        </trans-unit>
        <trans-unit id="1cc898b24b5934f9ecf52c4f2514750c1a887e03" translate="yes" xml:space="preserve">
          <source>Also note that you should set the &lt;code&gt;Efs&lt;/code&gt; option to true if you are working with UTF8 filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4516f893f396703a765e286979d300545dd3cb43" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">Также обратите внимание, что для суперпользователя в локальных файловых системах тесты &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-W&lt;/code&gt; всегда возвращают 1, а &lt;code&gt;-x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; возвращают 1, если в режиме установлен какой-либо бит выполнения. Таким образом, скриптам, запускаемым суперпользователем, может потребоваться выполнить stat (), чтобы определить фактический режим файла, или временно установить их эффективный uid на другое значение.</target>
        </trans-unit>
        <trans-unit id="63277c7c7b95830e3556168d50e815433213b167" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">Также обратите внимание, что для суперпользователя в локальных файловых системах тесты &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-W&lt;/code&gt; всегда возвращают 1, а &lt;code&gt;-x&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; возвращают 1, если в режиме установлен какой-либо бит выполнения. Таким образом, скриптам, запускаемым суперпользователем, может потребоваться выполнить stat (), чтобы определить фактический режим файла, или временно установить их эффективный uid на другое значение.</target>
        </trans-unit>
        <trans-unit id="4c12857d50953ae8911fef9be5deb3cb6261b630" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0223c3f3274398a55ed8725b06675a40efd8ef" translate="yes" xml:space="preserve">
          <source>Also note that:</source>
          <target state="translated">Обратите внимание:</target>
        </trans-unit>
        <trans-unit id="87da44cc851ca2f3b8c127c8f7ddc08e6bd458e4" translate="yes" xml:space="preserve">
          <source>Also note, that because all ASCII characters are UTF-8 invariant (meaning they have the exact same representation (always a single byte) whether encoded in UTF-8 or not), &lt;code&gt;isASCII&lt;/code&gt; will give the correct results when called with any byte in any string encoded or not in UTF-8. And similarly &lt;code&gt;isASCII_utf8&lt;/code&gt; will work properly on any string encoded or not in UTF-8.</source>
          <target state="translated">Также обратите внимание, что поскольку все символы ASCII инвариантны для UTF-8 (то есть они имеют одно и то же представление (всегда один байт), независимо от того, закодированы ли они в UTF-8 или нет), &lt;code&gt;isASCII&lt;/code&gt; даст правильные результаты при вызове с любым байтом в любом строка в кодировке или не в UTF-8. Точно так же &lt;code&gt;isASCII_utf8&lt;/code&gt; будет правильно работать с любой строкой, закодированной или не в UTF-8.</target>
        </trans-unit>
        <trans-unit id="523b244d1d9de0ba3f1938d9267c5634264d7182" translate="yes" xml:space="preserve">
          <source>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</source>
          <target state="translated">Также обратите внимание,что независимо от того,какие аргументы вы передаете в функцию perl_parse(),PERL_SYS_INIT3()должны вызываться на C main()argc,argv и env и только один раз.</target>
        </trans-unit>
        <trans-unit id="84e807ea22d37e9fcac5bf336f329420c5d937c0" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;a href=&quot;File::Basename&quot;&gt;&lt;code&gt;File::Basename&lt;/code&gt;&lt;/a&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b1e0d1886e4ff75f5ec5ef85846c4c02e181e1" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;code&gt;File::Basename&lt;/code&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">Также можно использовать &lt;code&gt;File::Basename&lt;/code&gt; из стандартного дистрибутива, который разбивает путь на части (базовое имя файла, полный путь к каталогу и суффикс файла).</target>
        </trans-unit>
        <trans-unit id="5f72eee36e825db36f597f9decf9236b17c32472" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; .</source>
          <target state="translated">В качестве терминов также анализируются конструкции &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , а также вызовы подпрограмм и методов, а также анонимные конструкторы &lt;code&gt;[]&lt;/code&gt; и &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e4187069aa3cdfe5b15fb66a75e8d762b8a3c7" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;do {}&lt;/code&gt; and &lt;code&gt;eval {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab49029f03642de1877e97fc5e4ccdaa8f4d8b8" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot;&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2bae6f7ee0c691e590b07608d4c9653431dd798" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">Также прочтите раздел &lt;a href=&quot;#DESCRIPTION&quot;&gt;ОПИСАНИЕ&lt;/a&gt; выше о том, как &lt;code&gt;Carp&lt;/code&gt; решает, откуда поступила ошибка.</target>
        </trans-unit>
        <trans-unit id="6e8426be1042a9c74b01dabfc6cf09d489acf3c6" translate="yes" xml:space="preserve">
          <source>Also referred to as &quot;Dotted-Integer&quot;, these contains more than one decimal point and may have an optional embedded underscore, see &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;Dotted-Decimal Versions&quot;&lt;/a&gt;. This is what is commonly used in most open source software as the &quot;external&quot; version (the one used as part of the tag or tarfile name). A leading 'v' character is now required and will warn if it missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e594eb3334af2971f8b461e9ae7e0b95244811c" translate="yes" xml:space="preserve">
          <source>Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &lt;code&gt;[fee|fie|foe]&lt;/code&gt; you're really only matching &lt;code&gt;[feio|]&lt;/code&gt; .</source>
          <target state="translated">Также помните, что &quot;|&quot; интерпретируется как литерал в квадратных скобках, поэтому, если вы напишете &lt;code&gt;[fee|fie|foe]&lt;/code&gt; вы действительно будете соответствовать только &lt;code&gt;[feio|]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d930463c65b067a74fc5ff7d23d0ccb6261af74" translate="yes" xml:space="preserve">
          <source>Also remember that C doesn't allow you to safely say &lt;code&gt;foo(SvPV(s, len),
len);&lt;/code&gt;. It might work with your compiler, but it won't work for everyone. Break this sort of statement up into separate assignments:</source>
          <target state="translated">Также помните, что C не позволяет безопасно произносить &lt;code&gt;foo(SvPV(s, len), len);&lt;/code&gt; . Это может работать с вашим компилятором, но не для всех. Разбейте такие утверждения на отдельные задания:</target>
        </trans-unit>
        <trans-unit id="f44fcd946ba2f23c70977904fbf45aba4b6fafca" translate="yes" xml:space="preserve">
          <source>Also remember that the &lt;code&gt;%p&lt;/code&gt; format really does require a void pointer:</source>
          <target state="translated">Также помните, что формат &lt;code&gt;%p&lt;/code&gt; действительно требует указателя void:</target>
        </trans-unit>
        <trans-unit id="d484e6b6d31da17dc2ff01d2d2dda31cda9e2d99" translate="yes" xml:space="preserve">
          <source>Also remember: If the META file contains a provides field, you shouldn't be indexing anything in the first place - just use that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058a190dd3d11e3f9bf93212c115f6265d98bac0" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">Также см. &lt;a href=&quot;functions/binmode&quot;&gt;Binmode&lt;/a&gt; или &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f380eae13c59641be526fa28a59640fd146bd59e" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b821601b2c44fa646b454cc4c61309ada267db9f" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--lquote&lt;/b&gt; and &lt;b&gt;--rquote&lt;/b&gt; options, which can be used to set the left and right quotes independently. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124ca3ad4251372cd630b0c4f1d026a6e1bb631a" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--quotes&lt;/b&gt; option, which can be used to set both quotes at once. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f14f1236967cfa8b858394733973952439e548" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;lquote&lt;/code&gt; and &lt;code&gt;rquote&lt;/code&gt; options, which can be used to set the left and right quotes independently. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43f69db8fdd0609b53e771f0c648e36f1cca6c0" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;quotes&lt;/code&gt; option, which can be used to set both quotes at once. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa855f9ba4cde9a2842bd3fc97af3045ad2e00c0" translate="yes" xml:space="preserve">
          <source>Also see:</source>
          <target state="translated">И еще:</target>
        </trans-unit>
        <trans-unit id="e8ab5cecbe34d47a3838306a541fd22a09e183f0" translate="yes" xml:space="preserve">
          <source>Also starting in v5.8.1, the &lt;code&gt;DATA&lt;/code&gt; pseudo-filehandle is translated from the encoding into UTF-8.</source>
          <target state="translated">Также, начиная с v5.8.1, псевдо-дескриптор файла &lt;code&gt;DATA&lt;/code&gt; переводится из кодировки в UTF-8.</target>
        </trans-unit>
        <trans-unit id="ab76f7fb0dafb2fd9b645c8d2859052a429122ce" translate="yes" xml:space="preserve">
          <source>Also study &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; carefully to avoid any bad assumptions about the operating system, filesystems, character set, and so forth.</source>
          <target state="translated">Также внимательно изучите &lt;a href=&quot;perlport&quot;&gt;perlport,&lt;/a&gt; чтобы избежать любых неверных предположений об операционной системе, файловых системах, наборе символов и так далее.</target>
        </trans-unit>
        <trans-unit id="2e87f20f7d97b568a4954fba96e48f292ed18abb" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;, which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;use v5.12&lt;/code&gt; or greater.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330eeffd40ec44ea764cda155371e57d6de9d850" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">Также неизменным является цитирование строк, отличных от UTF-8, когда они выходят за рамки функции &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , которая заключается в заключении в кавычки всех символов в верхнем диапазоне Latin1. Это обеспечивает полную обратную совместимость для старых программ, не использующих Unicode. (Обратите внимание, что &lt;code&gt;unicode_strings&lt;/code&gt; автоматически включается в рамках &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; или выше.)</target>
        </trans-unit>
        <trans-unit id="d897a47e8affb873fdb6ab1911f0d831b446c551" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">Также неизменным является цитирование строк, отличных от UTF-8, когда они выходят за рамки функции &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , которая заключается в заключении в кавычки всех символов в верхнем диапазоне Latin1. Это обеспечивает полную обратную совместимость для старых программ, не использующих Unicode. (Обратите внимание, что &lt;code&gt;unicode_strings&lt;/code&gt; автоматически включается в рамках &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; или выше.)</target>
        </trans-unit>
        <trans-unit id="77e4638580e542bd7efbc6ad1037c219e33a2a27" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">Также, в отличие от &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; не включает в себя завершающую косую черту в возвращаемом пути.</target>
        </trans-unit>
        <trans-unit id="26303c82ac6b3a7fa556573e39f86a09e33051c1" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt;, &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf4e79f0d2cc479a41a6179c877f4a73d453199" translate="yes" xml:space="preserve">
          <source>Also when working on Perl programs on VMS, if you need a syntax in a specific operating system format, then you need either to check the appropriate DECC$ feature logical, or call a conversion routine to force it to that format.</source>
          <target state="translated">Также при работе с Perl-программами на VMS,если вам нужен синтаксис в определенном формате операционной системы,то вам нужно либо проверить соответствующую логику DECC$ функции,либо вызвать рутину преобразования,чтобы заставить ее перейти в этот формат.</target>
        </trans-unit>
        <trans-unit id="5fc47794ba1a865aaaa0f149000e05b513e4f015" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2C-HVs-and-undefined-values&quot;&gt;&quot;AVs, HVs and undefined values&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a91fa72735b293f0702212cc8b8ff7dd3fc1bc" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AVs, HVs and undefined values&lt;/a&gt;).</source>
          <target state="translated">Также вы должны быть осторожны при использовании &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; в качестве значения в AV или HV (см. &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AV, HV и неопределенные значения&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="88b9515cdbcd45bb30a5ed0507a9f79663403c03" translate="yes" xml:space="preserve">
          <source>Also, &lt;b&gt;in Perl 5.8.x and earlier&lt;/b&gt;, this pragma uses pseudo-hashes, the effect being that you can have objects with named fields which are as compact and as fast arrays to access, as long as the objects are accessed through properly typed variables.</source>
          <target state="translated">Кроме того, &lt;b&gt;в Perl 5.8.x и ранее&lt;/b&gt; эта прагма использует &lt;b&gt;псевдохеши&lt;/b&gt; , в результате чего у вас могут быть объекты с именованными полями, которые являются столь же компактными и такими же быстрыми массивами для доступа, если доступ к объектам осуществляется через правильно типизированные переменные. .</target>
        </trans-unit>
        <trans-unit id="67b0ddab77dcdca452f298cae2c04c86ed3d38be" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; yields &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; for any</source>
          <target state="translated">Кроме того, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; дает &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; для любого</target>
        </trans-unit>
        <trans-unit id="d7b7987422ffa4fcf0f2ef8eb8b0440e2263954b" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">Кроме того, Case_Folding доступен с помощью модификатора &lt;code&gt;/i&lt;/code&gt; в регулярных выражениях, экранирования транслитерации &lt;code&gt;\F&lt;/code&gt; и оператора &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d028de5400e80b7bddfc22d550144658f5c96f35" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;perlfunc#fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329290910e0fbb3b491e01928584618de2f21b4e" translate="yes" xml:space="preserve">
          <source>Also, Configure might abort with</source>
          <target state="translated">Также,Конфигурация может прерваться с</target>
        </trans-unit>
        <trans-unit id="dbf6f9732bd6d02a3c14e683c3aa4b4c3c151f41" translate="yes" xml:space="preserve">
          <source>Also, a &lt;code&gt;&quot;r&quot;&lt;/code&gt; and/or &lt;code&gt;&quot;w&quot;&lt;/code&gt; in &lt;code&gt;$sMode&lt;/code&gt; is used to decide how the file descriptor is converted into a Perl file handle, even though this doesn't appear to make a difference. One of the following is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e804a10723cc82e329f560a2f2a4e122d8ad225" translate="yes" xml:space="preserve">
          <source>Also, a backslash followed by two or three octal digits is considered an octal number.</source>
          <target state="translated">Кроме того,обратная косая черта,за которой следуют две или три восьмеричные цифры,считается восьмеричным числом.</target>
        </trans-unit>
        <trans-unit id="931d2aa4d5ca7dba171a5dba8982f8a76fb7815e" translate="yes" xml:space="preserve">
          <source>Also, as of Perl 5.30, delimiters which are unassigned code points but that may someday become assigned are prohibited. Otherwise, code that works today would fail to compile if the currently unassigned delimiter ends up being something that isn't a stand-alone grapheme. Because Unicode is never going to assign &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;non-character code points&lt;/a&gt;, nor &lt;a href=&quot;perlunicode#Beyond-Unicode-code-points&quot;&gt;code points that are above the legal Unicode maximum&lt;/a&gt;, those can be delimiters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc421c7386da7b14eefaf275d4a113f5c542cb3" translate="yes" xml:space="preserve">
          <source>Also, both these methods currently allow only single characters to be named. To name a sequence of characters, use a &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;custom translator&lt;/a&gt; (described below).</source>
          <target state="translated">Кроме того, оба этих метода в настоящее время позволяют именовать только отдельные символы. Чтобы назвать последовательность символов, используйте &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;специальный переводчик&lt;/a&gt; (описанный ниже).</target>
        </trans-unit>
        <trans-unit id="0b19a92a5a63a3defc0247ff7123f75e1b423945" translate="yes" xml:space="preserve">
          <source>Also, calling &amp;amp;$coderef($lh, ...parameters...) can throw any sort of exception (if, say, code in that sub tries to divide by zero). But a very common exception occurs when you have Bracket Notation text that says to call a method &quot;foo&quot;, but there is no such method. (E.g., &quot;You have [qua&lt;b&gt;tn&lt;/b&gt;,_1,ball].&quot; will throw an exception on trying to call $lh-&amp;gt;qua&lt;b&gt;tn&lt;/b&gt;($_[1],'ball') -- you presumably meant &quot;quant&quot;.) &lt;code&gt;maketext&lt;/code&gt; catches these exceptions, but only to make the error message more readable, at which point it rethrows the exception.</source>
          <target state="translated">Кроме того, вызов &amp;amp; $ coderef ($ lh, ... parameters ...) может вызвать любое исключение (если, скажем, код в этой подгруппе пытается разделиться на ноль). Но очень распространенное исключение возникает, когда у вас есть текст в скобках, в котором говорится о вызове метода &amp;laquo;foo&amp;raquo;, но такого метода нет. (Например, &amp;laquo;У вас есть [qua &lt;b&gt;tn&lt;/b&gt; , _1, ball].&amp;raquo; Вызовет исключение при попытке вызвать $ lh-&amp;gt; qua &lt;b&gt;tn&lt;/b&gt; ($ _ [1], 'ball') - вы предположительно имели в виду &amp;laquo;квант&amp;raquo;. ) &lt;code&gt;maketext&lt;/code&gt; перехватывает эти исключения, но только для того, чтобы сделать сообщение об ошибке более читабельным, после чего он повторно генерирует исключение.</target>
        </trans-unit>
        <trans-unit id="bd6593efc170267903ffe758130a7c9bc58d5233" translate="yes" xml:space="preserve">
          <source>Also, entries like</source>
          <target state="translated">Также,записи типа</target>
        </trans-unit>
        <trans-unit id="74a420b208a6c382bb28f75840a5f1acef599188" translate="yes" xml:space="preserve">
          <source>Also, every C program that uses Perl must link in the</source>
          <target state="translated">Кроме того,каждая программа на Си,использующая Perl,должна ссылаться на</target>
        </trans-unit>
        <trans-unit id="34500a88731ba3291ee1333607a6b7ca5f090a54" translate="yes" xml:space="preserve">
          <source>Also, feel free to play with experimental features. Run</source>
          <target state="translated">Кроме того,не стесняйтесь играть с экспериментальными функциями.Запустите .</target>
        </trans-unit>
        <trans-unit id="efa6c1b4904cf64e5362ea949feda8f167d890cd" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;&quot;Unicode Properties&quot;&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt;, &lt;code&gt;\p{ID_Continue}&lt;/code&gt;, &lt;code&gt;\p{XID_Start}&lt;/code&gt;, and &lt;code&gt;\p{XID_Continue}&lt;/code&gt;. See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8f99a26ea97ae4edab854723c19d8a2e3a7a2e" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode Properties&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; , and &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">Кроме того, для более детального набора символов, которые находятся в идентификаторах языков программирования за пределами диапазона ASCII, вы можете вместо этого использовать более настраиваемые &lt;a href=&quot;#Unicode-Properties&quot;&gt;свойства Unicode&lt;/a&gt; , &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; и &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . См. &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;Http://unicode.org/reports/tr31&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccef320717b4d17e6eccfe71944895dfdb94c8a6" translate="yes" xml:space="preserve">
          <source>Also, having valid values as keys becomes very useful if you set up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</source>
          <target state="translated">Кроме того,наличие действительных значений в качестве ключей становится очень полезным при настройке лексики _AUTO.Лексики _AUTO обсуждаются в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="57c4e07e0cc219d38dd06e6e1bcf0b1ea8e52540" translate="yes" xml:space="preserve">
          <source>Also, if the SV passed to &lt;code&gt;mg_find&lt;/code&gt; or &lt;code&gt;mg_findext&lt;/code&gt; is not of type SVt_PVMG, Perl may core dump.</source>
          <target state="translated">Кроме того, если SV, переданный в &lt;code&gt;mg_find&lt;/code&gt; или &lt;code&gt;mg_findext&lt;/code&gt; , не относится к типу SVt_PVMG, Perl может выполнить дамп ядра.</target>
        </trans-unit>
        <trans-unit id="a715fbfabba33c1ab0f07edc90c111741da66e2f" translate="yes" xml:space="preserve">
          <source>Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'. The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities. Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &lt;code&gt;NOT&lt;/code&gt; clause in their description that highlights their not being binary. These also require the compound form to match them, whereas true binary properties have both single and compound forms available.</source>
          <target state="translated">Кроме того, в двоичных свойствах &amp;laquo;Да&amp;raquo;, &amp;laquo;Т&amp;raquo; и &amp;laquo;Истина&amp;raquo; являются синонимами &amp;laquo;Y&amp;raquo;. И &amp;laquo;Нет&amp;raquo;, &amp;laquo;F&amp;raquo; и &amp;laquo;Ложь&amp;raquo; - все синонимы для &amp;laquo;N&amp;raquo;. В таблице показаны &amp;laquo;Y *&amp;raquo; и &amp;laquo;N *&amp;raquo;, чтобы указать на это, и нет отдельных записей для других возможностей. Обратите внимание, что не все свойства, которые имеют значения &amp;laquo;Да&amp;raquo; и &amp;laquo;Нет&amp;raquo;, являются двоичными, и все их значения указаны без использования этого подстановочного знака и предложения &lt;code&gt;NOT&lt;/code&gt; в их описании, которое подчеркивает, что они не являются двоичными. Они также требуют, чтобы составная форма соответствовала им, тогда как для истинных бинарных свойств доступны как одиночные, так и составные формы.</target>
        </trans-unit>
        <trans-unit id="a00a976f777c7c9555d5a4f1c975df6f1666beb4" translate="yes" xml:space="preserve">
          <source>Also, in the context of &lt;b&gt;Unicode&lt;/b&gt;, a writing system for a particular language or group of languages, such as Greek, Bengali, or Tengwar.</source>
          <target state="translated">Кроме того, в контексте &lt;b&gt;Unicode&lt;/b&gt; , система письма для определенного языка или группы языков, например греческого, бенгальского или тенгварского.</target>
        </trans-unit>
        <trans-unit id="d74824efd3c4979bad6a6f8c4e477bf4cb023fd4" translate="yes" xml:space="preserve">
          <source>Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimizer is not very clever about handling them.</source>
          <target state="translated">Также стоит отметить,что паттерны,определенные таким образом,вероятно,будут не столь эффективны,так как оптимизатор не очень умён в обращении с ними.</target>
        </trans-unit>
        <trans-unit id="487cc7057b2c00a1fbc251ce9c403787bcbb592b" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ). For &lt;code&gt;CRLF&lt;/code&gt; , try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">Кроме того, строки не должны разделяться в &lt;code&gt;CRLF&lt;/code&gt; (т.е. между &lt;code&gt;\r&lt;/code&gt; и &lt;code&gt;\n&lt;/code&gt; нет пустой строки ). Для &lt;code&gt;CRLF&lt;/code&gt; попробуйте слой &lt;code&gt;:crlf&lt;/code&gt; (см. &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f3992030bd7e3a922eb5df07ea510b7432d80298" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt;). For &lt;code&gt;CRLF&lt;/code&gt;, try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63323aa4e4ec3045e43bf822a9f6601fadcf053b" translate="yes" xml:space="preserve">
          <source>Also, negative signal values don't do anything special under VMS; they're just converted to the corresponding positive value.</source>
          <target state="translated">Кроме того,отрицательные значения сигналов не делают ничего особенного под VMS,они просто преобразуются в соответствующее положительное значение.</target>
        </trans-unit>
        <trans-unit id="6a350d1c09fc9665a8e389e53064c822190440b0" translate="yes" xml:space="preserve">
          <source>Also, note that using the file tests for security purposes is a lost cause from the start: there is a window open for race conditions (who is to say that the permissions will not change between the test and the real operation?). Therefore if you are serious about security, just try the real operation and test for its success - think in terms of atomic operations. Filetests are more useful for filesystem administrative tasks, when you have no need for the content of the elements on disk.</source>
          <target state="translated">Также обратите внимание,что использование файловых тестов в целях безопасности-потерянная причина с самого начала:открыто окно для условий гонки (кто скажет,что разрешения не изменятся между тестом и реальной операцией?).Поэтому,если вы серьезно относитесь к безопасности,просто попробуйте настоящую операцию и проверьте ее успешность-подумайте об атомных операциях.Файловые тесты более полезны для задач администрирования файловой системы,когда вам не нужно содержимое элементов на диске.</target>
        </trans-unit>
        <trans-unit id="d574d865815009daf05f1054bf415b0bf6943266" translate="yes" xml:space="preserve">
          <source>Also, note the following:</source>
          <target state="translated">Также обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="48ddb81f1627e1f3a6389ef3f6f1aa66ba367e47" translate="yes" xml:space="preserve">
          <source>Also, once a project is otherwise complete and you start to localize it, you can scrape together all the various keys you use, and pass it to a translator; and then the translator's work will go faster if what he's presented is this:</source>
          <target state="translated">Кроме того,как только проект будет завершен и вы начнете его локализацию,вы можете соскрести все различные ключи,которые вы используете,и передать их переводчику;и тогда работа переводчика пойдет быстрее,если то,что он представляет собой:</target>
        </trans-unit>
        <trans-unit id="25de230710079ae2e7ac75bdcf59f8719d1c3ed7" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">Кроме того, perl можно перекомпилировать для работы с более ранней версией стандарта Unicode. Дополнительная информация находится в &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="b542e84834d4e9866d33acb374e33e8f660c85fa" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76997e16af65c741ca3a61aadd72db51de092e73" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;$x&lt;/code&gt; is lexical, it can't be reached or modified by any Perl code outside.</source>
          <target state="translated">Кроме того, поскольку &lt;code&gt;$x&lt;/code&gt; является лексическим, он не может быть доступен или изменен никаким внешним кодом Perl.</target>
        </trans-unit>
        <trans-unit id="38f33518e3f4f0a218000c4a9eb29242c2ff03c6" translate="yes" xml:space="preserve">
          <source>Also, since the number of opcodes in your current version of perl might not be an exact multiple of eight, there may be unused bits in the last byte of an upset. This should not cause any problems (Opcode functions ignore those extra bits) but it does mean that using the ~ operator will typically not produce the same 'physical' opset 'string' as the invert_opset function.</source>
          <target state="translated">Также,поскольку количество опкодов в вашей текущей версии perl может быть неточным,кратным восьми,могут быть неиспользованные биты в последнем байте расстройства.Это не должно вызывать никаких проблем (функции Opcode игнорируют эти лишние биты),но это действительно означает,что использование оператора ~,как правило,не будет производить тот же 'физический' опсет 'string',что и функция invert_opset.</target>
        </trans-unit>
        <trans-unit id="3ed7ac3c49479a3dd530e1364bfdfcfdef42d4e9" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; , and &lt;code&gt;CRLF&lt;/code&gt; , as well as &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; , and &lt;code&gt;$CRLF&lt;/code&gt; , which map to &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , and &lt;code&gt;\015\012&lt;/code&gt; . If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">Также предусмотрены некоторые общие константы &amp;laquo;новой строки&amp;raquo; сокетов: константы &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; и &lt;code&gt;CRLF&lt;/code&gt; , а также &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; и &lt;code&gt;$CRLF&lt;/code&gt; , которые отображаются в &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; и &lt;code&gt;\015\012&lt;/code&gt; . Если вы не хотите использовать буквальные символы в своих программах, используйте указанные здесь константы. По умолчанию они не экспортируются, но могут быть импортированы по отдельности и с &lt;code&gt;:crlf&lt;/code&gt; экспорта : crlf :</target>
        </trans-unit>
        <trans-unit id="09c79652fdab8435dc64bf1d503eb44817957310" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;LF&lt;/code&gt;, and &lt;code&gt;CRLF&lt;/code&gt;, as well as &lt;code&gt;$CR&lt;/code&gt;, &lt;code&gt;$LF&lt;/code&gt;, and &lt;code&gt;$CRLF&lt;/code&gt;, which map to &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, and &lt;code&gt;\015\012&lt;/code&gt;. If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c4a82fda1ed827381af159c98e8fcbdf05900b" translate="yes" xml:space="preserve">
          <source>Also, some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt; , you have to run make as follows:</source>
          <target state="translated">Также несколько специальных инструкций по сборке Perl с помощью Sun Studio в Linux. Следуя обычной &lt;code&gt;Configure&lt;/code&gt; , вы должны запустить make следующим образом:</target>
        </trans-unit>
        <trans-unit id="430b83395a22758023df144cbbf527affef6a44c" translate="yes" xml:space="preserve">
          <source>Also, subroutines could be declared with the &lt;code&gt;:locked&lt;/code&gt; attribute which would serialize access to the subroutine, but allowed different threads non-simultaneous access.</source>
          <target state="translated">Кроме того, подпрограммы могут быть объявлены с атрибутом &lt;code&gt;:locked&lt;/code&gt; , который будет сериализовать доступ к подпрограмме, но позволит разным потокам неодновременный доступ.</target>
        </trans-unit>
        <trans-unit id="f700fce01f8bef830aa30a8774e7a762bfbaf65f" translate="yes" xml:space="preserve">
          <source>Also, the internal representation of Time::Piece-&amp;gt;strftime deviates from the standard POSIX implementation in that is uses the epoch (instead of separate year, month, day parts). This change was added in version 1.30. If you must have a more traditional strftime (which will normally never calculate day light saving times correctly), you can pass the date parts from Time::Piece into the strftime function provided by the POSIX module (see strftime in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7201d576462a40ab9a535c50ec57d12c94dd4c2" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the &lt;code&gt;refaddr&lt;/code&gt; the same as other handles and so can be compared to other handles with &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb14deb83dae5ba493a96acfadaf1236cbdc5ea" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the C</source>
          <target state="translated">Кроме того,объект настроен таким образом,что он строится к имени временного файла,и поэтому его можно напрямую сравнивать с именем файла.Он нумеруется до C</target>
        </trans-unit>
        <trans-unit id="913c9e19c71d84db5eb4e7b9fa93a06fccc33227" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns and transliterations makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7807da341a2e1187eef533ebec80cd0117d203" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">Кроме того,диапазон 'A'-'Z' в ASCII представляет собой непрерывную последовательность из 26 заглавных алфавитных символов.В EBCDIC это не так.Как и для 'a'-'z'.Но '0'-'9'-это непрерывный диапазон в обеих системах.Ничего не думайте о других диапазонах.(Обратите внимание,что специальная обработка диапазонов в шаблонах регулярных выражений приводит к тому,что в коде Perl оказывается,что все перечисленные диапазоны являются непрерывными).</target>
        </trans-unit>
        <trans-unit id="ed48bbc731848457db80d2fadad2fe9e698169b3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious, see &lt;a href=&quot;#Security-Implications-of-Unicode&quot;&gt;&quot;Security Implications of Unicode&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e213d7b8a81bd451ffb3f3ae8fa862e904a6c3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious. Read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">Кроме того, использование Unicode может представлять неочевидные проблемы безопасности. Прочтите &amp;laquo; &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Вопросы безопасности Unicode&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a6ddd5f6cea51490776d1ee7aa46674933e080d" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt; , for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">Кроме того, с помощью этого модификатора сопоставление без учета регистра работает для всего набора символов Unicode. &lt;code&gt;KELVIN SIGN&lt;/code&gt; , например , совпадает с буквой &amp;laquo;К&amp;raquo; и &amp;laquo;K&amp;raquo;; и &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; соответствует последовательности &amp;laquo;ff&amp;raquo;, которая, если вы не подготовлены, может сделать ее похожей на шестнадцатеричную константу, представляя еще одну потенциальную проблему безопасности. См. &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;Http://unicode.org/reports/tr36&lt;/a&gt; для подробного обсуждения вопросов безопасности Unicode.</target>
        </trans-unit>
        <trans-unit id="082c639d640961ab2741dc8437aea7d26245da44" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt;, for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;https://unicode.org/reports/tr36&quot;&gt;https://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d458ad7a020a232313ae8d56db7bcab0ded5305" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;</source>
          <target state="translated">Кроме того , различные синонимы , такие как &lt;code&gt;\p{Alpha}&lt;/code&gt; для &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; все перечисленные в &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Свойствах доступны через \ p {} и \ P {} в perluniprops&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="185cbf92e7b7051aa2f9930ee2ca151063ceb454" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt;; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd51e4e1d10037d178287b3c2e52d39f31c50f2" translate="yes" xml:space="preserve">
          <source>Also, when your</source>
          <target state="translated">Также,когда ваш</target>
        </trans-unit>
        <trans-unit id="94df63c3696c6e9f216a0b26ed643a62ffdfe44b" translate="yes" xml:space="preserve">
          <source>Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &lt;code&gt;/x&lt;/code&gt; modifier hasn't been specified on the regular expression. But in the table below a '&lt;b&gt;T&lt;/b&gt;' at the beginning of an entry means that tighter (stricter) rules are used for that entry:</source>
          <target state="translated">Кроме того, пробелы, дефисы и подчеркивания обычно игнорируются везде между {фигурными скобками} и, следовательно, могут быть свободно добавлены или удалены, даже если модификатор &lt;code&gt;/x&lt;/code&gt; не был указан в регулярном выражении. Но в таблице ниже буква &amp;laquo; &lt;b&gt;T&lt;/b&gt; &amp;raquo; в начале записи означает, что для этой записи используются более строгие (более строгие) правила:</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="554a943cef6b1565f2a13a13d21f280b671c0db6" translate="yes" xml:space="preserve">
          <source>Alter regular expression behaviour</source>
          <target state="translated">Изменение поведения регулярной экспрессии</target>
        </trans-unit>
        <trans-unit id="4b26f888988c3f23411577d380346f5e87008e97" translate="yes" xml:space="preserve">
          <source>Alternate Stack Manipulation</source>
          <target state="translated">Альтернативная манипуляция стеком</target>
        </trans-unit>
        <trans-unit id="baff84fe31ffd586fd0cbbd5cab56329f0775d04" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the local address to &lt;code&gt;bind()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db36f7208c555076a29994a086e6ad6fe2b6c88" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the peer to &lt;code&gt;connect()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4495ae5a9f0394b58820a885d0978ae962fd139c" translate="yes" xml:space="preserve">
          <source>Alternately I can pass an open filehandle as source and have the parser read from that rather than attempting to run a test script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5fc16ac82340f31ba65517d29fc05e91506541" translate="yes" xml:space="preserve">
          <source>Alternately I can supply the names of my substitute classes to the TAP::Harness constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9227d0ca3877e84e35d83f9ac364f43162e4ef9e" translate="yes" xml:space="preserve">
          <source>Alternately, if the language used to write my tests allows a shebang line I can use that to specify the interpreter. Here's a test written in PHP:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd038ee8b646edddd400b75f62f9db870f503cd5" translate="yes" xml:space="preserve">
          <source>Alternately, if you have an SV that is a blessed reference, you can find out the stash pointer by using:</source>
          <target state="translated">С другой стороны,если у вас есть SV,который является благословенной ссылкой,вы можете узнать указатель тайника с помощью:</target>
        </trans-unit>
        <trans-unit id="6589e5a8ee283a61027f2499ac81f9bd22f55b5a" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">В качестве альтернативы, если вы импортируете &lt;code&gt;:constants&lt;/code&gt; , вы можете напрямую использовать следующие константы:</target>
        </trans-unit>
        <trans-unit id="8a245817c61d1ffafbf0a5d7c18cd6a72b400a7e" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt;, you can use the following constants directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3835ce5fac7a47f4550c37daaf24821ea36a9658" translate="yes" xml:space="preserve">
          <source>Alternately, if you use OS/2-ish shell, like CMD or 4os2, put the following at the start of your perl script:</source>
          <target state="translated">Или,если вы используете оболочку OS/2-ish,например,CMD или 4os2,поставьте следующее в начале вашего perl скрипта:</target>
        </trans-unit>
        <trans-unit id="3c02b30c04d1bd2e064bba714a6c966f7e7001cc" translate="yes" xml:space="preserve">
          <source>Alternately, try running pod2text on</source>
          <target state="translated">Попеременно попробуйте запустить pod2-текст на</target>
        </trans-unit>
        <trans-unit id="c6586bf995507ef47c1e8462c0b96f9bda48432b" translate="yes" xml:space="preserve">
          <source>Alternately, you can change to binary mode on an existing handle this way:</source>
          <target state="translated">В качестве альтернативы вы можете перейти в двоичный режим на существующей ручке таким образом:</target>
        </trans-unit>
        <trans-unit id="436c604fc9e91f4036987513f30ceb0b117df526" translate="yes" xml:space="preserve">
          <source>Alternately, you can set the global variable &lt;code&gt;$Carp::Verbose&lt;/code&gt; to true. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below.</source>
          <target state="translated">В качестве альтернативы вы можете установить для глобальной переменной &lt;code&gt;$Carp::Verbose&lt;/code&gt; значение true. См. Раздел &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="15f2c59a8b9b5baf596fabaf5af782241acbedb6" translate="yes" xml:space="preserve">
          <source>Alternately, you can specify the exact directory to place the extension's files by placing a &quot;PREFIX=/destination/directory&quot; after the make install (or in between the make and install if you have a brain-dead version of make). This can be very useful if you are building an extension that will eventually be distributed to multiple systems. You can then just archive the files in the destination directory and distribute them to your destination systems.</source>
          <target state="translated">Или же вы можете указать точный каталог для размещения файлов расширения,поместив &quot;PREFIX=/destination/directory&quot; после make install (или между make и install,если у вас есть мозговая версия make).Это может быть очень полезно,если вы собираете расширение,которое в конечном итоге будет распространяться на нескольких системах.Затем вы можете просто архивировать файлы в целевом каталоге и распространять их в ваших целевых системах.</target>
        </trans-unit>
        <trans-unit id="e00c3a1ce8b9e2b0c7ee0051f3ec0d7cf8bcbdb9" translate="yes" xml:space="preserve">
          <source>Alternately, you can try to get a replacement for the system's &lt;b&gt;Execute&lt;/b&gt; command that honors the #!/usr/bin/perl syntax in scripts and set the s-Bit of your scripts. Then you can invoke your scripts like under UNIX with</source>
          <target state="translated">С другой стороны , вы можете попытаться получить замену системы &lt;b&gt;Выполните&lt;/b&gt; команду , которая чтит #! / USR / бен / Perl синтаксис сценариев и установите S-бит ваших сценариев. Затем вы можете вызывать свои сценарии, как в UNIX, с помощью</target>
        </trans-unit>
        <trans-unit id="70b8f05f7796eca9b3373c7ecd058a653ad0409c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">В качестве альтернативы вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , оператор кавычки регулярного выражения (подробнее см. &lt;a href=&quot;perlop&quot;&gt;Perlop&lt;/a&gt; ). Он цитирует и, возможно, компилирует шаблон, и вы можете применять к нему флаги регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="7d48931e8ff9955945645810ae372a2695434121" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;qr//&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="be9a6aa6691045b50a599c27892a7efaa458c7af" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt; , and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt; .</source>
          <target state="translated">Чередование позволяет регулярному выражению выбирать среди альтернатив, но само по себе это неудовлетворительно. Причина в том, что каждая альтернатива - это целое регулярное выражение, но иногда нам нужны альтернативы только для части регулярного выражения. Например, предположим, что мы хотим найти домашних кошек или домработниц. &lt;code&gt;housecat|housekeeper&lt;/code&gt; выражение housecat | housekeeper отвечает всем требованиям, но неэффективно, поскольку нам приходилось вводить &lt;code&gt;house&lt;/code&gt; дважды. Было бы неплохо, если бы части регулярного выражения были постоянными, например &lt;code&gt;house&lt;/code&gt; , а у некоторых частей были альтернативы, например &lt;code&gt;cat|keeper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2748d57020b2771f7481af94280b0d7745a90798" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt;, and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf43ccde7eeaee521a4a189652a63c1baacf5e0" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt; . So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">Чередования ведут себя в группах так же, как и вне них: в заданной позиции строки берется крайняя левая альтернатива, которая позволяет регулярному выражению соответствовать. Таким образом, в последнем примере в первой строковой позиции &lt;code&gt;&quot;20&quot;&lt;/code&gt; соответствует второй альтернативе, но ничего не осталось, чтобы соответствовать следующим двум цифрам &lt;code&gt;\d\d&lt;/code&gt; . Итак, Perl переходит к следующей альтернативе, которая является нулевой альтернативой и работает, поскольку &lt;code&gt;&quot;20&quot;&lt;/code&gt; - это две цифры.</target>
        </trans-unit>
        <trans-unit id="ef0bb58311a4cc103103ca6beeb54a0245223e8c" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt;. So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45912dbd856f0ddf337c48eab0e2b6ac8ae702c" translate="yes" xml:space="preserve">
          <source>Alternative Hash Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92135acee6fb42da0402ddedc5b8263e8afa69de" translate="yes" xml:space="preserve">
          <source>Alternative capture group numbering</source>
          <target state="translated">Альтернативная нумерация групп захвата</target>
        </trans-unit>
        <trans-unit id="ef523340b1a308a5c82202213f6749b6e6b1eda0" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::Calc&quot;&gt;Math::BigInt::Calc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701e87ca0ad0ba8cd11eda21d6ba26ee826bdec9" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::FastCalc&quot;&gt;Math::BigInt::FastCalc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c07200d4699b036f2138680fade3c9689f7058" translate="yes" xml:space="preserve">
          <source>Alternative math libraries</source>
          <target state="translated">Альтернативные математические библиотеки</target>
        </trans-unit>
        <trans-unit id="6aa5c766a08c26061e42a91b28e7696a27f14067" translate="yes" xml:space="preserve">
          <source>Alternative option starters</source>
          <target state="translated">Альтернативный вариант стартера</target>
        </trans-unit>
        <trans-unit id="443fe46b83982a5185e410eceac3b7185f7ae257" translate="yes" xml:space="preserve">
          <source>Alternative to Test::More::use_ok</source>
          <target state="translated">Альтернатива тестированию::Больше::use_ok</target>
        </trans-unit>
        <trans-unit id="c7461a3c1c3204afbbfd69dbbccd1e2b59471f99" translate="yes" xml:space="preserve">
          <source>Alternative warn and die for modules</source>
          <target state="translated">Альтернативное предупреждение и штамповка для модулей</target>
        </trans-unit>
        <trans-unit id="12e5972b55b252c3c9bc2d82985850d79c96249e" translate="yes" xml:space="preserve">
          <source>Alternatively edit the init file interactively via: 3rd mouse button -&amp;gt; New Display -&amp;gt; Edit Menu</source>
          <target state="translated">В качестве альтернативы отредактируйте файл инициализации в интерактивном режиме: 3-я кнопка мыши -&amp;gt; Новый дисплей -&amp;gt; Меню редактирования</target>
        </trans-unit>
        <trans-unit id="44c86b27ab468eef89d417477ce09eb4480abfb2" translate="yes" xml:space="preserve">
          <source>Alternatively look here: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</source>
          <target state="translated">Или посмотрите здесь: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e35a7c6545b16241ad2de0b09b446ca8d6a30265" translate="yes" xml:space="preserve">
          <source>Alternatively one can use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d17661d2312f06dcd6c1a5156f20af2512c469b" translate="yes" xml:space="preserve">
          <source>Alternatively the list of subfields can by supplied as a scalar, thus</source>
          <target state="translated">В качестве альтернативы список подполей может поставляться в виде скаляра,а именно</target>
        </trans-unit>
        <trans-unit id="2d8ede1527fb5e6a736864b76d2f172c35af4997" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094a83381a58e4403aca1b491639e03749297bf0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the XPUSHs() macro, which combines a &lt;code&gt;EXTEND(SP, 1)&lt;/code&gt; and &lt;code&gt;PUSHs()&lt;/code&gt;. This is less efficient if you're pushing multiple values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3d4d311210785c85520063de48eeff7de6af69" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the compiler directive our() to bring a dynamic variable into the current lexical scope.</source>
          <target state="translated">Или же вы можете использовать директиву компилятора our()для приведения динамической переменной в текущую лексическую область видимости.</target>
        </trans-unit>
        <trans-unit id="2cec5cf8bbfadcf33f7e5849e13d536e2c1766e0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use:</source>
          <target state="translated">В качестве альтернативы вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="43f0cea439a0fe2f49f0e9b79ff517dcdbec8d84" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from &lt;code&gt;CPAN&lt;/code&gt; .</source>
          <target state="translated">В качестве альтернативы вы можете получить эти документы предварительно собранными из &lt;code&gt;CPAN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f7013a74aa2034d027da86e6edefa6ad1f3b65" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from CPAN.</source>
          <target state="translated">В качестве альтернативы вы можете получить эти документы из CPAN.</target>
        </trans-unit>
        <trans-unit id="06dab9dc9469b67b9f013b1f7d978b8fd09b7e74" translate="yes" xml:space="preserve">
          <source>Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in</source>
          <target state="translated">В качестве альтернативы,Berkeley DB версия 1 доступна в ближайшем архиве CPAN по адресу</target>
        </trans-unit>
        <trans-unit id="4613df2f546fec79f85cfae70e64069cb1648bc9" translate="yes" xml:space="preserve">
          <source>Alternatively, a version range &lt;b&gt;may&lt;/b&gt; use the operators &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal). For example, the specification &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; means that any version of the prerequisite less than 2.0 is suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18aa5e8fea6653b702c48738f98b3e8db633fcaf" translate="yes" xml:space="preserve">
          <source>Alternatively, an array reference of section specifications can be used:</source>
          <target state="translated">В качестве альтернативы может использоваться массивная ссылка на спецификации секций:</target>
        </trans-unit>
        <trans-unit id="89c6743b65649f02ac7d006f9c75c999b8c0f7a0" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">В качестве альтернативы, начиная с версии 2.24, параметры конфигурации можно передавать вместе с оператором &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="865e46b39731975715e5505f357dc99fc1bb9e96" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;use&lt;/code&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6383e28e6083bea50110ff705c0169c065025b" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;decode_pod&lt;/code&gt; is set, it will decode the collected pod sections according to the &lt;code&gt;=encoding&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f72336ff028f49493e1034a2d5aa23e62a23ff" translate="yes" xml:space="preserve">
          <source>Alternatively, if the &lt;code&gt;string&lt;/code&gt; parameter is given, the supplied string will be parsed instead of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9aa6c54c04158a408f2c0b76a7a51f158187ce5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't need perlglob.exe and don't need to enable the USE_SETARGV option then you can safely just remove all mention of $(GLOBEXE) from win32/Makefile and setargv.obj won't be required anyway.</source>
          <target state="translated">Кроме того,если Вам не нужен perlglob.exe и не нужно включать опцию USE_SETARGV,то Вы можете безопасно просто удалить все упоминания $(GLOBEXE)из win32/Makefile и setargv.obj в любом случае не понадобится.</target>
        </trans-unit>
        <trans-unit id="068fceff1e33e5da627a6b110b456936f6082b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have the &lt;code&gt;gunzip&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">В качестве альтернативы, если у вас есть программа &lt;code&gt;gunzip&lt;/code&gt; , вы можете использовать ее для чтения сжатых файлов.</target>
        </trans-unit>
        <trans-unit id="4d16466752d2c087e599f1526f5793b26a5e2b0a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to read the &lt;code&gt;&quot;data1&quot;&lt;/code&gt; member into memory, use a scalar reference for the &lt;code&gt;output&lt;/code&gt; parameter.</source>
          <target state="translated">В качестве альтернативы, если вы хотите прочитать член &lt;code&gt;&quot;data1&quot;&lt;/code&gt; в памяти, используйте скалярную ссылку для &lt;code&gt;output&lt;/code&gt; параметра.</target>
        </trans-unit>
        <trans-unit id="067a937688c2a4c5c986d21853b255fbc5aefe6e" translate="yes" xml:space="preserve">
          <source>Alternatively, one can round the results explicitly using one of &lt;a href=&quot;#round%28%29&quot;&gt;&quot;round()&quot;&lt;/a&gt;, &lt;a href=&quot;#bround%28%29&quot;&gt;&quot;bround()&quot;&lt;/a&gt; or &lt;a href=&quot;#bfround%28%29&quot;&gt;&quot;bfround()&quot;&lt;/a&gt; or by passing the desired accuracy to the method as an additional parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742c3c00178ebe72a9bfad0e3ef29810b62b04e9" translate="yes" xml:space="preserve">
          <source>Alternatively, put this as the first line of your script:</source>
          <target state="translated">В качестве альтернативы,поставьте это в качестве первой строки вашего сценария:</target>
        </trans-unit>
        <trans-unit id="daefa0329439a8224d52050e5214c48286284b22" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than having to explicitly name each of the files that you want to compress, you could use a fileglob to select all the &lt;code&gt;txt&lt;/code&gt; files in the current directory, as follows</source>
          <target state="translated">В качестве альтернативы, вместо того, чтобы явно указывать каждый из файлов, которые вы хотите сжать, вы можете использовать fileglob для выбора всех файлов &lt;code&gt;txt&lt;/code&gt; в текущем каталоге, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="eefa7323e5eca7f13253bb419c7f371832614e4a" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this always gets it right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44b1aed9efe7eda393df0bd7f553f139ab03a17" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">В качестве альтернативы, просто используйте &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; для сравнения, это всегда будет правильно. Пока не существует способа получить число, автоматически представленное в виде строки, которая в точности соответствует тому, как это представляет Perl.</target>
        </trans-unit>
        <trans-unit id="055ca33d620827ab022a97400794bf3fb8a2807b" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;Text::ParseWords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad4e77e5423588b083e2af8975456f597a84a91" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">В качестве альтернативы модуль &lt;a href=&quot;text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt; (часть стандартного дистрибутива Perl) позволяет вам сказать:</target>
        </trans-unit>
        <trans-unit id="e3f5b7f0771697b931c8ecd89602848a9590421e" translate="yes" xml:space="preserve">
          <source>Alternatively, the crypt libraries in GNU libc have been ported to Cygwin.</source>
          <target state="translated">Или же библиотеки склепов в GNU libc были перенесены на Cygwin.</target>
        </trans-unit>
        <trans-unit id="43ccb7ccf6de944158b57bdf33cf5e43082dfbc3" translate="yes" xml:space="preserve">
          <source>Alternatively, use the macro &lt;a href=&quot;#CopLABEL_len_flags&quot;&gt;&quot;&lt;code&gt;CopLABEL_len_flags&lt;/code&gt;&quot;&lt;/a&gt;; or if you don't need to know if the label is UTF-8 or not, the macro &lt;a href=&quot;#CopLABEL_len&quot;&gt;&quot;&lt;code&gt;CopLABEL_len&lt;/code&gt;&quot;&lt;/a&gt;; or if you additionally dont need to know the length, &lt;a href=&quot;#CopLABEL&quot;&gt;&quot;&lt;code&gt;CopLABEL&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996763dc438b824d04ceb178a7d6d2de1f4e3617" translate="yes" xml:space="preserve">
          <source>Alternatively, using a customized typemap for your purposes in the first place is probably preferable.</source>
          <target state="translated">В качестве альтернативы,возможно,предпочтительнее использовать настраиваемую типовую карту для ваших целей.</target>
        </trans-unit>
        <trans-unit id="818d3daf2781969164beb46d939858b0992b14b8" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used &lt;code&gt;C&lt;/code&gt; to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</source>
          <target state="translated">В качестве альтернативы мы могли бы использовать &lt;code&gt;C&lt;/code&gt; для распаковки индивидуально доступных байтовых регистров FL, FH, AL, AH и т. Д .:</target>
        </trans-unit>
        <trans-unit id="87ca4d1f50f588b444c138934de28912a7c4fa3d" translate="yes" xml:space="preserve">
          <source>Alternatively, we might be able to use a command line option such as -R</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c917006b223001c63f85b3d40138b38f9bf9a9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can achieve a similar static effect by declaring the variable in a separate block outside the function, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973c34c798c56bb32a7153f1be5f39dd390df9c7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can fiddle with the stack directly: &lt;code&gt;SP&lt;/code&gt; gives you the first element in your portion of the stack, and &lt;code&gt;TOP*&lt;/code&gt; gives you the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation of an integer:</source>
          <target state="translated">В качестве альтернативы вы можете напрямую возиться со стеком: &lt;code&gt;SP&lt;/code&gt; дает вам первый элемент в вашей части стека, а &lt;code&gt;TOP*&lt;/code&gt; дает вам верхний SV / IV / NV / и т. Д. в стеке. Так, например, для унарного отрицания целого числа:</target>
        </trans-unit>
        <trans-unit id="4486c955e53dc63730c2501b04fe03ec6d1fb66c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can quote the class name:</source>
          <target state="translated">Или же вы можете процитировать имя класса:</target>
        </trans-unit>
        <trans-unit id="3dc4c1bc0515a5f540589d100b6ce1224a32ad91" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a reference to a scalar as the destination:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9393a15204a23768f5fb6e120d832da535fff827" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a scalar reference as the destination:</source>
          <target state="translated">Кроме того,вы можете указать,что опция может иметь несколько значений,добавив &quot;@&quot;,и передать скалярную ссылку в качестве пункта назначения:</target>
        </trans-unit>
        <trans-unit id="86794ed15412a1fa79e33d4ba8f3e04841c9eebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the &lt;code&gt;plan()&lt;/code&gt; function. Useful for when you have to calculate the number of tests.</source>
          <target state="translated">В качестве альтернативы вы можете использовать функцию &lt;code&gt;plan()&lt;/code&gt; . Полезно, когда нужно подсчитать количество тестов.</target>
        </trans-unit>
        <trans-unit id="bd695ed1549655fbf2b6a69e34efa112b5887ecd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the GCC_EXEC_PREFIX environment variable to ensure that Sun's as and ld are used. Consult your gcc documentation for further information on the -B option and the GCC_EXEC_PREFIX variable.</source>
          <target state="translated">В качестве альтернативы можно использовать переменную окружения GCC_EXEC_PREFIX,чтобы убедиться,что Sun's as и ld используются.Для получения дополнительной информации об опции -B и переменной окружения GCC_EXEC_PREFIX обратитесь к документации gcc.</target>
        </trans-unit>
        <trans-unit id="ee23e1f9045483d4017c29efb93306a8f81a02a3" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;posix#WIFEXITED&quot;&gt;&lt;code&gt;W*()&lt;/code&gt;&lt;/a&gt; calls from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3eb7cca34a1ce6ec3422f81caa582587938fc9" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; with the &lt;code&gt;W*()&lt;/code&gt; calls from the POSIX module.</source>
          <target state="translated">В качестве альтернативы вы можете проверить значение &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; с помощью вызовов &lt;code&gt;W*()&lt;/code&gt; из модуля POSIX.</target>
        </trans-unit>
        <trans-unit id="273eb19a8880a15607895e1cd30f571a681e7c99" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98574b24c9752f26b07d4e571e873801f591432e" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::OutputMap&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3baaa9fdf5df5a376581f707e9bd2202f9c63495" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc46e4aa2514a5747d9e66b804729fd4f6f91eb" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">Альтернативы пробуются слева направо, поэтому первая найденная альтернатива, которой соответствует все выражение, является той, которая выбрана. Это означает, что альтернативы не обязательно должны быть жадными. Например: при сопоставлении &lt;code&gt;foo|foot&lt;/code&gt; с &amp;laquo;босиком&amp;raquo; будет соответствовать только часть &amp;laquo;foo&amp;raquo;, так как это первая попытка альтернативы, и она успешно соответствует целевой строке. (Это может показаться неважным, но это важно, когда вы записываете совпадающий текст, используя круглые скобки.)</target>
        </trans-unit>
        <trans-unit id="c8af2aafd15c21262760094a19550be8139535e2" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &lt;code&gt;&quot;barefoot&quot;&lt;/code&gt;, only the &lt;code&gt;&quot;foo&quot;&lt;/code&gt; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178ef3c8a39076052130de80299d367dd5e6090f" translate="yes" xml:space="preserve">
          <source>Alternatives to raw</source>
          <target state="translated">Альтернативы сырью</target>
        </trans-unit>
        <trans-unit id="52a09d99c8be7488acf8d5679596a3a7ebeeb466" translate="yes" xml:space="preserve">
          <source>Alternatives: &lt;a href=&quot;Test2::AsyncSubtest&quot;&gt;Test2::AsyncSubtest&lt;/a&gt; and &lt;a href=&quot;Test2::Workflow&quot;&gt;Test2::Workflow&lt;/a&gt; (not stable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc6e5f9721668e6a6d8a7cd85c26663fa384cb4" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;https://metacpan.org/search?q=plack+auth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895965b31db8e4bfa4de954e884b587830b4927d" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">В качестве альтернативы посмотрите на &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt; или на один из других &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;вариантов аутентификации Plack&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="083655cd712cf57272ed2f0a7a5805f36d9802f0" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; cannot do this directly, there is a module which can layer transparently over &lt;b&gt;DB_File&lt;/b&gt; to accomplish this feat.</source>
          <target state="translated">Хотя &lt;b&gt;DB_File&lt;/b&gt; не может сделать это напрямую, существует модуль, который может прозрачно &lt;b&gt;накладываться&lt;/b&gt; на &lt;b&gt;DB_File&lt;/b&gt; для выполнения этой &lt;b&gt;задачи&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3768f14455445c5980f80214d4ffa65dc7a14002" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.</source>
          <target state="translated">Хотя на &lt;b&gt;DB_File&lt;/b&gt; распространяется лицензия Perl, используемая им библиотека, а именно Berkeley DB, не распространяется. Berkeley DB имеет собственное авторское право и собственную лицензию. Пожалуйста, найдите время, чтобы прочитать это.</target>
        </trans-unit>
        <trans-unit id="73b1840016122f68e05350fe0f1ab0303bd2fd8b" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs, &lt;b&gt;DB_File&lt;/b&gt; arranges for it to work like version 1. This feature allows &lt;b&gt;DB_File&lt;/b&gt; scripts that were built with version 1 to be migrated to version 2 or greater without any changes.</source>
          <target state="translated">Хотя &lt;b&gt;DB_File&lt;/b&gt; предназначен для использования с Berkeley DB версии 1, его также можно использовать с версиями 2, 3 или 4. В этом случае интерфейс ограничен функциональностью, предоставляемой Berkeley DB 1.x. Везде, где интерфейс версии 2 или выше отличается, &lt;b&gt;DB_File&lt;/b&gt; обеспечивает его работу как версию 1. Эта функция позволяет сценариям &lt;b&gt;DB_File&lt;/b&gt; , созданным с версией 1, без каких-либо изменений переноситься в версию 2 или выше.</target>
        </trans-unit>
        <trans-unit id="a4ee4e9c8be6f9bb865a03f9dd6635b3149d28d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;$_&lt;/code&gt; doesn't actually appear explicitly in the sample filters above, it is implicitly used in a number of places.</source>
          <target state="translated">Хотя &lt;code&gt;$_&lt;/code&gt; на самом деле не отображается явно в приведенных выше примерах фильтров, он неявно используется во многих местах.</target>
        </trans-unit>
        <trans-unit id="80dfb6d994a40fa49e44520920eac36d9fa1f16f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . These things make &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">Хотя &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; является ложным для простого еще не использованного хеша, он становится истинным в нескольких неочевидных обстоятельствах, включая итераторы, слабые ссылки, имена тайников, даже оставаясь истинным после &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . Эти вещи делают &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; бесполезным на практике, поэтому теперь он генерирует фатальную ошибку.</target>
        </trans-unit>
        <trans-unit id="7ff687f6589d5bc55ea5b6cd3b7acf0a8989e998" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Compress::Zlib&lt;/code&gt; has a pair of functions called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt;, they are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1f79335b5e25baa8b910d3ca247a13fd7eda4e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;cmp_ok()&lt;/code&gt; was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">Хотя &lt;code&gt;cmp_ok()&lt;/code&gt; была введена в 0.40, 0.86 исправила важную ошибку, сделав ее безопасной для перегруженных объектов; исправленная версия впервые была представлена ​​с Perl в 5.10.1 как часть Test :: More 0.92.</target>
        </trans-unit>
        <trans-unit id="a46f1c081d434cfa72b0670296268695a927ef72" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;defined %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;undef %hash&lt;/code&gt;. These things make &lt;code&gt;defined %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4fc726a9484b19113d6eedd6d8805f1968eb73" translate="yes" xml:space="preserve">
          <source>Although FileCache can be used with piped opens ('-|' or '|-') doing so is strongly discouraged. If FileCache finds it necessary to close and then reopen a pipe, the command at the far end of the pipe will be reexecuted - the results of performing IO on FileCache'd pipes is unlikely to be what you expect. The ability to use FileCache on pipes may be removed in a future release.</source>
          <target state="translated">Хотя FileCache можно использовать с открытиями piped ('-|' или '|-'),делать это категорически не рекомендуется.Если FileCache сочтет необходимым закрыть,а затем снова открыть трубу,команда на дальнем конце трубы будет выполнена заново-результаты ввода-вывода на трубах FileCache вряд ли будут такими,какими вы ожидали.Возможность использования FileCache на трубах может быть удалена в одном из будущих релизов.</target>
        </trans-unit>
        <trans-unit id="077804ce34db1c72deaf81a9a83f1e62f8a114a7" translate="yes" xml:space="preserve">
          <source>Although I have made use of only the &lt;code&gt;POP*&lt;/code&gt; macros to access values returned from Perl subroutines, it is also possible to bypass these macros and read the stack using the &lt;code&gt;ST&lt;/code&gt; macro (See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for a full description of the &lt;code&gt;ST&lt;/code&gt; macro).</source>
          <target state="translated">Хотя я использовал только &lt;code&gt;POP*&lt;/code&gt; макросы доступа к значениям возвращаемых из подпрограмм Perl, также можно обойти эти макросы и читать стек с помощью &lt;code&gt;ST&lt;/code&gt; макроса (см &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; для полного описания &lt;code&gt;ST&lt;/code&gt; макро).</target>
        </trans-unit>
        <trans-unit id="ebf0c3d2a317483257bd5985b5509d45e615f5a4" translate="yes" xml:space="preserve">
          <source>Although PA-RISC binaries can run on Itanium systems, you should not attempt to use a PA-RISC version of Perl on an Itanium system. This is because shared libraries created on an Itanium system cannot be loaded while running a PA-RISC executable.</source>
          <target state="translated">Хотя исполняемые файлы PA-RISC могут работать на Itanium-системах,не следует пытаться использовать PA-RISC-версию Perl на Itanium-системах.Это связано с тем,что разделяемые библиотеки,созданные на системе Itanium,не могут быть загружены во время выполнения исполняемого файла PA-RISC.</target>
        </trans-unit>
        <trans-unit id="2b071251c66f97d7a5a833d31d9bbb833fc948ef" translate="yes" xml:space="preserve">
          <source>Although Perl will automatically grow strings for you, if you need to force Perl to allocate more memory for your SV, you can use the macro</source>
          <target state="translated">Хотя Perl будет автоматически увеличивать строки для вас,если вам нужно заставить Perl выделить больше памяти для вашего SV,вы можете использовать макрос</target>
        </trans-unit>
        <trans-unit id="3fece6ab5bd6d283eb840842e215942103cb610e" translate="yes" xml:space="preserve">
          <source>Although Plan 9 Perl currently only provides static loading, it is built with a number of useful extensions. These include Opcode, FileHandle, Fcntl, and POSIX. Expect to see others (and DynaLoading!) in the future.</source>
          <target state="translated">Хотя Plan 9 Perl в настоящее время обеспечивает только статическую загрузку,он построен с рядом полезных расширений.К ним относятся Opcode,FileHandle,Fcntl и POSIX.Ожидайте увидеть другие (и DynaLoading!)в будущем.</target>
        </trans-unit>
        <trans-unit id="e4e6f6df84571e93788f39ee96ef2a5f0752bec2" translate="yes" xml:space="preserve">
          <source>Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use &lt;code&gt;done_testing()&lt;/code&gt; but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More &amp;gt; 0.88.</source>
          <target state="translated">Хотя Test :: More был основным модулем в версиях Perl начиная с 5.6.2, Test :: More с тех пор эволюционировал, и не все функции, к которым вы привыкли, будут присутствовать в поставляемой версии Test :: Больше. Если вы пишете модуль, не забудьте указать в метаданных вашего пакета минимальную версию Test :: More, которая вам нужна. Например, если вы хотите использовать &lt;code&gt;done_testing()&lt;/code&gt; но хотите, чтобы ваш тестовый скрипт запускался на Perl 5.10.0, вам необходимо явно потребовать Test :: More&amp;gt; 0.88.</target>
        </trans-unit>
        <trans-unit id="4b6eb7d4608b6bb5e2737f99ed626a9c3d3fdff3" translate="yes" xml:space="preserve">
          <source>Although all mathematical operations on version objects are forbidden by default, it is possible to retrieve a number which corresponds to the version object through the use of the $obj-&amp;gt;numify method. For formatting purposes, when displaying a number which corresponds a version object, all sub versions are assumed to have three decimal places. So for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cac5f469f6b90c62f4e56ab4bfa747637957a2" translate="yes" xml:space="preserve">
          <source>Although as of 5.14, that can be also be accomplished this way:</source>
          <target state="translated">Хотя по состоянию на 5.14 это может быть сделано и таким образом:</target>
        </trans-unit>
        <trans-unit id="06dbd031cbe601d39502de2a4b463b8de205125c" translate="yes" xml:space="preserve">
          <source>Although at first sight there seems to be quite a lot going on in &lt;code&gt;Apache::GZip&lt;/code&gt;, you could sum up what the code was doing as follows -- read the contents of the file in &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt;, compress it and write the compressed data to standard output. That's all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b446ed3017bd4a5c94fd715dbc357d36cd8b9eae" translate="yes" xml:space="preserve">
          <source>Although if your manager accused you of seeking job security (or rapid insecurity) through inscrutable code, it would be hard to argue. :-) If I were you, I'd put that in a function:</source>
          <target state="translated">Хотя,если ваш менеджер обвинил вас в том,что вы ищете гарантию занятости (или быструю незащищенность)с помощью непостижимого кода,то с этим трудно спорить.:-).На вашем месте я бы поместил это в функцию:</target>
        </trans-unit>
        <trans-unit id="4a4e26bb6dd1017566ef68d6d6d4ea499d6e917f" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</source>
          <target state="translated">Хотя он не имеет прямого эквивалента в C, оператор &lt;code&gt;//&lt;/code&gt; Perl связан со своим C-стилем &amp;laquo;or&amp;raquo;. Фактически, это то же самое, что и &lt;code&gt;||&lt;/code&gt; , за исключением того, что он проверяет определенность левой части вместо ее истинности. Таким образом, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; возвращает значение &lt;code&gt;EXPR1&lt;/code&gt; , если оно определено, в противном случае возвращается значение &lt;code&gt;EXPR2&lt;/code&gt; . ( &lt;code&gt;EXPR1&lt;/code&gt; вычисляется в скалярном контексте, &lt;code&gt;EXPR2&lt;/code&gt; в контексте самого &lt;code&gt;//&lt;/code&gt; ). Обычно это тот же результат, что и &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (за исключением того, что форма тернарного оператора может использоваться как lvalue, а &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; не может). Это очень полезно для предоставления значений по умолчанию для переменных. Если вы действительно хотите проверить, определен ли хотя бы один из &lt;code&gt;$x&lt;/code&gt; и &lt;code&gt;$y&lt;/code&gt; , используйте &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb2cc3c9a7a9c586fba874bcd544c7350b090af" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;defined(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;defined($x // $y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d57a21b7f19f0f3f2ceca275a472340c6e4e3a5" translate="yes" xml:space="preserve">
          <source>Although it has the same precedence as in C, Perl's &lt;code&gt;?:&lt;/code&gt; operator produces an lvalue. This assigns $x to either $if_true or $if_false, depending on the trueness of $maybe:</source>
          <target state="translated">Хотя он имеет тот же приоритет, что и в C, оператор Perl &lt;code&gt;?:&lt;/code&gt; Создает lvalue. Это присваивает $ x либо $ if_true, либо $ if_false, в зависимости от правильности $ might:</target>
        </trans-unit>
        <trans-unit id="5ee0b4360c14601bcb250b62e156bc4ae2010689" translate="yes" xml:space="preserve">
          <source>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in</source>
          <target state="translated">Хотя это немного сбивает с толку и некоторые люди возражают против терминологии,стоит взглянуть на комментарий,который был в</target>
        </trans-unit>
        <trans-unit id="da1e430c6e0d63cde26c5c8c71827f0d44bf6196" translate="yes" xml:space="preserve">
          <source>Although it is not illegal, the use of &lt;code&gt;MultiHomed&lt;/code&gt; on a socket which is in non-blocking mode is of little use. This is because the first connect will never fail with a timeout as the connect call will not block.</source>
          <target state="translated">Хотя это и не является незаконным, использование &lt;code&gt;MultiHomed&lt;/code&gt; на сокете, который находится в неблокирующем режиме, малоэффективно . Это связано с тем, что первое соединение никогда не завершится ошибкой с тайм-аутом, поскольку вызов соединения не будет заблокирован.</target>
        </trans-unit>
        <trans-unit id="e93362b29f52a34d35cc322a788d526233d087a7" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</source>
          <target state="translated">Хотя можно (с некоторыми усилиями с вашей стороны) использовать этот модуль для доступа к файлам .zip, существуют и другие модули Perl, которые сделают всю тяжелую работу за вас. Ознакомьтесь с &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; и &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c711291979b77793d98593cadd4dda9f5e5ad0f" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt;, &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a135fdb236629c700a0674370bcc8d9bb97bd72" translate="yes" xml:space="preserve">
          <source>Although it may be considered internal, the class hierarchy does matter for both users and programmer. CPAN.pm deals with the four classes mentioned above, and those classes all share a set of methods. Classical single polymorphism is in effect. A metaclass object registers all objects of all kinds and indexes them with a string. The strings referencing objects have a separated namespace (well, not completely separated):</source>
          <target state="translated">Несмотря на то,что иерархию классов можно считать внутренней,она имеет значение как для пользователей,так и для программиста.CPAN.pm работает с четырьмя упомянутыми выше классами,и все эти классы имеют общий набор методов.Действует классический единый полиморфизм.Объект метакласса регистрирует все объекты всех видов и индексирует их строкой.Строки,на которые ссылаются объекты,имеют отдельное пространство имён (ну,не полностью отделенное):</target>
        </trans-unit>
        <trans-unit id="c770d25bc14389e491ccd1785ab555be61626cb8" translate="yes" xml:space="preserve">
          <source>Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.</source>
          <target state="translated">Хотя это может быть не сразу видно из приведенного кода,интерфейс ассоциативного массива можно использовать для записи значений с дублирующимися ключами,но его нельзя использовать для их считывания из БД.</target>
        </trans-unit>
        <trans-unit id="180ef42cd3ef3f7ed108e6700423675760cce278" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">Хотя это может показаться настоящей головной болью, на самом деле стоит приложить все усилия, чтобы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; во всех ваших скриптах.</target>
        </trans-unit>
        <trans-unit id="566dc93bd22756361b44728a27034002b97a3383" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;use strict&lt;/code&gt; in all your scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf682b28167943a367ab8e4c8b1a462063a4d50" translate="yes" xml:space="preserve">
          <source>Although it's less convenient in some ways than the tied hash interface, you can also call methods directly to manipulate individual symbols. In some cases, this allows you finer control than using a tied hash aggregate. The following methods are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eddb5fd279be6b295018b9f9f42e02ddccfda46" translate="yes" xml:space="preserve">
          <source>Although memory overhead of bigger buckets is kept inside the bucket, for smaller buckets, it is kept in separate areas. This field gives the total size of these areas.</source>
          <target state="translated">Несмотря на то,что память больших ведер хранится внутри ведра,для меньших ведер она хранится в отдельных местах.В этом поле указывается общий размер этих областей.</target>
        </trans-unit>
        <trans-unit id="89dede28bef0b8e7f141797013c579678fb08474" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe78f913ab3f5713143fe4461404c36ff017beb" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">Хотя в настоящее время предупреждения не возникает, результаты не очень хорошо определены, когда эти операции выполняются с операндами, которые не являются ни числами (см. &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленная арифметика&lt;/a&gt; ), ни битовыми строками (см. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Побитовые строковые операторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c94501363b8d49d883be5ef00569dcb0d5283b0f" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; statement. There are three forms: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR, and &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">Хотя Perl и не для слабонервных, он поддерживает &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . Существует три формы: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR и &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - &amp;amp; NAME. LABEL цикла на самом деле не является допустимой целью для &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ; это просто название цикла.</target>
        </trans-unit>
        <trans-unit id="1069922d0daa5d3be0e9150c826b5a6eaf7851b6" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;goto&lt;/code&gt; statement. There are three forms: &lt;code&gt;goto&lt;/code&gt;-LABEL, &lt;code&gt;goto&lt;/code&gt;-EXPR, and &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;goto&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c556c081516373f750515951f1b9a5217dc9bdfc" translate="yes" xml:space="preserve">
          <source>Although one can already do quite a lot with the literal string regexps above, we've only scratched the surface of regular expression technology. In this and subsequent sections we will introduce regexp concepts (and associated metacharacter notations) that will allow a regexp to represent not just a single character sequence, but a</source>
          <target state="translated">Хотя с приведенными выше регеxps буквенной строки уже достаточно много можно сделать,мы только поцарапали поверхность технологии регулярных выражений.В этом и последующих разделах мы введем понятия регеxp (и связанные с ними метахарные нотации),которые позволят регеxp представлять не только одну последовательность символов,но и</target>
        </trans-unit>
        <trans-unit id="2365e59fbff407c44bacc5b415419bc0925eb6e4" translate="yes" xml:space="preserve">
          <source>Although one does not have to follow this convention, be aware that the convention for UNIX man pages for commands is for the man page title to be in all-uppercase, even if the command isn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a0eac57e1c4484372ccab28955e18fb02ea640" translate="yes" xml:space="preserve">
          <source>Although one would expect the quantities $y and $z to be the same and equal to 100000 they will differ and instead will be 0 and 100000 respectively.</source>
          <target state="translated">Хотя можно ожидать,что суммы в $y и $z будут одинаковыми и равными 100000,они будут отличаться,а вместо этого будут равны 0 и 100000 соответственно.</target>
        </trans-unit>
        <trans-unit id="5829c5fcc8ce3b64df01881896b3b15fd774741a" translate="yes" xml:space="preserve">
          <source>Although only a single value was expected to be returned from</source>
          <target state="translated">Хотя ожидалось,что только одно значение будет возвращено из</target>
        </trans-unit>
        <trans-unit id="2a2b97db7310124d07426632d32011d83ef42107" translate="yes" xml:space="preserve">
          <source>Although primarily designed for use with multi-threaded Perl, the macros have been designed so that they will work with non-threaded Perl as well.</source>
          <target state="translated">Несмотря на то,что макросы в первую очередь предназначены для использования с многопоточным Perl,они разработаны таким образом,что будут работать и с непоточным Perl.</target>
        </trans-unit>
        <trans-unit id="797e69b4382557ebf9cc947a771d199448156185" translate="yes" xml:space="preserve">
          <source>Although similar, file path specifications differ between Unix, Windows, Mac OS, OS/2, VMS, VOS, RISC OS, and probably others. Unix, for example, is one of the few OSes that has the elegant idea of a single root directory.</source>
          <target state="translated">Несмотря на схожесть,спецификации путей к файлам различаются между Unix,Windows,Mac OS,OS/2,VMS,VOS,RISC OS и,возможно,другими.Unix,например,одна из немногих ОС,которая имеет элегантную идею одного корневого каталога.</target>
        </trans-unit>
        <trans-unit id="d6190ff15955860c6c9fdd297f5be90390874780" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt; , and &lt;code&gt;result&lt;/code&gt; . (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">Несмотря на то, что отказов теста должно быть достаточно, дополнительная диагностика может быть запущена в конце выполнения теста. &lt;code&gt;onfail&lt;/code&gt; передается ссылка на массив хеш-ссылок, которые описывают каждую ошибку теста. Каждый хеш будет содержать как минимум следующие поля: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;repetition&lt;/code&gt; и &lt;code&gt;result&lt;/code&gt; . (Вы не должны полагаться на наличие каких-либо других полей.) Если тест имел ожидаемое значение или диагностическую (или &amp;laquo;примечание&amp;raquo;) строку, они также будут включены.</target>
        </trans-unit>
        <trans-unit id="cb955315f15c5e807d16b61b980d5ee47a32430b" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt;. (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224e863badf25248ea988718d8bd34cef72cce5a" translate="yes" xml:space="preserve">
          <source>Although that form may run into trouble in network transit (due to the presence of 8 bit characters) or on non ISO-Latin character sets. But it does allow &lt;code&gt;Is_c1&lt;/code&gt; to be rewritten so it works on Perls that don't have &lt;code&gt;'unicode_strings'&lt;/code&gt; (earlier than v5.14):</source>
          <target state="translated">Хотя эта форма может вызвать проблемы при передаче по сети (из-за наличия 8-битных символов) или при использовании наборов символов, отличных от ISO-Latin. Но он позволяет переписать &lt;code&gt;Is_c1&lt;/code&gt; , чтобы он работал на Perls, у которых нет &lt;code&gt;'unicode_strings'&lt;/code&gt; (ранее, чем v5.14):</target>
        </trans-unit>
        <trans-unit id="99123ea723cf2a29473e47c091f28928ebbdafd8" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;%&lt;/code&gt; code is documented as returning a &quot;checksum&quot;: don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</source>
          <target state="translated">Хотя код &lt;code&gt;%&lt;/code&gt; задокументирован как возвращающий &amp;laquo;контрольную сумму&amp;raquo;: не доверяйте таким значениям! Даже при применении к небольшому количеству байтов они не гарантируют заметного расстояния Хэмминга.</target>
        </trans-unit>
        <trans-unit id="6834c0c595f466c17dc9377b6377ec111fa7e11c" translate="yes" xml:space="preserve">
          <source>Although the above may seem a bit confusing at first, it generally does &quot;the right thing&quot; in most situations. This determination of the default values to use is based upon the following typical Unix conventions:</source>
          <target state="translated">Хотя вышеизложенное может сначала показаться немного запутанным,в большинстве ситуаций оно,как правило,делает &quot;правильные вещи&quot;.Такое определение значений по умолчанию основано на следующих типичных Unix конвенциях:</target>
        </trans-unit>
        <trans-unit id="a0b752b8fd0002195999a4940b4a67ff51de0cf2" translate="yes" xml:space="preserve">
          <source>Although the error message above refers to the second tie() statement in the script, the source of the problem is really with the untie() statement that precedes it.</source>
          <target state="translated">Хотя приведенное выше сообщение об ошибке относится ко второму оператору tie()в сценарии,источник проблемы на самом деле заключается в предшествующем ему операторе untie().</target>
        </trans-unit>
        <trans-unit id="050771d84c3ebf7bfb6e4438000d2961a2adc2a7" translate="yes" xml:space="preserve">
          <source>Although the functionality provided by this flag may seem straightforward, it should be used only if there is a good reason to do so. The reason for being cautious is that, even if you have specified the G_NOARGS flag, it is still possible for the Perl subroutine that has been called to think that you have passed it parameters.</source>
          <target state="translated">Хотя функциональность,предоставляемая этим флагом,может показаться простой,ее следует использовать только в том случае,если на то есть веская причина.Причина осторожности заключается в том,что даже если Вы указали флаг G_NOARGS,для вызываемой подпрограммной панели Perl все равно возможно,что Вы передали ей параметры.</target>
        </trans-unit>
        <trans-unit id="0019a6a5066bef3137d87deda446668085e7063b" translate="yes" xml:space="preserve">
          <source>Although the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.</source>
          <target state="translated">Хотя игнорируемый аргумент не попадает в переменную,его передача все равно обязательна для вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="35ed9f698c7272524026c7a45834a834a74d7bb0" translate="yes" xml:space="preserve">
          <source>Although the main discussion of Perl security issues can be found in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;, a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. A malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:</source>
          <target state="translated">Хотя основное обсуждение вопросов безопасности Perl можно найти в &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; , обсуждение обработки языковых стандартов Perl было бы неполным, если бы оно не привлекло ваше внимание к вопросам безопасности, зависящим от локали. Локали - особенно в системах, которые позволяют непривилегированным пользователям создавать свои собственные локали - не заслуживают доверия. Вредоносный (или просто сломанный) языковой стандарт может привести к тому, что приложение, поддерживающее языковой стандарт, даст неожиданные результаты. Вот несколько возможностей:</target>
        </trans-unit>
        <trans-unit id="6ad8f5d884e3bfe99068d75f61c2b91c556f88ba" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the $key element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">Хотя самый глубоко вложенный массив или хеш-элемент не появится только потому, что его существование было проверено, любые промежуточные элементы появятся. Таким образом, &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; и &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; появятся в результате проверки существования элемента $ key выше. Это происходит везде, где используется оператор стрелки, в том числе даже здесь:</target>
        </trans-unit>
        <trans-unit id="d1b22581bc0b80baeffbb205fa759bdb0ff242e5" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the &lt;code&gt;$key&lt;/code&gt; element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece6731e40fd98f25883ef891976cdd74d8b5353" translate="yes" xml:space="preserve">
          <source>Although the optree is read-only, there is an overlay facility that allows you to override what values the various B::*OP methods return for a particular op. &lt;code&gt;$B::overlay&lt;/code&gt; should be set to reference a two-deep hash: indexed by OP address, then method name. Whenever a an op method is called, the value in the hash is returned if it exists. This facility is used by B::Deparse to &quot;undo&quot; some optimisations. For example:</source>
          <target state="translated">Хотя optree доступно только для чтения, существует возможность наложения, которая позволяет вам переопределить, какие значения возвращают различные методы B :: * OP для конкретной операции. &lt;code&gt;$B::overlay&lt;/code&gt; должен быть установлен для ссылки на хэш с двумя глубинами: индексируется адресом OP, затем именем метода. Каждый раз, когда вызывается операционный метод, возвращается значение хэша, если оно существует. Эта возможность используется B :: Deparse для &amp;laquo;отмены&amp;raquo; некоторых оптимизаций. Например:</target>
        </trans-unit>
        <trans-unit id="4006666c099c71fba2fd95778e8d769cab92e521" translate="yes" xml:space="preserve">
          <source>Although the primary purpose for the existence of &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; is for use by the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; modules, it can be used on its own for simple compression/uncompression tasks.</source>
          <target state="translated">Хотя основная цель существования &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; - использование модулями &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; и &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; , его можно использовать отдельно для простых задач сжатия / распаковки. .</target>
        </trans-unit>
        <trans-unit id="73cce3599d213093393a3d6545498d75ae280481" translate="yes" xml:space="preserve">
          <source>Although the techniques described here are applicable when embedding Perl in a C program, this is not the primary goal of this document. There are other details that must be considered and are specific to embedding Perl. For details on embedding Perl in C refer to &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Хотя описанные здесь методы применимы при встраивании Perl в программу на C, это не является основной целью данного документа. Есть и другие особенности, которые необходимо учитывать и относятся к встраиванию Perl. Для получения подробной информации о встраивании Perl в C обратитесь к &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14e1e99a665303302472280aa271e6e7551860a9" translate="yes" xml:space="preserve">
          <source>Although there can be any number of source streams in existence at any given time, only one will be active.</source>
          <target state="translated">Хотя в любой момент времени может существовать любое количество исходных потоков,активным будет только один.</target>
        </trans-unit>
        <trans-unit id="837688ce8fc062bca9030ce8b90ed396865f417d" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;&quot;Context&quot;&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;&quot;List value constructors&quot; in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84534656a685169f0194cbbe1e16531f562b033" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;List value constructors in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">Хотя они сгруппированы по семействам, все они имеют приоритет назначения. Эти комбинированные операторы присваивания могут работать только со скалярами, тогда как обычный оператор присваивания может присваивать массивы, хэши, списки и даже ссылки. (См. &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;Разделы Конструкторы значений &lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;контекста&lt;/a&gt; и списка в perldata и &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Назначение ссылок в perlref&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="1f0ef7687de397f14de7592d67f915d2f79f2a4c" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a &lt;code&gt;PUSHMARK&lt;/code&gt; before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;&quot;call_pv&quot;&lt;/a&gt; for example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459be48ccfdeb87ea73fbd1fbec51d1410292106" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a PUSHMARK before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; for example).</source>
          <target state="translated">Хотя эта функция возвращает свои значения в стеке аргументов perl, она не принимает никаких параметров из этого стека (и, таким образом, в частности, нет необходимости делать PUSHMARK перед ее вызовом, в отличие, например , от &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ecb9099e922e4493577adbe3649de5e0005a135" translate="yes" xml:space="preserve">
          <source>Although this keyword is optional and in some cases provides redundant information it should always be used. This keyword will ensure that the XSUBs appear in the desired package.</source>
          <target state="translated">Хотя это ключевое слово является необязательным и в некоторых случаях предоставляет избыточную информацию,его всегда следует использовать.Это ключевое слово гарантирует,что XSUBs появятся в нужном пакете.</target>
        </trans-unit>
        <trans-unit id="66fb31ad783a8264f17dab51f3aa1ad011017a08" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt; .</source>
          <target state="translated">Хотя эту опцию можно использовать с OO-интерфейсом, она наиболее полезна с одноразовым интерфейсом. Например, в приведенном ниже коде показано, как можно использовать &lt;code&gt;FilterName&lt;/code&gt; для удаления компонента пути из серии имен файлов перед их сохранением в &lt;code&gt;$zipfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7045e0d3148f2b5800c2c6d6d41c5d9e7c09642" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2398658140451226b4cd3f1886215ebf8c65091f" translate="yes" xml:space="preserve">
          <source>Although this stuff is easier to explain using examples, you first need be aware of a few important definitions.</source>
          <target state="translated">Хотя этот материал легче объяснить на примерах,сначала вам нужно знать несколько важных определений.</target>
        </trans-unit>
        <trans-unit id="5d6b9d5e42d7a86677e3f471c1e47e328daf1dc8" translate="yes" xml:space="preserve">
          <source>Although very useful, the big problem with using &lt;b&gt;-w&lt;/b&gt; on the command line to enable warnings is that it is all or nothing. Take the typical scenario when you are writing a Perl program. Parts of the code you will write yourself, but it's very likely that you will make use of pre-written Perl modules. If you use the &lt;b&gt;-w&lt;/b&gt; flag in this case, you end up enabling warnings in pieces of code that you haven't written.</source>
          <target state="translated">Хотя это очень полезно, большая проблема с использованием &lt;b&gt;-w&lt;/b&gt; в командной строке для включения предупреждений заключается в том, что это все или ничего. Возьмите типичный сценарий, когда вы пишете программу на Perl. Части кода вы напишете сами, но очень вероятно, что вы будете использовать предварительно написанные модули Perl. Если вы используете в этом случае флаг &lt;b&gt;-w&lt;/b&gt; , вы в конечном итоге активируете предупреждения в частях кода, которые вы не писали.</target>
        </trans-unit>
        <trans-unit id="560edbbb945d8ba093edcea345708feb744a0493" translate="yes" xml:space="preserve">
          <source>Although we do suggest that you always build your own Perl from the source code, both for maximal configurability and for security, in case you are in a hurry you can check &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; for binary distributions.</source>
          <target state="translated">Хотя мы рекомендуем вам всегда создавать свой собственный Perl из исходного кода, как для максимальной настраиваемости, так и для обеспечения безопасности, в случае, если вы торопитесь, вы можете проверить &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; для бинарные распределения.</target>
        </trans-unit>
        <trans-unit id="cd023125cfeba9eec78f15bbf69240c8b819181b" translate="yes" xml:space="preserve">
          <source>Although we wish to free any temps at the same time, we have to be careful not to free any temps which are keeping return args alive; nor to free the temps we have just created while mortal copying return args. Fortunately, &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; is capable of making mortal copies of return args, shifting args down the stack, and only processing those entries on the temps stack that are safe to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ce08a44dd2ba4f6ce9e91fa3d420e93dff144d" translate="yes" xml:space="preserve">
          <source>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you'll want to localize some package variables:</source>
          <target state="translated">Хотя запись может работать с лексическими или пакетными переменными,какие бы переменные вы ни использовали,они должны иметь область видимости в формате.Скорее всего,это означает,что вы захотите локализовать некоторые переменные пакета:</target>
        </trans-unit>
        <trans-unit id="e5edf100e2a7db4baae600915e4757f07b6f80de" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e9346790d51b0db2514b5ac70a5da4526349c7" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">Хотя по историческим причинам дистрибутив &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; получил свое название от этого модуля, теперь он существует только для предоставления &lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; интерфейса, который в некоторой степени обратно совместим с &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx. Если вы пишете новый код, подумайте об использовании &lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt; напрямую.</target>
        </trans-unit>
        <trans-unit id="31fcae02d3e65b92831cdd124f189410606de910" translate="yes" xml:space="preserve">
          <source>Alvestrand, Harald Tveit. 1995.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f966b3ea336af8830bc18236a5389bd937c78b7c" translate="yes" xml:space="preserve">
          <source>Always be civil.</source>
          <target state="translated">Всегда будь вежлив.</target>
        </trans-unit>
        <trans-unit id="c369c01b27ace1a743bc3e37d378c5dbbf093f50" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt; , include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">Всегда проверяйте коды возврата системных вызовов. Хорошие сообщения об ошибках должны поступать в &lt;code&gt;STDERR&lt;/code&gt; , включая то, какая программа вызвала проблему, каковы были неудачные системные вызовы и аргументы, и (ОЧЕНЬ ВАЖНО) должно содержать стандартное системное сообщение об ошибке, указывающее, что пошло не так. Вот простой, но достаточный пример:</target>
        </trans-unit>
        <trans-unit id="c9f2011c5ea88ecfcfb89f58ad78e623f2ab76d8" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt;, include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5844f1a31b652c47f84d0aaae5c714b741011321" translate="yes" xml:space="preserve">
          <source>Always commit changes to config variables to disk?</source>
          <target state="translated">Всегда фиксировать изменения в переменных конфигурации на диске?</target>
        </trans-unit>
        <trans-unit id="c9994fb26151727507038319136d7dd61608906c" translate="yes" xml:space="preserve">
          <source>Always comparing to a version object will help avoid surprises:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2fdc72c972de55363038192e944aae07f2f5ef" translate="yes" xml:space="preserve">
          <source>Always decompose on the way in, then recompose on the way out.</source>
          <target state="translated">Всегда разлагайтесь по пути внутрь,а затем снова разлагайтесь по пути наружу.</target>
        </trans-unit>
        <trans-unit id="a981ab84adf96ff26a362806abc6776217d3e6df" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%X&lt;/code&gt;, the locale's appropriate time representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ade828ef985c357a4f590a718feea06b8ef69f" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%c&lt;/code&gt;, the locale's appropriate date and time representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500eaed1bf2ab70574a92f0ee3e10b9af4499072" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%x&lt;/code&gt;, the locale's appropriate date representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c61fff2e0b1e2b49630e69bc2a2e99ec24ecff3" translate="yes" xml:space="preserve">
          <source>Always explicitly and immediately call close() on the writable end of any pipe, unless that process is actually writing to it. Even if you don't explicitly call close(), Perl will still close() all filehandles during global destruction. As previously discussed, if those filehandles have been opened with Safe Pipe Open, this will result in calling waitpid(), which may again deadlock.</source>
          <target state="translated">Всегда явно и немедленно вызывайте функцию close()на конце любой трубы,доступной для записи,если только этот процесс на самом деле не пишет в нее.Даже если вы явно не вызываете функцию close(),Perl все равно будет закрывать()все файловые дескрипторы во время глобального разрушения.Как обсуждалось ранее,если эти файловые дескрипторы были открыты с помощью Safe Pipe Open,это приведет к вызову функции waitpid(),которая может снова зайти в тупик.</target>
        </trans-unit>
        <trans-unit id="242eddbfa115df236054209d0570301b5af3c68e" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt; .</source>
          <target state="translated">Всегда размещайте макрос START_MY_CXT сразу после объявления &lt;code&gt;my_cxt_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a1f78b377f3f4dbcc2f8cd296fbf35bd7322707" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891f99ab9e41224456357d41b700c51457def43d" translate="yes" xml:space="preserve">
          <source>Always quote the version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f26e154493acc9e3d45671d863271e7464d39e" translate="yes" xml:space="preserve">
          <source>Always strive to remain compatible with previous released versions. Otherwise try to add a mechanism to revert to the old behavior if people rely on it. Document incompatible changes.</source>
          <target state="translated">Всегда старайтесь оставаться совместимым с предыдущими выпущенными версиями.Иначе попробуйте добавить механизм возврата к старому поведению,если люди на него полагаются.Документировать несовместимые изменения.</target>
        </trans-unit>
        <trans-unit id="1c41f11cd18971bbdb3e2ef9969d459e5296677c" translate="yes" xml:space="preserve">
          <source>Always try to check and verify signatures if a SIGNATURE file is in the package and Module::Signature is installed (yes/no)?</source>
          <target state="translated">Всегда старайтесь проверять и проверять подписи,есть ли в пакете файл SIGNATURE и установлен ли модуль::Signature (да/нет)?</target>
        </trans-unit>
        <trans-unit id="24f1e77216b2edc00da08bfb70769a17a94800b4" translate="yes" xml:space="preserve">
          <source>Always try to show upload date with 'd' and 'm' command (yes/no)?</source>
          <target state="translated">Всегда пытаться показать дату загрузки с помощью команды 'd' и 'm' (да/нет)?</target>
        </trans-unit>
        <trans-unit id="ab3692e008452cea5b34a3fe52ad03c81207161c" translate="yes" xml:space="preserve">
          <source>Always use &lt;b&gt;-w&lt;/b&gt;.</source>
          <target state="translated">Всегда используйте &lt;b&gt;-w&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f5dc9ef4a983f2881df95298081703042e4c314a" translate="yes" xml:space="preserve">
          <source>Always use a dotted-decimal with (at least) three components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af0291b70c5a30fa81736f480600ed39cabe174" translate="yes" xml:space="preserve">
          <source>Always use a leading-v</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8367b54257a55d960e03d572f3ffce6e4f988276" translate="yes" xml:space="preserve">
          <source>Always use with a subtag. Notable forms: {sgn-gb} British Sign Language (BSL); {sgn-ie} Irish Sign Language (ESL); {sgn-ni} Nicaraguan Sign Language (ISN); {sgn-us} American Sign Language (ASL).</source>
          <target state="translated">Всегда используйте с подтегом.Примечательные формы:{sgn-gb}Британский язык жестов (БЯЖ);{sgn-ie}Ирландский язык жестов (ESL);{sgn-ni}никарагуанский язык жестов (ISN);{sgn-us}Американский язык жестов (ASL).</target>
        </trans-unit>
        <trans-unit id="d7fc26ae93e0cf00af5e88a1fe69971068f3bf0a" translate="yes" xml:space="preserve">
          <source>Ambiguous Local Times (DST)</source>
          <target state="translated">Двусмысленное местное время (DST)</target>
        </trans-unit>
        <trans-unit id="60b78dd3bc38b79497387b8798a6af56908b3286" translate="yes" xml:space="preserve">
          <source>Ambiguous call resolved as CORE::%s(), qualify as such or use &amp;amp;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d6325a5322b24a8cad3df61889fcccc37da082" translate="yes" xml:space="preserve">
          <source>Ambiguous range in transliteration operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edda76ce0ef49493fbd99f6a03d679fce823d7ca" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c resolved as operator %c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f919429ce49eab88ebaca27d4b763e67507277" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s[...]} resolved to %c%s[...]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c963134cf7d24b861988abb82e92519a22caf5a" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s{...}} resolved to %c%s{...}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d7860a6ad7ad4f88f893704243eeb8b4377d90" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s} resolved to %c%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67f229db4a4d1b5f2225b9846f84a14f01ccc8d" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %s resolved as %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59caacddbf40a7be1f1b173255e30458a45962f9" translate="yes" xml:space="preserve">
          <source>Ambiguous use of -%s resolved as -&amp;amp;%s()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61e588022eb4910c7d278a411480210f9347590" translate="yes" xml:space="preserve">
          <source>Ambulation.pm</source>
          <target state="translated">Ambulation.pm</target>
        </trans-unit>
        <trans-unit id="7dec8f79f324daec9e2bc3cec19154d9b44d20cf" translate="yes" xml:space="preserve">
          <source>Amiga Developers Environment</source>
          <target state="translated">Амига Разработчики Окружающая среда</target>
        </trans-unit>
        <trans-unit id="e2b08dd8d56c6933a46584a5b28aac8a3ed2befa" translate="yes" xml:space="preserve">
          <source>Amiga Specific Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb77f842d900a2dedf7fde5ab4f77cd221a01f3" translate="yes" xml:space="preserve">
          <source>Amiga,</source>
          <target state="translated">Amiga,</target>
        </trans-unit>
        <trans-unit id="e6b810bb50ff4aa9149ad36bef5c0f4e23da0b22" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx</source>
          <target state="translated">Amiga::ARexx</target>
        </trans-unit>
        <trans-unit id="01a8977a9be8d612968643e3bf495cf6b7267806" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx - Perl extension for ARexx support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adf028f8c6d2a6a1f2e1490947a8c498843d956" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx METHODS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06d09541ec208da13b7be9ff5bbfee7e66e27b2" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx::Msg METHODS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7974d6ce506c1fbe8763064a655033977f865b" translate="yes" xml:space="preserve">
          <source>Amiga::Exec</source>
          <target state="translated">Amiga::Exec</target>
        </trans-unit>
        <trans-unit id="d165b945227b32b2aec4eb213a7b6887056e595f" translate="yes" xml:space="preserve">
          <source>Amiga::Exec - Perl extension for low level amiga support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6763cfad1bb35aed134ab02bf5d64d5a57ca8187" translate="yes" xml:space="preserve">
          <source>Amnesty will prevent a failed assertion from causing the overall test to fail. In other words it marks a failure as expected and allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c76575f93cf9b6439e5c8c228d14871841f2be6" translate="yes" xml:space="preserve">
          <source>Among IBM EBCDIC character code sets there are 13 characters that are often mapped to different integer values. Those characters are known as the 13 &quot;variant&quot; characters and are:</source>
          <target state="translated">Среди наборов символьных кодов IBM EBCDIC есть 13 символов,которые часто сопоставляются с различными целочисленными значениями.Эти символы известны как 13 &quot;вариантов&quot; и являются таковыми:</target>
        </trans-unit>
        <trans-unit id="dc547e0c079def6202bb164de4204e6fef69df9c" translate="yes" xml:space="preserve">
          <source>Amongst the changes made for OS/2 are...</source>
          <target state="translated">Среди изменений,внесенных в OS/2...</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="a57b3b45aeac822e093194b4bfd981f0e59fb655" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;&quot; element in HTML.</source>
          <target state="translated">Область &quot;= over&quot; ... &quot;= back&quot;, не содержащая абзацев &quot;= item&quot; вообще, и содержащая только некоторое количество обычных / дословных абзацев, и, возможно, также несколько вложенных &quot;= over&quot; ... &quot;= back&quot; регионов, &quot;= для ...&quot; абзацев и &quot;= начало&quot; ... &quot;= конец&quot; регионов. Такая безэлементная область &quot;= over&quot; ... &quot;= back&quot; в Pod эквивалентна по значению элементу &quot;&amp;lt;blockquote&amp;gt; ... &amp;lt;/blockquote&amp;gt;&quot; в HTML.</target>
        </trans-unit>
        <trans-unit id="a1fa998f4d85fe0a03c929b0df6c0b9a9c55bdd0" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">&quot;=over&quot; ...&quot;=назад&quot;,содержащая только команды &quot;=пункт *&quot;,за каждым из которых следует некоторое количество обычных/вербатичных абзацев,другой вложенный &quot;=over&quot; ...&quot;=зад&quot; регионов,&quot;=для...&quot; параграфов,и &quot;=начать&quot;...&quot;=завершить&quot; регионов.</target>
        </trans-unit>
        <trans-unit id="f7c11a0a43a54d0c5011769a3613a3b8e32e4b7f" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">&quot;=over&quot; ...&quot;=назад&quot;,содержащая только команды &quot;=пункт [текст]&quot;,за каждой из которых (или каждой группой)следует некоторое количество обычных/вербатичных абзацев,другие вложенные &quot;=назад&quot; ...&quot;=зад&quot; регионов,или &quot;=для...&quot; параграфов,и &quot;=начало&quot;...&quot;=конечность&quot; регионов.</target>
        </trans-unit>
        <trans-unit id="bf06369b3eb3e5c957377be368c2f7244136f0a8" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">Область &quot;= поверх&quot; ... &quot;= назад&quot;, содержащая только &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; абзацев, каждый (или каждая их группа), за которыми следует некоторое количество обычные / дословные абзацы, другие вложенные &quot;= поверх&quot; ... &quot;= задние&quot; области, &quot;= для ...&quot; абзацев и / или коды &quot;= начало&quot; ... &quot;= конец&quot;. Обратите внимание, что номера должны начинаться с 1 в каждом разделе и должны идти по порядку и без пропуска цифр.</target>
        </trans-unit>
        <trans-unit id="927c2fc26d9fdc3522cb89e03e51cb9a3f52db71" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c821406e2ce644bf837234397ad75d8f26b35cf" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a</source>
          <target state="translated">&quot;Независимое&quot; подвыражение,которое соответствует подстроке,которая a</target>
        </trans-unit>
        <trans-unit id="16be1ac4526418524ec7dfd0204b1847a01b249e" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a standalone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a02e2541679357b758fec91e5c00ccb84d49cd8" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used to provide Unread() function for layers which have no buffer or cannot be bothered. (Basically this layer's &lt;code&gt;Fill()&lt;/code&gt; pops itself off the stack and so resumes reading from layer below.)</source>
          <target state="translated">&amp;laquo;Внутренняя&amp;raquo; производная от &amp;laquo;perlio&amp;raquo;, которая может использоваться для обеспечения функции Unread () для слоев, у которых нет буфера или которые не могут быть обработаны. (Обычно &lt;code&gt;Fill()&lt;/code&gt; этого слоя выскакивает из стека и возобновляет чтение со слоя ниже.)</target>
        </trans-unit>
        <trans-unit id="94f93318c67b8e306fa7a939182b6dc1a8d99788" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &lt;code&gt;*param*&lt;/code&gt; calls. (Yes, having to read the source to make sense of this is considered a known bug).</source>
          <target state="translated">&amp;laquo;Внутренний&amp;raquo; метод, который может быть изменен, в настоящее время вызывается, чтобы разрешить классу-приоритету кэшировать информацию, которая затем будет передана во все вызовы &lt;code&gt;*param*&lt;/code&gt; . (Да, необходимость читать источник, чтобы понять это, считается известной ошибкой).</target>
        </trans-unit>
        <trans-unit id="c723dc089a4e0462d0565d4c223eb6a79ebcd3aa" translate="yes" xml:space="preserve">
          <source>An $eol of &quot;&quot; (the empty string) is special. In this case, no &quot;soft line breaks&quot; are introduced and binary mode is effectively enabled so that any &quot;\n&quot; in the original data is encoded as well.</source>
          <target state="translated">$eol из &quot;&quot; (пустая строка)-специальный.В этом случае не вводятся &quot;мягкие разрывы строк&quot; и эффективно включается бинарный режим,так что любой &quot;\n&quot; в исходных данных также кодируется.</target>
        </trans-unit>
        <trans-unit id="5a6a13a346ab7340f151e0f470997f73ed378c5a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; without an argument uses the last file read. Using &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; to be examined to determine if input is available. Similarly, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; list, and if you haven't set &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt;, will read input from &lt;code&gt;STDIN&lt;/code&gt;; see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1711b8c03a9928dbbe638d8c791d95aa2c85763c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91de5a24da27e5fce41ca7887051c5441493c51" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efa71e97154f5e1c53935b4d4b0410d3433b623" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;XSUB&lt;/b&gt; forms the basic unit of the XS interface. After compilation by the &lt;b&gt;xsubpp&lt;/b&gt; compiler, each XSUB amounts to a C function definition which will provide the glue between Perl calling conventions and C calling conventions.</source>
          <target state="translated">&lt;b&gt;XSUB&lt;/b&gt; образует базовый блок интерфейса XS. После компиляции компилятором &lt;b&gt;xsubpp&lt;/b&gt; каждый XSUB представляет собой определение функции C, которое обеспечивает связь между соглашениями о вызовах Perl и соглашениями о вызовах C.</target>
        </trans-unit>
        <trans-unit id="09718e49ee8b20061f562ba9e5c34673e940b8ad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;anonymous&lt;/b&gt; subroutine that, when a reference to it is generated at runtime, keeps track of the identities of externally visible &lt;b&gt;lexical variables&lt;/b&gt;, even after those lexical variables have supposedly gone out of &lt;b&gt;scope&lt;/b&gt;. They&amp;rsquo;re called &amp;ldquo;closures&amp;rdquo; because this sort of behavior gives mathematicians a sense of closure.</source>
          <target state="translated">&lt;b&gt;Анонимная&lt;/b&gt; подпрограмма , которая, когда ссылка на него генерируются во время выполнения отслеживает тождества видимого внешние &lt;b&gt;лексических переменных&lt;/b&gt; , даже после того, как эти лексические переменные якобы вышли из &lt;b&gt;сферы&lt;/b&gt; . Их называют &amp;laquo;замыканиями&amp;raquo;, потому что такое поведение дает математикам ощущение замыкания.</target>
        </trans-unit>
        <trans-unit id="9e2f49be17e25fca915fffd9825b7a69527fa78a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer directly to the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; can change the actual arguments by changing the formal arguments. That is, the formal argument is an &lt;b&gt;alias&lt;/b&gt; for the actual argument. See also &lt;b&gt;call by value&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Аргумент&lt;/b&gt; -passing механизм , в котором &lt;b&gt;формальные аргументах&lt;/b&gt; относятся непосредственно к &lt;b&gt;фактическим аргументам&lt;/b&gt; , и &lt;b&gt;подпрограмма&lt;/b&gt; может изменить фактические аргументы путем изменения формальных аргументов. То есть формальный аргумент является &lt;b&gt;псевдонимом&lt;/b&gt; фактического аргумента. См. Также &lt;b&gt;вызов по значению&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="4e9ca74e5eb3ceca0031d5a290a9926f188e9f44" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer to a copy of the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; cannot change the actual arguments by changing the formal arguments. See also &lt;b&gt;call by reference&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Аргумент&lt;/b&gt; -passing механизм , в котором &lt;b&gt;формальные аргументы&lt;/b&gt; относятся к копии &lt;b&gt;фактических аргументов&lt;/b&gt; , а &lt;b&gt;подпрограмма&lt;/b&gt; не может изменить фактические аргументы путем изменения формальных аргументов. Смотрите также &lt;b&gt;звонок по ссылке&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="3ae7537da81b89a37f1fba19db52f45ea5a64265" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the left of the current match location.</source>
          <target state="translated">&lt;b&gt;Утверждение&lt;/b&gt; , что заглядывает в строке слева от текущего местоположения матча.</target>
        </trans-unit>
        <trans-unit id="9186a718ac3c2fd4c0066859c2036b1188f86bf7" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the right of the current match location.</source>
          <target state="translated">&lt;b&gt;Утверждающее&lt;/b&gt; , что заглядывает в строке справа от текущего местоположения матча.</target>
        </trans-unit>
        <trans-unit id="fccd6c0eca3ee2fd48a0479b2f7467ef677a981b" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that states something exists and perhaps describes what it&amp;rsquo;s like, without giving any commitment as to how or where you&amp;rsquo;ll use it. A declaration is like the part of your recipe that says, &amp;ldquo;two cups flour, one large egg, four or five tadpoles&amp;hellip;&amp;rdquo; See &lt;b&gt;statement&lt;/b&gt; for its opposite. Note that some declarations also function as statements. Subroutine declarations also act as definitions if a body is supplied.</source>
          <target state="translated">&lt;b&gt;Утверждение&lt;/b&gt; , что государства что - то существует , и , возможно , описывает то , что это походит, не давая каких - либо обязательств относительно того , как и где вы будете его использовать. Декларация похожа на часть вашего рецепта, в которой говорится: &amp;laquo;два стакана муки, одно большое яйцо, четыре или пять головастиков&amp;hellip;&amp;raquo; См. &lt;b&gt;Утверждение&lt;/b&gt; для его противоположности. Обратите внимание, что некоторые объявления также работают как операторы. Объявления подпрограмм также действуют как определения, если предоставляется тело.</target>
        </trans-unit>
        <trans-unit id="a79df62ffe9655f3bb9b573a11129a38c97d9727" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;attribute&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;; data stored with the particular object rather than with the class as a whole.</source>
          <target state="translated">&lt;b&gt;Атрибут&lt;/b&gt; из &lt;b&gt;объекта&lt;/b&gt; ; данные, хранящиеся с конкретным объектом, а не с классом в целом.</target>
        </trans-unit>
        <trans-unit id="6b5c38c6212536b2650f8fd4b5e6e9c46fa7ac78" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that evaluates to something that can be used as a &lt;b&gt;filehandle&lt;/b&gt;: a &lt;b&gt;string&lt;/b&gt; (filehandle name), a &lt;b&gt;typeglob&lt;/b&gt;, a typeglob &lt;b&gt;reference&lt;/b&gt;, or a low-level &lt;b&gt;IO&lt;/b&gt; object.</source>
          <target state="translated">&lt;b&gt;Выражение&lt;/b&gt; , которое вычисляется в чем - то , что может быть использована в качестве &lt;b&gt;дескриптора файла&lt;/b&gt; : в &lt;b&gt;строке&lt;/b&gt; (указатель_на_файл имя), &lt;b&gt;типа - глоб&lt;/b&gt; , в типе - глобу &lt;b&gt;ссылки&lt;/b&gt; , или низкий уровень &lt;b&gt;IO&lt;/b&gt; объекта.</target>
        </trans-unit>
        <trans-unit id="a9ea33da0846dba2dfc2c719e640a6b936943a76" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that yields a &lt;b&gt;value&lt;/b&gt; that an &lt;b&gt;operator&lt;/b&gt; operates on. See also &lt;b&gt;precedence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Выражение&lt;/b&gt; , что дает &lt;b&gt;значение&lt;/b&gt; , что &lt;b&gt;оператор&lt;/b&gt; работает на. См. Также &lt;b&gt;приоритет&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6a827ebadd37467385c749c36afe5cfe5a720e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;increment&lt;/b&gt; operator that knows how to bump up ASCII alphabetics as well as numbers.</source>
          <target state="translated">&lt;b&gt;Прибавка&lt;/b&gt; оператор , который знает , как поднять до ASCII alphabetics, а также номера.</target>
        </trans-unit>
        <trans-unit id="6e6a46de7223236ab22a0ae8657b922fe424257e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;instance&lt;/b&gt; of a &lt;b&gt;class&lt;/b&gt;. Something that &amp;ldquo;knows&amp;rdquo; what user-defined type (class) it is, and what it can do because of what class it is. Your program can request an object to do things, but the object gets to decide whether it wants to do them or not. Some objects are more accommodating than others.</source>
          <target state="translated">&lt;b&gt;Экземпляр&lt;/b&gt; из &lt;b&gt;класса&lt;/b&gt; . Что-то, что &amp;laquo;знает&amp;raquo;, что это за определяемый пользователем тип (класс) и что он может делать в зависимости от того, к какому классу он относится. Ваша программа может запрашивать у объекта какие-то действия, но объект решает, хочет он это делать или нет. Некоторые объекты более удобны, чем другие.</target>
        </trans-unit>
        <trans-unit id="193974eee4df69740e47a6c9868c573734e793d8" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;object&lt;/b&gt; is a data structure that bundles together data and subroutines which operate on that data. An object's data is called &lt;b&gt;attributes&lt;/b&gt;, and its subroutines are called &lt;b&gt;methods&lt;/b&gt;. An object can be thought of as a noun (a person, a web service, a computer).</source>
          <target state="translated">&lt;b&gt;Объект&lt;/b&gt; представляет собой структуру данных , которая связывает воедино данные и подпрограммы , которые работают над этими данными. Данные объекта называются &lt;b&gt;атрибутами&lt;/b&gt; , а его подпрограммы - &lt;b&gt;методами&lt;/b&gt; . Объект можно рассматривать как существительное (человек, веб-сервис, компьютер).</target>
        </trans-unit>
        <trans-unit id="9f3264403f458576129fd753f7da0132d1126157" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; X&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;,
such as the output-grabbing operator, &amp;lt;literal
moreinfo=&quot;none&quot;&lt;/code&gt;`&amp;gt;</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; X , &lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;, such as the output-grabbing operator, &amp;lt;literal moreinfo=&quot;none&quot;&lt;/code&gt; `&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e3876b6031a7c1f940174f56c5f7362a7f615429" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;trinary&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; принимает три &lt;b&gt;операнда&lt;/b&gt; . Иногда произносится как &lt;b&gt;тройной&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="209f1fbbc9e85cade5ad6da705d3c26984c35559" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; , который приходит между его &lt;b&gt;операндами&lt;/b&gt; , такие как умножение в &lt;code&gt;24 * 7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f71291b7c0cc8bd6ef4195e1d392449e6f1d53" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463ba99d535672eaf8355ca19021da8d2cf33452" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; , который делает что - то со списком значений, например, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; . Обычно используется для именованных встроенных операторов (таких как &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ), которые не требуют заключения в скобки списка &lt;b&gt;аргументов&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="74d9d7e2bcff5578ed582b2be81c1fd95c4fc9ac" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;join&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, and &lt;code&gt;system&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2a4670adc782be015d0bb2ea5ffee02ea42397" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; , который следует за своим &lt;b&gt;операндом&lt;/b&gt; , как в &lt;code&gt;$x++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2a91b007dceec65feca65e72cf86b169ecd0ff6" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7f1151c5c90e6fb1284f5e0bc779ad8ed2e33c" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; , который предшествует его &lt;b&gt;операнд&lt;/b&gt; , как в &lt;code&gt;++$x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a25f284ffc65045a6c69870223421c5797a335e9" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabe188f0a1b9c27289c477dd8047df3b523cb5a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that says whether a particular ordering relationship is &lt;b&gt;true&lt;/b&gt; about a pair of &lt;b&gt;operands&lt;/b&gt;. Perl has both numeric and string relational operators. See &lt;b&gt;collating sequence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; , который говорит , является ли особые отношения упорядочения &lt;b&gt;верно&lt;/b&gt; о паре &lt;b&gt;операндов&lt;/b&gt; . Perl имеет как числовые, так и строковые операторы отношения. См. &lt;b&gt;Последовательность сортировки&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="717a4af81f7132fc96e1d23c981f1ff3401e5290" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that surrounds its &lt;b&gt;operand&lt;/b&gt;, like the angle operator, or parentheses, or a hug.</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; , который окружает его &lt;b&gt;операнд&lt;/b&gt; , как оператор угла, или круглые скобки, или объятие.</target>
        </trans-unit>
        <trans-unit id="355f7096b65520d72731600341dac924b0bb6aad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that takes two &lt;b&gt;operands&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; , который принимает два &lt;b&gt;операнда&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b7885e2c7085b9ecc7bc4fd21946e64edd22e910" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; whose assigned mission in life is to change the value of a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Оператор&lt;/b&gt; которого назначена миссия в жизни, чтобы изменить значение &lt;b&gt;переменной&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3959ebca99af56cd591ab2c731b4edab6ffa5f" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</source>
          <target state="translated">&lt;b&gt;Обычный пункт&lt;/b&gt; . Абзац считается обычным абзацем, если его первая строка не соответствует ни &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; ни &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8dd7686cbc9fa2ea98c8a7eb1004bca8a6b2e068" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98f8de412a14cfe117cc1f33fdf08a188a327cd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; без аргумента использует последний файл для чтения. Использование &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; с пустыми скобками отличается. Он относится к псевдофайлу, сформированному из файлов, перечисленных в командной строке и доступ к которому осуществляется с помощью оператора &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Поскольку &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; не открывается явно, как обычный дескриптор файла, использование &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; перед &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; вызовет &lt;code&gt;@ARGV&lt;/code&gt; , чтобы определить, доступен ли ввод. Точно так же &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; после того, как &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; вернет конец файла, будет предполагать, что вы обрабатываете другой список &lt;code&gt;@ARGV&lt;/code&gt; , и, если вы не установили &lt;code&gt;@ARGV&lt;/code&gt; , будет читать ввод из &lt;code&gt;STDIN&lt;/code&gt; ; см. &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;Операторы ввода-вывода в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b538c9784366b2a5b380fc1646cd6d2c36676cbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; выполняется в подпрограмме , определенной в &lt;code&gt;DB&lt;/code&gt; пакета не видит обычный окружающий лексическую область, а объем первого не Д.Б. кусок кода , который назвал его. Обычно вам не нужно беспокоиться об этом, если вы не пишете отладчик Perl.</target>
        </trans-unit>
        <trans-unit id="9638cc264773db141fdbff9966aa75b61a42b264" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; без аргумента использует последний файл для чтения. Использование &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; с пустыми скобками отличается. Он относится к псевдофайлу, сформированному из файлов, перечисленных в командной строке и доступ к которому осуществляется с помощью оператора &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Поскольку &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; не открывается явно, как обычный дескриптор файла, использование &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; перед &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; вызовет &lt;code&gt;@ARGV&lt;/code&gt; , чтобы определить, доступен ли ввод. Точно так же &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; после того, как &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; вернет конец файла, будет предполагать, что вы обрабатываете другой список &lt;code&gt;@ARGV&lt;/code&gt; , и, если вы не установили &lt;code&gt;@ARGV&lt;/code&gt; , будет читать ввод из &lt;code&gt;STDIN&lt;/code&gt; ; см. &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;Операторы ввода-вывода в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f39d8054296556b4b922794a4d5a34f617f1fc94" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">Однако &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; может видеть лексические переменные области видимости, в которой она оценивается, если имена не скрыты объявлениями внутри самой &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;perlref&quot;&gt;Perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6342bae4fda60017077e5c45e326240a9752de8d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; выполняется в подпрограмме , определенной в &lt;code&gt;DB&lt;/code&gt; пакета не видит обычный окружающий лексическую область, а объем первого не Д.Б. кусок кода , который назвал его. Обычно вам не нужно беспокоиться об этом, если вы не пишете отладчик Perl.</target>
        </trans-unit>
        <trans-unit id="e98b3b90e3045dc3b637b5a6dd09b73503e89407" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; декларация объявляет псевдоним для переменного пакета , который будет виден во всей своей лексической области видимости, даже через границу пакета. Пакет, в который вводится переменная, определяется в момент объявления, а не в момент использования. Это означает следующее поведение:</target>
        </trans-unit>
        <trans-unit id="b85b4821ea02e10c76868c61d73ce67c03c3c58f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; заявление может также иметь список атрибутов , связанных с ним.</target>
        </trans-unit>
        <trans-unit id="0e6a38b5837351a0fa7ad12169129c95c04803d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; декларация объявляет псевдоним для переменного пакета , который будет виден во всей своей лексической области видимости, даже через границу пакета. Пакет, в который вводится переменная, определяется в момент объявления, а не в момент использования. Это означает следующее поведение:</target>
        </trans-unit>
        <trans-unit id="ff67756e1b83b8c246879fd06b2405feac998276" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; заявление может также иметь список атрибутов , связанных с ним.</target>
        </trans-unit>
        <trans-unit id="09f284e34c7193100513bdbf0c748168a131c400" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">Команда &lt;code&gt;=item&lt;/code&gt; или &lt;code&gt;=back&lt;/code&gt; была обнаружена вне блока &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74ddbf837617e690734ce4e331574925980ad4cf" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cb1e02933a96ffc4b888e742e11e5e2a0810c8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">Блок кода &lt;code&gt;END&lt;/code&gt; выполняется как можно позже, то есть после того, как perl завершил выполнение программы и непосредственно перед выходом из интерпретатора, даже если он завершился в результате функции die (). (Но не в том случае, если он трансформируется в другую программу через &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; или вылетает из воды сигналом - вы должны поймать это самостоятельно (если можете).) У вас может быть несколько блоков &lt;code&gt;END&lt;/code&gt; в файле - они будут выполнить в порядке, обратном определению; то есть: последний пришел, первый ушел (LIFO). Блоки &lt;code&gt;END&lt;/code&gt; не выполняются, когда вы запускаете perl с ключом &lt;code&gt;-c&lt;/code&gt; или если компиляция не выполняется.</target>
        </trans-unit>
        <trans-unit id="e942cc0968d145d9b00a1b1c78467e33e46acc43" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;exec&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e32fa7ec52528fa53daf789a891351a0047191f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2106dcfb583dc95f2d7d0a7530b5308a6cea8ccd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IO::Handle&lt;/code&gt; object is a reference to a symbol/GLOB reference (see the &lt;code&gt;Symbol&lt;/code&gt; package). Some modules that inherit from &lt;code&gt;IO::Handle&lt;/code&gt; may want to keep object related variables in the hash table part of the GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module should prefix its variables with its own name separated by _'s. For example the IO::Socket module keeps a &lt;code&gt;timeout&lt;/code&gt; variable in 'io_socket_timeout'.</source>
          <target state="translated">Объект &lt;code&gt;IO::Handle&lt;/code&gt; - это ссылка на символ / ссылку GLOB (см. Пакет &lt;code&gt;Symbol&lt;/code&gt; ). Некоторые модули, унаследованные от &lt;code&gt;IO::Handle&lt;/code&gt; могут захотеть сохранить связанные с объектами переменные в части хэш-таблицы GLOB. Пытаясь предотвратить взаимное наложение модулей друг на друга, я предлагаю, чтобы любой такой модуль префикс своих переменных имел собственное имя, разделенное знаком _. Например, модуль IO :: Socket хранит переменную &lt;code&gt;timeout&lt;/code&gt; в io_socket_timeout.</target>
        </trans-unit>
        <trans-unit id="ddbf17a10e023000ccc30961ca5b0d4cd79dd73a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf77a66a50c9398b1fd7246b531ff3583302d3a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval()&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;eval()&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4327b0847cdc34977cdbdda7e68546f97fba6ace" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;https&lt;/code&gt; connection may be made via an &lt;code&gt;http&lt;/code&gt; proxy that supports the CONNECT command (i.e. RFC 2817). You may not proxy &lt;code&gt;https&lt;/code&gt; via a proxy that itself requires &lt;code&gt;https&lt;/code&gt; to communicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7b8e2c63742b11c42dcae1ac500eab80f3ab56" translate="yes" xml:space="preserve">
          <source>An Array Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4bdf476b3365f09a887c13f6c40076ebfaf6c1" translate="yes" xml:space="preserve">
          <source>An Aside About Smarter and Safer Code</source>
          <target state="translated">Дополнительная информация об &quot;Умном и безопасном коде&quot;.</target>
        </trans-unit>
        <trans-unit id="3b01e7833f6ef8368a6a19aec43504160373e004" translate="yes" xml:space="preserve">
          <source>An E&amp;lt;...&amp;gt; surrounding strange content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e626c65821f55eedc24b3d056f760901055b33ab" translate="yes" xml:space="preserve">
          <source>An Error Handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96ae95b9e6d2684c36b739e4e16b84332bd4be3" translate="yes" xml:space="preserve">
          <source>An Event-Driven Program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd29613666219a97f2491f0610be4945ceed298" translate="yes" xml:space="preserve">
          <source>An Example</source>
          <target state="translated">Пример</target>
        </trans-unit>
        <trans-unit id="f8c1ce33e34656d389a163577db68ecf2ef0ded0" translate="yes" xml:space="preserve">
          <source>An Example -- the NULL termination problem.</source>
          <target state="translated">Пример --проблема NULL-окончания.</target>
        </trans-unit>
        <trans-unit id="b0338e71cce0b4ccb879ecd4b7099e83ebe3be92" translate="yes" xml:space="preserve">
          <source>An Example: the NULL termination problem.</source>
          <target state="translated">Пример:проблема NULL-окончания.</target>
        </trans-unit>
        <trans-unit id="8c00947f1047eee3af23c94728ed5ad710d9cb2f" translate="yes" xml:space="preserve">
          <source>An INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:</source>
          <target state="translated">В комплект поставки должен входить файл INSTALL,который должен содержать простые инструкции по установке.При использовании ExtUtils::MakeMaker это обычно так и будет:</target>
        </trans-unit>
        <trans-unit id="506b7c2a6739d4b086313431ab2d8807d26d26ea" translate="yes" xml:space="preserve">
          <source>An Input FileGlob string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d4eb0ecab7adc479ea3b6eef3a6aca32ccbec3" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to place the read data at some place in the string other than the beginning. A negative OFFSET specifies placement at that many characters counting backwards from the end of the string. A positive OFFSET greater than the length of SCALAR results in the string being padded to the required size with &lt;code&gt;&quot;\0&quot;&lt;/code&gt; bytes before the result of the read is appended.</source>
          <target state="translated">СМЕЩЕНИЕ может быть указано для помещения считанных данных в какое-либо место в строке, кроме начала. Отрицательное СМЕЩЕНИЕ указывает размещение такого количества символов, считая в обратном порядке от конца строки. Положительное значение OFFSET, превышающее длину SCALAR, приводит к тому, что строка дополняется до требуемого размера байтами &lt;code&gt;&quot;\0&quot;&lt;/code&gt; перед добавлением результата чтения.</target>
        </trans-unit>
        <trans-unit id="0dc3cbd84029f4f613840045b9422510efa87d84" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to write the data from some part of the string other than the beginning. A negative OFFSET specifies writing that many characters counting backwards from the end of the string. If SCALAR is of length zero, you can only use an OFFSET of 0.</source>
          <target state="translated">Для записи данных из какой-то части строки,отличной от начала,может быть задан OFFSET.Отрицательный OFFSET указывает на запись,при которой многие символы отсчитываются от конца строки.Если SCALAR имеет нулевую длину,можно использовать только OFFSET,равный 0.</target>
        </trans-unit>
        <trans-unit id="bd9383fdee820dfd7a79259db8339a2ec8fb85d9" translate="yes" xml:space="preserve">
          <source>An Object is Simply a Data Structure</source>
          <target state="translated">Объект-это просто структура данных.</target>
        </trans-unit>
        <trans-unit id="a75b7e5900f9f9a5e2336a6194fd54179bb27c7e" translate="yes" xml:space="preserve">
          <source>An Output FileGlob</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813d4e6c344e0e779c908b93f3b8922ba5b51b2f" translate="yes" xml:space="preserve">
          <source>An RDF vocabulary to describe software projects. &lt;a href=&quot;http://usefulinc.com/doap&quot;&gt;http://usefulinc.com/doap&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2be5f7e627a6ada01e5f83f900c749a12504c5b" translate="yes" xml:space="preserve">
          <source>An RPN expression can also be interpreted in another way, as a sequence of operations on a stack, one operation per token. A literal or variable token pushes a value onto the stack. A binary operator pulls two items off the stack, performs a calculation with them, and pushes the result back onto the stack. The stack starts out empty, and at the end of the expression there must be exactly one value left on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451423395ae3ecccc772428a72078e3af59aea77" translate="yes" xml:space="preserve">
          <source>An RPN expression may be any of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69ceb552111cae999e0e9d8f79c888a4e18b2ab" translate="yes" xml:space="preserve">
          <source>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</source>
          <target state="translated">SV (или AV,HV и т.д.)выделяется в две части:головка (struct sv,av,hv...)содержит информацию о типе и количестве ссылок,а для многих типов-указатель на тело (struct xrv,xpv,xpviv...),который содержит поля,специфичные для каждого типа.Некоторые типы хранят в голове все,что им нужно,поэтому у них нет тела.</target>
        </trans-unit>
        <trans-unit id="0db48295b7cb634bd39479ea9baf6751db33420c" translate="yes" xml:space="preserve">
          <source>An SV can be created and loaded with one command. There are five types of values that can be loaded: an integer value (IV), an unsigned integer value (UV), a double (NV), a string (PV), and another scalar (SV). (&quot;PV&quot; stands for &quot;Pointer Value&quot;. You might think that it is misnamed because it is described as pointing only to strings. However, it is possible to have it point to other things. For example, it could point to an array of UVs. But, using it for non-strings requires care, as the underlying assumption of much of the internals is that PVs are just for strings. Often, for example, a trailing &lt;code&gt;NUL&lt;/code&gt; is tacked on automatically. The non-string use is documented only in this paragraph.)</source>
          <target state="translated">SV можно создать и загрузить с помощью одной команды. Есть пять типов значений, которые могут быть загружены: целочисленное значение (IV), целое число без знака (UV), двойное значение (NV), строка (PV) и еще один скаляр (SV). (&amp;laquo;PV&amp;raquo; означает &amp;laquo;значение указателя&amp;raquo;. Вы можете подумать, что он неправильно назван, потому что описывается как указывающий только на строки. Однако он может указывать на другие объекты. Например, он может указывать на массив UV-разверток. Но его использование для нестроковых элементов требует осторожности, поскольку основное предположение многих внутренних компонентов состоит в том, что PV предназначены только для строк. Часто, например, завершающий &lt;code&gt;NUL&lt;/code&gt; добавляется автоматически. задокументировано только в этом абзаце.)</target>
        </trans-unit>
        <trans-unit id="e49daf61f2f4bab338dc0435e2098c4740ae32f6" translate="yes" xml:space="preserve">
          <source>An SV may be passed as a second argument. If so, the name will be assigned to it and it will be returned. Otherwise the returned SV will be a new mortal.</source>
          <target state="translated">SV может быть передан в качестве второго аргумента.Если это так,то ему будет присвоено имя,и оно будет возвращено.В противном случае возвращаемое SV будет новым смертным.</target>
        </trans-unit>
        <trans-unit id="7e60a0da99f77ec00184644cb08929c2fbb88e98" translate="yes" xml:space="preserve">
          <source>An URL for a bug tracker (e.g. Bugzilla or RT queue) for this project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb53ac6b527ff22855aa21b588aeb5e456de693" translate="yes" xml:space="preserve">
          <source>An URL for an official statement of this distribution's license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d6fdbeeb22295aa04aac68ad9fd7f77cf9046a" translate="yes" xml:space="preserve">
          <source>An XS module that is locale-dependent could have been written under the assumption that it will never be called in a multi-threaded environment, and so uses other non-locale constructs that aren't multi-thread-safe. See &lt;a href=&quot;perlxs#Thread-aware-system-interfaces&quot;&gt;&quot;Thread-aware system interfaces&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a93457850bdbb33ca102c024544fcdc99dd999" translate="yes" xml:space="preserve">
          <source>An XSUB section continues until another section-start keyword is found.</source>
          <target state="translated">Раздел XSUB продолжается до тех пор,пока не будет найдено другое ключевое слово,начинающееся с раздела.</target>
        </trans-unit>
        <trans-unit id="db98408a971f988d838aae97c21a88cbfeff498b" translate="yes" xml:space="preserve">
          <source>An abstract character&amp;rsquo;s integer value. Same thing as &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">Целочисленное значение абстрактного символа. То же, что и &lt;b&gt;код&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bd8526c4f7f2f82dc46961c40bfa270781cafa7e" translate="yes" xml:space="preserve">
          <source>An accessor function can be redefined in order to provide additional checking of values, etc. Here, we want the &lt;code&gt;count&lt;/code&gt; element always to be nonnegative, so we redefine the &lt;code&gt;count&lt;/code&gt; accessor accordingly.</source>
          <target state="translated">Функция доступа может быть переопределена, чтобы обеспечить дополнительную проверку значений и т. Д. Здесь мы хотим, чтобы элемент &lt;code&gt;count&lt;/code&gt; всегда был неотрицательным, поэтому мы соответствующим образом переопределяем &lt;code&gt;count&lt;/code&gt; доступа count .</target>
        </trans-unit>
        <trans-unit id="76864d299088548272113a8d31dd2510d163d674" translate="yes" xml:space="preserve">
          <source>An accessor lets you add additional code around attribute access. For example, you could apply a default to an attribute that wasn't set in the constructor, or you could validate that a new value for the attribute is acceptable.</source>
          <target state="translated">Аксессуар позволяет добавлять дополнительный код вокруг доступа к атрибутам.Например,Вы можете применить значение по умолчанию к атрибуту,который не был установлен в конструкторе,или Вы можете проверить,что новое значение для атрибута допустимо.</target>
        </trans-unit>
        <trans-unit id="7f7dfcb0e79b76d6607a032d4c42004b6d846b72" translate="yes" xml:space="preserve">
          <source>An action that terminates a process will terminate</source>
          <target state="translated">Действие,которое завершает процесс,прекращает</target>
        </trans-unit>
        <trans-unit id="3d55486b7ae618b0c9e5822b88065546dbd8b09b" translate="yes" xml:space="preserve">
          <source>An actual piece of data, in contrast to all the variables, references, keys, indices, operators, and whatnot that you need to access the value.</source>
          <target state="translated">Фактическая часть данных,в отличие от всех переменных,ссылок,ключей,индексов,операторов и всего остального,что нужно для доступа к значению.</target>
        </trans-unit>
        <trans-unit id="1e18a14c7435e1ad99b33d06cb67211ccd6f13ff" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Псевдофункция прилагательного, которая декларативно искажает значение &lt;b&gt;lvalue&lt;/b&gt; . В настоящее время существует три модификатора lvalue: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147929b2af4f7b23dfdf17e155cb639bdee82ce1" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, and &lt;code&gt;local&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450e105909f5464a91b8d711013a548cdad0ecea" translate="yes" xml:space="preserve">
          <source>An algorithm to map a character set to a byte sequence. You don't have to be able to tell which character set a given byte sequence belongs. 7-bit ISO-2022 is a CES but it cannot be a CCS. EUC is an example of being both a CCS and CES.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddce428631d662b65df938a0ab59dc6d26df5c3" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">Псевдоним может отображаться либо на официальное имя символа Unicode (не с произвольным совпадением имени), либо на числовую кодовую точку (порядковый номер). Последнее полезно для присвоения имен кодовым точкам в областях частного использования Unicode, таких как U + E800 - U + F8FF. Числовой код должен быть неотрицательным целым числом или строкой, начинающейся с &lt;code&gt;&quot;U+&quot;&lt;/code&gt; или &lt;code&gt;&quot;0x&quot;&lt;/code&gt; а остаток считается шестнадцатеричным целым числом. Литеральная числовая константа должна быть беззнаковой; он будет интерпретироваться как шестнадцатеричный, если в начале стоит ноль или содержит не десятичные шестнадцатеричные цифры; в противном случае он будет интерпретирован как десятичный. Если он начинается с &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , он интерпретируется как кодовая точка Unicode; в противном случае он интерпретируется как родной. (Только кодовые точки ниже 256 могут отличаться между Unicode и native.) Таким образом &lt;code&gt;U+41&lt;/code&gt; - это всегда латинская буква &amp;laquo;А&amp;raquo;; но &lt;code&gt;0x41&lt;/code&gt; может быть &quot; ПРОБЕЛОМ БЕЗ ПЕРЕРЫВА &quot; на платформах EBCDIC.</target>
        </trans-unit>
        <trans-unit id="307b5df586934d78ce8b5dabe9ab9b8c2f875563" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt;, it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346eaad655197a010139149e8271c64c649a891" translate="yes" xml:space="preserve">
          <source>An alias for fullname</source>
          <target state="translated">Псевдоним для полного имени</target>
        </trans-unit>
        <trans-unit id="7fe1e0c1ce121b1e661962490b3a8d17f0df008e" translate="yes" xml:space="preserve">
          <source>An alias for hostfqdn ().</source>
          <target state="translated">Псевдоним Hostfqdn ().</target>
        </trans-unit>
        <trans-unit id="0f9c5134c84e70c19466ac6665667bdc11f335df" translate="yes" xml:space="preserve">
          <source>An alphanumeric name preceded by dollar sign refers to a Perl scalar variable. Only variables declared with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; are supported. If the variable's value is not a native integer, it will be converted to an integer, by Perl's usual mechanisms, at the time it is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa449dd40ff0246bd3a833083086ff6fe9ea989c" translate="yes" xml:space="preserve">
          <source>An alternate (and possibly simpler) method to pushing values on the stack is to use the macro:</source>
          <target state="translated">Альтернативным (и,возможно,более простым)методом выталкивания значений в стеке является использование макроса:</target>
        </trans-unit>
        <trans-unit id="1921a2093ccc86489ce0ad3cb2bb5dbbb1b5fcf0" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;a href=&quot;#-Fpattern&quot;&gt;-F&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490e5f218f41d502acc0f80b9b4c03244664bdb6" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">Альтернативный разделитель может быть указан с помощью &lt;b&gt;-F&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a3cee96423e82840fff05ec16e3bc4bd5558bd28" translate="yes" xml:space="preserve">
          <source>An alternate filename that points to the real &lt;b&gt;filename&lt;/b&gt;, which in turn points to the real &lt;b&gt;file&lt;/b&gt;. Whenever the &lt;b&gt;operating system&lt;/b&gt; is trying to parse a &lt;b&gt;pathname&lt;/b&gt; containing a symbolic link, it merely substitutes the new name and continues parsing.</source>
          <target state="translated">Альтернативное имя файла, указывающее на настоящее &lt;b&gt;имя файла&lt;/b&gt; , которое, в свою очередь, указывает на настоящий &lt;b&gt;файл&lt;/b&gt; . Всякий раз, когда &lt;b&gt;операционная система&lt;/b&gt; пытается проанализировать &lt;b&gt;путь,&lt;/b&gt; содержащий символическую ссылку, она просто подставляет новое имя и продолжает синтаксический анализ.</target>
        </trans-unit>
        <trans-unit id="567849086db2a3773d0ebaa265c330619cbbb371" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;../simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Теперь доступен альтернативный интерфейс для Filter :: Util :: Call. Смотрите &lt;a href=&quot;../simple&quot;&gt;Filter :: Simple&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="309e6a9857cb37095aa6e70561b74ca78f25b7d4" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;Filter::Simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c89b199090d1d97e837c8f064d662931bf60c5" translate="yes" xml:space="preserve">
          <source>An alternate way to create a new version object is through the exported qv() sub. This is not strictly like other q? operators (like qq, qw), in that the only delimiters supported are parentheses (or spaces). It is the best way to initialize a short version without triggering the floating point interpretation. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675501f93d17028172930c214a15945683c8e504" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt; .</source>
          <target state="translated">Альтернативный подход к &lt;code&gt;Memoize&lt;/code&gt; кеша - использовать параметр &lt;code&gt;HASH&lt;/code&gt; (см. Выше), чтобы запросить, чтобы Memoize использовал конкретную хеш-переменную в качестве своего кеша. Затем вы можете проверить или изменить хеш в любое время любым способом. Вы можете очистить кеш с помощью &lt;code&gt;%hash = ()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8b6136f62918ff1ea1ed138ea0c96c6d31fc586" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fe156c5b22968eab0fbdde266b1268db8760ef" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">Альтернативой является CamelBones, фреймворк, который обеспечивает доступ как к классам и объектам Foundation, так и к AppKit, так что полноценные приложения с графическим интерфейсом пользователя могут быть созданы на Perl. CamelBones можно найти на SourceForge по адресу &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b9956d0c6aedc296243c0a951b58bd48cc08ba5" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;https://www.sourceforge.net/projects/camelbones/&quot;&gt;https://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf70c06c68960fa2b5ce48b474675e096b9430d" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">Альтернативный метод отладки регулярных выражений - встраивание операторов &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; в регулярное выражение. Это дает подробный отчет об откате в чередовании:</target>
        </trans-unit>
        <trans-unit id="d38adacc9748189f199af8dc89eab5c14ea53178" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;print&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="797f91185d7afbacb2d3c5eed6df4adbd22d2a7d" translate="yes" xml:space="preserve">
          <source>An alternative reference is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577bb949a7cbee63183e379cdce8743144bb2e97" translate="yes" xml:space="preserve">
          <source>An alternative to using &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf78a032596f44477dfca0392a1f37e462bfc42f" translate="yes" xml:space="preserve">
          <source>An alternative to using substr() as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with splice().</source>
          <target state="translated">Альтернативой использованию функции substr()в качестве значения l является указание строки замены в качестве 4-го аргумента.Это позволяет заменить части EXPR и вернуть то,что было раньше,за одну операцию,точно так же,как вы можете это сделать с помощью функции splice().</target>
        </trans-unit>
        <trans-unit id="25b5286961be13762e984cfd1189ea7a9bb06d7a" translate="yes" xml:space="preserve">
          <source>An alternative to writing the filter in C is to create a separate executable in the language of your choice. The separate executable reads from standard input, does whatever processing is necessary, and writes the filtered data to standard output. &lt;code&gt;Filter::cpp&lt;/code&gt; is an example of a source filter implemented as a separate executable - the executable is the C preprocessor bundled with your C compiler.</source>
          <target state="translated">Альтернативой написанию фильтра на C является создание отдельного исполняемого файла на выбранном вами языке. Отдельный исполняемый файл читает из стандартного ввода, выполняет необходимую обработку и записывает отфильтрованные данные в стандартный вывод. &lt;code&gt;Filter::cpp&lt;/code&gt; - это пример исходного фильтра, реализованного как отдельный исполняемый файл - исполняемый файл - это препроцессор C, связанный с вашим компилятором C.</target>
        </trans-unit>
        <trans-unit id="9216315bb2214d5ed94f6db6fec42532477a8283" translate="yes" xml:space="preserve">
          <source>An alternative way of writing something more easily; a shortcut.</source>
          <target state="translated">Альтернативный способ написания чего-нибудь более простого-короткий путь.</target>
        </trans-unit>
        <trans-unit id="d69bfaa7d98ebed8954a924a638458e2ecf0b867" translate="yes" xml:space="preserve">
          <source>An alternative way to achieve this can be seen in &lt;a href=&quot;Gtk2::CodeGen&quot;&gt;Gtk2::CodeGen&lt;/a&gt; and &lt;a href=&quot;Glib::CodeGen&quot;&gt;Glib::CodeGen&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3719242868ba601b24b2c4019225372b6d1ba5a6" translate="yes" xml:space="preserve">
          <source>An alternatively is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ef70866e892e0391f54f3f0e595fde0691ccb0" translate="yes" xml:space="preserve">
          <source>An anchor useful in basic regexps is the</source>
          <target state="translated">Якорь,полезный для основных регэкспрессов,это</target>
        </trans-unit>
        <trans-unit id="a941741e26d01bf48e71deca7cfe67d745df0d18" translate="yes" xml:space="preserve">
          <source>An anonymous array of alternative library specifications to be searched for (in order) until at least one library is found. E.g.</source>
          <target state="translated">Анонимный массив спецификаций альтернативных библиотек для поиска (по порядку)до тех пор,пока не будет найдена хотя бы одна библиотека.например</target>
        </trans-unit>
        <trans-unit id="c253698bf9e4f75c2b5d0a18558b851f2d3f6b5e" translate="yes" xml:space="preserve">
          <source>An application that takes the trouble to use information in &lt;code&gt;LC_MONETARY&lt;/code&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in US dollars instead of Hong Kong dollars.</source>
          <target state="translated">Приложение, которое пытается использовать информацию в &lt;code&gt;LC_MONETARY&lt;/code&gt; , может форматировать дебеты, как если бы они были кредитами, и наоборот, если эта локаль была нарушена. Или он может производить платежи в долларах США вместо гонконгских долларов.</target>
        </trans-unit>
        <trans-unit id="01ac9da7b76fdd816e4e95bf07e705af326d0f2c" translate="yes" xml:space="preserve">
          <source>An application using Module can say something like:</source>
          <target state="translated">Приложение,использующее Module,может сказать что-то вроде:</target>
        </trans-unit>
        <trans-unit id="a335ab967a8e1f5c521e6fbf8a762d039a0699ab" translate="yes" xml:space="preserve">
          <source>An archaic expression for what is more correctly referred to as &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">Архаичное выражение того, что более правильно называть &lt;b&gt;контекстом списка&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd0ff3c6abfb69f462a62c5017ae088c797d806" translate="yes" xml:space="preserve">
          <source>An argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare &lt;code&gt;$&lt;/code&gt; sigil. For example,</source>
          <target state="translated">Аргумент можно игнорировать, опустив основную часть имени в объявлении параметра, оставив только символ &lt;code&gt;$&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="3f5cfd48537bc41203499ec678c7f8d1ffcc4184" translate="yes" xml:space="preserve">
          <source>An argument line supplying values to plug into the previous picture line.</source>
          <target state="translated">Строка аргументов,содержащая значения для подключения к предыдущей строке рисунка.</target>
        </trans-unit>
        <trans-unit id="e1318b0f2b2dd2f7e8a55cad33c819c262a23ea1" translate="yes" xml:space="preserve">
          <source>An array can also change its length:</source>
          <target state="translated">Массив также может изменять свою длину:</target>
        </trans-unit>
        <trans-unit id="a7633012ecb371a2113d013c22d2c030bb2a3192" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt; ), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt; ), then the subscript inside square brackets. For example:</source>
          <target state="translated">Доступ к массиву можно получить по одному скаляру за раз, указав знак доллара ( &lt;code&gt;$&lt;/code&gt; ), затем имя массива (без ведущего &lt;code&gt;@&lt;/code&gt; ), а затем нижний индекс в квадратных скобках. Например:</target>
        </trans-unit>
        <trans-unit id="540cdd79efe573437a7605791a2eb1616100de60" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt;), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt;), then the subscript inside square brackets. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015711954685a7b3ea99a44f6e657f520fa53416" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Here's a declaration of the array:</source>
          <target state="translated">Массив массива - это обычный старый массив @AoA, который можно получить с двумя индексами, например &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Вот объявление массива:</target>
        </trans-unit>
        <trans-unit id="11613ff6241b5d0054882bce3b479c51b671807c" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt;. Here's a declaration of the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae61cf59e4cd9db6ee9b5a175cc315be8ef10741" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;&quot;C_constant&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aee3421650400587ce5406d39d397928a2add0e" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt;.</source>
          <target state="translated">Массив имен констант, либо скаляры, содержащие имена, либо хэш-ссылки, как описано в &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dbdb6c0876baa594d12d6a72f40a78381bda16" translate="yes" xml:space="preserve">
          <source>An array of file names for the shared objects that were loaded.</source>
          <target state="translated">Массив имен файлов для совместно используемых объектов,которые были загружены.</target>
        </trans-unit>
        <trans-unit id="26930aebfa1fee021fd440dae3cf343080566995" translate="yes" xml:space="preserve">
          <source>An array of module (package) names that have been bootstrap'ed.</source>
          <target state="translated">Массив имен модулей (пакетов),которые были bootstrap'ed.</target>
        </trans-unit>
        <trans-unit id="e8f1da37492eab7b118aed0b3744e018cc0392dd" translate="yes" xml:space="preserve">
          <source>An array of non-negative integers that is used for comparison purposes with other version objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792d37106ab796a9da516b2cfe4619175268f4f1" translate="yes" xml:space="preserve">
          <source>An array of patches on CPAN or on the local disk to be applied in order via an external patch program. If the value for the &lt;code&gt;-p&lt;/code&gt; parameter is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is determined by reading the patch beforehand. The path to each patch is either an absolute path on the local filesystem or relative to a patch directory specified in the &lt;code&gt;patches_dir&lt;/code&gt; configuration variable or in the format of a canonical distro name. For examples please consult the distroprefs/ directory in the CPAN.pm distribution (these examples are not installed by default).</source>
          <target state="translated">Массив исправлений на CPAN или на локальном диске, которые будут применены по порядку с помощью внешней программы исправлений. Если значение параметра &lt;code&gt;-p&lt;/code&gt; равно &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; , определяется предварительным чтением патча. Путь к каждому патчу является либо абсолютным путем в локальной файловой системе, либо относительно каталога патча, указанного в &lt;code&gt;patches_dir&lt;/code&gt; конфигурации patches_dir, или в формате канонического имени дистрибутива. За примерами обратитесь к каталогу distroprefs / в дистрибутиве CPAN.pm (эти примеры не устанавливаются по умолчанию).</target>
        </trans-unit>
        <trans-unit id="b89f1be8b64b665e2888aa36341ca67f3fc8a573" translate="yes" xml:space="preserve">
          <source>An array of the handles returned by successful calls to dl_load_file(), made by bootstrap, in the order in which they were loaded. Can be used with dl_find_symbol() to look for a symbol in any of the loaded files.</source>
          <target state="translated">Массив дескрипторов,возвращаемых успешными вызовами dl_load_file(),выполненными bootstrap,в порядке их загрузки.Может быть использовано с помощью dl_find_symbol()для поиска символа в любом из загруженных файлов.</target>
        </trans-unit>
        <trans-unit id="c823d47a703f9ce8bdd6c6bd99c53c578f964658" translate="yes" xml:space="preserve">
          <source>An array reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2042400b9cf51420ca0bb02f4a95651f7d9e0fc1" translate="yes" xml:space="preserve">
          <source>An array represents a list of values:</source>
          <target state="translated">Массив представляет собой список значений:</target>
        </trans-unit>
        <trans-unit id="7ce42eb4fb16bbef377321c32853b8f06079f21c" translate="yes" xml:space="preserve">
          <source>An array which exposes the contents of the capture buffers, if any, of the last successful pattern match, not counting patterns matched in nested blocks that have been exited already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58bf09473fcb443f32238cd3f343fe1cb52e884" translate="yes" xml:space="preserve">
          <source>An array with multiple subscripts for finding a single element. Perl implements these using &lt;b&gt;references&lt;/b&gt;&amp;mdash;see Camel chapter 9, &amp;ldquo;Data Structures&amp;rdquo;.</source>
          <target state="translated">Массив с несколькими индексами для поиска одного элемента. Perl реализует их с помощью &lt;b&gt;ссылок -&lt;/b&gt; см. Camel, глава 9, &amp;laquo;Структуры данных&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e730b7563caa7a9a3615b79242bd88575f2b5d2f" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">Попытка &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; не удалась, хотя в списке расширений указано, что она должна быть успешной. Исправьте, выполнив надлежащую установку.</target>
        </trans-unit>
        <trans-unit id="f00d85ec569efd3d0ba1b09d16f4a00196ee0d74" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;eval &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8668d93103d45211068cbb7aa1991bd63b959bd9" translate="yes" xml:space="preserve">
          <source>An attempt to allocate memory failed.</source>
          <target state="translated">Попытка выделить память не удалась.</target>
        </trans-unit>
        <trans-unit id="4965e597a6abdfe2d520970b55b8363275b2a451" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</source>
          <target state="translated">Попытка установить нераспознанный атрибут - фатальная ошибка. (Ошибка является перехваченной, но она все равно останавливает компиляцию внутри этого &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; .) Установка атрибута с именем, состоящим только из строчных букв, которое не является встроенным атрибутом (например, &amp;laquo;foo&amp;raquo;), приведет к предупреждению с помощью &lt;b&gt;-w&lt;/b&gt; или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24018dbac9a81adda03170beee4acf228798de6" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;eval&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;use warnings 'reserved'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c1784b7ddee55af5b75a4bf233031106bc926c" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , or &lt;code&gt;ANY&lt;/code&gt; .</source>
          <target state="translated">Обработчик атрибута был указан с помощью &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; , но тип референта, который он был определен для обработки, не входил в число пяти разрешенных: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; или &lt;code&gt;ANY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be2ec17006c02c47726210c596c995f951690163" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, or &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed24a1addfea7e1a18f9560990ecafe644b6003" translate="yes" xml:space="preserve">
          <source>An attribute is a piece of data belonging to a particular object. Unlike most object-oriented languages, Perl provides no special syntax or support for declaring and manipulating attributes.</source>
          <target state="translated">Атрибут-это часть данных,принадлежащих определенному объекту.В отличие от большинства объектно-ориентированных языков,Perl не предоставляет специального синтаксиса или поддержки для декларирования и манипулирования атрибутами.</target>
        </trans-unit>
        <trans-unit id="4774fb20b25b2c00d90761710a32f25902ad2435" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Список атрибутов - это последовательность спецификаций атрибутов, разделенных пробелом или двоеточием (с необязательным пробелом). Спецификация каждого атрибута представляет собой простое имя, за которым может следовать список параметров в скобках. Если такой список параметров присутствует, он просматривается в соответствии с правилами для оператора &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; . (См. &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Цитаты и операторы, подобные кавычкам в perlop&lt;/a&gt; .) Однако список параметров передается в том виде, в котором он был найден, а не в соответствии с &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6c334100243f2c62d45354cd17461eb4374199" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;q()&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;q()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a21fa1e7844543aacf6b214485b949a7b1705b" translate="yes" xml:space="preserve">
          <source>An early change, in fact the change that made Test2 an idea, was a change to the indentation of the subtest note. It was decided it would be more readable to outdent the subtest note instead of having it inline with the subtest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6356b19b83a0de734fd036ef3412ad9e0499e73b" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(&lt;i&gt;pattern&lt;/i&gt;))\g{-1}&lt;/code&gt;. This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt;, and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ff4a009f82a7cfb00247fff66222df5571297d" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt; , and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">Эффект, подобный &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; может быть достигнут записью &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . Это соответствует той же подстроке, что и автономный &lt;code&gt;a+&lt;/code&gt; , и следующий &lt;code&gt;\g{-1}&lt;/code&gt; съедает совпавшую строку; поэтому он превращает утверждение нулевой длины в аналог &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; . (Разница между этими двумя конструкциями заключается в том, что вторая использует группу захвата, таким образом сдвигая порядковые номера обратных ссылок в остальной части регулярного выражения.)</target>
        </trans-unit>
        <trans-unit id="c5d792d65a737f380eae7ddca70051ed5bf418d1" translate="yes" xml:space="preserve">
          <source>An embedded perl needs to be started up while the global locale is in effect. See &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;&quot;Using embedded Perl with POSIX locales&quot; in perlembed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65503b1bc3cc6e29b56e0751024a1c32f6babaa5" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830fe5530bf8a388dd3b4e1cd4354d40bf489efb" translate="yes" xml:space="preserve">
          <source>An empty E&amp;lt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de720044af3435092cdfe83370a7cafc924ed83" translate="yes" xml:space="preserve">
          <source>An empty X&amp;lt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5eb41f6f24dfa906c0da1eda1f150cd75892a06" translate="yes" xml:space="preserve">
          <source>An empty leading field is produced when there is a positive-width match at the beginning of EXPR. For instance:</source>
          <target state="translated">Пустое опережающее поле создается,когда в начале EXPR появляется матч положительной ширины.Например:</target>
        </trans-unit>
        <trans-unit id="7c1d0be8e8ca70fd2b14e62fb21989504ef1df2a" translate="yes" xml:space="preserve">
          <source>An empty list as soon as an explicit &lt;code&gt;break&lt;/code&gt; is encountered.</source>
          <target state="translated">Пустой список при обнаружении явного &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39e866d4dec47e8ffded31535bf330825a29cb83" translate="yes" xml:space="preserve">
          <source>An empty list, in list context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbf0f80f22fc5d795da7f111754a1b9ed2a4fe4" translate="yes" xml:space="preserve">
          <source>An empty trailing field, on the other hand, is produced when there is a match at the end of EXPR, regardless of the length of the match (of course, unless a non-zero LIMIT is given explicitly, such fields are removed, as in the last example). Thus:</source>
          <target state="translated">Пустое трейлинговое поле,с другой стороны,создается при наличии матча в конце EXPR,независимо от длины матча (конечно,если ненулевой LIMIT не указан явно,такие поля,как в последнем примере,удаляются).Таким образом:</target>
        </trans-unit>
        <trans-unit id="cd562f569c7a192c547c6c2160f193f3f97949c6" translate="yes" xml:space="preserve">
          <source>An enchantment, illusion, phantasm, or jugglery. Said when Perl&amp;rsquo;s magical &lt;b&gt;dwimmer&lt;/b&gt; effects don&amp;rsquo;t do what you expect, but rather seem to be the product of arcane</source>
          <target state="translated">Очарование, иллюзия, фантазм или жонглирование. Сказано, когда волшебные эффекты &lt;b&gt;двиммера&lt;/b&gt; Perl не делают того, что вы ожидаете, а скорее кажутся продуктом тайного</target>
        </trans-unit>
        <trans-unit id="5a1e64f9893fb69df07a9e0956194fcfd71ca286" translate="yes" xml:space="preserve">
          <source>An endpoint for network communication among multiple &lt;b&gt;processes&lt;/b&gt; that works much like a telephone or a post office box. The most important thing about a socket is its &lt;b&gt;network address&lt;/b&gt; (like a phone number). Different kinds of sockets have different kinds of addresses&amp;mdash;some look like filenames, and some don&amp;rsquo;t.</source>
          <target state="translated">Конечная точка для сетевой связи между несколькими &lt;b&gt;процессами,&lt;/b&gt; которая работает так же, как телефон или почтовый ящик. Самым важным в сокете является его &lt;b&gt;сетевой адрес&lt;/b&gt; (например, номер телефона). Разные типы сокетов имеют разные типы адресов - некоторые выглядят как имена файлов, а некоторые нет.</target>
        </trans-unit>
        <trans-unit id="84340afb233fc1ed2c36b5178d0bb87bc821d3fd" translate="yes" xml:space="preserve">
          <source>An entire computer program crammed into one line of text.</source>
          <target state="translated">Целая компьютерная программа,зажатая в одну строку текста.</target>
        </trans-unit>
        <trans-unit id="0b89a9a0affedc51570a8afe57fcceb747dbf5fe" translate="yes" xml:space="preserve">
          <source>An entity specified by number (dec, hex, oct) is out of range (1-255).</source>
          <target state="translated">Сущность,заданная числом (дека,гекс,окт),находится вне диапазона (1-255).</target>
        </trans-unit>
        <trans-unit id="e4a99f74cee987dba72920fbff7e10dc623de69d" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-La:\foo&lt;/code&gt; specifies the &lt;code&gt;a:\foo&lt;/code&gt; directory to look for the libraries that follow.</source>
          <target state="translated">Запись в форме &lt;code&gt;-La:\foo&lt;/code&gt; указывает каталог &lt;code&gt;a:\foo&lt;/code&gt; для поиска следующих библиотек.</target>
        </trans-unit>
        <trans-unit id="e872c91a08d6535bc529f64f8ec25e1266b0facd" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt; , which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt; , but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt; . If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt; , depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">Запись формы &lt;code&gt;-lfoo&lt;/code&gt; указывает библиотеку &lt;code&gt;foo&lt;/code&gt; , которая может быть написана по-разному в зависимости от того, какой компилятор вы используете. Если вы используете GCC, он преобразуется в &lt;code&gt;libfoo.a&lt;/code&gt; , но для других компиляторов win32 он становится &lt;code&gt;foo.lib&lt;/code&gt; . Если файлы с такими переведенными именами не найдены, делается еще одна попытка найти их с помощью &lt;code&gt;foo.a&lt;/code&gt; или &lt;code&gt;libfoo.lib&lt;/code&gt; , в зависимости от того, используется ли GCC или какой-либо другой компилятор win32 соответственно.</target>
        </trans-unit>
        <trans-unit id="b955ec169e3cf404a025241c85cc35d91ed6e518" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt;, which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt;, but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt;. If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt;, depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542b3550714b3908eea8d8c13ea7256018c9e930" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nodefault/i&lt;/code&gt; disables the appending of default libraries found in &lt;code&gt;$Config{perllibs}&lt;/code&gt; (this should be only needed very rarely).</source>
          <target state="translated">Запись, соответствующая &lt;code&gt;/:nodefault/i&lt;/code&gt; , отключает добавление библиотек по умолчанию, найденных в &lt;code&gt;$Config{perllibs}&lt;/code&gt; (это должно быть необходимо очень редко).</target>
        </trans-unit>
        <trans-unit id="54596c2d41917bea50cab186303f4d27d58e3783" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt; ), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">Запись, соответствующая &lt;code&gt;/:nosearch/i&lt;/code&gt; отключает любой поиск библиотек, указанных после нее. Трансляция &lt;code&gt;-Lfoo&lt;/code&gt; и &lt;code&gt;-lfoo&lt;/code&gt; по- прежнему выполняется при необходимости (в зависимости от используемого компилятора, что отражено в &lt;code&gt;$Config{cc}&lt;/code&gt; ), но записи не проверяются на правильность файлов или каталогов.</target>
        </trans-unit>
        <trans-unit id="0f36c83e40eae68ee067d041dd5eaac816d400ba" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt;), but the entries are not verified to be valid files or directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341641ec8dfdfc884739074e9d2b0f226cf6a1e7" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</source>
          <target state="translated">Запись, соответствующая &lt;code&gt;/:search/i&lt;/code&gt; , снова включает поиск библиотек, указанных после нее. Вы можете поместить его в конец, чтобы разрешить поиск библиотек по умолчанию, указанных в &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58b3df12b9c4c1391c5d6a764ee07751d9f03ea6" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764e7bd0665e9fa3ca103f1f3c69a2b0a336ccc2" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac77ebce5cb434a4347aeb52157baf13e86e68f" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file &lt;b&gt;sv.h&lt;/b&gt; in the &lt;code&gt;svtype&lt;/code&gt; enum. Test these flags with the &lt;code&gt;SvTYPE&lt;/code&gt; macro.</source>
          <target state="translated">Перечисление флагов для типов Perl. Они находятся в файле &lt;b&gt;sv.h&lt;/b&gt; в перечислении &lt;code&gt;svtype&lt;/code&gt; . Проверьте эти флаги с &lt;code&gt;SvTYPE&lt;/code&gt; макроса SvTYPE .</target>
        </trans-unit>
        <trans-unit id="a352e1f402bd0b0688137a6b2ecc0dfb6c13f18b" translate="yes" xml:space="preserve">
          <source>An enum value. Used to transfer an enum component from C. There is no reason to pass an enum value to C since it is stored as an IV inside perl.</source>
          <target state="translated">Перечисленное значение.Используется для переноса компонента перечисления из C.Нет причин передавать значение перечисления в C,так как оно хранится как IV внутри perl.</target>
        </trans-unit>
        <trans-unit id="22fd110d7c238cdd41592c0a602172ada41cc36a" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b348ed9fe24e3e5ab044fd0ea208d3866c0f50" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">Используется переменная среды, а не параллельное выполнение, потому что &lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness сам&lt;/a&gt; должен иметь возможность планировать отдельные неконфликтующие тестовые сценарии, и не существует стандартного интерфейса, &lt;code&gt;make&lt;/code&gt; утилитам взаимодействовать со своими планировщиками заданий.</target>
        </trans-unit>
        <trans-unit id="066862fe86f40b5704d122b8bfa39f1462669702" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</source>
          <target state="translated">Произошла ошибка (для &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d508ac8c71c775f43142d23e442e2000fbf79e9" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf25473c20a4c33f096f0b4023a99e2a049e0b27" translate="yes" xml:space="preserve">
          <source>An essential part of any good development process is appropriate error handling with appropriately informative messages, however there exists a school of thought which suggests that log files should be</source>
          <target state="translated">Существенной частью любого хорошего процесса развития является надлежащая обработка ошибок с соответствующими информационными сообщениями,однако существует школа мысли,которая предполагает,что лог-файлы должны быть</target>
        </trans-unit>
        <trans-unit id="66bdaa16d0763f3a76de0b4a13d35f1b3d80f29a" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt; &amp;lt;</source>
          <target state="translated">Еще более странный код шаблона - &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c948915c37e1832c4cdb4ea5562b06199c7d0645" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt;&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5463243357a8ee13bfd32810dc057038bf9e07" translate="yes" xml:space="preserve">
          <source>An event that causes a &lt;b&gt;handler&lt;/b&gt; to be run.</source>
          <target state="translated">Событие, вызывающее запуск &lt;b&gt;обработчика&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="aa855332f899b198338c3e15641312b3dfa643e8" translate="yes" xml:space="preserve">
          <source>An example conversion function for a typemapped struct &lt;code&gt;foo_t *&lt;/code&gt; might be:</source>
          <target state="translated">Примером функции преобразования для структурированной структуры &lt;code&gt;foo_t *&lt;/code&gt; может быть:</target>
        </trans-unit>
        <trans-unit id="ec7aaa34ffb73c97f6ed68693695810184b33f37" translate="yes" xml:space="preserve">
          <source>An example disabling Nagle's algorithm on a socket:</source>
          <target state="translated">Пример отключения алгоритма Нейгла на разъеме:</target>
        </trans-unit>
        <trans-unit id="370a61094a87b707b90886b80eccf424717c5430" translate="yes" xml:space="preserve">
          <source>An example for Russian and some languages using the Cyrillic script:</source>
          <target state="translated">Пример для русского и некоторых языков с использованием кириллицы:</target>
        </trans-unit>
        <trans-unit id="62a8d925afd0ed802ddeaf7e7056d235e6263d4e" translate="yes" xml:space="preserve">
          <source>An example may make this clearer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562686eabf6589e6760dcb870fbc2918a4b18229" translate="yes" xml:space="preserve">
          <source>An example of all of the phases Perl code can see:</source>
          <target state="translated">Пример всех фаз можно посмотреть на Perl-коде:</target>
        </trans-unit>
        <trans-unit id="b3f8fac7e809f312cdc7e6d944996bb2ded1f5bf" translate="yes" xml:space="preserve">
          <source>An example of how this is used is the &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt; formatter. For unbuffered subtests the events are rendered as they are generated. At the end of the subtest, the final subtest event is rendered, but the &lt;code&gt;subevents&lt;/code&gt; attribute is ignored. For buffered subtests the opposite occurs, the events are NOT rendered as they are generated, instead the &lt;code&gt;subevents&lt;/code&gt; attribute is used to render them all at once. This is useful when running subtests tests in parallel, since without it the output from subtests would be interleaved together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5242beac10407637f4a4b464517825d71718f4a4" translate="yes" xml:space="preserve">
          <source>An example of how this might be used is as follows:</source>
          <target state="translated">Пример того,как это может быть использовано,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5a34b3fb3e9dbd7f514687e325a9fcbdaa8609fe" translate="yes" xml:space="preserve">
          <source>An example of this is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af46ea4947cfe8e14d48ae32223fb001ec7bc498" translate="yes" xml:space="preserve">
          <source>An example of using Name property wildcards is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9dc32ca31441503bc05feea6fc9cf1b0dfb98e" translate="yes" xml:space="preserve">
          <source>An example output might be:</source>
          <target state="translated">Пример выхода может быть:</target>
        </trans-unit>
        <trans-unit id="d132f664732cae183fc32adf49e25fe3aca9db69" translate="yes" xml:space="preserve">
          <source>An example taken from an article posted to comp.lang.perl.misc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516a8fafa09adceb915093c484c5d89d031db306" translate="yes" xml:space="preserve">
          <source>An example usage looks like:</source>
          <target state="translated">Похоже на пример использования:</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="b3e01d95d4f7169aa36a737a1211243d324cf5ef" translate="yes" xml:space="preserve">
          <source>An exception</source>
          <target state="translated">Исключение</target>
        </trans-unit>
        <trans-unit id="af317c13cfaee4d2548fba4cee59592a6612afcd" translate="yes" xml:space="preserve">
          <source>An exception event will display to STDERR, and will prevent the overall test file from passing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ab19b971476be687f1585d2d4d367fb367ec27" translate="yes" xml:space="preserve">
          <source>An exception is considered to match a string if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441facb85290f4d6c3e35bab01158ccc81039064" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is that &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb08b0a2e1d46bb5d472e490ea7b28d5dd9e956d" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">Исключением является то, что вы можете назначить &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в списке. Это полезно для отбрасывания некоторых возвращаемых значений функции:</target>
        </trans-unit>
        <trans-unit id="b907b876869fb91f8d35b06170f79ee9f948ffa2" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;undef&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1bf7c1ca3df304818b1a482b2ae19817ae3aee" translate="yes" xml:space="preserve">
          <source>An exception will be raised if &lt;code&gt;verify_SSL&lt;/code&gt; is true and no CA certificate file is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc1d98cce4c241de46d33d676c33734f841fc89" translate="yes" xml:space="preserve">
          <source>An executable compiled on a PA-RISC 2.0 platform will not execute on a PA-RISC 1.1 platform, even if they are running the same version of HP-UX. If you are building Perl on a PA-RISC 2.0 platform and want that Perl to also run on a PA-RISC 1.1, the compiler flags +DAportable and +DS32 should be used.</source>
          <target state="translated">Исполняемый файл,скомпилированный на платформе PA-RISC 2.0,не будет выполняться на платформе PA-RISC 1.1,даже если они работают с той же версией HP-UX.Если вы собираете Perl на платформе PA-RISC 2.0 и хотите,чтобы Perl также выполнялся на PA-RISC 1.1,следует использовать флаги компилятора +DAportable и +DS32.</target>
        </trans-unit>
        <trans-unit id="089b36ce65cddba1918a51ae6a46d8831ee39956" translate="yes" xml:space="preserve">
          <source>An exit status of 0 implies &quot;success&quot;. For example, &lt;b&gt;diff(1)&lt;/b&gt; exits with a status of 0 if the two files have the same contents.</source>
          <target state="translated">Статус выхода 0 означает &amp;laquo;успех&amp;raquo;. Например, &lt;b&gt;diff (1)&lt;/b&gt; завершает работу со статусом 0, если два файла имеют одинаковое содержимое.</target>
        </trans-unit>
        <trans-unit id="bbd4429d08a5ebe605cc6bfbbfa2eaacec53a0f9" translate="yes" xml:space="preserve">
          <source>An exit status of 1 implies possibly abnormal, but non-defective, program termination. For example, &lt;b&gt;grep(1)&lt;/b&gt; exits with a status of 1 if it did</source>
          <target state="translated">Статус выхода 1 подразумевает, возможно, ненормальное, но исправное завершение программы. Например, &lt;b&gt;grep (1)&lt;/b&gt; завершает работу со статусом 1, если</target>
        </trans-unit>
        <trans-unit id="e246081e6327d64a230056100ee6a6d47e29ef00" translate="yes" xml:space="preserve">
          <source>An exit status of 2 or more implies a fatal error. For example, &lt;b&gt;ls(1)&lt;/b&gt; exits with a status of 2 if you specify an illegal (unknown) option on the command line.</source>
          <target state="translated">Статус выхода 2 или более означает фатальную ошибку. Например, &lt;b&gt;ls (1)&lt;/b&gt; завершится со статусом 2, если вы укажете недопустимый (неизвестный) параметр в командной строке.</target>
        </trans-unit>
        <trans-unit id="1ff1cef51589fc8dbb6faba666f12b831fe6b899" translate="yes" xml:space="preserve">
          <source>An experimental pseudolayer that removes the topmost layer. Use with the same care as is reserved for nitroglycerine.</source>
          <target state="translated">Экспериментальный псевдо-слой,который удаляет верхний слой.Используйте с той же осторожностью,что и нитроглицерин.</target>
        </trans-unit>
        <trans-unit id="846db25d0ecc19ed2c5fd44070c00f6f8a9c0772" translate="yes" xml:space="preserve">
          <source>An explanation of VMS file specs can be found at &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;.</source>
          <target state="translated">Объяснение спецификаций файла VMS можно найти на &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b85172cf7a158b615a4c1e4c610cfa79b7fa2c51" translate="yes" xml:space="preserve">
          <source>An explicit format parameter index, such as &lt;code&gt;2$&lt;/code&gt;. By default sprintf will format the next unused argument in the list, but this allows you to take the arguments out of order:</source>
          <target state="translated">Явный индекс параметра формата, например &lt;code&gt;2$&lt;/code&gt; . По умолчанию sprintf отформатирует следующий неиспользуемый аргумент в списке, но это позволяет вам выносить аргументы не по порядку:</target>
        </trans-unit>
        <trans-unit id="52691b6df07cdbefee8cb7a498d3dc93b2c8dd90" translate="yes" xml:space="preserve">
          <source>An exploration of some of the issues facing Perl programmers on EBCDIC based computers.</source>
          <target state="translated">Исследование некоторых проблем,с которыми сталкиваются программисты Perl на компьютерах на базе EBCDIC.</target>
        </trans-unit>
        <trans-unit id="372a1e4ea54335151ba75e3cd2ea53899b760f24" translate="yes" xml:space="preserve">
          <source>An expression which, when its value changes, causes a breakpoint in the Perl debugger.</source>
          <target state="translated">Выражение,которое при изменении своего значения вызывает точку останова в отладчике Perl.</target>
        </trans-unit>
        <trans-unit id="d16dfa398c1840b695b36040deeba3088ca6a02a" translate="yes" xml:space="preserve">
          <source>An extension is a way of calling compiled C code from Perl. Reading &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; is a good place to learn more about extensions.</source>
          <target state="translated">Расширение - это способ вызова скомпилированного кода C из Perl. Чтение &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; - хорошее место, чтобы узнать больше о расширениях.</target>
        </trans-unit>
        <trans-unit id="9164cae08d37bdf18edf58e540f0e6c559fb27cc" translate="yes" xml:space="preserve">
          <source>An extension that is built with the above steps is ready to use on systems supporting dynamic loading. On systems that do not support dynamic loading, any newly created extension has to be linked together with the available resources. MakeMaker supports the linking process by creating appropriate targets in the Makefile whenever an extension is built. You can invoke the corresponding section of the makefile with</source>
          <target state="translated">Надстройка,построенная по вышеописанным этапам,готова к использованию в системах,поддерживающих динамическую нагрузку.В системах,не поддерживающих динамическую загрузку,любое вновь созданное расширение должно быть связано с имеющимися ресурсами.MakeMaker поддерживает процесс компоновки,создавая соответствующие цели в Makefile при каждой сборке расширения.Вы можете вызвать соответствующий раздел makefile с помощью кнопки</target>
        </trans-unit>
        <trans-unit id="62fe96c831d4e5434f2a2484c5da0d22ce2c69d7" translate="yes" xml:space="preserve">
          <source>An external &lt;b&gt;subroutine&lt;/b&gt; defined in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">Внешняя &lt;b&gt;подпрограмма,&lt;/b&gt; определенная в &lt;b&gt;XS&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7422ed8b7617c92670f322946ad1f9ad0f35ee57" translate="yes" xml:space="preserve">
          <source>An extra field consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">Дополнительное поле состоит из нуля и более подполей.Каждое подполе состоит из двух байтового заголовка,за которым следуют данные подполя.</target>
        </trans-unit>
        <trans-unit id="18c0e84026650565acf5b36d62e6093af36330f9" translate="yes" xml:space="preserve">
          <source>An extraordinarily exported, expeditiously excellent, expressly eXternal Subroutine, executed in existing C or C++ or in an exciting extension language called (exasperatingly) XS.</source>
          <target state="translated">Чрезвычайно экспортированная,быстро превосходная,явно вечная подпрограмма,выполняемая на существующем языке C или C++или на захватывающем языке расширений,называемом (безумно)XS.</target>
        </trans-unit>
        <trans-unit id="5ae0ec1c420230a4b9a6f6f5a35cd2c66a33eeb2" translate="yes" xml:space="preserve">
          <source>An extremely lightweight &lt;b&gt;DB_File&lt;/b&gt; wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</source>
          <target state="translated">Чрезвычайно легкая оболочка &lt;b&gt;DB_File,&lt;/b&gt; которая просто &lt;b&gt;собирает файл&lt;/b&gt; блокировки перед &lt;b&gt;связыванием&lt;/b&gt; базы данных и сбрасывает блокировку после развязывания. Позволяет при желании использовать один и тот же файл блокировки для нескольких баз данных, чтобы избежать проблем с взаимоблокировкой. Используется для баз данных, где обновления считываются быстро, и достаточно простой семантики блокировки стай.</target>
        </trans-unit>
        <trans-unit id="6c7aaf1b9af23250eb8ede6f4c91ca5fbe3ad083" translate="yes" xml:space="preserve">
          <source>An identifier (not necessarily related to the real name of a file) that represents a particular instance of opening a file, until you close it. If you&amp;rsquo;re going to open and close several different files in succession, it&amp;rsquo;s fine to open each of them with the same filehandle, so you don&amp;rsquo;t have to write out separate code to process each file.</source>
          <target state="translated">Идентификатор (не обязательно связанный с настоящим именем файла), который представляет конкретный экземпляр открытия файла до его закрытия. Если вы собираетесь открывать и закрывать несколько разных файлов последовательно, можно открывать каждый из них с одним и тем же дескриптором файла, поэтому вам не нужно писать отдельный код для обработки каждого файла.</target>
        </trans-unit>
        <trans-unit id="2ca4f6f5a018c6a780d2f920105ee21e87c135e6" translate="yes" xml:space="preserve">
          <source>An immediate filter allows you to specify the filter code to be used at the point where the filter is applied to a dbm. In this mode the Filter_*_Push methods expects to receive exactly two parameters.</source>
          <target state="translated">Непосредственный фильтр позволяет указать код фильтра,который будет использоваться в точке,где фильтр применяется к dbm.В этом режиме методы Filter_*_Push ожидают получения ровно двух параметров.</target>
        </trans-unit>
        <trans-unit id="854d43de9440512807e67ff18407c545a932b325" translate="yes" xml:space="preserve">
          <source>An imperfect standard</source>
          <target state="translated">Несовершенный стандарт</target>
        </trans-unit>
        <trans-unit id="20af74febdbf871248a6b2f4c417ca9aaffe6f3f" translate="yes" xml:space="preserve">
          <source>An important property of the digest algorithms is that the digest is</source>
          <target state="translated">Важным свойством алгоритмов дайджеста является то,что дайджест-это</target>
        </trans-unit>
        <trans-unit id="5358f4c4e85e881620623ef0fa458c651c57bf92" translate="yes" xml:space="preserve">
          <source>An incremental option is specified with a plus &lt;code&gt;+&lt;/code&gt; after the option name:</source>
          <target state="translated">Инкрементная опция указывается со знаком плюс &lt;code&gt;+&lt;/code&gt; после имени опции:</target>
        </trans-unit>
        <trans-unit id="eff14445a69700081714d1ed9ff369fb4f2bc735" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">Указатель имен символов доступен в режиме онлайн в Консорциуме Unicode, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt; ; пояснительный материал со ссылками на другие ресурсы на &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00b6943f411e2de4ec124878b41ea6334f76e3b4" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;https://www.unicode.org/charts/charindex.html&quot;&gt;https://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;https://www.unicode.org/standard/where&quot;&gt;https://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef770a25a15f3c0ce63ccdcd24649733fd026bd0" translate="yes" xml:space="preserve">
          <source>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</source>
          <target state="translated">Косвенная файловая ручка-это использование чего-либо,кроме символа,в месте,где ожидается файловая ручка.Вот способы получения косвенных файловых дескрипторов:</target>
        </trans-unit>
        <trans-unit id="858451a2efc846133fcc1f6e934e6a48b50f2e8c" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt; , is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">Информативный хэш, доступный через &lt;code&gt;details()&lt;/code&gt; , сохраняется для каждого выполняемого вами теста. Таким образом, использование памяти будет линейно масштабироваться с каждым запуском теста. Хотя это не проблема для большинства наборов тестов, это может стать проблемой, если вы выполните большие (от сотен тысяч до миллиона) комбинаторических тестов за один прогон.</target>
        </trans-unit>
        <trans-unit id="701384a60361f136947eccd77eb6f91598d0f6e9" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt;, is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e6a3af85651e42bfa391fe495fc3734c02ae8b" translate="yes" xml:space="preserve">
          <source>An input file that uses source filtering probably won't be deparsed into runnable code, because it will still include the &lt;b&gt;use&lt;/b&gt; declaration for the source filtering module, even though the code that is produced is already ordinary Perl which shouldn't be filtered again.</source>
          <target state="translated">Входной файл, который использует исходную фильтрацию, вероятно, не будет преобразован в исполняемый код, потому что он по-прежнему будет включать объявление &lt;b&gt;использования&lt;/b&gt; для модуля исходной фильтрации, даже если созданный код уже является обычным Perl, который не должен подвергаться повторной фильтрации.</target>
        </trans-unit>
        <trans-unit id="aa16b38820f7deb5595d1bc31e5c4264a804f15b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">При установке можно разрешить сопоставление любого из них, загрузив базу данных Unicode с &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; в &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="41c8e8c55ba26c070500d10138a4327fcb1ea456" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a014f84e1453ef226d46effcd0a9cbfe569a9f81" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">Экземпляр запущенной программы. В многозадачных системах, таких как Unix, два или более отдельных процесса могут запускать одну и ту же программу независимо в одно и то же время - на самом деле, функция &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; предназначена для достижения этого счастливого положения вещей. В других операционных системах процессы иногда называют &amp;laquo;потоками&amp;raquo;, &amp;laquo;задачами&amp;raquo; или &amp;laquo;заданиями&amp;raquo;, часто с небольшими нюансами в значении.</target>
        </trans-unit>
        <trans-unit id="d7bfae97a3fa7902fae2c04baaa1f1c2a7428aa8" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;fork&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0214de560f2556559c172656f6d4683531a40229" translate="yes" xml:space="preserve">
          <source>An integer divisor when you&amp;rsquo;re interested in the remainder instead of the quotient.</source>
          <target state="translated">Целочисленный делитель, когда вас интересует остаток, а не частное.</target>
        </trans-unit>
        <trans-unit id="ef97a772df2ab33140914238f0dfa09aa1f2481c" translate="yes" xml:space="preserve">
          <source>An integer in the range from 0 to 1, inclusive. The smallest possible unit of information storage. An eighth of a &lt;b&gt;byte&lt;/b&gt; or of a dollar. (The term &amp;ldquo;Pieces of Eight&amp;rdquo; comes from being able to split the old Spanish dollar into 8 bits, each of which still counted for money. That&amp;rsquo;s why a 25- cent piece today is still &amp;ldquo;two bits&amp;rdquo;.)</source>
          <target state="translated">Целое число в диапазоне от 0 до 1 включительно. Наименьшая возможная единица хранения информации. Одна восьмая &lt;b&gt;байта&lt;/b&gt; или доллара. (Термин &amp;laquo;восьмерка&amp;raquo; происходит от возможности разделить старый испанский доллар на 8 битов, каждая из которых все еще считается деньгами. Вот почему 25-центовая монета сегодня все еще остается &amp;laquo;двумя битами&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="487c5ee86805465c96baeca407a9f1d4e496a654" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE
SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">Интересным свойством 32 управляющих символов C0 в таблице ASCII является то, что они могут быть &amp;laquo;буквально&amp;raquo; созданы как управляющие символы в Perl, например &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt; , и так далее. Perl на платформах EBCDIC был портирован так, чтобы &lt;code&gt;\c@&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; в chr (0), а &lt;code&gt;\cA&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; и т. д., но получаемые символы зависят от того, какую кодовую страницу вы используете. В таблице ниже используются стандартные сокращения для элементов управления. Наборы POSIX-BC и 1047 идентичны во всем этом диапазоне и отличаются от набора 0037 только одной точкой (21 десятичный знак). Обратите внимание , что линия терминатора символ может быть порождена &lt;code&gt;\cJ&lt;/code&gt; на ASCII платформах а &lt;code&gt;\cU&lt;/code&gt; на 1047 или POSIX-BC платформ и не могут быть созданы как &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; управляющий персонаж на платформах 0037. Также обратите внимание, что &lt;code&gt;\c\&lt;/code&gt; не может быть последним элементом в строке или регулярном выражении, так как он поглотит терминатор. Но &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; - &lt;code&gt;FILE SEPARATOR&lt;/code&gt; объединенный с</target>
        </trans-unit>
        <trans-unit id="5ec5858c69c508303478b5682163ba9de4ba1b6f" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(chr(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt;)&amp;gt; &lt;code&gt;(chr(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt;)&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;chr(0)&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;chr(1)&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef88cb460d98eb7a1821664038bd8e659735536" translate="yes" xml:space="preserve">
          <source>An internal &amp;ldquo;glob value&amp;rdquo; typedef, holding a &lt;b&gt;typeglob&lt;/b&gt;. The &lt;code&gt;GV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">Внутренний typedef &amp;laquo; &lt;b&gt;глобальное&lt;/b&gt; значение&amp;raquo;, содержащий &lt;b&gt;typeglob&lt;/b&gt; . Тип &lt;code&gt;GV&lt;/code&gt; является подклассом &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="365d20928561014537aae861944e88c7698c35b5" translate="yes" xml:space="preserve">
          <source>An internal I/O object. Can also mean &lt;b&gt;indirect object&lt;/b&gt;.</source>
          <target state="translated">Внутренний объект ввода-вывода. Также может означать &lt;b&gt;косвенный объект&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="56ae7164116e23d92fc781838b142ca53874c36a" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines.</source>
          <target state="translated">Внутренняя функция для генерации встроенного perl кода,который будет регенерировать постоянные подпрограммы.</target>
        </trans-unit>
        <trans-unit id="7baaf8aedf397c98d596c2159887aa7f484b6db4" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines. Parameters are the same as for C_constant.</source>
          <target state="translated">Внутренняя функция для генерации встроенного perl кода,который будет регенерировать постоянные подпрограммы.Параметры такие же,как и для C_constant.</target>
        </trans-unit>
        <trans-unit id="85667dd393cb7f2981dedf066accff60dc1411e5" translate="yes" xml:space="preserve">
          <source>An internal method to generate a suitable &lt;code&gt;switch&lt;/code&gt; clause, called by &lt;code&gt;C_constant&lt;/code&gt;</source>
          <target state="translated">Внутренний метод для генерации подходящего предложения &lt;code&gt;switch&lt;/code&gt; , вызываемый &lt;code&gt;C_constant&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69e28cd04a2779fc9d5742eab6b3a6ded1892dd3" translate="yes" xml:space="preserve">
          <source>An internal representation of your program wherein lower-level &lt;b&gt;constructs&lt;/b&gt; dangle off the higher-level constructs enclosing them.</source>
          <target state="translated">Внутреннее представление вашей программы, в котором низкоуровневые &lt;b&gt;конструкции&lt;/b&gt; свешиваются над окружающими их конструкциями более высокого уровня.</target>
        </trans-unit>
        <trans-unit id="ce42a8cc64b6b6a7bf11b4b312683fee15a303f0" translate="yes" xml:space="preserve">
          <source>An internal shorthand for a &amp;ldquo;push- pop&amp;rdquo; code; that is, C code implementing Perl&amp;rsquo;s stack machine.</source>
          <target state="translated">Внутреннее сокращение для кода &amp;laquo;push-pop&amp;raquo;; то есть код C, реализующий стековую машину Perl.</target>
        </trans-unit>
        <trans-unit id="2be767144e56c8e338304ff9f530373044c5bc8a" translate="yes" xml:space="preserve">
          <source>An internal variable used by &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d1d6d772129317410071c249632c5b5382b664" translate="yes" xml:space="preserve">
          <source>An internal variable used by PerlIO. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">Внутренняя переменная, используемая PerlIO. Строка из двух частей, разделенных байтом &lt;code&gt;\0&lt;/code&gt; , первая часть описывает входные слои, вторая часть описывает выходные слои.</target>
        </trans-unit>
        <trans-unit id="30d4f93cd3d13081a21910a8e9e9a9f2e19354af" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">Обнаружена недопустимая команда POD. Допустимые значения: &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="680a8cfcc47d942c4c76eb14d38af7a01657dc85" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt;, &lt;code&gt;=head2&lt;/code&gt;, &lt;code&gt;=head3&lt;/code&gt;, &lt;code&gt;=head4&lt;/code&gt;, &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;, &lt;code&gt;=back&lt;/code&gt;, &lt;code&gt;=begin&lt;/code&gt;, &lt;code&gt;=end&lt;/code&gt;, &lt;code&gt;=for&lt;/code&gt;, &lt;code&gt;=pod&lt;/code&gt;, &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf1c0648159d8ce5ec8b307b5ed4c7e4b2df3c9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Обнаружена недопустимая команда разметки. Допустимые значения: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab0cc889ac8e69a2e34e2105510c7875248e79d9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1262d5508556d2b36a24c42f3e9a2dee57cb72" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">Элемент &amp;laquo;_ *&amp;raquo; интерпретируется как &amp;laquo;все из @_, кроме $ _ [0]&amp;raquo;. Т.е., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Обратите внимание, что это пустой список в случае вызовов типа $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="c7832bda7130f94045f7bfb60ec1dccf55e7e697" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt;. Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af9ff7e003c973fa83a18c634e0daee75f8051b" translate="yes" xml:space="preserve">
          <source>An item that is &quot;_</source>
          <target state="translated">Пункт,который называется &quot;_</target>
        </trans-unit>
        <trans-unit id="7b5f2c15e59a54bf0587db95d2a9b094a2521830" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">Число, указывающее максимальное количество возвращаемых полей. Если этот аргумент опущен (или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), разделение продолжается как можно дольше.</target>
        </trans-unit>
        <trans-unit id="da38298cadbae3dcfcb616625cc2268ee1079670" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;undef&lt;/code&gt;), split continues as long as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabc404e0d4e219ccc6748ea24d333aab485d543" translate="yes" xml:space="preserve">
          <source>An object belonging to a language class is called a &quot;language handle&quot;; it's typically a flyweight object.</source>
          <target state="translated">Объект,принадлежащий к классу языка,называется &quot;языковым дескриптором&quot;;как правило,это объект с летучим весом.</target>
        </trans-unit>
        <trans-unit id="49f2fe3106e7ff8ff917e823e3eefb2822882e64" translate="yes" xml:space="preserve">
          <source>An object corresponding to a paragraph of POD input text. It may be a plain paragraph, a verbatim paragraph, or a command paragraph (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">Объект, соответствующий абзацу входного текста POD. Это может быть простой абзац, дословный абзац или командный абзац (см. &lt;a href=&quot;../perlpod&quot;&gt;Perlpod&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8c3786be4e01790b87960925526e572088af640f" translate="yes" xml:space="preserve">
          <source>An object corresponding to a tree of parsed POD text. Each &quot;node&quot; in a parse-tree (or</source>
          <target state="translated">Объект,соответствующий дереву разобранного POD-текста.Каждый &quot;узел&quot; в дереве разбора (или</target>
        </trans-unit>
        <trans-unit id="7e0998ddd63a38891699bf9ec1b0ac44c576baee" translate="yes" xml:space="preserve">
          <source>An object corresponding to an interior sequence command from the POD input text (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">Объект, соответствующий команде внутренней последовательности из входного текста POD (см. &lt;a href=&quot;../perlpod&quot;&gt;Perlpod&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a21e67f15a49134056700786cd13ad755082aac" translate="yes" xml:space="preserve">
          <source>An object is simply a data structure that knows to which class it belongs.</source>
          <target state="translated">Объект-это просто структура данных,которая знает,к какому классу она принадлежит.</target>
        </trans-unit>
        <trans-unit id="a359cbcceea3057766a3859aec9166b89f1082b5" translate="yes" xml:space="preserve">
          <source>An object method that initializes the first and last name to its two arguments. If called as a class method, &lt;code&gt;init()&lt;/code&gt; creates an object in the given class and initializes that.</source>
          <target state="translated">Метод объекта, который инициализирует имя и фамилию двумя своими аргументами. Если вызывается как метод класса, &lt;code&gt;init()&lt;/code&gt; создает объект в данном классе и инициализирует его.</target>
        </trans-unit>
        <trans-unit id="2624824193fa16111d4b98614c9c89fd43601093" translate="yes" xml:space="preserve">
          <source>An object of a class created by the first and third forms is based on an array, whereas an object of a class created by the second form is based on a hash. The array-based forms will be somewhat faster and smaller; the hash-based forms are more flexible.</source>
          <target state="translated">Объект класса,созданного первой и третьей формами,основан на массиве,в то время как объект класса,созданного второй формой,основан на хэше.Формы,основанные на массивах,будут несколько быстрее и меньше;формы,основанные на хэшах,более гибкие.</target>
        </trans-unit>
        <trans-unit id="439e33121717fb8b3802d4a57550afd4a17f81f5" translate="yes" xml:space="preserve">
          <source>An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</source>
          <target state="translated">Объект класса Archive::Tar представляет собой архив .tar(.gz),полный файлов и вещей.</target>
        </trans-unit>
        <trans-unit id="fcd5621c0c225a91e3f7d06ac2a91fa4ab613367" translate="yes" xml:space="preserve">
          <source>An object representing a POD interior sequence command. It has the following methods/attributes:</source>
          <target state="translated">Объект,представляющий команду внутренней последовательности POD.Он имеет следующие методы/атрибуты:</target>
        </trans-unit>
        <trans-unit id="c24cc2e914ce53bfd778879fef27948d64904b08" translate="yes" xml:space="preserve">
          <source>An object representing a paragraph of POD input text. It has the following methods/attributes:</source>
          <target state="translated">Объект,представляющий собой абзац входного текста POD.Он имеет следующие методы/атрибуты:</target>
        </trans-unit>
        <trans-unit id="6fdb094e1018942aa0eb673bb8c92b50838eeb01" translate="yes" xml:space="preserve">
          <source>An object represents a single discrete thing. For example, an object might represent a file. The attributes for a file object might include its path, content, and last modification time. If we created an object to represent</source>
          <target state="translated">Объект представляет собой единственную дискретную вещь.Например,объект может представлять файл.Атрибуты файлового объекта могут включать его путь,содержимое и время последней модификации.Если мы создали объект для представления</target>
        </trans-unit>
        <trans-unit id="ca7e61e203c4b11d26a8c4d45f16575384df7da5" translate="yes" xml:space="preserve">
          <source>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</source>
          <target state="translated">Объект,перегружающий оператор присваивания,делает это только в отношении присваиваний этому объекту.Другими словами,Perl никогда не вызывает соответствующие методы с третьим аргументом (&quot;swap&quot;),установленным в TRUE.Например,операция</target>
        </trans-unit>
        <trans-unit id="5dcc2b27aa012d9c72429af38062f2b4f54986c2" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt; , which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">Члены объекта не могут быть доступны как переменные. Ближайший Perl-эквивалент &lt;code&gt;with(object) { method() }&lt;/code&gt; предназначен &lt;code&gt;for&lt;/code&gt; , который может использовать псевдоним &lt;code&gt;$_&lt;/code&gt; для объекта:</target>
        </trans-unit>
        <trans-unit id="667eaf5552288796413270dd142cf8898197f884" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt;, which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b940725a20a5223e137a3da755a048d1310c8a3b" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt; . However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">Однако объект - это ссылка на благословенные данные, поэтому, если &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; являются объектами, тогда присваивание &lt;code&gt;$a = $b&lt;/code&gt; копирует только ссылку, оставляя &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; относящимися к одним и тем же данным объекта. Следовательно, можно было бы ожидать, что операция &lt;code&gt;--$a&lt;/code&gt; уменьшит &lt;code&gt;$b&lt;/code&gt; а также &lt;code&gt;$a&lt;/code&gt; . Однако это не соответствовало бы тому, как мы ожидаем, что математические операторы будут работать.</target>
        </trans-unit>
        <trans-unit id="25fb12e7db9c947b1012ab13c08ddc21606a22cc" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt;. However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee679c1ad7f71a88f44d59f19712e4063863e7e" translate="yes" xml:space="preserve">
          <source>An older style is to use a bareword as the filehandle, as</source>
          <target state="translated">Старый стиль заключается в использовании голого слова в качестве ручки файла,а именно</target>
        </trans-unit>
        <trans-unit id="60dc562d58d05afda178b352ef3aa2e15f8841ff" translate="yes" xml:space="preserve">
          <source>An op is a fundamental operation that Perl can perform: all the built-in functions and operators are ops, and there are a series of ops which deal with concepts the interpreter needs internally - entering and leaving a block, ending a statement, fetching a variable, and so on.</source>
          <target state="translated">Оп-это фундаментальная операция,которую Perl может выполнять:все встроенные функции и операторы-это оп,и существует ряд оп,которые работают с концепциями,необходимыми интерпретатору внутренне-входом и выходом из блока,завершением оператора,получением переменной и так далее.</target>
        </trans-unit>
        <trans-unit id="7d7b9e438ab0eb414e5789ea7e5ffe93395e4dff" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">Оператор с одним &lt;b&gt;операндом&lt;/b&gt; , например &lt;code&gt;!&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; . Унарные операторы обычно являются префиксными; то есть они предшествуют своему операнду. Операторы &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; могут быть как префиксными, так и постфиксными. (Их позиция</target>
        </trans-unit>
        <trans-unit id="2af9fb33db84bf30fe452d6a36fe8b4e335e0649" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;chdir&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9db1e29b16d48958d935e90ad14b3aea77dc3c" translate="yes" xml:space="preserve">
          <source>An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir. Negating an opname or optag means remove the corresponding ops from the accumulated set of ops at that point.</source>
          <target state="translated">Имя или оптаг могут быть префиксованы восклицательным знаком,например,!mkdir.Отказаться от имени или оптага означает удалить соответствующие операционные из накопленного набора операционных в этот момент.</target>
        </trans-unit>
        <trans-unit id="dd9db1bae968b2ebc8590123585766603b6be162" translate="yes" xml:space="preserve">
          <source>An option on a pattern or substitution, such as &lt;code&gt;/i&lt;/code&gt; to render the pattern case- insensitive.</source>
          <target state="translated">Параметр в шаблоне или подстановке, такой как &lt;code&gt;/i&lt;/code&gt; , чтобы сделать шаблон нечувствительным к регистру.</target>
        </trans-unit>
        <trans-unit id="1a49163e236ca9288cd8e7003ee1066226da4567" translate="yes" xml:space="preserve">
          <source>An option you give on a command line to influence the way your program works, usually introduced with a minus sign. The word is also used as a nickname for a &lt;b&gt;switch statement&lt;/b&gt;.</source>
          <target state="translated">Опция, которую вы даете в командной строке, чтобы повлиять на работу вашей программы, обычно обозначается знаком минус. Это слово также используется как псевдоним для оператора &lt;b&gt;switch&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="eab6379d02e7da9bfe1cac71088e9311f2348060" translate="yes" xml:space="preserve">
          <source>An optional array of other socket options to apply after the three listed above. The value is an ARRAY containing 2- or 3-element ARRAYrefs. Each inner array relates to a single option, giving the level and option name, and an optional value. If the value element is missing, it will be given the value of a platform-sized integer 1 constant (i.e. suitable to enable most of the common boolean options).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2561efefd0f2b6e16416b85a2d7a359b74ad024" translate="yes" xml:space="preserve">
          <source>An optional feature provided by a CPAN distribution</source>
          <target state="translated">Дополнительная функция,предоставляемая дистрибутивом CPAN</target>
        </trans-unit>
        <trans-unit id="9645245b8e6172ce42528bd667596edb4e44c226" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) that output will be printed to.</source>
          <target state="translated">Необязательная файловая рукоятка (или IO::Handle ),на которую будет напечатана выходная информация.</target>
        </trans-unit>
        <trans-unit id="bcc5a81df3ac1dbb29e0b23ff110e8ac5f546061" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) to which the output string will be printed.</source>
          <target state="translated">Необязательная файловая ручка (или IO::Handle ),на которую будет распечатана выходная строка.</target>
        </trans-unit>
        <trans-unit id="2f9901f0f16239239419edd137f25118d48c58b4" translate="yes" xml:space="preserve">
          <source>An optional parameter can be nameless just like a mandatory parameter. For example,</source>
          <target state="translated">Дополнительный параметр может быть безымянным так же,как и обязательный параметр.Например,</target>
        </trans-unit>
        <trans-unit id="c0d6b2a0df46d7d7fb341e1412dc44bcca1bf51c" translate="yes" xml:space="preserve">
          <source>An optional part of a &lt;b&gt;subroutine&lt;/b&gt; declaration telling the Perl compiler how many and what flavor of arguments may be passed as &lt;b&gt;actual arguments&lt;/b&gt;, so you can write subroutine calls that parse much like built-in functions. (Or don&amp;rsquo;t parse, as the case may be.)</source>
          <target state="translated">Необязательная часть объявления &lt;b&gt;подпрограммы,&lt;/b&gt; сообщающая компилятору Perl, сколько аргументов и какой вид аргументов могут быть переданы в качестве &lt;b&gt;фактических аргументов&lt;/b&gt; , поэтому вы можете писать вызовы подпрограмм, которые анализируют так же, как встроенные функции. (Или не разбирайте, в зависимости от обстоятельств.)</target>
        </trans-unit>
        <trans-unit id="a21eb72be8656b34c88984249eec6f0bab32e544" translate="yes" xml:space="preserve">
          <source>An optional third parameter can be used to specify the buffer size used for copying. This is the number of bytes from the first file, that will be held in memory at any given time, before being written to the second file. The default buffer size depends upon the file, but will generally be the whole file (up to 2MB), or 1k for filehandles that do not reference files (eg. sockets).</source>
          <target state="translated">Необязательный третий параметр может быть использован для указания размера буфера,используемого для копирования.Это количество байт из первого файла,которое будет храниться в памяти в любой момент времени перед записью во второй файл.Размер буфера по умолчанию зависит от файла,но,как правило,это будет весь файл (до 2 МБ),или 1 кб для файловых хэндлов,которые не ссылаются на файлы (например,сокеты).</target>
        </trans-unit>
        <trans-unit id="0ba928fdaea76c696564501e58ec48f20c5c9dc1" translate="yes" xml:space="preserve">
          <source>An ordered sequence of &lt;b&gt;values&lt;/b&gt;, stored such that you can easily access any of the values using an</source>
          <target state="translated">Упорядоченная последовательность &lt;b&gt;значений&lt;/b&gt; , хранимая таким образом, что вы можете легко получить доступ к любому из значений с помощью</target>
        </trans-unit>
        <trans-unit id="2b793fb04f1842403dcb9eae8e630daf85625e60" translate="yes" xml:space="preserve">
          <source>An ordered set of scalar values.</source>
          <target state="translated">Заказанный набор скалярных значений.</target>
        </trans-unit>
        <trans-unit id="5c49a2821f5a5074f3f77a39e2cb0f3e615a425e" translate="yes" xml:space="preserve">
          <source>An ordinary disk file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77cc50988bf220f630f8fad5e50fc8b8f153295" translate="yes" xml:space="preserve">
          <source>An ordinary hard disk partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d009c1cdb4335605c0d3fe2975d2046a8496a5" translate="yes" xml:space="preserve">
          <source>An overview of the Perl interpreter source code and some details on how Perl does what it does.</source>
          <target state="translated">Обзор исходного кода Perl-интерпретатора и некоторые подробности о том,как Perl делает то,что он делает.</target>
        </trans-unit>
        <trans-unit id="bfd206b59d07c02456cd04b8e043a98488117f17" translate="yes" xml:space="preserve">
          <source>An overview of the Perl source tree. This will help you find the files you're looking for.</source>
          <target state="translated">Обзор дерева источников Perl.Это поможет вам найти нужные файлы.</target>
        </trans-unit>
        <trans-unit id="a982a39a2d5d6b9f37342b5e83c23e1f0856fa85" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) variable. You can try to provoke a fatal error with the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If not caught, the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">Неперехваченное &lt;b&gt;исключение&lt;/b&gt; , которое вызывает завершение &lt;b&gt;процесса&lt;/b&gt; после печати сообщения в &lt;b&gt;стандартном&lt;/b&gt; потоке &lt;b&gt;ошибок&lt;/b&gt; . Ошибки, происходящие внутри &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , не фатальны. Вместо этого &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; завершается после помещения сообщения об исключении в переменную &lt;code&gt;$@&lt;/code&gt; ( &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ). Вы можете попытаться спровоцировать фатальную ошибку с помощью оператора &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (так называемая генерация исключения), но это может быть обнаружено динамически включающим &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если его не поймать, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; становится фатальной ошибкой.</target>
        </trans-unit>
        <trans-unit id="f1a5d434a9faff9684c6af59ceb8c569c1859cc2" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;eval&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;eval&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt;) variable. You can try to provoke a fatal error with the &lt;code&gt;die&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;eval&lt;/code&gt;. If not caught, the &lt;code&gt;die&lt;/code&gt; becomes a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe98c7b5bde8acca47b9d777c6042909674e86b2" translate="yes" xml:space="preserve">
          <source>An unclosed formatting code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b48446507c5be16337d09d4b16f13d55933f7d" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip6_address is considered a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9293e352420d9fd32f5883ba4908461fd77eae" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip_address is considered a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54365bc1044b88eb77fbf7f1b4c0664f5bcb036c" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) are not emulated.</source>
          <target state="translated">Неопределенное значение не допускается в качестве разделителя записей. Специальная семантика Perl &quot;режим абзаца&quot; (а-ля &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) не эмулируется.</target>
        </trans-unit>
        <trans-unit id="0407455390a08706db99e80a71be456dbdff3c3e" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt;) are not emulated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b64166e760d6e4e08cfb550598a86717021fc931" translate="yes" xml:space="preserve">
          <source>An unnamed list of temporary scalar values that may be passed around within a program from any list-generating function to any function or construct that provides a &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">Безымянный список временных скалярных значений, которые могут быть переданы в программе из любой функции создания списка в любую функцию или конструкцию, которая предоставляет &lt;b&gt;контекст списка&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b7a4ac1dececd2f0138b0d9e87eae14a3bf0f323" translate="yes" xml:space="preserve">
          <source>An unordered association of &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pairs, stored such that you can easily use a string &lt;b&gt;key&lt;/b&gt; to look up its associated data &lt;b&gt;value&lt;/b&gt;. This glossary is like a hash, where the word to be defined is the key and the definition is the value. A hash is also sometimes septisyllabically called an &amp;ldquo;associative array&amp;rdquo;, which is a pretty good reason for simply calling it a &amp;ldquo;hash&amp;rdquo; instead.</source>
          <target state="translated">Неупорядоченная ассоциация пар &lt;b&gt;ключ&lt;/b&gt; / &lt;b&gt;значение&lt;/b&gt; , хранимая таким образом, что вы можете легко использовать строковый &lt;b&gt;ключ&lt;/b&gt; для поиска связанного с ним &lt;b&gt;значения&lt;/b&gt; данных . Этот глоссарий похож на хэш, где слово, которое нужно определить, является ключом, а определение - значением. Хэш также иногда септисложно называют &amp;laquo;ассоциативным массивом&amp;raquo;, что является довольно хорошей причиной для того, чтобы вместо этого просто называть его &amp;laquo;хешем&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b718389bf63428a7f7a0b8e8cfc5e0574b25619d" translate="yes" xml:space="preserve">
          <source>An unset or empty PERLIO is equivalent to the default set of layers for your platform; for example, &lt;code&gt;:unix:perlio&lt;/code&gt; on Unix-like systems and &lt;code&gt;:unix:crlf&lt;/code&gt; on Windows and other DOS-like systems.</source>
          <target state="translated">Неустановленный или пустой PERLIO эквивалентен набору слоев по умолчанию для вашей платформы; например &lt;code&gt;:unix:perlio&lt;/code&gt; в Unix-подобных системах и &lt;code&gt;:unix:crlf&lt;/code&gt; в Windows и других DOS-подобных системах.</target>
        </trans-unit>
        <trans-unit id="1b2099e63b3baac079849a311cb94bc9726d2b6a" translate="yes" xml:space="preserve">
          <source>An unsigned byte.</source>
          <target state="translated">Безымянный байт.</target>
        </trans-unit>
        <trans-unit id="17f8abaddabc70c518443c4340875b6f3d1f87f6" translate="yes" xml:space="preserve">
          <source>An unsigned integer.</source>
          <target state="translated">Беззнаковое целое число.</target>
        </trans-unit>
        <trans-unit id="6dc9fd633e86a9f8c5100a5a45701b6dac466c39" translate="yes" xml:space="preserve">
          <source>An upgrade to the PA-RISC design, it shipped for many years in many different system.</source>
          <target state="translated">Обновление конструкции PA-RISC,он поставлялся в течение многих лет в различных системах.</target>
        </trans-unit>
        <trans-unit id="05468cfd5e27b4298d95a71824d624b7c4dbc8a7" translate="yes" xml:space="preserve">
          <source>An xV that is visible at the Perl level should not become unreferenced and thus be destroyed. Normally, an object will only become unreferenced when it is no longer visible, often by the same means that makes it invisible. For example, a Perl reference value (RV) owns a reference to its referent, so if the RV is overwritten that reference gets destroyed, and the no-longer-reachable referent may be destroyed as a result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd7bedc3ca5ffad7ed1a2379448571632c9a196" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt; , there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt; .</source>
          <target state="translated">Аналогично &lt;code&gt;pTHX&lt;/code&gt; существуют эквивалентные формы, когда макрос является первым или последним в нескольких аргументах, где &lt;code&gt;_aMY_CXT&lt;/code&gt; подчеркивание представляет запятую, то есть _aMY_CXT , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; и &lt;code&gt;pMY_CXT_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39d947054eb91fd720a6dfc1c92ebab2af540974" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt;, there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt;, &lt;code&gt;aMY_CXT_&lt;/code&gt;, &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf45b9159d8cf5fded0f359396c02baabcce4fe" translate="yes" xml:space="preserve">
          <source>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</source>
          <target state="translated">Анализирует строку,чтобы сделать быстрый поиск по ней с помощью fbm_instr()--алгоритма Бойера-Мура.</target>
        </trans-unit>
        <trans-unit id="69b405aab620184a43024659654fa4b84c6160c1" translate="yes" xml:space="preserve">
          <source>Analyzes the string in order to make fast searches on it using &lt;code&gt;fbm_instr()&lt;/code&gt; -- the Boyer-Moore algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23a158b83cb28ac3361aeaadb0ea701f833add8" translate="yes" xml:space="preserve">
          <source>Anantha Kesari H Y (hyanantha@novell.com) Aditya C (caditya@novell.com)</source>
          <target state="translated">Ананта Кесари H Y (hyanantha@novell.com)Aditya C (caditya@novell.com)</target>
        </trans-unit>
        <trans-unit id="e7694709c56de3564de85fb7f6b62bf3f9d5a2dd" translate="yes" xml:space="preserve">
          <source>Anatomy of .xs file</source>
          <target state="translated">Анатомия файла .xs</target>
        </trans-unit>
        <trans-unit id="c371090fde9f09dd68fd0c025b019139f11c3b43" translate="yes" xml:space="preserve">
          <source>Anatomy of a typemap</source>
          <target state="translated">Анатомия типографской карты</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="126b187e44894c18f8676c982d3d84ada9d1092e" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56126a3ba8ff8d615bfc883458ff2ad74c4445f8" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">А &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; поддерживает счетчик нечетных бит:</target>
        </trans-unit>
        <trans-unit id="0fdb46cc394058268f8370b027acd6f7507ad5af" translate="yes" xml:space="preserve">
          <source>And a print to show what values we're currently using:</source>
          <target state="translated">И отпечаток,чтобы показать,какие ценности мы используем в настоящее время:</target>
        </trans-unit>
        <trans-unit id="3e6cfdab3639e924ccc0236d51702eea17278fbe" translate="yes" xml:space="preserve">
          <source>And add the following code to Mytest.t, while incrementing the &quot;11&quot; tests to &quot;13&quot;:</source>
          <target state="translated">И добавьте следующий код в Mytest.t,увеличив тесты &quot;11&quot; до &quot;13&quot;:</target>
        </trans-unit>
        <trans-unit id="7e934152fc5094b95aee4b1e3cfca4dfe3b716a5" translate="yes" xml:space="preserve">
          <source>And also add the following function definition to the end of the .xs file:</source>
          <target state="translated">А также добавить следующее определение функции в конец файла .xs:</target>
        </trans-unit>
        <trans-unit id="e095a5f2bc9f3ebef8eb601baecde5aacc183619" translate="yes" xml:space="preserve">
          <source>And an even parity bit can be determined like this:</source>
          <target state="translated">И бит четности может быть определен вот так:</target>
        </trans-unit>
        <trans-unit id="fa65fe1d258f3efe5fa4b14f6a4bdf869e0bca12" translate="yes" xml:space="preserve">
          <source>And don't forget, all commands but &lt;code&gt;=encoding&lt;/code&gt; last up until the end of its</source>
          <target state="translated">И не забывайте, что все команды, кроме &lt;code&gt;=encoding&lt;/code&gt; , действуют до конца своего</target>
        </trans-unit>
        <trans-unit id="d49f8a3fb63a02de3bc96673eb479046741fcd21" translate="yes" xml:space="preserve">
          <source>And elsewhere:</source>
          <target state="translated">И в другом месте:</target>
        </trans-unit>
        <trans-unit id="81cb3b2a1b531c9a6c9a5580cd54769bc7cdb329" translate="yes" xml:space="preserve">
          <source>And especially its subject 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d86ebfaa42125fcbf7621caf9b51d0d516488b0" translate="yes" xml:space="preserve">
          <source>And even if you take all the above into account, ANSI still lets this:</source>
          <target state="translated">И даже если учесть все вышесказанное,ANSI все равно позволяет это:</target>
        </trans-unit>
        <trans-unit id="7a24c6f39dbf571ec01b5431e8552ecca7394253" translate="yes" xml:space="preserve">
          <source>And finally create a file Makefile.PL that looks like this:</source>
          <target state="translated">И,наконец,создайте файл Makefile.PL,который выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="ae77b129ec8a4042483f52a6f594546db002727e" translate="yes" xml:space="preserve">
          <source>And finally we'll test that we don't make Unicode strings if &lt;code&gt;U&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; the first active format:</source>
          <target state="translated">И , наконец , мы протестируем , что мы не делаем строку Unicode , если &lt;code&gt;U&lt;/code&gt; является &lt;b&gt;не&lt;/b&gt; первым активным форматом:</target>
        </trans-unit>
        <trans-unit id="a3e1249d44e165c645bd656a34581eba0f8a1e5b" translate="yes" xml:space="preserve">
          <source>And finally, END OF CHARMAP ends the section.</source>
          <target state="translated">И,наконец,&quot;КОНЕЦ ЧАРМАП&quot; заканчивает раздел.</target>
        </trans-unit>
        <trans-unit id="2d457e986a9ae5a62a56559cd5a194f65f8d8696" translate="yes" xml:space="preserve">
          <source>And finally, in list context, it will try to extract as many objects from the stream as it can find and return them, or the empty list otherwise. For this to work, there must be no separators (other than whitespace) between the JSON objects or arrays, instead they must be concatenated back-to-back. If an error occurs, an exception will be raised as in the scalar context case. Note that in this case, any previously-parsed JSON texts will be lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa08a28d9fbfd1e04544d3cbe387157894102ef" translate="yes" xml:space="preserve">
          <source>And finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">И, наконец, разделители &lt;code&gt;//&lt;/code&gt; по умолчанию для совпадения можно заменить на произвольные, поставив перед ним &lt;code&gt;'m'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8bfb479933b19ce9cc3cdcd7ea52e1ab56622323" translate="yes" xml:space="preserve">
          <source>And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW flags.</source>
          <target state="translated">И,наконец,флаг UNICODE_WARN_ILLEGAL_INTERCHANGE выбирает все четыре вышеуказанных флага WARN,а UNICODE_DISALLOW_ILLEGAL_INTERCHANGE выбирает все четыре флага DISALLOW.</target>
        </trans-unit>
        <trans-unit id="805a895ac4ae294cb6372936f60badec42431ba0" translate="yes" xml:space="preserve">
          <source>And get the correct results.</source>
          <target state="translated">И получить правильные результаты.</target>
        </trans-unit>
        <trans-unit id="e2f2205f3663f3c210b60bce452eee7ce9387b44" translate="yes" xml:space="preserve">
          <source>And have a look at the return value:</source>
          <target state="translated">И посмотрите на возвратное значение:</target>
        </trans-unit>
        <trans-unit id="fbc4c3241647a832011ec07f9650e675a0c500ca" translate="yes" xml:space="preserve">
          <source>And here are some alternative portable ways to write them:</source>
          <target state="translated">И вот несколько альтернативных портативных способов их написания:</target>
        </trans-unit>
        <trans-unit id="dd7d82addca3d88c7a2654bf3c9e6dcef14475a8" translate="yes" xml:space="preserve">
          <source>And here is an example of</source>
          <target state="translated">И вот пример</target>
        </trans-unit>
        <trans-unit id="d607f0d907db7da1691c33f97b8d6b2f2769c71d" translate="yes" xml:space="preserve">
          <source>And here is some Perl to test it.</source>
          <target state="translated">И вот немного Перла,чтобы проверить его.</target>
        </trans-unit>
        <trans-unit id="eae54ac5b1d17fae865a39da8414bc4e94611b48" translate="yes" xml:space="preserve">
          <source>And here is the function from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a015e04d33b93191e1790b436d13c5a1d0ec08" translate="yes" xml:space="preserve">
          <source>And here is the previous example modified to use the &lt;code&gt;comment&lt;/code&gt; method (which requires the tied object):</source>
          <target state="translated">А вот предыдущий пример, измененный для использования метода &lt;code&gt;comment&lt;/code&gt; (для которого требуется связанный объект):</target>
        </trans-unit>
        <trans-unit id="949c884471ed5b1d107f6efb48c3d4a2b28f9c98" translate="yes" xml:space="preserve">
          <source>And here it is as a subroutine, modeled after the above:</source>
          <target state="translated">И вот она,как подпрограмма,смоделированная по вышеуказанному:</target>
        </trans-unit>
        <trans-unit id="33110031311636694f867a410fcd13fa8bb80c0c" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server to go along with it. We'll leave the address as &lt;code&gt;INADDR_ANY&lt;/code&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), fill this in with your real address instead.</source>
          <target state="translated">А вот и соответствующий сервер. Мы оставим адрес &lt;code&gt;INADDR_ANY&lt;/code&gt; , чтобы ядро ​​могло выбрать соответствующий интерфейс на многосетевых хостах. Если вы хотите работать с определенным интерфейсом (например, с внешней стороны шлюза или брандмауэра), укажите вместо этого свой реальный адрес.</target>
        </trans-unit>
        <trans-unit id="dbd6a4af2108db6ae982ecf10d7522ed7e526a16" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server. You don't have to worry about silly network terminators here because Unix domain sockets are guaranteed to be on the localhost, and thus everything works right.</source>
          <target state="translated">А вот и соответствующий сервер.Вам не нужно беспокоиться о глупых сетевых терминаторах здесь,потому что доменные сокеты Unix гарантированно находятся на локальном хосте,и таким образом все работает правильно.</target>
        </trans-unit>
        <trans-unit id="944b5652f25ab675361c7efd6d5681a5765fc752" translate="yes" xml:space="preserve">
          <source>And here's a multitasking version. It's multitasked in that like most typical servers, it spawns (fork()s) a slave server to handle the client request so that the master server can quickly go back to service a new client.</source>
          <target state="translated">А вот многозадачная версия.Она многозадачна в том,что,как и большинство типичных серверов,она порождает (fork()s)ведомый сервер для обработки запроса клиента,так что главный сервер может быстро вернуться к обслуживанию нового клиента.</target>
        </trans-unit>
        <trans-unit id="412d21e904b4a5d9be299f9e46dd7d8fb8650015" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">А вот повторная реализация оператора &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; в Perl :</target>
        </trans-unit>
        <trans-unit id="328ddc059366c7b26584066902e71a55942bcb50" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;grep&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39e0321aadc55f074a271968aaa41d7162f8c6f" translate="yes" xml:space="preserve">
          <source>And here's a safe pipe open for writing:</source>
          <target state="translated">А вот безопасная трубка,открытая для письма:</target>
        </trans-unit>
        <trans-unit id="e0737e576532a52571f2f02f804f1b9fffb668de" translate="yes" xml:space="preserve">
          <source>And here's how it could be (ab)used:</source>
          <target state="translated">И вот как это может быть использовано (ab):</target>
        </trans-unit>
        <trans-unit id="9d8d64c2d75cb873a59d78e68255422a53fcc02a" translate="yes" xml:space="preserve">
          <source>And here's how to start up a child process you intend to read from:</source>
          <target state="translated">И вот как запустить детский процесс,от которого ты собираешься читать:</target>
        </trans-unit>
        <trans-unit id="4c941c96c3f11d53f1f07f2e00498b7a8046f1f0" translate="yes" xml:space="preserve">
          <source>And here's the &lt;code&gt;HotKey&lt;/code&gt; module, which hides the somewhat mystifying calls to manipulate the POSIX termios structures.</source>
          <target state="translated">А вот модуль &lt;code&gt;HotKey&lt;/code&gt; , который скрывает несколько загадочные вызовы для управления структурами POSIX termios.</target>
        </trans-unit>
        <trans-unit id="c1de37a9a564348e268bb7765797260079df1212" translate="yes" xml:space="preserve">
          <source>And if it's an integer</source>
          <target state="translated">А если это целое число</target>
        </trans-unit>
        <trans-unit id="1e83d880ce4037fe2787ac7496582407c6b33838" translate="yes" xml:space="preserve">
          <source>And if the protocol you're using supports a way of letting the recipient know which character encoding you used, please help the receiving end by using that feature! For example, E-mail and HTTP support MIME headers, so you can use the &lt;code&gt;Content-Type&lt;/code&gt; header. They can also have &lt;code&gt;Content-Length&lt;/code&gt; to indicate the number of</source>
          <target state="translated">И если используемый вами протокол поддерживает способ сообщить получателю, какую кодировку символов вы использовали, пожалуйста, помогите принимающей стороне, используя эту функцию! Например, электронная почта и HTTP поддерживают заголовки MIME, поэтому вы можете использовать заголовок &lt;code&gt;Content-Type&lt;/code&gt; . Они также могут иметь &lt;code&gt;Content-Length&lt;/code&gt; , чтобы указать количество</target>
        </trans-unit>
        <trans-unit id="c041e6b2053eeffc72c3a76864ceba40caffea7d" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;&quot;*&quot;&lt;/code&gt;'s in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;&quot;*&quot;&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530bb41f401dd9a37c76bab8cac0844cf9ab82e0" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;*&lt;/code&gt; 's in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">И если вы использовали &lt;code&gt;*&lt;/code&gt; во внутренних группах вместо ограничения их совпадениями от 0 до 5, то это заняло бы вечность - или пока у вас не закончится место в стеке. Более того, эти внутренние оптимизации не всегда применимы. Например, если вы поместите &lt;code&gt;{0,5}&lt;/code&gt; вместо &lt;code&gt;*&lt;/code&gt; для внешней группы, текущая оптимизация не применима, и сопоставление займет много времени.</target>
        </trans-unit>
        <trans-unit id="85fb030d5b378f589d8d5a1abf4a0effa17a51ec" translate="yes" xml:space="preserve">
          <source>And if you want to repeat any previous command, use the exclamation: '&lt;b&gt;!&lt;/b&gt;':</source>
          <target state="translated">А если вы хотите повторить любую предыдущую команду, используйте восклицательный знак: ' &lt;b&gt;!&lt;/b&gt; ':</target>
        </trans-unit>
        <trans-unit id="e2e9c56949878c68d60537e13a0fee819e61a651" translate="yes" xml:space="preserve">
          <source>And if you want to update your remote-tracking branches for all defined remotes simultaneously you can do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ee0ae161979dc9986599ac47ae17f4297a5e95" translate="yes" xml:space="preserve">
          <source>And if you wanted to list line 5 again, type 'l 5', (note the space):</source>
          <target state="translated">И если вы хотите снова перечислить строку 5,наберите 'l 5',(обратите внимание на пробел):</target>
        </trans-unit>
        <trans-unit id="749d2869c6a2cd1160d264bfc5684c9df865e407" translate="yes" xml:space="preserve">
          <source>And if you're not writing a formatter class, but are instead just writing a program that does something simple with a Pod::PullParser object (and not an object of a subclass), then there's no reason to bother subclassing to add a &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">И если вы не пишете класс форматировщика, а вместо этого просто пишете программу, которая делает что-то простое с объектом Pod :: PullParser (а не объектом подкласса), тогда нет причин беспокоиться о создании подклассов, чтобы добавить &lt;code&gt;run&lt;/code&gt; метод.</target>
        </trans-unit>
        <trans-unit id="a90e884faa57a601f440de65c751d0540510d763" translate="yes" xml:space="preserve">
          <source>And in gdb do:</source>
          <target state="translated">И в gdb do:</target>
        </trans-unit>
        <trans-unit id="81cf331b9c5b31a88becd7901f7891213a4ee929" translate="yes" xml:space="preserve">
          <source>And in gdb:</source>
          <target state="translated">И в ГДБ:</target>
        </trans-unit>
        <trans-unit id="46441ba6d0d6e8d0a7cff3ad4e65de9157fcaa3a" translate="yes" xml:space="preserve">
          <source>And in the special case of Unix value 1 the encoding is:</source>
          <target state="translated">А в особом случае Unix значение 1-это кодировка:</target>
        </trans-unit>
        <trans-unit id="c703bcbb84cf0b00ade16c5fcf17098b7ecf2788" translate="yes" xml:space="preserve">
          <source>And it worked; nowadays, those legacy standards are rarely used. Most everyone uses Unicode.</source>
          <target state="translated">И это сработало,сейчас эти унаследованные стандарты используются редко.Большинство используют Юникод.</target>
        </trans-unit>
        <trans-unit id="54037314563b22510a39098497cd62d4a291d5ca" translate="yes" xml:space="preserve">
          <source>And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than waiting for the program to finish.</source>
          <target state="translated">И это тоже будет быстрее,так как мы можем начать обрабатывать stdout программы немедленно,а не ждать,пока программа закончится.</target>
        </trans-unit>
        <trans-unit id="05b8d44f52c6cb1137bdef7406a03b86305390f3" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt; :</source>
          <target state="translated">И непосредственно перед тем, как мы начнем цикл, мы установим &lt;code&gt;patcopy&lt;/code&gt; как начало &lt;code&gt;pat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1283b8c922466a3c7b07d1feee37151a4dce3090" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d9997bbf1b12f8dbc675ed04e53a7e01c218a79" translate="yes" xml:space="preserve">
          <source>And just use a multilevel hash to start with.</source>
          <target state="translated">И для начала используйте многоуровневый хэш.</target>
        </trans-unit>
        <trans-unit id="6f762806ee86000a08af1e9120bb69dbd27df3b8" translate="yes" xml:space="preserve">
          <source>And let's have a look at it:</source>
          <target state="translated">И давайте посмотрим на это:</target>
        </trans-unit>
        <trans-unit id="2fcd80e8aae7192e91938fbeb5e4135bca3cc513" translate="yes" xml:space="preserve">
          <source>And likewise, the &lt;code&gt;UNICODE_WARN_SUPER&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; flags affect the handling of code points that are above the Unicode maximum of 0x10FFFF. Languages other than Perl may not be able to accept files that contain these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3304a768e2182435437e989432d9119802e93fc2" translate="yes" xml:space="preserve">
          <source>And locally for months:</source>
          <target state="translated">И на местном уровне в течение нескольких месяцев:</target>
        </trans-unit>
        <trans-unit id="a3a5e5aaccae80b6482e3c73484c3e27d16e3695" translate="yes" xml:space="preserve">
          <source>And make sure the '|1' or '|3' entry FOLLOWS the '|0' entry.</source>
          <target state="translated">И убедитесь,что запись '|1' или '|3' содержит запись '|0'.</target>
        </trans-unit>
        <trans-unit id="13b0bb554f54abc8fbffc8c8994d2d663c4a335c" translate="yes" xml:space="preserve">
          <source>And make the &lt;code&gt;SHELL&lt;/code&gt; environment variable point to this</source>
          <target state="translated">И &lt;code&gt;SHELL&lt;/code&gt; переменная окружения SHELL указывает на это</target>
        </trans-unit>
        <trans-unit id="be7020a4d943fe59e561bee80058c6fdc65ab9a2" translate="yes" xml:space="preserve">
          <source>And more miscellaneous functions:</source>
          <target state="translated">И больше разных функций:</target>
        </trans-unit>
        <trans-unit id="a60081f8386184766dad1be5fdc437aa5eeeb0e1" translate="yes" xml:space="preserve">
          <source>And note that unlike the first example, this will permanently set &lt;code&gt;$^W&lt;/code&gt; since it cannot both run during compile-time and be localized to a run-time block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804a1ae29f0ee92582bcfc8bf24a3ed82f77d6d1" translate="yes" xml:space="preserve">
          <source>And note, that some items returned by &lt;code&gt;Localeconv&lt;/code&gt; are available through &lt;a href=&quot;perlapi#Perl_langinfo&quot;&gt;&quot;Perl_langinfo&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2abac4d1c06c7d4176cadc5fbb88490348f44bd" translate="yes" xml:space="preserve">
          <source>And now some examples as a list operator:</source>
          <target state="translated">А теперь несколько примеров в качестве оператора списка:</target>
        </trans-unit>
        <trans-unit id="325f253298d4946260db0eee17abb5d004c58cf0" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt; , the two values will be assigned as in:</source>
          <target state="translated">И теперь программа Perl вызывает &lt;code&gt;tzname&lt;/code&gt; , два значения будут назначены следующим образом:</target>
        </trans-unit>
        <trans-unit id="f59e966510e8c065dbf5dc3f3cc9146205ad5af4" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt;, the two values will be assigned as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d6d0f0cc9d0f09a7a155f9b933e949a3d93b8d" translate="yes" xml:space="preserve">
          <source>And now when we run it, we get &quot;\n&quot; still, but at least we know why. Just getting this script to compile has exposed the '$varl' (with the letter 'l') variable, and simply changing $varl to $var1 solves the problem.</source>
          <target state="translated">И теперь,когда мы его запускаем,мы все еще получаем &quot;\n&quot;,но,по крайней мере,мы знаем,почему.Простое получение этого скрипта для компиляции обнажило переменную '$varl' (с буквой 'l'),и простое изменение $varl на $var1 решает эту проблему.</target>
        </trans-unit>
        <trans-unit id="5ed144a58c9fd20df52c8636158ebb39098e1299" translate="yes" xml:space="preserve">
          <source>And now whenever either of those variables is accessed, its current system priority is retrieved and returned. If those variables are set, then the process's priority is changed!</source>
          <target state="translated">И теперь при каждом обращении к любой из этих переменных извлекается и возвращается ее текущий системный приоритет.Если эти переменные установлены,то изменяется приоритет процесса!</target>
        </trans-unit>
        <trans-unit id="f9560789fd59b77ec60e56d7ede2c768c8b84e1a" translate="yes" xml:space="preserve">
          <source>And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</source>
          <target state="translated">И теперь у вас будут дубликаты только тогда,когда сами ключи будут действительно одинаковыми.(Примечание:в версиях библиотеки db до примерно ноября 1996 года такие дубликаты ключей были сохранены,чтобы можно было восстановить исходные ключи в тех наборах ключей,которые сравнивались как равные).</target>
        </trans-unit>
        <trans-unit id="5a5750ab899553015c34706ef7f35d79aa761c9c" translate="yes" xml:space="preserve">
          <source>And of course a very basic test:</source>
          <target state="translated">И,конечно же,очень простой тест:</target>
        </trans-unit>
        <trans-unit id="892ba36b3022eacc3edbb4c21af99c36c593d715" translate="yes" xml:space="preserve">
          <source>And on the off chance you need a literal tilde in a bracket expression, you get it with &quot;~~&quot;.</source>
          <target state="translated">И на случай,если тебе понадобится буквальная тильда в скобках,ты получишь ее с &quot;~~&quot;.</target>
        </trans-unit>
        <trans-unit id="7c31eaf7ebf6ce5c72185594ad0e1b74e04b6fe1" translate="yes" xml:space="preserve">
          <source>And only on Solaris 8 you also need:</source>
          <target state="translated">И только на Солярисе 8 тебе тоже нужно:</target>
        </trans-unit>
        <trans-unit id="15fba9c4eb39007661b94becfb32901d56aa6cd3" translate="yes" xml:space="preserve">
          <source>And only the last two of these match:</source>
          <target state="translated">И только последние два из этих матчей:</target>
        </trans-unit>
        <trans-unit id="96df95971f3fa6b1c473a349d8884984b667322b" translate="yes" xml:space="preserve">
          <source>And other assignment variations are analogous to &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'-='&lt;/code&gt; (and similar to &lt;code&gt;'.='&lt;/code&gt; and &lt;code&gt;'x='&lt;/code&gt; above):</source>
          <target state="translated">И другие варианты присваивания аналогичны &lt;code&gt;'+='&lt;/code&gt; и &lt;code&gt;'-='&lt;/code&gt; (и аналогичны &lt;code&gt;'.='&lt;/code&gt; И &lt;code&gt;'x='&lt;/code&gt; выше):</target>
        </trans-unit>
        <trans-unit id="efa161d50be827f153878be8fe5d6eeddd3f9aab" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers.</source>
          <target state="translated">И,пожалуй,самое главное,сохранить последовательность элементов:либо использовать &quot;=пункт *&quot; для всех них,чтобы получить пули;либо использовать &quot;=пункт 1&quot;,&quot;=пункт 2&quot; и т.д.,чтобы получить пронумерованные списки;либо использовать &quot;=пункт foo&quot;,&quot;=пункт bar&quot; и т.д.и т.п.-то есть вещи,которые не похожи ни на пули,ни на числа.</target>
        </trans-unit>
        <trans-unit id="ac0a1fd097b0dfd986a143395713cf6857292218" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers. (If you have a list that contains both: 1) things that don't look like bullets nor numbers, plus 2) things that do, you should preface the bullet- or number-like items with &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;#Z%3C%3E-a-null-%28zero-effect%29-formatting-code&quot;&gt;Z&amp;lt;&amp;gt;&lt;/a&gt; below for an example.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b837400890ba807a5f5e88629d11f36f624c30a2" translate="yes" xml:space="preserve">
          <source>And pull new changes from the repository, and update your local repository (must be clean first)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abab37034be7516f5a858adebbbb45b8ced8395" translate="yes" xml:space="preserve">
          <source>And push the branch to your fork:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91e4f8b7302927647ddce5513c00f7d31bca99b" translate="yes" xml:space="preserve">
          <source>And since we're on that subject ...</source>
          <target state="translated">И раз уж мы заговорили об этом...</target>
        </trans-unit>
        <trans-unit id="787438686ae95a1032fa3a9e1aa177c6c4fd8565" translate="yes" xml:space="preserve">
          <source>And so do these:</source>
          <target state="translated">И это тоже:</target>
        </trans-unit>
        <trans-unit id="d57613d3e5e04fb527cb785d3cbc34d0addd45d8" translate="yes" xml:space="preserve">
          <source>And some of the entries are marked as &quot;undocumented&quot;. This means that they aren't necessarily considered stable, and could be changed or removed in some future release without warning. It is therefore a bad idea to use them without further checking. It could be that these are considered to be for perl core use only; or it could be, though, that &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't know where to find their documentation, or that it's just an oversight that they haven't been documented. If you want to use one, and potentially have it backported, first send mail to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a765d6600ae95d5f3b4bad120d6d7aba62ac6d" translate="yes" xml:space="preserve">
          <source>And success is always the value 0 in all behaviors.</source>
          <target state="translated">А успех всегда является ценностью 0 во всех поступках.</target>
        </trans-unit>
        <trans-unit id="438bed71f720bad1480f9f02fbee09a0688495fa" translate="yes" xml:space="preserve">
          <source>And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.</source>
          <target state="translated">И представьте,что вы отвечаете на запросы клиентов на языке $wanted,просто просматривая $greetings{$wanted}.</target>
        </trans-unit>
        <trans-unit id="2669b5893403010caa914594080405bbbce0ff5c" translate="yes" xml:space="preserve">
          <source>And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language. So an interaction looks like:</source>
          <target state="translated">И предположим,что Вы пишете программу,которая читает этот файл,а затем запускается как демон,отвечая на запросы клиентов,которые указывают языковой тег,а затем ожидаете строку,которая говорит,как приветствовать на этом языке.Итак,взаимодействие выглядит так:</target>
        </trans-unit>
        <trans-unit id="2df99fba715f8ad036f73439b0d1c572a25bb0d8" translate="yes" xml:space="preserve">
          <source>And that does the Right Thing.</source>
          <target state="translated">И это делает правильную вещь.</target>
        </trans-unit>
        <trans-unit id="f185ef04d67f1d1642dde1d5aaeb827268181df4" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">И здесь возникает первая причуда: шаблоны &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; должны быть заполнены кодами &lt;code&gt;x&lt;/code&gt; , чтобы получить эти дополнительные байты заполнения.</target>
        </trans-unit>
        <trans-unit id="faa61c2d15a96573c75e47bc47738ee4332bd44e" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c2e146487dcd6b006ca0fe732ee06c5f66c58a6" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;*&lt;/code&gt; quantifier (or its equivalent &lt;code&gt;(0,}&lt;/code&gt;) is illegal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c7d2fddd9456e1d45eb87fbe318da0c23d0419" translate="yes" xml:space="preserve">
          <source>And the removal of:</source>
          <target state="translated">И удаление:</target>
        </trans-unit>
        <trans-unit id="6321b918eecf63aae95252ec27d4a4007661cbea" translate="yes" xml:space="preserve">
          <source>And then at least you can use the values(), which will be real refs, instead of the keys(), which won't.</source>
          <target state="translated">И тогда,по крайней мере,вы можете использовать значения(),которые будут настоящими ссылками,вместо клавиш(),которые не будут.</target>
        </trans-unit>
        <trans-unit id="4c721f20845157aa106a3ca5329f5d50475f12f2" translate="yes" xml:space="preserve">
          <source>And then hard-code it, leaving porting as an exercise to your successor.</source>
          <target state="translated">А затем жестко закодируйте его,оставив портирование как упражнение для вашего преемника.</target>
        </trans-unit>
        <trans-unit id="47e6e2e5fec5f13213aa3c81c38b973ca1f59e41" translate="yes" xml:space="preserve">
          <source>And then instead of storing the compiled value in the lexicon hash it will store it in $lh-&amp;gt;{'_external_lex_cache'}</source>
          <target state="translated">А затем вместо сохранения скомпилированного значения в хэше словаря оно сохранит его в $ lh -&amp;gt; {'_ external_lex_cache'}</target>
        </trans-unit>
        <trans-unit id="4ddb0364527af5ee5b5762f819c0ea16f6ac0a17" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">А затем откройте, как и раньше, выбирая &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; или &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; мере необходимости:</target>
        </trans-unit>
        <trans-unit id="c1e2199a985f69bef0e671090e4f82d7d27c974b" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733e92d2677896a5105fc9334a5547dcbabc4286" translate="yes" xml:space="preserve">
          <source>And then provide a typemap entry &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; that maps underscores to double-colons (::), and declare &lt;code&gt;Net_Config&lt;/code&gt; to be of that type:</source>
          <target state="translated">А затем предоставьте запись &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; карты типов, которая сопоставляет подчеркивание с двойным двоеточием (: :), и объявите &lt;code&gt;Net_Config&lt;/code&gt; принадлежащим этому типу:</target>
        </trans-unit>
        <trans-unit id="0b78c6f57eb325a818fb40b5bb64b41ae51db883" translate="yes" xml:space="preserve">
          <source>And then replace the hash name with the reference:</source>
          <target state="translated">А затем замените имя хэша на ссылку:</target>
        </trans-unit>
        <trans-unit id="1482b41f1c8c23a1b6f51e392e8562858f488f4e" translate="yes" xml:space="preserve">
          <source>And then set PERL5LIB to</source>
          <target state="translated">А затем установите PERL5LIB в положение.</target>
        </trans-unit>
        <trans-unit id="e66399c5da24330a870822849d8e76cf4cddfe41" translate="yes" xml:space="preserve">
          <source>And then step until you hit what you're looking for. This works well in a loop if you want to only break at certain iterations:</source>
          <target state="translated">А потом шагай,пока не ударишь по тому,что ищешь.Это хорошо работает в петле,если вы хотите сломаться только на определенных итерациях:</target>
        </trans-unit>
        <trans-unit id="4fa5c1cdc4927fc4a1301e4902474775669ad62e" translate="yes" xml:space="preserve">
          <source>And these conditions hold</source>
          <target state="translated">И эти условия держат</target>
        </trans-unit>
        <trans-unit id="d5d9b0ee41acfcea7375d0a36877f181aee3c098" translate="yes" xml:space="preserve">
          <source>And they all mean exactly the same as this:</source>
          <target state="translated">И все они означают в точности то же самое:</target>
        </trans-unit>
        <trans-unit id="8536c300c45ef5952d0313ea8b714a35911f6d2e" translate="yes" xml:space="preserve">
          <source>And this example uses anonymous subroutines to create separate counters:</source>
          <target state="translated">И этот пример использует анонимные подпрограммы для создания отдельных счетчиков:</target>
        </trans-unit>
        <trans-unit id="2e09b2a3ab0575b70e3e084aed68993db1ebce78" translate="yes" xml:space="preserve">
          <source>And this is the XS code:</source>
          <target state="translated">А это код XS:</target>
        </trans-unit>
        <trans-unit id="0991be3e57b74fce439099710428de62b394a4a0" translate="yes" xml:space="preserve">
          <source>And this is the reason that many of the C library string handling functions should not be used. They don't cope with the full generality of Perl strings. It may be that your test cases don't have embedded &lt;code&gt;NUL&lt;/code&gt;s, and so the tests pass, whereas there may well eventually arise real-world cases where they fail. A lesson here is to include &lt;code&gt;NUL&lt;/code&gt;s in your tests. Now it's fairly rare in most real world cases to get &lt;code&gt;NUL&lt;/code&gt;s, so your code may seem to work, until one day a &lt;code&gt;NUL&lt;/code&gt; comes along.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0a495178fdf07510ea88975dd8d193311ceae6" translate="yes" xml:space="preserve">
          <source>And this is what the script above will print:</source>
          <target state="translated">И вот что напечатает вышеприведенный сценарий:</target>
        </trans-unit>
        <trans-unit id="f3108d27ee1408a1d7ae19ba3de728a5ab7ca78b" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot; in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35194f4922bc124f887493e5a4a0600918a32f35" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">И это еще не все. Начиная с Perl v5.12, строки, которые не закодированы в UTF-8, могут также обрабатываться как Unicode при различных условиях (см. &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;Правила ASCII и правила Unicode в perlunicode&lt;/a&gt; ). На самом деле это проблема только для символов, порядковые номера которых находятся в диапазоне от 128 до 255, и их поведение зависит от правил ASCII и Unicode в зависимости от вашего кода (см &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;. Ошибка Unicode в perlunicode&lt;/a&gt; ). Опубликованного API для решения этой проблемы не существует, поскольку он может быть изменен, но вы можете посмотреть код &lt;code&gt;pp_lc&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="04dc4562232363a5a2cdcef5ad0c57a632cc4d72" translate="yes" xml:space="preserve">
          <source>And this one reads from the child:</source>
          <target state="translated">А эта читает от ребёнка:</target>
        </trans-unit>
        <trans-unit id="22fab1b1ab24735dd2f54767a6ec2977de574611" translate="yes" xml:space="preserve">
          <source>And this too is valid:</source>
          <target state="translated">И это тоже относится к делу:</target>
        </trans-unit>
        <trans-unit id="ca100b799213c6d95d191edf790bdf80dab3cf7a" translate="yes" xml:space="preserve">
          <source>And this:</source>
          <target state="translated">И это:</target>
        </trans-unit>
        <trans-unit id="ca54ab72a0f62623ded9fadca0c4ae598b7f81fe" translate="yes" xml:space="preserve">
          <source>And to check the sequence in which the library directories are searched by perl, run</source>
          <target state="translated">А чтобы проверить последовательность поиска каталогов библиотеки по perl,выполните команду</target>
        </trans-unit>
        <trans-unit id="362fec7b951a6425bfa81311e580eeb12dfb603d" translate="yes" xml:space="preserve">
          <source>And to desurrogate;</source>
          <target state="translated">И десурротировать;</target>
        </trans-unit>
        <trans-unit id="2615ff8743f40d3114fe04e3d5a96ce87c8f4c9d" translate="yes" xml:space="preserve">
          <source>And try again:</source>
          <target state="translated">И попробуй еще раз:</target>
        </trans-unit>
        <trans-unit id="92794ee0d6f5c6f795ca92dffa6111092171b2bc" translate="yes" xml:space="preserve">
          <source>And we end up with the program:</source>
          <target state="translated">И мы заканчиваем с программой:</target>
        </trans-unit>
        <trans-unit id="fea4a67d42b69d2a6859a380b25f39bb4220097d" translate="yes" xml:space="preserve">
          <source>And whitespace may be used between the &lt;code&gt;~&lt;/code&gt; and quoted delimiters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397d92a7cd41c0dad432b26c8f27299cae1c6b41" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">И с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; по сути, это то же самое, что и код в UTF-8:</target>
        </trans-unit>
        <trans-unit id="5057821b43bf3328e6eb98ddc5e990c468614ce5" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;use encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b354e965b809ff14ff904fafbdc0b4de89c4bc4e" translate="yes" xml:space="preserve">
          <source>And with boolean methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd73bf27445a15ee33df36a7d8cf60d584177c03" translate="yes" xml:space="preserve">
          <source>And you can see the changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a140f07fc1f24b5deb3f2211fd3e22212c7dcd8" translate="yes" xml:space="preserve">
          <source>And you may also sense that you do not want to bother your translators with having to write Perl code -- you'd much rather that they spend their</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72514ebfb8885208b2209c125f8bbac4bdc3aa69" translate="yes" xml:space="preserve">
          <source>And you write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cc2408ca05432d5f7face5b62924a44acb8f84" translate="yes" xml:space="preserve">
          <source>And your caller module would be something like this:</source>
          <target state="translated">И твой вызывающий модуль был бы чем-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="f429519c2ad8f6db43559b6df0122aa7e92ef582" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">И, как вы заметили из предыдущего примера, если вы переопределите &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; , оператор &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob также переопределится.</target>
        </trans-unit>
        <trans-unit id="09ddb5c3e778ae1b6a95dadacffb550e09674ca1" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;glob&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f027b49b77d3cee2d1bd5a0ad1af1a5214bdb5ba" translate="yes" xml:space="preserve">
          <source>And, most importantly, there's all the practical details of how to actually go about deriving from Maketext so you can use it for your interfaces, and the various tools and conventions for starting out and maintaining individual language modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0872d4a5d2061a3d40ffa31b9853ff607e66e0c5" translate="yes" xml:space="preserve">
          <source>And, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">Кроме того, свойства Name и Name_Aliases доступны через интерполяцию &lt;code&gt;\N{}&lt;/code&gt; в строках с двойными кавычками и регулярных выражениях; и функции &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , и &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (которые требуют &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; должны быть указаны.</target>
        </trans-unit>
        <trans-unit id="a3d4a9b48a0e71abc1829b589dc1a4bb4344372b" translate="yes" xml:space="preserve">
          <source>And, there is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49cf0754660175d0a77b4c857d087e651cbf367" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt; , which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt; :</source>
          <target state="translated">А с Perl 5.10 и новее вам не нужно проверять наследование, чтобы увидеть, может ли объект обрабатывать роль. Для этого вы можете использовать &lt;code&gt;DOES&lt;/code&gt; из &lt;code&gt;UNIVERSAL&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="df1177936aa7e7d352017983c64995f489a2f05c" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt;, which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973c0aeb4f70654b3b70d2e3c1f5c993e73805e5" translate="yes" xml:space="preserve">
          <source>Andreas J. Koenig</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c4d01ab2b12800c7bf2f6468b98b449d53a99b" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &amp;lt;andk@cpan.org&amp;gt;, Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b41c9a4e6f27e4cb868723e388d3e3baf23ec77" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Андреас Кениг &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17721a7a6efc10cf2782e06109ae542e5e371c5d" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</source>
          <target state="translated">Андреас Кениг &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="f2f8905b2465e6f0ad9cfd91b9febf4156adfa14" translate="yes" xml:space="preserve">
          <source>Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Энди Армстонг &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d272317e48a940ed9b68adfad919572635019ce3" translate="yes" xml:space="preserve">
          <source>Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Энди Армстронг &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b85b5eb312e6917fec0aa730c7d70660252958f" translate="yes" xml:space="preserve">
          <source>Andy Armstrong, &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Энди Армстронг, &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9084574cd986898323dbe20b46abf1751fbbf849" translate="yes" xml:space="preserve">
          <source>Andy Broad &amp;lt;andy@broad.ology.org.uk&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9ef1486d01c7ad977376f692dc981d906e478c" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</source>
          <target state="translated">Энди Догерти &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Андреас Кёниг &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Тим Банс &lt;code&gt;timb@cpan.org&lt;/code&gt; . Поддержка VMS Чарльзом Бейли &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . Поддержка OS / 2 - Илья Захаревич &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54b2fb7511cb7a7c3493b4e0650ca3d85102f114" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt;, Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb884ee85ba557bf7e891804c953fd2fabe3f95" translate="yes" xml:space="preserve">
          <source>Andy Glew,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9371666f1dc2fa002dd7c688c18705bc84f8f9d0" translate="yes" xml:space="preserve">
          <source>Andy Lester</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f309e7ea03de47735dc8e5cfc8cc01f796755634" translate="yes" xml:space="preserve">
          <source>Anecdotal estimates of source-to-compiled code bloat suggest an eightfold increase. This means that the compiled form of reasonable (normally commented, properly indented etc.) code will take about eight times more space in memory than the code took on disk.</source>
          <target state="translated">Общая оценка разбухания исходного кода свидетельствует о восьмикратном увеличении.Это означает,что скомпилированный вид разумного (обычно комментируемого,с правильными отступами и т.д.)кода займет в памяти примерно в восемь раз больше места,чем код,взятый на диске.</target>
        </trans-unit>
        <trans-unit id="dd5ff38fa4ac27c93c3c6622ac77c49ca0b0e6b7" translate="yes" xml:space="preserve">
          <source>Angle brackets not written as &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; can potentially cause errors as they could be misinterpreted as markup commands. This is only printed when the -warnings level is greater than 1.</source>
          <target state="translated">Угловые скобки, не записанные как &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; , потенциально могут вызывать ошибки, поскольку их можно неправильно интерпретировать как команды разметки. Это печатается только тогда, когда уровень -warnings больше 1.</target>
        </trans-unit>
        <trans-unit id="4a0daf5f778b84f7d47324f4951f69110d4d48b4" translate="yes" xml:space="preserve">
          <source>Anno Siegel (ANNO) wrote the xs code and the changes in perl proper Jerry Hedden (JDHEDDEN) made it faster</source>
          <target state="translated">Анно Сигел (ANNO)написала код xs,а изменения в perl собственно Джерри Хеддена (JDHEDDEN)сделали это быстрее.</target>
        </trans-unit>
        <trans-unit id="602afe4dcabe1b2fe81bdeaea0130200ac9160dc" translate="yes" xml:space="preserve">
          <source>AnnoCPAN: Annotated CPAN documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa7bfd58b194e39ca2dde6c48f032e168048d8e" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">Аннотированный POD для &lt;a href=&quot;threads&quot;&gt;потоков&lt;/a&gt; : &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7858242352e2796cb227df6cabe7747dcc9c11c4" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba63b983b01c370d674ecdc009b4d7bcd13f4f33" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">Аннотированный POD для &lt;a href=&quot;threads/shared&quot;&gt;потоков :: общий&lt;/a&gt; : &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ff3b3d306ae85d31c9461b66532ebdda6c7e205" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0700dd0d246c337cd6fa922a92caa253e25b21" translate="yes" xml:space="preserve">
          <source>Annotated list of characters</source>
          <target state="translated">Аннотированный список персонажей</target>
        </trans-unit>
        <trans-unit id="c10f845c88bdb301cd3ade696bdf99cccd4ed1f0" translate="yes" xml:space="preserve">
          <source>Annotated tags in the canonical perl.git repository will never be deleted or modified. Think long and hard about whether you want to push a local tag to perl.git before doing so. (Pushing simple tags is not allowed.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5154e030234862764507248749c6a7c751b8bc6" translate="yes" xml:space="preserve">
          <source>Anonymous Subroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911169a23e106a872e476c8d2fa5935672c571c0" translate="yes" xml:space="preserve">
          <source>Anonymous hash and array composers like these can be intermixed freely to produce as complicated a structure as you want. The multidimensional syntax described below works for these too. The values above are literals, but variables and expressions would work just as well, because assignment operators in Perl (even within local() or my()) are executable statements, not compile-time declarations.</source>
          <target state="translated">Анонимные композиторы хэшей и массивов,подобные этим,могут свободно перемешиваться,чтобы создать такую сложную структуру,какую Вы захотите.Многомерный синтаксис,описанный ниже,тоже подходит для этих работ.Вышеуказанные значения являются литералами,но переменные и выражения будут работать так же хорошо,потому что операторы присваивания в Perl (даже внутри local()или my())являются исполняемыми операторами,а не объявлениями времени компиляции.</target>
        </trans-unit>
        <trans-unit id="ddd265fb1f3b46963f4185e092c2f56d761a6e96" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines act as closures with respect to my() variables, that is, variables lexically visible within the current scope. Closure is a notion out of the Lisp world that says if you define an anonymous function in a particular lexical context, it pretends to run in that context even when it's called outside the context.</source>
          <target state="translated">Анонимные подпрограммы действуют как закрывающие переменные my(),т.е.переменные,лексически видимые в текущей области видимости.Закрытие-это понятие из мира Lisp,которое гласит,что если вы определяете анонимную функцию в определённом лексическом контексте,она делает вид,что выполняется в этом контексте,даже когда она вызывается вне контекста.</target>
        </trans-unit>
        <trans-unit id="3eb95879a615d5ea34c741b40bf67030c1977968" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">Анонимные подпрограммы захватывают каждый раз, когда вы выполняете &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; оператор, поскольку они создаются на лету. Если вы привыкли использовать вложенные подпрограммы на других языках программирования с их собственными частными переменными, вам придется немного поработать над этим в Perl. Интуитивно понятное кодирование этого типа вещей вызывает загадочные предупреждения о том, что &amp;laquo;не будут использоваться совместно&amp;raquo; по причинам, описанным выше. Например, это не сработает:</target>
        </trans-unit>
        <trans-unit id="484e8735a38d0b2c3316b6b4767502150b9246c0" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;sub&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0878cc2f5c4c23ed0c52c0dfcedfeb6916f96a7" translate="yes" xml:space="preserve">
          <source>Another Example</source>
          <target state="translated">Другой пример</target>
        </trans-unit>
        <trans-unit id="58127100a894b61eeb7ff5e87057e807d55c8b96" translate="yes" xml:space="preserve">
          <source>Another Example -- Key is a C int.</source>
          <target state="translated">Другой пример...Ключ-это C int.</target>
        </trans-unit>
        <trans-unit id="60d38257f9d2129e1058114b1893e74a3db974bb" translate="yes" xml:space="preserve">
          <source>Another Example: Key is a C int.</source>
          <target state="translated">Еще один пример:Ключ-C int.</target>
        </trans-unit>
        <trans-unit id="c610761bff33dc8f8934a509a66662b8c1def3f8" translate="yes" xml:space="preserve">
          <source>Another P5P contributor recommended installation and use of Devel::PatchPerl for this situation, first to determine the version of perl at the commit in question, then to patch the source code at that point to facilitate a build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5842d0c6f0b2a32d5a2aac4ce0ec4bcd453989" translate="yes" xml:space="preserve">
          <source>Another Portable Binary Encoding</source>
          <target state="translated">Другое портативное двоичное кодирование</target>
        </trans-unit>
        <trans-unit id="a3a811e6345c52a72030025da749e7378837c8a7" translate="yes" xml:space="preserve">
          <source>Another brief debugger, slightly more useful, can be created with only the line:</source>
          <target state="translated">Еще один краткий отладчик,немного более полезный,может быть создан только с помощью строки:</target>
        </trans-unit>
        <trans-unit id="723c39858f051ddac15e8257e9c5bc5481712afe" translate="yes" xml:space="preserve">
          <source>Another common error is to use ordinary parentheses to construct a list reference when you should be using square or curly brackets, for example, if you say</source>
          <target state="translated">Другая распространенная ошибка-использование обычных круглых скобок для построения ссылки на список,когда вы должны использовать квадратные или фигурные скобки,например,если вы говорите</target>
        </trans-unit>
        <trans-unit id="989f6c267d1aa6631d47641c01947fa297495517" translate="yes" xml:space="preserve">
          <source>Another common use for this construct is when you need to execute something without the shell's interference. With system(), it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call exec() directly.</source>
          <target state="translated">Другое распространенное применение этой конструкции-когда нужно выполнить что-то без вмешательства оболочки.С помощью system()это просто,но вы не можете безопасно использовать открытую трубу или черные метки.Это потому,что нет способа остановить оболочку от получения ваших аргументов.Вместо этого используйте контроль нижнего уровня для прямого вызова функции exec().</target>
        </trans-unit>
        <trans-unit id="948bec86ec25e1c793c75848e3f095908f00b9e7" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;&quot;Unicode and Localisation Support&quot;&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. This is another instance where the parsing needs to be restarted, and it can and is done immediately. The function returns failure, and sets the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; (encapsulated by using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt;). This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79a0e3805beb03c075ab9c59ea2fd3f85cbbe5" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode and Localisation Support&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. Currently, all regular expression constructions which can trigger this are parsed by code in &lt;code&gt;regatom()&lt;/code&gt; .</source>
          <target state="translated">Еще одна сложность заключается в том, что представление, используемое для программы, отличается, если ей нужно хранить Unicode, но не всегда можно точно узнать, работает ли он до середины анализа. Юникодное представление программы больше и не может быть сопоставлено так эффективно. (См. Ниже &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode и Поддержка локализации&lt;/a&gt; для более подробной информации о том, почему.) Если шаблон содержит буквальный Unicode, очевидно, что программе необходимо сохранить Unicode. В противном случае синтаксический анализатор оптимистично предполагает, что можно использовать более эффективное представление, и начинает определять размер на этой основе. Однако, если он затем обнаруживает что-то в шаблоне, которое должно быть сохранено как Unicode, например &lt;code&gt;\x{...}&lt;/code&gt; escape-последовательность, представляющая символьный литерал, тогда это означает, что все ранее рассчитанные размеры необходимо переделать, используя значения, подходящие для представления Unicode. В настоящее время все конструкции регулярных выражений, которые могут вызвать это, анализируются кодом в &lt;code&gt;regatom()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b313efb71a57a4464cb94a659a9e8b90c24250e" translate="yes" xml:space="preserve">
          <source>Another confusion with both these properties is that the definition is not that the code point has been</source>
          <target state="translated">Другая путаница с обоими этими свойствами заключается в том,что определение не является тем,что точка кода была</target>
        </trans-unit>
        <trans-unit id="8de6445149b9f420296053261c9997adf2340600" translate="yes" xml:space="preserve">
          <source>Another consequence of using &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt;, the I/O subsystem will regard it as the end of the file, unless you use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7643f36484ae100d2da2d3c144ef9dbeaed949e" translate="yes" xml:space="preserve">
          <source>Another consequence of using binmode() (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt; , the I/O subsystem will regard it as the end of the file, unless you use binmode().</source>
          <target state="translated">Еще одним следствием использования binmode () (в некоторых системах) является то, что специальные маркеры конца файла будут рассматриваться как часть потока данных. Для систем из семейства Microsoft это означает, что если ваши двоичные данные содержат &lt;code&gt;\cZ&lt;/code&gt; , подсистема ввода-вывода будет рассматривать их как конец файла, если вы не используете binmode ().</target>
        </trans-unit>
        <trans-unit id="3cc44056a9f339f4466b010a8b6a440f514bb627" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt; ) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">Еще одна конструкция, которой следует опасаться, - это неправильное использование шестнадцатеричных (если вы не используете &lt;code&gt;\N{U+...}&lt;/code&gt; ) или восьмеричных констант в регулярных выражениях. Рассмотрим следующий набор сабвуферов:</target>
        </trans-unit>
        <trans-unit id="4bdabce8c57375ff87d8b683a0b4feedd678dfa2" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt;) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd580d9d1c12fa08ea2d8378d289e2825dd48a0c" translate="yes" xml:space="preserve">
          <source>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;. All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen. This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.</source>
          <target state="translated">Другое описание начинается с понятия &quot;лучше&quot;/&quot;хуже&quot;.Все подстроки,которым может соответствовать данное регулярное выражение,могут быть отсортированы от &quot;лучшего&quot; соответствия к &quot;худшему&quot;,и выбирается &quot;лучшее&quot; соответствие.Это заменяет вопрос &quot;что выбрано?&quot; на вопрос &quot;какие совпадения лучше,а какие хуже?&quot;.</target>
        </trans-unit>
        <trans-unit id="856a6f6c8652259321cab00a9ad8f033dc81e6f4" translate="yes" xml:space="preserve">
          <source>Another drawback is only valid for Perl versions before 5.6.0. This drawback is that the seek and tell functions (both the builtin version and POSIX module version) will not perform correctly.</source>
          <target state="translated">Другой недостаток действителен только для версий Perl до 5.6.0.Этот недостаток заключается в том,что функции поиска и оповещения (как встроенная версия,так и версия POSIX-модуля)работают некорректно.</target>
        </trans-unit>
        <trans-unit id="d8eeb28f49e1f9d89b4e036aaf71838ed7700dd9" translate="yes" xml:space="preserve">
          <source>Another dummy layer. When pushed it pops itself and sets the &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; flag on the layer which was (and now is once more) the top of the stack.</source>
          <target state="translated">Еще один слой-пустышка. При нажатии он появляется и устанавливает флаг &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; на слое, который был (и теперь снова является) верхним в стеке.</target>
        </trans-unit>
        <trans-unit id="d9e8985e4a56d117b356dcbeb0c42c3cbcba847b" translate="yes" xml:space="preserve">
          <source>Another example of a data paragraph:</source>
          <target state="translated">Еще один пример параграфа с данными:</target>
        </trans-unit>
        <trans-unit id="b5c62d28b9310748f7a00e0cde763766b0ceff47" translate="yes" xml:space="preserve">
          <source>Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:</source>
          <target state="translated">Другой пример переключил первую кодировку &quot;latin1&quot;,которую он находит,на &quot;utf8&quot; в файле pod:</target>
        </trans-unit>
        <trans-unit id="50f1426af11ad7a924141e38d176e901ed8b9c69" translate="yes" xml:space="preserve">
          <source>Another example that shows that within &lt;code&gt;\p{...}&lt;/code&gt;, &lt;code&gt;/x&lt;/code&gt; isn't needed to have spaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">Еще один пример:</target>
        </trans-unit>
        <trans-unit id="ece934d7c44856dd3f545147d03b2aa737a1de6d" translate="yes" xml:space="preserve">
          <source>Another form of code expression is the</source>
          <target state="translated">Другой формой кодового выражения является</target>
        </trans-unit>
        <trans-unit id="48b78ab1e531e9b3794c2d43c0589ca792ae0b42" translate="yes" xml:space="preserve">
          <source>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The &lt;code&gt;TAIL&lt;/code&gt; regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the &lt;code&gt;TAIL&lt;/code&gt; point to the thing that &lt;code&gt;TAIL&lt;/code&gt; points to, thus &quot;skipping&quot; the node.</source>
          <target state="translated">Другая форма оптимизации, которая может иметь место, - это оптимизация &amp;laquo;на глазок&amp;raquo; после анализа, когда неэффективные конструкции заменяются более эффективными. В &lt;code&gt;TAIL&lt;/code&gt; regops , которые используются в ход синтаксического анализа , чтобы отметить конец ветвей и конец групп являются примерами этого. Эти регопы используются в качестве заполнителей во время построения и &amp;laquo;всегда совпадают&amp;raquo;, поэтому их можно &amp;laquo;оптимизировать&amp;raquo;, сделав то, что указывает на &lt;code&gt;TAIL&lt;/code&gt; , на то, на что указывает &lt;code&gt;TAIL&lt;/code&gt; , таким образом &amp;laquo;пропуская&amp;raquo; узел.</target>
        </trans-unit>
        <trans-unit id="6a81857ae4b443a44f359782c057cbbbeb457048" translate="yes" xml:space="preserve">
          <source>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</source>
          <target state="translated">Еще одна весомая причина,помимо удобочитаемости и удобства обслуживания для использования относительных ссылок,проиллюстрирована следующим примером,в котором используется простой шаблон для сопоставления специфических строк:</target>
        </trans-unit>
        <trans-unit id="bfac64b9584bc828981db16d0cc4e6658be646cc" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">Еще один интересный подход к IPC - сделать вашу единственную программу многопроцессорной и обмениваться данными между вами или даже между вами. Функция open () примет аргумент файла либо &lt;code&gt;&quot;-|&quot;&lt;/code&gt; или &lt;code&gt;&quot;|-&quot;&lt;/code&gt; чтобы сделать очень интересную вещь: он разветвляет дочерний элемент, связанный с указателем файла, который вы открыли. Ребенок выполняет ту же программу, что и родитель. Это полезно, например, для безопасного открытия файла при работе с предполагаемым UID или GID. Если вы откроете трубу</target>
        </trans-unit>
        <trans-unit id="4522d51a25407d48caa1899497ae3f892458c192" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The two-argument form of the open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075cc903bac6f7e2aa6bd64ab5e44c58b488750c" translate="yes" xml:space="preserve">
          <source>Another interesting signal to send is signal number zero. This doesn't actually affect a child process, but instead checks whether it's alive or has changed its UIDs.</source>
          <target state="translated">Еще один интересный сигнал для отправки-это сигнал нулевого номера.На самом деле это не влияет на дочерний процесс,а вместо этого проверяет,жив ли он или изменил свои UID.</target>
        </trans-unit>
        <trans-unit id="5625c9da79ea74fa11d7487b4856a60b8a448f5c" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function, available at least in Unix-like systems and VMS.</source>
          <target state="translated">Другой интерфейс для запроса информации, зависящей от локали, - это &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; , доступная по крайней мере в Unix-подобных системах и VMS.</target>
        </trans-unit>
        <trans-unit id="b2c6ea999a64bd42bd0c393eb0d4d13d68bfe00e" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0169360cab902c54c29d1ed679e73f96ea0a5a" translate="yes" xml:space="preserve">
          <source>Another is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdba3e1788bc415b19d9a9a11cdf704cabf535e" translate="yes" xml:space="preserve">
          <source>Another kind of client-server setup is one that uses not connections, but messages. UDP communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, UDP offers some advantages over TCP, including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just TCP to start with.</source>
          <target state="translated">Другой тип настройки клиент-сервер-это такая настройка,при которой используются не соединения,а сообщения.UDP-соединения связаны со значительно меньшими накладными расходами,но при этом обеспечивают меньшую надежность,так как нет никаких обещаний,что сообщения будут поступать вообще,не говоря уже о том,что они будут упорядочены и не запутаны.Тем не менее,UDP предлагает некоторые преимущества перед TCP,в том числе возможность &quot;широковещательной&quot; или &quot;многоадресной&quot; рассылки на целую кучу хостов назначения одновременно (обычно в вашей локальной подсети).Если Вас слишком беспокоит надежность и Вы начинаете строить проверки в Вашей системе сообщений,то для начала,вероятно,Вам следует использовать только TCP.</target>
        </trans-unit>
        <trans-unit id="15bc936b8bd7810df3b41eba0889fe66dfa9061e" translate="yes" xml:space="preserve">
          <source>Another memory limiting item to check is your MAXASSIZE parameter in your 'SYS1.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space limits can be set on a per user ID basis in the USS segment of a RACF profile). People have reported successful builds of Perl with MAXASSIZE parameters as small as 503316480 (and it may be possible to build Perl with a MAXASSIZE smaller than that).</source>
          <target state="translated">Другой элемент ограничения памяти для проверки-параметр MAXASSIZE в наборе данных 'SYS1.PARMLIB(BPXPRMxx)' (также обратите внимание,что,начиная с V2R8,ограничения адресного пространства могут быть установлены на основе идентификатора пользователя в USS-сегменте профиля RACF).Сообщалось об успешных сборках Perl с параметрами MAXASSIZE размером всего 503316480 (и возможно построить Perl с MAXASSIZE размером меньше этого).</target>
        </trans-unit>
        <trans-unit id="7f12c23dd22baed9e55a21bc829f2cdbb2990e89" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (without swearing) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce05ce9dfc0d776de0b8b42183a9011dbca61f46" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (printable) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">Другой мнемоник для этого модификатора - &amp;laquo;Зависит&amp;raquo;, поскольку фактически используемые правила зависят от разных вещей, и в результате вы можете получить неожиданные результаты. См &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;. Ошибку Unicode в perlunicode&lt;/a&gt; . Ошибка Unicode стала довольно печально известной, что привело к появлению еще одного (печатаемого) имени для этого модификатора - &amp;laquo;Dodgy&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="df7cbfe3fb975c17e692f6a855e0332ef03824f0" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension to the JSON syntax, enabled with the &lt;code&gt;allow_tags&lt;/code&gt; setting, are tagged values. In this implementation, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfb16782780267975128af9b462f0c7f8f09971" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt; , which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">Еще одна необычная особенность в алфавите шаблонов - &lt;code&gt;u&lt;/code&gt; , которая содержит &amp;laquo;строку uuencoded&amp;raquo;. (&amp;laquo;uu&amp;raquo; - это сокращение от Unix-to-Unix.) Скорее всего, вам никогда не понадобится этот метод кодирования, который был изобретен для преодоления недостатков устаревших сред передачи, которые не поддерживают другие данные, кроме простых данных ASCII. Основной рецепт прост: возьмите три байта или 24 бита. Разделите их на 4 упаковки по шесть штук, добавив к каждой пробел (0x20). Повторяйте, пока все данные не будут объединены. Сложите группы по 4 байта в строки длиной не более 60 и украсьте их перед исходным счетчиком байтов (увеличенным на 0x20) и &lt;code&gt;&quot;\n&quot;&lt;/code&gt; в конце. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; повар будет готовить это для вас, а - ля минут, при выборе кода пакета &lt;code&gt;u&lt;/code&gt; в меню:</target>
        </trans-unit>
        <trans-unit id="0815afa133e3357f3c224c29010f1fab6f9eb77d" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt;, which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;pack&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b90d55edc9bd711b381039fe4df0f81ca8e910" translate="yes" xml:space="preserve">
          <source>Another operator with surprising precedence is exponentiation. It binds more tightly even than unary minus, making &lt;code&gt;-2**2&lt;/code&gt; produce a negative four and not a positive one. It is also right-associating, meaning that &lt;code&gt;2**3**2&lt;/code&gt; is two raised to the ninth power, not eight squared.</source>
          <target state="translated">Другой оператор с удивительным приоритетом - возведение в степень. Он связывает более плотно, чем унарный минус, поэтому &lt;code&gt;-2**2&lt;/code&gt; дает отрицательную четверку, а не положительную. Это также ассоциируется справа, что означает, что &lt;code&gt;2**3**2&lt;/code&gt; - это два в девятой степени, а не восемь в квадрате.</target>
        </trans-unit>
        <trans-unit id="0a8ead7308fc061719df6bc244f6348d6cfaf232" translate="yes" xml:space="preserve">
          <source>Another optimisation that can occur is that of &quot;&lt;code&gt;EXACT&lt;/code&gt; merging&quot; which is where two consecutive &lt;code&gt;EXACT&lt;/code&gt; nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; can be converted into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</source>
          <target state="translated">Другая возможная оптимизация - это &amp;laquo; &lt;code&gt;EXACT&lt;/code&gt; слияние&amp;raquo;, при котором два последовательных &lt;code&gt;EXACT&lt;/code&gt; узла объединяются в одну регистрацию. Еще более агрессивная форма этого состоит в том, что последовательность ветвлений в формате &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; может быть преобразована в &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</target>
        </trans-unit>
        <trans-unit id="bd2c2ceaa1b82e7064a95fc5a1daa0bbc069a63f" translate="yes" xml:space="preserve">
          <source>Another option for Perls starting with 5.16, if you only care about ASCII matches, is to add the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex. This will exclude all these non-obvious matches, thus getting rid of this message. You can also say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aabd99f333ab712e259e5fbe14c5365c3fb3eb5" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">Другой вариант - использовать метод класса &lt;code&gt;iter&lt;/code&gt; для перебора файлов в архиве без одновременного чтения их всех в памяти.</target>
        </trans-unit>
        <trans-unit id="82d37f84faabd12d777cc2ff160de45bc66b098d" translate="yes" xml:space="preserve">
          <source>Another option is to use the make written in Perl, available from CPAN.</source>
          <target state="translated">Другой вариант-использовать make написанный на Perl,доступный в CPAN.</target>
        </trans-unit>
        <trans-unit id="655a86d88b6839dd2179128ff91b78ce22ba6c96" translate="yes" xml:space="preserve">
          <source>Another peculiarity of urllist is that the site that we could successfully fetch the last file from automatically gets a preference token and is tried as the first site for the next request. So if you add a new site at runtime it may happen that the previously preferred site will be tried another time. This means that if you want to disallow a site for the next transfer, it must be explicitly removed from urllist.</source>
          <target state="translated">Еще одной особенностью urllist'а является то,что сайт,с которого мы смогли успешно получить последний файл,автоматически получает маркер предпочтений и пытается как первый сайт для следующего запроса.Так что если вы добавите новый сайт во время выполнения,то может случиться так,что ранее предпочитаемый сайт будет опробован в другой раз.Это означает,что если вы хотите запретить сайт для следующей передачи,он должен быть явно удален из urllist'а.</target>
        </trans-unit>
        <trans-unit id="ce6cb12c61e008cd3f2b006405f6306cfa9808f3" translate="yes" xml:space="preserve">
          <source>Another point worth noting is that in the first series of examples I have made use of only the</source>
          <target state="translated">Еще один момент,на который стоит обратить внимание,заключается в том,что в первой серии примеров я использовал только</target>
        </trans-unit>
        <trans-unit id="4398365ad3174110f099b9553fe6a9ab1f982409" translate="yes" xml:space="preserve">
          <source>Another popular use for &lt;code&gt;recompile&lt;/code&gt; is to act as a rescue in case your perl breaks binary compatibility. If one of the modules that CPAN uses is in turn depending on binary compatibility (so you cannot run CPAN commands), then you should try the CPAN::Nox module for recovery.</source>
          <target state="translated">Еще одно популярное применение &lt;code&gt;recompile&lt;/code&gt; - это спасение, если ваш Perl нарушает двоичную совместимость. Если один из модулей, которые использует CPAN, в свою очередь зависит от двоичной совместимости (поэтому вы не можете запускать команды CPAN), вам следует попробовать модуль CPAN :: Nox для восстановления.</target>
        </trans-unit>
        <trans-unit id="9d8cd00450b93b9762fe1f4860bcee6a18ea20de" translate="yes" xml:space="preserve">
          <source>Another possibility is that you forgot a backslash. Perl isn't smart enough to figure out what you really meant.</source>
          <target state="translated">Другая возможность-это то,что ты забыл обратный слеш.Перл недостаточно умен,чтобы понять,что ты на самом деле имел в виду.</target>
        </trans-unit>
        <trans-unit id="385e095c764654e0fb183ec8deedb8c0e3232a76" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement instead of &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">Другая возможная причина проблем заключается в том, что вы использовали синтаксис косвенного объекта (например, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) в имени класса до того, как Perl обнаружил, что такой пакет существует. Лучше всего убедиться, что все ваши пакеты определены, прежде чем вы начнете их использовать, о чем позаботятся, если вы будете &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; оператор use вместо &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; . Если нет, не забудьте вместо этого использовать стрелку (например, &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ). Обозначение объекта объясняется в &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb10e4ab85598fb1febe5de364db832f8ae6b33d" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt;) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;use&lt;/code&gt; statement instead of &lt;code&gt;require&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt;) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c972997167e011df9a56046ecd4a5023cc5037ca" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">Еще одна проблема, которая возникает с классами наизнанку, - это сериализация. Поскольку данные объекта находятся не на своем обычном месте, стандартные процедуры, такие как &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; и &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; не могут справиться с ними самостоятельно. И &lt;code&gt;Data::Dumper&lt;/code&gt; и &lt;code&gt;Storable&lt;/code&gt; предоставляют необходимые перехватчики для работы, но функции или методы, используемые перехватчиками, должны предоставляться каждым внутренним классом.</target>
        </trans-unit>
        <trans-unit id="0ea375285a64fb396aba7ed50ea3def9a1613d41" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt;, &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4838334963e3cee1c557a4f6afcd664375d054be" translate="yes" xml:space="preserve">
          <source>Another problem with this approach is that operations that cross the single byte/multiple byte boundary are not well-defined, and so are disallowed. (This boundary is between the codepoints at 255/256.) For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF). But in the Greek locale, for example, there is no character at 0xFF, and Perl has no way of knowing what the character at 0xFF is really supposed to represent. Thus it disallows the operation. In this mode, the lowercase of U+0178 is itself.</source>
          <target state="translated">Другая проблема такого подхода заключается в том,что операции,пересекающие границу одного байта/множества байтов,плохо определены,а значит,запрещены.(Эта граница находится между кодовыми точками на 255/256.)Например,нижняя обсадная труба LATIN CAPITAL LETTER Y W WITH DIAERESIS (U+0178)должна возвращать LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF).Но в греческой локали,например,нет символа в 0xFF,и Perl не имеет возможности узнать,что на самом деле должен представлять символ в 0xFF.Таким образом,это не позволяет выполнить операцию.В этом режиме младший регистр U+0178 сам по себе.</target>
        </trans-unit>
        <trans-unit id="e3482e337a3d87721af4bdffd6d9b7cb27fdfc8f" translate="yes" xml:space="preserve">
          <source>Another reason it isn't completely a drop-in replacement is that it is declared to return &lt;code&gt;const char *&lt;/code&gt;, whereas the system setlocale omits the &lt;code&gt;const&lt;/code&gt; (presumably because its API was specified long ago, and can't be updated; it is illegal to change the information &lt;code&gt;setlocale&lt;/code&gt; returns; doing so leads to segfaults.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d25e58d1b57cecb55c387a5dd5c52709e7a7cf9" translate="yes" xml:space="preserve">
          <source>Another reason that folks sometimes think they want a variable to contain the name of a variable is that they don't know how to build proper data structures using hashes. For example, let's say they wanted two hashes in their program: %fred and %barney, and that they wanted to use another scalar variable to refer to those by name.</source>
          <target state="translated">Другая причина,по которой люди иногда думают,что они хотят,чтобы переменная содержала имя переменной,заключается в том,что они не знают,как построить правильные структуры данных,используя хэши.Например,скажем,они хотели,чтобы в их программе было два хэша:%fred и %barney,и что они хотят использовать другую скалярную переменную,чтобы ссылаться на них по имени.</target>
        </trans-unit>
        <trans-unit id="0421a2fa7b166fbdb782231a9f8dbd1fd87115e8" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;HASH&lt;/code&gt; is to provide your own hash variable. You can then inspect or modify the contents of the hash to gain finer control over the cache management.</source>
          <target state="translated">Еще одна причина использовать &lt;code&gt;HASH&lt;/code&gt; - предоставить вашу собственную хеш-переменную. Затем вы можете проверить или изменить содержимое хэша, чтобы получить более точный контроль над управлением кешем.</target>
        </trans-unit>
        <trans-unit id="1d033aa9337856f2221026f5c7e24c794df0edbb" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8bed8e10e25cfa736414741ddf1e9e2d2b9072" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">Другой пример модуля, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize :: Saves&lt;/a&gt; , доступен в отдельном дистрибутиве на CPAN. Он реализует политику, которая позволяет указать, что определенные значения функции всегда будут искать заново. Подробности смотрите в документации.</target>
        </trans-unit>
        <trans-unit id="5d1b15340e7ecbdf1f65260c165ba0bcb3105f71" translate="yes" xml:space="preserve">
          <source>Another subtle error that can occur in resolving prerequisites comes from the way that modules in prerequisites are indexed to distribution files on CPAN. When a module is deleted from a distribution, prerequisites calling for that module could indicate an older distribution should be installed, potentially overwriting files from a newer distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67a475c6b156df5eac51c84854028a80181079b" translate="yes" xml:space="preserve">
          <source>Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's builtin malloc. Whichever one it is, try using the other one and see whether this makes a difference. Information about malloc is in the</source>
          <target state="translated">Еще одна вещь,которую нужно попробовать,это узнать,был ли ваш Perl скомпилирован с системным malloc или со встроенным malloc Perl.Что бы это ни было,попробуйте использовать другой и посмотрите,имеет ли это значение.Информация о malloc находится в</target>
        </trans-unit>
        <trans-unit id="a1cb48749447600d090febf98d3e4d0e00ee484e" translate="yes" xml:space="preserve">
          <source>Another thing you should bear in mind is that the UNINST parameter can be dangerous when you are installing into a private area because you might accidentally remove modules that other people depend on that are not using the private area.</source>
          <target state="translated">Еще одним моментом,который следует помнить,является то,что параметр UNINST может быть опасен,когда вы устанавливаете в личную область,поскольку вы можете случайно удалить модули,от которых зависят другие люди,не использующие личную область.</target>
        </trans-unit>
        <trans-unit id="254082198376f41ade29efc6ce1df2a3ebdfd235" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7600b26c92e308f5a7b9737781947f5e033b05" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">Еще одно тщательное решение этой ловушки во время выполнения и во время компиляции - использовать &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt; , который представляет собой оболочку Exporter, которая позволяет весь шаблонный код одним глотком в операторе использования.</target>
        </trans-unit>
        <trans-unit id="8f128db16727c4206b263e3f2e5e2f91028aada1" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">Другое типичное использование переотправки бы в &lt;code&gt;AUTOLOAD&lt;/code&gt; методов ред. Если такой метод определил, что он не может обработать конкретный вызов, он может выбрать повторную отправку этого вызова в надежде, что какой-то другой &lt;code&gt;AUTOLOAD&lt;/code&gt; (над ним или слева от него) может сработать лучше.</target>
        </trans-unit>
        <trans-unit id="c4228b8c62bb634355292e1e3ac8e4544658301e" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt;'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f35e8d306941d11adce5505a92ca2044351acf" translate="yes" xml:space="preserve">
          <source>Another unofficial source of data. Currently, it is not used to get data, but the notes and explanatory material were very useful for understanding discrepancies between the sources.</source>
          <target state="translated">Еще один неофициальный источник данных.В настоящее время он не используется для получения данных,но примечания и пояснительные материалы были очень полезны для понимания расхождений между источниками.</target>
        </trans-unit>
        <trans-unit id="a159ba74ceaa166e4b6d8831134290b3cd8265be" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;MERGE&lt;/code&gt; is when you want both kinds of return values stored in the same disk file; this saves you from having to deal with two disk files instead of one. You can use a normalizer function to keep the two sets of return values separate. For example:</source>
          <target state="translated">Еще одно применение &lt;code&gt;MERGE&lt;/code&gt; - это когда вы хотите, чтобы оба типа возвращаемых значений хранились в одном файле на диске; это избавляет вас от необходимости иметь дело с двумя дисковыми файлами вместо одного. Вы можете использовать функцию нормализатора, чтобы разделить два набора возвращаемых значений. Например:</target>
        </trans-unit>
        <trans-unit id="3dd7e16e7ef3fb6df50c7af26f6bc9d68c338053" translate="yes" xml:space="preserve">
          <source>Another use for a closure is to make a variable</source>
          <target state="translated">Другое использование для закрытия,чтобы сделать переменную</target>
        </trans-unit>
        <trans-unit id="5cec4425942c518509d1fda3df7b77a63ebbfefa" translate="yes" xml:space="preserve">
          <source>Another use for escape sequences is to specify characters that cannot (or which you prefer not to) be written literally. These are described in detail in &lt;a href=&quot;perlrebackslash#Character-Escapes&quot;&gt;&quot;Character Escapes&quot; in perlrebackslash&lt;/a&gt;, but the next three paragraphs briefly describe some of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46f51ca5d9afdb7291b96d0559a5eecba4e7c63" translate="yes" xml:space="preserve">
          <source>Another use for normalizers is when the function depends on data other than those in its arguments. Suppose you have a function which returns a value which depends on the current hour of the day:</source>
          <target state="translated">Другое применение нормализаторов-это когда функция зависит от данных,отличных от тех,что указаны в ее аргументах.Предположим,у вас есть функция,которая возвращает значение,зависящее от текущего часа дня:</target>
        </trans-unit>
        <trans-unit id="62444c7bc781846313fe8302369f08d7688eae95" translate="yes" xml:space="preserve">
          <source>Another use for the INIT: section is to check for preconditions before making a call to the C function:</source>
          <target state="translated">Другое использование секции INIT:-проверка предусловий перед вызовом функции С:</target>
        </trans-unit>
        <trans-unit id="3a9f1ae19985a41ad9db3a10b2882d84afcc8d3c" translate="yes" xml:space="preserve">
          <source>Another use for typeglobs is to pass filehandles into a function or to create new filehandles. If you need to use a typeglob to save away a filehandle, do it this way:</source>
          <target state="translated">Другое применение типографских шрифтов-передача файловых дескрипторов в функцию или создание новых файловых дескрипторов.Если вам нужно использовать typeglob для сохранения файловых дескрипторов,сделайте это таким образом:</target>
        </trans-unit>
        <trans-unit id="bd85fb00e79bd02a66b771e2ae402c322124bc55" translate="yes" xml:space="preserve">
          <source>Another use is to indicate that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385eea7f2546356b9012fe969f08ace72fffebdd" translate="yes" xml:space="preserve">
          <source>Another use of symbol tables is for making &quot;constant&quot; scalars.</source>
          <target state="translated">Другое применение таблиц символов-изготовление &quot;постоянных&quot; скаляров.</target>
        </trans-unit>
        <trans-unit id="7e444bc856c81853904c1c90381dc826b2163cfa" translate="yes" xml:space="preserve">
          <source>Another use of the generic object would be as a template. It is a convenient place to store class-specific defaults for various fields to be used in actual object initialization.</source>
          <target state="translated">Другое использование общего объекта было бы в качестве шаблона.Это удобное место для хранения специфических для класса настроек по умолчанию для различных полей,которые будут использоваться при фактической инициализации объекта.</target>
        </trans-unit>
        <trans-unit id="03d707d0fcf79e0d7b50ca27287f1758fef3a3d9" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt; , it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt; , for example.</source>
          <target state="translated">Другой полезный ярлык , который, если вы используете буквальный массив или хэш в качестве аргумента &lt;code&gt;given&lt;/code&gt; , оно превращается в ссылки. Поэтому &lt;code&gt;given(@foo)&lt;/code&gt; такая же , как &lt;code&gt;given(\@foo)&lt;/code&gt; , например.</target>
        </trans-unit>
        <trans-unit id="cc6a78b5df54e2e6affa44db83d9141a9a6580a8" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt;, it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a05112cda91b50dc34bb4913074b7fa53fabce3" translate="yes" xml:space="preserve">
          <source>Another variation on a theme. This time we will modify the &lt;code&gt;Subst&lt;/code&gt; filter to allow a starting and stopping pattern to be specified as well as the</source>
          <target state="translated">Еще одна вариация на тему. На этот раз мы &lt;code&gt;Subst&lt;/code&gt; фильтр Subst, чтобы можно было указать шаблон запуска и остановки, а также</target>
        </trans-unit>
        <trans-unit id="95d0ad8589b46d03f061e120707df66c84d9cbde" translate="yes" xml:space="preserve">
          <source>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</source>
          <target state="translated">Другая версия использует глобальное совпадение в контексте списка,затем присваивает результат скаляру,производя подсчет количества совпадений.</target>
        </trans-unit>
        <trans-unit id="a0589db0a4f4f29bef401c1107ff7696f0cffdbb" translate="yes" xml:space="preserve">
          <source>Another way is to assign to a substr() that's off the end of the string.</source>
          <target state="translated">Другой способ-назначить подстроку(),которая находится вне конца строки.</target>
        </trans-unit>
        <trans-unit id="d77d43e614a814160a75653eb86a2b6f1db8267e" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c83abcaae94dfa04aa0d7e9c83f8b2a9880cd1b" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">Другой способ - использовать модуль &lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt; , который обрабатывает весь файл как массив. Просто получите доступ к случайному элементу массива.</target>
        </trans-unit>
        <trans-unit id="360771e8bfe1eade19d5dbc8ea8baae5f8a955ef" translate="yes" xml:space="preserve">
          <source>Another way is to use undef as an element on the left-hand-side:</source>
          <target state="translated">Другой способ-использовать undef в качестве элемента слева:</target>
        </trans-unit>
        <trans-unit id="b6dde2905ab30997325ea52458484ff80b17847e" translate="yes" xml:space="preserve">
          <source>Another way of describing the operation is this: If &lt;code&gt;/c&lt;/code&gt; is specified, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b74b30f842e3a2fe422587280e297e6a0fb34e2" translate="yes" xml:space="preserve">
          <source>Another way of thinking about this function is finding a needle in a haystack. &lt;code&gt;big&lt;/code&gt; points to the first byte in the haystack. &lt;code&gt;big_end&lt;/code&gt; points to one byte beyond the final byte in the haystack. &lt;code&gt;little&lt;/code&gt; points to the first byte in the needle. &lt;code&gt;little_end&lt;/code&gt; points to one byte beyond the final byte in the needle. All the parameters must be non-&lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81299a8407385b954919f2cec05019d576de6e8" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for an example.</source>
          <target state="translated">Другой способ создания анонимных дескрипторов файлов - с помощью модуля Symbol или модуля IO :: Handle и ему подобных. Преимущество этих модулей в том, что они не скрывают разные типы с одним и тем же именем во время local (). См. Пример внизу &lt;a href=&quot;functions/open&quot;&gt;открытой&lt;/a&gt; страницы.</target>
        </trans-unit>
        <trans-unit id="6660859ea71d8fc8ba79b6222c7cabca290a534d" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e614c6db5b38b002f45562db1a27e62289c42947" translate="yes" xml:space="preserve">
          <source>Another way to debug compile-time code is to start the debugger, set a breakpoint on the</source>
          <target state="translated">Другой способ отладки кода во время компиляции-запустить отладчик,установить точку останова на</target>
        </trans-unit>
        <trans-unit id="9901f72c76524abdcc53f059c75aff5db9ab2a29" translate="yes" xml:space="preserve">
          <source>Another way to declare &lt;code&gt;host&lt;/code&gt; is to use a C block in the CODE: section:</source>
          <target state="translated">Другой способ объявить &lt;code&gt;host&lt;/code&gt; - использовать блок C в разделе CODE :.</target>
        </trans-unit>
        <trans-unit id="205baf27defe296be93a335acebfa113cc8193c2" translate="yes" xml:space="preserve">
          <source>Another way to disable the safe signal behavior locally is to use the &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; module from CPAN, which affects all signals.</source>
          <target state="translated">Другой способ локально отключить безопасное поведение сигналов - использовать модуль &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; из CPAN, который влияет на все сигналы.</target>
        </trans-unit>
        <trans-unit id="11569e74dec6446efa52dec2c7a4e093532b6648" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68459b39b80a3326501665280a8d6df2de3c0dc3" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">Другой способ исследовать дерево - использовать внутренний модуль компилятора, такой как &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1475dee12421b2759f280ec12406b6a9a8686bb7" translate="yes" xml:space="preserve">
          <source>Another way to lay hands on a reference to the underlying object is to use the tied() function, so they might alternately have set clobber using:</source>
          <target state="translated">Другой способ наложить руки на ссылку на базовый объект-это использовать функцию tied(),так что они могут поочередно устанавливать clobber,используя его:</target>
        </trans-unit>
        <trans-unit id="00149c3d1137c9330feb23e2fe36062f95ccc0ba" translate="yes" xml:space="preserve">
          <source>Another way to look at it is via bits:</source>
          <target state="translated">Другой способ взглянуть на это-через биты:</target>
        </trans-unit>
        <trans-unit id="87cb792899401773acea6f65b31b31644b7caaf0" translate="yes" xml:space="preserve">
          <source>Another way to modify &lt;code&gt;@INC&lt;/code&gt; without modifying the program, is to use the &lt;code&gt;lib&lt;/code&gt; pragma, e.g.:</source>
          <target state="translated">Другой способ изменить &lt;code&gt;@INC&lt;/code&gt; без изменения программы - использовать прагму &lt;code&gt;lib&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="53f5ac93c7a0f074f16d88622079abd1a07b9541" translate="yes" xml:space="preserve">
          <source>Another way to see the output of a PM program is to run it as</source>
          <target state="translated">Другой способ увидеть вывод программы PM-это запустить ее как</target>
        </trans-unit>
        <trans-unit id="60d4191bfc5b5a27fe1df7d104bb0fb301db392c" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt; , which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">Другой способ пропустить символы в строке UTF-8 - использовать &lt;code&gt;utf8_hop&lt;/code&gt; , который принимает строку и количество символов, которые нужно пропустить. Однако вы сами по себе относительно проверки границ, так что не используйте ее легкомысленно.</target>
        </trans-unit>
        <trans-unit id="bdbeba721ab6028c2b3830fe28f0b278956ef2ae" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt;, which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebbeb1bfc20bbb2eabb0051011fd1f94e30bfced" translate="yes" xml:space="preserve">
          <source>Another way to specify many INSTALL directories with a single parameter is LIB.</source>
          <target state="translated">Другой способ указать множество каталогов УСТАНОВКИ с одним параметром-LIB.</target>
        </trans-unit>
        <trans-unit id="ab320674027c2ae8c6c6ac4c9c8202490be618cd" translate="yes" xml:space="preserve">
          <source>Another way to write &lt;code&gt;Is_latin_1()&lt;/code&gt; would be to use the characters in the range explicitly:</source>
          <target state="translated">Другой способ написать &lt;code&gt;Is_latin_1()&lt;/code&gt; - явно использовать символы из диапазона:</target>
        </trans-unit>
        <trans-unit id="7b86cf4ed2b3d4be5d67a5a0ca22b08970c9b1b4" translate="yes" xml:space="preserve">
          <source>Ansgar Burchardt &amp;lt;ansgar@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb531954bffd941479549648f2841c2d77a7164" translate="yes" xml:space="preserve">
          <source>Anton Tagunov doubts its usefulness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b561300a9259946d1254bc1d65f626fe87539" translate="yes" xml:space="preserve">
          <source>Any $(FOO) used in the examples are make variables, not Perl.</source>
          <target state="translated">Любые $(FOO),используемые в примерах,являются переменными make,а не Perl.</target>
        </trans-unit>
        <trans-unit id="bea7ca75aae1ff5f6e730010d46af50a09d7d1c8" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;user-defined property&lt;/a&gt; used must be already defined by the time the regular expression is compiled (but note that this construct can be used instead of such properties).</source>
          <target state="translated">Любое используемое &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;определяемое пользователем свойство&lt;/a&gt; должно быть уже определено к моменту компиляции регулярного выражения (но обратите внимание, что эту конструкцию можно использовать вместо таких свойств).</target>
        </trans-unit>
        <trans-unit id="31e755c53eda86352ddd4b11acb45031c2d27960" translate="yes" xml:space="preserve">
          <source>Any &lt;b&gt;class method&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;, or &lt;b&gt;subroutine&lt;/b&gt; that composes, initializes, blesses, and returns an &lt;b&gt;object&lt;/b&gt;. Sometimes we use the term loosely to mean a &lt;b&gt;composer&lt;/b&gt;.</source>
          <target state="translated">Любой &lt;b&gt;метод класса&lt;/b&gt; , &lt;b&gt;экземпляр&lt;/b&gt; или &lt;b&gt;подпрограмма,&lt;/b&gt; которая составляет, инициализирует, благословляет и возвращает &lt;b&gt;объект&lt;/b&gt; . Иногда мы используем этот термин в широком смысле для обозначения &lt;b&gt;композитора&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc443723afa597f0f46ae7e71ea2b268b18eec2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;\&lt;/code&gt; (backslashes) are converted to &lt;code&gt;/&lt;/code&gt; (forward slashes), and then File::Spec::Unix canonpath() is called on the result.</source>
          <target state="translated">Любые &lt;code&gt;\&lt;/code&gt; (обратные косые черты) преобразуются в &lt;code&gt;/&lt;/code&gt; (прямые косые черты), а затем для результата вызывается File :: Spec :: Unix canonpath ().</target>
        </trans-unit>
        <trans-unit id="0297ad87a59e1b9acfbd34804e1d88eb60665363" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; is run unconditionally. An</source>
          <target state="translated">Любая &lt;code&gt;make&lt;/code&gt; или &lt;code&gt;test&lt;/code&gt; проводится безоговорочно. An</target>
        </trans-unit>
        <trans-unit id="bf7362a2fe12e03fc4b84c1c886bc1d5ed325938" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;use utf8&lt;/code&gt; or &lt;code&gt;no utf8&lt;/code&gt; declarations within the string have no effect, and source filters are forbidden. (&lt;code&gt;unicode_strings&lt;/code&gt;, however, can appear within the string.) See also the &lt;a href=&quot;#evalbytes-EXPR&quot;&gt;&lt;code&gt;evalbytes&lt;/code&gt;&lt;/a&gt; operator, which works properly with source filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd3503f8d612240a0cdcfcf3958cd4b47fd1bc1" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt; 's, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt; .</source>
          <target state="translated">Любой SV может быть волшебным, то есть у него есть особенности, которых нет у обычного SV. Эти функции хранятся в структуре SV в связанном списке &lt;code&gt;struct magic&lt;/code&gt; , с типом &lt;code&gt;MAGIC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33b69c22f5834c109ce23cffa5c65513da0e84fe" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt;'s, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3990dd07c484552abc78d056ff16c2e2a8e23114" translate="yes" xml:space="preserve">
          <source>Any additional arguments are expected to be names of modules to generate code for.</source>
          <target state="translated">Предполагается,что дополнительными аргументами будут имена модулей для генерации кода.</target>
        </trans-unit>
        <trans-unit id="33e9e1331c3f51ebe91a9bc05248aec433c1afce" translate="yes" xml:space="preserve">
          <source>Any additional arguments found before the &lt;b&gt;--&lt;/b&gt; token are expected to be names of modules to generate code for.</source>
          <target state="translated">Любые дополнительные аргументы , найденные до &lt;b&gt;-&lt;/b&gt; лексема , как ожидается, имена модулей для генерации кода для.</target>
        </trans-unit>
        <trans-unit id="c6e53a3422c150f8910984634fe5fc4926bb37bc" translate="yes" xml:space="preserve">
          <source>Any additional flags you wish to pass to the linker.</source>
          <target state="translated">Любые дополнительные флаги,которые вы хотите передать компоновщику.</target>
        </trans-unit>
        <trans-unit id="76af9e90cc2fb275b94658ee19c44c077d496116" translate="yes" xml:space="preserve">
          <source>Any argument provided is passed as CHECK to underlying Encode::decode() call. Pass the value &lt;code&gt;Encode::FB_CROAK&lt;/code&gt; to have the decoding croak if not all the command line arguments can be decoded. See &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot; in Encode&lt;/a&gt; for details on other options for CHECK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fc9753c4799266fbd1d9873fa8ed5292bbf609" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">Любой аргумент, который выглядит как имя сигнала (то есть &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) указывает, что &lt;b&gt;sigtrap&lt;/b&gt; должен установить обработчик для этого имени.</target>
        </trans-unit>
        <trans-unit id="f26e937185e1c5cd97a379a8dabb810b138157bc" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt;) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669f46fd59266a6910f9368caa3825ce94a0d579" translate="yes" xml:space="preserve">
          <source>Any arguments after the second '--' token are additional linker arguments that will be examined for potential conflict. If there is no conflict, the additional arguments will be part of the output.</source>
          <target state="translated">Любые аргументы после второй лексемы '--' являются дополнительными аргументами компоновщика,которые будут рассматриваться на предмет потенциального конфликта.Если конфликта нет,то дополнительные аргументы будут являться частью вывода.</target>
        </trans-unit>
        <trans-unit id="b8ba7c975cc3879d276e04e3e9eb8ad2f669d5cb" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt; . (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt; . The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">Любые переданные аргументы отображаются в массиве &lt;code&gt;@_&lt;/code&gt; . (Они также могут отображаться в лексических переменных, представленных подписью; см. &lt;a href=&quot;#Signatures&quot;&gt;Сигнатуры&lt;/a&gt; ниже.) Следовательно, если вы вызываете функцию с двумя аргументами, они будут сохранены в &lt;code&gt;$_[0]&lt;/code&gt; и &lt;code&gt;$_[1]&lt;/code&gt; . Массив &lt;code&gt;@_&lt;/code&gt; является локальным массивом, но его элементы являются псевдонимами фактических скалярных параметров. В частности, если элемент &lt;code&gt;$_[0]&lt;/code&gt; обновляется, соответствующий аргумент обновляется (или возникает ошибка, если он не обновляется). Если аргумент является массивом или хеш-элементом, который не существовал при вызове функции, этот элемент создается только тогда (и если) он изменяется или берется ссылка на него. (Некоторые более ранние версии Perl создавали элемент вне зависимости от того, был ли этот элемент назначен.) Присвоение всему массиву &lt;code&gt;@_&lt;/code&gt; удаляет этот псевдоним и не обновляет никакие аргументы.</target>
        </trans-unit>
        <trans-unit id="f35f240798e3c5e460d473d423be038d4c72e7d0" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt;. (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt;. The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6247c19341895e60632e62b6ff63ef2ca7a1ee" translate="yes" xml:space="preserve">
          <source>Any attempt by the code in STRING to use an operator which is not permitted by the compartment will cause an error (at run-time of the main program but at compile-time for the code in STRING). The error is of the form &quot;'%s' trapped by operation mask...&quot;.</source>
          <target state="translated">Любая попытка кода в STRING использовать оператор,не допущенный отделением,приведет к ошибке (во время выполнения основной программы,но во время компиляции кода в STRING).Ошибка имеет вид &quot;'%s'',запертая операционной маской...&quot;.</target>
        </trans-unit>
        <trans-unit id="813cebd9a54eacff09b02a5f15b34a12df0ec8d1" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt; , which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">Любой символ прототипа с обратной косой чертой представляет собой фактический аргумент, который должен начинаться с этого символа (необязательно перед ним &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ), за исключением &lt;code&gt;$&lt;/code&gt; , который будет принимать любое скалярное выражение lvalue, такое как &lt;code&gt;$foo = 7&lt;/code&gt; или &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . Значение, переданное как часть &lt;code&gt;@_&lt;/code&gt; , будет ссылкой на фактический аргумент, указанный в вызове подпрограммы, полученный путем применения &lt;code&gt;\&lt;/code&gt; к этому аргументу.</target>
        </trans-unit>
        <trans-unit id="ffa3112ef74eec5708dbce1d67d94690c63f3116" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt;, which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt;. The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8738a2a75fb40cb2ee10b2d9e2137a995a5cab3" translate="yes" xml:space="preserve">
          <source>Any call from a package to itself is safe.</source>
          <target state="translated">Любой звонок от пакета к самому себе безопасен.</target>
        </trans-unit>
        <trans-unit id="4b72ee9b0cb5399c6a83f5d4a70d821be8027231" translate="yes" xml:space="preserve">
          <source>Any call from an internal Perl module is safe. (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</source>
          <target state="translated">Любой звонок со встроенного модуля Perl безопасен.(Ничто не мешает пользовательским модулям маркировать себя как внутренний Perl,но такая практика не поощряется).</target>
        </trans-unit>
        <trans-unit id="32561ad60b0d62ef81eb27f4c0654f92745f16b5" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; .)</source>
          <target state="translated">Любой вызов системы предупреждений Perl (например, самого Carp) безопасен. (Это правило не дает ему сообщать об ошибке в том месте, где вы вызываете &lt;code&gt;carp&lt;/code&gt; или &lt;code&gt;croak&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="3b252f8b26d454c8056df1a78fc7a97e6d22f01f" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be54b4dca13888b86e758e818195dea970243c9" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt; .</source>
          <target state="translated">Любой символ не соответствует &lt;code&gt;\d&lt;/code&gt; подобрано &lt;code&gt;\D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a92f497a3debf42be69af7cf310d253bf9089f09" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072286fccc69e711078f97acb3c710b733c38c10" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt; .</source>
          <target state="translated">Любой символ не соответствует &lt;code&gt;\s&lt;/code&gt; подобрано &lt;code&gt;\S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f9b47e6ac747d8625677192454745261e50c9f3" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd14be74c570e6d8f1d353ef998bd9cdb853857" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">Любой символ не соответствует &lt;code&gt;\w&lt;/code&gt; подобран &lt;code&gt;\W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca92dc8b5b50382eccc8de66976a91add27a47ad" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45bb18b3ba9ff92c60226f6eef9c2b785d393ac" translate="yes" xml:space="preserve">
          <source>Any character not part of the 65-character base64 subset is silently ignored. Characters occurring after a '=' padding character are never decoded.</source>
          <target state="translated">Любой символ,не входящий в 65-символьное подмножество base64,беззвучно игнорируется.Символы,встречающиеся после символа подстановки '=' никогда не декодируются.</target>
        </trans-unit>
        <trans-unit id="fdc4fb7a943f332e78ce7564ebae9fbe7a142c7e" translate="yes" xml:space="preserve">
          <source>Any character that is</source>
          <target state="translated">Любой персонаж,который</target>
        </trans-unit>
        <trans-unit id="d1ae992eb64cfaf05e3391f63560921ed6515ef6" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt; ), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">Любой символ с общей категорией комбинированного знака ( &lt;code&gt;\p{GC=M}&lt;/code&gt; ), который может быть пробелом или нет. Некоторые даже невидимы. Последовательность комбинирования символов, следующих за базовым символом графемы, вместе составляет один видимый пользователю символ, называемый &lt;b&gt;графемой&lt;/b&gt; . Большинство, но не все диакритические знаки объединяют символы, и наоборот.</target>
        </trans-unit>
        <trans-unit id="f7f37ee9ffee4805d8681593ea741f6cb413f361" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt;), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47500f097947cd7ef6b655a33fe0adeaed93c8c" translate="yes" xml:space="preserve">
          <source>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</source>
          <target state="translated">Любой класс,полученный от перегруженного класса,также перегружен и наследует реализацию своего оператора.Если один и тот же оператор перегружен более чем в одном предке,то реализация определяется обычными правилами наследования.</target>
        </trans-unit>
        <trans-unit id="82762c13b8c241690349f9ba71914d3aafcada68" translate="yes" xml:space="preserve">
          <source>Any class for which this function returns true is &quot;universal&quot; in the sense that all classes potentially inherit methods from it.</source>
          <target state="translated">Любой класс,для которого данная функция возвращает true,является &quot;универсальным&quot; в том смысле,что все классы потенциально наследуют от него методы.</target>
        </trans-unit>
        <trans-unit id="4c366c83fbe5661336d1ed5dad628d12372f6675" translate="yes" xml:space="preserve">
          <source>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</source>
          <target state="translated">Любой класс может определять крючки,которые будут вызываться в процессе сериализации и десериализации на объектах,являющихся экземплярами этого класса.Эти крючки могут переопределить способ сериализации (и,следовательно,то,как должна выполняться симметричная десериализация).</target>
        </trans-unit>
        <trans-unit id="6e6281f412687ca7280049212c9dd37d5f605837" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">Любая команда, не распознанная отладчиком, выполняется напрямую ( &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 'd) как код Perl в текущем пакете. (Отладчик использует пакет БД для хранения собственной информации о состоянии.)</target>
        </trans-unit>
        <trans-unit id="78f7d4f4e5eb056442905f4be332daa2d7078212" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;eval&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fcc44228bcb7043c7f8789e115cc416dabfd31" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch by first adding an entry to the relevant voting file in the maint-votes branch announcing the commit as a candidate for back-porting, and then waiting for at least two other committers to add their votes in support of this (i.e. a total of at least three votes is required before a commit may be back-ported).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8dc7e3add242376e935c5e7dec68c1bf0f28dae" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch if they send mail to perl5-porters announcing their intent to cherry-pick a specific commit along with a rationale for doing so and at least two other committers respond to the list giving their assent. (This policy applies to current and former pumpkings, as well as other committers.)</source>
          <target state="translated">Любой коммиттер может выбрать любой коммит из blead в ветку maint,если он посылает почту perl5-портерам с сообщением о своём намерении выбрать конкретный коммит вместе с обоснованием этого,и как минимум два других коммиттера отвечают на список,давая своё согласие.(Эта политика распространяется на текущую и бывшую выкачку,а также на других коммиттеров).</target>
        </trans-unit>
        <trans-unit id="b95f0a7c9cbc43fb72281273ec465950ff501fea" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt; ) modifiers.</source>
          <target state="translated">Любые содержащиеся классы символов POSIX, включая такие вещи, как &lt;code&gt;\w&lt;/code&gt; и &lt;code&gt;\D&lt;/code&gt; уважают модификаторы &lt;code&gt;/a&lt;/code&gt; (и &lt;code&gt;/aa&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed912b6d995f34c695ed9e38e5b4d742feccc889" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt;) modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db2df3ee56bd2a814ccc5209f324c5b3591842c" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">Любые типы данных, поддерживаемые &lt;a href=&quot;../threads/shared&quot;&gt;thread :: shared,&lt;/a&gt; могут передаваться через очереди:</target>
        </trans-unit>
        <trans-unit id="4e0656683c3bae7fc0640dbcbac9a2b39fa2d301" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e796dc658263f7829a0c740b0d175dbd881579ef" translate="yes" xml:space="preserve">
          <source>Any diagnostics that were output for the test. This only includes diagnostics output &lt;b&gt;after&lt;/b&gt; the test result is declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500c84c6a69d3cbc0070a804d35fd877c67e676d" translate="yes" xml:space="preserve">
          <source>Any directory to prefix to the extraction path, if any</source>
          <target state="translated">Любой каталог для префиксации пути извлечения,если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="fe63280e6a478a3a4b2a298d74baf468659f885a" translate="yes" xml:space="preserve">
          <source>Any existing</source>
          <target state="translated">Любой существующий</target>
        </trans-unit>
        <trans-unit id="910f15fcdac4d39c624eb5925c6aedfca05cbd8f" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">Любое расширение Perl, включая те, которые содержат XSUB, должно иметь модуль Perl, служащий начальной загрузкой, которая втягивает расширение в Perl. Этот модуль экспортирует функции и переменные расширения в программу Perl и вызовет связывание XSUB расширения с Perl. Следующий модуль будет использоваться для большинства примеров в этом документе и должен использоваться из Perl с командой &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , как показано ранее. Модули Perl объясняются более подробно далее в этом документе.</target>
        </trans-unit>
        <trans-unit id="4138f336ca25f7058dac8592c9829407df50fe3e" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;use&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a23450424903dcd5fa1cc3d1a014ad157de4c5" translate="yes" xml:space="preserve">
          <source>Any extra arguments which shouldn't be passed on to &lt;code&gt;plan()&lt;/code&gt; should be stripped off by this method.</source>
          <target state="translated">Любые дополнительные аргументы, которые не следует передавать в &lt;code&gt;plan()&lt;/code&gt; должны быть удалены этим методом.</target>
        </trans-unit>
        <trans-unit id="479572afcef4faf54a80923b02d6ecab023cba50" translate="yes" xml:space="preserve">
          <source>Any extra arguments you want passed into the subtest code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e812c3c14740bd790df37fd5ab976ff0e033c047" translate="yes" xml:space="preserve">
          <source>Any filehandles open at the time of the fork() will be dup()-ed. Thus, the files can be closed independently in the parent and child, but beware that the dup()-ed handles will still share the same seek pointer. Changing the seek position in the parent will change it in the child and vice-versa. One can avoid this by opening files that need distinct seek pointers separately in the child.</source>
          <target state="translated">Любые файловые дескрипторы,открытые во время работы функции fork(),будут дублироваться функцией dup()-ed.Таким образом,файлы могут быть закрыты независимо от родительского и дочернего,но остерегайтесь,что дескрипторы dup()-ed все равно будут иметь один и тот же указатель на поиск.Изменение позиции поиска в родителе изменит ее в дочернем и наоборот.Этого можно избежать,открывая файлы,которым нужны разные указатели поиска отдельно в дочернем процессе.</target>
        </trans-unit>
        <trans-unit id="187558535ccb5da9eca3826ba8e4d8b30ca76bc1" translate="yes" xml:space="preserve">
          <source>Any function in the list below may be used either with or without parentheses around its arguments. (The syntax descriptions omit the parentheses.) If you use parentheses, the simple but occasionally surprising rule is this: It</source>
          <target state="translated">Любая функция из приведенного ниже списка может быть использована как со скобками,так и без скобок вокруг ее аргументов.(Синтаксические описания опускают круглые скобки.)Если вы используете круглые скобки,то простое,но иногда удивительное правило заключается в следующем:Оно .</target>
        </trans-unit>
        <trans-unit id="9f6c837fd47f5e061c1ecbb824c94df3994dcde5" translate="yes" xml:space="preserve">
          <source>Any good book on software engineering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c8f5e2946c066d9a62168dcf66b92198c6784a" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">Любые ключи со значением &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="0c7f27e33616c341daf05c0b6c508f0fa8fdbd74" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">Любые ключи со значением &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; будут проигнорированы.</target>
        </trans-unit>
        <trans-unit id="b98397e3061065c914af3247fdcc89fdfd6a02c2" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;undef&lt;/code&gt; will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568e69d3500c9fb9cde3152f15ae5ed8fcf84af4" translate="yes" xml:space="preserve">
          <source>Any keys not described in this specification document (whether top-level or within compound data structures described herein) are considered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204edb5197689fcdc449ffc64469cd176c221d73" translate="yes" xml:space="preserve">
          <source>Any large IRC network (Dalnet, EFnet) is also likely to have a #perl channel, with varying activity levels.</source>
          <target state="translated">Любая большая сеть IRC (Dalnet,EFnet)также,вероятно,имеет #perl канал,с различными уровнями активности.</target>
        </trans-unit>
        <trans-unit id="9ec17e0cbd0b3e2eebd6b6cf6a596cebb4cfc33d" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;:&quot;&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimnsx-imnsx)&lt;/code&gt;. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44271c2c405bf35e52ab0041e6847e60ca1ca0c2" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . For example,</source>
          <target state="translated">Есть буквы между &lt;code&gt;?&lt;/code&gt; и &lt;code&gt;:&lt;/code&gt; действуют как модификаторы флагов, как с &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="5618684dee489724ebf8f57ba00718b3f30e3494" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">Любые вызовы методов для объекта, созданного с помощью &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; будут отправлены в пакет как обычный объект.</target>
        </trans-unit>
        <trans-unit id="26b68c72e2b484267b2f658de2349d6444e86420" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;qr//&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125ade77b67e2c4cd7a637af74e96e943bde8b70" translate="yes" xml:space="preserve">
          <source>Any methods marked</source>
          <target state="translated">Любые отмеченные методы</target>
        </trans-unit>
        <trans-unit id="c1aa612608eba8166ce338b4b530d56d4e20399c" translate="yes" xml:space="preserve">
          <source>Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check these two modules for further information.</source>
          <target state="translated">Любые методы,не перечисленные здесь,являются производными от Math::BigFloat (или Math::BigInt),поэтому не забудьте проверить эти два модуля для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="9782a834fd90fe5d5545a24d61a39706e25bf926" translate="yes" xml:space="preserve">
          <source>Any mixture is possible. For example, the most frequently used options could be stored in variables while all other options get stored in the hash:</source>
          <target state="translated">Любая смесь возможна.Например,наиболее часто используемые опции могут быть сохранены в переменных,в то время как все остальные опции будут сохранены в хэше:</target>
        </trans-unit>
        <trans-unit id="d9afc9d2e9f12a7ae747d6b9bda2062ad21b9fd2" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt; ) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Future versions may make this a fatal error.</source>
          <target state="translated">Любые имена, не являющиеся тегами, добавляются в &lt;code&gt;@EXPORT&lt;/code&gt; или &lt;code&gt;@EXPORT_OK&lt;/code&gt; без изменений, но вызывают предупреждение (с &lt;code&gt;-w&lt;/code&gt; ), чтобы избежать добавления неправильно написанных имен тегов в &lt;code&gt;@EXPORT&lt;/code&gt; или &lt;code&gt;@EXPORT_OK&lt;/code&gt; . В будущих версиях это может стать фатальной ошибкой.</target>
        </trans-unit>
        <trans-unit id="f1edfb250e37d4b9a7863e1b2498e2a280885f23" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt;) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;. Future versions may make this a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485a3dceff3fe3343086f55cd7ded47422eb7429" translate="yes" xml:space="preserve">
          <source>Any newlines in $perl_code will be escaped. Leading and trailing newlines will be stripped. Makes this idiom much easier:</source>
          <target state="translated">Любые новые строки в $perl_коде будут экранированы.Ведущие и отстающие новые линии будут удалены.Делает эту идиому намного проще:</target>
        </trans-unit>
        <trans-unit id="85505e3e03d4cfb2c5d76c353aad39b235819057" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">Любой разделитель, отличный от пробелов, может заменить косую черту. Добавьте пробел после &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; при использовании символа, разрешенного в идентификаторах. Если используются одинарные кавычки, строка замены не интерпретируется ( однако модификатор &lt;code&gt;/e&lt;/code&gt; отменяет это). Обратите внимание, что Perl рассматривает обратные кавычки как обычные разделители; текст замены не рассматривается как команда. Если</target>
        </trans-unit>
        <trans-unit id="48ec8f1e8af52f4ed4957bdfee1ffd49c84a8c6f" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;s&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21321c35f59a007bf7dcddd13bebabd646dd3b58" translate="yes" xml:space="preserve">
          <source>Any number of &lt;code&gt;(*PRUNE)&lt;/code&gt; assertions may be used in a pattern.</source>
          <target state="translated">В &lt;code&gt;(*PRUNE)&lt;/code&gt; может использоваться любое количество утверждений (* PRUNE) .</target>
        </trans-unit>
        <trans-unit id="8bc2478d6a5974c2f338a393e6f6ea8ec88b251c" translate="yes" xml:space="preserve">
          <source>Any number of arguments can occur in the list before the array but the input and output arrays must be the last elements in the list.</source>
          <target state="translated">В списке перед массивом может появиться любое количество аргументов,но входной и выходной массивы должны быть последними элементами в списке.</target>
        </trans-unit>
        <trans-unit id="637eecabf535d7591a4a05a68e784539a4cbb56d" translate="yes" xml:space="preserve">
          <source>Any number of tildes and surrounding whitespace will be collapsed to a single space.</source>
          <target state="translated">Любое количество тильд и окружающих пробельных символов будет сведено в единое пространство.</target>
        </trans-unit>
        <trans-unit id="6743acd9891044d5d8bdbb4fb2163336b42729f9" translate="yes" xml:space="preserve">
          <source>Any numerical value returned which is less than SVt_PVAV will be a scalar of some form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c027e1a6e6b64e23c560209fac7288c23f0070f0" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;IO::Socket#CONSTRUCTOR-ARGUMENTS&quot;&gt;&quot;CONSTRUCTOR ARGUMENTS&quot; in IO::Socket&lt;/a&gt; may be passed to the constructor, but if any arguments are provided, then one of them must be the &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument. The &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument can, by default, be either &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_UNIX&lt;/code&gt;. Other domains can be used if a proper subclass for the domain family is registered. All other arguments will be passed to the &lt;code&gt;configuration&lt;/code&gt; method of the package for that domain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c5d3662ce5a04f9a5a84a78523f9d65e2d1542" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the &lt;code&gt;$timeleft&lt;/code&gt;. If not, they always return &lt;code&gt;$timeleft&lt;/code&gt; equal to the supplied &lt;code&gt;$timeout&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799d3a594ea06ab8f69431e4521092706a0ca250" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be undef. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the $timeleft. If not, they always return $timeleft equal to the supplied $timeout.</source>
          <target state="translated">Любая из битовых масок также может быть неповреждённой.Тайм-аут,если он указан,находится в секундах,что может быть дробным.Замечание:не все реализации способны вернуть $timeleft.Если нет,то они всегда возвращают $timeleft,равный поставляемому $timeout.</target>
        </trans-unit>
        <trans-unit id="96dac77ef4a45d1d47b4f15ad920f1efda518fb4" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt;.</source>
          <target state="translated">Любой из этих модификаторов может применяться глобально ко всем регулярным выражениям, скомпилированным в рамках области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . См. &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;Режим '/ flags' в re&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="511eb3ecca55bf6890b46608108a95afce5c385f" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;use re&lt;/code&gt;. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72e7a2b4416a01397ed95a3d69723c275ceb3de" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">Любой из этих операторов является хорошей заменой для &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; с тем же эффектом времени компиляции. Основное отличие состоит в том, что &lt;code&gt;base&lt;/code&gt; код взаимодействует с объявленными &lt;code&gt;fields&lt;/code&gt; то время как &lt;code&gt;parent&lt;/code&gt; - это упрощенная версия старого &lt;code&gt;base&lt;/code&gt; кода, просто устанавливающая связь IS-A.</target>
        </trans-unit>
        <trans-unit id="a58afbeb2eaab93b0832f3d91597b76dd426bf94" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { require Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d3e07363608f1d20995e0548f7b8658feed7f4" translate="yes" xml:space="preserve">
          <source>Any omitted or empty regular expressions will default to &quot;.*&quot;. Please note that each regular expression given is implicitly anchored by adding &quot;^&quot; and &quot;$&quot; to the beginning and end. Also, if a given regular expression starts with a &quot;!&quot; character, then the expression is</source>
          <target state="translated">Любые опущенные или пустые регулярные выражения будут по умолчанию &quot;.*&quot;.Обратите внимание,что каждое приведенное регулярное выражение неявно привязывается к началу и концу,добавляя &quot;^&quot; и &quot;$&quot;.Также,если заданное регулярное выражение начинается со знака &quot;!&quot;,то это выражение имеет вид</target>
        </trans-unit>
        <trans-unit id="0f87f06eba2caf7b827d1f8e16065d83ac575560" translate="yes" xml:space="preserve">
          <source>Any other character it taken literally.</source>
          <target state="translated">Любой другой персонаж в буквальном смысле этого слова.</target>
        </trans-unit>
        <trans-unit id="3effb550cd8c77527aa9de81743828a3b7722f93" translate="yes" xml:space="preserve">
          <source>Any other parameters specific to the method</source>
          <target state="translated">Любые другие параметры,специфичные для данного метода</target>
        </trans-unit>
        <trans-unit id="c9c0186423c77aa8d8e97bed87ca7acf745a240d" translate="yes" xml:space="preserve">
          <source>Any other return code means that a flush point was not found. If more data is available, &lt;code&gt;inflateSync&lt;/code&gt; can be called repeatedly with more compressed data until the flush point is found.</source>
          <target state="translated">Любой другой код возврата означает, что точка слива не найдена. Если доступно больше данных, &lt;code&gt;inflateSync&lt;/code&gt; можно вызывать повторно с более сжатыми данными, пока не будет найдена точка сброса .</target>
        </trans-unit>
        <trans-unit id="f1dc9b8d3bdcecba91d97097df903ce52027fe14" translate="yes" xml:space="preserve">
          <source>Any other string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c9cefe7b574f70d77490b40ef9d059faa47f0c" translate="yes" xml:space="preserve">
          <source>Any parameters to be pushed onto the stack should be bracketed by the &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;code&gt;PUTBACK&lt;/code&gt; macros. The purpose of these two macros, in this context, is to count the number of parameters you are pushing automatically. Then whenever Perl is creating the &lt;code&gt;@_&lt;/code&gt; array for the subroutine, it knows how big to make it.</source>
          <target state="translated">Любые параметры, &lt;code&gt;PUSHMARK&lt;/code&gt; в стек, должны заключаться в скобки макросами PUSHMARK и &lt;code&gt;PUTBACK&lt;/code&gt; . В данном контексте цель этих двух макросов - подсчитать количество параметров, которые вы вводите автоматически. Затем всякий раз, когда Perl создает массив &lt;code&gt;@_&lt;/code&gt; для подпрограммы, он знает, насколько большим нужно его сделать.</target>
        </trans-unit>
        <trans-unit id="393576095a8de6bc0086f7597df6e48f941f115a" translate="yes" xml:space="preserve">
          <source>Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; variables. When doing so the following rules apply:</source>
          <target state="translated">Любой шаблон, содержащий специальный глагол поиска с возвратом, который разрешает аргумент, имеет особое поведение, при выполнении которого он устанавливает переменные &lt;code&gt;$REGERROR&lt;/code&gt; и &lt;code&gt;$REGMARK&lt;/code&gt; текущего пакета . При этом действуют следующие правила:</target>
        </trans-unit>
        <trans-unit id="0f7c0d8ab3a57bbfaec5da2f59e5489aaf2f7ee1" translate="yes" xml:space="preserve">
          <source>Any references that are the same as one of those passed in will be named &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">Любые ссылки, которые совпадают с одной из переданных, будут называться &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0947cd6471d04a9e9e7aba2d6ed254ce36b6a65" translate="yes" xml:space="preserve">
          <source>Any regular expression special characters in &lt;code&gt;$regex&lt;/code&gt; are still special, and the pattern still has to be valid or Perl will complain. For instance, in this pattern there is an unpaired parenthesis.</source>
          <target state="translated">Любые специальные символы регулярных выражений в &lt;code&gt;$regex&lt;/code&gt; по-прежнему являются особенными, и шаблон должен быть действительным, иначе Perl будет жаловаться. Например, в этом шаблоне есть непарная скобка.</target>
        </trans-unit>
        <trans-unit id="fe7f6f318181e1a9721562694a44d98bb9f0d89c" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">Любое скалярное значение, которое не равно 0 или &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc814185c98806f976443ba7f707c9de190e5102" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aef8e8c0d886239b79a86d40fbcb9638ca8176a" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry &lt;code&gt;PERL_MAGIC_collxfrm&lt;/code&gt; magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9848f5389028c0e6f897c58baee24bbe4b4452b" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">Любая скалярная переменная может нести магию PERL_MAGIC_collxfrm,которая содержит скалярные данные переменной,но преобразована в такой формат,что для сравнения данных в соответствии с настройками локали можно использовать обычное сравнение памяти.</target>
        </trans-unit>
        <trans-unit id="38fbec488780a53c892b68c97c1898064ef5cf3c" translate="yes" xml:space="preserve">
          <source>Any simple statement may optionally be followed by a</source>
          <target state="translated">Любое простое утверждение может по желанию сопровождаться</target>
        </trans-unit>
        <trans-unit id="6edad6532b87dcd9565ed8ca948fd8e9febfc827" translate="yes" xml:space="preserve">
          <source>Any single character in a pattern matches that same character in the target string, unless the character is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57ad08ad6b4b977666be8da12ed7e9b3597a3e6" translate="yes" xml:space="preserve">
          <source>Any single character matches itself, unless it is a</source>
          <target state="translated">Любой одиночный символ совпадает сам по себе,если только это не</target>
        </trans-unit>
        <trans-unit id="f581a0aac4749093894a9605cfac9a184c97919e" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;../config#lddlflags&quot;&gt;lddlflags in Config&lt;/a&gt;)</source>
          <target state="translated">Любые специальные флаги, которые может потребоваться передать ld для создания общей библиотеки, подходящей для динамической загрузки. Его использование зависит от make-файла. (См. &lt;a href=&quot;../config#lddlflags&quot;&gt;Lddlflags в Config&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="bea6827ac537eb7924457a4cf759d617d88c98bb" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;config#lddlflags&quot;&gt;&quot;lddlflags&quot; in Config&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae1c49f6637fcf58ae140f395f043a2e193fb5a" translate="yes" xml:space="preserve">
          <source>Any statement within the body of a loop that can make a loop prematurely stop looping or skip an &lt;b&gt;iteration&lt;/b&gt;. Generally, you shouldn&amp;rsquo;t try this on roller coasters.</source>
          <target state="translated">Любой оператор в теле цикла, который может заставить цикл преждевременно прекратить цикл или пропустить &lt;b&gt;итерацию&lt;/b&gt; . Как правило, вы не должны пробовать это на американских горках.</target>
        </trans-unit>
        <trans-unit id="a7b963c94b597f0a356b5a56744621822590c340" translate="yes" xml:space="preserve">
          <source>Any string eval which is executed by code executing in a compartment, or by code called from code executing in a compartment, will be eval'd in the namespace of the compartment. This is potentially a serious problem.</source>
          <target state="translated">Любая строка оценивается по коду,который выполняется в помещении,или по коду,который вызывается из кода,выполняемого в помещении,будет оцениваться в пространстве имен помещения.Это потенциально серьезная проблема.</target>
        </trans-unit>
        <trans-unit id="8a7a9db7b2a7d9c3bc4a0371b24f090bb005ce01" translate="yes" xml:space="preserve">
          <source>Any switches in the &lt;code&gt;PERLDOC&lt;/code&gt; environment variable will be used before the command line arguments.</source>
          <target state="translated">Любые переключатели в &lt;code&gt;PERLDOC&lt;/code&gt; среды PERLDOC будут использоваться перед аргументами командной строки.</target>
        </trans-unit>
        <trans-unit id="7c3b8e236160fc72cba179bfa08e7e8fcf86e97c" translate="yes" xml:space="preserve">
          <source>Any test which does not match a rule will be run in sequence at the end of the run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c697d8a2e427d5d56c9e1028dbc399fcc4b347e2" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">В любое время после того, как Perl запустит вашу основную программу. См. Также &lt;b&gt;этап компиляции&lt;/b&gt; . Фаза выполнения в основном проводится во &lt;b&gt;время выполнения,&lt;/b&gt; но также может быть потрачена во &lt;b&gt;время компиляции,&lt;/b&gt; когда это &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2c3d3bd0813c99a89a071ee04615c19b004d52d" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00807e0e44bec9e684bd05f5d6ca841ffb6f513c" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">В любое время до того, как Perl запустит вашу основную программу. См. Также &lt;b&gt;этап выполнения&lt;/b&gt; . Фаза компиляции в основном тратится на &lt;b&gt;время компиляции&lt;/b&gt; , но может также проводиться во &lt;b&gt;время выполнения,&lt;/b&gt; когда &lt;code&gt;BEGIN&lt;/code&gt; блоки BEGIN , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; объявлений или константные подвыражения. Код запуска и импорта любого объявления &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; также запускается на этапе компиляции.</target>
        </trans-unit>
        <trans-unit id="89bbb32771fb02c8c9a2b7c9c816ca4c3b49cddb" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;use&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08963a941982a994fe2895ea2c775da89cda3e41" translate="yes" xml:space="preserve">
          <source>Any time you're doing a &quot;this equals that&quot; sort of test, use &lt;code&gt;is()&lt;/code&gt;. It even works on arrays. The test is always in scalar context, so you can test how many elements are in an array this way. [5]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa83fb5c769020023303529abde854eefeaa0d66" translate="yes" xml:space="preserve">
          <source>Any version between 1.00 and 1.82 inclusive would be acceptable, except for 1.75.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34097998161c40da19bcb944501b160cf796dc7" translate="yes" xml:space="preserve">
          <source>Any version from version 1.2 onward, except version 1.5, that also precedes version 2.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5515dadcc88944ac0dd16b3a430dc89d34c3d0" translate="yes" xml:space="preserve">
          <source>Any version which &quot;looks like a number&quot;, see &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;. This also includes versions with a single decimal point and a single embedded underscore, see &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;Alpha Versions&quot;&lt;/a&gt;, even though these must be quoted to preserve the underscore formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6b65d5c451906eff3dea5dd5120214b2325bd" translate="yes" xml:space="preserve">
          <source>Any/all fields and accessors are autovivified into existence. There is no way to know what metadata may be added, so any is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bea195cc0120bd58a5f6ddfad70e861a932bba8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File</source>
          <target state="translated">AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="abf989fc06a7a8552843b93b1474a012067198d8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File - provide framework for multiple DBMs</source>
          <target state="translated">AnyDBM_File-обеспечить основу для нескольких БДМ.</target>
        </trans-unit>
        <trans-unit id="29c9b5ccd4a8843ac06d93de6db98a168d9747a5" translate="yes" xml:space="preserve">
          <source>Anyone interested in resurrecting this file should pull the old version from the MakeMaker CVS repository and contact makemaker@perl.org.</source>
          <target state="translated">Любой,кто заинтересован в воскрешении этого файла,должен вытащить старую версию из репозитория MakeMaker CVS и связаться с makemaker@perl.org.</target>
        </trans-unit>
        <trans-unit id="f1313a33b13e0ad302add61f009e5344735237ef" translate="yes" xml:space="preserve">
          <source>Anything after this line is the description of XSUB functions. These descriptions are translated by &lt;b&gt;xsubpp&lt;/b&gt; into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter.</source>
          <target state="translated">Все, что находится после этой строки, является описанием функций XSUB. Эти описания переводятся &lt;b&gt;xsubpp&lt;/b&gt; в код C, который реализует эти функции с использованием соглашений о вызовах Perl и делает эти функции видимыми из интерпретатора Perl.</target>
        </trans-unit>
        <trans-unit id="7767ddde79c4e54f955f8a8770af897489800878" translate="yes" xml:space="preserve">
          <source>Anything before this line is plain C code which describes which headers to include, and defines some convenience functions. No translations are performed on this part, apart from having embedded POD documentation skipped over (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) it goes into the generated output C file as is.</source>
          <target state="translated">Все, что находится перед этой строкой, представляет собой простой код C, который описывает, какие заголовки следует включать, и определяет некоторые вспомогательные функции. В этой части не выполняется никаких переводов, кроме того, что встроенная документация POD пропущена (см. &lt;a href=&quot;perlpod&quot;&gt;Perlpod&lt;/a&gt; ), она входит в сгенерированный выходной файл C как есть.</target>
        </trans-unit>
        <trans-unit id="9e010e0ae6e0590e5e1834d00dd2ae5e4328a555" translate="yes" xml:space="preserve">
          <source>Anything between white space and an end of line within a &lt;code&gt;MANIFEST&lt;/code&gt; file is considered to be a comment. Any line beginning with # is also a comment. Beginning with ExtUtils::Manifest 1.52, a filename may contain whitespace characters if it is enclosed in single quotes; single quotes or backslashes in that filename must be backslash-escaped.</source>
          <target state="translated">Все, что находится между пробелом и концом строки в файле &lt;code&gt;MANIFEST&lt;/code&gt; считается комментарием. Любая строка, начинающаяся с символа #, также является комментарием. Начиная с ExtUtils :: Manifest 1.52, имя файла может содержать символы пробела, если оно заключено в одинарные кавычки; одинарные кавычки или обратные косые черты в этом имени файла должны быть экранированы обратной косой чертой.</target>
        </trans-unit>
        <trans-unit id="d23663e502213da0e6ba19093e62429d22e02845" translate="yes" xml:space="preserve">
          <source>Anything else is a Perl-specific convenience abbreviation. Specify one or more scripts by names if you want short names that are script-specific.</source>
          <target state="translated">Все остальное-это специальная аббревиатура для удобства.Укажите один или несколько скриптов по именам,если вам нужны короткие имена,зависящие от конкретного скрипта.</target>
        </trans-unit>
        <trans-unit id="7d749de0de5c93aeb0a7eeebe5226cb0dd35304d" translate="yes" xml:space="preserve">
          <source>Anything in EXPR that matches PATTERN is taken to be a separator that separates the EXPR into substrings (called &quot;</source>
          <target state="translated">Все в EXPR,что соответствует ДАТЧИКЕ,считается разделителем,который разделяет EXPR на подстроки (называется &quot;</target>
        </trans-unit>
        <trans-unit id="beac50162375e06d01167c42cce2dc5426c4e092" translate="yes" xml:space="preserve">
          <source>Anything marked as BE is Big Endian (or network byte order) and LE is Little Endian (aka VAX byte order). For anything not marked either BE or LE, a character called Byte Order Mark (BOM) indicating the endianness is prepended to the string.</source>
          <target state="translated">Все,что помечено как BE,является Большим Эндианом (или сетевым порядком байт),а LE-Маленьким Эндианом (также известным как VAX порядок байт).Для всего,что не помечено ни BE,ни LE,к строке добавляется символ,называемый Byte Order Mark (BOM),указывающий на эндианность.</target>
        </trans-unit>
        <trans-unit id="09e186b65803161a334d1142c77aae1e01d4460e" translate="yes" xml:space="preserve">
          <source>Anything not listed here is not part of the public API, and should not be used by extension writers at all. For these reasons, blindly using functions listed in proto.h is to be avoided when writing extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c6485292ca5760fa287d9f9ae8c3f36373f766" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to &lt;a href=&quot;ExtUtils::MM_Any#postamble-%28o%29&quot;&gt;MY::postamble()&lt;/a&gt; if you have one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">Все,что здесь написано,будет передано в MY::postamble(),если она у вас есть.</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">Все, что следует за &lt;code&gt;#&lt;/code&gt; , рассматривается как комментарий.</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">Все, что вы можете на законных основаниях сказать в месте, где требуется &lt;b&gt;значение&lt;/b&gt; . Обычно состоит из &lt;b&gt;литералов&lt;/b&gt; , &lt;b&gt;переменных&lt;/b&gt; , &lt;b&gt;операторов&lt;/b&gt; , &lt;b&gt;функций&lt;/b&gt; и вызовов &lt;b&gt;подпрограмм&lt;/b&gt; , не обязательно в этом порядке.</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">В любом случае,вот оно.Должна работать на perl v4 или больше.Может,меньше.</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">В любом случае,это то,что ты можешь сделать,если не можешь помочь себе.</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">Где бы Вы ни поместили идентификатор (или цепочку идентификаторов)в качестве части имени переменной или подпрограмм,Вы можете заменить идентификатор на BLOCK,возвращая ссылку правильного типа.Другими словами,предыдущие примеры могут быть написаны таким образом:</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">Везде,куда бы Вы ни поместили идентификатор (или цепочку идентификаторов)в качестве части имени переменной или подпрограмм,Вы можете заменить идентификатор на простую скалярную переменную,содержащую ссылку правильного типа:</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache::GZip Revisited</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">Помимо того, что это не переносимо для некоторых операционных систем, это затрудняло использование &lt;code&gt;gzopen&lt;/code&gt; в ситуациях, когда вы хотели извлечь / создать поток данных gzip, который встроен в файл большего размера, без необходимости открывать и закрывать файл несколько раз. раз.</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">Помимо обсуждения интерфейса C,предоставляемого Perl для написания обратных вызовов,документ использует ряд примеров,чтобы показать,как интерфейс на самом деле работает на практике.Кроме того,рассматриваются некоторые методы кодирования обратных вызовов.</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">Помимо того, что теперь переменная &lt;code&gt;$^W&lt;/code&gt; является логической, она работает точно так же ужасно неконтролируемым глобальным образом, за исключением того, что она не может отключать / включать предупреждения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="03dfbadf395083cbac3ebe537f5fd26158769beb" translate="yes" xml:space="preserve">
          <source>Apart from resetting the iterator, &lt;code&gt;values @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt;. (We recommend that you use void context &lt;code&gt;keys @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;values @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">Кроме поведения,описанного выше,Perl не расширяет множественные уровни интерполяции.В частности,вопреки ожиданиям программистов-оболочек,обратные кавычки делают</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">Кроме первого параметра,импорт может принимать необязательный список параметров.Их можно использовать для передачи параметров фильтру.Например:</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Не считая избыточного, он во всех отношениях работает как Pod :: Text. См. &lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt; для подробностей и доступных опций.</target>
        </trans-unit>
        <trans-unit id="da695cf6105edcb1a8b40d8d706c52df71f42750" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9828a7d2d366fc4b8702a1f03e94b53802450369" translate="yes" xml:space="preserve">
          <source>Apollo Domain/OS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f771942800f2d67122e33798021164ef80e3a2" translate="yes" xml:space="preserve">
          <source>App::Cpan</source>
          <target state="translated">App::Cpan</target>
        </trans-unit>
        <trans-unit id="5d59978967734805e51a9980657b59fbf6558d9e" translate="yes" xml:space="preserve">
          <source>App::Cpan - easily interact with CPAN from the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove - реализует команду &lt;code&gt;prove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State - хранилище состояний для команды &lt;code&gt;prove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
