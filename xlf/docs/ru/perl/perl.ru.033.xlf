<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="eae6ee7e119fbc5f2aa2be859ce356e5505eb961" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">В некоторых Unix-системах select (2) может сообщать о дескрипторе файла сокета как о &amp;laquo;готовом к чтению&amp;raquo;, даже если данные недоступны, и, таким образом, любое последующее &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; будет блокироваться. Этого можно избежать, если всегда использовать O_NONBLOCK для сокета. Смотрите select (2) и fcntl (2) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c9de2fe586a63b0f77cf89fdbb109c06623eb1f4" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">В некоторых Unix-системах select (2) может сообщать о дескрипторе файла сокета как о &amp;laquo;готовом к чтению&amp;raquo;, даже если данные недоступны, и, таким образом, любое последующее &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; будет блокироваться. Этого можно избежать, если всегда использовать O_NONBLOCK для сокета. Смотрите select (2) и fcntl (2) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="5ae4b16cd5d25f3c3c80ae711072c40499b4bc55" translate="yes" xml:space="preserve">
          <source>On some older systems, it may sleep up to a full second less than what you requested, depending on how it counts seconds. Most modern systems always sleep the full amount. They may appear to sleep longer than that, however, because your process might not be scheduled right away in a busy multitasking system.</source>
          <target state="translated">На некоторых старых системах,он может спать до полной секунды меньше,чем вы просили,в зависимости от того,как он считает секунды.Большинство современных систем всегда спят полную сумму.Они могут показаться,чтобы спать дольше,чем это,однако,потому что ваш процесс может не быть запланирован сразу же в занятой многозадачности системы.</target>
        </trans-unit>
        <trans-unit id="558bd651fa8715821f75a4be7598cfc24234462e" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ed for.</source>
          <target state="translated">В некоторых операционных системах определенные обработчики сигналов должны &amp;laquo;что-то делать&amp;raquo; перед возвратом. Одним из примеров может быть CHLD или CLD, что указывает на завершение дочернего процесса. В некоторых операционных системах ожидается, что обработчик сигналов будет &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; завершения дочернего процесса. В таких системах схема отложенного сигнала не будет работать для этих сигналов: она не выполняет &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Опять же, сбой будет выглядеть как цикл, поскольку операционная система повторно отправит сигнал, потому что есть завершенные дочерние процессы, которые еще не &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b286c0e46361b954aaba8f772a4a53334de3bd4e" translate="yes" xml:space="preserve">
          <source>On some operating systems such as Win32 installation may not be possible until after a reboot has occurred. This can have varying consequences: removing an old DLL does not impact programs using the new one, but if a new DLL cannot be installed properly until reboot then anything depending on it must wait. The package variable</source>
          <target state="translated">На некоторых операционных системах,таких как Win32,установка может быть невозможна до тех пор,пока не произойдет перезагрузка.Это может иметь различные последствия:удаление старых DLL не влияет на программы,использующие новую,но если новая DLL не может быть установлена должным образом до перезагрузки,то все,что зависит от нее,должно подождать.Переменная пакета</target>
        </trans-unit>
        <trans-unit id="abbe82684e199993d30da7c411dda78b8ffa5204" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">В некоторых операционных системах, особенно Solaris и Unixware, вызов &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; из дочернего процесса сбрасывает и закрывает открытые дескрипторы файлов в родительском процессе, тем самым повреждая дескрипторы файлов. В этих системах вместо этого предлагается вызвать &lt;code&gt;_exit()&lt;/code&gt; . &lt;code&gt;_exit()&lt;/code&gt; доступен в Perl через модуль &lt;code&gt;POSIX&lt;/code&gt; . Пожалуйста, обратитесь к руководству вашей системы для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="e360f8c5bbe5608f4331396810f247c8a100f0a1" translate="yes" xml:space="preserve">
          <source>On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want. You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (for example, &lt;code&gt;;&lt;/code&gt; on many Unix shells and &lt;code&gt;&amp;amp;&lt;/code&gt; on the Windows NT &lt;code&gt;cmd&lt;/code&gt; shell).</source>
          <target state="translated">На некоторых платформах (особенно подобных DOS) оболочка может быть не способна работать с многострочными командами, поэтому добавление новой строки в строку может не дать вам того, что вы хотите. Вы можете быть в состоянии оценить несколько команд в одной строке, разделив их символом команды сепаратором, если ваша оболочка поддерживает , что (например, &lt;code&gt;;&lt;/code&gt; на многих оболочках Unix и &lt;code&gt;&amp;amp;&lt;/code&gt; на Windows NT &lt;code&gt;cmd&lt;/code&gt; оболочки).</target>
        </trans-unit>
        <trans-unit id="b7498bd2534b138ca9192ebcb30213ef70ed5c94" translate="yes" xml:space="preserve">
          <source>On some platforms Perl supports retrieving the C level backtrace (similar to what symbolic debuggers like gdb do).</source>
          <target state="translated">На некоторых платформах Perl поддерживает получение обратной связи на уровне C (аналогично тому,как это делают такие отладчики,как gdb).</target>
        </trans-unit>
        <trans-unit id="a9e0966de849860f2089841e81ee24c757771be3" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">На некоторых платформах,таких как Windows,где системный вызов fork()недоступен,Perl может быть собран для эмуляции fork()на уровне интерпретатора.Эта эмуляция имеет ограничения,связанные с убийством,которые должны быть рассмотрены,для кода,работающего под Windows и в коде,предназначенном для переноса.</target>
        </trans-unit>
        <trans-unit id="4dca8272040520711e1d36a027c5a86ea7b32ae2" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. While the emulation is designed to be as compatible as possible with the real fork() at the level of the Perl program, there are certain important differences that stem from the fact that all the pseudo child &quot;processes&quot; created this way live in the same real process as far as the operating system is concerned.</source>
          <target state="translated">На некоторых платформах,таких как Windows,где системный вызов fork()недоступен,Perl может быть собран для эмуляции fork()на уровне интерпретатора.Хотя эмуляция спроектирована так,чтобы быть максимально совместимой с реальной fork()на уровне программы на Perl,существуют некоторые важные различия,связанные с тем,что все псевдоподобные &quot;процессы&quot;,созданные таким образом,живут в одном и том же реальном процессе,что и операционная система.</target>
        </trans-unit>
        <trans-unit id="c6a78bf511c92cd39ee02c1151b5e571d5127a45" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">На некоторых платформах, таких как Windows, где системный вызов fork () недоступен, Perl может быть построен для эмуляции fork () в интерпретаторе Perl. Эмуляция разработана на уровне программы Perl, чтобы быть максимально совместимой с &quot;Unix&quot; fork (). Однако у него есть ограничения, которые необходимо учитывать в коде, предназначенном для переносимости. Смотрите &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="27073e810409a02dd0f24c371c3bfbfa303200d5" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">На некоторых платформах, таких как Windows, где системный вызов fork () недоступен, Perl может быть построен для эмуляции fork () в интерпретаторе Perl. Эмуляция разработана на уровне программы Perl, чтобы быть максимально совместимой с &quot;Unix&quot; fork (). Однако у него есть ограничения, которые необходимо учитывать в коде, предназначенном для переносимости. Смотрите &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8ed99749e4754bfa5b0b973c5aff98a5ab4786e4" translate="yes" xml:space="preserve">
          <source>On some platforms the thread-safe library interfaces may fail if the result buffer is too small (for example the user group databases may be rather large, and the reentrant interfaces may have to carry around a full snapshot of those databases). Perl will start with a small buffer, but keep retrying and growing the result buffer until the result fits. If this limitless growing sounds bad for security or memory consumption reasons you can recompile Perl with &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; defined to the maximum number of bytes you will allow.</source>
          <target state="translated">На некоторых платформах интерфейсы потоковобезопасных библиотек могут дать сбой, если буфер результатов слишком мал (например, базы данных групп пользователей могут быть довольно большими, а повторно входимые интерфейсы могут иметь полный снимок этих баз данных). Perl начнет с небольшого буфера, но продолжайте повторять попытки и увеличивать буфер результата, пока результат не будет соответствовать. Если этот безграничный рост звучит плохо по соображениям безопасности или потребления памяти, вы можете перекомпилировать Perl с &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; , определенным на максимальное количество байтов, которое вы позволите.</target>
        </trans-unit>
        <trans-unit id="79a433ae6e8abc1654ff92b55b4f90deb9b64777" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На некоторых платформах, например Windows, вся выделенная память, принадлежащая потоку, освобождается при завершении этого потока. Поэтому, если вам нужно, чтобы этого не происходило, вам нужно использовать функции общей памяти, такие как &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a5fee577d9d0e5cea7ff481ecfa7871d14cc642" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На некоторых платформах, например Windows, вся выделенная память, принадлежащая потоку, освобождается при завершении этого потока. Поэтому, если вам нужно, чтобы этого не происходило, вам нужно использовать функции общей памяти, такие как &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96135c965e974cf2dcbb35a5a0a72331dbb017cf" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На некоторых платформах, например Windows, вся выделенная память, принадлежащая потоку, освобождается при завершении этого потока. Поэтому, если вам нужно, чтобы этого не происходило, вам нужно использовать функции общей памяти, такие как &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a47d30d42c677c2e62622d2c25ff6400601837c5" translate="yes" xml:space="preserve">
          <source>On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).</source>
          <target state="translated">На некоторых платформах,например Windows NT,невозможно разблокировать открытый файл (сначала файл должен быть закрыт).На этих платформах фактическое развязывание откладывается до окончания работы программы и возвращения ей хорошего состояния.Проверка все равно выполняется для того,чтобы убедиться,что хэндл файла и имя файла указывают на одно и то же (но не в момент выполнения конечного блока,т.к.отложенное удаление может не иметь доступа к хэндлу файла).</target>
        </trans-unit>
        <trans-unit id="9e21af4bec3442feba775d62193829f8b7a0c4e5" translate="yes" xml:space="preserve">
          <source>On some platforms, it might not be possible to destroy</source>
          <target state="translated">На некоторых платформах,возможно,не удастся уничтожить</target>
        </trans-unit>
        <trans-unit id="b340b3bd6640d116c671c5bca7f5a658b943c207" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;b&gt;-Dp&lt;/b&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">На некоторых платформах это также заставляет Perl добавлять суффиксы к имени файла при его поиске. Например, на платформах Win32 суффиксы &amp;laquo;.bat&amp;raquo; и &amp;laquo;.cmd&amp;raquo; добавляются, если поиск исходного имени завершается неудачно, и если имя еще не оканчивается одним из этих суффиксов. Если ваш Perl был скомпилирован с &lt;code&gt;DEBUGGING&lt;/code&gt; , использование переключателя &lt;b&gt;-Dp&lt;/b&gt; на Perl показывает, как продвигается поиск.</target>
        </trans-unit>
        <trans-unit id="e74540fb7a91002e20c8eda026f9bf8b28624a25" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) binmode() is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">На некоторых системах (в общем,системах на базе DOS и Windows)функция binmode()необходима,когда вы не работаете с текстовым файлом.Ради переносимости всегда полезно использовать его,когда это уместно,и никогда не использовать его,когда это не уместно.Также,люди могут устанавливать свои входы/выходы по умолчанию в кодировке UTF8 Unicode,а не в байтах.</target>
        </trans-unit>
        <trans-unit id="bae1ed91e60744c25391f2c5a28e8865cb837e1c" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with new_from_fd(), or created with accept() from such an object, the protocol(), sockdomain() and socktype() methods may return undef.</source>
          <target state="translated">На некоторых системах для объекта IO::Socket,созданного с помощью new_from_fd(),или созданного с помощью accept()из такого объекта,методы protocol(),sockdomain()и socktype()могут возвращать undef.</target>
        </trans-unit>
        <trans-unit id="5cb77e1072ab2963baa8f6d218988c1f72414bff" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;code&gt;strftime()&lt;/code&gt; function has been extended in a non-standard way to use a &lt;code&gt;%C&lt;/code&gt; format, which they sometimes claim is the &quot;century&quot;. It isn't, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to determine reliably the current century or millennium.</source>
          <target state="translated">В некоторых системах функция &lt;code&gt;strftime()&lt;/code&gt; модуля &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; была расширена нестандартным способом для использования формата &lt;code&gt;%C&lt;/code&gt; , который они иногда называют &amp;laquo;веком&amp;raquo;. Это не так, потому что в большинстве таких систем это только первые две цифры четырехзначного года, и поэтому они не могут использоваться для надежного определения текущего столетия или тысячелетия.</target>
        </trans-unit>
        <trans-unit id="9a2307b9852232321e1093b21cd83d1ba46b51a6" translate="yes" xml:space="preserve">
          <source>On some systems, there can be cooperative and preemptive threads running simultaneously. (Threads running with realtime priorities often behave cooperatively, for example, while threads running at normal priorities behave preemptively.)</source>
          <target state="translated">На некоторых системах могут одновременно работать кооперативные и упреждающие потоки.(Потоки,работающие с приоритетами реального времени,часто ведут себя совместно,например,в то время как потоки,работающие с нормальными приоритетами,ведут себя упреждающе).</target>
        </trans-unit>
        <trans-unit id="14dcaed53f17e703b8cfce8077083c7079226d84" translate="yes" xml:space="preserve">
          <source>On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">На некоторых системах,возможно,придется менять одиночные кавычки на двойные,что необходимо</target>
        </trans-unit>
        <trans-unit id="a73b71b53a0ef6fd5b9c990fee1a5a53d7f99a60" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 3 elements is returned. The elements are:</source>
          <target state="translated">При успешной работе в контексте списка возвращается массив из 3 элементов.Элементы являются:</target>
        </trans-unit>
        <trans-unit id="104cbe85a4799563175bc8875552e7ec3d9444ff" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 6 elements is returned. The elements are:</source>
          <target state="translated">При успешной работе в контексте списка возвращается массив из 6 элементов.Элементы являются:</target>
        </trans-unit>
        <trans-unit id="bb19677ff47ab7a0061dc31fa21208b0fdd0ce0e" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">В случае успеха $ decoder - это объект, который задокументирован в &lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding&lt;/a&gt; . Итак, теперь вы можете это сделать;</target>
        </trans-unit>
        <trans-unit id="9ed1d2d6abe6133cffe9d52759b8403cf251f405" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; returns the</source>
          <target state="translated">В случае успеха автоумирающая форма &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="555bab907001ef6e8e0bb6e66b34e7245218e3f9" translate="yes" xml:space="preserve">
          <source>On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.</source>
          <target state="translated">На системах,не поддерживающих уровни безопасности HIGH или MEDIUM (например,Win NT или OS/2),любая попытка изменить уровень будет проигнорирована.Решение игнорировать,а не поднимать уровень исключений,позволяет писать портативные программы с высокой степенью безопасности для систем,которые могут это поддерживать,без тех программ,которые выходят из строя в системах,где дополнительные тесты не имеют отношения к делу.</target>
        </trans-unit>
        <trans-unit id="0c0c64b8ddf70f7334be3908bef0a4e5be9026f3" translate="yes" xml:space="preserve">
          <source>On systems that don't have locales, this pragma will cause your operations to behave as if in the &quot;C&quot; locale; attempts to change the locale will fail.</source>
          <target state="translated">На системах,не имеющих локалей,эта прагма приведет к тому,что ваши операции будут вести себя так,как будто в &quot;C&quot; локали;попытки изменить локаль будут безуспешными.</target>
        </trans-unit>
        <trans-unit id="8a74a95b0c966e10aac8d77a4f0a3bf544781a21" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the $base filename. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">В системах с грамматикой,которая указывает имена файлов,это игнорирует $base имя файла.В противном случае все компоненты пути считаются каталогами.</target>
        </trans-unit>
        <trans-unit id="1b51da93b22332f93d96c5b573c9ad75ab82f7bf" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the &lt;code&gt;$base&lt;/code&gt; filename as well. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">В системах, в которых есть грамматика, указывающая имена файлов, это также игнорирует имя файла &lt;code&gt;$base&lt;/code&gt; . В противном случае предполагается, что все компоненты пути являются каталогами.</target>
        </trans-unit>
        <trans-unit id="5314c4a5a0cc48c834a98edadeb967581bfc1cbf" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">В системах , которые поддерживают флаг крупным по-Exec на файлах, этот флаг устанавливается на всех вновь открытых файловых дескрипторов , чьи &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s являются</target>
        </trans-unit>
        <trans-unit id="be056ae4f4d92fcc824ea5af426faa5948d961c7" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">В системах , которые поддерживают флаг крупным по-Exec на файлах, этот флаг устанавливается на всех вновь открытых файловых дескрипторов , чьи &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s являются</target>
        </trans-unit>
        <trans-unit id="3fcf7eb3896f4c5961c6c4a30af97fd660da9d5d" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах , которые поддерживают тесную-на-Exec флаг на файлах, флаг будет установлен для вновь открытого дескриптора файла , как определено значением &lt;code&gt;$^F&lt;/code&gt; . Смотрите &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c665037f5c6992c82bd182869050b43d00b7e424" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах , которые поддерживают тесную-на-Exec флаг на файлах, флаг будет установлен для вновь открытого дескриптора файла , как определено значением &lt;code&gt;$^F&lt;/code&gt; . Смотрите &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a490a64d93357b4e803f1bde203444d3253ea771" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытого файлового дескриптора, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8889b4502c97331fb6c0d71d79b94f89a2ce179" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытого файлового дескриптора, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="901c01459d3ad6fdd533264983a881490e329c6b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытых файловых дескрипторов, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4b0eeffda71eae98ca0b23d4d9a435052a31c58" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытых файловых дескрипторов, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0bcb70dd655374823428e8ecf318b875be23f0d" translate="yes" xml:space="preserve">
          <source>On systems that support a real flock(2), locks are inherited across fork() calls, whereas those that must resort to the more capricious fcntl(2) function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">На системах,которые поддерживают реальный флок(2),блокировки наследуются через вызовы fork(),в то время как те,кто должен прибегнуть к более капризной функции fcntl(2),теряют свои блокировки,что значительно усложняет запись серверов.</target>
        </trans-unit>
        <trans-unit id="92426fd5bb12f295ba78cf2e855950f52eab1f1b" translate="yes" xml:space="preserve">
          <source>On systems that support fchdir(2), you may pass a filehandle or directory handle as the argument. On systems that don't support fchdir(2), passing handles raises an exception.</source>
          <target state="translated">На системах,поддерживающих fchdir(2),вы можете передать в качестве аргумента дескриптор файла или дескриптор каталога.На системах,которые не поддерживают fchdir(2),передача дескрипторов вызывает исключение.</target>
        </trans-unit>
        <trans-unit id="92172c92aed2c4eacbbf108b43a01fa41c1e7227" translate="yes" xml:space="preserve">
          <source>On systems that support fchmod(2), you may pass filehandles among the files. On systems that don't support fchmod(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">На системах,поддерживающих fchmod(2),вы можете передавать файловые дескрипторы между файлами.На системах,не поддерживающих fchmod(2),передача файловых дескрипторов вызывает исключение.Файловые дескрипторы должны передаваться в виде глобусов или глобусных ссылок,чтобы их можно было распознать;пустые слова считаются именами файлов.</target>
        </trans-unit>
        <trans-unit id="dc52e8f7e1c0866f647ccf5e1cd248ecabff8b5f" translate="yes" xml:space="preserve">
          <source>On systems that support fchown(2), you may pass filehandles among the files. On systems that don't support fchown(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">На системах,поддерживающих fchown(2),вы можете передавать файловые дескрипторы между файлами.На системах,которые не поддерживают fchown(2),передача файловых дескрипторов вызывает исключение.Для распознавания файловые дескрипторы должны передаваться в виде глобусов или глобусных ссылок;пустые слова считаются именами файлов.</target>
        </trans-unit>
        <trans-unit id="9d32f7bede11ac1c00998cc26b587f02c25e363b" translate="yes" xml:space="preserve">
          <source>On systems that support futimes(2), you may pass filehandles among the files. On systems that don't support futimes(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">На системах,поддерживающих futimes(2),можно передавать файловые дескрипторы между файлами.На системах,которые не поддерживают futimes(2),передача файловых дескрипторов вызывает исключение.Файловые дескрипторы должны передаваться в виде глобусов или глобусных ссылок,чтобы их можно было распознать;пустые слова считаются именами файлов.</target>
        </trans-unit>
        <trans-unit id="c71329e94ef821ac647632fa2fb53326dd2a9466" translate="yes" xml:space="preserve">
          <source>On systems that supported it, older versions of Perl used the SA_RESTART flag when installing %SIG handlers. This meant that restartable system calls would continue rather than returning when a signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0 and later do</source>
          <target state="translated">На системах,которые его поддерживали,старые версии Perl использовали флаг SA_RESTART при установке обработчиков %SIG.Это означало,что перезагрузка системных вызовов будет продолжаться,а не возвращаться при поступлении сигнала.Для того,чтобы доставить отложенные сигналы быстро,Perl 5.8.0 и более поздние версии делают следующее</target>
        </trans-unit>
        <trans-unit id="6ba77bd32e9b25ffdeddd2abe71a6e9ea02320ab" translate="yes" xml:space="preserve">
          <source>On systems traditionally bereft of a usable &lt;b&gt;man&lt;/b&gt; command, the debugger invokes &lt;b&gt;perldoc&lt;/b&gt;. Occasionally this determination is incorrect due to recalcitrant vendors or rather more felicitously, to enterprising users. If you fall into either category, just manually set the $DB::doccmd variable to whatever viewer to view the Perl documentation on your system. This may be set in an rc file, or through direct assignment. We're still waiting for a working example of something along the lines of:</source>
          <target state="translated">В системах, традиционно лишенных &lt;b&gt;доступной&lt;/b&gt; для использования команды &lt;b&gt;man&lt;/b&gt; , отладчик вызывает &lt;b&gt;perldoc&lt;/b&gt; . Иногда это определение оказывается неверным из-за непокорности продавцов или, что более удачно, из-за предприимчивых пользователей. Если вы попадаете в любую категорию, просто вручную установите переменную $ DB :: doccmd для любого средства просмотра, чтобы просмотреть документацию Perl в вашей системе. Это может быть установлено в файле rc или путем прямого назначения. Мы все еще ждем рабочего примера чего-то вроде:</target>
        </trans-unit>
        <trans-unit id="495743307752ec1e7f711d11bd0bef034af0b675" translate="yes" xml:space="preserve">
          <source>On systems which do support negative epoch values, this module should be able to cope with dates before the start of the epoch, down the minimum value of time_t for the system.</source>
          <target state="translated">В системах,которые поддерживают отрицательные значения эпох,этот модуль должен уметь справляться с датами до начала эпохи,вниз по минимальному значению time_t для системы.</target>
        </trans-unit>
        <trans-unit id="46c423b9491070d51507de37df7f4e753a419998" translate="yes" xml:space="preserve">
          <source>On systems with restrictions on file name length, the file corresponding to a subroutine may have a shorter name that the routine itself. This can lead to conflicting file names. The</source>
          <target state="translated">В системах с ограничениями по длине имени файла,файл,соответствующий подпрограмме,может иметь более короткое имя,чем сама подпрограмма.Это может привести к конфликтующим именам файлов..</target>
        </trans-unit>
        <trans-unit id="fec43c22ce98f30270ab97bbbb4fe9d6075857b3" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a &lt;a href=&quot;file://&quot;&gt;file:////&lt;/a&gt; url. On other operating systems returns empty.</source>
          <target state="translated">В системах с концепцией &lt;a href=&quot;file://&quot;&gt;общего&lt;/a&gt; сетевого ресурса (в настоящее время только Windows) возвращает общее имя из файла: //// url. В других операционных системах возвращается пустым.</target>
        </trans-unit>
        <trans-unit id="928cc7ef7cb478fdbb60e26c8543bd66bba1f884" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt; . Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt; , which resulted in garbage results part of the time.</source>
          <target state="translated">В системах с концепцией тома, если &lt;code&gt;$path&lt;/code&gt; и &lt;code&gt;$base&lt;/code&gt; находятся на двух разных томах, мы не будем пытаться разрешить два пути, а вместо этого просто вернем &lt;code&gt;$path&lt;/code&gt; . Обратите внимание, что предыдущие версии этого модуля игнорировали объем &lt;code&gt;$base&lt;/code&gt; , что в некоторых случаях приводило к получению мусора.</target>
        </trans-unit>
        <trans-unit id="04b62c831c8eef6cc7d4b1d7cdb6bf880f9b84f3" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt; ) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">В текстовых полях каретка включает своего рода режим заполнения. Вместо произвольного выражения передаваемое значение должно быть скалярной переменной, содержащей текстовую строку. Perl помещает следующую часть текста в поле, а затем обрезает переднюю часть строки, чтобы при следующей ссылке на переменную можно было напечатать больше текста. (Да, это означает, что сама переменная изменяется во время выполнения вызова write () и не восстанавливается.) Следующая часть текста определяется грубым алгоритмом разрыва строки. Вы можете использовать символ возврата каретки ( &lt;code&gt;\r&lt;/code&gt; ) для принудительного разрыва строки. Вы можете изменить допустимые символы для разбиения, изменив переменную &lt;code&gt;$:&lt;/code&gt; (это $ FORMAT_LINE_BREAK_CHARACTERS, если вы используете английский модуль) к списку нужных символов.</target>
        </trans-unit>
        <trans-unit id="c0193cc78fe98d1b4b454c6f69412908ead97760" translate="yes" xml:space="preserve">
          <source>On the AS/400, if PERL5 is in your library list, you may need to wrap your Perl scripts in a CL procedure to invoke them like so:</source>
          <target state="translated">В AS/400,если PERL5 находится в списке вашей библиотеки,вам может понадобиться завернуть ваши Perl скрипты в процедуру CL,чтобы вызвать их таким образом:</target>
        </trans-unit>
        <trans-unit id="ea65f5f2a1cec2b70340514d27743f128cc959b6" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt; .</source>
          <target state="translated">В данной программе, идентифицированной по &lt;code&gt;program_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c9fcecabc9c2ff5c185e1af9b86fe28cd4ccda1" translate="yes" xml:space="preserve">
          <source>On the mainframe Perl currently works under the &quot;Unix system services for OS/390&quot; (formerly known as OpenEdition), VM/ESA OpenEdition, or the BS200 POSIX-BC system (BS2000 is supported in Perl 5.6 and greater). See &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; for details. Note that for OS/400 there is also a port of Perl 5.8.1/5.10.0 or later to the PASE which is ASCII-based (as opposed to ILE which is EBCDIC-based), see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;.</source>
          <target state="translated">На мэйнфрейме Perl в настоящее время работает под &amp;laquo;системными службами Unix для OS / 390&amp;raquo; (ранее известными как OpenEdition), VM / ESA OpenEdition или системой BS200 POSIX-BC (BS2000 поддерживается в Perl 5.6 и выше). Подробности см. На &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; . Обратите внимание, что для OS / 400 существует также порт Perl 5.8.1 / 5.10.0 или более поздней версии для PASE, основанный на ASCII (в отличие от ILE, основанного на EBCDIC), см. &lt;a href=&quot;perlos400&quot;&gt;Perlos400&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="580309d3af9907826e397d1c3342546e17a8ad3c" translate="yes" xml:space="preserve">
          <source>On the opposite end of the scale, a declaration like</source>
          <target state="translated">На противоположном конце шкалы,декларация вроде</target>
        </trans-unit>
        <trans-unit id="30429117a84b2dd407e0605edcb4b807f19cd366" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want the other meaning, you can do this:</source>
          <target state="translated">С другой стороны,если вы хотите другого значения,вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="fbae3feec67f27fa104cf2845f242f528c54850f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the array element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">С другой стороны, если вы действительно надеялись рассматривать элемент массива как список, вам нужно посмотреть, как работают ссылки, потому что Perl не будет волшебным образом преобразовывать скаляры в списки за вас. См. &lt;a href=&quot;perlref&quot;&gt;Perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce76eb877363ead375654de95e60f5e7b6c574b5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the hash element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">С другой стороны, если вы действительно надеялись рассматривать хэш-элемент как список, вам нужно посмотреть, как работают ссылки, потому что Perl не будет волшебным образом преобразовывать скаляры в списки за вас. См. &lt;a href=&quot;perlref&quot;&gt;Perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="528cd15a9b0aff8a5cdc97823c4262e5cf5bb2ab" translate="yes" xml:space="preserve">
          <source>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.</source>
          <target state="translated">С другой стороны,автоматическое смешивание различных кодировок национальных стандартов работает,если только $data не слишком короток,чтобы можно было угадать.</target>
        </trans-unit>
        <trans-unit id="095e1a5231bfc256caf5b97c9e59036a8cd94e78" translate="yes" xml:space="preserve">
          <source>On the other hand, sometimes you want to clobber whatever might already be there. To empty out a file before you start writing to it, you can open it in write-only mode:</source>
          <target state="translated">С другой стороны,иногда тебе хочется засорить то,что уже может быть там.Чтобы очистить файл перед началом записи в него,вы можете открыть его в режиме только для записи:</target>
        </trans-unit>
        <trans-unit id="94024e45d5031c319fa3ba71f3df1c69292913dd" translate="yes" xml:space="preserve">
          <source>On the other hand:</source>
          <target state="translated">С другой стороны:</target>
        </trans-unit>
        <trans-unit id="f18fa46000a23ad2307a5bee120c399fc4cc324f" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; , and &lt;code&gt;&quot;not&quot;&lt;/code&gt; , which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">Справа от оператора списка запятая имеет очень низкий приоритет, так что она контролирует все найденные там выражения, разделенные запятыми. Единственными операторами с более низким приоритетом являются логические операторы &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; и &lt;code&gt;&quot;not&quot;&lt;/code&gt; , которые могут использоваться для оценки вызовов операторов списка без необходимости использования скобок:</target>
        </trans-unit>
        <trans-unit id="c0b2c5bcb8fba3a9644276ad63b66e732faef04f" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;).</source>
          <target state="translated">На этих платформах имейте в виду, что набор символов EBCDIC может влиять на то, что происходит с некоторыми функциями Perl (такими как &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ), а также на использование битов с Константы ASCII с использованием операторов типа &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;|&lt;/code&gt; , не говоря уже о работе с интерфейсами сокетов для компьютеров ASCII (см. &lt;a href=&quot;#Newlines&quot;&gt;Новые строки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf1c918758fe737aef37e1c0ba64400f9f7705ae" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">На тех платформах и компиляторах, где &lt;code&gt;bool&lt;/code&gt; действительно является логическим (C ++, C99), легко забыть приведение. Вы можете заставить &lt;code&gt;bool&lt;/code&gt; быть &lt;code&gt;char&lt;/code&gt; , скомпилировав с &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . Вы также можете запустить &lt;code&gt;Configure&lt;/code&gt; с чем-то вроде</target>
        </trans-unit>
        <trans-unit id="750180603d4fade1f60619d413443d4388791bcb" translate="yes" xml:space="preserve">
          <source>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. It will be called with the preconstructed new &lt;code&gt;regexp&lt;/code&gt; structure as an argument, the &lt;code&gt;pprivate&lt;/code&gt; member will point at the &lt;b&gt;old&lt;/b&gt; private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</source>
          <target state="translated">В многопоточных сборках может потребоваться дублирование регулярного выражения, чтобы шаблон можно было использовать в нескольких потоках. Ожидается, что эта процедура будет обрабатывать дублирование любых личных данных, на которые &lt;code&gt;pprivate&lt;/code&gt; член pprivate структуры &lt;code&gt;regexp&lt;/code&gt; . Он будет вызываться с предварительно сконструированной новой структурой &lt;code&gt;regexp&lt;/code&gt; в качестве аргумента, член &lt;code&gt;pprivate&lt;/code&gt; будет указывать на &lt;b&gt;старую&lt;/b&gt; частную структуру, и эта подпрограмма несет ответственность за создание копии и возврат на нее указателя (который Perl затем будет использовать для перезаписи поле, переданное в эту процедуру.)</target>
        </trans-unit>
        <trans-unit id="c8ce1f6dab9f2ca8a499735e7d64c50092c9a849" translate="yes" xml:space="preserve">
          <source>On unthreaded builds this field doesn't exist.</source>
          <target state="translated">На непонятных стройках этого поля не существует.</target>
        </trans-unit>
        <trans-unit id="baf07ba18b50ccd1689ea2941fb77a3117773a24" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt; ) have been called, all further output from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">После &lt;code&gt;test_out&lt;/code&gt; или &lt;code&gt;test_err&lt;/code&gt; (или &lt;code&gt;test_fail&lt;/code&gt; или &lt;code&gt;test_diag&lt;/code&gt; ) весь дальнейший вывод &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; будет захвачен &lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester&lt;/a&gt; . Это означает, что вы не сможете выполнять дальнейшие тесты для нормального вывода обычным способом, пока не &lt;code&gt;test_test&lt;/code&gt; (ну, если вы вручную не вмешиваетесь в дескрипторы выходных файлов)</target>
        </trans-unit>
        <trans-unit id="9443afa365a30ff5f37332fa968121f2dbb81425" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;../harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">После &lt;code&gt;test_test&lt;/code&gt; выходные данные теста будут перенаправлены обратно на исходные дескрипторы файлов, к которым был подключен &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; (возможно, STDOUT и STDERR), что означает, что любые последующие тесты, которые вы запускаете, будут работать нормально и вызовут успех / ошибки для &lt;a href=&quot;../harness&quot;&gt;Test :: Harness&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0908b28a0f268394a7964fa489d2fda27d507a0" translate="yes" xml:space="preserve">
          <source>Once EOF is detected (&lt;code&gt;$status&lt;/code&gt; is zero) the filter will insert an extra line into the source stream. When this extra line is executed it will print a count of the number of substitutions actually made. Note that &lt;code&gt;$status&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in this case.</source>
          <target state="translated">Как только EOF обнаружен ( &lt;code&gt;$status&lt;/code&gt; равен нулю), фильтр вставит дополнительную строку в исходный поток. Когда эта дополнительная строка будет выполнена, она напечатает количество фактически сделанных замен. Обратите внимание, что в этом случае &lt;code&gt;$status&lt;/code&gt; установлен в &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48f0ab6402e0ed10a074d92b2f594ddaae93f903" translate="yes" xml:space="preserve">
          <source>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to $`, part to $&amp;amp;, and part to $'. Thus the penalty is most severe with long strings and patterns that match often. Avoid $&amp;amp;, $', and $` if you can, but if you can't, once you've used them at all, use them at will because you've already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the $&amp;amp; variable is no longer &quot;expensive&quot; the way the other two are.</source>
          <target state="translated">Как только Perl видит, что вам нужна одна из этих переменных в любом месте программы, он предоставляет их при каждом совпадении с образцом. Это означает, что при каждом совпадении с шаблоном вся строка будет скопирована, часть - в $ `, часть - в $ &amp;amp;, а часть - в $ '. Таким образом, штраф наиболее серьезен для длинных строк и часто совпадающих шаблонов. Избегайте $ &amp;amp;, $ 'и $ `, если можете, но если вы не можете, когда вы их вообще использовали, используйте их по своему желанию, потому что вы уже заплатили цену. Помните, что некоторые алгоритмы их действительно ценят. Начиная с версии 5.005, переменная $ &amp;amp; больше не &quot;дорогая&quot;, как две другие.</target>
        </trans-unit>
        <trans-unit id="296ec9cb13f85c2f6eee6c3dfe23452785f51838" translate="yes" xml:space="preserve">
          <source>Once a feature, construct or module has been marked as deprecated, we may remove it from the Perl core. Unsurprisingly, we say we've &lt;b&gt;removed&lt;/b&gt; these things. When a module is removed, it will no longer ship with Perl, but will continue to be available on CPAN.</source>
          <target state="translated">Как только функция, конструкция или модуль помечены как устаревшие, мы можем удалить их из ядра Perl. Неудивительно, что мы говорим, что &lt;b&gt;удалили&lt;/b&gt; эти вещи. После удаления модуля он больше не будет поставляться с Perl, но будет по-прежнему доступен на CPAN.</target>
        </trans-unit>
        <trans-unit id="7394cfde1fc1b93e93cb9b4f086c54f1b9ffd59b" translate="yes" xml:space="preserve">
          <source>Once a module has been included in the Perl core, however, everyone involved in maintaining Perl should be aware that the module is still the property of the original author unless the original author explicitly gives up their ownership of it. In particular:</source>
          <target state="translated">Однако,как только модуль включен в ядро Perl,все,кто участвует в поддержке Perl,должны знать,что модуль все еще является собственностью оригинального автора,если только оригинальный автор явно не отказывается от своего права собственности на него.В частности:</target>
        </trans-unit>
        <trans-unit id="395a04379c153d488a5c8556f8b5ec9aaac6c9a5" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">Как только референт был благословлен, &lt;code&gt;blessed&lt;/code&gt; функция из основного модуля &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; может сообщить нам имя своего класса. Эта подпрограмма возвращает класс объекта при передаче объекта и false в противном случае.</target>
        </trans-unit>
        <trans-unit id="591c19dc13259933f77d04158c9b97cb405eddcb" translate="yes" xml:space="preserve">
          <source>Once a thread is detached, it may not be joined, and any return data that it might have produced (if it was done and waiting for a join) is lost.</source>
          <target state="translated">Как только поток отсоединяется,он не может быть присоединен,и любые данные,которые он мог получить (если это было сделано и ожидание присоединения),теряются.</target>
        </trans-unit>
        <trans-unit id="12df76345c558476956303e6bd354373a1af6336" translate="yes" xml:space="preserve">
          <source>Once a todo test starts succeeding, simply move it outside the block. When the block is empty, delete it.</source>
          <target state="translated">Как только тест на тодо начнется успешно,просто переместите его за пределы блока.Когда блок будет пуст,удалите его.</target>
        </trans-unit>
        <trans-unit id="de1c57e84d4335aa8d593dcd913db4541c9be506" translate="yes" xml:space="preserve">
          <source>Once a variable is removed, its use triggers an error telling you the variable is unsupported.</source>
          <target state="translated">Как только переменная удаляется,ее использование вызывает ошибку,говорящую о том,что она не поддерживается.</target>
        </trans-unit>
        <trans-unit id="aeba7900e971ad3f9f9e894e67cc3b717aab109e" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; has done all the work for you. They produce the standard &lt;code&gt;Makefile.PL&lt;/code&gt; you see when you download and install modules, and this produces a Makefile with a &lt;code&gt;dist&lt;/code&gt; target.</source>
          <target state="translated">И снова &lt;code&gt;module-starter&lt;/code&gt; или &lt;code&gt;h2xs&lt;/code&gt; сделали всю работу за вас. Они создают стандартный &lt;code&gt;Makefile.PL&lt;/code&gt; ,который вы видите при загрузке и установке модулей, и это создает Makefile с целью &lt;code&gt;dist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1aff24b00940dd82d1491dbe39c6cb52b648ed" translate="yes" xml:space="preserve">
          <source>Once approved, changes are merged into &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;, the repository which drives &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;, and they are distributed with the next Perl 5 release.</source>
          <target state="translated">После утверждения изменения объединяются в &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt; , репозиторий, который управляет &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; , и распространяются со следующим выпуском Perl 5.</target>
        </trans-unit>
        <trans-unit id="2b54e888aa5f3b1e9daaa58b06235556e830e504" translate="yes" xml:space="preserve">
          <source>Once at the command line, type &lt;code&gt;h&lt;/code&gt; for one-page help screen; the rest should be self-explanatory.</source>
          <target state="translated">В командной строке введите &lt;code&gt;h&lt;/code&gt; , чтобы открыть одностраничный экран справки; остальное не требует пояснений.</target>
        </trans-unit>
        <trans-unit id="480a6fac81e70daea3f924bcfe32eba60a95619a" translate="yes" xml:space="preserve">
          <source>Once called the FILE * should</source>
          <target state="translated">После вызова ФИЛА*должен</target>
        </trans-unit>
        <trans-unit id="fadbaf9125427892864d707c6d22361430d22b8f" translate="yes" xml:space="preserve">
          <source>Once ended, no more items may be placed in the queue.</source>
          <target state="translated">После окончания,больше нельзя ставить предметы в очередь.</target>
        </trans-unit>
        <trans-unit id="916fa7b57196ffe55f0094ed9d80bbb62daf5b2c" translate="yes" xml:space="preserve">
          <source>Once mapped, you can treat &lt;code&gt;$string&lt;/code&gt; as you would any other string. Since you don't necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</source>
          <target state="translated">После сопоставления вы можете обращаться с &lt;code&gt;$string&lt;/code&gt; как с любой другой строкой. Поскольку вам не обязательно загружать данные, mmap-процесс может быть очень быстрым и не может увеличить объем памяти.</target>
        </trans-unit>
        <trans-unit id="48df5812892e79e577960bece1b7fde5e79ea047" translate="yes" xml:space="preserve">
          <source>Once miniperl.exe creation is over, run nmake from the NetWare folder. This will build the Perl interpreter for NetWare as</source>
          <target state="translated">После создания miniperl.exe запустите nmake из папки NetWare.Это создаст интерпретатор Perl для NetWare как</target>
        </trans-unit>
        <trans-unit id="f6c4f57a7ab5a360e46162416f69b58e4d7acd9a" translate="yes" xml:space="preserve">
          <source>Once picked, it is important to stick to your version scheme, without reducing the number of digits. This is because &quot;downstream&quot; packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.</source>
          <target state="translated">После выбора,важно придерживаться схемы версий,не уменьшая при этом количество цифр.Это происходит потому,что &quot;последующие&quot; упаковщики,такие как система портов FreeBSD,интерпретируют номера версий различными способами.Если вы измените количество цифр в вашей схеме версий,вы можете запутать эти системы,чтобы они вывели из строя версии вашего модуля,что,очевидно,плохо.</target>
        </trans-unit>
        <trans-unit id="07633063ecd66c0146fe9d11656fc4703df1f61f" translate="yes" xml:space="preserve">
          <source>Once produced Makefiles for MacOS Classic</source>
          <target state="translated">Однажды выпущенные Makefiles для MacOS Classic</target>
        </trans-unit>
        <trans-unit id="654d50c5d753e55a4e1dbf0b00907d7f4969d3a9" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre/post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt; .</source>
          <target state="translated">После регистрации нет механизма для отключения этих хуков, поэтому, если это необходимо, вам нужно будет сделать это самостоятельно. Запись в &lt;code&gt;%^H&lt;/code&gt; , вероятно, является лучшим способом, поэтому эффект имеет лексическую область видимости; однако также можно использовать макросы &lt;code&gt;BhkDISABLE&lt;/code&gt; и &lt;code&gt;BhkENABLE&lt;/code&gt; для временного включения и выключения записей. Вы также должны знать, что, вообще говоря, по крайней мере одна область будет открыта до загрузки вашего расширения, поэтому вы увидите некоторые пары &lt;code&gt;pre/post_end&lt;/code&gt; , у которых не было соответствующего &lt;code&gt;start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbf6b188e1d6cda2b1c31b9f2ea910f75bac5ce6" translate="yes" xml:space="preserve">
          <source>Once the 'aaab' at the start of the string has matched, and the &lt;code&gt;(*SKIP)&lt;/code&gt; executed, the next starting point will be where the cursor was when the &lt;code&gt;(*SKIP)&lt;/code&gt; was executed.</source>
          <target state="translated">После совпадения &amp;laquo;aaab&amp;raquo; в начале строки и выполнения &lt;code&gt;(*SKIP)&lt;/code&gt; следующей начальной точкой будет то место, где находился курсор при выполнении &lt;code&gt;(*SKIP)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8672a62497c5f795c9c2acf9e29afcdfcf0e6269" translate="yes" xml:space="preserve">
          <source>Once the AV has been created, the following operations are possible on it:</source>
          <target state="translated">После того,как AV был создан,над ним можно выполнить следующие операции:</target>
        </trans-unit>
        <trans-unit id="67df8d841097b17fc29c0a4ea72cc77f4ff9a4eb" translate="yes" xml:space="preserve">
          <source>Once the HV has been created, the following operations are possible on it:</source>
          <target state="translated">После создания HV над ним можно выполнить следующие операции:</target>
        </trans-unit>
        <trans-unit id="57df9a521b252465d2cd33284b38479df5df9b79" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt; ). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt; , as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt; , they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">После применения фильтрации исходные строки, регулярные выражения, POD и т. Д. Повторно вставляются в код, заменяя каждый заполнитель соответствующим исходным компонентом (из &lt;code&gt;@components&lt;/code&gt; ). Обратите внимание, что это означает, что с переменной &lt;code&gt;@components&lt;/code&gt; следует обращаться с особой осторожностью в фильтре. В массиве &lt;code&gt;@components&lt;/code&gt; хранятся &amp;laquo;обратные переводы&amp;raquo; каждого заполнителя, вставленного в &lt;code&gt;$_&lt;/code&gt; , а также промежуточный исходный код между заполнителями. Если &lt;code&gt;@components&lt;/code&gt; заполнителей изменяются в @components , они будут аналогичным образом изменены, когда заполнители будут удалены из &lt;code&gt;$_&lt;/code&gt; после завершения фильтра.</target>
        </trans-unit>
        <trans-unit id="4bda05c922f6c0e7108b9b6664cf70b280c74345" translate="yes" xml:space="preserve">
          <source>Once the first line has been processed, the flow will look like this:</source>
          <target state="translated">После обработки первой строки поток будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="2abcd9048b9f7de01dd766ea3b827a4a4ca6e4d7" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">После того, как общий сокет сервера был создан с использованием параметров, перечисленных выше, сервер ожидает подключения к нему нового клиента. Сервер блокирует метод &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; , который в конечном итоге принимает двунаправленное соединение от удаленного клиента. (Не забудьте автозаполнить этот дескриптор, чтобы обойти буферизацию.)</target>
        </trans-unit>
        <trans-unit id="3ee769afc72db89229ffb2a909f356b2b29d26cc" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the exit status. If the parser ran an executable, it returns the exit status of the executable.</source>
          <target state="translated">Как только синтаксический анализатор закончит работу,он вернет статус выхода.Если парсер запустил исполняемый файл,он вернет статус выхода исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="4d1cfe61310d7995317dabd0218a153aefb9089c" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.</source>
          <target state="translated">Как только парсер будет закончен,он вернет номер версии для обработанного TAP.Номер версии был введен с TAP версии 13,поэтому если номер версии не найден,предполагается,что это версия 12.</target>
        </trans-unit>
        <trans-unit id="295310f03609b1e9bcb5a3f97bee3cf209b7fdc9" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; status.</source>
          <target state="translated">Как только парсер завершит работу, он вернет статус ожидания. Если парсер запустил исполняемый файл, он возвращает состояние ожидания исполняемого файла. В противном случае это просто возвращает статус &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e563448cf76902cc1f89b5320bc98d51a6a5d5a8" translate="yes" xml:space="preserve">
          <source>Once the prefix an dthe outermost opening delimiter bracket have been recognized, code blocks are extracted by stepping through the input text and trying the following alternatives in sequence:</source>
          <target state="translated">После того,как префикс d крайней открывающей разделительной скобки распознан,блоки кода извлекаются путем пошагового прохождения по входному тексту и последовательного пробования следующих альтернатив:</target>
        </trans-unit>
        <trans-unit id="c16b3faffb99d8d54125fd9ac6e0e713e87e3953" translate="yes" xml:space="preserve">
          <source>Once the program is otherwise done, and once its localization for the first language works right (via the data and methods in Projname::L10N::en_us), you can get together the data for translation. If your first language lexicon isn't an _AUTO lexicon, then you already have all the messages explicitly in the lexicon (or else you'd be getting exceptions thrown when you call $lh-&amp;gt;maketext to get messages that aren't in there). But if you were (advisedly) lazy and are using an _AUTO lexicon, then you've got to make a list of all the phrases that you've so far been letting _AUTO generate for you. There are very many ways to assemble such a list. The most straightforward is to simply grep the source for every occurrence of &quot;maketext&quot; (or calls to wrappers around it, like the above &lt;code&gt;pmt&lt;/code&gt; function), and to log the following phrase.</source>
          <target state="translated">Как только программа будет завершена и как только ее локализация для первого языка работает правильно (с помощью данных и методов в Projname :: L10N :: en_us), вы можете собрать данные для перевода. Если ваш первый языковой лексикон не является лексиконом _AUTO, значит, у вас уже есть все сообщения явно в лексиконе (иначе вы получите исключения, когда вы вызываете $ lh-&amp;gt; maketext для получения сообщений, которых там нет ). Но если вы были (умышленно) ленивы и используете лексикон _AUTO, то вам нужно составить список всех фраз, которые вы до сих пор позволяли _AUTO генерировать для вас. Есть очень много способов составить такой список. Самый простой - просто найти источник для каждого вхождения &amp;laquo;maketext&amp;raquo; (или обращения к оболочкам вокруг него, как в &lt;code&gt;pmt&lt;/code&gt; выше pmt функция) и записать следующую фразу.</target>
        </trans-unit>
        <trans-unit id="2748f5e91bdbaf9d65e1b144f8ee5e1cdc0ecbe6" translate="yes" xml:space="preserve">
          <source>Once the reference is stored in a variable like $aref or $href, you can copy it or store it just the same as any other scalar value:</source>
          <target state="translated">Как только ссылка хранится в переменной типа $aref или $href,вы можете скопировать ее или сохранить так же,как и любое другое скалярное значение:</target>
        </trans-unit>
        <trans-unit id="15fa63ef5d4644b5d99dc644eff10efe12c6233c" translate="yes" xml:space="preserve">
          <source>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now &lt;code&gt;SIZE_ONLY&lt;/code&gt; will be false, and the actual construction can occur.</source>
          <target state="translated">После определения размера программы шаблон снова анализируется, но на этот раз по-настоящему. Теперь &lt;code&gt;SIZE_ONLY&lt;/code&gt; будет ложным, и может произойти фактическое построение.</target>
        </trans-unit>
        <trans-unit id="1ce09f4f2086e283549a294da4a8bb0ec70720b9" translate="yes" xml:space="preserve">
          <source>Once this is done, do the following to build any extension:</source>
          <target state="translated">Как только это будет сделано,сделайте следующее,чтобы построить любое расширение:</target>
        </trans-unit>
        <trans-unit id="c86d1961dcc0430277520b8cb5786b3c716d4a7c" translate="yes" xml:space="preserve">
          <source>Once this process completes for a given function, it is defined, so future calls to the subroutine will bypass the AUTOLOAD mechanism.</source>
          <target state="translated">Как только этот процесс завершается для данной функции,он определяется,поэтому будущие вызовы подпрограммы будут осуществляться в обход механизма AUTOLOAD.</target>
        </trans-unit>
        <trans-unit id="9bc6c924aca0f68365c3f48d14dbdebf3eb3856a" translate="yes" xml:space="preserve">
          <source>Once uploaded, it'll sit unnoticed in your author directory. If you want it connected to the rest of the CPAN, you'll need to go to &quot;Register Namespace&quot; on PAUSE. Once registered, your module will appear in the by-module and by-category listings on CPAN.</source>
          <target state="translated">После загрузки он будет незамеченным в вашем авторском каталоге.Если вы хотите,чтобы он был подключен к остальной части CPAN,вам нужно перейти в &quot;Регистрационное пространство имен&quot; на PAUSE.После регистрации ваш модуль появится в списке байт-модулей и байт-категорий CPAN.</target>
        </trans-unit>
        <trans-unit id="852b82c0a8fc155a5b67d823ae98f4fd4d342839" translate="yes" xml:space="preserve">
          <source>Once upon a time, C code compilable under both BSD and SysV. In general, code that can be easily converted to run on another &lt;b&gt;platform&lt;/b&gt;, where &amp;ldquo;easily&amp;rdquo; can be defined however you like, and usually is. Anything may be considered portable if you try hard enough, such as a mobile home or London Bridge.</source>
          <target state="translated">Когда-то давно код C компилировался как под BSD, так и под SysV. В общем, код, который можно легко преобразовать для работы на другой &lt;b&gt;платформе&lt;/b&gt; , где &amp;laquo;легко&amp;raquo; можно определить, как вам нравится, и обычно это так. Все, что угодно, можно считать портативным, если вы достаточно постараетесь, например, мобильный дом или Лондонский мост.</target>
        </trans-unit>
        <trans-unit id="028479890974f67d52e50ca30dc71571debad796" translate="yes" xml:space="preserve">
          <source>Once upon a time, I wrote a program called pstruct. It was a perl program that tried to parse out C structures and display their member offsets for you. This was especially useful for people looking at binary dumps or poking around the kernel.</source>
          <target state="translated">Давным-давно я написал программу под названием Pstruct.Это была программа на perl,которая пыталась разобрать структуры на C и отобразить их членские смещения для вас.Это было особенно полезно для людей,смотрящих на двоичные свалки или копающихся в ядре.</target>
        </trans-unit>
        <trans-unit id="5311fe73402702af14e5a56e844da83a8b07a8a6" translate="yes" xml:space="preserve">
          <source>Once upon a time, MakeMaker could produce an approximation of a correct Makefile on MacOS Classic (MacPerl). Due to a lack of maintainers, this fell out of sync with the rest of MakeMaker and hadn't worked in years. Since there's little chance of it being repaired, MacOS Classic is fading away, and the code was icky to begin with, the code has been deleted to make maintenance easier.</source>
          <target state="translated">Давным-давно,MakeMaker мог создать аппроксимацию правильного Makefile на MacOS Classic (MacPerl).Из-за отсутствия сопровождающих это не синхронизировалось с остальными версиями MakeMaker и не работало годами.Так как шансов на его ремонт мало,MacOS Classic затухает,а код для начала был ледяным,код был удален,чтобы облегчить обслуживание.</target>
        </trans-unit>
        <trans-unit id="f360544bd22369fcd1b6d32877524b0035f30449" translate="yes" xml:space="preserve">
          <source>Once upon a time, there was a library called</source>
          <target state="translated">Давным-давно существовала библиотека,которая называлась</target>
        </trans-unit>
        <trans-unit id="c419b35f29ce772e59b3d6f120a7bf0188bed72b" translate="yes" xml:space="preserve">
          <source>Once we've blessed the hash referred to by &lt;code&gt;$self&lt;/code&gt; we can start calling methods on it. This is useful if you want to put object initialization in its own separate method:</source>
          <target state="translated">После того, как мы благословили хэш, на который ссылается &lt;code&gt;$self&lt;/code&gt; мы можем начать вызывать для него методы. Это полезно, если вы хотите поместить инициализацию объекта в отдельный отдельный метод:</target>
        </trans-unit>
        <trans-unit id="6b240bbed00f45e13a77c757892ecbf1631c45c9" translate="yes" xml:space="preserve">
          <source>Once you can identify individual blocks, try allowing them to be nested. That isn't difficult either.</source>
          <target state="translated">Как только вы сможете определить отдельные блоки,попробуйте позволить им быть вложенными.Это тоже не сложно.</target>
        </trans-unit>
        <trans-unit id="383155a2b30e1482a3f900136a965760218a5249" translate="yes" xml:space="preserve">
          <source>Once you have a reference, you can use the following macro to dereference the reference:</source>
          <target state="translated">После получения ссылки можно использовать следующий макрос для снятия ссылки:</target>
        </trans-unit>
        <trans-unit id="77ad49af6893225c730f233c983aba4b11bcf0d8" translate="yes" xml:space="preserve">
          <source>Once you have done that, you can access the Berkeley DB API functions as &lt;b&gt;DB_File&lt;/b&gt; methods directly like this:</source>
          <target state="translated">Как только вы это сделаете, вы сможете напрямую обращаться к функциям Berkeley DB API как &lt;b&gt;к&lt;/b&gt; методам &lt;b&gt;DB_File&lt;/b&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="9d9573b46c2994b393d22341f4e2899c15619352" translate="yes" xml:space="preserve">
          <source>Once you have it on, simply bring up a PASE shell and extract the tarball.</source>
          <target state="translated">Как только вы его наденете,просто поднимите оболочку PASE и извлеките тарбол.</target>
        </trans-unit>
        <trans-unit id="2403323a2c0ab8ef6892066d26c525181d3596a2" translate="yes" xml:space="preserve">
          <source>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</source>
          <target state="translated">После того,как у вас есть список ключей,вы можете обработать этот список,прежде чем обрабатывать хэш-элементы.Например,вы можете отсортировать ключи,чтобы обработать их в лексическом порядке:</target>
        </trans-unit>
        <trans-unit id="fa2bd757e5448bc96817cbaf4661aeb1b493b281" translate="yes" xml:space="preserve">
          <source>Once you have this code, slap it into the second argument of</source>
          <target state="translated">Как только вы получите этот код,вставьте его во второй аргумент из</target>
        </trans-unit>
        <trans-unit id="ae0a83fd366650f3f9c13c1a72ec5ce82cd02510" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; instead of the variable-sized &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; for your input.</source>
          <target state="translated">После того, как ваш двоичный файл правильно открыт в нужном режиме, вы можете использовать все те же функции ввода-вывода Perl, которые вы использовали для текстовых файлов. Однако вы можете захотеть использовать &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; фиксированного размера вместо &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; чтения переменного размера для ввода.</target>
        </trans-unit>
        <trans-unit id="4a97180f59d4ebc49010b5f130f6497cfeb42c05" translate="yes" xml:space="preserve">
          <source>Once you have your hook functions, you need a &lt;code&gt;BHK&lt;/code&gt; structure to put them in. It's best to allocate it statically, since there is no way to free it once it's registered. The function pointers should be inserted into this structure using the &lt;code&gt;BhkENTRY_set&lt;/code&gt; macro, which will also set flags indicating which entries are valid. If you do need to allocate your &lt;code&gt;BHK&lt;/code&gt; dynamically for some reason, be sure to zero it before you start.</source>
          <target state="translated">Когда у вас есть функции-перехватчики, вам понадобится структура &lt;code&gt;BHK&lt;/code&gt; для их размещения. Лучше всего выделять ее статически, так как нет возможности освободить ее после регистрации. Указатели функций должны быть вставлены в эту структуру с &lt;code&gt;BhkENTRY_set&lt;/code&gt; макроса BhkENTRY_set , который также установит флаги, указывающие, какие записи допустимы. Если по какой-то причине вам действительно нужно динамически распределять &lt;code&gt;BHK&lt;/code&gt; , не забудьте обнулить его перед началом.</target>
        </trans-unit>
        <trans-unit id="e41f59d96ffbb22709bea4ad583772ec9921c59e" translate="yes" xml:space="preserve">
          <source>Once you know what the type of an object is, you then know what subclass it belongs to, and therefore what methods it supports.</source>
          <target state="translated">Как только вы знаете,какой тип объекта,вы знаете,к какому подклассу он принадлежит,и,следовательно,какие методы он поддерживает.</target>
        </trans-unit>
        <trans-unit id="850880274fc323f37b6b25fc23ccf3a516cbf65a" translate="yes" xml:space="preserve">
          <source>Once you start accumulating users, they'll send you bug reports. If you're lucky, they'll even send you patches. Welcome to the joys of maintaining a software project...</source>
          <target state="translated">Как только вы начнете накапливать пользователей,они будут посылать вам сообщения об ошибках.Если повезет,они даже пришлют вам исправления.Добро пожаловать в радость поддержания программного проекта...</target>
        </trans-unit>
        <trans-unit id="ba22e7b4a3b9d48110bef39d92876fccf1215f67" translate="yes" xml:space="preserve">
          <source>Once you're doing this, you may alter Concise output by adding new rendering styles, and by optionally adding callback routines which populate new variables, if such were referenced from those (just added) styles.</source>
          <target state="translated">Сделав это,вы можете изменить лаконичный вывод,добавив новые стили рендеринга,а также опционально добавив подпрограммы обратного вызова,которые заполняют новые переменные,если на них ссылались из этих (только что добавленных)стилей.</target>
        </trans-unit>
        <trans-unit id="566e6d16d506c3974bf904eb0b48aa55735c513e" translate="yes" xml:space="preserve">
          <source>Once you're done here, check out &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; next.</source>
          <target state="translated">Как только вы закончите, ознакомьтесь с &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29ed2494b99283db9c4753c1220697c79a656d72" translate="yes" xml:space="preserve">
          <source>Once you've actually set any options you want (if any), you can go ahead and use the following methods to search for Pod files in particular ways.</source>
          <target state="translated">После того,как вы установили любые опции (если таковые имеются),вы можете использовать следующие методы для поиска файлов Pod определенными способами.</target>
        </trans-unit>
        <trans-unit id="23b007b44c67108f453a7c776499a8dd3ea3293f" translate="yes" xml:space="preserve">
          <source>Once you've done that, you can safely omit the encoding part of the open mode:</source>
          <target state="translated">Сделав это,вы можете безопасно пропустить часть кодирования в открытом режиме:</target>
        </trans-unit>
        <trans-unit id="57d330172757358785b8cc8eade4d52dfcf7f16d" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make dist&lt;/code&gt; , and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">Убедившись, что ваш модуль проходит собственные тесты - всегда полезно убедиться - вы можете &lt;code&gt;make dist&lt;/code&gt; , и Makefile, надеюсь, создаст вам хороший архив вашего модуля, готовый к загрузке.</target>
        </trans-unit>
        <trans-unit id="f63abbf1c003f24ebc901d81ec59d8ecd65e101a" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">После того, как вы установили NDK и настроили свое устройство, все, что вам осталось сделать, это настроить устройство и среду кросс-компиляции. Blackberry предоставляет сценарий &lt;code&gt;bbndk-env.sh&lt;/code&gt; (иногда называемый чем-то вроде &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ), который можно использовать для этого. Однако есть небольшая загвоздка, с которой мы должны работать: сценарий изменяет PATH так, чтобы 'gcc' или 'ar' указывали на их эквиваленты кросс-компиляции, что затрудняет процесс сборки.</target>
        </trans-unit>
        <trans-unit id="6dca0ad4315ae940ee938651b8e1193e8aa9a420" translate="yes" xml:space="preserve">
          <source>Once you've localized your program/site/etc. for all desired languages, be sure to show the result (whether live, or via screenshots) to the translators. Once they approve, make every effort to have it then checked by at least one other speaker of that language. This holds true even when (or especially when) the translation is done by one of your own programmers. Some kinds of systems may be harder to find testers for than others, depending on the amount of domain-specific jargon and concepts involved -- it's easier to find people who can tell you whether they approve of your translation for &quot;delete this message&quot; in an email-via-Web interface, than to find people who can give you an informed opinion on your translation for &quot;attribute value&quot; in an XML query tool's interface.</source>
          <target state="translated">После того,как Вы локализовали свою программу/сайт/и т.д.для всех желаемых языков,обязательно покажите результат (в прямом эфире или с помощью скриншотов)переводчикам.Как только они одобрят его,приложите все усилия,чтобы он был проверен,по крайней мере,еще одним носителем этого языка.Это справедливо даже тогда,когда (или особенно когда)перевод осуществляется одним из ваших собственных программистов.Для некоторых типов систем может быть сложнее найти тестеров,чем для других,в зависимости от количества специфических для данной области жаргонов и концепций-проще найти людей,которые могут сказать вам,одобряют ли они ваш перевод для &quot;удаления этого сообщения&quot; в интерфейсе email-via-Web,чем найти людей,которые могут дать вам обоснованное мнение о вашем переводе для &quot;значения атрибута&quot; в интерфейсе XML-инструмента запроса.</target>
        </trans-unit>
        <trans-unit id="c53ec1e93f888bd372b8348217b36ca16ed6c602" translate="yes" xml:space="preserve">
          <source>Once you've understood those, embedding Perl in C is easy.</source>
          <target state="translated">Как только вы их поймете,внедрить Perl в C легко.</target>
        </trans-unit>
        <trans-unit id="8154145e302b1a07e64a971e9a8a8af681b5891f" translate="yes" xml:space="preserve">
          <source>Once you've unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">После распаковки дистрибутива запустите &quot;sh Configure&quot; (см.УСТАНОВКУ для полного обсуждения опций конфигурации).Есть файл &quot;подсказок&quot; для os390,который определяет правильные значения для большинства вещей.Некоторые вещи,на которые следует обратить внимание,включают в себя:</target>
        </trans-unit>
        <trans-unit id="db5c3d0411160491df177efaf9a707107fc6ab38" translate="yes" xml:space="preserve">
          <source>Once your extension is complete and passes all its tests, installing it is quite simple: you simply run &quot;make install&quot;. You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you.</source>
          <target state="translated">После того,как ваше расширение будет завершено и пройдет все тесты,его установка довольно проста:вы просто запускаете &quot;make install&quot;.Вам нужно будет либо иметь права на запись в каталоги,где установлен Perl,либо попросить вашего системного администратора запустить make за вас.</target>
        </trans-unit>
        <trans-unit id="4f49dbc375a0394fd3dd511b9f8226cfef74fa93" translate="yes" xml:space="preserve">
          <source>One additional translation is performed: instead of</source>
          <target state="translated">Выполняется один дополнительный перевод:вместо</target>
        </trans-unit>
        <trans-unit id="a68ac543ed261e894527754904db5e74312dfaac" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure perl code outside the lexical scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC &lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">Одна из областей, где произошел конфликт, касается локалей C. (См. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; .) Perl, за одним исключением, и если не указано иное, устанавливает базовый языковой стандарт, в котором выполняется программа, на языковой стандарт, переданный ему из среды. Это важное отличие от общей программы на языке C, где основной локалью является локаль &quot;C&quot;, если программа не изменяет ее. Начиная с версии 5.20, этот базовый языковой стандарт полностью скрыт от чистого кода Perl за пределами лексической области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; за исключением нескольких вызовов функций в модуле POSIX, которые по необходимости его используют. Но базовый языковой стандарт с одним исключением предоставляется коду XS, влияя на все подпрограммы библиотеки C, поведение которых зависит от языкового стандарта. Ваш XS-код лучше не предполагает, что базовая локаль - &quot;C&quot;. Исключением является категория языкового стандарта &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC&lt;/a&gt; , и причина, по которой это исключение, заключается в том, что опыт показал, что это может быть проблематичным для кода XS, тогда как у нас не было сообщений о проблемах с &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;другими категориями языковых стандартов.&lt;/a&gt;. И причина того, что эта категория является проблематичной, заключается в том, что символ, используемый в качестве десятичной точки, может варьироваться. Во многих европейских языках используется запятая, тогда как в английском и, следовательно, Perl ожидает точку (U + 002E: FULL STOP). Многие модули могут обрабатывать только символ системы счисления, являющийся точкой, и perl пытается это сделать. Вплоть до Perl v5.20 попытка заключалась в том, чтобы просто установить &lt;code&gt;LC_NUMERIC&lt;/code&gt; при запуске на локаль &lt;code&gt;&quot;C&quot;&lt;/code&gt; . В противном случае любой &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale ()&lt;/a&gt; изменил бы его; это вызвало некоторые сбои. Поэтому, начиная с v5.22, perl старается, чтобы &lt;code&gt;LC_NUMERIC&lt;/code&gt; всегда был установлен на &lt;code&gt;&quot;C&quot;&lt;/code&gt; для кода XS.</target>
        </trans-unit>
        <trans-unit id="6b3b34651f404f7056a8a03b94a1667665687e73" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt; ). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">Одно большое различие между наборами символов на основе ASCII и EBCDIC - это относительное положение символов при сортировке в собственном порядке. Наибольшее беспокойство вызывают прописные и строчные буквы, цифры и символ подчеркивания ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ). На платформах ASCII в собственном порядке сортировки цифры идут перед прописными буквами, которые идут перед подчеркиванием, которое стоит перед строчными буквами. В EBCDIC сначала идет подчеркивание, затем строчные буквы, затем прописные буквы и последними цифры. При сортировке на платформе, основанной на ASCII, двухбуквенное сокращение для врача идет перед двухбуквенным сокращением для диска; то есть:</target>
        </trans-unit>
        <trans-unit id="a63660a2be4a88226e8e69f57c474e97932c916a" translate="yes" xml:space="preserve">
          <source>One can also use &quot;short&quot; names:</source>
          <target state="translated">Можно также использовать &quot;короткие&quot; имена:</target>
        </trans-unit>
        <trans-unit id="577442f1eff045466125f84e1aef5d482722c146" translate="yes" xml:space="preserve">
          <source>One can always start</source>
          <target state="translated">Всегда можно начать</target>
        </trans-unit>
        <trans-unit id="29c09e61bbeafec8533e6d27dfc8a923e0fca57d" translate="yes" xml:space="preserve">
          <source>One can build perl with thread support enabled by providing &lt;code&gt;-D usethreads&lt;/code&gt; option to</source>
          <target state="translated">Можно создать Perl с включенной поддержкой потоков, &lt;code&gt;-D usethreads&lt;/code&gt; параметр -D usethreads для</target>
        </trans-unit>
        <trans-unit id="359cf3d8d5555fb74ca7adc2fbcedf983680dde4" translate="yes" xml:space="preserve">
          <source>One can change the output file handle of the messages by setting $Getopt::Std::OUTPUT_HELP_VERSION. One can print the messages of &lt;code&gt;--help&lt;/code&gt; (without the &lt;code&gt;Usage:&lt;/code&gt; line) and &lt;code&gt;--version&lt;/code&gt; by calling functions help_mess() and version_mess() with the switches string as an argument.</source>
          <target state="translated">Можно изменить дескриптор выходного файла сообщений, установив $ Getopt :: Std :: OUTPUT_HELP_VERSION. Сообщения &lt;code&gt;--help&lt;/code&gt; (без строки &lt;code&gt;Usage:&lt;/code&gt; :) и &lt;code&gt;--version&lt;/code&gt; можно распечатать , вызвав функции help_mess () и version_mess () со строкой переключателей в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="d414d38c04c2c09cb11f7d028ae1e652935790fa" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt; .</source>
          <target state="translated">Можно проверить, поддерживает ли загруженный в данный момент пакет ReadLine эти методы, проверив соответствующие &lt;code&gt;Features&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c198d2cf41321cd565d4f52242fa64736d1a9f4a" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">Обе эти проблемы можно обойти двумя способами. Либо передавайте и сохраняйте числа всегда в текстовом формате, а не в исходном двоичном формате, либо рассмотрите возможность использования таких модулей, как &lt;code&gt;Data::Dumper&lt;/code&gt; и &lt;code&gt;Storable&lt;/code&gt; (включенных в Perl 5.8). Хранение всех данных в виде текста значительно упрощает дело.</target>
        </trans-unit>
        <trans-unit id="09119ba09b711474d1016a03da12b7c5aabeff6a" translate="yes" xml:space="preserve">
          <source>One can get RSX from, say</source>
          <target state="translated">Можно получить RSX,скажем.</target>
        </trans-unit>
        <trans-unit id="fc1d1f2f775a433521e449135abda7dc4b545354" translate="yes" xml:space="preserve">
          <source>One can get different parts of EMX from, say</source>
          <target state="translated">Можно получить разные части EMX от,скажем.</target>
        </trans-unit>
        <trans-unit id="b1f6c95529bb8b413cce8749a9949bb156c89f7b" translate="yes" xml:space="preserve">
          <source>One can have Unicode in identifier names, but not in package/class or subroutine names. While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.</source>
          <target state="translated">Можно использовать Unicode в именах идентификаторов,но не в именах пакетов/классов или подпрограмм.Хотя некоторая ограниченная функциональность в этом отношении существует на Perl 5.8.0,это более случайно,чем разработано;использование Юникода для этих целей не поддерживается.</target>
        </trans-unit>
        <trans-unit id="419250bbe62537b6d8975e14166ba62003b501d4" translate="yes" xml:space="preserve">
          <source>One can read this document in the following formats:</source>
          <target state="translated">Этот документ можно прочитать в следующих форматах:</target>
        </trans-unit>
        <trans-unit id="6893de36816aebf716cd1fd72a1de7d9c51768bf" translate="yes" xml:space="preserve">
          <source>One can replace a numeric repeat count with a template letter enclosed in brackets to use the packed byte length of the bracketed template for the repeat count.</source>
          <target state="translated">Можно заменить числовой счетчик повторов на шаблонную букву,заключенную в скобки,чтобы использовать длину упакованного байта шаблона в скобках для счетчика повторов.</target>
        </trans-unit>
        <trans-unit id="05782b074320e38eef954451f657efc4b11fa74a" translate="yes" xml:space="preserve">
          <source>One case that this does not handle is a gv without SvFAKE set. After</source>
          <target state="translated">Один из случаев,с которым он не справляется,это гВ без комплекта SvFAKE.После</target>
        </trans-unit>
        <trans-unit id="702f5c0458dfb1f9b9fa361a8264610e99c16724" translate="yes" xml:space="preserve">
          <source>One common debugging approach here, would be to liberally sprinkle a few print statements, to add a check just before we print out our data, and another just after:</source>
          <target state="translated">Одним из распространенных подходов к отладке здесь было бы либеральное разбрызгивание нескольких печатных утверждений,добавление проверки непосредственно перед распечаткой наших данных,и еще одно сразу после:</target>
        </trans-unit>
        <trans-unit id="38e71844bc36e8f5a99e4a47f54b762cb30af6e8" translate="yes" xml:space="preserve">
          <source>One common mistake when using this port with a GUI library like &lt;code&gt;Tk&lt;/code&gt; is assuming that Perl's normal behavior of opening a command-line window will go away. This isn't the case. If you want to start a copy of &lt;code&gt;perl&lt;/code&gt; without opening a command-line window, use the &lt;code&gt;wperl&lt;/code&gt; executable built during the installation process. Usage is exactly the same as normal &lt;code&gt;perl&lt;/code&gt; on Windows, except that options like &lt;code&gt;-h&lt;/code&gt; don't work (since they need a command-line window to print to).</source>
          <target state="translated">Одна из распространенных ошибок при использовании этого порта с библиотекой GUI, такой как &lt;code&gt;Tk&lt;/code&gt; , заключается в предположении, что нормальное поведение Perl при открытии окна командной строки исчезнет. Это не так. Если вы хотите запустить копию &lt;code&gt;perl&lt;/code&gt; , не открывая окно командной строки, используйте исполняемый файл &lt;code&gt;wperl&lt;/code&gt; , созданный в процессе установки. Использование точно такое же, как и в обычном &lt;code&gt;perl&lt;/code&gt; в Windows, за исключением того, что такие параметры, как &lt;code&gt;-h&lt;/code&gt; , не работают (так как им нужно окно командной строки для печати).</target>
        </trans-unit>
        <trans-unit id="8a4117118bb75dbafb375915c27d62ebe634dd07" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">Эту информацию передают в &lt;b&gt;xsubpp&lt;/b&gt; , заменяя &lt;code&gt;*&lt;/code&gt; перед аргументом на &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; означает, что аргумент должен быть передан библиотечной функции по ее адресу. Две указанные выше функции могут быть XSUB-образными как</target>
        </trans-unit>
        <trans-unit id="d10907c81f2d55151091ac660924f2a1e254db78" translate="yes" xml:space="preserve">
          <source>One could use this to create subclasses of &lt;b&gt;Pod::Paragraphs&lt;/b&gt; and &lt;b&gt;Pod::InteriorSequences&lt;/b&gt; for specific commands (or to create your own custom node-types in the parse-tree) and add some kind of &lt;b&gt;emit()&lt;/b&gt; method to each custom node/subclass object in the tree. Then all you'd need to do is recursively walk the tree in the desired order, processing the children (most likely from left to right) by formatting them if they are text-strings, or by calling their &lt;b&gt;emit()&lt;/b&gt; method if they are objects/references.</source>
          <target state="translated">Это можно использовать для создания подклассов &lt;b&gt;Pod :: Paragraphs&lt;/b&gt; и &lt;b&gt;Pod :: InteriorSequences&lt;/b&gt; для определенных команд (или для создания ваших собственных типов узлов в дереве синтаксического анализа) и добавления какого-либо метода &lt;b&gt;emit ()&lt;/b&gt; к каждому настраиваемому узлу / объект подкласса в дереве. Затем все, что вам нужно сделать, это рекурсивно пройти по дереву в желаемом порядке, обрабатывая дочерние элементы (скорее всего, слева направо), форматируя их, если они являются текстовыми строками, или вызывая их метод &lt;b&gt;emit (),&lt;/b&gt; если они объекты / ссылки.</target>
        </trans-unit>
        <trans-unit id="d5d134d4ce2691a8fd3e620efdc0c0a7dc96f2ab" translate="yes" xml:space="preserve">
          <source>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</source>
          <target state="translated">Один контрагент в столбце с пометкой &quot;ASCII-диапазон Юникод&quot; в таблице совпадает только с символами из набора ASCII-символов.</target>
        </trans-unit>
        <trans-unit id="e759a7518c2a7615eb212a5b5c617930b5079aa4" translate="yes" xml:space="preserve">
          <source>One especially common bit of Perl code is opening a pipe to &lt;b&gt;sendmail&lt;/b&gt;:</source>
          <target state="translated">Один из наиболее распространенных фрагментов кода Perl - это открытие канала для &lt;b&gt;sendmail&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="6006eb32ad88f65a8e3a677b12b70bf0c21cd44a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">Один пример модуля, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO :: via :: QuotedPrint&lt;/a&gt; , включен в Perl 5.8.0, и другие примеры модулей доступны из CPAN, такие как &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64&lt;/a&gt; . Например, модуль PerlIO :: via :: StripHTML позволяет вам сказать:</target>
        </trans-unit>
        <trans-unit id="5ffc602a59cde7db4cddb26183a3140b07c9e1e7" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">Единственным исключением является скалярная переменная по умолчанию: начиная с perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; всегда удаляет всю магию из $ _, чтобы можно было безопасно повторно использовать $ _ в подпрограмме.</target>
        </trans-unit>
        <trans-unit id="08b4b3fb221020ddd9f00f023bbae8ca4cbaad9d" translate="yes" xml:space="preserve">
          <source>One facility, one priority.</source>
          <target state="translated">Один объект,один приоритет.</target>
        </trans-unit>
        <trans-unit id="8aecc974b0a5e7d4fdcb37dff6e7916eb87115e6" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt; , where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">Одна форма, доступная начиная с Perl 5.14, выглядит как &lt;code&gt;\o{...}&lt;/code&gt; , где точки представляют одну или несколько восьмеричных цифр. Его можно использовать для любого символа Юникода.</target>
        </trans-unit>
        <trans-unit id="322c61ed78983eea548dac2ca0c0f3a32df9d886" translate="yes" xml:space="preserve">
          <source>One generally uses it like so:</source>
          <target state="translated">Обычно так используют:</target>
        </trans-unit>
        <trans-unit id="5328aa4f92833315a7e49e7973d7b5d5df515277" translate="yes" xml:space="preserve">
          <source>One good reason is when you already have an existing application written in another language that's all done (and done well), or you have an application language specifically designed for a certain task (e.g. prolog, make).</source>
          <target state="translated">Одна из веских причин заключается в том,что у вас уже есть существующее приложение,написанное на другом языке,которое все сделано (и сделано хорошо),или у вас есть язык приложения,специально разработанный для определенной задачи (например,пролог,make).</target>
        </trans-unit>
        <trans-unit id="5181341efe5d191b40c7bb4f79e039f1b83f3ecd" translate="yes" xml:space="preserve">
          <source>One last thing before we show you how to open files: opening files does not (usually) automatically lock them in Perl. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for how to lock.</source>
          <target state="translated">И последнее, прежде чем мы покажем вам, как открывать файлы: открытие файлов (обычно) не блокирует их автоматически в Perl. См. &lt;a href=&quot;perlfaq5&quot;&gt;Perlfaq5,&lt;/a&gt; чтобы узнать, как заблокировать.</target>
        </trans-unit>
        <trans-unit id="b7d0dbf83cb5d86dbb1f5f3433c118dbdc75390f" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . These days, it's considered cleaner to call the internal function directly as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">Сначала выполняется один уровень интерпретации двойных кавычек, но вы не можете сказать &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; потому что это косвенный дескриптор файла, как описано в предыдущем абзаце. (В более старых версиях Perl программисты вставляли фигурные скобки для принудительной интерпретации как имени файла glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . В наши дни считается более чистым вызывать внутреннюю функцию напрямую как &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt; , что, вероятно, является правильный способ сделать это в первую очередь.) Например:</target>
        </trans-unit>
        <trans-unit id="cb3729bf6ea691a9592670464973a67c30ec7dce" translate="yes" xml:space="preserve">
          <source>One line description of the module. Will be included in PPD file.</source>
          <target state="translated">Описание модуля в одной строке.Будет включено в файл PPD.</target>
        </trans-unit>
        <trans-unit id="812bfff50b3cdd6b1a9ee7ea09cf72b33f18f12d" translate="yes" xml:space="preserve">
          <source>One log at a time.</source>
          <target state="translated">По одному бревну за раз.</target>
        </trans-unit>
        <trans-unit id="283b267b63bd1be649ecf96f103c3d06603de13e" translate="yes" xml:space="preserve">
          <source>One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has a C structure that packages all the interpreter state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined, and enables the support for passing in a &quot;hidden&quot; first argument that represents all three data structures. MULTIPLICITY makes multi-threaded perls possible (with the ithreads threading model, related to the macro USE_ITHREADS.)</source>
          <target state="translated">Один макрос управляет основным ароматом Perl:MULTIPLICITY.MULTIPLICITY build имеет структуру на C,которая упаковывает все состояния интерпретатора.При использовании perls с поддержкой множественности,PERL_IMPLICIT_CONTEXT также обычно определяется и включает поддержку передачи в &quot;скрытом&quot; первом аргументе,который представляет все три структуры данных.MULTIPLICITY делает возможным многопотоковый perls (с моделью ithreads threading,относящейся к макросу USE_ITHREADS).</target>
        </trans-unit>
        <trans-unit id="d690e728f490966c2e852c98cb2c60fa0b1d2fcd" translate="yes" xml:space="preserve">
          <source>One may also use pod directives to quickly comment out a section of code.</source>
          <target state="translated">Также можно использовать директивы pod для быстрого комментирования участка кода.</target>
        </trans-unit>
        <trans-unit id="9dbb00f26b5f18e0abff366f4de58cbb31829dd9" translate="yes" xml:space="preserve">
          <source>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is</source>
          <target state="translated">Можно задаться вопросом,почему мы называем вышеприведенный калькулятор символическим.Причина в том,что фактическое вычисление значения выражения откладывается до тех пор,пока значение не будет равно</target>
        </trans-unit>
        <trans-unit id="bf00ffa0a786e25adb9ef6ba76b09b1f7cf9677e" translate="yes" xml:space="preserve">
          <source>One might initially guess that Perl would find the &lt;code&gt;at&lt;/code&gt; in &lt;code&gt;cat&lt;/code&gt; and stop there, but that wouldn't give the longest possible string to the first quantifier &lt;code&gt;.*&lt;/code&gt;. Instead, the first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regexp match. In this example, that means having the &lt;code&gt;at&lt;/code&gt; sequence with the final &lt;code&gt;at&lt;/code&gt; in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the</source>
          <target state="translated">Изначально можно было бы предположить, что Perl найдет &lt;code&gt;at&lt;/code&gt; в &lt;code&gt;cat&lt;/code&gt; и остановится на нем, но это не даст самую длинную строку для первого квантификатора &lt;code&gt;.*&lt;/code&gt; . Вместо этого первый квантификатор &lt;code&gt;.*&lt;/code&gt; Захватывает как можно большую часть строки, сохраняя соответствие регулярному выражению. В этом примере это означает наличие последовательности &lt;code&gt;at&lt;/code&gt; с конечной &lt;code&gt;at&lt;/code&gt; в строке. Другой важный принцип, проиллюстрированный здесь, заключается в том, что, когда в регулярном выражении есть два или более элемента,</target>
        </trans-unit>
        <trans-unit id="3150bc5b7154ac86649428809493c4398ced1ef5" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt; . This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">Можно подумать, что &lt;code&gt;\s&lt;/code&gt; эквивалентен &lt;code&gt;[\h\v]&lt;/code&gt; . Это действительно так, начиная с Perl v5.18, но до этого единственная разница заключалась в том, что вертикальная табуляция ( &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) не соответствовала &lt;code&gt;\s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9432dfd3d2e52e33cd8be01a23869f988f439b1e" translate="yes" xml:space="preserve">
          <source>One more thing here. The arrow is optional</source>
          <target state="translated">И еще кое-что.Стрелка необязательна</target>
        </trans-unit>
        <trans-unit id="a5eb562f91efde24f12f2e0986c6a04d104745fa" translate="yes" xml:space="preserve">
          <source>One must be careful with scalars and strings that are passed to print that contain ASCII encodings. One common place for this to occur is in the output of the MIME type header for CGI script writing. For example, many Perl programming guides recommend something similar to:</source>
          <target state="translated">Следует быть осторожным со скалярами и строками,которые передаются на печать и содержат кодировку ASCII.Общим местом для этого является вывод заголовка MIME-типа для написания CGI-скриптов.Например,многие руководства по программированию на Perl рекомендуют что-то подобное:</target>
        </trans-unit>
        <trans-unit id="8aa98e22038b28e02e918eedca3ae733d476de73" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">Одно имя для файла. Это имя занесено в &lt;b&gt;каталог&lt;/b&gt; . Вы можете использовать его при &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; чтобы сообщить &lt;b&gt;операционной системе&lt;/b&gt; , какой именно файл вы хотите открыть, и связать файл с &lt;b&gt;дескриптором файла&lt;/b&gt; , который будет нести последующий идентификатор этого файла в вашей программе, пока вы не закроете его.</target>
        </trans-unit>
        <trans-unit id="f26a31e071285811042cc63d258cbdf20a705a7a" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt; 's most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt; . When someone tries to use &lt;code&gt;Moose&lt;/code&gt; 's introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt; -using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">Одна из самых привлекательных особенностей &lt;code&gt;Moo&lt;/code&gt; - его совместимость с &lt;code&gt;Moose&lt;/code&gt; . Когда кто-то пытается использовать API самоанализа &lt;code&gt;Moose&lt;/code&gt; в классе или роли &lt;code&gt;Moo&lt;/code&gt; , он прозрачно преобразуется в класс или роль &lt;code&gt;Moose&lt;/code&gt; . Это упрощает включение кода, использующего &lt;code&gt;Moo&lt;/code&gt; ,в базу кода &lt;code&gt;Moose&lt;/code&gt; и наоборот.</target>
        </trans-unit>
        <trans-unit id="5bf48b13931751973cecbe1ffc3a845b843b66dc" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc.</source>
          <target state="translated">URL-адрес одного из центров переноса HP - &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/.&lt;/a&gt; В настоящее время доступный порт создан с помощью GNU gcc.</target>
        </trans-unit>
        <trans-unit id="94bda56a061a9cf12b48d3cef39a83cda8c248d2" translate="yes" xml:space="preserve">
          <source>One of Perl's internal formats happens to be UTF-8. Unfortunately, Perl can't keep a secret, so everyone knows about this. That is the source of much confusion. It's better to pretend that the internal format is some unknown encoding, and that you always have to encode and decode explicitly.</source>
          <target state="translated">Один из внутренних форматов Perl-UTF-8.К сожалению,Perl не умеет хранить секреты,поэтому все об этом знают.Это источник большой путаницы.Лучше притвориться,что внутренний формат-это какая-то неизвестная кодировка,и что всегда нужно кодировать и декодировать явно.</target>
        </trans-unit>
        <trans-unit id="cc31f4f8c344159a9afe652428d4adbed5ef0111" translate="yes" xml:space="preserve">
          <source>One of the filters between the data and what you get as input or what you end up with as output.</source>
          <target state="translated">Один из фильтров между данными и тем,что вы получаете на входе или что вы получаете на выходе.</target>
        </trans-unit>
        <trans-unit id="3850b3f9f916208f5af479bdf2a17050a569dd0c" translate="yes" xml:space="preserve">
          <source>One of the hacks is to disable floating point exceptions on Perl startup (as is the default with EMX). This helps only with compile-time-linked DLLs changing the flags before main() had a chance to be called.</source>
          <target state="translated">Одним из способов взлома является отключение исключений с плавающей запятой при запуске Perl (как и в EMX по умолчанию).Это помогает только скомпилированным по времени DLL,меняющим флаги до того,как main()получила возможность быть вызванной.</target>
        </trans-unit>
        <trans-unit id="b9aab9b2588d728ddcd8fd3f3150c7ee7136503c" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt; , you know you're in for big trouble. An immeasurably superior approach is to use the &lt;code&gt;Socket&lt;/code&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Одна из основных проблем с древним, устаревшим кодом сокетов в Perl заключалась в том, что он использовал жестко запрограммированные значения для некоторых констант, что серьезно ухудшало переносимость. Если вы когда-нибудь увидите код, который явно устанавливает &lt;code&gt;$AF_INET = 2&lt;/code&gt; , значит, вас ждут большие проблемы. Неизмеримо лучший подход - использовать модуль &lt;code&gt;Socket&lt;/code&gt; , который более надежно предоставляет доступ к различным константам и функциям, которые вам понадобятся.</target>
        </trans-unit>
        <trans-unit id="6c4fa2a95a0e37301600fc24249222e084bd9620" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called 'references', and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">Одной из наиболее важных новинок в Perl 5 стала возможность управления сложными структурами данных,такими как многомерные массивы и вложенные хэши.Для их реализации в Perl 5 была введена функция под названием &quot;ссылки&quot;,а использование ссылок является ключом к управлению сложными,структурированными данными в Perl.К сожалению,есть много забавного синтаксиса для изучения,и главная страница руководства может быть трудной для понимания.Руководство достаточно полное,и иногда люди находят это проблемой,потому что может быть сложно сказать,что важно,а что нет.</target>
        </trans-unit>
        <trans-unit id="41a97cc2346bbbbc5f26243bf51ad23f4ba0e8d3" translate="yes" xml:space="preserve">
          <source>One of the problems with a filter like:</source>
          <target state="translated">Одна из проблем с таким фильтром,как</target>
        </trans-unit>
        <trans-unit id="a626f07a30077e1f9ff80b843148b2bf2dc96ddf" translate="yes" xml:space="preserve">
          <source>One of the things that makes Perl really powerful is the fact that Perl hackers tend to want to share the solutions to problems they've faced, so you and I don't have to battle with the same problem again.</source>
          <target state="translated">Одной из вещей,которая делает Perl действительно мощным,является тот факт,что хакеры Perl,как правило,хотят поделиться решениями проблем,с которыми они столкнулись,так что нам с вами не придется бороться с той же самой проблемой снова.</target>
        </trans-unit>
        <trans-unit id="aa5b2755a479a90ca14fceb1d31618523426dc94" translate="yes" xml:space="preserve">
          <source>One of the two modules that is used by perlivp was not present in the installation. This is a serious error since it adversely affects perlivp's ability to function. You may be able to correct this by performing a proper perl installation.</source>
          <target state="translated">Один из двух модулей,используемых perlivp,не присутствовал в инсталляции.Это серьезная ошибка,так как она отрицательно влияет на работу perlivp.Вы можете исправить это,выполнив правильную установку на perl.</target>
        </trans-unit>
        <trans-unit id="d738b6e570cef7894a16f160998423dd24b30a2e" translate="yes" xml:space="preserve">
          <source>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &lt;code&gt;-&lt;/code&gt; ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="translated">Один или несколько встроенных модификаторов сопоставления с образцом, которые должны быть включены (или выключены, если им предшествует &lt;code&gt;-&lt;/code&gt; ) для оставшейся части образца или оставшейся части включающей группы образцов (если есть).</target>
        </trans-unit>
        <trans-unit id="721d29636c1b919768ad8c3269b118c8775df092" translate="yes" xml:space="preserve">
          <source>One or more files turned up missing according to a run of &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; over your installation. Correct by conducting a proper installation.</source>
          <target state="translated">Один или несколько файлов оказались пропущенными в соответствии с запуском &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; во время установки. Исправьте, выполнив надлежащую установку.</target>
        </trans-unit>
        <trans-unit id="88abd7d83fea4aa59fb220bc8cdda84165c2e0f9" translate="yes" xml:space="preserve">
          <source>One or more modifiers below may optionally follow certain letters in the TEMPLATE (the second column lists letters for which the modifier is valid):</source>
          <target state="translated">Один или несколько модификаторов ниже могут по желанию следовать определенным буквам в TEMPLATE (во второй колонке перечислены буквы,для которых модификатор действителен):</target>
        </trans-unit>
        <trans-unit id="3fcfdc5f9b9b3f122957e3a54f34893e2f61290e" translate="yes" xml:space="preserve">
          <source>One or more sections or subsections giving greater detail of available methods and routines and any other relevant information.</source>
          <target state="translated">Один или несколько разделов или подразделов с более подробным описанием доступных методов и процедур,а также любая другая соответствующая информация.</target>
        </trans-unit>
        <trans-unit id="c5eeb4b94f000feadb0a97d5609bef506c388a67" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">Еще одна интересная вещь, которую позволяет флаг &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; - это цепочка замен:</target>
        </trans-unit>
        <trans-unit id="1f9412fcd9541135d5364daa53310c1798b61f41" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">Еще одна вещь, которую следует учитывать, - это то, что резюме может быть просто неопределенным, а не освобожденным, например &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . В этом случае его RefCount возможно , не достиг нуля, но мы все - таки удалить его блокнот и его &lt;code&gt;CvROOT&lt;/code&gt; и т.д. Поскольку различные дети могут до сих пор их &lt;code&gt;CvOUTSIDE&lt;/code&gt; , указывающей на этом неопределенном резюме, мы продолжаем свой &lt;code&gt;CvOUTSIDE&lt;/code&gt; до поры до времени, так что цепочка лексических значений не разорвана. Например, следующее должно вывести 123:</target>
        </trans-unit>
        <trans-unit id="54709e3c9ceaf35c18e13834b92c003e53cefa1d" translate="yes" xml:space="preserve">
          <source>One particularly pernicious problem with the 4NT command shell for Windows is that it (nearly) always treats a % character as indicating that environment variable expansion is needed. Under this shell, it is therefore important to always double any % characters which you want Perl to see (for example, for hash variables), even when they are quoted.</source>
          <target state="translated">Одной из особенно вредных проблем командной оболочки 4NT для Windows является то,что она (почти)всегда рассматривает символ % как указание на то,что необходимо расширение переменных окружения.Поэтому в этой оболочке важно всегда удваивать любые символы %,которые вы хотите видеть в Perl (например,для хэш-переменных),даже если они заключены в кавычки.</target>
        </trans-unit>
        <trans-unit id="3b85137385a802506b55867204695f7dbafde5be" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt; . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">Одна из возможностей - рассматривать любое совпадение с этими кодовыми точками как неопределенное. Но поскольку в Perl нет концепции неопределенного совпадения, он преобразует это значение в ошибку или &lt;code&gt;FALSE&lt;/code&gt; . Это почти, но не совсем то, что Perl делал начиная с v5.14 (когда использование этих кодовых точек стало в целом надежным) до v5.18. Разница в том, что Perl считал все совпадения &lt;code&gt;\p{}&lt;/code&gt; неудачными, а все совпадения &lt;code&gt;\P{}&lt;/code&gt; - успешными.</target>
        </trans-unit>
        <trans-unit id="1709a410cf93d9bdbeb6df92828279b6d704a7e5" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">Одна из возможных причин этого заключается в том, что вы ожидали, что вы импортировали константу в свое пространство имен с &lt;b&gt;использованием&lt;/b&gt; или &lt;b&gt;импортом, в&lt;/b&gt; то время как такой импорт не производился, например, может быть, что ваша операционная система не поддерживает эту конкретную константу. Надеюсь, вы использовали явный список импорта для констант, которые ожидаете увидеть; см. &lt;a href=&quot;functions/use&quot;&gt;использование&lt;/a&gt; и &lt;a href=&quot;functions/import&quot;&gt;импорт&lt;/a&gt; . Хотя явный список импорта, вероятно, обнаружил бы эту ошибку раньше, он, естественно, не исправляет того факта, что ваша операционная система все еще не поддерживает эту константу. Может быть, у вас есть опечатка в константах списка &lt;b&gt;использования&lt;/b&gt; или &lt;b&gt;импорта&lt;/b&gt; символа для &lt;b&gt;импорта&lt;/b&gt; или в имени константы в строке, где возникла эта ошибка?</target>
        </trans-unit>
        <trans-unit id="07ffb8bf7d3f585bbcc39c2a43071e1fcedc7e55" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use Encode::decode_utf8.</source>
          <target state="translated">Одной из возможных причин является то,что вы сами устанавливаете флаг UTF8 для данных,которые,как вы думали,находятся в UTF-8,но это не так (это были,например,старые 8-битные данные).Чтобы защититься от этого,вы можете использовать Encode::decode_utf8.</target>
        </trans-unit>
        <trans-unit id="2c03f254e4e39f57b8a0f0a972c88db9a731c9ed" translate="yes" xml:space="preserve">
          <source>One possibly useful value for the &quot;fail&quot; attribute is the method name &quot;failure_handler_auto&quot;. This is a method defined in the class Locale::Maketext itself. You set it with:</source>
          <target state="translated">Одним из возможных полезных значений для атрибута &quot;fail&quot; является имя метода &quot;failure_handler_auto&quot;.Это метод,определенный в самом классе Locale::Maketext.Вы его устанавливаете с помощью:</target>
        </trans-unit>
        <trans-unit id="b269ab649a9c9d812d50cb6b126828e7c900c2dc" translate="yes" xml:space="preserve">
          <source>One problem that comes up all the time is needing a hash whose values are lists. Perl has hashes, of course, but the values have to be scalars; they can't be lists.</source>
          <target state="translated">Одна из проблем,которая постоянно возникает,это необходимость в хэше,значения которого представляют собой списки.Хэши на Perl,конечно,есть,но значения должны быть скалярами;они не могут быть списками.</target>
        </trans-unit>
        <trans-unit id="da0157bdbeb61d81e4c036f5229eec00b96121c7" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusting results in some cases:</source>
          <target state="translated">Одна из проблем заключается в том,что это приводит к неожиданным,а в некоторых случаях-к запутанным результатам:</target>
        </trans-unit>
        <trans-unit id="28b64c8c7b545333b3723cd48a2c35dd515526c6" translate="yes" xml:space="preserve">
          <source>One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</source>
          <target state="translated">Одной из причин этой незавершенности является присущая ей (в настоящее время)непредсказуемость:поскольку имена пакетов,и имена подпрограмм могут потребовать сопоставления с именами файлов и каталогов,возможность Юникода в файловой системе становится импортируемой-и,к сожалению,нет переносимых ответов.</target>
        </trans-unit>
        <trans-unit id="ea120cdc114e86190ef9485fa0b67ab7b3ed56c2" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">Одна из причин, по которой Perl не пытается разрешить роль Unicode в этих ситуациях, заключается в том, что ответы сильно зависят от операционной системы и файловой системы (систем). Например, могут ли имена файлов быть в Юникоде и в какой именно кодировке - это не совсем переносимая концепция. Аналогично для &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; : насколько хорошо &amp;laquo;интерфейс командной строки&amp;raquo; (и какой из них?) Будет обрабатывать Unicode?</target>
        </trans-unit>
        <trans-unit id="f8927d95df9fc41f4dc802a7941a3910e635adce" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</source>
          <target state="translated">Один счетчик ссылок украден, поэтому вам может потребоваться выполнить &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4267ef088e1112c0c8dad77c36351342e81e6a78" translate="yes" xml:space="preserve">
          <source>One simple way to check that things are in the right place is to print out the hard-coded &lt;code&gt;@INC&lt;/code&gt; that perl looks through for libraries:</source>
          <target state="translated">Один простой способ проверить, что все находится в нужном месте, - распечатать жестко запрограммированный &lt;code&gt;@INC&lt;/code&gt; , который perl просматривает для библиотек:</target>
        </trans-unit>
        <trans-unit id="dc49c03d5b80e5ca3e1e2c3c5c594145d4d2cfdb" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">Одним из решений вашей проблемы может быть автоматическое обновление | обновление. См. &lt;a href=&quot;../bignum&quot;&gt;Прагмы bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; и &lt;a href=&quot;../bigrat&quot;&gt;bigrat,&lt;/a&gt; чтобы узнать, как это легко сделать.</target>
        </trans-unit>
        <trans-unit id="02a95fea5b4501f9e97b845e1295326b4030d00a" translate="yes" xml:space="preserve">
          <source>One such concept is that of a</source>
          <target state="translated">Одной из таких концепций является концепция</target>
        </trans-unit>
        <trans-unit id="9fa9079fbfabecb5820f55e5b80f8f3529f8caa0" translate="yes" xml:space="preserve">
          <source>One thing Perl porters should note is that</source>
          <target state="translated">Перл-портеры должны обратить внимание на то,что</target>
        </trans-unit>
        <trans-unit id="46c4b185ea7870c493b95dc5795ba2145a16a509" translate="yes" xml:space="preserve">
          <source>One thing you may not want to rely on is the EBCDIC encoding of punctuation characters since these may differ from code page to code page (and once your module or script is rumoured to work with EBCDIC, folks will want it to work with all EBCDIC character sets).</source>
          <target state="translated">Одна вещь,на которую вы,возможно,не захотите полагаться-это кодировка знаков препинания EBCDIC,так как они могут отличаться от кодовой страницы к кодовой странице (и как только по слухам ваш модуль или скрипт будет работать с EBCDIC,люди захотят,чтобы он работал со всеми наборами символов EBCDIC).</target>
        </trans-unit>
        <trans-unit id="3339e6cb559916439f958aa73fa10717ebc88663" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, the code which implements the addition operator:</source>
          <target state="translated">Единственное,что вы заметите в источнике Perl,это то,что он полон макросов.Некоторые называют повсеместное использование макросов самой трудной для понимания вещью,другие считают,что это добавляет ясности.Рассмотрим пример,код,реализующий оператор сложения:</target>
        </trans-unit>
        <trans-unit id="6281791d1604f0f2ed2c5d9e3d66b1042f62e087" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">Один из &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;приемов&lt;/a&gt; - использовать File :: ReadBackwards , который начинается в конце файла. Этот модуль предоставляет объект, который обертывает реальный дескриптор файла, чтобы вам было проще перемещаться по файлу. Как только вы окажетесь в нужном месте, вы сможете получить фактический дескриптор файла и работать с ним как обычно. В этом случае вы получаете позицию файла в конце последней строки, которую хотите сохранить, и усекаете файл до этой точки:</target>
        </trans-unit>
        <trans-unit id="2f7425b7bd02b814bd9989aec894f5edbf698c87" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt; .</source>
          <target state="translated">Одним из полезного значения &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; является &lt;code&gt;less -+C -E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e54e615dc99abeb96e3dcca5dc954ca0886ad54d" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt; . The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt; , then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">Один из способов сделать это - использовать оператор подстановки и флаг double &lt;code&gt;/e&lt;/code&gt; . Первый &lt;code&gt;/e&lt;/code&gt; оценивает &lt;code&gt;$1&lt;/code&gt; на стороне замены и превращает его в &lt;code&gt;$foo&lt;/code&gt; . Второй / e начинается с &lt;code&gt;$foo&lt;/code&gt; и заменяет его своим значением. Тогда &lt;code&gt;$foo&lt;/code&gt; превращается в 'Fred', и это, наконец, то, что осталось в строке:</target>
        </trans-unit>
        <trans-unit id="147fc583705f82dfe6c5d25a61550d429d726533" translate="yes" xml:space="preserve">
          <source>One way is to treat the return values as a list and index into it:</source>
          <target state="translated">Один из способов-рассматривать возвращаемые значения как список и индексировать в него:</target>
        </trans-unit>
        <trans-unit id="f26562604a7b87b255854e546e57c428a05a7c6b" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">Один из способов заглянуть внутрь внутренней кодировки символов Юникода - использовать &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; для получения байтов любой кодировки строки, или &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; чтобы получить байты кодировки UTF-8:</target>
        </trans-unit>
        <trans-unit id="aa5979d9afcdae3acb920da4d4cb51dd1f70406d" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">Один из способов избежать конфликтов пространства имен в этом сценарии - преобразовать имя файла в гарантированно уникальное имя пакета, а затем скомпилировать код в этот пакет с помощью &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; . В приведенном ниже примере каждый файл будет скомпилирован только один раз. Или приложение может выбрать очистку таблицы символов, связанной с файлом, после того, как он больше не нужен. Используя &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv в perlapi&lt;/a&gt; , мы вызовем подпрограмму &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; которая находится в файле &lt;code&gt;persistent.pl&lt;/code&gt; , и передадим имя файла и логический флаг очистки / кеширования в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="3bf742d4fed91595248e4e766bfc873dce09be23" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; before your method:</source>
          <target state="translated">Один из способов сделать это - ввести редкий вызов где-нибудь рядом с тем, что вы ищете. Например, вы можете добавить &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; перед своим методом:</target>
        </trans-unit>
        <trans-unit id="2f4920008fd4d756e499ea61ff8d38a964bd84a8" translate="yes" xml:space="preserve">
          <source>One way to find out how much memory is being used by Perl data structures is to install the Devel::Size module from CPAN: it gives you the minimum number of bytes required to store a particular data structure. Please be mindful of the difference between the size() and total_size().</source>
          <target state="translated">Один из способов узнать,сколько памяти используется Perl структурами данных,-установить модуль Devel::Size из CPAN:он дает минимальное количество байт,требуемое для хранения определенной структуры данных.Пожалуйста,помните о разнице между size()и total_size().</target>
        </trans-unit>
        <trans-unit id="00322fdac947c21ed0522e06d3fcf307d762cdd8" translate="yes" xml:space="preserve">
          <source>One way to get around this macro hell is to use the dumping functions in</source>
          <target state="translated">Один из способов обойти этот макрос-ад-использовать функции дампинга в</target>
        </trans-unit>
        <trans-unit id="eeda9b7821d8b2cc38107791f4013f43a6f0fb4b" translate="yes" xml:space="preserve">
          <source>One way you can contribute is to send test results for each module that you install. If you install the CPAN::Reporter module, you have the option to automatically generate and deliver test reports to CPAN Testers whenever you run tests on a CPAN package.</source>
          <target state="translated">Одним из способов внести свой вклад является отправка результатов тестирования для каждого модуля,который вы устанавливаете.Если вы установите модуль CPAN::Reporter,у вас будет возможность автоматически генерировать и доставлять отчеты о тестировании CPAN Testers всякий раз,когда вы запускаете тесты на CPAN пакете.</target>
        </trans-unit>
        <trans-unit id="31e7d725bdb8f49cf001861a4a5f8e1249780511" translate="yes" xml:space="preserve">
          <source>One work around is to apply encodings to STDOUT and STDERR as early as possible and before Test::More (or any other Test module) loads.</source>
          <target state="translated">Одной из задач является применение кодировок к STDOUT и STDERR как можно раньше и до загрузки Test::More (или любого другого тестового модуля).</target>
        </trans-unit>
        <trans-unit id="32a8b32d9a6fd88cc288ea2d28ee5e2eb22aa577" translate="yes" xml:space="preserve">
          <source>One would use either of these:</source>
          <target state="translated">Можно использовать любую из них:</target>
        </trans-unit>
        <trans-unit id="d2c29e5eed5921eb0c039672d0a71cd9e82eb212" translate="yes" xml:space="preserve">
          <source>One-Liner Command tips</source>
          <target state="translated">Советы однолинейной команды</target>
        </trans-unit>
        <trans-unit id="c123784569a1603a8fb4810445cb2d1918c306b4" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">Система с одним аргументом () (см. &lt;a href=&quot;functions/system&quot;&gt;System&lt;/a&gt; ), exec () (см. &lt;a href=&quot;functions/exec&quot;&gt;Exec&lt;/a&gt; ) с перенаправлением или метасимволами оболочки;</target>
        </trans-unit>
        <trans-unit id="486e0bed310a26c3d92d0d575fbba324cf28a58e" translate="yes" xml:space="preserve">
          <source>One-line BLOCK may be put on one line, including curlies.</source>
          <target state="translated">БЛОКИРОВКА на одну линию может быть поставлена на одну линию,включая кудряшки.</target>
        </trans-unit>
        <trans-unit id="58784e03024491cc3bfab913b657f51ddfe4ea02" translate="yes" xml:space="preserve">
          <source>One-way visibility means these firewalls try to make themselves invisible to users inside the firewall. An FTP data connection is normally created by sending your IP address to the remote server and then listening for the return connection. But the remote server will not be able to connect to you because of the firewall. For these types of firewall, FTP connections need to be done in a passive mode.</source>
          <target state="translated">Односторонняя видимость означает,что эти брандмауэры пытаются сделать себя невидимыми для пользователей внутри брандмауэра.FTP-соединение для передачи данных обычно создается путем отправки вашего IP-адреса на удаленный сервер,а затем прослушиванием обратного соединения.Но удаленный сервер не сможет соединиться с Вами из-за брандмауэра.Для таких брандмауэров FTP-соединения должны создаваться в пассивном режиме.</target>
        </trans-unit>
        <trans-unit id="c61018f75253ce1e2ca9788d8ce3f56d39e963aa" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;#define&lt;/code&gt; symbols get translated; you must still correctly pack up your own arguments to pass as args for locking functions, etc.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; только символы #define ; вы все равно должны правильно упаковать свои собственные аргументы для передачи в качестве аргументов для функций блокировки и т. д.</target>
        </trans-unit>
        <trans-unit id="54e17eb2662bd037dd06b791727211df88880e9a" translate="yes" xml:space="preserve">
          <source>Only Intel C++ Compiler v12.1 has been tested. Other versions probably will work. Using Intel C++ Compiler instead of Visual C has the benefit of C99 compatibility which is needed by some CPAN XS modules, while maintaining compatibility with Visual C object code and Visual C debugging infrastructure unlike GCC.</source>
          <target state="translated">Только Intel C++Compiler v12.1 был протестирован.Вероятно,сработают и другие версии.Использование Intel C++Compiler вместо Visual C имеет преимущество совместимости с C99,которое необходимо некоторым модулям CPAN XS,при этом поддерживая совместимость с объектным кодом Visual C и отладочной инфраструктурой Visual C в отличие от GCC.</target>
        </trans-unit>
        <trans-unit id="833cc9382a3040aac18b72415747288176c0756d" translate="yes" xml:space="preserve">
          <source>Only available in 5.9 and later.</source>
          <target state="translated">Доступно только в версии 5.9 и выше.</target>
        </trans-unit>
        <trans-unit id="791c96ad0d89f4c2a397055a16ea908da3689beb" translate="yes" xml:space="preserve">
          <source>Only certain operations originating outside Perl should be affected, as follows:</source>
          <target state="translated">Только определенные операции,происходящие за пределами Perl,должны быть затронуты следующим образом:</target>
        </trans-unit>
        <trans-unit id="332e2ea6f0f288093c9c025ee61a2877052c734b" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; and &quot;other&quot; read-write access. (RISC OS)</source>
          <target state="translated">Хорошо подходит только для изменения &quot;владельца&quot; и &quot;другого&quot; доступа к чтению и записи.(RISC OS)</target>
        </trans-unit>
        <trans-unit id="066c19c4ab7873f5036df4d41c91cf9966174fcb" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; read-write access, &quot;group&quot;, and &quot;other&quot; bits are meaningless. (Win32)</source>
          <target state="translated">Только изменение &quot;владельца&quot; доступа на чтение-запись,&quot;группы&quot; и &quot;других&quot; битов не имеет смысла.(Win32)</target>
        </trans-unit>
        <trans-unit id="e35c0d1762bd110103b5f686e3235899e75efbd0" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.</source>
          <target state="translated">Между фигурными скобками действительны только шестнадцатеричные цифры.Если встречается недопустимый символ,то выдается предупреждение и недопустимый символ и все последующие символы (действительные или недопустимые)внутри фигурных скобок отбрасываются.</target>
        </trans-unit>
        <trans-unit id="575a185473fa8007dc4a01bd9786576149895549" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt; . When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt; , and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt; . Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">После &lt;code&gt;\x&lt;/code&gt; допустимы только шестнадцатеричные цифры . Если за &lt;code&gt;\x&lt;/code&gt; следует менее двух действительных цифр, любые допустимые цифры будут дополнены нулями. Это означает, что &lt;code&gt;\x7&lt;/code&gt; будет интерпретироваться как &lt;code&gt;\x07&lt;/code&gt; , а одиночный &lt;code&gt;&quot;\x&quot;&lt;/code&gt; будет интерпретироваться как &lt;code&gt;\x00&lt;/code&gt; . Если число действительных цифр меньше двух, за исключением конца строки, будет выдано предупреждение. Обратите внимание, что хотя в предупреждении говорится, что недопустимый символ игнорируется, он игнорируется только как часть экранирования и все равно будет использоваться в качестве следующего символа в строке. Например:</target>
        </trans-unit>
        <trans-unit id="6fefd95a29f89da3d95e7f9f02daa15254f112a5" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt; , including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt; , even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">В таблице символов пакета хранятся только идентификаторы, начинающиеся с букв (или подчеркивания). Все остальные символы хранятся в &lt;code&gt;main&lt;/code&gt; пакете , включая все переменные пунктуации, например $ _. Вдобавок, если они не определены, идентификаторы STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC и SIG должны быть включены в &lt;code&gt;main&lt;/code&gt; пакет , даже если они используются для других целей, кроме встроенных. Если у вас есть пакет с именем &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; , вы не можете использовать квалифицированную форму идентификатора, потому что вместо этого он будет интерпретироваться как сопоставление с шаблоном, подстановка или транслитерация.</target>
        </trans-unit>
        <trans-unit id="9758de0e100772430c6fab7d629b550064e3e906" translate="yes" xml:space="preserve">
          <source>Only implemented on sockets. (Win32, VMS)</source>
          <target state="translated">Реализуется только на розетках.(Win32,VMS)</target>
        </trans-unit>
        <trans-unit id="59e3f78d233739ccaf48b169b4ca0ebaefa1c7ab" translate="yes" xml:space="preserve">
          <source>Only in very early releases; is a subset of</source>
          <target state="translated">Только в очень ранних релизах;это подмножество</target>
        </trans-unit>
        <trans-unit id="e3b46eafe2952d2a80f0f05636b70051fd116c6a" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Только в очень редких случаях код должен работать с кодовыми точками Unicode (в отличие от нативных). В этих нескольких случаях вместо этого используйте &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a2ea2fb860587376b8c211541f4f73f5bfc66a" translate="yes" xml:space="preserve">
          <source>Only log errors:</source>
          <target state="translated">Только ошибки журнала:</target>
        </trans-unit>
        <trans-unit id="150ec79437779628315de700ea569bc7019ae33a" translate="yes" xml:space="preserve">
          <source>Only meaningful if PADNAMEt_OUTER is set.</source>
          <target state="translated">Имеет смысл только в том случае,если установлен PADNAMEt_OUTER.</target>
        </trans-unit>
        <trans-unit id="b3938c3e89a8c33d91a1c3ac566ca87a5a31bade" translate="yes" xml:space="preserve">
          <source>Only my/our variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way my/our variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in PL_op-&amp;gt;op_targ), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">Только мои / наши ячейки переменных получают допустимые имена. Остальные - это операционные цели / GV / константы, которые статически выделяются или разрешаются во время компиляции. У них нет имен, по которым их можно было бы найти в коде Perl во время выполнения через eval &quot;&quot;, как это могут быть мои / наши переменные. Поскольку их нельзя искать по &amp;laquo;имени&amp;raquo;, а только по их индексу, выделенному во время компиляции (который обычно находится в PL_op-&amp;gt; op_targ), тратить для них имя SV не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="1f33cd4a2033d06e1657cc72bf00ffb7bbc8903a" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt; , returning just the $dirs.</source>
          <target state="translated">Только в VMS (где нет двусмысленности между частями пути файла и каталога) и AmigaOS (возможно, из-за особенностей реализации в этом модуле) &lt;code&gt;dirname()&lt;/code&gt; работает как &lt;code&gt;fileparse($path)&lt;/code&gt; , возвращая только $ dirs.</target>
        </trans-unit>
        <trans-unit id="cb371934ef388875a4c4834fa50d202d61748f1c" translate="yes" xml:space="preserve">
          <source>Only one encoding is allowed. If you combine modules in a program that have different encodings, only one will be actually used.</source>
          <target state="translated">Допускается только одна кодировка.Если вы комбинируете модули в программе,имеющие разные кодировки,то фактически будет использоваться только одна.</target>
        </trans-unit>
        <trans-unit id="99a4e5aa3778d9b7cf73bb7582fb4140a87cc1e7" translate="yes" xml:space="preserve">
          <source>Only one timer may be counting at once. Each call disables the previous timer, and an argument of &lt;code&gt;0&lt;/code&gt; may be supplied to cancel the previous timer without starting a new one. The returned value is the amount of time remaining on the previous timer.</source>
          <target state="translated">Одновременно может вести счет только один таймер. Каждый вызов отключает предыдущий таймер, и может быть передан аргумент &lt;code&gt;0&lt;/code&gt; для отмены предыдущего таймера без запуска нового. Возвращаемое значение - это количество времени, оставшееся на предыдущем таймере.</target>
        </trans-unit>
        <trans-unit id="f44c9ad6ed1548b5f164387565fa3e8cb708d77b" translate="yes" xml:space="preserve">
          <source>Only package variables (globals, even if localized) are visible to symbolic references. Lexical variables (declared with my()) aren't in a symbol table, and thus are invisible to this mechanism. For example:</source>
          <target state="translated">В символических ссылках видны только переменные пакета (глобусы,даже если они локализованы).Лексические переменные (объявленные функцией my())не находятся в таблице символов,и поэтому невидимы для этого механизма.Например:</target>
        </trans-unit>
        <trans-unit id="8a4fbadaeb2851f2ac1b0ed5194eefd55b4c5de6" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">Только доступ для чтения (через выборку значения или &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; ) приводит к вызовам функций; доступ к изменению выполняется как с обычным хешем.</target>
        </trans-unit>
        <trans-unit id="b7947c4bc8660c246e83d1a75c7b2184fd12d7e5" translate="yes" xml:space="preserve">
          <source>Only reliable on sockets. (RISC OS)</source>
          <target state="translated">Надежность только на розетках.(RISC OS)</target>
        </trans-unit>
        <trans-unit id="fdb6f92993012f8b0d4ace849f814451bcfe4e88" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;.</source>
          <target state="translated">Только некоторые из них используются стандартными стилями, другие предназначены для вас, чтобы вы могли вникнуть в механику optree, если вы хотите добавить новый стиль (см. &lt;a href=&quot;#add_style&quot;&gt;Add_style&lt;/a&gt; ниже), который их использует. Вы также можете добавить новые, используя &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe3b6a74b3cb931875055e55d8dd7ade28775580" translate="yes" xml:space="preserve">
          <source>Only text files containing at least one valid POD command are found.</source>
          <target state="translated">Найдены только текстовые файлы,содержащие хотя бы одну действительную команду POD.</target>
        </trans-unit>
        <trans-unit id="d9f9d19343c8e9d3fc7cfa076da595c837a27fd3" translate="yes" xml:space="preserve">
          <source>Only the INPUT part of this is implemented (Perl to XSUB) and there are no known users in core or on CPAN.</source>
          <target state="translated">Реализована только часть INPUT (от Perl до XSUB)и нет известных пользователей в ядре или на CPAN.</target>
        </trans-unit>
        <trans-unit id="3e92fe265d981838f6731ee2a1313d924147a101" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;S&lt;/code&gt; is considered. (This is important only if &lt;code&gt;S&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">Рассматривается только лучшее совпадение для &lt;code&gt;S&lt;/code&gt; .(Это важно, только если &lt;code&gt;S&lt;/code&gt; имеет захватывающие круглые скобки, а обратные ссылки используются где-то еще во всем регулярном выражении.)</target>
        </trans-unit>
        <trans-unit id="8e81698472dd458b4e2c811d33c204c45a731d7f" translate="yes" xml:space="preserve">
          <source>Only the latest runtime is supported, currently &lt;code&gt;0.9d fix 03&lt;/code&gt;. Perl may run under earlier versions of EMX, but this is not tested.</source>
          <target state="translated">Поддерживается только последняя &lt;code&gt;0.9d fix 03&lt;/code&gt; среды выполнения, в настоящее время 0.9d fix 03 . Perl может работать под более ранними версиями EMX, но это не проверено.</target>
        </trans-unit>
        <trans-unit id="ffed3ab3981beea3a9602d82e26d788b9e9c1484" translate="yes" xml:space="preserve">
          <source>Only the modification time is updated. (VMS, RISC OS)</source>
          <target state="translated">Обновляется только время модификации.(ЗИС,RISC OS)</target>
        </trans-unit>
        <trans-unit id="9aa8446a580db25edb8f05217d7fb57147e13abf" translate="yes" xml:space="preserve">
          <source>Only up to Perl 5.9.4</source>
          <target state="translated">Только до Perl 5.9.4.</target>
        </trans-unit>
        <trans-unit id="ac1ac5484f948b783774a56425a6df37a8f81a3b" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the integer value of the REGEX stored in the MAGIC.</source>
          <target state="translated">Действительно только на r-magic,возвращает целое значение REGEX,сохраненное в MAGIC.</target>
        </trans-unit>
        <trans-unit id="9f66fc81372c8ac766a246f4baea414733aad7cf" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the string that generated the regexp.</source>
          <target state="translated">Действует только на r-magic,возвращает строку,которая сгенерировала регенерацию.</target>
        </trans-unit>
        <trans-unit id="a61aeee0d09958da7f9004eaa2f24e389c377add" translate="yes" xml:space="preserve">
          <source>Only when perl was compiled with ithreads.</source>
          <target state="translated">Только когда Perl был скомпилирован с помощью ithreads.</target>
        </trans-unit>
        <trans-unit id="cd0ef3273488ddac67311854e00313faa5aef30e" translate="yes" xml:space="preserve">
          <source>Oodles of very useful information in there - this seems to be the way forward.</source>
          <target state="translated">Удлы очень полезной информации-это,кажется,и есть путь вперед.</target>
        </trans-unit>
        <trans-unit id="95ff9f7a98d97e5bb7dd5d8797ddd23ecbc3a49a" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;  U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">Ой, мы забыли одну вещь: что, если в начале шаблона есть пробелы? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot; U*&quot;, @stuff)&lt;/code&gt; будет иметь &lt;code&gt;U&lt;/code&gt; в качестве первого активного символа, даже если это не первый элемент в шаблоне. В этом случае мы должны продвигать &lt;code&gt;patcopy&lt;/code&gt; вместе с &lt;code&gt;pat&lt;/code&gt; , когда видим пробелы:</target>
        </trans-unit>
        <trans-unit id="74d23243f911dfb26f7142c0a3c3910d6d1436bc" translate="yes" xml:space="preserve">
          <source>Opcode</source>
          <target state="translated">Opcode</target>
        </trans-unit>
        <trans-unit id="d74efeac75c3ed1e29e1ef5d2a48fa327033703a" translate="yes" xml:space="preserve">
          <source>Opcode - Disable named opcodes when compiling perl code</source>
          <target state="translated">Опкод-Отключить именованные опкоды при компиляции perl кода.</target>
        </trans-unit>
        <trans-unit id="f07e565d51e16d912b38ef0d870eb764e49b25e3" translate="yes" xml:space="preserve">
          <source>Opcode Functions</source>
          <target state="translated">Опкод Функции</target>
        </trans-unit>
        <trans-unit id="96b61e5d9d0edd94f6948898f1398f5d478335a2" translate="yes" xml:space="preserve">
          <source>Open &quot;membername&quot; from the zip file for reading.</source>
          <target state="translated">Откройте &quot;membername&quot; из zip-файла для чтения.</target>
        </trans-unit>
        <trans-unit id="55f7ee4c6a28ca478d6d447371d4c70238f47b16" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See</source>
          <target state="translated">Откройте /dev/tty и используйте TIOCNOTTY ioctl на нем.См..</target>
        </trans-unit>
        <trans-unit id="bdb6e0b133b1b1b5b97afd41a0d0173daaa4add6" translate="yes" xml:space="preserve">
          <source>Open Edition (UNIX System Services) from V2R8 onward does support #!/path/to/perl script invocation. There is a PTF available from IBM for V2R7 that will allow shell/kernel support for #!. USS releases prior to V2R7 did not support the #! means of script invocation. If you are running V2R6 or earlier then see:</source>
          <target state="translated">Open Edition (UNIX System Services)с V2R8 и далее поддерживает #!/path/to/perl вызов скрипта.Есть PTF,доступный в IBM для V2R7,который позволит shell/kernel поддерживать #! Релизы USS до V2R7 не поддерживали #! средства вызова скриптов.Если вы используете V2R6 или более раннюю версию,то смотрите:</target>
        </trans-unit>
        <trans-unit id="6a72f9cc67788da43d43bb9ed1f39ccdfc57b884" translate="yes" xml:space="preserve">
          <source>Open Perl IDE is an integrated development environment for writing and debugging Perl scripts with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.</source>
          <target state="translated">Open Perl IDE-это интегрированная среда разработки для написания и отладки Perl скриптов с дистрибутивом ActiveState ActivePerl под Windows 95/98/NT/2000.</target>
        </trans-unit>
        <trans-unit id="23e95096990f8472afd6cb3709ce6af6451d33e6" translate="yes" xml:space="preserve">
          <source>Open a directory for reading.</source>
          <target state="translated">Откройте каталог для чтения.</target>
        </trans-unit>
        <trans-unit id="8ad49f69af5decd196c780b9f3d0aaa3e3816d7b" translate="yes" xml:space="preserve">
          <source>Open a file for read and write.</source>
          <target state="translated">Откройте файл для чтения и записи.</target>
        </trans-unit>
        <trans-unit id="1e59fee2b2d0c9f3865876e8e0e389d326d3f7c1" translate="yes" xml:space="preserve">
          <source>Open a file for reading for writing. This returns file descriptors, not Perl filehandles. Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">Откройте файл для чтения для записи. Это возвращает дескрипторы файлов, а не дескрипторы файлов Perl. Используйте &lt;code&gt;POSIX::close&lt;/code&gt; чтобы закрыть файл.</target>
        </trans-unit>
        <trans-unit id="6c23e6c0a506e51b8807fe030bb649eaa2c7d5d5" translate="yes" xml:space="preserve">
          <source>Open a file for write, with truncation.</source>
          <target state="translated">Откройте файл для записи,с усечением.</target>
        </trans-unit>
        <trans-unit id="4308ff2808cb74655d1f6985fb86c3f779077365" translate="yes" xml:space="preserve">
          <source>Open a file read-only with mode 0666.</source>
          <target state="translated">Откройте файл только для чтения в режиме 0666.</target>
        </trans-unit>
        <trans-unit id="83b3247daf1ae38653a1c2f6dc56f1f4dd823340" translate="yes" xml:space="preserve">
          <source>Open a process for both reading and writing using open2()</source>
          <target state="translated">Откройте процесс чтения и записи с помощью open2().</target>
        </trans-unit>
        <trans-unit id="2f8a8512d160e2040075be8a77906336494c9074" translate="yes" xml:space="preserve">
          <source>Open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">Откройте процесс чтения,записи и обработки ошибок с помощью функции open3().</target>
        </trans-unit>
        <trans-unit id="79ce744f7faf84a934a5966a77055041e905f34c" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open возвращает ненулевое значение в случае успеха, в противном случае - неопределенное значение. Если &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; связано с конвейером, возвращаемое значение является pid подпроцесса.</target>
        </trans-unit>
        <trans-unit id="78b623ce85a0de7052165209a2216ebe49f4e867" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open возвращает ненулевое значение в случае успеха, в противном случае - неопределенное значение. Если &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; связано с конвейером, возвращаемое значение является pid подпроцесса.</target>
        </trans-unit>
        <trans-unit id="47834b64146be82f867d9923797633975d9cd92f" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt; . The</source>
          <target state="translated">Open должен (возможно, косвенно) вызвать &lt;code&gt;PerlIO_allocate()&lt;/code&gt; чтобы выделить слот в таблице и связать его с информацией о слоях для открытого файла, вызвав &lt;code&gt;PerlIO_push&lt;/code&gt; . В</target>
        </trans-unit>
        <trans-unit id="fa04c7c6f525f721026d1ba438790f3fcc864164" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt; , and with facility &lt;code&gt;LOCAL0&lt;/code&gt; :</source>
          <target state="translated">Откройте системный журнал с параметрами &lt;code&gt;ndelay&lt;/code&gt; и &lt;code&gt;pid&lt;/code&gt; , а также &lt;code&gt;LOCAL0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49536a6420d53dc725b117e3d37bfc34dfb9bef1" translate="yes" xml:space="preserve">
          <source>OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</source>
          <target state="translated">Дампы ядра OpenBSD из getprotobyname_r и getervbyname_r с помощью ithreads</target>
        </trans-unit>
        <trans-unit id="d32dc42d00fa4f78f0a59f030ed60cd6a30b3295" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS
/CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alpha v7.3-1 и новее, а также все версии OpenVMS I64 поддерживают чувствительность к регистру как настройку процесса (см. &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl в настоящее время не поддерживает чувствительность к регистру в VMS, но может в будущем, поэтому программы Perl должны использовать метод &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; для определения состояния, а не переменную &lt;code&gt;$^O&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="580bd0fefd9022c163462e267d5f62605679e1bf" translate="yes" xml:space="preserve">
          <source>Opening Binary Files</source>
          <target state="translated">Открытие бинарных файлов</target>
        </trans-unit>
        <trans-unit id="3b6c1a6dbd679781e98b430deca927902564168e" translate="yes" xml:space="preserve">
          <source>Opening Pipes</source>
          <target state="translated">Разрывные трубы</target>
        </trans-unit>
        <trans-unit id="97614657c24973c63e30d6aea12f0ee16c28cc0b" translate="yes" xml:space="preserve">
          <source>Opening Text Files</source>
          <target state="translated">Открытие текстовых файлов</target>
        </trans-unit>
        <trans-unit id="36680b4c4dae060cef49428930207438c7efaa37" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Reading</source>
          <target state="translated">Открытие текстовых файлов для чтения</target>
        </trans-unit>
        <trans-unit id="2a72037dbe3a876109b6617803140785c781433b" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Writing</source>
          <target state="translated">Открытие текстовых файлов для записи</target>
        </trans-unit>
        <trans-unit id="d41c1a93b08d5c6da84630f4e7549a5cfa0c9f29" translate="yes" xml:space="preserve">
          <source>Opening a Berkeley DB Database File</source>
          <target state="translated">Открытие файла базы данных Berkeley DB</target>
        </trans-unit>
        <trans-unit id="c901450d25c1b4adffc158756d930772312effed" translate="yes" xml:space="preserve">
          <source>Opening a process does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">Открытие процесса не позволяет автоматически промывать выходные ручки на некоторых платформах.(SunOS,Solaris,HP-UX)</target>
        </trans-unit>
        <trans-unit id="b294c249cb9dd744fe8333a0cf9a3eaca337d759" translate="yes" xml:space="preserve">
          <source>Opening and setup functions</source>
          <target state="translated">Функции открытия и настройки</target>
        </trans-unit>
        <trans-unit id="9d1b0daa9340247fc5dd5775b7b3c96ab82ed183" translate="yes" xml:space="preserve">
          <source>Opening brace lines up with &quot;if&quot; when conditional spans multiple lines; should be at end-of-line otherwise</source>
          <target state="translated">Открывать линии скобки с надписью &quot;if&quot;,когда условные линии охватывают несколько линий;в противном случае они должны быть в конце линии.</target>
        </trans-unit>
        <trans-unit id="4a1d6b2927f0e3d3a000bd5c08d3176bb52e234e" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающаяся скобка для облегченного обратного вызова. См. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;ОБЛЕГЧЕННЫЕ ОТВЕТЫ в perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2922ae0d4b2356e8683f8338a16e139ec4c04e6a" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;PUTBACK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающая скобка для аргументов обратного вызова. Смотрите &lt;code&gt;PUTBACK&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0cd04a850fb6ef4b1c1ae0773c22c62016e5236" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;FREETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающая скобка для временных конструкций при обратном вызове. Смотрите &lt;code&gt;FREETMPS&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3379b419b90643ab2744dfbdcecf5edbb46257a1" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;LEAVE&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающая скобка при обратном вызове. Смотрите &lt;code&gt;LEAVE&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb5320c0f77aa06e6c4f3f19f91a0a627e401dd" translate="yes" xml:space="preserve">
          <source>Opening curly on same line as keyword, if possible, otherwise line up.</source>
          <target state="translated">Открытие фигурным шрифтом на той же строке,что и ключевое слово,если это возможно,в противном случае-в строке.</target>
        </trans-unit>
        <trans-unit id="702f344a10799adb9c373ae43617c29a1d640fe4" translate="yes" xml:space="preserve">
          <source>Opening files for read-write is currently not supported if they use stdio (normal perl file handles).</source>
          <target state="translated">Открытие файлов для чтения-записи в настоящее время не поддерживается,если они используют stdio (обычные дескрипторы perl файлов).</target>
        </trans-unit>
        <trans-unit id="f85c9c937148eb202d62793f91340ba09b2f7a5e" translate="yes" xml:space="preserve">
          <source>Opening the data file in write-only or append mode is not supported.</source>
          <target state="translated">Открытие файла данных в режиме только для записи или в режиме добавления не поддерживается.</target>
        </trans-unit>
        <trans-unit id="c745d61fd7e06451beaeff422ae86fd1baafa519" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;$output&lt;/code&gt; in append mode.</source>
          <target state="translated">Открывает &lt;code&gt;$output&lt;/code&gt; в режиме добавления.</target>
        </trans-unit>
        <trans-unit id="83d174f108cd7d61c427811f31c1c3a17b3fd039" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">Открывает каталог с именем EXPR для обработки &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; . В случае успеха возвращает true. DIRHANDLE может быть выражением, значение которого может использоваться как косвенный дескриптор dirhandle, обычно это настоящее имя dirhandle. Если DIRHANDLE - неопределенная скалярная переменная (или массив, или хеш-элемент), переменной назначается ссылка на новый анонимный дескриптор dir; то есть он самовживителен. У DIRHANDLE есть собственное пространство имен, отдельное от FILEHANDLE.</target>
        </trans-unit>
        <trans-unit id="bde0bd94d408d74305c3ef236f8e210809c61889" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">Открывает каталог с именем EXPR для обработки &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; . В случае успеха возвращает true. DIRHANDLE может быть выражением, значение которого может использоваться как косвенный дескриптор dirhandle, обычно это настоящее имя dirhandle. Если DIRHANDLE - неопределенная скалярная переменная (или массив, или хеш-элемент), переменной назначается ссылка на новый анонимный дескриптор dir; то есть он самовживителен. У DIRHANDLE есть собственное пространство имен, отдельное от FILEHANDLE.</target>
        </trans-unit>
        <trans-unit id="ef6eec3f73e02b66c5dbdd58e24c78d1b02394cb" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;code&gt;$|&lt;/code&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">Открывает пару подключенных каналов, как соответствующий системный вызов. Обратите внимание: если вы настроили цикл конвейерных процессов, может возникнуть взаимоблокировка, если вы не будете очень осторожны. Кроме того, обратите внимание, что каналы Perl используют буферизацию ввода-вывода, поэтому вам может потребоваться установить &lt;code&gt;$|&lt;/code&gt; очищать WRITEHANDLE после каждой команды, в зависимости от приложения.</target>
        </trans-unit>
        <trans-unit id="97d9deba78acd708222827724c50fc7000bf21a2" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Открывает сокет указанного типа и присоединяет его к дескриптору файла SOCKET. DOMAIN, TYPE и PROTOCOL задаются так же, как и для одноименного системного вызова. Сначала вы должны &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; чтобы импортировать правильные определения. См. Примеры в &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bf5e36d7b7be8ff46fbdc02b28950f2a5493007" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Открывает сокет указанного типа и присоединяет его к дескриптору файла SOCKET. DOMAIN, TYPE и PROTOCOL задаются так же, как и для одноименного системного вызова. Сначала вы должны &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; чтобы импортировать правильные определения. См. Примеры в &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f043104d316702a10e0ee9e23884fe89eeee7102" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</source>
          <target state="translated">Открывает файл,имя которого указано в EXPR,и связывает его с FILEHANDLE.</target>
        </trans-unit>
        <trans-unit id="f8d3156ec9740e3cf785b92426587c9913bf7a48" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's</source>
          <target state="translated">Открывает файл,имя которого задано FILENAME,и связывает его с FILEHANDLE.Если FILEHANDLE является выражением,его значение используется как реальная нужная файловая ручка;неопределенный скаляр будет соответствующим образом автоповинован.Эта функция вызывает базовую операционную систему</target>
        </trans-unit>
        <trans-unit id="4d5a806f4d052ec496b3b922107438a0577f84fc" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : see &lt;a href=&quot;#Facilities&quot;&gt;Facilities&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">Открывает системный журнал. &lt;code&gt;$ident&lt;/code&gt; добавляется к каждому сообщению. &lt;code&gt;$logopt&lt;/code&gt; содержит ноль или более параметров, описанных ниже. &lt;code&gt;$facility&lt;/code&gt; указывает часть системы, о которой следует сообщать, например, &lt;code&gt;LOG_USER&lt;/code&gt; или &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : см. Список известных средств в разделе &amp;laquo; &lt;a href=&quot;#Facilities&quot;&gt;Средства&amp;raquo;&lt;/a&gt; , а в документации по &lt;code&gt;syslog(3)&lt;/code&gt; - средства, доступные в вашей системе. Проверьте &lt;a href=&quot;#SEE-ALSO&quot;&gt;СМОТРИ ТАКЖЕ&lt;/a&gt; полезные ссылки. Функцию можно указать в виде строки или числового макроса.</target>
        </trans-unit>
        <trans-unit id="d7befdfbc60eb47b3289957505fb12ce62daabea" translate="yes" xml:space="preserve">
          <source>Operating System Interfaces</source>
          <target state="translated">Интерфейсы операционной системы</target>
        </trans-unit>
        <trans-unit id="b9967a65c2c4c5007de8b77bf65865521f0d26c6" translate="yes" xml:space="preserve">
          <source>Operating on references to hashes.</source>
          <target state="translated">Работает по ссылкам на хэши.</target>
        </trans-unit>
        <trans-unit id="c28848b2a51553304abcd6de3ae0236ffb496efe" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments which is exactly what you expect.</source>
          <target state="translated">Операции с перегруженными операторами сохраняют аргументы,которые в точности соответствуют вашим ожиданиям.</target>
        </trans-unit>
        <trans-unit id="d4e4327f6fb8077a49e03daa6c0ea206ecb5c16a" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</source>
          <target state="translated">Операции с перегруженными операторами сохраняют аргументы,а это именно то,чего вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="f921f14a57cf5d524fbd5fad00e7ed999feb448d" translate="yes" xml:space="preserve">
          <source>Operator Names and Operator Lists</source>
          <target state="translated">Имена и списки операторов</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="translated">Перегрузка оператора</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">Приоритет оператора и партнерская деятельность</target>
        </trans-unit>
        <trans-unit id="11c9953040dd3157f9326929003c9899b7cffb21" translate="yes" xml:space="preserve">
          <source>Operator associativity</source>
          <target state="translated">Ассоциативность оператора</target>
        </trans-unit>
        <trans-unit id="08ca8c19d61f0facd586cd4f482f39a253b12167" translate="yes" xml:space="preserve">
          <source>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; call. Values specified as strings are interpreted as method names. Thus</source>
          <target state="translated">Реализации операторов (значения) могут быть подпрограммами, ссылками на подпрограммы или анонимными подпрограммами - другими словами, все, что разрешено внутри вызова &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; . Значения, указанные как строки, интерпретируются как имена методов. Таким образом</target>
        </trans-unit>
        <trans-unit id="4f99a8916efac564a63d50ce560cad0dd70e1540" translate="yes" xml:space="preserve">
          <source>Operator names are typically small lowercase words like enterloop, leaveloop, last, next, redo etc. Sometimes they are rather cryptic like gv2cv, i_ncmp and ftsvtx.</source>
          <target state="translated">Имена операторов обычно представляют собой маленькие строчные слова,такие как enterloop,leaveloop,last,next,redo и т.д.Иногда они довольно загадочны,как gv2cv,i_ncmp и ftsvtx.</target>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="translated">Первенство оператора</target>
        </trans-unit>
        <trans-unit id="b559bbb40846a93d37a125fab7a9a1b57c0dd2f9" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity work in Perl more or less like they do in mathematics.</source>
          <target state="translated">Приоритет оператора и ассоциативность работают на Perl более или менее так же,как и в математике.</target>
        </trans-unit>
        <trans-unit id="6852b1cd2bb1031ac4d81d694fd94535c3eb3d11" translate="yes" xml:space="preserve">
          <source>Operator tags can be used to refer to groups (or sets) of operators. Tag names always begin with a colon. The Opcode module defines several optags and the user can define others using the define_optag function.</source>
          <target state="translated">Метки операторов могут использоваться для обозначения групп (или наборов)операторов.Имена тегов всегда начинаются с двоеточия.Модуль Opcode определяет несколько оптагов,а пользователь может определить другие с помощью функции define_optag.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="63e0a2d0a1f37e46caa267d78be1feaf655b0cda" translate="yes" xml:space="preserve">
          <source>Operators dealing with filenames are examples.</source>
          <target state="translated">Примером могут служить операторы,работающие с именами файлов.</target>
        </trans-unit>
        <trans-unit id="55ddd8565a51d103a65dc3c453ea6bce04b13905" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">Такие операторы, как &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; переводят аргументы в формат с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="864704fd78dbf2c79b9e58c4ea43f3220669cded" translate="yes" xml:space="preserve">
          <source>Ops such as chdir obviously effect the process as a whole and not just the code in the compartment. Ops such as rand and srand have a similar but more subtle effect.</source>
          <target state="translated">Очевидно,что такие операции,как chdir,влияют на процесс в целом,а не только на код в отсеке.Такие операторы,как rand и srand,имеют похожий,но более тонкий эффект.</target>
        </trans-unit>
        <trans-unit id="977af567e0cb291a9f2082343e1b048e5433a7e1" translate="yes" xml:space="preserve">
          <source>Opsets may be manipulated using the perl bit vector operators &amp;amp; (and), | (or), ^ (xor) and ~ (negate/invert).</source>
          <target state="translated">Опциями можно управлять с помощью операторов битовых векторов Perl &amp;amp; (и), | (или), ^ (xor) и ~ (отрицание / инвертирование).</target>
        </trans-unit>
        <trans-unit id="6221772a58b20793863ce371d773cbe75426798d" translate="yes" xml:space="preserve">
          <source>OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax-highlighting editor.</source>
          <target state="translated">OptiPerl-это Windows IDE с симулированной CGI-средой,включающей отладчик и редактор синтаксиса.</target>
        </trans-unit>
        <trans-unit id="3aefe0ba1ba6e76e7b11557d066b96b14e2c986e" translate="yes" xml:space="preserve">
          <source>Optimisation data; subject to change.</source>
          <target state="translated">Данные оптимизации;могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="6169946bff1ab1bb2fe62a2ebdb2dd4fa18f40fb" translate="yes" xml:space="preserve">
          <source>Optimisation flags; subject to change.</source>
          <target state="translated">Флаги оптимизации;могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="18a333060bee7f2ee65af71205072e100d62bacc" translate="yes" xml:space="preserve">
          <source>Optimized-away statements are rendered as '???'. This includes statements that have a compile-time side-effect, such as the obscure</source>
          <target state="translated">Оптимизированные заявления выдаются в виде '??'.Это включает в себя утверждения,которые имеют побочный эффект компилирующего времени,такие как неясные</target>
        </trans-unit>
        <trans-unit id="3e1ccc3d0caaae646e1ab71f59e1842b2b4f1166" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt; .</source>
          <target state="translated">Дальнейшая оптимизация - задача для &lt;code&gt;p5p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b89db00fb49023ab4c0f78acb572909bcf10d35" translate="yes" xml:space="preserve">
          <source>Option Format</source>
          <target state="translated">Вариант Формат</target>
        </trans-unit>
        <trans-unit id="f506dd24a9e7c79211553ebe1422f91140092c4a" translate="yes" xml:space="preserve">
          <source>Option Stickiness</source>
          <target state="translated">Вариант Липкость</target>
        </trans-unit>
        <trans-unit id="8b0267bbb54c30709fbd963f611e8c9f6fcd1f57" translate="yes" xml:space="preserve">
          <source>Option words are separated by commas (not whitespace) and follow the usual conventions of compiler backend options.</source>
          <target state="translated">Слова опций разделены запятыми (не пробелами)и следуют обычным конвенциям опций бэкэнда компилятора.</target>
        </trans-unit>
        <trans-unit id="bd62828c4813996c3de7a8b7f837c827369e6d5e" translate="yes" xml:space="preserve">
          <source>Option, Argument, Parameter, and Configuration File Processing</source>
          <target state="translated">Опция,Аргумент,Параметр и Обработка файла конфигурации</target>
        </trans-unit>
        <trans-unit id="16df76c37a27e75c2b404f915ffcff82e54620ed" translate="yes" xml:space="preserve">
          <source>Optional - called when the layer is about to be removed.</source>
          <target state="translated">Необязательно-вызывается,когда слой собирается удалить.</target>
        </trans-unit>
        <trans-unit id="279393da5192f90d67ca2ac7c82f748509f343b9" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for opens which pass a numeric file descriptor. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">Необязательно-если нет нижнего слоя,то открывается.Если присутствует,то вызывается после того,как слой подталкивается к открытиям,которые передают числовой файловый дескриптор.Эта функция может быть изменена,так как нет простого способа заставить нижний слой сделать открытие,а затем вернуть контроль.</target>
        </trans-unit>
        <trans-unit id="66c7071a6fa7cb2bb38d9b2c01a05a137c430add" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for sysopen style opens which pass a numeric mode and permissions. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">Необязательно-если нет нижнего слоя,то открывается.Если присутствует,то вызывается после нажатия на слой для открытия Sysopen стиля,который проходит числовой режим и права доступа.Эта функция может быть изменена,так как нет простого способа заставить нижний слой сделать открытие,а затем вернуть контроль.</target>
        </trans-unit>
        <trans-unit id="00aae857e158214ab9fea8340d3e81b79261acff" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called for normal opens after the layer is pushed. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">Необязательно-если нет нижнего слоя,то открывается.Если присутствует,вызывается для нормального открытия после нажатия на слой.Эта функция может быть изменена,так как нет простого способа заставить нижний слой сделать открытие,а затем вернуть контроль.</target>
        </trans-unit>
        <trans-unit id="c67ecb9d9cd03592e40a8cfa5395a4594326ddf4" translate="yes" xml:space="preserve">
          <source>Optional - if not present the layer is popped on binmode($fh) or when &lt;code&gt;:raw&lt;/code&gt; is pushed. If present it should return 0 on success, -1 on error, or undef to pop the layer.</source>
          <target state="translated">Необязательно - если его нет, слой появляется в binmode ($ fh) или когда &lt;code&gt;:raw&lt;/code&gt; выталкивается. Если присутствует, он должен вернуть 0 в случае успеха, -1 в случае ошибки или undef для выталкивания слоя.</target>
        </trans-unit>
        <trans-unit id="ea8b4c621a2282475d1c70505956ae9cadc5c505" translate="yes" xml:space="preserve">
          <source>Optional - if present it will be called immediately after PUSHED has returned. It should return a true value if the layer expects data to be UTF-8 encoded. If it returns true, the result is as if the caller had done</source>
          <target state="translated">Необязательно-если присутствует,он будет вызван сразу после возвращения PUSHED.Должно возвращаться значение true,если слой ожидает,что данные будут в кодировке UTF-8.Если возвращается true,то результат будет выглядеть так,как если бы вызывающая сторона сделала следующее</target>
        </trans-unit>
        <trans-unit id="74e7ab47ea9482eb12b8ad3e12ec65d52754eeba" translate="yes" xml:space="preserve">
          <source>Optional Exports</source>
          <target state="translated">Дополнительный экспорт</target>
        </trans-unit>
        <trans-unit id="a1586faede4e39ea6174b7a684a9a34f79190989" translate="yes" xml:space="preserve">
          <source>Optional Libraries for Perl on Cygwin</source>
          <target state="translated">Дополнительные библиотеки для Perl на Cygwin</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="translated">Дополнительные параметры</target>
        </trans-unit>
        <trans-unit id="5d44ae4df7ee3a08403ce68c38bfce3a82e017dd" translate="yes" xml:space="preserve">
          <source>Optional argument is (NAMESPACE), where NAMESPACE is the root namespace to use for the compartment (defaults to &quot;Safe::Root0&quot;, incremented for each new compartment).</source>
          <target state="translated">Необязательный аргумент (NAMESPACE),где NAMESPACE-это корневое пространство имён,используемое для помещения (по умолчанию &quot;Safe::Root0&quot;,инкрементированное для каждого нового помещения).</target>
        </trans-unit>
        <trans-unit id="b9ba9d28014863d3a9a0ee7c8bcd9a7976dbaee9" translate="yes" xml:space="preserve">
          <source>Optional positional parameters must come after all mandatory positional parameters. (If there are no mandatory positional parameters then an optional positional parameters can be the first thing in the signature.) If there are multiple optional positional parameters and not enough arguments are supplied to fill them all, they will be filled from left to right.</source>
          <target state="translated">Дополнительные параметры позиционирования должны приходить после всех обязательных параметров позиционирования.(Если нет обязательных параметров позиционирования,то опциональные параметры позиционирования могут быть первыми в подписи).Если существует несколько опциональных позиционных параметров и не хватает аргументов для их заполнения,они будут заполняться слева направо.</target>
        </trans-unit>
        <trans-unit id="555e2b70062eccf33f8313bcc3fba207cf55ade3" translate="yes" xml:space="preserve">
          <source>Optional sorting weight for names, to determine the order of linear testing when multiple names fall in the same case of a switch clause. Higher comes earlier, undefined defaults to zero.</source>
          <target state="translated">Необязательная сортировка по весу названий для определения порядка линейного тестирования,когда несколько названий попадают в один и тот же случай пункта переключения.Выше-раньше,неопределенные значения по умолчанию-ноль.</target>
        </trans-unit>
        <trans-unit id="da333a941fe0f82279c2c56c201f1766ccc0c3ef" translate="yes" xml:space="preserve">
          <source>Optional state for the subroutine. The state is passed in as &lt;code&gt;$_[1]&lt;/code&gt; . A reference to the subroutine itself is passed in as &lt;code&gt;$_[0]&lt;/code&gt; .</source>
          <target state="translated">Необязательное состояние подпрограммы. Состояние передается как &lt;code&gt;$_[1]&lt;/code&gt; . Ссылка на саму подпрограмму передается как &lt;code&gt;$_[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3640bdb58e89d324060d7d4f59fe26b0786d9f1e" translate="yes" xml:space="preserve">
          <source>Optional system utilities/More</source>
          <target state="translated">Дополнительные системные утилиты/Больше</target>
        </trans-unit>
        <trans-unit id="d82440108ab7dd6400453483bc258adad0e75461" translate="yes" xml:space="preserve">
          <source>Optional warnings are enabled by using the &lt;code&gt;warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; and &lt;b&gt;-W&lt;/b&gt; switches. Warnings may be captured by setting &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; to a reference to a routine that will be called on each warning instead of printing it. See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Необязательные предупреждения включаются с помощью &lt;code&gt;warnings&lt;/code&gt; warnings или ключей &lt;b&gt;-w&lt;/b&gt; и &lt;b&gt;-W&lt;/b&gt; . Предупреждения могут быть получены путем установки в &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; ссылки на процедуру, которая будет вызываться при каждом предупреждении вместо его печати. См. &lt;a href=&quot;perlvar&quot;&gt;Perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24b988e3016e060f13aed9e152faafade2e2cb57" translate="yes" xml:space="preserve">
          <source>Optional. If present should return an SV * representing the string argument passed to the layer when it was pushed. e.g. &quot;:encoding(ascii)&quot; would return an SvPV with value &quot;ascii&quot;. (</source>
          <target state="translated">Необязательно.Если присутствующий должен вернуть SV *,представляющий строковый аргумент,переданный слою при его проталкивании,например,&quot;:encoding(ascii)&quot; вернет SvPV со значением &quot;ascii&quot;.(</target>
        </trans-unit>
        <trans-unit id="f5c256c5844c41d82f2e7aa133aee1f37b9932b4" translate="yes" xml:space="preserve">
          <source>Optional. No return.</source>
          <target state="translated">Необязательно.Возврата нет.</target>
        </trans-unit>
        <trans-unit id="ce76e8ee73778e5c913a5dddf60e41e4482a439a" translate="yes" xml:space="preserve">
          <source>Optional. Returns end-of-file state. Default is a function of the return value of FILL or READ.</source>
          <target state="translated">Необязательно.Возвращает состояние конца файла.По умолчанию является функцией возвращаемого значения FILL или READ.</target>
        </trans-unit>
        <trans-unit id="aceaf62498201d3cb7c33131b06976b5e7ec5946" translate="yes" xml:space="preserve">
          <source>Optional. Returns error state. Default is no error until a mechanism to signal error (die?) is worked out.</source>
          <target state="translated">Необязательно.Возвращает состояние ошибки.Состояние по умолчанию не является ошибкой до тех пор,пока не будет отработан механизм сигнала об ошибке (смерти?).</target>
        </trans-unit>
        <trans-unit id="d29adb828f03b9de58472833d11e71256f30b852" translate="yes" xml:space="preserve">
          <source>Optional. Used when &lt;code&gt;:raw&lt;/code&gt; layer is pushed (explicitly or as a result of binmode(FH)). If not present layer will be popped. If present should configure layer as binary (or pop itself) and return 0. If it returns -1 for error &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; will fail with layer still on the stack.</source>
          <target state="translated">По желанию. Используется, когда &lt;code&gt;:raw&lt;/code&gt; слой помещается (явно или в результате binmode (FH)). Если его нет, слой будет всплывать. Если присутствует, следует сконфигурировать уровень как двоичный (или &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; сам) и вернуть 0. Если он вернет -1 для ошибки, binmode завершится неудачно, а слой все еще находится в стеке.</target>
        </trans-unit>
        <trans-unit id="54b5a80daefc2af51dc49c0805f2d21b91e8668b" translate="yes" xml:space="preserve">
          <source>Optionally calls timethese(), then outputs comparison chart. This:</source>
          <target state="translated">Опционально вызывает функцию timethese(),затем выводит сравнительный график.Это:</target>
        </trans-unit>
        <trans-unit id="8f2a6f0c361fa39f73808260e667b43a0b479347" translate="yes" xml:space="preserve">
          <source>Optionally, for trying out the feature, you may want to enable automatic dumping of the backtrace just before a warning or croak (die) message is emitted, by adding &lt;code&gt;-Accflags=-DUSE_C_BACKTRACE_ON_ERROR&lt;/code&gt; for Configure.</source>
          <target state="translated">При желании, чтобы опробовать эту функцию, вы можете включить автоматический сброс трассировки непосредственно перед &lt;code&gt;-Accflags=-DUSE_C_BACKTRACE_ON_ERROR&lt;/code&gt; предупреждения или кваканья (умереть), добавив -Accflags = -DUSE_C_BACKTRACE_ON_ERROR для Configure.</target>
        </trans-unit>
        <trans-unit id="6d56e16a59906dea5f31b29892ce1311dd9cccd9" translate="yes" xml:space="preserve">
          <source>Optionally, one can merge the description of types and the list of argument names, rewriting this as</source>
          <target state="translated">Дополнительно можно объединить описание типов и список имен аргументов,переписав его как</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="9c5258ecb746f12e305ee9f0999e8ac50793402b" translate="yes" xml:space="preserve">
          <source>Options (specified by the following modifiers) are:</source>
          <target state="translated">Опции (заданные следующими модификаторами):</target>
        </trans-unit>
        <trans-unit id="ec1f90c3315fe4700f720cb2f4a9e4c50e170f92" translate="yes" xml:space="preserve">
          <source>Options affect how things are rendered (ie printed). They're presented here by their visual effect, 1st being strongest. They're grouped according to how they interrelate; within each group the options are mutually exclusive (unless otherwise stated).</source>
          <target state="translated">Опции влияют на то,как вещи отображаются (т.е.распечатываются).Они представлены здесь своим визуальным эффектом,1-ый-самый сильный.Они сгруппированы в соответствии с тем,как они взаимосвязаны;внутри каждой группы опции являются взаимоисключающими (если не указано иначе).</target>
        </trans-unit>
        <trans-unit id="48a464c28a671924b790e4e5d29f7c52e88ad928" translate="yes" xml:space="preserve">
          <source>Options are as described in &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; above; in addition, the following match process modifiers are available:</source>
          <target state="translated">Параметры описаны в &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; выше; кроме того, доступны следующие модификаторы процесса сопоставления:</target>
        </trans-unit>
        <trans-unit id="6e758911022c90dc88a8767e43a034d257baa395" translate="yes" xml:space="preserve">
          <source>Options are as with &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; with the addition of the following replacement specific options:</source>
          <target state="translated">Параметры такие же, как в случае с &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; с добавлением следующих специальных опций для замены:</target>
        </trans-unit>
        <trans-unit id="1be4081ccaf3e011dcb6256fd6926414b643ca82" translate="yes" xml:space="preserve">
          <source>Options can be combined as required.</source>
          <target state="translated">Опции могут быть объединены по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="44de2a921493b7d9eacebba61cb9256d0440d480" translate="yes" xml:space="preserve">
          <source>Options can have values, the value is placed after the option character. Sometimes with whitespace in between, sometimes not:</source>
          <target state="translated">Опции могут иметь значения,значение помещается после символа опции.Иногда с пробелами между ними,иногда нет:</target>
        </trans-unit>
        <trans-unit id="6f40af16e1d24ead9dd1ab7a9826636a3e146727" translate="yes" xml:space="preserve">
          <source>Options can take multiple values at once, for example</source>
          <target state="translated">Опции могут принимать несколько значений одновременно,например</target>
        </trans-unit>
        <trans-unit id="3ddfd37b7dede31756596dac520f5a582b7ed831" translate="yes" xml:space="preserve">
          <source>Options controlling sequence numbering</source>
          <target state="translated">Опции,управляющие нумерацией последовательности</target>
        </trans-unit>
        <trans-unit id="9a8a3df69d73a894006df726b5df3d7d2139bdfa" translate="yes" xml:space="preserve">
          <source>Options for Line-Style</source>
          <target state="translated">Опции для линейного стиля</target>
        </trans-unit>
        <trans-unit id="58018de8cc3dcfc82b97b039f35b6a1c13becc88" translate="yes" xml:space="preserve">
          <source>Options for Opcode Ordering</source>
          <target state="translated">Опции для заказа опкодов</target>
        </trans-unit>
        <trans-unit id="55b5d2921e00a398b412bd693eeb7b816a5988e5" translate="yes" xml:space="preserve">
          <source>Options for tree-specific formatting</source>
          <target state="translated">Опции для специфического для деревьев форматирования</target>
        </trans-unit>
        <trans-unit id="85b85ab75dd0ae66d7aa6313828663d28696cdc6" translate="yes" xml:space="preserve">
          <source>Options include:</source>
          <target state="translated">Опции включают в себя:</target>
        </trans-unit>
        <trans-unit id="0cc4681b46a8bbe1672f6ee5cc5274a5a2e1321f" translate="yes" xml:space="preserve">
          <source>Options sometimes take several values. For example, a program could use multiple directories to search for library files:</source>
          <target state="translated">Опции иногда принимают несколько значений.Например,программа может использовать несколько каталогов для поиска библиотечных файлов:</target>
        </trans-unit>
        <trans-unit id="f78d98a0f0a1d210a552e42c750a6f91f2370150" translate="yes" xml:space="preserve">
          <source>Options that take arguments:</source>
          <target state="translated">Варианты,которые принимают аргументы:</target>
        </trans-unit>
        <trans-unit id="41151a23e0b5c5a846ca08d323cfca7cf516f1a6" translate="yes" xml:space="preserve">
          <source>Options with hash values</source>
          <target state="translated">Опции со значениями хэша</target>
        </trans-unit>
        <trans-unit id="60f84bb401de02d865a716cc0a5e1289035f7821" translate="yes" xml:space="preserve">
          <source>Options with multiple names</source>
          <target state="translated">Опции с несколькими названиями</target>
        </trans-unit>
        <trans-unit id="c9529a432aa4df6cdd00e1eef2fc89856c4d9538" translate="yes" xml:space="preserve">
          <source>Options with multiple values</source>
          <target state="translated">Опции с несколькими значениями</target>
        </trans-unit>
        <trans-unit id="ce4401244b851388c74b7c8db83ca37894df35bc" translate="yes" xml:space="preserve">
          <source>Options with values</source>
          <target state="translated">Варианты со значениями</target>
        </trans-unit>
        <trans-unit id="44b169e466bada4cebf1bd71469144108ff2f954" translate="yes" xml:space="preserve">
          <source>Options.U</source>
          <target state="translated">Options.U</target>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="99fd4ae20169f4f1fd95e0b318eddbf04496e03f" translate="yes" xml:space="preserve">
          <source>Optree Manipulation Functions</source>
          <target state="translated">Функции манипуляции оптером</target>
        </trans-unit>
        <trans-unit id="6660f96406f6f5efcf28a2f461913aed19ed8b17" translate="yes" xml:space="preserve">
          <source>Optree construction</source>
          <target state="translated">Конструкция по выбору</target>
        </trans-unit>
        <trans-unit id="219c1efc76675f38bcd59bb9804c4faf6887590f" translate="yes" xml:space="preserve">
          <source>Or by including the &lt;a href=&quot;tester/color&quot;&gt;Test::Builder::Tester::Color&lt;/a&gt; module directly in the PERL5LIB.</source>
          <target state="translated">Или включив модуль &lt;a href=&quot;tester/color&quot;&gt;Test :: Builder :: Tester :: Color&lt;/a&gt; непосредственно в PERL5LIB.</target>
        </trans-unit>
        <trans-unit id="939c0047d2a7d9894b911fc7f2bc8d3ef6ebb72b" translate="yes" xml:space="preserve">
          <source>Or even the day of the year (which is what some people think of as a Julian day):</source>
          <target state="translated">Или даже день в году (что некоторые считают днем Джулиана):</target>
        </trans-unit>
        <trans-unit id="c8d29c4a4243321b13a4333a16028d3427ee5e4d" translate="yes" xml:space="preserve">
          <source>Or even to place backup copies of the original files into another directory (provided the directory already exists):</source>
          <target state="translated">Или даже разместить резервные копии исходных файлов в другой каталог (при условии,что каталог уже существует):</target>
        </trans-unit>
        <trans-unit id="a39395a536571e326a3e448e36d0980f046516aa" translate="yes" xml:space="preserve">
          <source>Or even with a literal numeric descriptor:</source>
          <target state="translated">Или даже с буквальным цифровым описанием:</target>
        </trans-unit>
        <trans-unit id="ab622aab7528770d4b43d68b1cd75eb516c4a74e" translate="yes" xml:space="preserve">
          <source>Or for months:</source>
          <target state="translated">Или в течение нескольких месяцев:</target>
        </trans-unit>
        <trans-unit id="4fbd4993cb449934f1a66fbe81f10f2f69d366bb" translate="yes" xml:space="preserve">
          <source>Or here's another sample of using our tied class:</source>
          <target state="translated">Или вот еще один пример использования нашего завязанного класса:</target>
        </trans-unit>
        <trans-unit id="1cc3245f722d14e01ba8265aa59ed13c82aa6c08" translate="yes" xml:space="preserve">
          <source>Or if you already have an open filehandle:</source>
          <target state="translated">Или если у тебя уже есть открытая ручка:</target>
        </trans-unit>
        <trans-unit id="4b436dc18b09a9237b0e320d550c6bceb76aed2a" translate="yes" xml:space="preserve">
          <source>Or if you don't care to play it safe, like this:</source>
          <target state="translated">Или если ты не хочешь играть в безопасную игру,вот так:</target>
        </trans-unit>
        <trans-unit id="ab228fa27d4891d818d4fcc6cc01c02a70a2f225" translate="yes" xml:space="preserve">
          <source>Or if you don't mind pulling in a few thousand lines of code just because you're afraid of a little &lt;code&gt;$|&lt;/code&gt; variable:</source>
          <target state="translated">Или, если вы не против добавить несколько тысяч строк кода только потому, что боитесь небольшой &lt;code&gt;$|&lt;/code&gt; переменная:</target>
        </trans-unit>
        <trans-unit id="6de1ca81804fc1d18de6212eb9c2eb10c739f658" translate="yes" xml:space="preserve">
          <source>Or if you have a core dump:</source>
          <target state="translated">Или если у тебя есть свалка:</target>
        </trans-unit>
        <trans-unit id="08ae01f1533c609ba5994d6d80c6e627d6b146ea" translate="yes" xml:space="preserve">
          <source>Or if you really want to save space:</source>
          <target state="translated">Или если ты действительно хочешь сэкономить место:</target>
        </trans-unit>
        <trans-unit id="91c274909c10e199bdd764d2f1727e59782d9346" translate="yes" xml:space="preserve">
          <source>Or if you try to do</source>
          <target state="translated">Или если ты попытаешься сделать</target>
        </trans-unit>
        <trans-unit id="151d66e1a17731064f48e0aa8f42f3272b7c1ba5" translate="yes" xml:space="preserve">
          <source>Or if you want to schedule a</source>
          <target state="translated">Или если ты хочешь запланировать</target>
        </trans-unit>
        <trans-unit id="a55b0108f3cf41f36382908140f2919f204761ba" translate="yes" xml:space="preserve">
          <source>Or in a more recent version:</source>
          <target state="translated">Или в более свежей версии:</target>
        </trans-unit>
        <trans-unit id="c2f0409db7dd86c778a013b8c1b13fb97d9866d1" translate="yes" xml:space="preserve">
          <source>Or insert multiple javascript source in the header (or for that matter include anything, thought this is not recommended)</source>
          <target state="translated">Или вставьте в заголовок несколько исходников javascript (или,если уж на то пошло,включите что-нибудь,думаю,это не рекомендуется).</target>
        </trans-unit>
        <trans-unit id="1f2f783b03d3690462c1ad2137de324e8f81f559" translate="yes" xml:space="preserve">
          <source>Or install it RPM Style:</source>
          <target state="translated">Или установите его в стиле RPM:</target>
        </trans-unit>
        <trans-unit id="4e1bab7ea88f309a093f0d39d4f730b201961c56" translate="yes" xml:space="preserve">
          <source>Or instead of storing this in the language class's lexicon, you can (and, in some cases, really should) represent the same bit of knowledge as code in a method in the language class. (That leaves a tidy distinction between the lexicon as the things we know how to</source>
          <target state="translated">Или вместо того,чтобы хранить это в лексиконе класса языка,можно (а в некоторых случаях и нужно)представлять тот же бит знаний,что и код в методе в классе языка.(Это оставляет аккуратное разграничение между лексикой и тем,что мы умеем.</target>
        </trans-unit>
        <trans-unit id="7045f93919469e6381656c230b7db826c2eef7c3" translate="yes" xml:space="preserve">
          <source>Or it can localize a typeglob and use the filehandle directly:</source>
          <target state="translated">Или он может локализовать печатный шрифт и использовать файловую ручку напрямую:</target>
        </trans-unit>
        <trans-unit id="ce435dd3f2375a45ae18754aa5933bf2c436dc74" translate="yes" xml:space="preserve">
          <source>Or just use &lt;code&gt;if&lt;/code&gt; .</source>
          <target state="translated">Или просто используйте &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="136d46bac172392fa4cdf46c2009daa41e71888d" translate="yes" xml:space="preserve">
          <source>Or like this:</source>
          <target state="translated">Или вот так:</target>
        </trans-unit>
        <trans-unit id="48f08d1241f74e59beb562174576b8f1d306023b" translate="yes" xml:space="preserve">
          <source>Or maybe we could use regular expressions:</source>
          <target state="translated">Или,может быть,мы могли бы использовать регулярные выражения:</target>
        </trans-unit>
        <trans-unit id="d3bba577160bb629ef905e44edb323af58458622" translate="yes" xml:space="preserve">
          <source>Or maybe you don't want to &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; at all! Maybe you could use a handler like this:</source>
          <target state="translated">А может, ты совсем не хочешь &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ! Возможно, вы могли бы использовать такой обработчик:</target>
        </trans-unit>
        <trans-unit id="eb07ce954d095bd48c2be1f0fcad35b67c72a58b" translate="yes" xml:space="preserve">
          <source>Or more succinctly:</source>
          <target state="translated">Или более лаконично:</target>
        </trans-unit>
        <trans-unit id="daea64cee75759eefcb8d884a9ad1d6ffab3b7eb" translate="yes" xml:space="preserve">
          <source>Or the modified Julian Day:</source>
          <target state="translated">Или модифицированный День Джулиана:</target>
        </trans-unit>
        <trans-unit id="37cd5be2ebf8ceaba65ad66ef7810a2d95ad6a73" translate="yes" xml:space="preserve">
          <source>Or to make an swrite() subroutine, which is to write() what sprintf() is to printf(), do this:</source>
          <target state="translated">Или сделать подпрограмму swrite(),которая должна написать(),что такое sprintf()для printf(),сделайте это:</target>
        </trans-unit>
        <trans-unit id="b578c02852dfedb0541b5bd3610b753c127ee1fb" translate="yes" xml:space="preserve">
          <source>Or to plan a variable number of tests:</source>
          <target state="translated">Или планировать переменное количество тестов:</target>
        </trans-unit>
        <trans-unit id="534e1e283610aa3e2f191a2196b648a7456ca580" translate="yes" xml:space="preserve">
          <source>Or use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; to try decoding it:</source>
          <target state="translated">Или используйте &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , чтобы попробовать его расшифровать:</target>
        </trans-unit>
        <trans-unit id="70d6fd7de2724ba9f6a39374a9f05288463f8ef9" translate="yes" xml:space="preserve">
          <source>Or use specific un-Unicode properties, like &lt;code&gt;\p{ahex}&lt;/code&gt; and &lt;code&gt;\p{POSIX_Digit&lt;/code&gt; }. Properties still work normally no matter what charset modifiers (&lt;code&gt;/d /u /l /a /aa&lt;/code&gt; ) should be effect.</source>
          <target state="translated">Или используйте определенные свойства не-Unicode, например &lt;code&gt;\p{ahex}&lt;/code&gt; и &lt;code&gt;\p{POSIX_Digit&lt;/code&gt; }. Свойства по-прежнему работают нормально, независимо от того, какие модификаторы кодировки ( &lt;code&gt;/d /u /l /a /aa&lt;/code&gt; ) должны действовать.</target>
        </trans-unit>
        <trans-unit id="d147ca7029faa376379ab60dd5e184279f392c55" translate="yes" xml:space="preserve">
          <source>Or use the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt;:</source>
          <target state="translated">Или используйте CPAN-модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3e3bc5aa2b1c65a2f0536a8ad61f1cf720e70bd7" translate="yes" xml:space="preserve">
          <source>Or use the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt;. Formatting files can be easily done by making a shell alias, like so:</source>
          <target state="translated">Или используйте CPAN-модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt; . Форматирование файлов можно легко выполнить, создав псевдоним оболочки, например:</target>
        </trans-unit>
        <trans-unit id="21cd44b0a63b2724e709817a957ed758ac294220" translate="yes" xml:space="preserve">
          <source>Or we can use the addfile method for more efficient reading of the file:</source>
          <target state="translated">Или мы можем использовать метод addfile для более эффективного чтения файла:</target>
        </trans-unit>
        <trans-unit id="7eb22b9341f8bed904b75d947077206dd520c369" translate="yes" xml:space="preserve">
          <source>Or we will publicly ridicule you. Seriously.</source>
          <target state="translated">Или мы публично высмеем тебя.Серьезно.</target>
        </trans-unit>
        <trans-unit id="2c4d7e281aa840be77762aa28882884e3b12c3e2" translate="yes" xml:space="preserve">
          <source>Or with a fixed amount of leading whitespace, with remaining indentation correctly preserved:</source>
          <target state="translated">Или с фиксированным количеством лидирующих белых пробелов,с сохранением оставшегося отступа правильно:</target>
        </trans-unit>
        <trans-unit id="9f8c04b29e5bdf5cb37189daec86558285ed03bf" translate="yes" xml:space="preserve">
          <source>Or with rationals:</source>
          <target state="translated">Или с рационами:</target>
        </trans-unit>
        <trans-unit id="ac4bf8a39abe6183f58cc853b82a958a3b19f773" translate="yes" xml:space="preserve">
          <source>Or write a small C program using the editor of champions:</source>
          <target state="translated">Или напишите небольшую программу на Си,используя редактор чемпионов:</target>
        </trans-unit>
        <trans-unit id="071de2b484157eae02726aef816948b89ceb81e6" translate="yes" xml:space="preserve">
          <source>Or write it yourself, iterating through the indices and checking the array element at each index until you find one that satisfies the condition:</source>
          <target state="translated">Или запишите его сами,проходя через индексы и проверяя элемент массива в каждом индексе до тех пор,пока не найдете тот,который удовлетворяет условию:</target>
        </trans-unit>
        <trans-unit id="fd30f1e33b918715dd71d5fd528fc3bfe2e3a2f3" translate="yes" xml:space="preserve">
          <source>Or write the &quot;bar&quot; method so you don't need to pass it the output from calling quux.</source>
          <target state="translated">Или напишите метод &quot;bar&quot;,чтобы вам не нужно было передавать ему выходные данные от вызова quux.</target>
        </trans-unit>
        <trans-unit id="1257832c1f8df8853297c11758dc7f82a58965f3" translate="yes" xml:space="preserve">
          <source>Or you can call these methods, which Pod::Simple::PullParser has defined to work just like Pod::Simple's same-named methods:</source>
          <target state="translated">Или вы можете вызвать эти методы,которые Pod::Simple::PullParser определил для работы так же,как и одноименные методы Pod::Simple:</target>
        </trans-unit>
        <trans-unit id="43deb0ef03dcaf9d7f9a23cfd26b6f349abc278d" translate="yes" xml:space="preserve">
          <source>Or you can give the name of a specific module:</source>
          <target state="translated">Или вы можете назвать имя конкретного модуля:</target>
        </trans-unit>
        <trans-unit id="44f4d760018e2beff2abc7deca32778f6b33edab" translate="yes" xml:space="preserve">
          <source>Or you can just use the &lt;a href=&quot;text/tabs&quot;&gt;Text::Tabs&lt;/a&gt; module (part of the standard Perl distribution).</source>
          <target state="translated">Или вы можете просто использовать модуль &lt;a href=&quot;text/tabs&quot;&gt;Text :: Tabs&lt;/a&gt; (часть стандартного дистрибутива Perl).</target>
        </trans-unit>
        <trans-unit id="3f560caefa4961932943871223d7a55e15210337" translate="yes" xml:space="preserve">
          <source>Or you can link to a web page:</source>
          <target state="translated">Или вы можете перейти по ссылке на веб-страницу:</target>
        </trans-unit>
        <trans-unit id="35426ac710dfda840e59a05cb7cce1999af24289" translate="yes" xml:space="preserve">
          <source>Or you can read the entire file contents into a scalar like this:</source>
          <target state="translated">Или вы можете прочитать все содержимое файла в скаляр,подобный этому:</target>
        </trans-unit>
        <trans-unit id="7ca35881b01bed9e83e28982a2d8d72c5c6104a0" translate="yes" xml:space="preserve">
          <source>Or you can try casting to a &quot;wide enough&quot; type:</source>
          <target state="translated">Или вы можете попробовать кастинг на &quot;достаточно широкий&quot; тип:</target>
        </trans-unit>
        <trans-unit id="043cc73307c25fd12afc139edc01af1987c07753" translate="yes" xml:space="preserve">
          <source>Or you can use</source>
          <target state="translated">Или вы можете использовать</target>
        </trans-unit>
        <trans-unit id="6eacf94ec3c91a6fb8f957244c216f33f4c57d92" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt;, though it is less convenient in the general case:</source>
          <target state="translated">Или вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; , хотя в общем случае это менее удобно:</target>
        </trans-unit>
        <trans-unit id="931b91df8b44901925eb12d70d322446a86049fc" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;code&gt;add_suspects&lt;/code&gt; method. The difference is that &lt;code&gt;set_suspects&lt;/code&gt; flushes the current suspects list while &lt;code&gt;add_suspects&lt;/code&gt; adds.</source>
          <target state="translated">Или вы можете использовать метод &lt;code&gt;add_suspects&lt;/code&gt; . Разница в том, что &lt;code&gt;set_suspects&lt;/code&gt; очищает текущий список подозреваемых, а &lt;code&gt;add_suspects&lt;/code&gt; добавляет.</target>
        </trans-unit>
        <trans-unit id="a39a91a0d1d979c65ad41157a37488c0834225c4" translate="yes" xml:space="preserve">
          <source>Or you could check out the &lt;a href=&quot;http://search.cpan.org/perldoc/String::Scanf&quot;&gt;String::Scanf&lt;/a&gt; module on the CPAN instead.</source>
          <target state="translated">Или вместо этого вы можете проверить модуль &lt;a href=&quot;http://search.cpan.org/perldoc/String::Scanf&quot;&gt;String :: Scanf&lt;/a&gt; на CPAN.</target>
        </trans-unit>
        <trans-unit id="5093d94168468d0b2a02ecd19e89cf6d81de9b6e" translate="yes" xml:space="preserve">
          <source>Or you could use this module, like this:</source>
          <target state="translated">Или вы можете использовать этот модуль,вот так:</target>
        </trans-unit>
        <trans-unit id="d54e1a4de96da66b4f1be3ddd384e9dc12182b2a" translate="yes" xml:space="preserve">
          <source>Or you may want to override it with something that traps any exceptions, if that's critical to your program:</source>
          <target state="translated">Или вы можете захотеть переопределить его с помощью чего-то,что поймает в ловушку любые исключения,если это важно для вашей программы:</target>
        </trans-unit>
        <trans-unit id="2bc5eff73e9b5c554f3a2ea69d7a2e4db2c90148" translate="yes" xml:space="preserve">
          <source>Or you might have had a temporary variable sitting around with the array in it.</source>
          <target state="translated">Или у вас могла быть временная переменная,сидящая с массивом в нем.</target>
        </trans-unit>
        <trans-unit id="778e7ba107050bb841c6a420e4c310f8b170e2db" translate="yes" xml:space="preserve">
          <source>Or, as a third option you can choose RAND which will make a random decision (something regular CPAN testers will enjoy).</source>
          <target state="translated">Или,в качестве третьего варианта,Вы можете выбрать RAND,который будет принимать случайное решение (что-нибудь,что понравится обычным CPAN тестировщикам).</target>
        </trans-unit>
        <trans-unit id="67fb52d7219a77edeaa3410be898dbaaf5eb7940" translate="yes" xml:space="preserve">
          <source>Or, going the other way:</source>
          <target state="translated">Или в другую сторону:</target>
        </trans-unit>
        <trans-unit id="c9cbc117e700c42b5960566f9d6e3ab9956f8e0e" translate="yes" xml:space="preserve">
          <source>Or, if you want to alter the value, you can even do things like this:</source>
          <target state="translated">Или,если вы хотите изменить значение,вы даже можете сделать такие вещи:</target>
        </trans-unit>
        <trans-unit id="bbaa299505c09af1ba1a690349c0d5013974e787" translate="yes" xml:space="preserve">
          <source>Or, if you want to use SHA-256 instead of the default SHA-1, simply say:</source>
          <target state="translated">Или,если вы хотите использовать SHA-256 вместо SHA-1 по умолчанию,просто скажите:</target>
        </trans-unit>
        <trans-unit id="43c22f6d092ff91e39fcd2c49c563a09384d2c27" translate="yes" xml:space="preserve">
          <source>Or, if you're fond of VMS command syntax:</source>
          <target state="translated">Или,если вам нравится синтаксис команд VMS:</target>
        </trans-unit>
        <trans-unit id="8f53b2f39475162ce9507ab6d3bc142ec9ebf18d" translate="yes" xml:space="preserve">
          <source>Or, if you're lazy, just:</source>
          <target state="translated">Или,если тебе лень,просто..:</target>
        </trans-unit>
        <trans-unit id="2e075c729b27aef299f95b8f9b89c3205825fc03" translate="yes" xml:space="preserve">
          <source>Or, if you're using a recent release of Perl, you can just use the Symbol::delete_package() function instead.</source>
          <target state="translated">Или,если вы используете недавний выпуск Perl,вы можете просто использовать вместо него функцию Symbol::delete_package().</target>
        </trans-unit>
        <trans-unit id="9ef47775ad6e32b75e39e1b8250e2051eeafc265" translate="yes" xml:space="preserve">
          <source>Or, in order to retain the UTF-x code points in hexadecimal:</source>
          <target state="translated">Или,чтобы сохранить пункты кода UTF-x в шестнадцатеричной системе:</target>
        </trans-unit>
        <trans-unit id="9ac1d61fe8e0e045309c1cd8c9bfbba7d77d8c46" translate="yes" xml:space="preserve">
          <source>Or, just use the fdopen(3S) feature of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Или просто используйте функцию fdopen (3S) в &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b65db10b884b8811cab09d1c35d73c9549dd89e0" translate="yes" xml:space="preserve">
          <source>Or, simply:</source>
          <target state="translated">Или просто:</target>
        </trans-unit>
        <trans-unit id="4509b32489cef8d9fa76782913fc02beac5d2e00" translate="yes" xml:space="preserve">
          <source>Or, you can combine this step with the next to save disk space:</source>
          <target state="translated">Или вы можете совместить этот шаг со следующим,чтобы сэкономить место на диске:</target>
        </trans-unit>
        <trans-unit id="a70a9c965ff5f01a36539ad3a4f1747814f861b5" translate="yes" xml:space="preserve">
          <source>Or, you can use a closure to bundle up the object, its method call, and arguments:</source>
          <target state="translated">Или,вы можете использовать закрытие для объединения объекта,его вызова методов и аргументов:</target>
        </trans-unit>
        <trans-unit id="8e30f14ff059f10f588d2a56e4ed3edbafad53cb" translate="yes" xml:space="preserve">
          <source>Or, you can use the &lt;code&gt;new&lt;/code&gt; method from one of the IO::* modules to create an anonymous filehandle and store that in a scalar variable.</source>
          <target state="translated">Или вы можете использовать &lt;code&gt;new&lt;/code&gt; метод из одного из модулей IO :: *, чтобы создать анонимный дескриптор файла и сохранить его в скалярной переменной.</target>
        </trans-unit>
        <trans-unit id="af6226005e40b70717bca3873f6972ffe8233b17" translate="yes" xml:space="preserve">
          <source>Or, you might want to only process some of the items. If you only want to deal with the keys that start with &lt;code&gt;text:&lt;/code&gt; , you can select just those using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Или вы можете захотеть обработать только некоторые элементы. Если вы хотите иметь дело только с клавишами, которые начинаются с &lt;code&gt;text:&lt;/code&gt; , вы можете выбрать только те, которые используют &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40119221cab56480c05aa14722b443b3fea26189" translate="yes" xml:space="preserve">
          <source>Or...</source>
          <target state="translated">Or...</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="ed006a3a71954db6f888573fde1410910ac75da8" translate="yes" xml:space="preserve">
          <source>Oracle on HP-UX</source>
          <target state="translated">Оракул на HP-UX</target>
        </trans-unit>
        <trans-unit id="d62b80826f613ec1202935a4c2f641139f04ab27" translate="yes" xml:space="preserve">
          <source>Order of initialization: early load()</source>
          <target state="translated">Порядок инициализации:ранняя загрузка()</target>
        </trans-unit>
        <trans-unit id="7393d644018f3205b57f7e4d05fa28a3cb608a27" translate="yes" xml:space="preserve">
          <source>Ordering is important in all these examples. That's because the shell processes file descriptor redirections in strictly left to right order.</source>
          <target state="translated">Заказ важен во всех этих примерах.Это связано с тем,что оболочка обрабатывает перенаправления дескрипторов файлов в строгом порядке слева направо.</target>
        </trans-unit>
        <trans-unit id="184a2b9a0782971148728db5cbfcd9146f0d9d22" translate="yes" xml:space="preserve">
          <source>Ordering of two matches for &lt;code&gt;S&lt;/code&gt; is the same as for &lt;code&gt;S&lt;/code&gt; . Similar for two matches for &lt;code&gt;T&lt;/code&gt; .</source>
          <target state="translated">Заказ двух матчей для &lt;code&gt;S&lt;/code&gt; такое же , как и для &lt;code&gt;S&lt;/code&gt; . Аналогично для двух матчей для &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f2e5db8ac8798852d4979873043eb23e9daf36e" translate="yes" xml:space="preserve">
          <source>Ordinarily you must assign the returned value to a variable, but there is one situation where an automatic assignment happens. If and only if the input symbol is the only thing inside the conditional of a &lt;code&gt;while&lt;/code&gt; statement (even if disguised as a &lt;code&gt;for(;;)&lt;/code&gt; loop), the value is automatically assigned to the global variable &lt;code&gt;$_&lt;/code&gt; , destroying whatever was there previously. (This may seem like an odd thing to you, but you'll use the construct in almost every Perl script you write.) The &lt;code&gt;$_&lt;/code&gt; variable is not implicitly localized. You'll have to put a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $_;&lt;/code&gt; before the loop if you want that to happen.</source>
          <target state="translated">Обычно вы должны присвоить возвращаемое значение переменной, но есть одна ситуация, когда происходит автоматическое присвоение. Если и только если входной символ - единственное, что находится внутри условного оператора &lt;code&gt;while&lt;/code&gt; (даже если он замаскирован под цикл &lt;code&gt;for(;;)&lt;/code&gt; ), значение автоматически присваивается глобальной переменной &lt;code&gt;$_&lt;/code&gt; , уничтожая все, что было там ранее. (Это может показаться вам странным, но вы будете использовать эту конструкцию почти в каждом написанном вами Perl-скрипте.) Переменная &lt;code&gt;$_&lt;/code&gt; не локализуется неявно. Вам нужно будет поместить &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $_;&lt;/code&gt; перед циклом, если вы хотите, чтобы это произошло.</target>
        </trans-unit>
        <trans-unit id="53258e41460718a5a3f67ea0dcecd0cea963c78d" translate="yes" xml:space="preserve">
          <source>Ordinarily, if you use B::Deparse on a subroutine which has been compiled in the presence of one or more of these pragmas, the output will include statements to turn on the appropriate directives. So if you then compile the code returned by coderef2text, it will behave the same way as the subroutine which you deparsed.</source>
          <target state="translated">Обычно,если вы используете B::Deparse в подпрограмме,которая была составлена в присутствии одной или нескольких из этих прагм,на выходе будут содержаться утверждения для включения соответствующих директив.Таким образом,если Вы затем скомпилируете код,возвращаемый с помощью coderef2text,он будет вести себя так же,как и подпрограмма,которую Вы отбросили.</target>
        </trans-unit>
        <trans-unit id="9eb59a093d68b441c9e588f45e1136962cd97df2" translate="yes" xml:space="preserve">
          <source>Ordinary Paragraph</source>
          <target state="translated">Обычный абзац</target>
        </trans-unit>
        <trans-unit id="852794a0888b2c26ae66b7390c3dc7aa906b25ab" translate="yes" xml:space="preserve">
          <source>Ordinary scalars are added to queues as they are.</source>
          <target state="translated">Обычные скаляры добавляются в очереди как есть.</target>
        </trans-unit>
        <trans-unit id="e643b2f1d6d20cd4b1a9b180a96d9d74142343a5" translate="yes" xml:space="preserve">
          <source>Organization of Perl Images</source>
          <target state="translated">Организация Perl изображений</target>
        </trans-unit>
        <trans-unit id="b7ac1ae7a629fb1e4790255da63efabc71780dd7" translate="yes" xml:space="preserve">
          <source>Original author Charles Bailey</source>
          <target state="translated">Оригинальный автор Чарльз Бейли</target>
        </trans-unit>
        <trans-unit id="6bb735e6ea9df22ee5b2de902784152d534e32cf" translate="yes" xml:space="preserve">
          <source>Original author lost in the mists of time. Probably the same as Makemaker.</source>
          <target state="translated">Оригинальный автор затерялся в тумане времени.Наверное,тот же самый,что и Макейкер.</target>
        </trans-unit>
        <trans-unit id="8478bfad57c6e4bf8f9631f29cfcd8913f5e1f7b" translate="yes" xml:space="preserve">
          <source>Original author: Jos Boumans &amp;lt;kane@cpan.org&amp;gt;. Current maintainer: Chris Williams &amp;lt;bingos@cpan.org&amp;gt;.</source>
          <target state="translated">Оригинальный автор: Джос Буманс &amp;lt;kane@cpan.org&amp;gt;. Текущий сопровождающий: Крис Уильямс &amp;lt;bingos@cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="82456b1a006fa0cfc6f13442efd03f45359b0924" translate="yes" xml:space="preserve">
          <source>Original code by Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; in late 2000, 2001 - 2006 and still at it in 2007.</source>
          <target state="translated">Оригинальный код Марка Биггара, перегруженный интерфейс Ильи Захаревича. Полностью переписан Tels &lt;a href=&quot;http://bloodgate.com&quot;&gt;http://bloodgate.com&lt;/a&gt; в конце 2000, 2001 - 2006 гг. И все еще работает в 2007 г.</target>
        </trans-unit>
        <trans-unit id="4907c478063f242cdad148d2cf2e2a3834c957e0" translate="yes" xml:space="preserve">
          <source>Original code by chromatic, maintained by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;</source>
          <target state="translated">Исходный код с помощью хроматики, поддерживается Майклом Г. Шверном &amp;lt;schwern@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5aa8fbf538dffef8e3de83026f7b50c6ec7e3e15" translate="yes" xml:space="preserve">
          <source>Original idea (using constants) by Zenin, reimplemented using subs by Russ Allbery &amp;lt;rra@cpan.org&amp;gt;, and then combined with the original idea by Russ with input from Zenin. 256-color support is based on work by Kurt Starsinic. Russ Allbery now maintains this module.</source>
          <target state="translated">Первоначальная идея (с использованием констант) Зенина, переосмысленная с использованием субтитров Рассом Олбери &amp;lt;rra@cpan.org&amp;gt;, а затем объединенная с оригинальной идеей Расса при участии Зенина. Поддержка 256 цветов основана на работе Курта Старсиника. Расс Олбери сейчас поддерживает этот модуль.</target>
        </trans-unit>
        <trans-unit id="531407d264d0d11235657451697ac677d9049ca2" translate="yes" xml:space="preserve">
          <source>Original math code by Mark Biggar, rewritten by Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; in late 2000.</source>
          <target state="translated">Оригинальный математический код Марка Биггара, переписанный Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; в конце 2000 года.</target>
        </trans-unit>
        <trans-unit id="de9fcab0737543137eaab2a0e06f6bd2ca79a9cc" translate="yes" xml:space="preserve">
          <source>Original math code by Mark Biggar, rewritten by Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; in late 2000. Separated from BigInt and shaped API with the help of John Peacock.</source>
          <target state="translated">Оригинальный математический код Марка Биггара, переписанный Tels &lt;a href=&quot;http://bloodgate.com/&quot;&gt;http://bloodgate.com/&lt;/a&gt; в конце 2000 года. Отделен от BigInt и сформирован API с помощью Джона Пикока.</target>
        </trans-unit>
        <trans-unit id="016eb101d0bd431b0d9ab4229772d8f00ba5eae2" translate="yes" xml:space="preserve">
          <source>Original module by Lionel Cons (CERN).</source>
          <target state="translated">Оригинальный модуль от Lionel Cons (CERN).</target>
        </trans-unit>
        <trans-unit id="a9ec70668a9cf8a9b6348458c85a3f762057ac0f" translate="yes" xml:space="preserve">
          <source>Original version by Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">Оригинальная версия Тома Кристиансена, &amp;lt;tchrist@perl.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="93bd0bc0b9a9e635b79e9c5f125cb705f4a31e8d" translate="yes" xml:space="preserve">
          <source>Originally &lt;code&gt;Class::Template&lt;/code&gt; by Dean Roehrich.</source>
          <target state="translated">Первоначально &lt;code&gt;Class::Template&lt;/code&gt; авторства Дина Рорича.</target>
        </trans-unit>
        <trans-unit id="98ac195b142c467725515fdf5766071e9fc6f61f" translate="yes" xml:space="preserve">
          <source>Originally began life in May 1999 as an XS interface to the system mkstemp() function. In March 2000, the OpenBSD mkstemp() code was translated to Perl for total control of the code's security checking, to ensure the presence of the function regardless of operating system and to help with portability. The module was shipped as a standard part of perl from v5.6.1.</source>
          <target state="translated">Первоначально начал свою жизнь в мае 1999 года как XS-интерфейс к системной функции mkstemp().В марте 2000 года код mkstemp()в OpenBSD был транслирован на Perl для полного контроля проверки кода на безопасность,для обеспечения наличия функции вне зависимости от операционной системы и для помощи с переносимостью.Модуль был отгружен в виде стандартной части на Perl из версии 5.6.1.</target>
        </trans-unit>
        <trans-unit id="05d3b834a8e1ec7b7d1784cd966acd56262bc822" translate="yes" xml:space="preserve">
          <source>Originally by Larry Wall. Turned into the &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; module by Ken Williams.</source>
          <target state="translated">Первоначально Ларри Уолл. Превратил в модуль &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; Кен Вильямс.</target>
        </trans-unit>
        <trans-unit id="78ba94984c09fe40c7fb0012a48157ae37638a1c" translate="yes" xml:space="preserve">
          <source>Originally by the perl5-porters.</source>
          <target state="translated">Первоначально perl5-портеры.</target>
        </trans-unit>
        <trans-unit id="0a58abf22ae0f33a5d3fa45db34e7ceb2370f30b" translate="yes" xml:space="preserve">
          <source>Originally designed and implemented by Malcolm Beattie, mbeattie@sable.ox.ac.uk as part of Safe version 1.</source>
          <target state="translated">Первоначально разработано и реализовано Малкольмом Битти (Malcolm Beattie),mbeattie@sable.ox.ac.uk в рамках Safe версии 1.</target>
        </trans-unit>
        <trans-unit id="c8441bf717fcfb993e717e28d6000796e14219bc" translate="yes" xml:space="preserve">
          <source>Originally designed and implemented by Malcolm Beattie.</source>
          <target state="translated">Первоначально спроектирован и реализован Малкольмом Битти.</target>
        </trans-unit>
        <trans-unit id="b5b9ddd002b9e83e3e5ffe5e5b5e1758fac1d1ee" translate="yes" xml:space="preserve">
          <source>Originally from the old Unix editor command for &amp;ldquo;Globally search for a Regular Expression and Print it&amp;rdquo;, now used in the general sense of any kind of search, especially text searches. Perl has a built-in &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; function that searches a list for elements matching any given criterion, whereas the &lt;b&gt;grep&lt;/b&gt;(1) program searches for lines matching a &lt;b&gt;regular expression&lt;/b&gt; in one or more files.</source>
          <target state="translated">Первоначально из старой команды редактора Unix для &amp;laquo;Глобального поиска регулярного выражения и печати его&amp;raquo;, теперь используется в общем смысле любого вида поиска, особенно текстового поиска. Perl имеет встроенную функцию &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; , которая ищет в списке элементы, соответствующие любому заданному критерию, тогда как программа &lt;b&gt;grep&lt;/b&gt; (1) ищет строки, соответствующие &lt;b&gt;регулярному выражению,&lt;/b&gt; в одном или нескольких файлах.</target>
        </trans-unit>
        <trans-unit id="179faca61deeed3ab0f554d9e5a2deeffd88d631" translate="yes" xml:space="preserve">
          <source>Originally part of &lt;a href=&quot;perlreguts&quot;&gt;perlreguts&lt;/a&gt;.</source>
          <target state="translated">Первоначально входил в состав &lt;a href=&quot;perlreguts&quot;&gt;перлрегутс&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f99926744d51a0882b56c8605cf23549f21bb7f7" translate="yes" xml:space="preserve">
          <source>Originally ripped off from &lt;a href=&quot;../../../test/harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">Первоначально скопировано с &lt;a href=&quot;../../../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71cbfb5529d2f3e7043bc6450156ba2700321efe" translate="yes" xml:space="preserve">
          <source>Originally ripped off from &lt;a href=&quot;../../test/harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">Первоначально скопировано с &lt;a href=&quot;../../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10558d1a36f98366d4aafd194d52755ed064b37d" translate="yes" xml:space="preserve">
          <source>Originally written by Dean Roehrich &amp;lt;</source>
          <target state="translated">Первоначально написано Дином Роричем &amp;lt;</target>
        </trans-unit>
        <trans-unit id="40fdd20b1b0722f4c9f525e21df0d8f46d7d85b2" translate="yes" xml:space="preserve">
          <source>Originally written by Yves Orton, expanded by &amp;AElig;var Arnfj&amp;ouml;r&amp;eth; Bjarmason.</source>
          <target state="translated">Первоначально написано Ивом Ортоном, дополнено var Arnfj&amp;ouml;r Bjarmason.</target>
        </trans-unit>
        <trans-unit id="f0958a863745f7bb7b877718e9ffc0407e157bdf" translate="yes" xml:space="preserve">
          <source>Ossanna, Joseph F., and Brian W. Kernighan. &quot;Troff User's Manual,&quot; Computing Science Technical Report No. 54, AT&amp;amp;T Bell Laboratories. This is the best documentation of standard &lt;b&gt;nroff&lt;/b&gt; and &lt;b&gt;troff&lt;/b&gt;. At the time of this writing, it's available at &lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/cstr.html&quot;&gt;http://www.cs.bell-labs.com/cm/cs/cstr.html&lt;/a&gt;.</source>
          <target state="translated">Оссанна, Джозеф Ф. и Брайан В. Керниган. &amp;laquo;Руководство пользователя Troff&amp;raquo;, Технический отчет по информатике № 54, AT&amp;amp;T Bell Laboratories. Это лучшая документация по стандартным &lt;b&gt;nroff&lt;/b&gt; и &lt;b&gt;troff&lt;/b&gt; . На момент написания этой статьи он доступен по адресу &lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/cstr.html&quot;&gt;http://www.cs.bell-labs.com/cm/cs/cstr.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4209bd1da7b6357d7fd219e08de4663ac8c8de52" translate="yes" xml:space="preserve">
          <source>Other C compilers (yes, there &lt;b&gt;are&lt;/b&gt; other C compilers than gcc) often have their &quot;strict ANSI&quot; or &quot;strict ANSI with some portability extensions&quot; modes on, like for example the Sun Workshop has its &lt;code&gt;-Xa&lt;/code&gt; mode on (though implicitly), or the DEC (these days, HP...) has its &lt;code&gt;-std1&lt;/code&gt; mode on.</source>
          <target state="translated">Другие компиляторы C (да, есть &lt;b&gt;и&lt;/b&gt; другие компиляторы C, кроме gcc) часто имеют свои режимы &amp;laquo;строгий ANSI&amp;raquo; или &amp;laquo;строгий ANSI с некоторыми расширениями переносимости&amp;raquo;, например, в Sun Workshop &lt;code&gt;-Xa&lt;/code&gt; режим -Xa (хотя и неявно), или DEC (в наши дни HP ...) имеет режим &lt;code&gt;-std1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="551852c7028ddd04d28686d5a46f202fe2ad7cb7" translate="yes" xml:space="preserve">
          <source>Other Functions</source>
          <target state="translated">Другие функции</target>
        </trans-unit>
        <trans-unit id="0bdf87a4ace9eb276a876bd8e9250301437be6c5" translate="yes" xml:space="preserve">
          <source>Other Handy Functions</source>
          <target state="translated">Другие удобные функции</target>
        </trans-unit>
        <trans-unit id="0ae890b35ce85bf30d57cf160315165f538a27b8" translate="yes" xml:space="preserve">
          <source>Other JRRT books fair game for quotes would thus include</source>
          <target state="translated">Другие книги JRRT справедливая игра для котировок будет,таким образом,включать в себя</target>
        </trans-unit>
        <trans-unit id="dfc61fffa8906502d8a54b080f23a45b3b6a145a" translate="yes" xml:space="preserve">
          <source>Other Methods</source>
          <target state="translated">Другие методы</target>
        </trans-unit>
        <trans-unit id="9165ac20a0a94eccf10c1024b71472d0032177d7" translate="yes" xml:space="preserve">
          <source>Other OO Systems</source>
          <target state="translated">Другие системы ООО</target>
        </trans-unit>
        <trans-unit id="92b14232c00517718a7c45a7ecde335eb02684ba" translate="yes" xml:space="preserve">
          <source>Other OSes</source>
          <target state="translated">Другие операционные системы</target>
        </trans-unit>
        <trans-unit id="ebafbcc27b9633bf022834dac0afdd7fe5320b31" translate="yes" xml:space="preserve">
          <source>Other References</source>
          <target state="translated">Другие ссылки</target>
        </trans-unit>
        <trans-unit id="fa1430ad78734f8ef31e36e90d4f36de9f13a735" translate="yes" xml:space="preserve">
          <source>Other Testing Methods</source>
          <target state="translated">Другие методы тестирования</target>
        </trans-unit>
        <trans-unit id="f0e56c564684ea4c937565ef815405ac4aa82ff1" translate="yes" xml:space="preserve">
          <source>Other available flags are:</source>
          <target state="translated">Другие доступные флаги:</target>
        </trans-unit>
        <trans-unit id="a9a6815e54ae300be1f551c6019a20062ec0f880" translate="yes" xml:space="preserve">
          <source>Other categories</source>
          <target state="translated">Другие категории</target>
        </trans-unit>
        <trans-unit id="fa31529000a27db1a7fada94ddb4d6caa2048ed7" translate="yes" xml:space="preserve">
          <source>Other characters that can't appear in Perl identifiers are also supported as aliases with Getopt::Long of at least version 2.39.</source>
          <target state="translated">Другие символы,которые не могут появляться в Perl-идентификаторах,также поддерживаются в качестве псевдонимов с Getopt::Long как минимум версии 2.39.</target>
        </trans-unit>
        <trans-unit id="6be322bc8ea0db1e8be06d4ec43ad756a099bfb6" translate="yes" xml:space="preserve">
          <source>Other data worth storing in a lexicon might be things like filenames for language-targetted resources:</source>
          <target state="translated">Другими данными,которые стоит хранить в лексиконе,могут быть такие вещи,как имена файлов для языковых ресурсов:</target>
        </trans-unit>
        <trans-unit id="36fefa00642398c0b54d66e1ab2941d7ce0381ab" translate="yes" xml:space="preserve">
          <source>Other environment variables that may influence tests</source>
          <target state="translated">Другие переменные среды,которые могут влиять на тесты</target>
        </trans-unit>
        <trans-unit id="293561c7c0c8a1abe2aec3c1c2e6ea87fd9c52f7" translate="yes" xml:space="preserve">
          <source>Other examples include</source>
          <target state="translated">Другие примеры включают в себя</target>
        </trans-unit>
        <trans-unit id="050e92356c2ad433980e335b3cd1c37de82b2130" translate="yes" xml:space="preserve">
          <source>Other examples include (using standard shell syntax to show environment variable settings):</source>
          <target state="translated">Другие примеры включают в себя (использование стандартного синтаксиса оболочки для отображения настроек переменных окружения):</target>
        </trans-unit>
        <trans-unit id="0890da9a3fe9000b110723faeb22296dde791fee" translate="yes" xml:space="preserve">
          <source>Other examples include:</source>
          <target state="translated">Другие примеры включают в себя:</target>
        </trans-unit>
        <trans-unit id="9b4e9be46864e281795d5dbc03712be976c67f55" translate="yes" xml:space="preserve">
          <source>Other information in the Unicode data base</source>
          <target state="translated">Прочая информация в базе данных Юникода</target>
        </trans-unit>
        <trans-unit id="be5464268eb0652d20727c597b5d478658d7e34b" translate="yes" xml:space="preserve">
          <source>Other interesting targets in the generated Makefile are</source>
          <target state="translated">Другими интересными целями в сгенерированном Makefile являются</target>
        </trans-unit>
        <trans-unit id="4995af619bf2d3ae8de0384100aa88eb416db8e0" translate="yes" xml:space="preserve">
          <source>Other interesting, non-Perl books</source>
          <target state="translated">Другие интересные,не-перловские книги</target>
        </trans-unit>
        <trans-unit id="a0a7f74c7a5b001c1898061e6c8bbb41c2b8f981" translate="yes" xml:space="preserve">
          <source>Other larger &lt;code&gt;regnode&lt;/code&gt; -like structures are defined in</source>
          <target state="translated">Другие более &lt;code&gt;regnode&lt;/code&gt; структуры, подобные regnode , определены в</target>
        </trans-unit>
        <trans-unit id="54a8c70b7563cbb778a36bb5bcccfde96170f9d6" translate="yes" xml:space="preserve">
          <source>Other man pages to check out, like man(1), man(7), makewhatis(8), or catman(8). Normally a simple list of man pages separated by commas, or a paragraph giving the name of a reference work. Man page references, if they use the standard &lt;code&gt;name(section)&lt;/code&gt; form, don't have to be enclosed in L&amp;lt;&amp;gt; (although it's recommended), but other things in this section probably should be when appropriate.</source>
          <target state="translated">Другие страницы руководства, например man (1), man (7), makewhatis (8) или catman (8). Обычно это простой список страниц руководства, разделенных запятыми, или абзац с названием справочной работы. Ссылки на страницы руководства, если они используют стандартную форму &lt;code&gt;name(section)&lt;/code&gt; , не должны быть заключены в L &amp;lt;&amp;gt; (хотя это рекомендуется), но другие элементы в этом разделе, вероятно, должны быть при необходимости.</target>
        </trans-unit>
        <trans-unit id="2a0be4d7126d12c4393a8f81b69236cf7f3adb37" translate="yes" xml:space="preserve">
          <source>Other methods defined in Encode::Encodings</source>
          <target state="translated">Другие методы,определенные в кодировке::Кодирование</target>
        </trans-unit>
        <trans-unit id="8b02b29f176b90b35adf0979292f2a1a362170a1" translate="yes" xml:space="preserve">
          <source>Other module design guidelines can be found in &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">Другие рекомендации по проектированию модулей можно найти в &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee6b0460067623519cc565a472bd480c100039cf" translate="yes" xml:space="preserve">
          <source>Other modules</source>
          <target state="translated">Другие модули</target>
        </trans-unit>
        <trans-unit id="35b38a9ced9a9e6defe1372beb74c2a71438500f" translate="yes" xml:space="preserve">
          <source>Other modules provide more specific access: &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::ODBC&quot;&gt;Win32::ODBC&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Alzabo&quot;&gt;Alzabo&lt;/a&gt;, &lt;code&gt;iodbc&lt;/code&gt; , and others found on CPAN Search: &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</source>
          <target state="translated">Другие модули обеспечивают более конкретный доступ: &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::ODBC&quot;&gt;Win32 :: ODBC&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Alzabo&quot;&gt;Alzabo&lt;/a&gt; , &lt;code&gt;iodbc&lt;/code&gt; и другие, найденные в поиске CPAN: &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d291165f3e48fa04de2df661e5577d3237e36a86" translate="yes" xml:space="preserve">
          <source>Other options</source>
          <target state="translated">Другие варианты</target>
        </trans-unit>
        <trans-unit id="014edefbdeb134528c300bbe292e9dea3d3171e2" translate="yes" xml:space="preserve">
          <source>Other people picked up on this and started to write clever or obfuscated programs to produce the same output, spinning things quickly out of control while still providing hours of amusement for their creators and readers.</source>
          <target state="translated">Другие люди подхватили это и начали писать умные или замысловатые программы для получения того же результата,быстро выводя вещи из-под контроля,в то же время предоставляя часы развлечений для своих создателей и читателей.</target>
        </trans-unit>
        <trans-unit id="b2c45e1355cf0a47d9a693c24c0422d1a1693c9c" translate="yes" xml:space="preserve">
          <source>Other perls</source>
          <target state="translated">Другие преимущества</target>
        </trans-unit>
        <trans-unit id="2d78880c37d6825d2ae3118f278c3357f9e4c7a8" translate="yes" xml:space="preserve">
          <source>Other places to ask questions are on the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org%2f&quot;&gt;PerlMonks site&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstackoverflow.com%2fquestions%2ftagged%2fperl&quot;&gt;stackoverflow&lt;/a&gt;.</source>
          <target state="translated">Другие места, где можно задать вопросы, находятся на сайте &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org%2f&quot;&gt;PerlMonks&lt;/a&gt; или на &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fstackoverflow.com%2fquestions%2ftagged%2fperl&quot;&gt;stackoverflow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94bfe5471f8f9572c8f23295ec358290aa5c0ef5" translate="yes" xml:space="preserve">
          <source>Other prebuilt perl binaries</source>
          <target state="translated">Другие готовые бинарные файлы perl</target>
        </trans-unit>
        <trans-unit id="e084077b7075b7e9a73a17897df829f14ab4b896" translate="yes" xml:space="preserve">
          <source>Other return codes are defined. See below and in the Berkeley DB documentation for details. The Berkeley DB documentation should be used as the definitive source.</source>
          <target state="translated">Определены другие коды возврата.Подробности см.ниже и в документации БД Беркли.В качестве окончательного источника следует использовать документацию БД Беркли.</target>
        </trans-unit>
        <trans-unit id="b333dbc669f480c73b5b58df634b402ae239a596" translate="yes" xml:space="preserve">
          <source>Other than &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, this module upgrades to Math::BigRat, meaning that instead of 2.5 you will get 2+1/2 as output.</source>
          <target state="translated">Помимо &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; , этот модуль обновляется до Math :: BigRat, что означает, что вместо 2.5 вы получите на выходе 2 + 1/2.</target>
        </trans-unit>
        <trans-unit id="eb36362d59c4594cc709a7ea4be2c2f79bf0b417" translate="yes" xml:space="preserve">
          <source>Other than those two situations, I don't imagine that it's useful to override the &lt;code&gt;maketext&lt;/code&gt; method. (If you run into a situation where it is useful, I'd be interested in hearing about it.)</source>
          <target state="translated">Помимо этих двух ситуаций, я не думаю, что полезно переопределять метод &lt;code&gt;maketext&lt;/code&gt; . (Если вы столкнетесь с ситуацией, когда это будет полезно, мне было бы интересно узнать об этом.)</target>
        </trans-unit>
        <trans-unit id="3a5b57060690dc31c3058289c6a303662394ee99" translate="yes" xml:space="preserve">
          <source>Other useful functions are &lt;code&gt;Perl_dump_sub&lt;/code&gt; , which turns a &lt;code&gt;GV&lt;/code&gt; into an op tree, &lt;code&gt;Perl_dump_packsubs&lt;/code&gt; which calls &lt;code&gt;Perl_dump_sub&lt;/code&gt; on all the subroutines in a package like so: (Thankfully, these are all xsubs, so there is no op tree)</source>
          <target state="translated">Другие полезные функции: &lt;code&gt;Perl_dump_sub&lt;/code&gt; , который превращает &lt;code&gt;GV&lt;/code&gt; в дерево &lt;code&gt;Perl_dump_packsubs&lt;/code&gt; , Perl_dump_packsubs, который вызывает &lt;code&gt;Perl_dump_sub&lt;/code&gt; для всех подпрограмм в пакете, например: (К счастью, это все xsub, поэтому дерева операций нет)</target>
        </trans-unit>
        <trans-unit id="7aec5a2099bba9d9c155d5ff98c8d088a4d87e95" translate="yes" xml:space="preserve">
          <source>Other useful sources include the Unicode Glossary &lt;a href=&quot;http://unicode.org/glossary/&quot;&gt;http://unicode.org/glossary/&lt;/a&gt;, the Free On-Line Dictionary of Computing &lt;a href=&quot;http://foldoc.org/&quot;&gt;http://foldoc.org/&lt;/a&gt;, the Jargon File &lt;a href=&quot;http://catb.org/~esr/jargon/&quot;&gt;http://catb.org/~esr/jargon/&lt;/a&gt;, and Wikipedia &lt;a href=&quot;http://www.wikipedia.org/&quot;&gt;http://www.wikipedia.org/&lt;/a&gt;.</source>
          <target state="translated">Другие полезные источники включают в себя Глоссарий Unicode &lt;a href=&quot;http://unicode.org/glossary/&quot;&gt;http://unicode.org/glossary/&lt;/a&gt; , бесплатный онлайн-словарь по вычислениям &lt;a href=&quot;http://foldoc.org/&quot;&gt;http://foldoc.org/&lt;/a&gt; , файл жаргона &lt;a href=&quot;http://catb.org/~esr/jargon/&quot;&gt;http://catb.org/~esr/jargon /&lt;/a&gt; и Википедия &lt;a href=&quot;http://www.wikipedia.org/&quot;&gt;http://www.wikipedia.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5dd1af1a4d04ac7e7f3b21f718a7e15571fdc1c" translate="yes" xml:space="preserve">
          <source>Other voting mechanisms may be used instead, as long as the same number of votes is gathered in a transparent manner. Specifically, proposals of which changes to cherry-pick must be visible to everyone on perl5-porters so that the views of everyone interested may be heard.</source>
          <target state="translated">Вместо этого могут использоваться другие механизмы голосования при условии,что в прозрачной форме будет собрано одинаковое количество голосов.В частности,предложения о внесении изменений в вишнёвый выбор должны быть видны всем на perl5-портах,чтобы мнение каждого заинтересованного было услышано.</target>
        </trans-unit>
        <trans-unit id="3ac0cc8652af1d4f7f345245edd00769715fa15d" translate="yes" xml:space="preserve">
          <source>Otherwise (i.e., if not a CGI), this tries various OS-specific ways to get the language-tags for the current locale/language, and then pretends that those were the value(s) passed to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="translated">В противном случае (то есть, если это не CGI), он пытается различными способами, зависящими от ОС, получить языковые теги для текущего языкового стандарта / языка, а затем делает вид, что это были значения, переданные в &lt;code&gt;get_handle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8e5ffbd89769bd3258cb9b3ff5d583b3da49162" translate="yes" xml:space="preserve">
          <source>Otherwise if &lt;code&gt;Configure&lt;/code&gt; found out how to do &quot;fast&quot; IO using the system's stdio, then the default layers are:</source>
          <target state="translated">В противном случае, если &lt;code&gt;Configure&lt;/code&gt; узнал, как выполнять &quot;быстрый&quot; ввод-вывод с использованием системного стандартного ввода-вывода, то по умолчанию используются следующие уровни:</target>
        </trans-unit>
        <trans-unit id="7e1be4e61a83d07cd0d9ce46ed206ea82b9d2b71" translate="yes" xml:space="preserve">
          <source>Otherwise if you really do want to build Perl, you need to get a binary version of &lt;code&gt;gcc&lt;/code&gt; for your system first. Use a search engine to find out how to do this for your operating system.</source>
          <target state="translated">В противном случае, если вы действительно хотите собрать Perl, вам сначала нужно получить двоичную версию &lt;code&gt;gcc&lt;/code&gt; для вашей системы. Воспользуйтесь поисковой системой, чтобы узнать, как это сделать в вашей операционной системе.</target>
        </trans-unit>
        <trans-unit id="16e91ca326f6d29d45932c9e83458e6f42f6b2d6" translate="yes" xml:space="preserve">
          <source>Otherwise the &lt;code&gt;PerlIO&lt;/code&gt; package is a place holder for additional PerlIO related functions.</source>
          <target state="translated">В противном случае пакет &lt;code&gt;PerlIO&lt;/code&gt; может заменить дополнительные функции, связанные с PerlIO.</target>
        </trans-unit>
        <trans-unit id="64d28c2a38bdb42602aa40deca558a7edd1c1d73" translate="yes" xml:space="preserve">
          <source>Otherwise the default layers are</source>
          <target state="translated">В противном случае слои по умолчанию</target>
        </trans-unit>
        <trans-unit id="8ee20b17c349e20c2d2bb84cf8ffa7aac44d8cc6" translate="yes" xml:space="preserve">
          <source>Otherwise this bracket group is invalid. For example, in the group &quot;[!@#,whatever]&quot;, the first item &lt;code&gt;&quot;!@#&quot;&lt;/code&gt; is neither the empty-string, &quot;_</source>
          <target state="translated">В противном случае эта группа скобок недействительна. Например, в группе &amp;laquo;[! @ #, Без разницы]&amp;raquo; первый элемент &lt;code&gt;&quot;!@#&quot;&lt;/code&gt; является пустой строкой, &amp;laquo;_</target>
        </trans-unit>
        <trans-unit id="7aa4578f342729b5a29e5d40bab856fc0c1cb526" translate="yes" xml:space="preserve">
          <source>Otherwise we will try and temporarily redirect STDERR and STDOUT, do a &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call with your command and then re-open STDERR and STDOUT. This is the method of last resort and will still allow you to execute your commands cleanly. However, no buffers will be available.</source>
          <target state="translated">В противном случае мы попытаемся временно перенаправить STDERR и STDOUT, выполнить вызов &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; с вашей командой, а затем повторно открыть STDERR и STDOUT. Это последний метод, который по-прежнему позволит вам аккуратно выполнять ваши команды. Однако буферы не будут доступны.</target>
        </trans-unit>
        <trans-unit id="c3a8d6e2eac21a8bc64fe947c356d86d63089cab" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;/a&lt;/code&gt; behaves like the &lt;code&gt;/u&lt;/code&gt; modifier, in that case-insensitive matching uses Unicode rules; for example, &quot;k&quot; will match the Unicode &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching, and code points in the Latin1 range, above ASCII will have Unicode rules when it comes to case-insensitive matching.</source>
          <target state="translated">В противном случае &lt;code&gt;/a&lt;/code&gt; ведет себя как модификатор &lt;code&gt;/u&lt;/code&gt; , в этом сопоставлении без учета регистра используются правила Unicode; например, &amp;laquo;k&amp;raquo; будет соответствовать Unicode &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; при сопоставлении &lt;code&gt;/i&lt;/code&gt; , а кодовые точки в диапазоне Latin1, выше ASCII будут иметь правила Unicode, когда дело доходит до сопоставления без учета регистра.</target>
        </trans-unit>
        <trans-unit id="283ab41299e1a089a797efad0855b8234af41dba" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; demands that a library file be included if it hasn't already been included. The file is included via the do-FILE mechanism, which is essentially just a variety of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; with the caveat that lexical variables in the invoking script will be invisible to the included code. If it were implemented in pure Perl, it would have semantics similar to the following:</source>
          <target state="translated">В противном случае &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; требует включения файла библиотеки, если он еще не был включен. Файл включается с помощью механизма do-FILE, который по сути представляет собой просто разновидность &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; с оговоркой, что лексические переменные в вызывающем скрипте будут невидимы для включенного кода. Если бы он был реализован на чистом Perl, он имел бы семантику, подобную следующей:</target>
        </trans-unit>
        <trans-unit id="3d8c7636a7e3958c42214af86cef6bf8fdccad1c" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; sets the default modifier to &lt;code&gt;/l&lt;/code&gt; ; and &lt;code&gt;&lt;a href=&quot;feature&quot;&gt;use feature 'unicode_strings&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (or higher) set the default to &lt;code&gt;/u&lt;/code&gt; when not in the same scope as either &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;. (&lt;code&gt;&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale ':not_characters'&lt;/a&gt;&lt;/code&gt; also sets the default to &lt;code&gt;/u&lt;/code&gt; , overriding any plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; .) Unlike the mechanisms mentioned above, these affect operations besides regular expressions pattern matching, and so give more consistent results with other operators, including using &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , etc. in substitution replacements.</source>
          <target state="translated">В противном случае &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; устанавливает модификатор по умолчанию на &lt;code&gt;/l&lt;/code&gt; ; и &lt;code&gt;&lt;a href=&quot;feature&quot;&gt;use feature 'unicode_strings&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (или выше), установите значение по умолчанию на &lt;code&gt;/u&lt;/code&gt; , когда не в той же области, что и &lt;code&gt;&lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; . ( &lt;code&gt;&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale ':not_characters'&lt;/a&gt;&lt;/code&gt; также устанавливает значение по умолчанию на &lt;code&gt;/u&lt;/code&gt; , переопределяя любой &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; обычного &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; .) В отличие от механизмов, упомянутых выше, они влияют на операции, помимо сопоставления с образцом регулярных выражений, и поэтому дают более согласованные результаты с другими операторами, включая использование &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; и т.п. в подмене замен.</target>
        </trans-unit>
        <trans-unit id="4164414c2bb6199a4fd794c5abe6619c58bbd334" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; demands that a library file be included if it hasn't already been included. The file is included via the do-FILE mechanism, which is essentially just a variety of &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; with the caveat that lexical variables in the invoking script will be invisible to the included code. If it were implemented in pure Perl, it would have semantics similar to the following:</source>
          <target state="translated">В противном случае &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; требует включения файла библиотеки, если он еще не был включен. Файл включается с помощью механизма do-FILE, который по сути представляет собой просто разновидность &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; с оговоркой, что лексические переменные в вызывающем скрипте будут невидимы для включенного кода. Если бы он был реализован на чистом Perl, он имел бы семантику, подобную следующей:</target>
        </trans-unit>
        <trans-unit id="b7cd0e99a1d89c3f5e339c3635e7cb0b51fb95e1" translate="yes" xml:space="preserve">
          <source>Otherwise, If EXPR has the UTF8 flag set:</source>
          <target state="translated">В противном случае,если в EXPR установлен флаг UTF8:</target>
        </trans-unit>
        <trans-unit id="17eeffaf5cce6164da792d14c62e778122ced660" translate="yes" xml:space="preserve">
          <source>Otherwise, Perl quotes non-ASCII characters using an adaptation from Unicode (see &lt;a href=&quot;http://www.unicode.org/reports/tr31/&quot;&gt;http://www.unicode.org/reports/tr31/&lt;/a&gt;). The only code points that are quoted are those that have any of the Unicode properties: Pattern_Syntax, Pattern_White_Space, White_Space, Default_Ignorable_Code_Point, or General_Category=Control.</source>
          <target state="translated">В противном случае Perl цитирует символы, отличные от ASCII, используя адаптацию из Unicode (см. &lt;a href=&quot;http://www.unicode.org/reports/tr31/&quot;&gt;Http://www.unicode.org/reports/tr31/&lt;/a&gt; ). В кавычках указаны только те кодовые точки, которые имеют любое из свойств Unicode: Pattern_Syntax, Pattern_White_Space, White_Space, Default_Ignorable_Code_Point или General_Category = Control.</target>
        </trans-unit>
        <trans-unit id="4b263d3e8956ad637fdb45e6619d7bb400854c44" translate="yes" xml:space="preserve">
          <source>Otherwise, a reference to a hash giving the mappings (or a reference to a hash of such hashes, explained below) is returned with the following keys and their meanings:</source>
          <target state="translated">В противном случае,ссылка на хэш,дающий отображение (или ссылка на хэш таких хэшей,объясненная ниже)возвращается со следующими ключами и их значениями:</target>
        </trans-unit>
        <trans-unit id="0a064c97bd76ea2baffc6a1f976852c73f8662d5" translate="yes" xml:space="preserve">
          <source>Otherwise, any string that includes a &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; will automatically have Unicode rules (see &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Byte and Character Semantics in perlunicode&lt;/a&gt;).</source>
          <target state="translated">В противном случае любая строка, содержащая &lt;code&gt;\N{&lt;i&gt;charname&lt;/i&gt;}&lt;/code&gt; или &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; будет автоматически иметь правила Unicode (см. &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;Семантику байтов и символов в perlunicode&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d003c1d5c8b3dbf299902770f34abe7c1bae5fc" translate="yes" xml:space="preserve">
          <source>Otherwise, besides slowing you down, you're going to break code when the thing in the scalar is actually neither a string nor a number, but a reference:</source>
          <target state="translated">Иначе,помимо замедления,вы сломаете код,когда вещь в скаляре на самом деле не строка и не число,а ссылка:</target>
        </trans-unit>
        <trans-unit id="3c9e5051cf80855af13f05b6891812714206afb2" translate="yes" xml:space="preserve">
          <source>Otherwise, each group is taken to be a comma-separated group of items, and each item is interpreted as follows:</source>
          <target state="translated">В противном случае каждая группа считается группой элементов,разделенных запятыми,и каждый элемент интерпретируется следующим образом:</target>
        </trans-unit>
        <trans-unit id="44c4557e33865fb576853827b17e4610d1545dd5" translate="yes" xml:space="preserve">
          <source>Otherwise, each item is interpreted as a string literal.</source>
          <target state="translated">В противном случае каждый элемент интерпретируется как строковый литерал.</target>
        </trans-unit>
        <trans-unit id="8160c1d9bfe0c258f726fcde8a38eac529a9399b" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; is in effect:</source>
          <target state="translated">В противном случае, если &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; действует:</target>
        </trans-unit>
        <trans-unit id="330cfb4214259a5977f17a0c8047846f1febf41e" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect:</source>
          <target state="translated">В противном случае, если действует &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; для &lt;code&gt;LC_CTYPE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="790132dff7791f0de9ca7fa702e257d000b8a890" translate="yes" xml:space="preserve">
          <source>Otherwise, if fallback is TRUE or undefined for the first operand then see if the &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;rules for autogeneration&lt;/a&gt; allows another of its operators to be used instead.</source>
          <target state="translated">В противном случае, если для первого операнда fallback имеет значение TRUE или undefined, посмотрите, разрешают ли &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;правила автогенерации&lt;/a&gt; использовать вместо этого другой из его операторов.</target>
        </trans-unit>
        <trans-unit id="3ed36ee27979b8527903ca8fac2a605c006c6947" translate="yes" xml:space="preserve">
          <source>Otherwise, if neither &lt;code&gt;CARP_TRACE&lt;/code&gt; nor &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; is available, stringify the value ignoring any overloading.</source>
          <target state="translated">В противном случае, если ни &lt;code&gt;CARP_TRACE&lt;/code&gt; , ни &lt;code&gt;$Carp::RefArgFormatter&lt;/code&gt; недоступны, преобразовать значение в строку , игнорируя любую перегрузку.</target>
        </trans-unit>
        <trans-unit id="2f787cbc7a032f69fffb6119d7035816b8ea11e2" translate="yes" xml:space="preserve">
          <source>Otherwise, if the variable &lt;code&gt;$IPC::Cmd::USE_IPC_OPEN3&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section), try to execute the command using &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt;. Buffers will be available on all platforms, interactive commands will still execute cleanly, and also your verbosity settings will be adhered to nicely;</source>
          <target state="translated">В противном случае, если для переменной &lt;code&gt;$IPC::Cmd::USE_IPC_OPEN3&lt;/code&gt; установлено значение true (см. Раздел &amp;laquo; &lt;a href=&quot;#Global-Variables&quot;&gt;Глобальные переменные&lt;/a&gt; &amp;raquo;), попробуйте выполнить команду с помощью &lt;a href=&quot;open3&quot;&gt;IPC :: Open3&lt;/a&gt; . Буферы будут доступны на всех платформах, интерактивные команды по-прежнему будут выполняться четко, а также будут соблюдаться ваши настройки детализации;</target>
        </trans-unit>
        <trans-unit id="fe09ff3823115671ffa501d26ad1a577bc040ded" translate="yes" xml:space="preserve">
          <source>Otherwise, if you have the &lt;code&gt;verbose&lt;/code&gt; argument set to true, we fall back to a simple &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call. We cannot capture any buffers, but interactive commands will still work.</source>
          <target state="translated">В противном случае, если для &lt;code&gt;verbose&lt;/code&gt; аргумента установлено значение true, мы возвращаемся к простому вызову &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . Мы не можем захватить какие-либо буферы, но интерактивные команды все равно будут работать.</target>
        </trans-unit>
        <trans-unit id="643e7b58bd1c31793f061806f8ffae4f428818df" translate="yes" xml:space="preserve">
          <source>Otherwise, import the functions into a convenient package like &lt;code&gt;HUF&lt;/code&gt; or, more general, &lt;code&gt;Aux&lt;/code&gt;</source>
          <target state="translated">В противном случае импортируйте функции в удобный пакет, например &lt;code&gt;HUF&lt;/code&gt; или, в более общем &lt;code&gt;Aux&lt;/code&gt; , Aux</target>
        </trans-unit>
        <trans-unit id="ec3718eb10f9299de84d9700b81d5d9ff67ef5c1" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns the index into the list of the range that contains the code point.; that is, find &lt;code&gt;i&lt;/code&gt; such that</source>
          <target state="translated">В противном случае он возвращает индекс в список диапазона, который содержит кодовую точку .; то есть, найти &lt;code&gt;i&lt;/code&gt; такой , что</target>
        </trans-unit>
        <trans-unit id="0d7b4536a86a677a8d4d8e936e21d06c203d8809" translate="yes" xml:space="preserve">
          <source>Otherwise, one can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; , which has effects at compile time and run time. Since Perl 5.9.5, this pragma is lexically scoped.</source>
          <target state="translated">В противном случае можно &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; , которая имеет эффект во время компиляции и выполнения. Начиная с Perl 5.9.5, эта прагма имеет лексическую область видимости.</target>
        </trans-unit>
        <trans-unit id="060d2d5af4a10b8f17638e7be02655b970ad0e80" translate="yes" xml:space="preserve">
          <source>Otherwise, the &quot;fail&quot; attribute's value should be a string denoting a method name, so that $lh-&amp;gt;maketext(</source>
          <target state="translated">В противном случае значением атрибута &amp;laquo;fail&amp;raquo; должна быть строка, обозначающая имя метода, так что $ lh-&amp;gt; maketext (</target>
        </trans-unit>
        <trans-unit id="e4d6075a624f71d57d66727413b2c14075c13d0f" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator behaves exactly as the comma operator or list argument separator, according to context.</source>
          <target state="translated">В противном случае оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; ведет себя точно так же, как оператор запятой или разделитель аргументов списка, в зависимости от контекста.</target>
        </trans-unit>
        <trans-unit id="153f18b9e853a33ec89bf986e0079606fc138189" translate="yes" xml:space="preserve">
          <source>Otherwise, the right side is a method name or a simple scalar variable containing either the method name or a subroutine reference, and the left side must be either an object (a blessed reference) or a class name (that is, a package name). See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">В противном случае правая часть - это имя метода или простая скалярная переменная, содержащая либо имя метода, либо ссылку на подпрограмму, а левая часть должна быть либо объектом (благословенная ссылка), либо именем класса (то есть именем пакета). . См. &lt;a href=&quot;perlobj&quot;&gt;Perlobj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93adaa86658b0d707fd7e6f95b2dd74b9f755925" translate="yes" xml:space="preserve">
          <source>Otherwise, you can use the File::Temp module.</source>
          <target state="translated">В противном случае можно использовать модуль File::Temp.</target>
        </trans-unit>
        <trans-unit id="5cbc6561d27e47c3ea5b5fa6d9459eb9629b7617" translate="yes" xml:space="preserve">
          <source>Otherwise:</source>
          <target state="translated">Otherwise:</target>
        </trans-unit>
        <trans-unit id="96b81f4b95ad77a7f2490339a2a4369277de66dd" translate="yes" xml:space="preserve">
          <source>Our best advice for verifying a person's mail address is to have them enter their address twice, just as you normally do to change a password. This usually weeds out typos. If both versions match, send mail to that address with a personal message. If you get the message back and they've followed your directions, you can be reasonably assured that it's real.</source>
          <target state="translated">Наш лучший совет для проверки почтового адреса человека-это дважды ввести его адрес,как вы обычно делаете для смены пароля.Это обычно устраняет опечатки.Если обе версии совпадают,отправьте письмо на этот адрес с личным сообщением.Если вы получили сообщение обратно и они последовали вашим указаниям,вы можете быть уверены,что оно реально.</target>
        </trans-unit>
        <trans-unit id="a36d716e41b5fdfa6778288f0df9280c6ac367a9" translate="yes" xml:space="preserve">
          <source>Our community has a long-held belief that backward-compatibility is a virtue, even when the functionality in question is a design flaw.</source>
          <target state="translated">Наше сообщество давно убеждено,что обратная совместимость-это добродетель,даже когда функциональность,о которой идет речь,является недостатком конструкции.</target>
        </trans-unit>
        <trans-unit id="aca2af8fba9b0e206c26228fbcf4f0a28aadfadd" translate="yes" xml:space="preserve">
          <source>Our constructor and accessors are not very smart. They don't check that a &lt;code&gt;$path&lt;/code&gt; is defined, nor do they check that a &lt;code&gt;$path&lt;/code&gt; is a valid filesystem path.</source>
          <target state="translated">Конструктор и аксессуары у нас не очень умные. Они не проверяют, определен ли &lt;code&gt;$path&lt;/code&gt; , и не проверяют, является ли &lt;code&gt;$path&lt;/code&gt; допустимым путем в файловой системе.</target>
        </trans-unit>
        <trans-unit id="02046a00610d7c36994a4a1cfc35b185bf538e5f" translate="yes" xml:space="preserve">
          <source>Our first extension will be very simple. When we call the routine in the extension, it will print out a well-known message and return.</source>
          <target state="translated">Наше первое расширение будет очень простым.Когда мы вызовем рутину в расширении,он распечатает известное сообщение и вернется.</target>
        </trans-unit>
        <trans-unit id="ea0a64102e29c4a40939ff09bce3a7c8b3baeb50" translate="yes" xml:space="preserve">
          <source>Our goals include, but are not limited to:</source>
          <target state="translated">Наши цели включают в себя,но не ограничиваются ими:</target>
        </trans-unit>
        <trans-unit id="dd423773d407b1a40adc986c561aae58350fc823" translate="yes" xml:space="preserve">
          <source>Our third extension will take one argument as its input, round off that value, and set the</source>
          <target state="translated">Наше третье расширение примет на вход один аргумент,округлит это значение и установит параметр</target>
        </trans-unit>
        <trans-unit id="d1eca9c1df299ed6f167227271a421fa1ed8acd5" translate="yes" xml:space="preserve">
          <source>Out of Memory!</source>
          <target state="translated">Из памяти!</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="dbd857869dc8d796444978bd605ba7b7d270b4e9" translate="yes" xml:space="preserve">
          <source>Output File Glob</source>
          <target state="translated">Выходной файл Глобус</target>
        </trans-unit>
        <trans-unit id="cabfa26f9d0a36c1ea391888431d2b012edaa467" translate="yes" xml:space="preserve">
          <source>Output FileGlobs take the</source>
          <target state="translated">Выходные ФайловыеГлобусы берут</target>
        </trans-unit>
        <trans-unit id="320abeb6fc8745d8377c151e5e59cdadfc038781" translate="yes" xml:space="preserve">
          <source>Output arguments for linking the Perl library and any extensions linked with the current Perl.</source>
          <target state="translated">Выводите аргументы для связывания библиотеки Perl и любых расширений,связанных с текущим Perl.</target>
        </trans-unit>
        <trans-unit id="dff47f3a71d82ad60cb4cacc40b69b766de3ff9e" translate="yes" xml:space="preserve">
          <source>Output arguments for linking the Perl library and extensions to your application.</source>
          <target state="translated">Выводите аргументы для линковки библиотеки Perl и расширений к вашему приложению.</target>
        </trans-unit>
        <trans-unit id="d4513ca13498ae2966be4acb14ad297fe3972a7d" translate="yes" xml:space="preserve">
          <source>Output data values (when they appear as constants) using Data::Dumper. Without this option, B::Deparse will use some simple routines of its own for the same purpose. Currently, Data::Dumper is better for some kinds of data (such as complex structures with sharing and self-reference) while the built-in routines are better for others (such as odd floating-point values).</source>
          <target state="translated">Выводить значения данных (когда они появляются в виде констант)с помощью Data::Dumper.Без этой опции,B::Deparse будет использовать несколько простых собственных процедур для той же цели.В настоящее время Data::Dumper лучше подходит для некоторых типов данных (таких как сложные структуры с общим доступом и самоназванием),в то время как встроенные процедуры лучше подходят для других (таких как нечетные значения с плавающей запятой).</target>
        </trans-unit>
        <trans-unit id="946f8eaf8de365c1db6707020e600be8dc0b2d32" translate="yes" xml:space="preserve">
          <source>Output from</source>
          <target state="translated">Выход из</target>
        </trans-unit>
        <trans-unit id="732197af5a245075eb093be6a52f4e49643ea019" translate="yes" xml:space="preserve">
          <source>Output produced by &lt;code&gt;POSIX::strftime()&lt;/code&gt; , which builds a formatted human-readable date/time string, is affected by the current &lt;code&gt;LC_TIME&lt;/code&gt; locale. Thus, in a French locale, the output produced by the &lt;code&gt;%B&lt;/code&gt; format element (full month name) for the first month of the year would be &quot;janvier&quot;. Here's how to get a list of long month names in the current locale:</source>
          <target state="translated">На вывод, производимый &lt;code&gt;POSIX::strftime()&lt;/code&gt; , которая строит отформатированную удобочитаемую строку даты / времени, влияет текущий языковой стандарт &lt;code&gt;LC_TIME&lt;/code&gt; . Таким образом, во французской локали вывод, произведенный элементом формата &lt;code&gt;%B&lt;/code&gt; (полное название месяца) для первого месяца года, будет &quot;janvier&quot;. Вот как получить список длинных названий месяцев в текущей локали:</target>
        </trans-unit>
        <trans-unit id="d20389c9ad811915dc895816013a0d6320f55cc3" translate="yes" xml:space="preserve">
          <source>Output record formats are declared as follows:</source>
          <target state="translated">Выходные форматы записи объявлены следующим образом:</target>
        </trans-unit>
        <trans-unit id="8be7301f815488d71ba9c93bb5af631cc0c5c280" translate="yes" xml:space="preserve">
          <source>Output test preamble</source>
          <target state="translated">Преамбула выходного теста</target>
        </trans-unit>
        <trans-unit id="0cb96efb75c4bbeb8be2ce6be1b81199c7dc6523" translate="yes" xml:space="preserve">
          <source>Output the string for the given capability padded as appropriate without any parameter substitution.</source>
          <target state="translated">Выведите строку для заданной возможности без подстановки параметров.</target>
        </trans-unit>
        <trans-unit id="e4a057a50b92dcf0b95865eb0847c9c19f40cf41" translate="yes" xml:space="preserve">
          <source>Output the summary for a &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">Выведите сводку для &lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="674e1e7520d063a11e6ddc4e4cd926f65dce8e61" translate="yes" xml:space="preserve">
          <source>Output values are BigFloat objects (normalized), except for bstr() and bsstr().</source>
          <target state="translated">Выходными значениями являются объекты BigFloat (нормализованные),за исключением bstr()и bsstr().</target>
        </trans-unit>
        <trans-unit id="5729e52e9619576e333d708f5b86cf53768b1b3b" translate="yes" xml:space="preserve">
          <source>Output values are BigInt objects (normalized), except for the methods which return a string (see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;).</source>
          <target state="translated">Выходные значения являются объектами BigInt (нормализованными), за исключением методов, возвращающих строку (см. &lt;a href=&quot;#SYNOPSIS&quot;&gt;ОБЗОР&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="92ee72c25cceb27be8a2caf11cbdcbd8ed211c74" translate="yes" xml:space="preserve">
          <source>Output will be indented and marked with a # so as not to interfere with test output. A newline will be put on the end if there isn't one already.</source>
          <target state="translated">Выходные данные будут снабжены отступом и помечены знаком #,чтобы не создавать помех для вывода результатов теста.Если его еще нет,на конец будет выведена новая строка.</target>
        </trans-unit>
        <trans-unit id="1c19ab0b423651729aa903ab380edeb2bca39734" translate="yes" xml:space="preserve">
          <source>Outputs a literal string with appropriate padding for the current terminal.</source>
          <target state="translated">Выводит буквенную строку с соответствующей набивкой для текущей клеммы.</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="27666598a1e0a42575577d9b60e589550171ef9f" translate="yes" xml:space="preserve">
          <source>Outstanding Issues with Perl on QNX4</source>
          <target state="translated">Нерешенные проблемы с Perl на QNX4</target>
        </trans-unit>
        <trans-unit id="639d7ade090cee980c6bc05e57d3d1577af16a27" translate="yes" xml:space="preserve">
          <source>Outstanding issues with perl under QNX6</source>
          <target state="translated">Нерешенные вопросы с perl под QNX6</target>
        </trans-unit>
        <trans-unit id="bdf3ed1bb141b837355c86c7c0dd2614394d1b0b" translate="yes" xml:space="preserve">
          <source>Over this group of porters presides Larry Wall. He has the final word in what does and does not change in any of the Perl programming languages. These days, Larry spends most of his time on Perl 6, while Perl 5 is shepherded by a &quot;pumpking&quot;, a porter responsible for deciding what goes into each release and ensuring that releases happen on a regular basis.</source>
          <target state="translated">Над этой группой носильщиков председательствует Ларри Уолл.У него есть последнее слово в том,что делает и не меняет ни один из языков программирования Perl.В эти дни Ларри проводит большую часть времени на Perl 6,в то время как Perl 5 управляется &quot;качалкой&quot;,портьером,отвечающим за принятие решений о том,что входит в каждый релиз,и обеспечение того,чтобы релизы происходили на регулярной основе.</target>
        </trans-unit>
        <trans-unit id="26e40e3844fb4d3113244cc032fb4a908e8fcd75" translate="yes" xml:space="preserve">
          <source>Overloadable Operations</source>
          <target state="translated">Перегрузочные операции</target>
        </trans-unit>
        <trans-unit id="ec86957a0fb6a3d4fbc42d54b629b68b40ef88b9" translate="yes" xml:space="preserve">
          <source>Overloading Constants</source>
          <target state="translated">Перегрузка Константы</target>
        </trans-unit>
        <trans-unit id="b399e489ae1423cf5aaa91fe52bb0ca8621359b8" translate="yes" xml:space="preserve">
          <source>Overloading respects inheritance via the @ISA hierarchy. Inheritance interacts with overloading in two ways.</source>
          <target state="translated">Перегрузка уважения к наследованию через иерархию @ISA.Наследование взаимодействует с перегрузкой двумя способами.</target>
        </trans-unit>
        <trans-unit id="d25853ad0b9aa2087c0afaa6cc2a5913f690f84b" translate="yes" xml:space="preserve">
          <source>Overridable by PREFIX</source>
          <target state="translated">Переопределяется с помощью PREFIX</target>
        </trans-unit>
        <trans-unit id="467a685e8ada69aefbe5924cc457f1afc183b3db" translate="yes" xml:space="preserve">
          <source>Overridden by PREFIX.</source>
          <target state="translated">Переопределена PREFIX.</target>
        </trans-unit>
        <trans-unit id="8de838ce5cdf14a3fefb1762cc63935ac8b01d94" translate="yes" xml:space="preserve">
          <source>Overridden methods</source>
          <target state="translated">Переопределенные методы</target>
        </trans-unit>
        <trans-unit id="18ab6a26cd6f669c409ca6006d7c65633ebdbc28" translate="yes" xml:space="preserve">
          <source>Override Unix. Cygwin case-tolerance depends on managed mount settings and as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE, indicating the case significance when comparing file specifications. Default: 1</source>
          <target state="translated">Отменить Unix.Регистрация Cygwin зависит от управляемых настроек монтирования и,как и в случае с MsWin32 на GetVolumeInformation()$ouFsFlags ==FS_CASE_SENSITIVE,что указывает на значимость регистра при сравнении спецификаций файлов.По умолчанию:1</target>
        </trans-unit>
        <trans-unit id="b812a67f3c81aa251e9cf3aa48fd3d76b409d29b" translate="yes" xml:space="preserve">
          <source>Override some of the slower, portable commands with Windows specific ones.</source>
          <target state="translated">Переопределите некоторые медленные,портативные команды с помощью команд,специфичных для Windows.</target>
        </trans-unit>
        <trans-unit id="d0c9857b122b80fa1b6a56bf1ebf37d184d83e68" translate="yes" xml:space="preserve">
          <source>Override the *DEFINE_VERSION macros with VMS semantics. Translate the MAKEMAKER filepath to VMS style.</source>
          <target state="translated">Переопределить макросы *DEFINE_VERSION семантикой VMS.Перевести файловый путь MAKEMAKER в стиль VMS.</target>
        </trans-unit>
        <trans-unit id="9e106e8d2f26a8506c045db84481cb6d80e276c4" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big integers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="translated">Переопределить встроенный метод hex()версией,которая может работать с большими целыми числами.Это переопределяет его,экспортируя в текущий пакет.В Perl v5.10.0 и выше,это не так необходимо,так как hex()лексически переопределяется в текущем диапазоне,когда активна прагма bigint.</target>
        </trans-unit>
        <trans-unit id="db1255a81faff303e8d6e7d3b798d7ce08d1d0bd" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bignum pragma is active.</source>
          <target state="translated">Переопределить встроенный метод hex()версией,которая может работать с большими числами.Это переопределяет его,экспортируя в текущий пакет.В Perl версии 5.10.0 и выше это не так необходимо,поскольку hex()лексически переопределяется в текущей области видимости всякий раз,когда активна прагматическая картинка.</target>
        </trans-unit>
        <trans-unit id="912f152c86b0fefa5f757189a8d412dd86bae7f1" translate="yes" xml:space="preserve">
          <source>Override the built-in hex() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as hex() is lexically overridden in the current scope whenever the bigrat pragma is active.</source>
          <target state="translated">Переопределить встроенный метод hex()версией,которая может работать с большими числами.Это переопределяет его,экспортируя в текущий пакет.В версии Perl v5.10.0 и выше это не так необходимо,так как hex()лексически переопределяется в текущей области применения всякий раз,когда активна прагма bigrat.</target>
        </trans-unit>
        <trans-unit id="517fe3ab934c9baa1bbd4819a553d1bd788ad3b6" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big integers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="translated">Переопределить встроенный метод oct()версией,которая может обрабатывать большие целые числа.Это переопределяет его,экспортируя в текущий пакет.В версии Perl v5.10.0 и выше это не так необходимо,так как oct()лексически переопределяется в текущей области видимости всякий раз,когда активна прагма bigint.</target>
        </trans-unit>
        <trans-unit id="4bed448b71cf61598fc58c7dedb86dd2c891a406" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigint pragma is active.</source>
          <target state="translated">Переопределить встроенный метод oct()версией,которая может работать с большими числами.Это переопределяет его,экспортируя в текущий пакет.В версии Perl v5.10.0 и выше это не так необходимо,так как oct()лексически переопределяется в текущей области видимости всякий раз,когда активна прагма bigint.</target>
        </trans-unit>
        <trans-unit id="ed5c7e59eb86a96d19a5d320701f2eeae30a9f3d" translate="yes" xml:space="preserve">
          <source>Override the built-in oct() method with a version that can handle big numbers. This overrides it by exporting it to the current package. Under Perl v5.10.0 and higher, this is not so necessary, as oct() is lexically overridden in the current scope whenever the bigrat pragma is active.</source>
          <target state="translated">Переопределить встроенный метод oct()версией,которая может работать с большими числами.Это переопределяет его,экспортируя в текущий пакет.В версии Perl v5.10.0 и выше это не так необходимо,так как oct()лексически переопределяется в текущей области видимости всякий раз,когда активна прагма bigrat.</target>
        </trans-unit>
        <trans-unit id="a84161f7c8651d9dbb9584e62df4eb94978336a4" translate="yes" xml:space="preserve">
          <source>Override the default link and compile tools.</source>
          <target state="translated">Переопределите стандартную ссылку и скомпилируйте инструменты.</target>
        </trans-unit>
        <trans-unit id="2e3576b163731229acda47e87e9f9b059e9f4a5b" translate="yes" xml:space="preserve">
          <source>Overriden Methods</source>
          <target state="translated">Переопределяющие методы</target>
        </trans-unit>
        <trans-unit id="88ddbf620473fa127baa14c63b6b03e218cdb828" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;Carp&lt;/code&gt; 's use of &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Заменяет &lt;code&gt;Carp&lt;/code&gt; использование &amp;laquo;s из &lt;code&gt;@ISA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f558940f2808fb5910806545f490b364bd4fae6" translate="yes" xml:space="preserve">
          <source>Overriding *AutoLoader*'s AUTOLOAD Subroutine</source>
          <target state="translated">Переопределяющая *Автозагрузчик*подпрограмма АВТОЛОАДА</target>
        </trans-unit>
        <trans-unit id="ad165e83687c2095d41c401a84a596f21c23d403" translate="yes" xml:space="preserve">
          <source>Overriding &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD Subroutine</source>
          <target state="translated">Переопределение &lt;b&gt;автозагрузчика&lt;/b&gt; &amp;laquo;S AUTOLOAD SUBROUTINE</target>
        </trans-unit>
        <trans-unit id="13e4e6c170816454742428861af9c648b7770476" translate="yes" xml:space="preserve">
          <source>Overriding Built-in Functions</source>
          <target state="translated">Переопределяющие встроенные функции</target>
        </trans-unit>
        <trans-unit id="0473324f13f95874cc801aec0b7f96d36dd3f4de" translate="yes" xml:space="preserve">
          <source>Overriding MakeMaker Methods</source>
          <target state="translated">Переопределяющие методы MakeMaker</target>
        </trans-unit>
        <trans-unit id="8975db571ede7ae4ff4258fa3aa601af32455235" translate="yes" xml:space="preserve">
          <source>Overriding may be done only by importing the name from a module at compile time--ordinary predeclaration isn't good enough. However, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma lets you, in effect, predeclare subs via the import syntax, and these names may then override built-in ones:</source>
          <target state="translated">Переопределение может быть выполнено только путем импорта имени из модуля во время компиляции - обычного предварительного объявления недостаточно. Однако прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; позволяет вам, по сути, предварительно объявить подпрограммы через синтаксис импорта, и эти имена могут затем переопределить встроенные:</target>
        </trans-unit>
        <trans-unit id="304bd31d39d40b4f3f802e079ce7c0e189c81a09" translate="yes" xml:space="preserve">
          <source>Overriding methods and method resolution</source>
          <target state="translated">Переопределяющие методы и разрешение метода</target>
        </trans-unit>
        <trans-unit id="ffad1af53b33d79810d2c0405dc312e1ae6928cd" translate="yes" xml:space="preserve">
          <source>Overstruck text is best viewed by page-at-a-time programs that take advantage of the terminal's &lt;b&gt;stand-out&lt;/b&gt; and</source>
          <target state="translated">Overstruck текст лучше всего просматривать с помощью страниц на-времени программ , которые используют преимущество терминала &lt;b&gt;выделяющиеся&lt;/b&gt; и</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="a66e34441ac56e5f8863c6bb5ce6bb649c646c79" translate="yes" xml:space="preserve">
          <source>Ownwership of directories that already exist will not be changed.</source>
          <target state="translated">Владение уже существующими каталогами не изменится.</target>
        </trans-unit>
        <trans-unit id="c90ae34a7bbf5b215bf702e4f15a56d1024f60a9" translate="yes" xml:space="preserve">
          <source>Oxford English Dictionary</source>
          <target state="translated">Оксфордский английский словарь</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="a5574a0609f5eaeb5946f32c91fbd5d565ba5c54" translate="yes" xml:space="preserve">
          <source>PA-RISC</source>
          <target state="translated">PA-RISC</target>
        </trans-unit>
        <trans-unit id="b18e26c5d2442635220100cdbb4632471aa32d8c" translate="yes" xml:space="preserve">
          <source>PA-RISC 1.0</source>
          <target state="translated">PA-RISC 1.0</target>
        </trans-unit>
        <trans-unit id="eb216919e4e2e5c1a44316f9467b8ca7837ec3cc" translate="yes" xml:space="preserve">
          <source>PA-RISC 1.1</source>
          <target state="translated">PA-RISC 1.1</target>
        </trans-unit>
        <trans-unit id="db7ada64f0dcd494ae2a9fde52058fe389930fc0" translate="yes" xml:space="preserve">
          <source>PA-RISC 2.0</source>
          <target state="translated">PA-RISC 2.0</target>
        </trans-unit>
        <trans-unit id="a671d1a90e2150d11e2b1f6323c00da36fa35704" translate="yes" xml:space="preserve">
          <source>PA-RISC and Itanium object files are not interchangeable. Although you may be able to use ar to create an archive library of PA-RISC object files on an Itanium system, you cannot link against it using an Itanium link editor.</source>
          <target state="translated">Объектные файлы PA-RISC и Itanium не являются взаимозаменяемыми.Хотя можно использовать ar для создания архивной библиотеки объектных файлов PA-RISC на Itanium-системе,при использовании редактора ссылок в Itanium ссылаться на нее нельзя.</target>
        </trans-unit>
        <trans-unit id="6e778bd20eb20ec966352f3796d7c0931f2a1b52" translate="yes" xml:space="preserve">
          <source>PACKAGE</source>
          <target state="translated">PACKAGE</target>
        </trans-unit>
        <trans-unit id="3b24034394fd782a09f93e8a5e6a19e433f5c0b7" translate="yes" xml:space="preserve">
          <source>PACKAGE VARIABLES</source>
          <target state="translated">ПЕРЕМЕННЫЕ ПАКЕТА</target>
        </trans-unit>
        <trans-unit id="f5757bc942837b06dcea162133be87f1399efdb1" translate="yes" xml:space="preserve">
          <source>PAD-RELATED CLASSES</source>
          <target state="translated">СВЯЗАННЫЕ С КОВРИКАМИ КЛАССЫ</target>
        </trans-unit>
        <trans-unit id="5256fd77701bc17fcebded5655a52af6c191f7ca" translate="yes" xml:space="preserve">
          <source>PADDING OF BASE64 DIGESTS</source>
          <target state="translated">НАПОЛНЕНИЕ ДАЙДЖЕСТОВ BASE64</target>
        </trans-unit>
        <trans-unit id="92903ba42bddaecab9133139d6657d1d38035291" translate="yes" xml:space="preserve">
          <source>PAR - optional module which can treat &lt;code&gt;.par&lt;/code&gt; files as Perl libraries.</source>
          <target state="translated">PAR - дополнительный модуль, который может обрабатывать файлы &lt;code&gt;.par&lt;/code&gt; как библиотеки Perl.</target>
        </trans-unit>
        <trans-unit id="8aa67c70b62b88425c0805fe7ee18784ade05280" translate="yes" xml:space="preserve">
          <source>PARNO</source>
          <target state="translated">PARNO</target>
        </trans-unit>
        <trans-unit id="d76071dc758ed7e342554ae65110a5912fa75887" translate="yes" xml:space="preserve">
          <source>PARSING OPTIONS</source>
          <target state="translated">ВАРИАНТЫ РАЗБОРА</target>
        </trans-unit>
        <trans-unit id="2f27cfe52f75001eb8b13ac0b269b4d71a7d0eff" translate="yes" xml:space="preserve">
          <source>PATCHING</source>
          <target state="translated">PATCHING</target>
        </trans-unit>
        <trans-unit id="b991d9932b6d73d6525c72b0344ecaf0a6e70612" translate="yes" xml:space="preserve">
          <source>PATCHING PERL</source>
          <target state="translated">ПАТЧИНГ</target>
        </trans-unit>
        <trans-unit id="09bd6a353a7bb8a33e37cfee71ada9fc9ce37d89" translate="yes" xml:space="preserve">
          <source>PATH</source>
          <target state="translated">PATH</target>
        </trans-unit>
        <trans-unit id="97000043438fbbe1d01d067a89cdcef2f0e8c14c" translate="yes" xml:space="preserve">
          <source>PATHNAME CONSTANTS</source>
          <target state="translated">КОНСТАНТЫ PATHNAME</target>
        </trans-unit>
        <trans-unit id="84c16d6a502dba6bf2d3fee213424d5d6bfb7b62" translate="yes" xml:space="preserve">
          <source>PATTERN</source>
          <target state="translated">PATTERN</target>
        </trans-unit>
        <trans-unit id="dac71a6819627d348c31a24b525d7fa382bddadb" translate="yes" xml:space="preserve">
          <source>PCRE/Python Support</source>
          <target state="translated">PCRE/Питон Поддержка</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="aa3411cdbe71b0a21abc88a3963b8403693bbc1b" translate="yes" xml:space="preserve">
          <source>PERFORMANCE</source>
          <target state="translated">PERFORMANCE</target>
        </trans-unit>
        <trans-unit id="a039af5d518d5df4edecd9355e8862ee9074cf7a" translate="yes" xml:space="preserve">
          <source>PERL 5 PORTERS</source>
          <target state="translated">PERL 5 ПОРТЕРЫ</target>
        </trans-unit>
        <trans-unit id="7e824f1cd9308ba64d688a71fcc968d2bf452aa4" translate="yes" xml:space="preserve">
          <source>PERL 5.8.0 BROKEN IN AMIGAOS</source>
          <target state="translated">ПЕРЛ 5.8.0 СЛОМАННЫЙ В АМИГАЯХ</target>
        </trans-unit>
        <trans-unit id="2ad8575bde04df8f3c3405e287595936fe2f6b74" translate="yes" xml:space="preserve">
          <source>PERL OO SYSTEMS</source>
          <target state="translated">СИСТЕМЫ PERL OO</target>
        </trans-unit>
        <trans-unit id="38707bbc3a64c94dc99f9b43d452049c22f48409" translate="yes" xml:space="preserve">
          <source>PERL.C</source>
          <target state="translated">PERL.C</target>
        </trans-unit>
        <trans-unit id="c4ef015b035531ca89e73efd9974dbb427096dd2" translate="yes" xml:space="preserve">
          <source>PERL.EXE</source>
          <target state="translated">PERL.EXE</target>
        </trans-unit>
        <trans-unit id="0f9466733223ddd1a05cbf29bb33f0f356cbffcb" translate="yes" xml:space="preserve">
          <source>PERL.H</source>
          <target state="translated">PERL.H</target>
        </trans-unit>
        <trans-unit id="4a444e7468c0f9cc5930e13403ef14557c1dcc70" translate="yes" xml:space="preserve">
          <source>PERL.OBJ</source>
          <target state="translated">PERL.OBJ</target>
        </trans-unit>
        <trans-unit id="52d59ca4a1575427154cd0921e5e7f03fc93f8dc" translate="yes" xml:space="preserve">
          <source>PERL5LIB and PERLLIB</source>
          <target state="translated">PERL5LIB и PERLLIB</target>
        </trans-unit>
        <trans-unit id="f0a75fb949dd06b3f9081176db6123371bfe89bd" translate="yes" xml:space="preserve">
          <source>PERLDOCS</source>
          <target state="translated">PERLDOCS</target>
        </trans-unit>
        <trans-unit id="985d8b7cd33b8ae8b97c10576f8525c5e43feb2b" translate="yes" xml:space="preserve">
          <source>PERLLIB_PREFIX</source>
          <target state="translated">PERLLIB_PREFIX</target>
        </trans-unit>
        <trans-unit id="a58122b37384a35d76a112224ebc05023622985d" translate="yes" xml:space="preserve">
          <source>PERLSHR</source>
          <target state="translated">PERLSHR</target>
        </trans-unit>
        <trans-unit id="f9b90ea60310458da34842ec49d8ba2dcc6d6842" translate="yes" xml:space="preserve">
          <source>PERL_ARCHIVE: path to libperl.a equivalent to be linked to dynamic extensions.</source>
          <target state="translated">PERL_ARCHIVE:путь к libperl.a,эквивалентному динамическим расширениям.</target>
        </trans-unit>
        <trans-unit id="6b32b9f2a6388fd49d59dc380fdfe54ede4bbab4" translate="yes" xml:space="preserve">
          <source>PERL_ARCHIVE_AFTER: path to a library which should be put on the linker command line</source>
          <target state="translated">PERL_ARCHIVE_AFTER:путь к библиотеке,которая должна быть помещена в командную строку компоновщика</target>
        </trans-unit>
        <trans-unit id="4c6d51550dda10c59c0baefc83a359a9b3e89e2d" translate="yes" xml:space="preserve">
          <source>PERL_BADFREE</source>
          <target state="translated">PERL_BADFREE</target>
        </trans-unit>
        <trans-unit id="a23a8f24b9f1defe9ff92b59171d38cc844c2e5c" translate="yes" xml:space="preserve">
          <source>PERL_BADLANG</source>
          <target state="translated">PERL_BADLANG</target>
        </trans-unit>
        <trans-unit id="ea61b8e3a3a6f667f8ac07d9441b74f7086fd4b1" translate="yes" xml:space="preserve">
          <source>PERL_DESTRUCT_LEVEL</source>
          <target state="translated">PERL_DESTRUCT_LEVEL</target>
        </trans-unit>
        <trans-unit id="61a82fd6ba532d8a72b14f2af64e53732c3f8065" translate="yes" xml:space="preserve">
          <source>PERL_ENV_TABLES</source>
          <target state="translated">PERL_ENV_TABLES</target>
        </trans-unit>
        <trans-unit id="df55d3100213212432ed7cb5fb2ce8aff5bb5e34" translate="yes" xml:space="preserve">
          <source>PERL_JSON_BACKEND</source>
          <target state="translated">PERL_JSON_BACKEND</target>
        </trans-unit>
        <trans-unit id="7406046b29d774dab6f67c9ebf1226de7875707f" translate="yes" xml:space="preserve">
          <source>PERL_MEM_LOG</source>
          <target state="translated">PERL_MEM_LOG</target>
        </trans-unit>
        <trans-unit id="35728d129bbb3e5ed03314204a1cbf6d4ce2e6d0" translate="yes" xml:space="preserve">
          <source>PERL_SET_CONTEXT(interp) should also be called whenever &lt;code&gt;interp&lt;/code&gt; is used by a thread that did not create it (using either perl_alloc(), or the more esoteric perl_clone()).</source>
          <target state="translated">PERL_SET_CONTEXT (interp) также должен вызываться всякий раз, когда &lt;code&gt;interp&lt;/code&gt; используется потоком, который его не создавал (с помощью perl_alloc () или более эзотерического perl_clone ()).</target>
        </trans-unit>
        <trans-unit id="a871d7bf7b2a02e819c07cf4df026d57906b3e51" translate="yes" xml:space="preserve">
          <source>PERL_SH_DIR</source>
          <target state="translated">PERL_SH_DIR</target>
        </trans-unit>
        <trans-unit id="4e4019cc5e2b7ec5fc3d43d1227c4891f068a0c3" translate="yes" xml:space="preserve">
          <source>PERL_VMS_EXCEPTION_DEBUG</source>
          <target state="translated">PERL_VMS_EXCEPTION_DEBUG</target>
        </trans-unit>
        <trans-unit id="22d485a76570fc46268de520a55e10a9a69f35aa" translate="yes" xml:space="preserve">
          <source>PERL_YAML_BACKEND</source>
          <target state="translated">PERL_YAML_BACKEND</target>
        </trans-unit>
        <trans-unit id="70101c7c85d7116954e48d6da8dddb7074ef2a17" translate="yes" xml:space="preserve">
          <source>PERSISTENT CACHE SUPPORT</source>
          <target state="translated">ПОСТОЯННАЯ ПОДДЕРЖКА КЭША</target>
        </trans-unit>
        <trans-unit id="60003793ea7b554ef4aa8d86e943a5c0f46d5e37" translate="yes" xml:space="preserve">
          <source>PF_INET, PF_INET6, PF_UNIX, ...</source>
          <target state="translated">PF_INET,PF_INET6,PF_UNIX,...</target>
        </trans-unit>
        <trans-unit id="fa7ff6fb00a7ace8d98cf880a492dc6c5ffc8ca7" translate="yes" xml:space="preserve">
          <source>PI</source>
          <target state="translated">PI</target>
        </trans-unit>
        <trans-unit id="3490ca5e3137d6e80d152267527e5428418a006e" translate="yes" xml:space="preserve">
          <source>PL files are normally run &lt;b&gt;after&lt;/b&gt; pm_to_blib and include INST_LIB and INST_ARCH in their &lt;code&gt;@INC&lt;/code&gt; , so the just built modules can be accessed... unless the PL file is making a module (or anything else in PM) in which case it is run &lt;b&gt;before&lt;/b&gt; pm_to_blib and does not include INST_LIB and INST_ARCH in its &lt;code&gt;@INC&lt;/code&gt; . This apparently odd behavior is there for backwards compatibility (and it's somewhat DWIM).</source>
          <target state="translated">Файлы PL обычно запускаются &lt;b&gt;после&lt;/b&gt; pm_to_blib и включают INST_LIB и INST_ARCH в свои &lt;code&gt;@INC&lt;/code&gt; , поэтому можно получить доступ к только что созданным модулям ... если файл PL не создает модуль (или что-то еще в PM), и в этом случае он запускается &lt;b&gt;до&lt;/b&gt; pm_to_blib и не включает INST_LIB и INST_ARCH в свой &lt;code&gt;@INC&lt;/code&gt; . Это явно странное поведение существует для обратной совместимости (и это в некотором роде DWIM).</target>
        </trans-unit>
        <trans-unit id="1f9b4355202a16dca9278309f8c57bab627534d7" translate="yes" xml:space="preserve">
          <source>PLANE ANGLE CONVERSIONS</source>
          <target state="translated">ПЛОСКОСТНЫЕ УГЛЫ</target>
        </trans-unit>
        <trans-unit id="397f26f7a31d1d29ed32b8ae38758d964d147496" translate="yes" xml:space="preserve">
          <source>PLATFORMS</source>
          <target state="translated">PLATFORMS</target>
        </trans-unit>
        <trans-unit id="0fcaf629ebcd1ef3b077048317114d46dcb1a205" translate="yes" xml:space="preserve">
          <source>PLUGINS</source>
          <target state="translated">PLUGINS</target>
        </trans-unit>
        <trans-unit id="96bb1ede828d06c7c676fc4aca0b2ab0fc3aaec6" translate="yes" xml:space="preserve">
          <source>POD</source>
          <target state="translated">POD</target>
        </trans-unit>
        <trans-unit id="9757efd691d77c4c7ce7af22ae0498da057b96f2" translate="yes" xml:space="preserve">
          <source>POD commands.</source>
          <target state="translated">Команды POD.</target>
        </trans-unit>
        <trans-unit id="4f47ae786af8b3ae6d44df79389191724c8e9b20" translate="yes" xml:space="preserve">
          <source>POD documentation</source>
          <target state="translated">документация POD</target>
        </trans-unit>
        <trans-unit id="e5ddb6a6721405eb11c587453e0434d2f646aa07" translate="yes" xml:space="preserve">
          <source>POD2MAN_macro</source>
          <target state="translated">POD2MAN_macro</target>
        </trans-unit>
        <trans-unit id="3bd1038b0ae3b6d74e0afdd1bb9c713c175f1f33" translate="yes" xml:space="preserve">
          <source>PODs: Embedded Documentation</source>
          <target state="translated">POD:Встроенная документация</target>
        </trans-unit>
        <trans-unit id="27d22d20fdc49ff65099906e5eeacad058aeb916" translate="yes" xml:space="preserve">
          <source>POPULATE AN INSTALLATION WITH LOTS OF MODULES</source>
          <target state="translated">ЗАПОЛНЯТЬ УСТАНОВКУ БОЛЬШИМ КОЛИЧЕСТВОМ МОДУЛЕЙ</target>
        </trans-unit>
        <trans-unit id="dfb1d5b6c2198f6b90dd9fb2aa67809b15a77598" translate="yes" xml:space="preserve">
          <source>PORTABILITY</source>
          <target state="translated">PORTABILITY</target>
        </trans-unit>
        <trans-unit id="fac926bb8a4de690e4dca18f3225a7ad2a06037c" translate="yes" xml:space="preserve">
          <source>PORTABILITY CAVEATS</source>
          <target state="translated">ПРЕДОСТЕРЕЖЕНИЯ О ПОРТАТИВНОСТИ</target>
        </trans-unit>
        <trans-unit id="eeaaaed2401766705588000c95399212adce6cd4" translate="yes" xml:space="preserve">
          <source>POS is absolute position. (Seek relative to the start of the file)</source>
          <target state="translated">POS-это абсолютная позиция.(Ищите по отношению к началу файла).</target>
        </trans-unit>
        <trans-unit id="eff46aebd5f7e19f03d6237cd80da90014c8e132" translate="yes" xml:space="preserve">
          <source>POS is an offset from the current position. (Seek relative to current)</source>
          <target state="translated">POS-это смещение от текущего положения.(Ищите по отношению к текущему)</target>
        </trans-unit>
        <trans-unit id="4a3852f381cc7917e0a6f01c96db05db1939d7a5" translate="yes" xml:space="preserve">
          <source>POS is an offset from the end of the file. (Seek relative to end)</source>
          <target state="translated">POS-это смещение от конца файла.(Ищите относительно конца)</target>
        </trans-unit>
        <trans-unit id="23507e798d66fee0b05313c2a15e15ff93e82f20" translate="yes" xml:space="preserve">
          <source>POSIX</source>
          <target state="translated">POSIX</target>
        </trans-unit>
        <trans-unit id="ae89c95fa22e7b32fa45fce7e8bf404e997e9054" translate="yes" xml:space="preserve">
          <source>POSIX - Perl interface to IEEE Std 1003.1</source>
          <target state="translated">POSIX-Perl-интерфейс к IEEE Std 1003.1</target>
        </trans-unit>
        <trans-unit id="d243eb13195dcdb315427d56a4c35f42dcb04024" translate="yes" xml:space="preserve">
          <source>POSIX CONSTANTS</source>
          <target state="translated">ПОЛОЖИТЕЛЬНЫЕ КОНСТАНТЫ</target>
        </trans-unit>
        <trans-unit id="5c9c75047d91af941801f6c6002bbc479d31b75d" translate="yes" xml:space="preserve">
          <source>POSIX Character Classes</source>
          <target state="translated">Классы персонажей POSIX</target>
        </trans-unit>
        <trans-unit id="f2d1e7de0e60a574e6d87a0cc3a67de6faf43784" translate="yes" xml:space="preserve">
          <source>POSIX FLAGS</source>
          <target state="translated">ПОЗИКСНЫЕ ФЛАГИ</target>
        </trans-unit>
        <trans-unit id="569385480ca60be76d48d613b39e1bc91f7990bf" translate="yes" xml:space="preserve">
          <source>POSIX FUNCTIONS</source>
          <target state="translated">ФУНКЦИИ ПОЗИЦИОНИРОВАНИЯ</target>
        </trans-unit>
        <trans-unit id="06b4e35ce432cb4702f6a995fe95c52f8db39c2a" translate="yes" xml:space="preserve">
          <source>POSIX character classes and their Unicode and Perl equivalents:</source>
          <target state="translated">Классы символов POSIX и их эквиваленты Unicode и Perl:</target>
        </trans-unit>
        <trans-unit id="72593fbc583aea6c901e13572f670a7d0d357161" translate="yes" xml:space="preserve">
          <source>POSIX character classes can be part of a larger bracketed character class. For example,</source>
          <target state="translated">Символьные классы POSIX могут быть частью более крупного класса символов,заключенного в скобки.Например,</target>
        </trans-unit>
        <trans-unit id="b4c2f7d57ee138ef8741ea704a671378863f20a1" translate="yes" xml:space="preserve">
          <source>POSIX character classes have the form &lt;code&gt;[:class:]&lt;/code&gt;, where</source>
          <target state="translated">Классы символов POSIX имеют вид &lt;code&gt;[:class:]&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="61668ef8f25bddd14989c415629b0df07e51f44b" translate="yes" xml:space="preserve">
          <source>POSIX functions:</source>
          <target state="translated">Функции POSIX:</target>
        </trans-unit>
        <trans-unit id="04680e6e37ce6d2dcbb31e0e8a36d7516c0e506b" translate="yes" xml:space="preserve">
          <source>POSIX-BC?</source>
          <target state="translated">POSIX-BC?</target>
        </trans-unit>
        <trans-unit id="864a3ec5736c1f231ee60dfa1ac4b3cf0adce372" translate="yes" xml:space="preserve">
          <source>POSIX.2</source>
          <target state="translated">POSIX.2</target>
        </trans-unit>
        <trans-unit id="3777385d2dd1e8926a9b75a14303ee4b22211baa" translate="yes" xml:space="preserve">
          <source>POSIX.pm</source>
          <target state="translated">POSIX.pm</target>
        </trans-unit>
        <trans-unit id="d45e49d46b986bef0fad349a44b3e4ef42953d70" translate="yes" xml:space="preserve">
          <source>POSIX::SigAction</source>
          <target state="translated">POSIX::SigAction</target>
        </trans-unit>
        <trans-unit id="74a299dde6a5128d521b652f2ba458a4da06a6a1" translate="yes" xml:space="preserve">
          <source>POSIX::SigRt</source>
          <target state="translated">POSIX::SigRt</target>
        </trans-unit>
        <trans-unit id="9cca0191c626eb89ac7a531f06862f8df3747e24" translate="yes" xml:space="preserve">
          <source>POSIX::SigSet</source>
          <target state="translated">POSIX::SigSet</target>
        </trans-unit>
        <trans-unit id="2b1f5cae0839a5eb5bae78193bd1a07008a2110c" translate="yes" xml:space="preserve">
          <source>POSIX::Termios</source>
          <target state="translated">POSIX::Termios</target>
        </trans-unit>
        <trans-unit id="fa4963cab46f1be7f819925dbfd48f68153bfc4a" translate="yes" xml:space="preserve">
          <source>POST-STRING</source>
          <target state="translated">POST-STRING</target>
        </trans-unit>
        <trans-unit id="d0012d64d9af33bc1cf8483ab0fda421fad18ba8" translate="yes" xml:space="preserve">
          <source>POSTSCRIPT</source>
          <target state="translated">POSTSCRIPT</target>
        </trans-unit>
        <trans-unit id="f581395efe2773e539af041b5a27fa1d0df00b1e" translate="yes" xml:space="preserve">
          <source>PRE-STRING</source>
          <target state="translated">PRE-STRING</target>
        </trans-unit>
        <trans-unit id="7840941760ebcd9fee13ec0f1666aa06fbb11bc3" translate="yes" xml:space="preserve">
          <source>PREAMBLE</source>
          <target state="translated">PREAMBLE</target>
        </trans-unit>
        <trans-unit id="69db2c13c51cc2aaf32e02ecde5988835599fa47" translate="yes" xml:space="preserve">
          <source>PREBUILT BINARIES OF PERL FOR SOLARIS.</source>
          <target state="translated">ПРЕДУСТАНОВЛЕННЫЕ ДВОИЧНЫЕ ФАЙЛЫ PERL ДЛЯ СОЛЯРИЕВ.</target>
        </trans-unit>
        <trans-unit id="4772fd326573fd42e768a1b15dd58bbb9cc8b317" translate="yes" xml:space="preserve">
          <source>PREFIX and LIB attribute</source>
          <target state="translated">атрибут PREFIX и LIB</target>
        </trans-unit>
        <trans-unit id="c6ea2417cccb8facb1f2ec2c030cf1e5c2fcb2f6" translate="yes" xml:space="preserve">
          <source>PREFIX and LIB can be used to set several INSTALL* attributes in one go. Here's an example for installing into your home directory.</source>
          <target state="translated">PREFIX и LIB могут быть использованы для установки нескольких атрибутов УСТАНОВКИ*за один раз.Вот пример для установки в ваш домашний каталог.</target>
        </trans-unit>
        <trans-unit id="40aa4e60b9a6d17247b06ec0bb028f55b0430593" translate="yes" xml:space="preserve">
          <source>PREFIX is the name of the SYMREF you're walking.</source>
          <target state="translated">PREFIX-это название SYMREF,который вы ходите.</target>
        </trans-unit>
        <trans-unit id="300c67e39443a38d0f595a8a987e17d646e3c291" translate="yes" xml:space="preserve">
          <source>PREFS</source>
          <target state="translated">PREFS</target>
        </trans-unit>
        <trans-unit id="9bc7b53b4ddb9c0604309a8f097387c59f61cafb" translate="yes" xml:space="preserve">
          <source>PREPARING TO USE LOCALES</source>
          <target state="translated">ПОДГОТОВКА К ИСПОЛЬЗОВАНИЮ ЛОКАЛЕЙ</target>
        </trans-unit>
        <trans-unit id="281d6f01426cc7b0d2d1be7a9e3ef9753991bf8a" translate="yes" xml:space="preserve">
          <source>PREREQUISITES</source>
          <target state="translated">PREREQUISITES</target>
        </trans-unit>
        <trans-unit id="109e7210182e5f1a38490846d4f7c1bf6d1efeaf" translate="yes" xml:space="preserve">
          <source>PREREQUISITES FOR COMPILING PERL ON CYGWIN</source>
          <target state="translated">ПРЕДПОСЫЛКИ ДЛЯ СОСТАВЛЕНИЯ ПЕРЛА НА ЦИГВИН</target>
        </trans-unit>
        <trans-unit id="d596e5c41b06e835a227eaeb7f80e95e078526da" translate="yes" xml:space="preserve">
          <source>PRIVATE METHODS AND DATA</source>
          <target state="translated">ЧАСТНЫЕ МЕТОДЫ И ДАННЫЕ</target>
        </trans-unit>
        <trans-unit id="28128cb215ccf5b12e0dff7a0c33d632bc940a28" translate="yes" xml:space="preserve">
          <source>PROBES</source>
          <target state="translated">PROBES</target>
        </trans-unit>
        <trans-unit id="9f903b4f167ea635d9adabe61a39c7254588d35a" translate="yes" xml:space="preserve">
          <source>PROCESS</source>
          <target state="translated">PROCESS</target>
        </trans-unit>
        <trans-unit id="924eaf1172c6dafd288f2618c0a1efe247bb92db" translate="yes" xml:space="preserve">
          <source>PROFILING</source>
          <target state="translated">PROFILING</target>
        </trans-unit>
        <trans-unit id="85dfd02e93a90ca8a93ed7e5af4995f7549887d0" translate="yes" xml:space="preserve">
          <source>PROFILING TOOLS</source>
          <target state="translated">ПРОФИЛИРОВОЧНЫЕ ИНСТРУМЕНТЫ</target>
        </trans-unit>
        <trans-unit id="9e3a8f7206c88ef34624181efda07f832c576870" translate="yes" xml:space="preserve">
          <source>PROGRAMMER'S INTERFACE</source>
          <target state="translated">ИНТЕРФЕЙС ПРОГРАММИСТА</target>
        </trans-unit>
        <trans-unit id="9e97d57f23d497e98a3c17e698f142751c84db81" translate="yes" xml:space="preserve">
          <source>PSEUDO RESPONSES</source>
          <target state="translated">ПСЕВДО-РЕАКЦИИ</target>
        </trans-unit>
        <trans-unit id="dd4d85a958623a5705575960b9b4ae857188fa7f" translate="yes" xml:space="preserve">
          <source>PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by openmethods.com voice solutions.</source>
          <target state="translated">PUSHCOLOR,POPCOLOR и LOCALCOLOR были дополнены голосовыми решениями openmethods.com.</target>
        </trans-unit>
        <trans-unit id="13e54ce098168f1fa1db9a288e5396806317b03b" translate="yes" xml:space="preserve">
          <source>PV</source>
          <target state="translated">PV</target>
        </trans-unit>
        <trans-unit id="4f4fc2fe1cdfbd4b127686b3c4701bfcc8bf5850" translate="yes" xml:space="preserve">
          <source>PVN</source>
          <target state="translated">PVN</target>
        </trans-unit>
        <trans-unit id="dbe7115eeb4102987d54e476c53cd399a6656a26" translate="yes" xml:space="preserve">
          <source>PVers</source>
          <target state="translated">PVers</target>
        </trans-unit>
        <trans-unit id="4db84d6ad2a10668614932a965ea5a3997c49335" translate="yes" xml:space="preserve">
          <source>Pack Recipes</source>
          <target state="translated">Упаковка Рецепты</target>
        </trans-unit>
        <trans-unit id="e5a69f2e40897b5daef39457bf875f755ff8707d" translate="yes" xml:space="preserve">
          <source>Pack and Unpack</source>
          <target state="translated">Упаковка и распаковка</target>
        </trans-unit>
        <trans-unit id="ae88d737dc553c18917f526e7ed4fab3bcf7d255" translate="yes" xml:space="preserve">
          <source>Pack and unpack can operate in two modes: character mode (&lt;code&gt;C0&lt;/code&gt; mode) where the packed string is processed per character, and UTF-8 byte mode (&lt;code&gt;U0&lt;/code&gt; mode) where the packed string is processed in its UTF-8-encoded Unicode form on a byte-by-byte basis. Character mode is the default unless the format string starts with &lt;code&gt;U&lt;/code&gt; . You can always switch mode mid-format with an explicit &lt;code&gt;C0&lt;/code&gt; or &lt;code&gt;U0&lt;/code&gt; in the format. This mode remains in effect until the next mode change, or until the end of the &lt;code&gt;()&lt;/code&gt; group it (directly) applies to.</source>
          <target state="translated">Пакетирование и распаковка могут работать в двух режимах: символьный режим (режим &lt;code&gt;C0&lt;/code&gt; ), в котором упакованная строка обрабатывается для каждого символа, и байтовый режим UTF-8 ( режим &lt;code&gt;U0&lt;/code&gt; ), где упакованная строка обрабатывается в форме Unicode в кодировке UTF-8 на на побайтовой основе. Символьный режим по умолчанию , если строка формата начинается с &lt;code&gt;U&lt;/code&gt; . Вы всегда можете переключить режим среднего формата с явным &lt;code&gt;C0&lt;/code&gt; или &lt;code&gt;U0&lt;/code&gt; в формате. Этот режим остается в силе до следующего изменения режима или до конца группы &lt;code&gt;()&lt;/code&gt; ,к которой он (напрямую) применяется.</target>
        </trans-unit>
        <trans-unit id="1557120d5088a59d57273db042de727192d13fe4" translate="yes" xml:space="preserve">
          <source>Package &lt;code&gt;overload.pm&lt;/code&gt; provides the following public functions:</source>
          <target state="translated">Пакет &lt;code&gt;overload.pm&lt;/code&gt; предоставляет следующие общедоступные функции:</target>
        </trans-unit>
        <trans-unit id="854d1d4510ef2ba36738b3c6bee00faff7d95b8e" translate="yes" xml:space="preserve">
          <source>Package Lexicals</source>
          <target state="translated">Пакет лексики</target>
        </trans-unit>
        <trans-unit id="2c11074689b7e2ad2c208b4e9d700f62e8d77364" translate="yes" xml:space="preserve">
          <source>Package for overloading Perl operations</source>
          <target state="translated">Пакет для перегрузки операций Perl</target>
        </trans-unit>
        <trans-unit id="0bb1778e3f25a2a84d101d6e9168311f3de452b1" translate="yes" xml:space="preserve">
          <source>Package lexicals declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the main block of a package using &lt;b&gt;AutoLoader&lt;/b&gt; will not be visible to auto-loaded subroutines, due to the fact that the given scope ends at the &lt;code&gt;__END__&lt;/code&gt; marker. A module using such variables as package globals will not work properly under the &lt;b&gt;AutoLoader&lt;/b&gt;.</source>
          <target state="translated">Лексические элементы пакета, объявленные с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; в основном блоке пакета, использующего &lt;b&gt;AutoLoader&lt;/b&gt; , не будут видны автоматически загружаемым подпрограммам из-за того, что данная область заканчивается на маркере &lt;code&gt;__END__&lt;/code&gt; . Модуль, использующий такие переменные, как глобальные переменные пакетов, не будет работать должным образом в &lt;b&gt;автозагрузчике&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="61fda0710845c0ff2e124df892b08c2fdc3b0249" translate="yes" xml:space="preserve">
          <source>Package names are sometimes an exception to this rule. Perl informally reserves lowercase module names for &quot;pragma&quot; modules like &lt;code&gt;integer&lt;/code&gt; and &lt;code&gt;strict&lt;/code&gt; . Other modules should begin with a capital letter and use mixed case, but probably without underscores due to limitations in primitive file systems' representations of module names as files that must fit into a few sparse bytes.</source>
          <target state="translated">Имена пакетов иногда являются исключением из этого правила. Perl неофициально резервирует имена модулей в нижнем регистре для модулей &amp;laquo;pragma&amp;raquo;, таких как &lt;code&gt;integer&lt;/code&gt; и &lt;code&gt;strict&lt;/code&gt; . Другие модули должны начинаться с заглавной буквы и использовать смешанный регистр, но, вероятно, без подчеркивания из-за ограничений в представлении примитивных файловых систем имен модулей как файлов, которые должны умещаться в несколько разреженных байтов.</target>
        </trans-unit>
        <trans-unit id="017a94912f4272ea63da9e237abc82a6ecd1cbbc" translate="yes" xml:space="preserve">
          <source>Package namespace of currently executing code.</source>
          <target state="translated">Пространство имён пакета выполняющегося в данный момент кода.</target>
        </trans-unit>
        <trans-unit id="b77eb8988a1d4f067854db5e1f2b1a7c6ddf5108" translate="yes" xml:space="preserve">
          <source>Package the module using &quot;make dist&quot;</source>
          <target state="translated">Упакуйте модуль с помощью &quot;make dist&quot;.</target>
        </trans-unit>
        <trans-unit id="dadc452bc83dd321cf9ff63134d60199b40bf1bd" translate="yes" xml:space="preserve">
          <source>Package-specific Attribute Handling</source>
          <target state="translated">Обработка конкретных атрибутов упаковки</target>
        </trans-unit>
        <trans-unit id="1b6b83de2c1ebd183fc9268fc7fc44ce0413fd67" translate="yes" xml:space="preserve">
          <source>Package/Module names are an exception to this rule. Perl informally reserves lowercase module names for 'pragma' modules like integer and strict. Other modules normally begin with a capital letter and use mixed case with no underscores (need to be short and portable).</source>
          <target state="translated">Имена пакетов/модулей являются исключением из этого правила.Perl неофициально резервирует для 'прагматических' модулей строгие и целочисленные имена модулей.Другие модули обычно начинаются с заглавной буквы и используют смешанный регистр без подчеркивания (должны быть короткими и переносимыми).</target>
        </trans-unit>
        <trans-unit id="0a999012ffb87b3edac99adbdfc498b12831a1e2" translate="yes" xml:space="preserve">
          <source>Packages</source>
          <target state="translated">Packages</target>
        </trans-unit>
        <trans-unit id="dcec9cb396ed550d472d01c925021db01eb054ef" translate="yes" xml:space="preserve">
          <source>Packages claim that there won't be errors on calls to or from packages explicitly marked as safe by inclusion in &lt;code&gt;@CARP_NOT&lt;/code&gt; , or (if that array is empty) &lt;code&gt;@ISA&lt;/code&gt; . The ability to override what @ISA says is new in 5.8.</source>
          <target state="translated">Пакеты утверждают, что не будет ошибок при вызовах пакетов или из них, явно отмеченных как безопасные путем включения в &lt;code&gt;@CARP_NOT&lt;/code&gt; или (если этот массив пуст) &lt;code&gt;@ISA&lt;/code&gt; . Возможность отменять то, что говорит @ISA, появилась в версии 5.8.</target>
        </trans-unit>
        <trans-unit id="ecc8e8a892ee953e2d150356ce7f795f7e40a13f" translate="yes" xml:space="preserve">
          <source>Packages may themselves contain package separators, as in &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . This implies nothing about the order of name lookups, however. There are no relative packages: all symbols are either local to the current package, or must be fully qualified from the outer package name down. For instance, there is nowhere within package &lt;code&gt;OUTER&lt;/code&gt; that &lt;code&gt;$INNER::var&lt;/code&gt; refers to &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . &lt;code&gt;INNER&lt;/code&gt; refers to a totally separate global package.</source>
          <target state="translated">Пакеты могут сами содержать разделители пакетов, как в &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . Однако это ничего не говорит о порядке поиска имени. Относительных пакетов нет: все символы либо локальны для текущего пакета, либо должны быть полностью определены от имени внешнего пакета вниз. Например, в пакете &lt;code&gt;OUTER&lt;/code&gt; нигде нет того, что &lt;code&gt;$INNER::var&lt;/code&gt; ссылается на &lt;code&gt;$OUTER::INNER::var&lt;/code&gt; . &lt;code&gt;INNER&lt;/code&gt; относится к совершенно отдельному глобальному пакету.</target>
        </trans-unit>
        <trans-unit id="5c700aceea5d157561b207ea0b138ca42d93986c" translate="yes" xml:space="preserve">
          <source>Packages should NOT be released with succeeding TODO tests. As soon as a TODO test starts working, it should be promoted to a normal test, and the newly working feature should be documented in the release notes or in the change log.</source>
          <target state="translated">Упаковки НЕ следует выпускать с последующими TODO-тестами.Как только TODO-тест начнет работать,его следует перевести в обычный режим,а новая работающая функция должна быть задокументирована в примечаниях к выпуску или в журнале изменений.</target>
        </trans-unit>
        <trans-unit id="f9b3a92a4e9c473029e482a2d030dd34f7fdde67" translate="yes" xml:space="preserve">
          <source>Packages such as the &lt;b&gt;AutoLoader&lt;/b&gt; and &lt;b&gt;SelfLoader&lt;/b&gt; that delay loading of subroutines within packages can create problems with package lexicals defined using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;. While the &lt;b&gt;vars&lt;/b&gt; pragma cannot duplicate the effect of package lexicals (total transparency outside of the package), it can act as an acceptable substitute by pre-declaring global symbols, ensuring their availability to the later-loaded routines.</source>
          <target state="translated">Пакеты , такие как &lt;b&gt;автозагрузки&lt;/b&gt; и &lt;b&gt;SelfLoader&lt;/b&gt; , что задержка загрузка подпрограмм в рамках пакетов может создать проблемы с пакетом лексическими , определенными с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; . Хотя прагма &lt;b&gt;vars&lt;/b&gt; не может дублировать эффект лексики пакета (полная прозрачность вне пакета), она может действовать как приемлемая замена, предварительно объявляя глобальные символы, обеспечивая их доступность для загружаемых позже подпрограмм.</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="ebd1d6c956dcaa7e80ad01427e2c132c913acd56" translate="yes" xml:space="preserve">
          <source>Packing Numbers</source>
          <target state="translated">Номера упаковки</target>
        </trans-unit>
        <trans-unit id="77ff08af8cc464aced5aa97fba37b76b1a287c76" translate="yes" xml:space="preserve">
          <source>Packing Text</source>
          <target state="translated">Текст упаковки</target>
        </trans-unit>
        <trans-unit id="1608f8af08441cd12fe9e2fbae53022489534f12" translate="yes" xml:space="preserve">
          <source>Packing and Unpacking C Structures</source>
          <target state="translated">Упаковка и распаковка конструкций C</target>
        </trans-unit>
        <trans-unit id="755fc829fa6b30f5bd0dea1183fbb4e40f383943" translate="yes" xml:space="preserve">
          <source>Packing and unpacking numbers implies conversion to and from some</source>
          <target state="translated">Упаковка и распаковка номеров подразумевает преобразование в и из некоторых</target>
        </trans-unit>
        <trans-unit id="c9cf82b43fad60a42156fab44e3aea80e40a265e" translate="yes" xml:space="preserve">
          <source>Pad Data Structures</source>
          <target state="translated">Структуры данных Pad</target>
        </trans-unit>
        <trans-unit id="a949a19a50821443871b3357ef792d3486159a28" translate="yes" xml:space="preserve">
          <source>Padre is cross-platform IDE for Perl written in Perl using wxWidgets to provide a native look and feel. It's open source under the Artistic License. It is one of the newer Perl IDEs.</source>
          <target state="translated">Padre-это кроссплатформенная IDE для Perl,написанная на Perl с использованием wxWidgets для обеспечения &quot;родного&quot; вида и ощущения.Он имеет открытый исходный код под Художественной Лицензией.Это одна из новых Perl IDE.</target>
        </trans-unit>
        <trans-unit id="e71eceb99b088c6966163f1c30b69039a2bc1008" translate="yes" xml:space="preserve">
          <source>Pairs of arguments will always be preserved in a single command, this is a heuristic for things like pm_to_blib and pod2man which work on pairs of arguments. This makes things like this safe:</source>
          <target state="translated">Пары аргументов всегда будут сохранены в одной команде,это эвристика для таких вещей,как pm_to_blib и pod2man,которые работают с парами аргументов.Это делает подобные вещи безопасными:</target>
        </trans-unit>
        <trans-unit id="6a74d0b33c52deb33630c75d846ae47130145559" translate="yes" xml:space="preserve">
          <source>Paragraph mode?</source>
          <target state="translated">Режим абзаца?</target>
        </trans-unit>
        <trans-unit id="8968f4cd8542e8f5dcc7b6c003f463e1278703a3" translate="yes" xml:space="preserve">
          <source>Parallel tests</source>
          <target state="translated">Параллельные тесты</target>
        </trans-unit>
        <trans-unit id="c5a55bab9e3352eacabd04b4af1ceaafddafe1be" translate="yes" xml:space="preserve">
          <source>Parameters are passed to the Perl subroutine using the Perl stack. This is the purpose of the code beginning with the line &lt;code&gt;dSP&lt;/code&gt; and ending with the line &lt;code&gt;PUTBACK&lt;/code&gt; . The &lt;code&gt;dSP&lt;/code&gt; declares a local copy of the stack pointer. This local copy should &lt;b&gt;always&lt;/b&gt; be accessed as &lt;code&gt;SP&lt;/code&gt; .</source>
          <target state="translated">Параметры передаются в подпрограмму Perl с использованием стека Perl. Это цель кода, который начинается строкой &lt;code&gt;dSP&lt;/code&gt; и заканчивается строкой &lt;code&gt;PUTBACK&lt;/code&gt; . &lt;code&gt;dSP&lt;/code&gt; объявляет локальную копию указателя стека. Эта локальная копия &lt;b&gt;всегда&lt;/b&gt; должна быть доступна как &lt;code&gt;SP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80783f8285e6c8c2e9ad9134ffee91ec59453e8c" translate="yes" xml:space="preserve">
          <source>Parameters for the './Build install' command? Typical frequently used setting:</source>
          <target state="translated">Параметры для команды './Build install'? Типичная часто используемая настройка:</target>
        </trans-unit>
        <trans-unit id="1d97e41da27293ace4ed2fbd57ab78ff1ca66f70" translate="yes" xml:space="preserve">
          <source>Parameters for the './Build' command? Setting might be:</source>
          <target state="translated">Параметры для команды &quot;./Строить&quot;? Установка может быть:</target>
        </trans-unit>
        <trans-unit id="f5e610dc6ea79e1fa2fc73a9c4a9f25754369b4d" translate="yes" xml:space="preserve">
          <source>Parameters for the 'make install' command? Typical frequently used setting:</source>
          <target state="translated">Параметры команды 'make install'? Типичная часто используемая настройка:</target>
        </trans-unit>
        <trans-unit id="ac5f82546938b3fb52bd2ca5918d7cd917da5ad3" translate="yes" xml:space="preserve">
          <source>Parameters for the 'make' command? Typical frequently used setting:</source>
          <target state="translated">Параметры для команды &quot;сделать&quot;? Типичная часто используемая настройка:</target>
        </trans-unit>
        <trans-unit id="2daf65e57908f6e4e34be353735de186e29fbed1" translate="yes" xml:space="preserve">
          <source>Parameters for the 'perl Build.PL' command?</source>
          <target state="translated">Параметры для команды 'perl Build.PL'?</target>
        </trans-unit>
        <trans-unit id="f2122e9ae0f9d0d393a429df01b5fba0a3936055" translate="yes" xml:space="preserve">
          <source>Parameters for the 'perl Makefile.PL' command?</source>
          <target state="translated">Параметры для команды 'perl Makefile.PL'?</target>
        </trans-unit>
        <trans-unit id="12a675963c2d259ddd1261e2417e886a181a761a" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt;</source>
          <target state="translated">Параметры, которым предшествуют &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0232bb8a39fafc143ca61d9de251f7dcdc27d0d" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords are considered to be used by the C subroutine</source>
          <target state="translated">Параметры, которым предшествуют ключевые слова &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; , считаются используемыми подпрограммой C.</target>
        </trans-unit>
        <trans-unit id="41ae2823f661f6ddef5e94291c2f12cd43c213a8" translate="yes" xml:space="preserve">
          <source>Parameters preceded by &lt;code&gt;OUTLIST&lt;/code&gt; keyword do not appear in the usage signature of the generated Perl function.</source>
          <target state="translated">Параметры, которым предшествует ключевое слово &lt;code&gt;OUTLIST&lt;/code&gt; , не появляются в сигнатуре использования сгенерированной функции Perl.</target>
        </trans-unit>
        <trans-unit id="44ce2ab75a2d568796b9a81ad9fe53a999fb4475" translate="yes" xml:space="preserve">
          <source>Parameters with C pointer types can have different semantic: C functions with similar declarations</source>
          <target state="translated">Параметры с указателями типа С могут иметь разную семантику:функции на C со схожими объявлениями</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="626558c7945f5a0bd6dde776e79591456600acd2" translate="yes" xml:space="preserve">
          <source>Params::Check</source>
          <target state="translated">Params::Check</target>
        </trans-unit>
        <trans-unit id="3c31e71b866e2be1b160d9df7e242f80a1e4ff7c" translate="yes" xml:space="preserve">
          <source>Params::Check - A generic input parsing/checking mechanism.</source>
          <target state="translated">Params::Check-Общий механизм разбора/проверки входных данных.</target>
        </trans-unit>
        <trans-unit id="8e747ae27947e13afe9efbf29825a7aff5681ea5" translate="yes" xml:space="preserve">
          <source>Params::Check can do the following things for you:</source>
          <target state="translated">Params::Check может сделать для вас следующие вещи:</target>
        </trans-unit>
        <trans-unit id="d2c3a97d4f65d97cc22a071d5d73380ed7818098" translate="yes" xml:space="preserve">
          <source>Params::Check is a generic input parsing/checking mechanism.</source>
          <target state="translated">Params::Check-это общий механизм разбора/проверки входных данных.</target>
        </trans-unit>
        <trans-unit id="0fcb11d8c3d4312636cc39b23c2f21a9a26545a6" translate="yes" xml:space="preserve">
          <source>Parrot</source>
          <target state="translated">Parrot</target>
        </trans-unit>
        <trans-unit id="f3350f0a17047f5a3aa07948204b506a6f7b873f" translate="yes" xml:space="preserve">
          <source>Parrot now uses C3</source>
          <target state="translated">Попугай теперь использует C3</target>
        </trans-unit>
        <trans-unit id="39fea3034dad6653f4f66f72da190aee39c9d313" translate="yes" xml:space="preserve">
          <source>Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">Разобрать вывод &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="864de3b696d3e06b04ffd3f5a91d959dcce58e7a" translate="yes" xml:space="preserve">
          <source>Parse Call Graph and a Grammar</source>
          <target state="translated">График разбора звонков и грамматика</target>
        </trans-unit>
        <trans-unit id="9712b394a0364a991bc67a7d52542c55240f7409" translate="yes" xml:space="preserve">
          <source>Parse META.yml and META.json CPAN metadata files</source>
          <target state="translated">Разбор файлов метаданных META.yml и META.json CPAN</target>
        </trans-unit>
        <trans-unit id="00d969b75c5246184c1f10c93d4e0b0704ad883c" translate="yes" xml:space="preserve">
          <source>Parse Pod into a simple parse tree</source>
          <target state="translated">Разобрать стручок в простое дерево для разбора.</target>
        </trans-unit>
        <trans-unit id="ce3404387b94afbebba7dec68b6b2b2a625f85c8" translate="yes" xml:space="preserve">
          <source>Parse a $file and return what $VERSION is set to by the first assignment. It will return the string &quot;undef&quot; if it can't figure out what $VERSION is. $VERSION should be for all to see, so &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt; $VERSION&lt;/code&gt; or plain $VERSION are okay, but &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt; $VERSION&lt;/code&gt; is not.</source>
          <target state="translated">Разберите файл $ и верните значение, установленное для $ VERSION при первом назначении. Он вернет строку &amp;laquo;undef&amp;raquo;, если не сможет определить, что такое $ VERSION. $ VERSION должен быть доступен всем, поэтому &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt; $VERSION&lt;/code&gt; или обычная $ VERSION подходят, а &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt; $VERSION&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="ad88342fff52b537c53c546c60e5e4da39c0d95b" translate="yes" xml:space="preserve">
          <source>Parse a Perl arithmetic expression. This may contain operators of precedence down to the bit shift operators. The expression must be followed (and thus terminated) either by a comparison or lower-precedence operator or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">Разобрать арифметическое выражение Perl.В нем могут быть операторы старшинства вплоть до операторов сдвига битов.За этим выражением (и,следовательно,оно должно быть прервано)должен следовать либо оператор сравнения,либо оператор с более низким приоритетом,либо что-то,что обычно прерывает выражение,например,точка с запятой.Если</target>
        </trans-unit>
        <trans-unit id="d13919626420ad4ba57c7f1e236f7e3f81a7aa3e" translate="yes" xml:space="preserve">
          <source>Parse a Perl list expression. This may contain operators of precedence down to the comma operator. The expression must be followed (and thus terminated) either by a low-precedence logic operator such as &lt;code&gt;or&lt;/code&gt; or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">Разберите выражение списка Perl. Это может содержать операторы приоритета вплоть до оператора запятой. За выражением должен следовать (и, следовательно, завершаться) либо логический оператор с низким приоритетом, такой как &lt;code&gt;or&lt;/code&gt; либо что-то, что обычно завершает выражение, например точка с запятой. Если</target>
        </trans-unit>
        <trans-unit id="73a31decc1f7a5c619a6729c16f491108de487bb" translate="yes" xml:space="preserve">
          <source>Parse a Perl term expression. This may contain operators of precedence down to the assignment operators. The expression must be followed (and thus terminated) either by a comma or lower-precedence operator or by something that would normally terminate an expression such as semicolon. If</source>
          <target state="translated">Разобрать выражение термина Perl.Оно может содержать операторы,имеющие приоритет вплоть до операторов присваивания.За этим выражением (и,следовательно,оно должно быть прервано)должна следовать либо запятая,либо оператор с более низким приоритетом,либо что-то,что обычно прерывает выражение,например,точка с запятой.Если</target>
        </trans-unit>
        <trans-unit id="03fd37a1b5d20bde462eaebffb2d4fbe34e1d46e" translate="yes" xml:space="preserve">
          <source>Parse a sequence of zero or more Perl statements. These may be normal imperative statements, including optional labels, or declarations that have compile-time effect, or any mixture thereof. The statement sequence ends when a closing brace or end-of-file is encountered in a place where a new statement could have validly started. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statements.</source>
          <target state="translated">Анализируйте последовательность из нуля или более операторов Perl. Это могут быть обычные императивные операторы, включая необязательные метки, или объявления, имеющие эффект времени компиляции, или любое их сочетание. Последовательность операторов заканчивается, когда закрывающая фигурная скобка или конец файла встречаются в месте, где новый оператор мог корректно начаться. Вызывающий &lt;a href=&quot;#PL_parser&quot;&gt;объект&lt;/a&gt; должен убедиться, что состояние динамического синтаксического анализатора ( PL_parser и др.) Правильно настроено для отражения источника анализируемого кода и лексического контекста для операторов.</target>
        </trans-unit>
        <trans-unit id="ce089482d2db81fc038bc61d37035494dbd4a5e7" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl code block. This consists of an opening brace, a sequence of statements, and a closing brace. The block constitutes a lexical scope, so &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables and various compile-time effects can be contained within it. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">Анализируйте один полный блок кода Perl. Он состоит из открывающей скобки, последовательности операторов и закрывающей скобки. Блок составляет лексическую область видимости, поэтому в нем могут содержаться &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; переменные и различные эффекты времени компиляции. Вызывающий &lt;a href=&quot;#PL_parser&quot;&gt;объект&lt;/a&gt; должен убедиться, что состояние динамического синтаксического анализатора ( PL_parser и др.) Правильно настроено для отражения источника кода, который будет проанализирован, и лексического контекста для оператора.</target>
        </trans-unit>
        <trans-unit id="9eba5130051b754a15b7c0146935178b7a793c12" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl expression. This allows the full expression grammar, including the lowest-precedence operators such as &lt;code&gt;or&lt;/code&gt; . The expression must be followed (and thus terminated) by a token that an expression would normally be terminated by: end-of-file, closing bracketing punctuation, semicolon, or one of the keywords that signals a postfix expression-statement modifier. If</source>
          <target state="translated">Разобрать одно полное выражение Perl. Это позволяет использовать полную грамматику выражений, включая операторы с самым низким приоритетом, такие как &lt;code&gt;or&lt;/code&gt; . За выражением должен следовать (и, таким образом, завершаться) токен, который обычно завершается выражением: конец файла, закрывающая скобка пунктуации, точка с запятой или одно из ключевых слов, которые сигнализируют о постфиксном модификаторе выражения-выражения. Если</target>
        </trans-unit>
        <trans-unit id="58f6019da7384a5fca463ab30964f465a7e74317" translate="yes" xml:space="preserve">
          <source>Parse a single complete Perl statement. This may be a normal imperative statement or a declaration that has compile-time effect, and may include optional labels. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">Разберите один полный оператор Perl. Это может быть обычный императивный оператор или объявление, которое имеет эффект времени компиляции и может включать необязательные метки. Вызывающий &lt;a href=&quot;#PL_parser&quot;&gt;объект&lt;/a&gt; должен убедиться, что состояние динамического синтаксического анализатора ( PL_parser и др.) Правильно настроено для отражения источника кода, который будет проанализирован, и лексического контекста для оператора.</target>
        </trans-unit>
        <trans-unit id="47cabbfacc2ecefb926eabaa7917ccc6eda5e749" translate="yes" xml:space="preserve">
          <source>Parse a single label, possibly optional, of the type that may prefix a Perl statement. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed. If</source>
          <target state="translated">Анализируйте одну метку, возможно, необязательную, типа, которая может предшествовать оператору Perl. Вызывающий &lt;a href=&quot;#PL_parser&quot;&gt;объект&lt;/a&gt; должен убедиться, что состояние динамического синтаксического анализатора ( PL_parser и др.) Правильно настроено для отражения источника кода, который необходимо проанализировать. Если</target>
        </trans-unit>
        <trans-unit id="2760bb775d2f5ac01c987fbbfc94d63c9c899e62" translate="yes" xml:space="preserve">
          <source>Parse a single unadorned Perl statement. This may be a normal imperative statement or a declaration that has compile-time effect. It does not include any label or other affixture. It is up to the caller to ensure that the dynamic parser state (&lt;a href=&quot;#PL_parser&quot;&gt;PL_parser&lt;/a&gt; et al) is correctly set to reflect the source of the code to be parsed and the lexical context for the statement.</source>
          <target state="translated">Разберите единственный оператор Perl без украшений. Это может быть обычное императивное утверждение или объявление, имеющее эффект времени компиляции. Он не включает никаких этикеток или других приспособлений. Вызывающий &lt;a href=&quot;#PL_parser&quot;&gt;объект&lt;/a&gt; должен убедиться, что состояние динамического синтаксического анализатора ( PL_parser и др.) Правильно настроено для отражения источника кода, который будет проанализирован, и лексического контекста для оператора.</target>
        </trans-unit>
        <trans-unit id="7c6f184ce547c8aba43670b279e40b0257db5871" translate="yes" xml:space="preserve">
          <source>Parse an L&amp;lt;&amp;gt; formatting code in POD text</source>
          <target state="translated">Разобрать код форматирования L &amp;lt;&amp;gt; в тексте POD</target>
        </trans-unit>
        <trans-unit id="e36fba2ce293e9dd2d7ccd39cdd6da710089a942" translate="yes" xml:space="preserve">
          <source>Parse and process a file with pod in it:</source>
          <target state="translated">Разобрать и обработать файл с pod в нем:</target>
        </trans-unit>
        <trans-unit id="95c795a721b662a23c96150509b7defee01aa093" translate="yes" xml:space="preserve">
          <source>Parse file paths into directory, filename and suffix.</source>
          <target state="translated">Разобрать пути к файлам в каталоге,имя файла и суффикс.</target>
        </trans-unit>
        <trans-unit id="7ef71ab4754324a2f907d13e0118b212e436f9d9" translate="yes" xml:space="preserve">
          <source>Parse text into an array of tokens or array of arrays</source>
          <target state="translated">Разбор текста в массиве токенов или массиве массивов</target>
        </trans-unit>
        <trans-unit id="8f66dc0790859dd1eeb3a917210e58e38ca209e0" translate="yes" xml:space="preserve">
          <source>Parse::CPAN::Meta</source>
          <target state="translated">Parse::CPAN::Meta</target>
        </trans-unit>
        <trans-unit id="14f134b3af22420beae12cee1984569fcb79b734" translate="yes" xml:space="preserve">
          <source>Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files</source>
          <target state="translated">Parse::CPAN::Meta-Parse META.yml и META.json Файлы метаданных CPAN</target>
        </trans-unit>
        <trans-unit id="fe64ba8660ae82053a168a558e1390828e9d75c0" translate="yes" xml:space="preserve">
          <source>Parse::RecDescent uses &lt;code&gt;extract_codeblock($text, '{}&amp;lt;&amp;gt;')&lt;/code&gt; to extract the code within the &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; directive, but there's a problem.</source>
          <target state="translated">Parse :: RecDescent использует &lt;code&gt;extract_codeblock($text, '{}&amp;lt;&amp;gt;')&lt;/code&gt; для извлечения кода в директиве &lt;code&gt;&amp;lt;defer:...&amp;gt;&lt;/code&gt; , но возникает проблема.</target>
        </trans-unit>
        <trans-unit id="418d1a5bd76755f2c0308bd1eebe8bb8f1bdc41d" translate="yes" xml:space="preserve">
          <source>Parser Components</source>
          <target state="translated">Компоненты парсера</target>
        </trans-unit>
        <trans-unit id="fe2f07bac5eb2fe04d3c37f8f55ba8daadac0f8d" translate="yes" xml:space="preserve">
          <source>Parses a string containing a valid YAML stream into a list of Perl data structures.</source>
          <target state="translated">Разбирает строку,содержащую действительный поток YAML в список структур данных Perl.</target>
        </trans-unit>
        <trans-unit id="581e381893d5cec0eef75cd617fe11072fd60c0d" translate="yes" xml:space="preserve">
          <source>Parses from &lt;code&gt;$source&lt;/code&gt; file to &lt;code&gt;$to&lt;/code&gt; file. Similar to &lt;a href=&quot;parser#parse_from_file&quot;&gt;parse_from_file in Pod::Parser&lt;/a&gt;.</source>
          <target state="translated">Разбирает из &lt;code&gt;$source&lt;/code&gt; файла в &lt;code&gt;$to&lt;/code&gt; файл. Аналогично &lt;a href=&quot;parser#parse_from_file&quot;&gt;parse_from_file в Pod :: Parser&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="092f1e46c6bd81566c97fcc512b18db5d5c4aab0" translate="yes" xml:space="preserve">
          <source>Parses the uri and creates a corresponding File::Fetch::Item object, that is ready to be &lt;code&gt;fetch&lt;/code&gt; ed and returns it.</source>
          <target state="translated">Анализирует uri и создает соответствующий объект File :: Fetch :: Item, который готов к &lt;code&gt;fetch&lt;/code&gt; и возвращает его.</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="201a7c8f517e70abce0e1a757b9f06ab6e1eaa4c" translate="yes" xml:space="preserve">
          <source>Parsing complications</source>
          <target state="translated">Осложнения при разборе</target>
        </trans-unit>
        <trans-unit id="56105dfe20714874a2e829f3d18d1b5e096635b7" translate="yes" xml:space="preserve">
          <source>Parsing for construction</source>
          <target state="translated">Разборка для строительства</target>
        </trans-unit>
        <trans-unit id="60d12b966804dcb52fae0aab613b1970bacceb22" translate="yes" xml:space="preserve">
          <source>Parsing for size</source>
          <target state="translated">Разбор размера</target>
        </trans-unit>
        <trans-unit id="80341dac319c1b5410ead916b5a70b09b9ef0f4d" translate="yes" xml:space="preserve">
          <source>Parsing harness related environmental variables where appropriate</source>
          <target state="translated">Анализ использования соответствующих экологических переменных там,где это целесообразно</target>
        </trans-unit>
        <trans-unit id="f5b02e670994bc090c4464c23b48f3c45762f6da" translate="yes" xml:space="preserve">
          <source>Parsing is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;. For backward compatibility, links where there is no section and name contains spaces, or links where the entirety of the link (except for the anchor text if given) is enclosed in double-quotes are interpreted as links to a section (L&amp;lt;/section&amp;gt;).</source>
          <target state="translated">Парсинг реализован на &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; . Для обратной совместимости ссылки, в которых нет раздела и имя содержит пробелы, или ссылки, в которых вся ссылка (кроме текста привязки, если он указан) заключена в двойные кавычки, интерпретируются как ссылки на раздел (L &amp;lt;/ section &amp;gt;).</target>
        </trans-unit>
        <trans-unit id="21fec48dc32ed2c2c516a7d00eccd1fc2dbbf7ca" translate="yes" xml:space="preserve">
          <source>Parsing of the &lt;code&gt;#!&lt;/code&gt; switches starts wherever &quot;perl&quot; is mentioned in the line. The sequences &quot;-*&quot; and &quot;- &quot; are specifically ignored so that you could, if you were so inclined, say</source>
          <target state="translated">Разбор файла &lt;code&gt;#!&lt;/code&gt; переключатели запускаются там, где в строке упоминается &quot;perl&quot;. Последовательности &amp;laquo;- *&amp;raquo; и &amp;laquo;-&amp;raquo; специально игнорируются, чтобы вы могли, если бы вы были так склонны, сказать</target>
        </trans-unit>
        <trans-unit id="f4a66fb666677831fbb89c4617c9cb55023dbd3e" translate="yes" xml:space="preserve">
          <source>Parsing of the bracketed character class construct, &lt;code&gt;[...]&lt;/code&gt; , is rather different than the rule used for the rest of the pattern. The terminator of this construct is found using the same rules as for finding the terminator of a &lt;code&gt;{}&lt;/code&gt; -delimited construct, the only exception being that &lt;code&gt;]&lt;/code&gt; immediately following &lt;code&gt;[&lt;/code&gt; is treated as though preceded by a backslash.</source>
          <target state="translated">Разбор конструкции класса символов в квадратных скобках &lt;code&gt;[...]&lt;/code&gt; несколько отличается от правила, используемого для остальной части шаблона. Терминатор этой конструкции находится с использованием тех же правил, что и терминатор &lt;code&gt;{}&lt;/code&gt; -ограниченной конструкции, за исключением того, что &lt;code&gt;]&lt;/code&gt; сразу после &lt;code&gt;[&lt;/code&gt; обрабатывается так, как если бы ему предшествовала обратная косая черта.</target>
        </trans-unit>
        <trans-unit id="73445354eb44bc4201e65870d8cf75c662a12338" translate="yes" xml:space="preserve">
          <source>Parsing options from an arbitrary array</source>
          <target state="translated">Опции разбора из произвольного массива</target>
        </trans-unit>
        <trans-unit id="7c23dc7bccdc54b6af40c30891098a1ec3018d31" translate="yes" xml:space="preserve">
          <source>Parsing options from an arbitrary string</source>
          <target state="translated">Опции разбора произвольной строки</target>
        </trans-unit>
        <trans-unit id="fae1cc5f61c39d7ca25192b6ad11336a46da6cc3" translate="yes" xml:space="preserve">
          <source>Part 1: The basics</source>
          <target state="translated">Часть 1:Основы</target>
        </trans-unit>
        <trans-unit id="0ef5ae5e92fc124e5a59c33d1478fa00e49ca98c" translate="yes" xml:space="preserve">
          <source>Part 2: Power tools</source>
          <target state="translated">Часть 2:Электроинструменты</target>
        </trans-unit>
        <trans-unit id="67d014ca4761f29f2d21414f531603a8e6bec46f" translate="yes" xml:space="preserve">
          <source>Pass an undef value to disable it:</source>
          <target state="translated">Передайте неопределенное значение,чтобы отключить его:</target>
        </trans-unit>
        <trans-unit id="6c2219e935754aed07fd99bb89a0b43879d2aa88" translate="yes" xml:space="preserve">
          <source>Pass arrays and hashes by reference, not by value. For one thing, it's the only way to pass multiple lists or hashes (or both) in a single call/return. It also avoids creating a copy of all the contents. This requires some judgement, however, because any changes will be propagated back to the original data. If you really want to mangle (er, modify) a copy, you'll have to sacrifice the memory needed to make one.</source>
          <target state="translated">Передавайте массивы и хэши по ссылке,а не по значению.Во-первых,это единственный способ передать несколько списков или хэшей (или оба)в одном вызове/отзыве.Это также позволяет избежать создания копии всего содержимого.Однако,это требует некоторого суждения,так как любые изменения будут распространяться обратно на исходные данные.Если вы действительно хотите изменить (э-э,модифицировать)копию,вам придется пожертвовать памятью,необходимой для ее создания.</target>
        </trans-unit>
        <trans-unit id="0faa9975944d7d7c5896c953cdfdaa9399cd924e" translate="yes" xml:space="preserve">
          <source>Pass arrays as references so more parameters can be added later (it's also faster). Convert functions into methods where appropriate. Split large methods into smaller more flexible ones. Inherit methods from other modules if appropriate.</source>
          <target state="translated">Передавайте массивы в качестве ссылок,чтобы позже можно было добавить больше параметров (это также быстрее).Преобразовывать функции в методы там,где это необходимо.Разбивать большие методы на более гибкие.Наследовать методы от других модулей,если это уместно.</target>
        </trans-unit>
        <trans-unit id="7d95906c33f61c39cf91fb90166084e4d01776d3" translate="yes" xml:space="preserve">
          <source>Pass by Reference</source>
          <target state="translated">Пройти по ссылке</target>
        </trans-unit>
        <trans-unit id="053ad74d06c8d9f5eb6073c958d95571ac0cf875" translate="yes" xml:space="preserve">
          <source>Pass-through options</source>
          <target state="translated">Сквозные варианты</target>
        </trans-unit>
        <trans-unit id="b99c51ad09b3295fb732520f288da663a4c77836" translate="yes" xml:space="preserve">
          <source>Passed in implicitly via standard input. This works only if there are no filename arguments--to pass arguments to a STDIN-read program you must explicitly specify a &quot;-&quot; for the program name.</source>
          <target state="translated">Проходит неявно через стандартный вход.Это работает только в случае отсутствия аргументов-имя файла-для передачи аргументов в программу,читаемую по STDIN,необходимо явно указать &quot;-&quot; для имени программы.</target>
        </trans-unit>
        <trans-unit id="c1dfda537026966c5e1e28098e3760a352bbbd9e" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;$hash{ 'foo' }&lt;/code&gt; to a subroutine used to be a special case, though. Since you could assign directly to &lt;code&gt;$_[0]&lt;/code&gt; , Perl had to be ready to make that assignment so it created the hash key ahead of time:</source>
          <target state="translated">Однако передача &lt;code&gt;$hash{ 'foo' }&lt;/code&gt; в подпрограмму была особым случаем. Поскольку вы могли назначить непосредственно &lt;code&gt;$_[0]&lt;/code&gt; , Perl должен был быть готов сделать это назначение, чтобы заранее создать хэш-ключ:</target>
        </trans-unit>
        <trans-unit id="5c25d01562076258933dad64551143b78c5bd332" translate="yes" xml:space="preserve">
          <source>Passing NULL for SV creates a constant sub equivalent to &lt;code&gt;sub BAR () {}&lt;/code&gt; , which won't be called if used as a destructor, but will suppress the overhead of a call to &lt;code&gt;AUTOLOAD&lt;/code&gt; . (This form, however, isn't eligible for inlining at compile time.)</source>
          <target state="translated">Передача NULL для SV создает постоянный субэквивалент &lt;code&gt;sub BAR () {}&lt;/code&gt; , который не будет вызываться, если используется в качестве деструктора, но подавит накладные расходы на вызов &lt;code&gt;AUTOLOAD&lt;/code&gt; . (Однако эта форма не подходит для встраивания во время компиляции.)</target>
        </trans-unit>
        <trans-unit id="92e7a89cda780976fa2b2bf15b8fa16940c9e791" translate="yes" xml:space="preserve">
          <source>Passing Parameters</source>
          <target state="translated">Параметры прохождения</target>
        </trans-unit>
        <trans-unit id="631e829d46dd7a132eee37564669347bda1fdeb4" translate="yes" xml:space="preserve">
          <source>Passing Symbol Table Entries (typeglobs)</source>
          <target state="translated">Записи в таблице передаваемых символов (печатные шрифты)</target>
        </trans-unit>
        <trans-unit id="9c282987a3e4a9c1f484c40c67cee6ec02907f83" translate="yes" xml:space="preserve">
          <source>Passing a true value for &lt;code&gt;$no_file&lt;/code&gt; indicates that the path being split only contains directory components, even on systems where you can usually (when not supporting a foreign syntax) tell the difference between directories and files at a glance.</source>
          <target state="translated">Передача истинного значения для &lt;code&gt;$no_file&lt;/code&gt; указывает на то, что разделяемый путь содержит только компоненты каталогов, даже в системах, где вы обычно (без поддержки чужого синтаксиса) можете сразу определить разницу между каталогами и файлами.</target>
        </trans-unit>
        <trans-unit id="57e7c7fde542cf4bbfc2454d2a7557dc31e803b8" translate="yes" xml:space="preserve">
          <source>Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references, making it equivalent to calling &lt;code&gt;list_files&lt;/code&gt; without arguments.</source>
          <target state="translated">Передача ссылки на массив, содержащей только один элемент, &amp;laquo;имя&amp;raquo;, имеет специальный корпус для возврата списка имен, а не списка хеш-ссылок, что делает его эквивалентным вызову &lt;code&gt;list_files&lt;/code&gt; без аргументов.</target>
        </trans-unit>
        <trans-unit id="33e2edde52cbb4ec756e8a81aaf676fa8eab3f52" translate="yes" xml:space="preserve">
          <source>Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references.</source>
          <target state="translated">Передача ссылки на массив,содержащий только один элемент,'name',имеет специальный корпус для возврата списка имён,а не списка хэш-ссылок.</target>
        </trans-unit>
        <trans-unit id="73e454c3c193b2c18919a57428be215c94732d74" translate="yes" xml:space="preserve">
          <source>Passing an empty string &quot;&quot; as the first argument to &lt;code&gt;catdir()&lt;/code&gt; is like passing&lt;code&gt;File::Spec-&amp;gt;rootdir()&lt;/code&gt; as the first argument, i.e.</source>
          <target state="translated">Передача пустой строки &quot;&quot; в качестве первого аргумента функции &lt;code&gt;catdir()&lt;/code&gt; аналогична передаче &lt;code&gt;File::Spec-&amp;gt;rootdir()&lt;/code&gt; в качестве первого аргумента, т.е.</target>
        </trans-unit>
        <trans-unit id="d6de5b84e84c7ec759c47090ea234e479eb3f3b2" translate="yes" xml:space="preserve">
          <source>Passing array/hash refs that contain objects may not work for Perl prior to 5.10.0.</source>
          <target state="translated">Передача массива/хэша ссылок,содержащих объекты,может не работать для Perl до 5.10.0.</target>
        </trans-unit>
        <trans-unit id="778d28f8a8c46b422aec9c2654919755f059cdd6" translate="yes" xml:space="preserve">
          <source>Passing new options to the $walker is the easiest way to change amongst any pre-defined styles (the ones you add are automatically recognized as options), and is the only way to alter rendering order without calling compile again. Note however that rendering state is still shared amongst multiple $walker objects, so they must still be used in a coordinated manner.</source>
          <target state="translated">Передача новых опций в $walker-это самый простой способ изменения среди всех предопределенных стилей (те,которые вы добавляете,автоматически распознаются как опции),и это единственный способ изменить порядок отрисовки без повторного вызова компиляции.Обратите внимание,однако,что состояние рендеринга все еще разделяется между несколькими объектами $walker,поэтому они все равно должны использоваться согласованным образом.</target>
        </trans-unit>
        <trans-unit id="000338825dc1ad597f0654c697650b0c505e9d75" translate="yes" xml:space="preserve">
          <source>Passing objects on queues may not work if the objects' classes do not support sharing. See &lt;a href=&quot;../threads/shared#BUGS-AND-LIMITATIONS&quot;&gt;BUGS AND LIMITATIONS in threads::shared&lt;/a&gt; for more.</source>
          <target state="translated">Передача объектов в очередях может не работать, если классы объектов не поддерживают совместное использование. Подробнее см. &lt;a href=&quot;../threads/shared#BUGS-AND-LIMITATIONS&quot;&gt;ОШИБКИ И ОГРАНИЧЕНИЯ в потоках :: shared&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b55ad2737b0f246adb41a25f43c9856e1465d7d3" translate="yes" xml:space="preserve">
          <source>Passing only one of the first two elements as &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is equivalent to passing a 0 and will not have the effect described when both are &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This also triggers an uninitialized warning.</source>
          <target state="translated">Передача только одного из первых двух элементов в качестве &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; эквивалентна передаче 0 и не будет иметь эффекта, описанного, когда оба являются &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Это также вызывает неинициализированное предупреждение.</target>
        </trans-unit>
        <trans-unit id="816c2ea902ef30f358f592af797150423983b160" translate="yes" xml:space="preserve">
          <source>Passing only one of the first two elements as &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is equivalent to passing a 0 and will not have the effect described when both are &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This also triggers an uninitialized warning.</source>
          <target state="translated">Передача только одного из первых двух элементов в качестве &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; эквивалентна передаче 0 и не будет иметь эффекта, описанного, когда оба являются &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Это также вызывает неинициализированное предупреждение.</target>
        </trans-unit>
        <trans-unit id="ff65b3fe44892512aa53628ad3cbe12f9d7ca3ec" translate="yes" xml:space="preserve">
          <source>Passing the tied object to &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Передача завязанного предмета на &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ec73bc8762feb2e3028dbf252686e023bd6e19" translate="yes" xml:space="preserve">
          <source>Past contributions from: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Предыдущие материалы от: brian d &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Адриано Р. Феррейра &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Шона М. Берка &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c5e8c22064e37b00fe594c59a2558cd9b22cdd1" translate="yes" xml:space="preserve">
          <source>Past contributions from: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ; Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; ; significant portions copied from</source>
          <target state="translated">Предыдущие материалы от: brian d &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Адриано Р. Феррейра &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; ; Шон М. Берк &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; ; значительные части скопированы из</target>
        </trans-unit>
        <trans-unit id="b20a451c29c9cea2e46c19630395de2df6f76e08" translate="yes" xml:space="preserve">
          <source>Past contributors are: brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Adriano R. Ferreira &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Sean M. Burke &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; , Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafcol.lafayette.edu&amp;gt;&lt;/code&gt; , and many others.</source>
          <target state="translated">Предыдущие участники: Брайан Д &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; Адриано Р. Феррейра &lt;code&gt;&amp;lt;ferreira@cpan.org&amp;gt;&lt;/code&gt; , Шон М. Берк &lt;code&gt;&amp;lt;sburke@cpan.org&amp;gt;&lt;/code&gt; , Кеннет Альбановски &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Энди Догерти &lt;code&gt;&amp;lt;doughera@lafcol.lafayette.edu&amp;gt;&lt;/code&gt; и многие другие.</target>
        </trans-unit>
        <trans-unit id="5b790410ca6021f643b25dc0684b80c6ac035a6f" translate="yes" xml:space="preserve">
          <source>Patch style</source>
          <target state="translated">Стиль патч</target>
        </trans-unit>
        <trans-unit id="e616d246e566a6e437d4992af55f91c42a43620c" translate="yes" xml:space="preserve">
          <source>Patch, extend or subclass an existing module where possible</source>
          <target state="translated">Патч,расширение или подкласс существующего модуля,где это возможно.</target>
        </trans-unit>
        <trans-unit id="57bddba1c66e0b8fdc9d892c78bfc22f25c546f6" translate="yes" xml:space="preserve">
          <source>Patches against Pod::Simple are welcome. Please send bug reports to &amp;lt;bug-pod-simple@rt.cpan.org&amp;gt;.</source>
          <target state="translated">Патчи против Pod :: Simple приветствуются. Отправляйте отчеты об ошибках на &amp;lt;bug-pod-simple@rt.cpan.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="139936b1a9a84a97721c26af3e777c3a03af1e6f" translate="yes" xml:space="preserve">
          <source>Patches are reviewed and discussed on the p5p list. Simple, uncontroversial patches will usually be applied without any discussion. When the patch is applied, the ticket will be updated and you will receive email. In addition, an email will be sent to the p5p list.</source>
          <target state="translated">Патчи рассматриваются и обсуждаются в списке p5p.Простые,неконтролируемые патчи обычно применяются без обсуждения.Когда патч будет применен,билет будет обновлен,и вы получите письмо по электронной почте.Кроме того,по электронной почте будет отправлено письмо в p5p-лист.</target>
        </trans-unit>
        <trans-unit id="f960f4eadeba1dd57f417d470c8e32c7459acc42" translate="yes" xml:space="preserve">
          <source>Patches may be applied by the pumpkin holder without the explicit cooperation of the module author if and only if they are very minor, time-critical in some fashion (such as urgent security fixes), or if the module author cannot be reached. Those patches must still be given back to the author when possible, and if the author decides on an alternate fix in their version, that fix should be strongly preferred unless there is a serious problem with it. Any changes not endorsed by the author should be marked as such, and the contributor of the change acknowledged.</source>
          <target state="translated">Заплатки могут быть применены держателем тыквы без явного сотрудничества с автором модуля,если и только в том случае,если они очень незначительны,критичны по времени в какой-то мере (например,срочные меры безопасности),или если автор модуля не может связаться с ним.Эти исправления все равно должны быть возвращены автору,когда это возможно,и если автор решает альтернативное исправление в своей версии,то это исправление должно быть предпочтительным,если только с ним нет серьезных проблем.Любые изменения,не одобренные автором,должны быть отмечены как таковые,а вкладчик изменения должен быть признан.</target>
        </trans-unit>
        <trans-unit id="bb89b691c1294b8ada4f9cd31a429e4caf872c3f" translate="yes" xml:space="preserve">
          <source>Patches speak louder than words</source>
          <target state="translated">Патчи говорят громче,чем слова</target>
        </trans-unit>
        <trans-unit id="d54931049c09c712e0cbea3d090e4d3b4a105c0b" translate="yes" xml:space="preserve">
          <source>Patches that add new warnings or errors or deprecate features.</source>
          <target state="translated">Патчи,которые добавляют новые предупреждения или ошибки или ухудшают характеристики.</target>
        </trans-unit>
        <trans-unit id="29abf1c3bbb8c54b1cd55ff655f670f9ebc399ee" translate="yes" xml:space="preserve">
          <source>Patches that add or remove features.</source>
          <target state="translated">Патчи,которые добавляют или удаляют функции.</target>
        </trans-unit>
        <trans-unit id="f84461a4c1a5b5e429209771f4e83af6717ee46b" translate="yes" xml:space="preserve">
          <source>Patches that break binary compatibility. (Please talk to a pumpking.)</source>
          <target state="translated">Понял,что нарушает бинарную совместимость.(Пожалуйста,поговорите с насосом.)</target>
        </trans-unit>
        <trans-unit id="323fd112f38ff019a7ad9800eabd680b9a815934" translate="yes" xml:space="preserve">
          <source>Patches that fix CVEs or security issues. These changes should be run through the perl5-security-report@perl.org mailing list rather than applied directly.</source>
          <target state="translated">Патчи,которые исправляют CVE или проблемы с безопасностью.Эти изменения должны быть запущены через список рассылки perl5-security-report@perl.org,а не применены напрямую.</target>
        </trans-unit>
        <trans-unit id="f0910db599c5e57f13f342f2401ca7baceb18c00" translate="yes" xml:space="preserve">
          <source>Patches that fix anything which prevents or seriously impacts the build or installation of perl.</source>
          <target state="translated">Замки,которые фиксируют все,что предотвращает или серьезно влияет на сборку или установку perl.</target>
        </trans-unit>
        <trans-unit id="21130596c95c32860a5fe99dde40cbc8202f1859" translate="yes" xml:space="preserve">
          <source>Patches that fix crashing bugs, assertion failures and memory corruption but which do not otherwise change perl's functionality or negatively impact performance.</source>
          <target state="translated">Патчи,которые исправляют сбои в работе,ошибки утверждения и повреждения памяти,но которые не изменяют функциональность perl и не оказывают отрицательного влияния на производительность.</target>
        </trans-unit>
        <trans-unit id="c95c81109a9edefb7a99fa1792240b1c8c4accc7" translate="yes" xml:space="preserve">
          <source>Patches that fix regressions in perl's behavior relative to previous releases, no matter how old the regression, since some people may upgrade from very old versions of perl to the latest version.</source>
          <target state="translated">Патчи,которые исправляют регрессии в поведении perl по сравнению с предыдущими релизами,независимо от того,сколько лет регрессии,так как некоторые люди могут обновляться с очень старых версий perl до последней версии.</target>
        </trans-unit>
        <trans-unit id="93c3b06e57a98513617dbda85f73638d28687b18" translate="yes" xml:space="preserve">
          <source>Patches which change behaviour (fixing bugs or introducing new features) must include regression tests to verify that everything works as expected.</source>
          <target state="translated">Патчи,которые изменяют поведение (исправление ошибок или введение новых возможностей)должны включать регрессионные тесты,чтобы проверить,что все работает,как ожидается.</target>
        </trans-unit>
        <trans-unit id="8270f0c679e10266c6a9f82f5a4c89d2c3cc697e" translate="yes" xml:space="preserve">
          <source>Patches without documentation are probably ill-thought out or incomplete. No features can be added or changed without documentation, so submitting a patch for the appropriate pod docs as well as the source code is important.</source>
          <target state="translated">Патчи без документации,вероятно,плохо продуманы или неполны.Никакие функции не могут быть добавлены или изменены без документации,поэтому предоставление патча для соответствующих pod docs,а также исходного кода важно.</target>
        </trans-unit>
        <trans-unit id="e27ae82b9a6b018ee112b21851652cbe49271b3b" translate="yes" xml:space="preserve">
          <source>Patching a core module</source>
          <target state="translated">Подключение основного модуля</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="0b1fe397674f2ea0ca0d83a858144940f7da6b34" translate="yes" xml:space="preserve">
          <source>Patterns are implicitly anchored at the beginning and end of each string when testing for a match.</source>
          <target state="translated">При тестировании на соответствие шаблоны неявно привязываются к началу и концу каждой строки.</target>
        </trans-unit>
        <trans-unit id="d223d697e7957195cfa22daa9019ad4f989b3028" translate="yes" xml:space="preserve">
          <source>Patterns are subject to an additional level of interpretation as a regular expression. This is done as a second pass, after variables are interpolated, so that regular expressions may be incorporated into the pattern from the variables. If this is not what you want, use &lt;code&gt;\Q&lt;/code&gt; to interpolate a variable literally.</source>
          <target state="translated">Шаблоны подвергаются дополнительному уровню интерпретации как регулярное выражение. Это делается во втором проходе после интерполяции переменных, так что регулярные выражения могут быть включены в шаблон из переменных. Если это не то, что вам нужно, используйте &lt;code&gt;\Q&lt;/code&gt; для буквальной интерполяции переменной.</target>
        </trans-unit>
        <trans-unit id="e23f050b63735be39db7dcbaa09bfdd36470f510" translate="yes" xml:space="preserve">
          <source>Patterns of the form /#\d/ will be replaced with the</source>
          <target state="translated">Шаблоны формы /#\d/будут заменены на</target>
        </trans-unit>
        <trans-unit id="657c59b79c5dc51478a7a404f0af13b53b988447" translate="yes" xml:space="preserve">
          <source>Paul Green (Paul.Green@stratus.com)</source>
          <target state="translated">Пол Грин (Paul.Green@stratus.com)</target>
        </trans-unit>
        <trans-unit id="7bea737592f1b2469295059802a7399af95a087a" translate="yes" xml:space="preserve">
          <source>Paul Marquess</source>
          <target state="translated">Поль Маркес</target>
        </trans-unit>
        <trans-unit id="1da5f372b188cb5eeeeafb09b1f0a31fca9b993f" translate="yes" xml:space="preserve">
          <source>Paul Marquess &amp;lt;Paul.Marquess@btinternet.com&amp;gt;</source>
          <target state="translated">Поль Маркиз &amp;lt;Paul.Marquess@btinternet.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4fbcf625afc3d507d379cacdea04bbc6b875a1d5" translate="yes" xml:space="preserve">
          <source>Paul Marquess &amp;lt;pmqs@cpan.org&amp;gt;</source>
          <target state="translated">Пол Маркиз &amp;lt;pmqs@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c4337beb0e4af629844f1525d967a958a8d53fbd" translate="yes" xml:space="preserve">
          <source>Paul Marquess pmqs@cpan.org</source>
          <target state="translated">Поль Маркес pmqs@cpan.org</target>
        </trans-unit>
        <trans-unit id="914e119a6f7c68c285bad290780b5645e4c2e6e0" translate="yes" xml:space="preserve">
          <source>Paul Szabo identified the race condition originally, and Brendan O'Dea wrote an implementation for Debian that addressed the problem. That code was used as a basis for the current code. Their efforts are greatly appreciated.</source>
          <target state="translated">Пол Сабо (Paul Szabo)изначально определил состояние гонки,а Brendan O'Dea написал для Debian реализацию,которая решала эту проблему.Этот код был использован в качестве основы для текущего кода.Их усилия высоко оценены.</target>
        </trans-unit>
        <trans-unit id="37c56bd6f44f98356093abe0640820d8fc0e4efe" translate="yes" xml:space="preserve">
          <source>Pay a special attention to the function &lt;code&gt;constant&lt;/code&gt; . This name appears twice in the generated .xs file: once in the first part, as a static C function, then another time in the second part, when an XSUB interface to this static C function is defined.</source>
          <target state="translated">Обратите особое внимание на &lt;code&gt;constant&lt;/code&gt; функции . Это имя появляется дважды в сгенерированном файле .xs: один раз в первой части как статическая функция C, затем еще раз во второй части, когда определен интерфейс XSUB для этой статической функции C.</target>
        </trans-unit>
        <trans-unit id="fd86f5fbb7a13e213f07f240ee7591f9616574c1" translate="yes" xml:space="preserve">
          <source>Pay careful attention to the next example:</source>
          <target state="translated">Обратите внимание на следующий пример:</target>
        </trans-unit>
        <trans-unit id="8629c3dd5ba30eee7c4ac6064407b780f19df3f6" translate="yes" xml:space="preserve">
          <source>Pay special attention to &lt;a href=&quot;#METHODS-FOR-PARSING-AND-PROCESSING&quot;&gt;METHODS FOR PARSING AND PROCESSING&lt;/a&gt; and to the objects described in &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt;. The former describes the gory details and parameters for how to customize and extend the parsing behavior of &lt;b&gt;Pod::Parser&lt;/b&gt;. &lt;b&gt;Pod::InputObjects&lt;/b&gt; provides several objects that may all be used interchangeably as parse-trees. The most obvious one is the &lt;b&gt;Pod::ParseTree&lt;/b&gt; object. It defines the basic interface and functionality that all things trying to be a POD parse-tree should do. A &lt;b&gt;Pod::ParseTree&lt;/b&gt; is defined such that each &quot;node&quot; may be a text-string, or a reference to another parse-tree. Each &lt;b&gt;Pod::Paragraph&lt;/b&gt; object and each &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; object also supports the basic parse-tree interface.</source>
          <target state="translated">Обратите особое внимание на &lt;a href=&quot;#METHODS-FOR-PARSING-AND-PROCESSING&quot;&gt;МЕТОДЫ РАЗРАБОТКИ И ОБРАБОТКИ&lt;/a&gt; и на объекты, описанные в &lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt; . Первый описывает кровавые детали и параметры того, как настроить и расширить поведение синтаксического анализа &lt;b&gt;Pod :: Parser&lt;/b&gt; . &lt;b&gt;Pod :: InputObjects&lt;/b&gt; предоставляет несколько объектов, которые могут использоваться взаимозаменяемо как деревья синтаксического анализа. Самый очевидный из них - объект &lt;b&gt;Pod :: ParseTree&lt;/b&gt; . Он определяет базовый интерфейс и функциональность, которые должны выполнять все, что пытается быть деревом синтаксического анализа POD. &lt;b&gt;Под :: ParseTree&lt;/b&gt; определяется таким образом, что каждый &amp;laquo;узел&amp;raquo; может представлять собой текстовый строка или ссылка на другой синтаксического дерева. Каждый объект &lt;b&gt;Pod :: Paragraph&lt;/b&gt; и каждый&lt;b&gt;&lt;/b&gt;Объект &lt;b&gt;Pod :: InteriorSequence&lt;/b&gt; также поддерживает базовый интерфейс дерева синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="8c0ffaf5c4cb2ca5b26bd5b8ebbf764c3f361b3b" translate="yes" xml:space="preserve">
          <source>Peeking At Perl's Internal Encoding</source>
          <target state="translated">Подглядывая за внутренним кодированием Perl.</target>
        </trans-unit>
        <trans-unit id="9326788fe51cb580ed1b0dbf97738788d7548374" translate="yes" xml:space="preserve">
          <source>Peep-hole Optimisation and Analysis</source>
          <target state="translated">Оптимизация и анализ глазковых скважин</target>
        </trans-unit>
        <trans-unit id="942951d0647566db32d37d28d3b5cb152d328945" translate="yes" xml:space="preserve">
          <source>Peephole optimizations are done by calling the function pointed to by the global variable &lt;code&gt;PL_peepp&lt;/code&gt; . By default, &lt;code&gt;PL_peepp&lt;/code&gt; just calls the function pointed to by the global variable &lt;code&gt;PL_rpeepp&lt;/code&gt; . By default, that performs some basic op fixups and optimisations along the execution-order op chain, and recursively calls &lt;code&gt;PL_rpeepp&lt;/code&gt; for each side chain of ops (resulting from conditionals). Extensions may provide additional optimisations or fixups, hooking into either the per-subroutine or recursive stage, like this:</source>
          <target state="translated">Оптимизация глазка выполняется путем вызова функции, на которую указывает глобальная переменная &lt;code&gt;PL_peepp&lt;/code&gt; . По умолчанию &lt;code&gt;PL_peepp&lt;/code&gt; просто вызывает функцию, на которую указывает глобальная переменная &lt;code&gt;PL_rpeepp&lt;/code&gt; . По умолчанию он выполняет некоторые базовые исправления и оптимизацию &lt;code&gt;PL_rpeepp&lt;/code&gt; в цепочке операций порядка выполнения и рекурсивно вызывает PL_rpeepp для каждой боковой цепочки операций (в результате условных выражений ). Расширения могут обеспечивать дополнительную оптимизацию или исправления, подключаясь либо к подпрограмме, либо к рекурсивному этапу, например:</target>
        </trans-unit>
        <trans-unit id="3d7bbafed59a27c1513d780d5e784c2a12ef1dc5" translate="yes" xml:space="preserve">
          <source>People frequently expect it to work like this. So it does.</source>
          <target state="translated">Люди часто ожидают,что это сработает вот так.Так и есть.</target>
        </trans-unit>
        <trans-unit id="bc1de57d7a939bd26a67e8c9562637156f53e824" translate="yes" xml:space="preserve">
          <source>People have a hard time remembering that some functions default to $_, or @ARGV, or whatever, but that others which you might expect to do not.</source>
          <target state="translated">Людям трудно вспомнить,что одни функции по умолчанию имеют значение $_,или @ARGV,или что-то в этом роде,а другие нет.</target>
        </trans-unit>
        <trans-unit id="af3c23d7810d9feb567b332e5161af8d9bd9f452" translate="yes" xml:space="preserve">
          <source>People like to see their strings nicely sorted--or as Unicode parlance goes, collated. But again, what do you mean by collate?</source>
          <target state="translated">Людям нравится,когда их струны хорошо отсортированы...или,как на языке Юникода,сопоставлены.Но опять же,что ты имеешь в виду под &quot;сопоставить&quot;?</target>
        </trans-unit>
        <trans-unit id="895626deb1f05ce05a822ae049fef844846a6710" translate="yes" xml:space="preserve">
          <source>People sometimes point out that &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; will do something similar, and ask why &lt;code&gt;Tie::File&lt;/code&gt; module is necessary.</source>
          <target state="translated">Иногда люди указывают, что &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; будет делать нечто подобное, и спрашивают, зачем нужен модуль &lt;code&gt;Tie::File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99dcc00aba3ea5fec8f203b99f7aa0dc52bd345a" translate="yes" xml:space="preserve">
          <source>Per default all untar operations are done with the perl module Archive::Tar; by setting this variable to true the external tar command is used if available; on Unix this is usually preferred because they have a reliable and fast gnutar implementation.</source>
          <target state="translated">По умолчанию все операции с tar выполняются с помощью модуля perl Archive::Tar;при установке этой переменной в true используется внешняя команда tar,если она доступна;в Unix это обычно предпочтительнее,так как они имеют надежную и быструю реализацию gnutar.</target>
        </trans-unit>
        <trans-unit id="c4f661f9e3bbabdfe8977d8e07c04f728f007afa" translate="yes" xml:space="preserve">
          <source>Per-Interpreter Variables</source>
          <target state="translated">Переменные для переводчика</target>
        </trans-unit>
        <trans-unit id="2559c9f59f217f32b3e891e1ab6877c4f55356cc" translate="yes" xml:space="preserve">
          <source>Per-instance Data</source>
          <target state="translated">Данные о местоположении</target>
        </trans-unit>
        <trans-unit id="637c16442a8f555cae097e71247c5fc7ee45adfd" translate="yes" xml:space="preserve">
          <source>Per-instance flag bits</source>
          <target state="translated">Биты флага прецедента</target>
        </trans-unit>
        <trans-unit id="24a428fdaa34dbb9d25a2ae2897474ba4a8b3383" translate="yes" xml:space="preserve">
          <source>Perceptive Perl hackers may have noticed that a &lt;code&gt;for&lt;/code&gt; loop has a return value, and that this value can be captured by wrapping the loop in a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; block. The reward for this discovery is this cautionary advice: The return value of a &lt;code&gt;for&lt;/code&gt; loop is unspecified and may change without notice. Do not rely on it.</source>
          <target state="translated">Проницательные хакеры Perl могли заметить, что цикл &lt;code&gt;for&lt;/code&gt; имеет возвращаемое значение, и что это значение можно получить, заключив цикл в блок &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; . Наградой за это открытие является предостерегающий совет: возвращаемое значение цикла &lt;code&gt;for&lt;/code&gt; не указано и может измениться без уведомления. Не надейтесь на это.</target>
        </trans-unit>
        <trans-unit id="2c46ae69f753cf6246720edd2c4a9cebd27597f5" translate="yes" xml:space="preserve">
          <source>Perform cache scanning ('atstart', 'atexit' or 'never')?</source>
          <target state="translated">Выполнять сканирование кэша ('atstart','atexit' или 'never')?</target>
        </trans-unit>
        <trans-unit id="c63fc543a09237e1df38dff5523874d7739bd5c9" translate="yes" xml:space="preserve">
          <source>Perform sorting on one type of platform only.</source>
          <target state="translated">Выполняйте сортировку только на одном типе платформы.</target>
        </trans-unit>
        <trans-unit id="c27007b93a4bc1c8de4cbbfbb0c5571ba69e57a4" translate="yes" xml:space="preserve">
          <source>Perform the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on the array.</source>
          <target state="translated">Выполните эквивалент &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; на массиве.</target>
        </trans-unit>
        <trans-unit id="f4070651c463f5c50952530e94f62331111d1bf1" translate="yes" xml:space="preserve">
          <source>Perform the equivalent of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on the array.</source>
          <target state="translated">Выполните эквивалент &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; на массиве.</target>
        </trans-unit>
        <trans-unit id="64184a2388a7346fec59e49f0f94873466b15963" translate="yes" xml:space="preserve">
          <source>Perform whatever actions the command line args specified. The &lt;code&gt;prove&lt;/code&gt; command line tool consists of the following code:</source>
          <target state="translated">Выполните все действия, указанные в аргументах командной строки. Инструмент командной строки &lt;code&gt;prove&lt;/code&gt; состоит из следующего кода:</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">Показатели эффективности</target>
        </trans-unit>
        <trans-unit id="8b696788f6758fff45816e3f44d267110dbc7d28" translate="yes" xml:space="preserve">
          <source>Performance issues</source>
          <target state="translated">Вопросы производительности</target>
        </trans-unit>
        <trans-unit id="75fbc5c30da07f1356bcf407f1026c09ad8550fb" translate="yes" xml:space="preserve">
          <source>Performance testing</source>
          <target state="translated">Тестирование производительности</target>
        </trans-unit>
        <trans-unit id="d9a7e43f70de19f613749fe02de0e154833f44cd" translate="yes" xml:space="preserve">
          <source>Performing Perl pattern matches and substitutions from your C program</source>
          <target state="translated">Выполнение шаблонных совпадений и замен по Perl из вашей программы на языке C</target>
        </trans-unit>
        <trans-unit id="b82005b8824a2b9aeaec337d4f6692160e086478" translate="yes" xml:space="preserve">
          <source>Performs a callback to the Perl sub whose name is in the SV. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Выполняет обратный вызов подпрограмме Perl, имя которой находится в SV. См. &lt;a href=&quot;perlcall&quot;&gt;Perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9a6e4b7d6eb6de9cfa7c1c05de09156f5313aec" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified Perl method. The blessed object must be on the stack. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Выполняет обратный вызов указанного метода Perl. Благословенный предмет должен быть в стеке. Смотрите &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3fb532eda4a585d8b90e5f5df9aa47f234c3a5" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified Perl sub. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Выполняет обратный вызов указанного Perl-подпрограммы. Смотрите &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49600604ba37ec7bb2caf7fae02578e1f3fb4be1" translate="yes" xml:space="preserve">
          <source>Performs a callback to the specified named and package-scoped Perl subroutine with &lt;code&gt;argv&lt;/code&gt; (a NULL-terminated array of strings) as arguments. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Выполняет обратный вызов указанной подпрограммы Perl с именем и областью действия пакета с &lt;code&gt;argv&lt;/code&gt; (массив строк с завершающим NULL). См. &lt;a href=&quot;perlcall&quot;&gt;Perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ada148fba94bb82b7e37d39db36e65570e59f9e9" translate="yes" xml:space="preserve">
          <source>Performs an &lt;code&gt;hv_iternext&lt;/code&gt; , &lt;code&gt;hv_iterkey&lt;/code&gt; , and &lt;code&gt;hv_iterval&lt;/code&gt; in one operation.</source>
          <target state="translated">Выполняет &lt;code&gt;hv_iternext&lt;/code&gt; , &lt;code&gt;hv_iterkey&lt;/code&gt; и &lt;code&gt;hv_iterval&lt;/code&gt; за одну операцию.</target>
        </trans-unit>
        <trans-unit id="08fa9ec15a0ad6b718fdf2229eda1c22f6e3ebcd" translate="yes" xml:space="preserve">
          <source>Performs some preprocessing to the string to ensure that it has the correct characteristics of a version. Flags the object if it contains an underscore (which denotes this is an alpha version). The boolean qv denotes that the version should be interpreted as if it had multiple decimals, even if it doesn't.</source>
          <target state="translated">Выполняет некоторую препроцессинговую обработку строки,чтобы удостовериться,что она имеет правильные характеристики версии.Помечает объект,если он содержит символ подчеркивания (что означает,что это альфа-версия).Булева qv обозначает,что версия должна интерпретироваться так,как если бы она имела несколько десятичных знаков,даже если это не так.</target>
        </trans-unit>
        <trans-unit id="8509e18df89af9b03f62a1a48a7b2cabc5f8fb27" translate="yes" xml:space="preserve">
          <source>Performs the default fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree. This consists of applying list context to each of the argument ops. This is the standard treatment used on a call marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , or a method call, or a call through a subroutine reference, or any other call where the callee can't be identified at compile time, or a call where the callee has no prototype.</source>
          <target state="translated">Выполняет исправление по умолчанию части аргументов дерева &lt;code&gt;entersub&lt;/code&gt; . Это состоит в применении контекста списка к каждой операции аргумента. Это стандартная обработка, используемая для вызова, отмеченного символом &lt;code&gt;&amp;amp;&lt;/code&gt; , или вызова метода, или вызова через ссылку на подпрограмму, или любого другого вызова, при котором вызываемый объект не может быть идентифицирован во время компиляции, или вызова, при котором вызываемый объект не имеет опытный образец.</target>
        </trans-unit>
        <trans-unit id="f72b3c1a72c8131e9de33c78c73bf05b880137dc" translate="yes" xml:space="preserve">
          <source>Performs the fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree based on a subroutine prototype. This makes various modifications to the argument ops, from applying context up to inserting &lt;code&gt;refgen&lt;/code&gt; ops, and checking the number and syntactic types of arguments, as directed by the prototype. This is the standard treatment used on a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time and has a prototype.</source>
          <target state="translated">Выполняет исправление части аргументов дерева &lt;code&gt;entersub&lt;/code&gt; в подпрограмму на основе прототипа подпрограммы. Это вносит различные изменения в аргументы ops, от применения контекста до вставки &lt;code&gt;refgen&lt;/code&gt; ops и проверки количества и синтаксических типов аргументов, как указано в прототипе. Это стандартная обработка, используемая при вызове подпрограммы, не отмеченная знаком &lt;code&gt;&amp;amp;&lt;/code&gt; , где вызываемый объект может быть идентифицирован во время компиляции и имеет прототип.</target>
        </trans-unit>
        <trans-unit id="6157a20bbb392600596ac64ab923dad03e358522" translate="yes" xml:space="preserve">
          <source>Performs the fixup of the arguments part of an &lt;code&gt;entersub&lt;/code&gt; op tree either based on a subroutine prototype or using default list-context processing. This is the standard treatment used on a subroutine call, not marked with &lt;code&gt;&amp;amp;&lt;/code&gt; , where the callee can be identified at compile time.</source>
          <target state="translated">Выполняет исправление части аргументов дерева &lt;code&gt;entersub&lt;/code&gt; в подпрограмму либо на основе прототипа подпрограммы, либо с использованием обработки контекста списка по умолчанию. Это стандартная обработка, используемая при вызове подпрограммы, не отмеченная знаком &lt;code&gt;&amp;amp;&lt;/code&gt; , где вызываемый может быть идентифицирован во время компиляции.</target>
        </trans-unit>
        <trans-unit id="710b350b3985543df26a6fea7ac3e9557988bb88" translate="yes" xml:space="preserve">
          <source>Perhaps the most common mistake programmers make is to attempt to optimize their code before a program actually does anything useful - this is a bad idea. There's no point in having an extremely fast program that doesn't work. The first job is to get a program to</source>
          <target state="translated">Возможно,самая распространенная ошибка,которую допускают программисты-это попытка оптимизировать свой код до того,как программа действительно сделает что-то полезное-это плохая идея.Нет смысла иметь чрезвычайно быструю программу,которая не работает.Первая задача-заставить программу</target>
        </trans-unit>
        <trans-unit id="f111d810e7ca920bda8f128569fc002610c45314" translate="yes" xml:space="preserve">
          <source>Perl</source>
          <target state="translated">Perl</target>
        </trans-unit>
        <trans-unit id="c1f70e71f78a6960e6bfc54f17ed9725d674c2b0" translate="yes" xml:space="preserve">
          <source>Perl 5 Documentation</source>
          <target state="translated">Perl 5 Документация</target>
        </trans-unit>
        <trans-unit id="8f5e9c26fdc65b3f883a3cb850a843ffd41fb0f9" translate="yes" xml:space="preserve">
          <source>Perl 5 Porters</source>
          <target state="translated">Перл 5 Портеры</target>
        </trans-unit>
        <trans-unit id="142bd9030035d40d81779a4f9a904554905faa01" translate="yes" xml:space="preserve">
          <source>Perl 5 has extension mechanisms, modules and XS, specifically to avoid the need to keep changing the Perl interpreter. You can write modules that export functions, you can give those functions prototypes so they can be called like built-in functions, you can even write XS code to mess with the runtime data structures of the Perl interpreter if you want to implement really complicated things.</source>
          <target state="translated">Perl 5 имеет механизмы расширения,модули и XS,специально для того,чтобы избежать необходимости постоянно менять интерпретатор Perl.Вы можете писать модули,которые экспортируют функции,вы можете дать этим функциям прототипы,чтобы они могли вызываться как встроенные функции,вы даже можете писать XS код,чтобы запутать структуры данных во время выполнения интерпретатора Perl,если вы хотите реализовать действительно сложные вещи.</target>
        </trans-unit>
        <trans-unit id="365a603ab08b813cf9c586a16f80eeba34a1d121" translate="yes" xml:space="preserve">
          <source>Perl 5 is developed by a community, not a corporate entity. Every change contributed to the Perl core is the result of a donation. Typically, these donations are contributions of code or time by individual members of our community. On occasion, these donations come in the form of corporate or organizational sponsorship of a particular individual or project.</source>
          <target state="translated">Perl 5 разработан сообществом,а не юридическим лицом.Каждое изменение,внесенное в ядро Perl,является результатом пожертвования.Обычно эти пожертвования являются вкладом кода или времени отдельных членов нашего сообщества.Иногда эти пожертвования поступают в виде корпоративного или организационного спонсорства конкретного человека или проекта.</target>
        </trans-unit>
        <trans-unit id="c7abcac9fa9f634d755f347614a5c92a44d2c3e5" translate="yes" xml:space="preserve">
          <source>Perl 5 was successfully compiled and tested on:</source>
          <target state="translated">Perl 5 был успешно составлен и протестирован:</target>
        </trans-unit>
        <trans-unit id="c7ebebb63cc5cd6e093751f9acf8676fc8362950" translate="yes" xml:space="preserve">
          <source>Perl 5.10 added three specials, &lt;code&gt;${^MATCH}&lt;/code&gt; , &lt;code&gt;${^PREMATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; to do the same job but without the global performance penalty. Perl 5.10 only sets these variables if you compile or execute the regular expression with the &lt;code&gt;/p&lt;/code&gt; modifier.</source>
          <target state="translated">Perl 5.10 добавил три специальных функции, &lt;code&gt;${^MATCH}&lt;/code&gt; , &lt;code&gt;${^PREMATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; чтобы выполнять ту же работу, но без глобального снижения производительности. Perl 5.10 устанавливает эти переменные, только если вы компилируете или выполняете регулярное выражение с модификатором &lt;code&gt;/p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce44e09ff142e65fee17e89d97567bf27f5d29b1" translate="yes" xml:space="preserve">
          <source>Perl 5.10 also introduced named capture groups and named backreferences. To attach a name to a capturing group, you write either &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt;. The backreference may then be written as &lt;code&gt;\g{name}&lt;/code&gt; . It is permissible to attach the same name to more than one group, but then only the leftmost one of the eponymous set can be referenced. Outside of the pattern a named capture group is accessible through the &lt;code&gt;%+&lt;/code&gt; hash.</source>
          <target state="translated">Perl 5.10 также представил именованные группы захвата и именованные обратные ссылки. Чтобы присвоить имя группе захвата, вы пишете &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; или &lt;code&gt;(?'name'...)&lt;/code&gt; . Тогда обратная ссылка может быть записана как &lt;code&gt;\g{name}&lt;/code&gt; . Допускается присвоение одного и того же имени более чем одной группе, но тогда можно ссылаться только на крайнее левое имя из одноименного набора. Вне шаблона именованная группа захвата доступна через хэш &lt;code&gt;%+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d78bc07daf7287cd2d82e764c55679c183debb95" translate="yes" xml:space="preserve">
          <source>Perl 5.10 introduced a number of control verbs intended to provide detailed control over the backtracking process, by directly influencing the regexp engine and by providing monitoring techniques. As all the features in this group are experimental and subject to change or removal in a future version of Perl, the interested reader is referred to &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;Special Backtracking Control Verbs in perlre&lt;/a&gt; for a detailed description.</source>
          <target state="translated">Perl 5.10 представил ряд управляющих команд, предназначенных для обеспечения детального управления процессом поиска с возвратом, путем прямого воздействия на механизм регулярных выражений и путем предоставления методов мониторинга. Поскольку все функции в этой группе являются экспериментальными и могут быть изменены или удалены в будущей версии Perl, заинтересованный читатель может обратиться к &lt;a href=&quot;perlre#Special-Backtracking-Control-Verbs&quot;&gt;специальным командам управления обратным отслеживанием в perlre&lt;/a&gt; для подробного описания.</target>
        </trans-unit>
        <trans-unit id="d8fc66ff20f940e5def5d5b04e16e404fe2d5094" translate="yes" xml:space="preserve">
          <source>Perl 5.12 an newer is not compatible with the IBM fileset perl.libext.</source>
          <target state="translated">Perl 5.12 несовместим с IBM-файловым набором perl.libext.</target>
        </trans-unit>
        <trans-unit id="ea53addd5f513ae8ff9630b1ab8b434a441c0d82" translate="yes" xml:space="preserve">
          <source>Perl 5.16 introduced a slightly more efficient mechanism that notes separately whether each of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; , and &lt;code&gt;$'&lt;/code&gt; have been seen, and thus may only need to copy part of the string. Perl 5.20 introduced a much more efficient copy-on-write mechanism which eliminates any slowdown.</source>
          <target state="translated">Perl 5.16 представил немного более эффективный механизм, который отдельно отмечает, были ли просмотрены каждый из &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; , и, следовательно, может потребоваться скопировать только часть строки. Perl 5.20 представил гораздо более эффективный механизм копирования при записи, который устраняет любое замедление.</target>
        </trans-unit>
        <trans-unit id="ecdd633a06acc3333c70644f93001a3679676523" translate="yes" xml:space="preserve">
          <source>Perl 5.18 introduced a new class, B::PADLIST, returned by B::CV's &lt;code&gt;PADLIST&lt;/code&gt; method.</source>
          <target state="translated">Perl 5,18 ввел новый класс, B :: PADLIST, возвращенный B :: анкетный &lt;code&gt;PADLIST&lt;/code&gt; метод.</target>
        </trans-unit>
        <trans-unit id="6b567ee259b41361a0ad9018ea4088cb70239efc" translate="yes" xml:space="preserve">
          <source>Perl 5.22 also introduces the experimental &quot;const&quot; attribute as an alternative. (Disable the &quot;experimental::const_attr&quot; warnings if you want to use it.) When applied to an anonymous subroutine, it forces the sub to be called when the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; expression is evaluated. The return value is captured and turned into a constant subroutine:</source>
          <target state="translated">Perl 5.22 также вводит экспериментальный атрибут &amp;laquo;const&amp;raquo; в качестве альтернативы. (Отключить &amp;laquo;экспериментальный :: const_attr&amp;raquo; предупреждение , если вы хотите использовать его.) Применительно к анонимной подпрограмме, она заставляет суб называться , когда &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; выражение. Возвращаемое значение фиксируется и превращается в постоянную подпрограмму:</target>
        </trans-unit>
        <trans-unit id="cf5bb1f9d37da5d5c2d35eb2fe5db684768a1718" translate="yes" xml:space="preserve">
          <source>Perl 5.22 introduced the B::PADNAMELIST and B::PADNAME classes.</source>
          <target state="translated">Perl 5.22 ввел классы B::PADNAMELIST и B::PADNAME.</target>
        </trans-unit>
        <trans-unit id="2c423e3fdc417abd5c0a870160561ad280c5b05c" translate="yes" xml:space="preserve">
          <source>Perl 5.6 added support for Unicode characters with code points &amp;gt; 255, and Perl 5.8 has full support for Unicode characters in hash keys. Perl internally encodes strings with these characters using utf8, and Storable serializes them as utf8. By default, if an older version of Perl encounters a utf8 value it cannot represent, it will &lt;code&gt;croak()&lt;/code&gt; . To change this behaviour so that Storable deserializes utf8 encoded values as the string of bytes (effectively dropping the</source>
          <target state="translated">Perl 5.6 добавил поддержку символов Unicode с кодовыми точками&amp;gt; 255, а Perl 5.8 полностью поддерживает символы Unicode в хэш-ключах. Perl внутренне кодирует строки с этими символами с помощью utf8, а Storable сериализует их как utf8. По умолчанию, если более старая версия Perl встречает значение utf8, которое она не может представить, она будет &lt;code&gt;croak()&lt;/code&gt; . Чтобы изменить это поведение таким образом, чтобы Storable десериализовал значения в кодировке utf8 как строку байтов (эффективно удаляя</target>
        </trans-unit>
        <trans-unit id="4d666cc8f0c2aafb781a5c3ee7854aa462c22563" translate="yes" xml:space="preserve">
          <source>Perl 5.6 and earlier used a quicksort algorithm to implement sort. That algorithm was not stable, so</source>
          <target state="translated">Для реализации сортировки на Perl 5.6 и более ранних версиях использовался алгоритм quicksort.Этот алгоритм не был стабильным,поэтому</target>
        </trans-unit>
        <trans-unit id="cc23cb198586dd32a543690c051c8df0366d1085" translate="yes" xml:space="preserve">
          <source>Perl 5.6 lets you write binary numbers directly with the &lt;code&gt;0b&lt;/code&gt; notation:</source>
          <target state="translated">Perl 5.6 позволяет записывать двоичные числа напрямую в нотации &lt;code&gt;0b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="45926b613d53010c55908af141dded6cf0223b03" translate="yes" xml:space="preserve">
          <source>Perl 5.6.0 introduced Unicode support. It's important for porters and XS writers to understand this support and make sure that the code they write does not corrupt Unicode data.</source>
          <target state="translated">На Perl 5.6.0 введена поддержка Unicode.Для портеров и XS-писателей важно понять эту поддержку и убедиться,что код,который они пишут,не повреждает данные Юникода.</target>
        </trans-unit>
        <trans-unit id="d766774f1389bd4f4ba4c170949b6d3cfbd45c53" translate="yes" xml:space="preserve">
          <source>Perl 5.6.x introduced the ability to optional configure the perl interpreter to use C's &lt;code&gt;long long&lt;/code&gt; type to allow scalars to store 64 bit integers on 32 bit systems. However, due to the way the Perl configuration system generated the C configuration files on non-Windows platforms, and the way Storable generates its header, nothing in the Storable file header reflected whether the perl writing was using 32 or 64 bit integers, despite the fact that Storable was storing some data differently in the file. Hence Storable running on perl with 64 bit integers will read the header from a file written by a 32 bit perl, not realise that the data is actually in a subtly incompatible format, and then go horribly wrong (possibly crashing) if it encountered a stored integer. This is a design failure.</source>
          <target state="translated">Perl 5.6.x представил возможность необязательной настройки интерпретатора perl для использования &lt;code&gt;long long&lt;/code&gt; типа C, чтобы скаляры могли хранить 64-битные целые числа в 32-битных системах. Однако из-за того, как система конфигурации Perl генерировала файлы конфигурации C на платформах, отличных от Windows, и способ, которым Storable генерирует свой заголовок, ничто в заголовке файла Storable не отражало, использовалось ли при записи Perl 32 или 64-битные целые числа, несмотря на Дело в том, что Storable по-разному хранил некоторые данные в файле. Следовательно, Storable, работающий на Perl с 64-битными целыми числами, будет читать заголовок из файла, записанного 32-битным Perl, не осознавая, что данные на самом деле находятся в слегка несовместимом формате, а затем будет ужасно ошибаться (возможно, сбой), если он встретит сохраненный целое число. Это неудачный проект.</target>
        </trans-unit>
        <trans-unit id="85ca30a6ededa148e4bfea0d2618456fe4f02a72" translate="yes" xml:space="preserve">
          <source>Perl 5.8 adds support for restricted hashes, which have keys restricted to a given set, and can have values locked to be read only. By default, when Storable encounters a restricted hash on a perl that doesn't support them, it will deserialize it as a normal hash, silently discarding any placeholder keys and leaving the keys and all values unlocked. To make Storable &lt;code&gt;croak()&lt;/code&gt; instead, set &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; to a &lt;code&gt;FALSE&lt;/code&gt; value. To restore the default set it back to some &lt;code&gt;TRUE&lt;/code&gt; value.</source>
          <target state="translated">Perl 5.8 добавляет поддержку ограниченных хэшей, у которых ключи ограничены заданным набором, а значения могут быть заблокированы только для чтения. По умолчанию, когда Storable встречает ограниченный хеш на perl, который их не поддерживает, он десериализует его как обычный хеш, молча отбрасывая все ключи-заполнители и оставляя ключи и все значения разблокированными. Чтобы вместо этого сделать Storable Croak &lt;code&gt;croak()&lt;/code&gt; , установите &lt;code&gt;$Storable::downgrade_restricted&lt;/code&gt; в значение &lt;code&gt;FALSE&lt;/code&gt; . Чтобы восстановить значение по умолчанию, верните его к некоторому &lt;code&gt;TRUE&lt;/code&gt; значению.</target>
        </trans-unit>
        <trans-unit id="565a4d4fa800ce5182da9b6ba981e8a739829623" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 added support for Unicode on EBCDIC platforms. This support was allowed to lapse in later releases, but was revived in 5.22. Unicode support is somewhat more complex to implement since additional conversions are needed. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.8.0 добавил поддержку Unicode на платформах EBCDIC. В более поздних выпусках эта поддержка была прекращена, но была восстановлена ​​в 5.22. Поддержка Unicode несколько сложнее реализовать, поскольку требуются дополнительные преобразования. См. &lt;a href=&quot;perlebcdic&quot;&gt;Perlebcdic&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="1d3bf07733afdb8eccda724369492b44b06d3912" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 and later avoid these problems by &quot;deferring&quot; signals. That is, when the signal is delivered to the process by the system (to the C code that implements Perl) a flag is set, and the handler returns immediately. Then at strategic &quot;safe&quot; points in the Perl interpreter (e.g. when it is about to execute a new opcode) the flags are checked and the Perl level handler from %SIG is executed. The &quot;deferred&quot; scheme allows much more flexibility in the coding of signal handlers as we know the Perl interpreter is in a safe state, and that we are not in a system library function when the handler is called. However the implementation does differ from previous Perls in the following ways:</source>
          <target state="translated">Perl 5.8.0 и более поздние версии позволяют избежать этих проблем путем &quot;отсрочки&quot; сигналов.То есть,когда сигнал поступает в процесс от системы (в код на C,реализующий Perl),устанавливается флаг,и обработчик немедленно возвращается.Затем в стратегических &quot;безопасных&quot; точках в интерпретаторе Perl (например,когда собирается выполнить новый опкод)проверяются флаги и выполняется обработчик уровня Perl из %SIG.Отложенная&quot; схема позволяет значительно больше гибкости в кодировании обработчиков сигналов,так как мы знаем,что Perl-интерпретатор находится в безопасном состоянии,и что при вызове обработчика мы не находимся в функции системной библиотеки.Однако реализация отличается от предыдущих Perls следующими способами:</target>
        </trans-unit>
        <trans-unit id="e73fd9ce0c7c872add12735883aa527cd3cbf5df" translate="yes" xml:space="preserve">
          <source>Perl 5.8.0 or later</source>
          <target state="translated">Perl 5.8.0 или более поздняя версия</target>
        </trans-unit>
        <trans-unit id="4e8757ee96021b145f4cb52d1033c040338543b5" translate="yes" xml:space="preserve">
          <source>Perl 6 is a reinvention of Perl, it is a language in the same lineage but not compatible. The two are complementary, not mutually exclusive. Perl 6 is not meant to replace Perl 5, and vice versa. See &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;What is Perl 6?&lt;/a&gt; below to find out more.</source>
          <target state="translated">Perl 6 - это новое изобретение Perl, это язык того же происхождения, но несовместимый. Эти два понятия дополняют друг друга, а не исключают друг друга. Perl 6 не предназначен для замены Perl 5, и наоборот. См. &lt;a href=&quot;#What-is-Perl-6%3f&quot;&gt;Что такое Perl 6? &lt;/a&gt;ниже, чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="70eed57e9021b8ec1bdc60c299cf0007c990e85c" translate="yes" xml:space="preserve">
          <source>Perl 6 was</source>
          <target state="translated">Perl 6 был</target>
        </trans-unit>
        <trans-unit id="c935317046cb2fe37bcb5104606c71edb33387e0" translate="yes" xml:space="preserve">
          <source>Perl &lt;b&gt;borrows syntax&lt;/b&gt; and concepts from many languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English. Other languages have borrowed syntax from Perl, particularly its regular expression extensions. So if you have programmed in another language you will see familiar pieces in Perl. They often work the same, but see &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt; for information about how they differ.</source>
          <target state="translated">Perl &lt;b&gt;заимствует синтаксис&lt;/b&gt; и концепции из многих языков: awk, sed, C, Bourne Shell, Smalltalk, Lisp и даже английского. Другие языки заимствовали синтаксис Perl, особенно его расширения регулярных выражений. Так что, если вы программировали на другом языке, вы увидите знакомые части в Perl. Они часто работают одинаково, но посмотрите &lt;a href=&quot;perltrap&quot;&gt;perltrap,&lt;/a&gt; чтобы узнать, чем они отличаются.</target>
        </trans-unit>
        <trans-unit id="a37780bb487077495edf8f34f760c1da9044ebae" translate="yes" xml:space="preserve">
          <source>Perl API not supported by ppport.h</source>
          <target state="translated">Perl API не поддерживается ppport.h.</target>
        </trans-unit>
        <trans-unit id="5b7471df455475e2c7d2175b53792162c97edfe3" translate="yes" xml:space="preserve">
          <source>Perl Authors Upload Server. Contains links to information for module authors.</source>
          <target state="translated">Perl Authors Upload Server.Содержит ссылки на информацию для авторов модулей.</target>
        </trans-unit>
        <trans-unit id="8bf74964bb9b0e9e3d4da81f0703933934a7c358" translate="yes" xml:space="preserve">
          <source>Perl Best Practices</source>
          <target state="translated">Лучшие практики Perl</target>
        </trans-unit>
        <trans-unit id="2cc43b42e51a4a8837fffe3af550658174edb610" translate="yes" xml:space="preserve">
          <source>Perl Books</source>
          <target state="translated">Перл Букс</target>
        </trans-unit>
        <trans-unit id="a3a9e748e5c4dd7f9dfa7cc95a251e60be896a8f" translate="yes" xml:space="preserve">
          <source>Perl Classes</source>
          <target state="translated">Перл-классы</target>
        </trans-unit>
        <trans-unit id="e482403a1124e0521d166c90c8a0769c85673b5e" translate="yes" xml:space="preserve">
          <source>Perl Cookbook</source>
          <target state="translated">Перл-кукнига</target>
        </trans-unit>
        <trans-unit id="d4efb54c65e7e3af46d13e87c7581a8dcba624d0" translate="yes" xml:space="preserve">
          <source>Perl DLL</source>
          <target state="translated">Perl DLL</target>
        </trans-unit>
        <trans-unit id="3283f18cd28cbde0549accd86697398505934bb4" translate="yes" xml:space="preserve">
          <source>Perl Editor by EngInSite is a complete integrated development environment (IDE) for creating, testing, and debugging Perl scripts; the tool runs on Windows 9x/NT/2000/XP or later.</source>
          <target state="translated">Perl Editor от EngInSite-это полная интегрированная среда разработки (IDE)для создания,тестирования и отладки Perl скриптов;инструмент работает под Windows 9x/NT/2000/XP или более поздней версии.</target>
        </trans-unit>
        <trans-unit id="7ac9d4c93ef979889b211c88f596e981156f45f4" translate="yes" xml:space="preserve">
          <source>Perl Extensions</source>
          <target state="translated">Расширения Perl</target>
        </trans-unit>
        <trans-unit id="f71fad82087d419a133c0dced88c67e1f9877063" translate="yes" xml:space="preserve">
          <source>Perl FAQ</source>
          <target state="translated">Часто задаваемые вопросы на Perl</target>
        </trans-unit>
        <trans-unit id="da7c8c4aaafde8c9b2e5f84c7552444fbb08c636" translate="yes" xml:space="preserve">
          <source>Perl Fails Because Of Unresolved Symbol sockatmark</source>
          <target state="translated">Perl не работает из-за нерешённого символа sockatmark.</target>
        </trans-unit>
        <trans-unit id="7c3d43451e7cda778a3f9c97b52abf3fd44bedb9" translate="yes" xml:space="preserve">
          <source>Perl Functions by Category</source>
          <target state="translated">Функции по категориям</target>
        </trans-unit>
        <trans-unit id="920e14089fbbc423ee2d5724c1de68632aef3813" translate="yes" xml:space="preserve">
          <source>Perl GNU Info Files on AmigaOS</source>
          <target state="translated">Информационные файлы Perl GNU на AmigaOS</target>
        </trans-unit>
        <trans-unit id="37de2a8ad505f52fcef06a6993c850291e480520" translate="yes" xml:space="preserve">
          <source>Perl HTML Documentation on AmigaOS</source>
          <target state="translated">Документация в формате Perl HTML на AmigaOS</target>
        </trans-unit>
        <trans-unit id="05eb1caf8706fb276d9b12087337d5c6103138c5" translate="yes" xml:space="preserve">
          <source>Perl LaTeX Documentation on AmigaOS</source>
          <target state="translated">Perl LaTeX Документация на AmigaOS</target>
        </trans-unit>
        <trans-unit id="91a43bc6de8b72c656ec8849bbbaebef043357f9" translate="yes" xml:space="preserve">
          <source>Perl Modules</source>
          <target state="translated">Модули Perl</target>
        </trans-unit>
        <trans-unit id="216d171ee4524430a28634ae1013da6c2f558efa" translate="yes" xml:space="preserve">
          <source>Perl Objects And C Structures</source>
          <target state="translated">Perl Объекты и С-структуры</target>
        </trans-unit>
        <trans-unit id="a472684894e509305085eced5d45bf35bf21cca5" translate="yes" xml:space="preserve">
          <source>Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; and &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) automatically test Perl source releases on platforms with various configurations.</source>
          <target state="translated">Perl Smokers ( &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build/&lt;/a&gt; и &lt;a href=&quot;http://www.nntp.perl.org/group/perl.daily-build.reports/&quot;&gt;http://www.nntp.perl.org/group/perl.daily-build.reports/&lt;/a&gt; ) автоматически тестируют Perl исходные версии на платформах с различными конфигурациями.</target>
        </trans-unit>
        <trans-unit id="a5b49734e895fa49b2262a8eac32c0a87b309e7f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter</source>
          <target state="translated">Фильтр на основе Perl</target>
        </trans-unit>
        <trans-unit id="d9385cb28cfa7ddf46c00b8a389aa72f1c3ecd2f" translate="yes" xml:space="preserve">
          <source>Perl Source Filter Utility Module</source>
          <target state="translated">Утилитный модуль фильтрации на основе Perl</target>
        </trans-unit>
        <trans-unit id="11827d68497a169d041d5a9b84cc14e0b5402701" translate="yes" xml:space="preserve">
          <source>Perl Threads Are Not X Threads</source>
          <target state="translated">Нитки Perl-это не X Нитки.</target>
        </trans-unit>
        <trans-unit id="0d5f49a6432453dfdae5c9b853d5d2137d7a3d82" translate="yes" xml:space="preserve">
          <source>Perl Traps</source>
          <target state="translated">Перл Ловушки</target>
        </trans-unit>
        <trans-unit id="e81612c89b54aaefee5157e85c78728a2455e0ca" translate="yes" xml:space="preserve">
          <source>Perl XS' attempt at a solution to this is the concept of typemaps. At an abstract level, a Perl XS typemap is nothing but a recipe for converting from a certain Perl data structure to a certain C data structure and vice versa. Since there can be C types that are sufficiently similar to one another to warrant converting with the same logic, XS typemaps are represented by a unique identifier, henceforth called an &lt;b&gt;XS type&lt;/b&gt; in this document. You can then tell the XS compiler that multiple C types are to be mapped with the same XS typemap.</source>
          <target state="translated">Попытка Perl XS решить эту проблему - это концепция типовых карт. На абстрактном уровне карта типов Perl XS - не что иное, как рецепт для преобразования определенной структуры данных Perl в определенную структуру данных C и наоборот. Поскольку могут быть типы C, которые достаточно похожи друг на друга, чтобы гарантировать преобразование с использованием той же логики, карты типов XS представлены уникальным идентификатором, в дальнейшем называемым &lt;b&gt;типом XS&lt;/b&gt; в этом документе. Затем вы можете сообщить компилятору XS, что несколько типов C должны отображаться с одной и той же картой типов XS.</target>
        </trans-unit>
        <trans-unit id="5aedddb9bed4a6f9cc4928e309c3362165c3d8aa" translate="yes" xml:space="preserve">
          <source>Perl actually inserts the following code:</source>
          <target state="translated">Perl фактически вставляет следующий код:</target>
        </trans-unit>
        <trans-unit id="0370590002494d49cbee29303986558b8c939d60" translate="yes" xml:space="preserve">
          <source>Perl actually stands for Pathologically Eclectic Rubbish Lister, but don't tell anyone I said that.</source>
          <target state="translated">Perl на самом деле означает &quot;Патологически эклектичный мусорный листер&quot;,но никому не говорите,что я это сказал.</target>
        </trans-unit>
        <trans-unit id="4ac1014663aa23e842df07d5739089aa502fbf6c" translate="yes" xml:space="preserve">
          <source>Perl adds magic to an SV using the sv_magic function:</source>
          <target state="translated">Perl добавляет магию в SV с помощью функции sv_magic:</target>
        </trans-unit>
        <trans-unit id="c3b8bb4554b031723a2e07241fd747dea1d44323" translate="yes" xml:space="preserve">
          <source>Perl after 5.8.7 has support for the &lt;code&gt;CLONE_SKIP&lt;/code&gt; special subroutine. Like &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; is called once per package; however, it is called just before cloning starts, and in the context of the parent thread. If it returns a true value, then no objects of that class will be cloned; or rather, they will be copied as unblessed, undef values. For example: if in the parent there are two references to a single blessed hash, then in the child there will be two references to a single undefined scalar value instead. This provides a simple mechanism for making a module threadsafe; just add &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; at the top of the class, and &lt;code&gt;DESTROY()&lt;/code&gt; will now only be called once per object. Of course, if the child thread needs to make use of the objects, then a more sophisticated approach is needed.</source>
          <target state="translated">Perl после 5.8.7 поддерживает специальную подпрограмму &lt;code&gt;CLONE_SKIP&lt;/code&gt; . Как и &lt;code&gt;CLONE&lt;/code&gt; , &lt;code&gt;CLONE_SKIP&lt;/code&gt; вызывается один раз для каждого пакета; однако он вызывается непосредственно перед началом клонирования и в контексте родительского потока. Если он возвращает истинное значение, то никакие объекты этого класса не будут клонированы; или, скорее, они будут скопированы как неблагословенные значения undef. Например: если в родительском элементе есть две ссылки на один благословенный хеш, то в дочернем элементе вместо этого будут две ссылки на одно неопределенное скалярное значение. Это обеспечивает простой механизм обеспечения безопасности потоков модуля; просто добавьте &lt;code&gt;sub CLONE_SKIP { 1 }&lt;/code&gt; в начало класса и &lt;code&gt;DESTROY()&lt;/code&gt; теперь будет вызываться только один раз для каждого объекта. Конечно, если дочернему потоку необходимо использовать объекты, тогда необходим более сложный подход.</target>
        </trans-unit>
        <trans-unit id="c3994bbd1bc4bb2e8469e1a722d815312e8adf0c" translate="yes" xml:space="preserve">
          <source>Perl allows multiple inheritance, which means that a class can inherit from multiple parents. While this is possible, we strongly recommend against it. Generally, you can use &lt;b&gt;roles&lt;/b&gt; to do everything you can do with multiple inheritance, but in a cleaner way.</source>
          <target state="translated">Perl допускает множественное наследование, что означает, что класс может наследовать от нескольких родителей. Хотя это возможно, мы настоятельно не рекомендуем этого делать. Как правило, вы можете использовать &lt;b&gt;роли,&lt;/b&gt; чтобы делать все, что вы можете делать с множественным наследованием, но более чистым способом.</target>
        </trans-unit>
        <trans-unit id="1876b83bb7cab17e23b16333856308b07e0072a3" translate="yes" xml:space="preserve">
          <source>Perl allows strings to contain a superset of Unicode code points, up to the limit of what is storable in an unsigned integer on your system, but these may not be accepted by other languages/systems. At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher. Code points above 0xFFFF_FFFF require larger than a 32 bit word.</source>
          <target state="translated">Perl позволяет строкам содержать суперсет из точек кода Юникода,вплоть до того,что хранится в беззнаковом целочислении в вашей системе,но это не может быть принято другими языками/системами.В свое время в некоторых стандартах было законно иметь точки кода до 0x7FFF_FFFFF,но не выше.Точки кода выше 0xFFFF_FFFFF требуют больше 32-битного слова.</target>
        </trans-unit>
        <trans-unit id="2ac9734d0ed22e02e26ee85745c9780f4e398059" translate="yes" xml:space="preserve">
          <source>Perl already</source>
          <target state="translated">Перл уже</target>
        </trans-unit>
        <trans-unit id="15634b8ec3adda1649ae8821b358664ffd34a247" translate="yes" xml:space="preserve">
          <source>Perl also defines a consistent extension syntax for features not found in standard tools like &lt;b&gt;awk&lt;/b&gt; and &lt;b&gt;lex&lt;/b&gt;. The syntax for most of these is a pair of parentheses with a question mark as the first thing within the parentheses. The character after the question mark indicates the extension.</source>
          <target state="translated">Perl также определяет согласованный синтаксис расширения для функций, которых нет в стандартных инструментах, таких как &lt;b&gt;awk&lt;/b&gt; и &lt;b&gt;lex&lt;/b&gt; . Синтаксис большинства из них - это пара круглых скобок со знаком вопроса в первую очередь в скобках. Символ после вопросительного знака указывает на расширение.</target>
        </trans-unit>
        <trans-unit id="a619d021759a90d753880bfe4b40f68e2b5378ff" translate="yes" xml:space="preserve">
          <source>Perl also guarantees that the ranges &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; , and any subranges of these match what an English-only speaker would expect them to match on any platform. That is, &lt;code&gt;[A-Z]&lt;/code&gt; matches the 26 ASCII uppercase letters; &lt;code&gt;[a-z]&lt;/code&gt; matches the 26 lowercase letters; and &lt;code&gt;[0-9]&lt;/code&gt; matches the 10 digits. Subranges, like &lt;code&gt;[h-k]&lt;/code&gt; , match correspondingly, in this case just the four letters &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; , and &lt;code&gt;&quot;k&quot;&lt;/code&gt; . This is the natural behavior on ASCII platforms where the code points (ordinal values) for &lt;code&gt;&quot;h&quot;&lt;/code&gt; through &lt;code&gt;&quot;k&quot;&lt;/code&gt; are consecutive integers (0x68 through 0x6B). But special handling to achieve this may be needed on platforms with a non-ASCII native character set. For example, on EBCDIC platforms, the code point for &lt;code&gt;&quot;h&quot;&lt;/code&gt; is 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; is 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; is 0x91, and &lt;code&gt;&quot;k&quot;&lt;/code&gt; is 0x92. Perl specially treats &lt;code&gt;[h-k]&lt;/code&gt; to exclude the seven code points in the gap: 0x8A through 0x90. This special handling is only invoked when the range is a subrange of one of the ASCII uppercase, lowercase, and digit ranges, AND each end of the range is expressed either as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , or as a named character (&lt;code&gt;\N{...}&lt;/code&gt; , including the &lt;code&gt;\N{U+...&lt;/code&gt; form).</source>
          <target state="translated">Perl также гарантирует, что диапазоны &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; и любые их поддиапазоны соответствуют тому, что говорящий только на английском языке ожидал бы от них на любой платформе. То есть &lt;code&gt;[A-Z]&lt;/code&gt; соответствует 26 заглавным буквам ASCII; &lt;code&gt;[a-z]&lt;/code&gt; соответствует 26 строчным буквам; и &lt;code&gt;[0-9]&lt;/code&gt; соответствует 10 цифрам. Поддиапазоны, такие как &lt;code&gt;[h-k]&lt;/code&gt; , соответствуют соответственно, в данном случае только четыре буквы &lt;code&gt;&quot;h&quot;&lt;/code&gt; , &lt;code&gt;&quot;i&quot;&lt;/code&gt; , &lt;code&gt;&quot;j&quot;&lt;/code&gt; и &lt;code&gt;&quot;k&quot;&lt;/code&gt; . Это естественное поведение на платформах ASCII, где кодовые точки (порядковые значения) от &lt;code&gt;&quot;h&quot;&lt;/code&gt; до &lt;code&gt;&quot;k&quot;&lt;/code&gt; - последовательные целые числа (от 0x68 до 0x6B). Но для этого может потребоваться специальная обработка на платформах с собственным набором символов, отличным от ASCII. Например, на платформах EBCDIC кодовая точка для &lt;code&gt;&quot;h&quot;&lt;/code&gt; - 0x88, &lt;code&gt;&quot;i&quot;&lt;/code&gt; - это 0x89, &lt;code&gt;&quot;j&quot;&lt;/code&gt; - 0x91, а &lt;code&gt;&quot;k&quot;&lt;/code&gt; - 0x92. Perl специально обрабатывает &lt;code&gt;[h-k]&lt;/code&gt; чтобы исключить семь кодовых точек в промежутке: от 0x8A до 0x90. Эта специальная обработка вызывается только тогда, когда диапазон является поддиапазоном одного из диапазонов верхнего, нижнего и цифрового символов ASCII, И каждый конец диапазона выражается либо как литерал, например &lt;code&gt;&quot;A&quot;&lt;/code&gt; , либо как именованный символ ( &lt;code&gt;\N{...}&lt;/code&gt; , включая форму &lt;code&gt;\N{U+...&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="43ed4c36b705c801489a6eaa310a7c1790004938" translate="yes" xml:space="preserve">
          <source>Perl also has environment variables that control how Perl handles data specific to particular natural languages; see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Perl также имеет переменные среды, которые управляют тем, как Perl обрабатывает данные, специфичные для определенных естественных языков; см. &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ec1e88310a904c3504c234668eb6f0ebab9fa04" translate="yes" xml:space="preserve">
          <source>Perl also has its own built-in variables whose names don't follow these rules. They have strange names so they don't accidentally collide with one of your normal variables. Strings that match parenthesized parts of a regular expression are saved under names containing only digits after the &lt;code&gt;$&lt;/code&gt; (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). In addition, several special variables that provide windows into the inner working of Perl have names containing punctuation characters and control characters. These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Perl также имеет свои собственные встроенные переменные, имена которых не соответствуют этим правилам. У них странные имена, поэтому они случайно не столкнутся с одной из ваших обычных переменных. Строки, соответствующие заключенным в скобки частям регулярного выражения, сохраняются под именами, содержащими только цифры после &lt;code&gt;$&lt;/code&gt; (см. &lt;a href=&quot;perlop&quot;&gt;Perlop&lt;/a&gt; и &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; ). Кроме того, несколько специальных переменных, которые открывают окна для внутренней работы Perl, имеют имена, содержащие знаки препинания и управляющие символы. Они задокументированы в &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="841c07e6d7a8a9202a2c193293298a117297f325" translate="yes" xml:space="preserve">
          <source>Perl also has single-form extensions that refer to blocks, &lt;code&gt;In_Cyrillic&lt;/code&gt; , meaning &lt;code&gt;Block=Cyrillic&lt;/code&gt; . These have always been written in the new style.</source>
          <target state="translated">Perl также имеет расширения одной формы, которые относятся к блокам, &lt;code&gt;In_Cyrillic&lt;/code&gt; , что означает &lt;code&gt;Block=Cyrillic&lt;/code&gt; . Они всегда писались в новом стиле.</target>
        </trans-unit>
        <trans-unit id="e768cdcaf855f3ac360271eae70fa3fb2f42dd9c" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a dereferenced scalar reference in a method call. That's a mouthful, so let's look at some code:</source>
          <target state="translated">Perl также позволяет использовать разыменованную ссылку на скаляр в вызове метода.Это полный рот,так что давайте посмотрим на какой-нибудь код:</target>
        </trans-unit>
        <trans-unit id="bb3ab86dafec3fc1c1204665ff3d23b69370b1f7" translate="yes" xml:space="preserve">
          <source>Perl also lets you use a scalar containing a string as a class name:</source>
          <target state="translated">Perl также позволяет использовать скаляр,содержащий строку в качестве имени класса:</target>
        </trans-unit>
        <trans-unit id="371faeea377937a5cb124120c079958efb812b1f" translate="yes" xml:space="preserve">
          <source>Perl also provides some additional extensions and short-cut synonyms for Unicode properties.</source>
          <target state="translated">Perl также предоставляет некоторые дополнительные расширения и короткие синонимы для свойств Юникода.</target>
        </trans-unit>
        <trans-unit id="bc3b136059aadb780f36682ea1b93270fac2fc5f" translate="yes" xml:space="preserve">
          <source>Perl also uses two special typedefs, I32 and I16, which will always be at least 32-bits and 16-bits long, respectively. (Again, there are U32 and U16, as well.) They will usually be exactly 32 and 16 bits long, but on Crays they will both be 64 bits.</source>
          <target state="translated">Perl также использует два специальных шрифта,I32 и I16,которые всегда будут как минимум 32 и 16 бит соответственно.(Опять же,есть U32 и U16,тоже.)Обычно они будут иметь ровно 32 и 16 бит,но на Crays они оба будут 64 бита.</target>
        </trans-unit>
        <trans-unit id="d9ec80db167215866b69eb0ca3e0370b7320f73c" translate="yes" xml:space="preserve">
          <source>Perl and its various modules and components, including its test frameworks, may sometimes make use of certain other environment variables. Some of these are specific to a particular platform. Please consult the appropriate module documentation and any documentation for your platform (like &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt;, &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt;, &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt;, &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, etc) for variables peculiar to those specific situations.</source>
          <target state="translated">Perl и его различные модули и компоненты, включая его тестовые среды, иногда могут использовать некоторые другие переменные среды. Некоторые из них относятся к конкретной платформе. Пожалуйста, обратитесь к документации соответствующего модуля и любой документации для вашей платформы (например, &lt;a href=&quot;perlsolaris&quot;&gt;perlsolaris&lt;/a&gt; , &lt;a href=&quot;perllinux&quot;&gt;perllinux&lt;/a&gt; , &lt;a href=&quot;perlmacosx&quot;&gt;perlmacosx&lt;/a&gt; , &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt; и т. Д.) , Чтобы узнать о переменных, характерных для этих конкретных ситуаций.</target>
        </trans-unit>
        <trans-unit id="d1f38ea6665b57c86a485191974a93669f79515b" translate="yes" xml:space="preserve">
          <source>Perl applications</source>
          <target state="translated">Perl-приложения</target>
        </trans-unit>
        <trans-unit id="502f7e3b25466218701794ac8b146d454581203f" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl пытается очистить все файлы, открытые для вывода, перед тем, как разветвлять дочерний процесс, но это может не поддерживаться на некоторых платформах (см. &lt;a href=&quot;../perlport&quot;&gt;Perlport&lt;/a&gt; ). В целях безопасности вам может потребоваться установить &lt;code&gt;$|&lt;/code&gt; ($ AutoFlush на английском языке) или вызовите &lt;code&gt;autoflush()&lt;/code&gt; метод &lt;code&gt;IO::Handle&lt;/code&gt; на любые открытые ручки , чтобы избежать дублирования вывода.</target>
        </trans-unit>
        <trans-unit id="310c094e234f2eeac0cd6d541a4252ff1573cf15" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before forking the child process, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid duplicate output.</source>
          <target state="translated">Perl пытается очистить все файлы, открытые для вывода, перед тем, как разветвлять дочерний процесс, но это может не поддерживаться на некоторых платформах (см. &lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt; ). В целях безопасности вам может потребоваться установить &lt;code&gt;$|&lt;/code&gt; ($ AutoFlush на английском языке) или вызовите &lt;code&gt;autoflush()&lt;/code&gt; метод &lt;code&gt;IO::Handle&lt;/code&gt; на любые открытые ручки , чтобы избежать дублирования вывода.</target>
        </trans-unit>
        <trans-unit id="de17dd0dec4269e99ee3620228765bf8385c7342" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl пытается очистить все файлы, открытые для вывода, перед exec, но это может не поддерживаться на некоторых платформах (см. &lt;a href=&quot;../perlport&quot;&gt;Perlport&lt;/a&gt; ). В целях безопасности вам может потребоваться установить &lt;code&gt;$|&lt;/code&gt; ($ AutoFlush на английском языке) или вызовите &lt;code&gt;autoflush()&lt;/code&gt; метод &lt;code&gt;IO::Handle&lt;/code&gt; на любые открытые ручки , чтобы избежать падения производства.</target>
        </trans-unit>
        <trans-unit id="003b4d9ba004fb0af8689ed0414255d30b89d115" translate="yes" xml:space="preserve">
          <source>Perl attempts to flush all files opened for output before the exec, but this may not be supported on some platforms (see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;). To be safe, you may need to set &lt;code&gt;$|&lt;/code&gt; ($AUTOFLUSH in English) or call the &lt;code&gt;autoflush()&lt;/code&gt; method of &lt;code&gt;IO::Handle&lt;/code&gt; on any open handles to avoid lost output.</source>
          <target state="translated">Perl пытается очистить все файлы, открытые для вывода, перед exec, но это может не поддерживаться на некоторых платформах (см. &lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt; ). В целях безопасности вам может потребоваться установить &lt;code&gt;$|&lt;/code&gt; ($ AutoFlush на английском языке) или вызовите &lt;code&gt;autoflush()&lt;/code&gt; метод &lt;code&gt;IO::Handle&lt;/code&gt; на любые открытые ручки , чтобы избежать падения производства.</target>
        </trans-unit>
        <trans-unit id="7d4f20a9384f8bc5428825b882bff482c1a8070c" translate="yes" xml:space="preserve">
          <source>Perl automatically calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method when processing a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement for a module. Modules and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; are documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;. Understanding the concept of modules and how the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement operates is important to understanding the Exporter.</source>
          <target state="translated">Perl автоматически вызывает метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; при обработке оператора &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; для модуля. Модули и их &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; описаны в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; и &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; . Понимание концепции модулей и того, как работает инструкция &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , важно для понимания Экспортера.</target>
        </trans-unit>
        <trans-unit id="f61b6a6317cfa23498f15dd9d06745532cf81070" translate="yes" xml:space="preserve">
          <source>Perl automatically enables a set of special security checks, called</source>
          <target state="translated">Perl автоматически включает набор специальных проверок безопасности,называемых</target>
        </trans-unit>
        <trans-unit id="fbe832a4f97c9466dde588ba9b2da8adad2850de" translate="yes" xml:space="preserve">
          <source>Perl automatically handles most of the common ways a method might be redefined. However, there are a few ways you could change a method in a stash without the cache code noticing, in which case you need to call this method afterwards:</source>
          <target state="translated">Perl автоматически обрабатывает большинство распространенных способов переопределения метода.Однако,есть несколько способов изменить метод в тайнике,не замечая кэш кода,и в этом случае необходимо вызвать этот метод позже:</target>
        </trans-unit>
        <trans-unit id="036d8f87f677f8c5718f1d28012fa559462c3777" translate="yes" xml:space="preserve">
          <source>Perl automatically provides large file support when built under 64-bit Windows.</source>
          <target state="translated">Perl автоматически обеспечивает поддержку больших файлов при сборке под 64-битной Windows.</target>
        </trans-unit>
        <trans-unit id="7a716c995ea81037d2661a333de648b734bf1c68" translate="yes" xml:space="preserve">
          <source>Perl believes that no machine ever has more than one of &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; , or &lt;code&gt;quota&lt;/code&gt; implemented, nor more than one of either &lt;code&gt;comment&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt; . Some machines do not support &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; , or allegedly, &lt;code&gt;passwd&lt;/code&gt; . You may call these methods no matter what machine you're on, but they return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if unimplemented.</source>
          <target state="translated">Perl считает, что ни на одной машине никогда не было реализовано более одного &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;age&lt;/code&gt; или &lt;code&gt;quota&lt;/code&gt; , а также более одного &lt;code&gt;comment&lt;/code&gt; или &lt;code&gt;class&lt;/code&gt; . Некоторые машины не поддерживают &lt;code&gt;expire&lt;/code&gt; , &lt;code&gt;gecos&lt;/code&gt; или предположительно &lt;code&gt;passwd&lt;/code&gt; . Вы можете вызывать эти методы независимо от того, на какой машине вы работаете, но они возвращают &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если не реализованы.</target>
        </trans-unit>
        <trans-unit id="5d0360d06e2a1778dd48425c09025dbdf8293f8e" translate="yes" xml:space="preserve">
          <source>Perl binary able to run this extension, load XS modules, etc...</source>
          <target state="translated">Двоичный файл Perl,способный запускать это расширение,загружать модули XS и т.д....</target>
        </trans-unit>
        <trans-unit id="cb8da21c98e2920d923d329d6f68942a153a615f" translate="yes" xml:space="preserve">
          <source>Perl binary distributions come with a</source>
          <target state="translated">Двоичные распределения на Perl поставляются с</target>
        </trans-unit>
        <trans-unit id="25b8cd5db95b73c8697ce2a24fc9a3c4624497ef" translate="yes" xml:space="preserve">
          <source>Perl binary for tasks that can be done by miniperl.</source>
          <target state="translated">Двоичный Perl для задач,которые могут быть выполнены с помощью miniperl.</target>
        </trans-unit>
        <trans-unit id="b72df5c4242785794c622b22864eb9d8a2e74001" translate="yes" xml:space="preserve">
          <source>Perl builds and runs on a bewildering number of platforms. Virtually all known and current Unix derivatives are supported (perl's native platform), as are other systems like VMS, DOS, OS/2, Windows, QNX, BeOS, OS X, MPE/iX and the Amiga.</source>
          <target state="translated">Perl собирается и работает на ошеломляющем количестве платформ.Поддерживаются практически все известные и текущие производные Unix (нативная платформа perl),а также другие системы,такие как VMS,DOS,OS/2,Windows,QNX,BeOS,OS X,MPE/iX и Amiga.</target>
        </trans-unit>
        <trans-unit id="96b360f2cb263510b9740f1a358943c2a62edfbc" translate="yes" xml:space="preserve">
          <source>Perl by default comes with the latest supported Unicode version built-in, but the goal is to allow you to change to use any earlier one. In Perls v5.20 and v5.22, however, the earliest usable version is Unicode 5.1. Perl v5.18 is able to handle all earlier versions.</source>
          <target state="translated">Perl по умолчанию поставляется с последней поддерживаемой версией встроенного Юникода,но цель состоит в том,чтобы позволить вам изменять его для использования любой более ранней версии.Однако в Perls v5.20 и v5.22 самой ранней из поддерживаемых версий является Unicode 5.1.Perl v5.18 способен работать со всеми более ранними версиями.</target>
        </trans-unit>
        <trans-unit id="858924b099068580d5d02f65c2520871f9621191" translate="yes" xml:space="preserve">
          <source>Perl by default is very forgiving. In order to make it more robust it is recommended to start every program with the following lines:</source>
          <target state="translated">Perl по умолчанию очень прощающий.Чтобы сделать его более надежным,рекомендуется начинать каждую программу со следующих строк:</target>
        </trans-unit>
        <trans-unit id="41943c9223a2849d683a6cec44cbaf36e58b907e" translate="yes" xml:space="preserve">
          <source>Perl can be built so that it by default will try to execute</source>
          <target state="translated">Perl может быть построен так,что по умолчанию будет пытаться выполнить</target>
        </trans-unit>
        <trans-unit id="36ba407dbee2d6e43709ef0153d960c56996ecc9" translate="yes" xml:space="preserve">
          <source>Perl can be compiled on platforms that run any of three commonly used EBCDIC character sets, listed below.</source>
          <target state="translated">Perl может быть скомпилирован на платформах,которые работают с любым из трех широко используемых наборов символов EBCDIC,перечисленных ниже.</target>
        </trans-unit>
        <trans-unit id="bea19b77ce1281f9b9bf9a47baf0d79604e6dd7a" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either HP's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of HP compiler-specific command-line flags.</source>
          <target state="translated">Perl может быть скомпилирован либо ANSI C компилятором HP,либо gcc.Первое рекомендуется,так как оно не только может скомпилировать Perl без проблем,но и может использовать возможности,перечисленные ниже,которые требуют использования флагов командной строки,специфичных для компилятора HP.</target>
        </trans-unit>
        <trans-unit id="f05f1e5361560b59743e9bd4f32b54cc023f431f" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only can it compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl может быть скомпилирован как с помощью ANSI C компилятора IBM,так и с помощью gcc.Первый вариант рекомендуется,так как он не только может скомпилировать Perl без проблем,но и может использовать возможности,перечисленные ниже,которые требуют использования флагов командной строки,специфичных для IBM-компилятора.</target>
        </trans-unit>
        <trans-unit id="19a69f0e2f064ea4c82b3309e77eb45ccd797a4c" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with either IBM's ANSI C compiler or with gcc. The former is recommended, as not only it can compile Perl with no difficulty, but also can take advantage of features listed later that require the use of IBM compiler-specific command-line flags.</source>
          <target state="translated">Perl может быть скомпилирован как с помощью ANSI C компилятора IBM,так и с помощью gcc.Первое рекомендуется,так как оно не только может скомпилировать Perl без проблем,но и может использовать возможности,перечисленные ниже,которые требуют использования флагов командной строки,специфичных для IBM-компилятора.</target>
        </trans-unit>
        <trans-unit id="751c036d6e62fec07bc2f5f4e73156154792a0fd" translate="yes" xml:space="preserve">
          <source>Perl can be compiled with gcc from MinGW release 3 and later (using gcc 3.4.5 and later). It can be downloaded here:</source>
          <target state="translated">Perl может быть скомпилирован с помощью gcc из MinGW версии 3 и более поздней (с использованием gcc 3.4.5 и более поздней).Его можно скачать здесь:</target>
        </trans-unit>
        <trans-unit id="2e57623077581e01731874e47fb8c2a4b90f970b" translate="yes" xml:space="preserve">
          <source>Perl can be run under the &quot;C&quot; locale by setting the environment variable &lt;code&gt;LC_ALL&lt;/code&gt; to &quot;C&quot;. This method is perhaps a bit more civilized than the &lt;code&gt;PERL_BADLANG&lt;/code&gt; approach, but setting &lt;code&gt;LC_ALL&lt;/code&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for the full list of relevant environment variables and &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt; for their effects in Perl. Effects in other programs are easily deducible. For example, the variable &lt;code&gt;LC_COLLATE&lt;/code&gt; may well affect your &lt;b&gt;sort&lt;/b&gt; program (or whatever the program that arranges &quot;records&quot; alphabetically in your system is called).</source>
          <target state="translated">Perl можно запустить в локали &amp;laquo;C&amp;raquo;, установив для переменной среды &lt;code&gt;LC_ALL&lt;/code&gt; значение &amp;laquo;C&amp;raquo;. Этот метод, возможно, немного более цивилизован, чем подход &lt;code&gt;PERL_BADLANG&lt;/code&gt; , но установка &lt;code&gt;LC_ALL&lt;/code&gt; (или других переменных локали) может повлиять и на другие программы, а не только на Perl. В частности, эти изменения заметят внешние программы, запущенные из Perl. Если вы сделаете новые настройки постоянными (читайте дальше), все программы, которые вы запускаете, увидят изменения. См. &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; для получения полного списка соответствующих переменных среды и &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt; для ознакомления с их действием в Perl. Эффекты в других программах легко вывести. Например, переменная &lt;code&gt;LC_COLLATE&lt;/code&gt; может повлиять на вашу &lt;b&gt;сортировку.&lt;/b&gt; программа (или как там называется программа, которая размещает &amp;laquo;записи&amp;raquo; в алфавитном порядке в вашей системе).</target>
        </trans-unit>
        <trans-unit id="afea4028a165b75f73beb84894121ff0308d01df" translate="yes" xml:space="preserve">
          <source>Perl can be used for almost any coding problem, even ones which require integrating specialist C code for extra speed. As with any tool it can be used well or badly. Perl has many strengths, and a few weaknesses, precisely which areas are good and bad is often a personal choice.</source>
          <target state="translated">Perl можно использовать практически для любой проблемы кодирования,даже для тех,которые требуют интеграции специализированного кода на C для дополнительной скорости.Как и любой другой инструмент,он может быть использован как хорошо,так и плохо.Perl имеет много сильных сторон и несколько слабых сторон,и то,какие именно области являются хорошими,а какие плохими,часто является личным выбором.</target>
        </trans-unit>
        <trans-unit id="9f84aec4fa7ef06751c778c8e8173ffe00dcd629" translate="yes" xml:space="preserve">
          <source>Perl can compile and run under EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;. This is transparent for the most part, but because the character sets differ, you shouldn't use numeric (decimal, octal, nor hex) constants to refer to characters. You can safely say &lt;code&gt;'A'&lt;/code&gt; , but not &lt;code&gt;0x41&lt;/code&gt; . You can safely say &lt;code&gt;'\n'&lt;/code&gt; , but not &lt;code&gt;\012&lt;/code&gt; . However, you can use macros defined in</source>
          <target state="translated">Perl может компилироваться и запускаться на платформах EBCDIC. См. &lt;a href=&quot;perlebcdic&quot;&gt;Perlebcdic&lt;/a&gt; . По большей части это прозрачно, но поскольку наборы символов различаются, вы не должны использовать числовые (десятичные, восьмеричные или шестнадцатеричные) константы для обозначения символов. Вы можете спокойно сказать &lt;code&gt;'A'&lt;/code&gt; , но не &lt;code&gt;0x41&lt;/code&gt; . Вы можете спокойно произносить &lt;code&gt;'\n'&lt;/code&gt; , но не &lt;code&gt;\012&lt;/code&gt; . Однако вы можете использовать макросы, определенные в</target>
        </trans-unit>
        <trans-unit id="fa07386a80b47ab8df8b6dbe1e6a41311efb8910" translate="yes" xml:space="preserve">
          <source>Perl can internally represent numbers in 3 different ways: as native integers, as native floating point numbers, and as decimal strings. Decimal strings may have an exponential notation part, as in &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; .</source>
          <target state="translated">Perl может внутренне представлять числа тремя разными способами: как собственные целые числа, как собственные числа с плавающей запятой и как десятичные строки. Десятичные строки могут иметь экспоненциальную часть записи, как в &lt;code&gt;&quot;12.34e-56&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05cb1fb37d34785f635f75844d77033b80fc24ef" translate="yes" xml:space="preserve">
          <source>Perl can process line directives, much like the C preprocessor. Using this, one can control Perl's idea of filenames and line numbers in error or warning messages (especially for strings that are processed with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;). The syntax for this mechanism is almost the same as for most C preprocessors: it matches the regular expression</source>
          <target state="translated">Perl может обрабатывать строковые директивы так же, как препроцессор C. Используя это, можно контролировать представление Perl об именах файлов и номерах строк в сообщениях об ошибках или предупреждениях (особенно для строк, которые обрабатываются с помощью &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; ). Синтаксис этого механизма почти такой же, как и у большинства препроцессоров C: он соответствует регулярному выражению</target>
        </trans-unit>
        <trans-unit id="87b4bc522cc9bacefe7588c2849722683c7ccc0c" translate="yes" xml:space="preserve">
          <source>Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default. The omitted ones are the Unihan properties (accessible via the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode::Unihan&lt;/a&gt;) and certain deprecated or Unicode-internal properties. (An installation may choose to recompile Perl's tables to change this. See &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Unicode character properties that are NOT accepted by Perl&lt;/a&gt;.)</source>
          <target state="translated">Perl может предоставить доступ ко всем условным свойствам символов Юникода, хотя не все из них включены по умолчанию. Не указаны свойства Unihan (доступные через модуль CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Unihan&quot;&gt;Unicode :: Unihan&lt;/a&gt; ) и некоторые устаревшие или внутренние свойства Unicode. (При установке может быть выбрана перекомпиляция таблиц Perl, чтобы изменить это. См. &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;Свойства символов Unicode, которые НЕ принимаются Perl&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b9d3bae2bf6cbe36ec81823e26589a3e2497f6c1" translate="yes" xml:space="preserve">
          <source>Perl cannot be compiled with threading support ATM.</source>
          <target state="translated">Perl не может быть скомпилирован с поддержкой потоков ATM.</target>
        </trans-unit>
        <trans-unit id="5aa9ff89c6dfca6cc410567a511ce06ca99ab635" translate="yes" xml:space="preserve">
          <source>Perl cannot protect you from all possibilities shown in the examples--there is no substitute for your own vigilance--but, when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, Perl uses the tainting mechanism (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to mark string results that become locale-dependent, and which may be untrustworthy in consequence. Here is a summary of the tainting behavior of operators and functions that may be affected by the locale:</source>
          <target state="translated">Perl не может защитить вас от всех возможностей , представленных в примерах - нет никакой замены для вашей собственной бдительности - но, когда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; в сущности, Perl использует механизм загрязненности (см &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; ) к результатам строковых меток , которые становятся Локальнозависимым , и, как следствие, может оказаться ненадежным. Вот краткое описание заражения операторов и функций, на которые может повлиять языковой стандарт:</target>
        </trans-unit>
        <trans-unit id="d5f3aa702381872bb34697babcd6d91dd23feeed" translate="yes" xml:space="preserve">
          <source>Perl code is always compiled into an internal format before execution.</source>
          <target state="translated">Perl-код всегда перед выполнением компилируется во внутренний формат.</target>
        </trans-unit>
        <trans-unit id="c5cce9b9678a00b1fe024a9af1e795642a5bcb9c" translate="yes" xml:space="preserve">
          <source>Perl comes with a wide selection of builtin functions. Some of the ones we've already seen include &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt;. A list of them is given at the start of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and you can easily read about any given function by using &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Perl поставляется с широким набором встроенных функций. Некоторые из тех, что мы уже видели, включают &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;perlfunc&quot;&gt;Их&lt;/a&gt; список приведен в начале perlfunc, и вы можете легко прочитать о любой данной функции, используя &lt;code&gt;perldoc -f &lt;i&gt;functionname&lt;/i&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d575f0416db18e1fc564b29cf8cc390222ecf415" translate="yes" xml:space="preserve">
          <source>Perl comes with an interactive debugger, which you can start with the &lt;code&gt;-d&lt;/code&gt; switch. It's fully explained in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">Perl поставляется с интерактивным отладчиком, который можно запустить с помощью переключателя &lt;code&gt;-d&lt;/code&gt; . Это полностью объяснено в &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="641c8779114365eacf0b514d71b892f3c88f6444" translate="yes" xml:space="preserve">
          <source>Perl compiler backend to produce perl code</source>
          <target state="translated">Бэкэнд компилятора Perl для создания perl кода</target>
        </trans-unit>
        <trans-unit id="a425209baf3b199ee00ab768f1943ede83ed4ff4" translate="yes" xml:space="preserve">
          <source>Perl contains internal support for reporting its own memory usage, but this is a fairly advanced concept that requires some understanding of how memory allocation works. See &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;Debugging Perl Memory Usage in perldebguts&lt;/a&gt; for the details.</source>
          <target state="translated">Perl содержит внутреннюю поддержку для сообщения об использовании собственной памяти, но это довольно продвинутая концепция, требующая некоторого понимания того, как работает распределение памяти. См. Подробности в разделе &amp;laquo; &lt;a href=&quot;perldebguts#Debugging-Perl-Memory-Usage&quot;&gt;Отладка использования памяти Perl в perldebguts&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a29ee67698d8ff496114e40d0f60aa708da987ff" translate="yes" xml:space="preserve">
          <source>Perl continues to warn (using the warning category &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to output noncharacters.</source>
          <target state="translated">Perl продолжает предупреждать (используя категорию предупреждений &lt;code&gt;&quot;nonchar&quot;&lt;/code&gt; , которая является подкатегорией &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ), если предпринимается попытка вывести символы, отличные от символов.</target>
        </trans-unit>
        <trans-unit id="baa05b026a869001e1e5be6e67df2e5d03445c53" translate="yes" xml:space="preserve">
          <source>Perl currently only supports single-byte locales for &lt;code&gt;LC_COLLATE&lt;/code&gt; . This means that a UTF-8 locale likely will just give you machine-native ordering. Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for the full implementation of the Unicode Collation Algorithm.</source>
          <target state="translated">Perl в настоящее время поддерживает только однобайтовые &lt;code&gt;LC_COLLATE&lt;/code&gt; для LC_COLLATE . Это означает, что локаль UTF-8, скорее всего, просто предоставит вам машинный заказ. Используйте &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; для полной реализации алгоритма сортировки Unicode.</target>
        </trans-unit>
        <trans-unit id="77cf5a91724851c2026eb0ed52027faf2ff9d8f3" translate="yes" xml:space="preserve">
          <source>Perl debug information is frequently required not just by debuggers, but also by modules that need some &quot;special&quot; information to do their job properly, like profilers.</source>
          <target state="translated">Отладочная информация на Perl часто требуется не только отладчиками,но и модулями,которым нужна некоторая &quot;специальная&quot; информация для правильного выполнения своей работы,например,профайлерами.</target>
        </trans-unit>
        <trans-unit id="edcd0b1168988fe6213df824f5ad91c7a66c6c43" translate="yes" xml:space="preserve">
          <source>Perl defines the following zero-width assertions:</source>
          <target state="translated">Perl определяет следующие утверждения нулевой ширины:</target>
        </trans-unit>
        <trans-unit id="6b26390b798af49773d52f4620dbbc3aff54133e" translate="yes" xml:space="preserve">
          <source>Perl deliberately randomizes hash order for security purposes on both ASCII and EBCDIC platforms.</source>
          <target state="translated">Perl сознательно рандомизирует порядок хэша в целях безопасности как на ASCII,так и на EBCDIC платформах.</target>
        </trans-unit>
        <trans-unit id="b360e4dc6087d3b16edb381fbc0c1f20ea026de5" translate="yes" xml:space="preserve">
          <source>Perl derives from the ubiquitous C programming language and to a lesser extent from sed, awk, the Unix shell, and many other tools and languages.</source>
          <target state="translated">Perl происходит от вездесущего языка программирования C и в меньшей степени от sed,awk,оболочки Unix и многих других инструментов и языков.</target>
        </trans-unit>
        <trans-unit id="82ed6e041cbd4aae6a032a9f05ea11dde0c68044" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl выполняет собственное форматирование &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; : он эмулирует C-функцию sprintf (3), но не использует ее, за исключением чисел с плавающей запятой, и даже тогда разрешены только стандартные модификаторы. Поэтому нестандартные расширения в вашем локальном sprintf (3) недоступны в Perl.</target>
        </trans-unit>
        <trans-unit id="9fd3bbafbe5f224f645e29f633eba572a0b47a6b" translate="yes" xml:space="preserve">
          <source>Perl does its own &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; formatting: it emulates the C function sprintf(3), but doesn't use it except for floating-point numbers, and even then only standard modifiers are allowed. Non-standard extensions in your local sprintf(3) are therefore unavailable from Perl.</source>
          <target state="translated">Perl выполняет собственное форматирование &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; : он эмулирует C-функцию sprintf (3), но не использует ее, за исключением чисел с плавающей запятой, и даже тогда разрешены только стандартные модификаторы. Поэтому нестандартные расширения в вашем локальном sprintf (3) недоступны в Perl.</target>
        </trans-unit>
        <trans-unit id="a4d0575e168bcb93baf91092d083b3f45edc7784" translate="yes" xml:space="preserve">
          <source>Perl does not allow overloading of ranges, so you can neither safely use ranges with bigint endpoints, nor is the iterator variable a bigint.</source>
          <target state="translated">Perl не допускает перегрузки диапазонов,поэтому вы не можете безопасно использовать диапазоны с конечными точками bigint,как и переменная итератора bigint.</target>
        </trans-unit>
        <trans-unit id="c115815d6de8f54c97b95bbf1feacf608d2cdd8a" translate="yes" xml:space="preserve">
          <source>Perl does not call the shell to expand wild cards when you pass &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; explicit parameter lists instead of strings with possible shell wildcards in them. Unfortunately, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, and backtick functions provide no such alternate calling convention, so more subterfuge will be required.</source>
          <target state="translated">Perl не вызывает оболочку для раскрытия подстановочных знаков, когда вы передаете явные списки параметров &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; вместо строк с возможными подстановочными знаками оболочки в них. К сожалению, функции &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; и backtick не предоставляют такого альтернативного соглашения о вызовах, поэтому потребуется больше уловок.</target>
        </trans-unit>
        <trans-unit id="acf14eaf9fdbdb615c0b9a213270f3740bd4a2b7" translate="yes" xml:space="preserve">
          <source>Perl does not care about file systems, but the perl library contains many files with long names, so to install it intact one needs a file system which supports long file names.</source>
          <target state="translated">Perl не заботится о файловых системах,но библиотека perl содержит много файлов с длинными именами,поэтому для того,чтобы установить ее нетронутой,нужна файловая система,поддерживающая длинные имена файлов.</target>
        </trans-unit>
        <trans-unit id="5354348a14ac18fad5dfd9ae6dc9f4e8955fd5e4" translate="yes" xml:space="preserve">
          <source>Perl does not depend on the registry, but it can look up certain default values if you choose to put them there. Perl attempts to read entries from &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; and &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; . Entries in the former override entries in the latter. One or more of the following entries (of type REG_SZ or REG_EXPAND_SZ) may be set:</source>
          <target state="translated">Perl не зависит от реестра, но может искать определенные значения по умолчанию, если вы решите поместить их туда. Perl пытается читать записи из &lt;code&gt;HKEY_CURRENT_USER\Software\Perl&lt;/code&gt; и &lt;code&gt;HKEY_LOCAL_MACHINE\Software\Perl&lt;/code&gt; . Записи в первом случае имеют приоритет над записями во втором. Могут быть установлены одна или несколько из следующих записей (типа REG_SZ или REG_EXPAND_SZ):</target>
        </trans-unit>
        <trans-unit id="e6697dea8bad1c38bf0eecc9764ad8eaf5ace311" translate="yes" xml:space="preserve">
          <source>Perl does not enforce private and public parts of its modules as you may have been used to in other languages like C++, Ada, or Modula-17. Perl doesn't have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren't invited, not because it has a shotgun.</source>
          <target state="translated">Perl не использует частные и публичные части своих модулей,к которым вы,возможно,привыкли в других языках,таких как C++,Ada или Modula-17.Perl не увлекается принудительной конфиденциальностью.Он предпочитает,чтобы вы держались подальше от его гостиной,потому что вас не пригласили,а не потому что у него есть дробовик.</target>
        </trans-unit>
        <trans-unit id="7376046122227141976ff6a43223937f5fa71800" translate="yes" xml:space="preserve">
          <source>Perl does not expand &lt;code&gt;~&lt;/code&gt; in filenames, which is good, since some folks use it for their backup files:</source>
          <target state="translated">Perl не расширяет &lt;code&gt;~&lt;/code&gt; в именах файлов, и это хорошо, поскольку некоторые люди используют его для своих файлов резервных копий:</target>
        </trans-unit>
        <trans-unit id="5b47de2bb8098559e3bf2dcabce87f213a6eb4f0" translate="yes" xml:space="preserve">
          <source>Perl does not have any built-in way to express roles. In the past, people just bit the bullet and used multiple inheritance. Nowadays, there are several good choices on CPAN for using roles.</source>
          <target state="translated">Perl не имеет встроенного способа выражения ролей.В прошлом люди просто кусали пулю и использовали множественное наследование.В настоящее время есть несколько хороших вариантов CPAN для использования ролей.</target>
        </trans-unit>
        <trans-unit id="eea568e6b9c913375e5a754c242df8539876547c" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for class definitions. A package is simply a namespace containing variables and subroutines. The only difference is that in a class, the subroutines may expect a reference to an object or the name of a class as the first argument. This is purely a matter of convention, so a class may contain both methods and subroutines which</source>
          <target state="translated">Perl не предоставляет никакого специального синтаксиса для определений классов.Пакет-это просто пространство имен,содержащее переменные и подпрограммы.Единственное отличие состоит в том,что в классе в качестве первого аргумента подпрограмм можно ожидать ссылку на объект или имя класса.Это чисто условно,поэтому класс может содержать как методы,так и подпрограммы,которые</target>
        </trans-unit>
        <trans-unit id="c5c3b122d3c32f38c2b6df0053286a38a52964b9" translate="yes" xml:space="preserve">
          <source>Perl does not provide any special syntax for defining a method. A method is simply a regular subroutine, and is declared with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;. What makes a method special is that it expects to receive either an object or a class name as its first argument.</source>
          <target state="translated">Perl не предоставляет никакого специального синтаксиса для определения метода. Метод - это обычная подпрограмма, объявленная с помощью &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; . Особенность метода заключается в том, что он ожидает получить в качестве первого аргумента либо объект, либо имя класса.</target>
        </trans-unit>
        <trans-unit id="cedf75e55d51d5b15900a202031f864d4002fc15" translate="yes" xml:space="preserve">
          <source>Perl doesn't match multiple characters in a bracketed character class unless the character that maps to them is explicitly mentioned, and it doesn't match them at all if the character class is inverted, which otherwise could be highly confusing. See &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes in perlrecharclass&lt;/a&gt;, and &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;Negation in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Perl не соответствует нескольким символам в классе символов в квадратных скобках, если символ, который им сопоставляется, явно не упомянут, и он не соответствует им вообще, если класс символов инвертирован, что в противном случае могло бы сильно сбивать с толку. См. &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;Разделы Классы символов в квадратных скобках в perlrecharclass&lt;/a&gt; и &lt;a href=&quot;perlrecharclass#Negation&quot;&gt;Отрицание в perlrecharclass&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="160ee861b96d9abcad026bc93515a6480468d14a" translate="yes" xml:space="preserve">
          <source>Perl doesn't officially have a no-op operator, but the bare constants &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are special-cased not to produce a warning in void context, so you can for example safely do</source>
          <target state="translated">Perl официально не имеет оператора no-op, но голые константы &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; имеют специальный корпус, чтобы не выдавать предупреждение в пустом контексте, поэтому вы можете, например, безопасно сделать</target>
        </trans-unit>
        <trans-unit id="ee11bfd628d5bc290b395480aaa995c735fee62a" translate="yes" xml:space="preserve">
          <source>Perl doesn't understand &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; as numeric literals, but you can have them as strings, and Perl will convert them as needed: &quot;Inf&quot; + 1. (You can, however, import them from the POSIX extension; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; and then use them as literals.)</source>
          <target state="translated">Perl не понимает &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; как числовые литералы, но вы можете иметь их как строки, и Perl преобразует их по мере необходимости: &amp;laquo;Inf&amp;raquo; + 1. (Однако вы можете импортировать их из расширения POSIX; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; POSIX qw(Inf NaN);&lt;/code&gt; а затем использовать их как литералы.)</target>
        </trans-unit>
        <trans-unit id="f06c7777ec6a9cec60c6bbba96236c8c49e10f30" translate="yes" xml:space="preserve">
          <source>Perl enables DECC$EFS_CASE_PRESERVE and DECC$ARGV_PARSE_STYLE by default. Note that the latter only takes effect when extended parse is set in the process in which Perl is running. When these features are explicitly disabled in the environment or the CRTL does not support them, Perl follows the traditional CRTL behavior of downcasing command-line arguments and returning file specifications in lower case only.</source>
          <target state="translated">Perl по умолчанию включает DECC$EFS_CASE_PRESERVE и DECC$ARGV_PARSE_STYLE.Обратите внимание,что последнее вступает в силу только в том случае,если в процессе,в котором запущен Perl,задан расширенный синтаксический анализ.Когда эти функции явно отключены в среде или CRTL не поддерживает их,Perl следует традиционному CRTL поведению,заключающемуся в понижении аргументов командной строки и возврате спецификаций файлов только в нижнем регистре.</target>
        </trans-unit>
        <trans-unit id="9a7ffa77beb4b5bfb6e9cd592ffc3d63fefd5d7f" translate="yes" xml:space="preserve">
          <source>Perl environment problems</source>
          <target state="translated">Проблемы окружающей среды Perl</target>
        </trans-unit>
        <trans-unit id="efd321f1d642a6164aeb6c6061ba19e8d5553328" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($myarray[$key])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1023174861c373cd70c764cd28a1ffe52c362de1" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @array;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1efb4e8b7d1884210a677a24eedc3aaa4097d90" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; @new_array = ($scalar1, $scalar2, $scalar3...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="994d82ebaabf45f0326fee88481665e6c0ceb2c7" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c448473e835de05f1fd2f4b0a4490f988bfea19" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; @myarray, $elem;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c7b86a8f8deba930918279e3c4fc84bda790f23" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@myarray);&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4b1f7bdfb013ea4679d96a3812b271f5a3c227d" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; @myarray, ( (&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;) x $n );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="066d54dd7f117a044b123bb5ad4d4d8cf43e8b71" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@myarray = ();&lt;/code&gt; .</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;@myarray = ();&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cef9ffe6af51e7c258630229039bfd2bf1b03f4a" translate="yes" xml:space="preserve">
          <source>Perl equivalent: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</source>
          <target state="translated">Эквивалент Perl: &lt;code&gt;@{&quot;$name&quot;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aec2fb1965c42df65abc2f4f5003e7dd1e44262" translate="yes" xml:space="preserve">
          <source>Perl extension for BSD glob routine</source>
          <target state="translated">Расширение на Perl для глобусного режима BSD</target>
        </trans-unit>
        <trans-unit id="24aff9b9093549c7d05ba26875dcbd18c62f3127" translate="yes" xml:space="preserve">
          <source>Perl extension for SHA-1/224/256/384/512</source>
          <target state="translated">Удлинитель на перл для SHA-1/224/256/384/512</target>
        </trans-unit>
        <trans-unit id="403524ab53fcfa65297b5c6d11da8a41e9bdf68e" translate="yes" xml:space="preserve">
          <source>Perl extension for Version Objects</source>
          <target state="translated">Расширение Perl для объектов версии</target>
        </trans-unit>
        <trans-unit id="c24a560ca7260d4a2d7424b6161a53890073335c" translate="yes" xml:space="preserve">
          <source>Perl extension for sharing data structures between threads</source>
          <target state="translated">Расширение Perl для обмена структурами данных между потоками</target>
        </trans-unit>
        <trans-unit id="3668aadc429b1304c6228d98dc9c4677872a86f1" translate="yes" xml:space="preserve">
          <source>Perl extension to manipulate DCL symbols</source>
          <target state="translated">Расширение Perl для манипулирования DCL-символами</target>
        </trans-unit>
        <trans-unit id="b4ef3d43e200cfbf35d2a7b6f42754d585642e16" translate="yes" xml:space="preserve">
          <source>Perl extensions are packages which provide both XS and Perl code to add new functionality to perl. (XS is a meta-language which simplifies writing C code which interacts with Perl, see &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details.) The Perl code for an extension is treated like any other library module - it's made available in your script through the appropriate &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, and usually defines a Perl package containing the extension.</source>
          <target state="translated">Расширения Perl - это пакеты, которые предоставляют код XS и Perl для добавления новых функций в Perl. (XS - это метаязык, который упрощает написание кода C, который взаимодействует с Perl, см. &lt;a href=&quot;perlxs&quot;&gt;Подробности в perlxs&lt;/a&gt; .) Код Perl для расширения рассматривается как любой другой модуль библиотеки - он становится доступным в вашем скрипте посредством соответствующего &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; оператор и обычно определяет пакет Perl, содержащий расширение.</target>
        </trans-unit>
        <trans-unit id="f81d1af8c2de641461c82be3969f85e5ad3bba8c" translate="yes" xml:space="preserve">
          <source>Perl flavors</source>
          <target state="translated">Вкусы Perl</target>
        </trans-unit>
        <trans-unit id="7d53205939368bef651c20e6009f95c9046101c6" translate="yes" xml:space="preserve">
          <source>Perl for VMS supports redirection of input and output on the command line, using a subset of Bourne shell syntax:</source>
          <target state="translated">Perl для VMS поддерживает перенаправление входных и выходных данных в командной строке,используя подмножество синтаксиса оболочки Борна:</target>
        </trans-unit>
        <trans-unit id="903e263457faf9b024e447e13142cbcffaf64dc8" translate="yes" xml:space="preserve">
          <source>Perl functions</source>
          <target state="translated">Функции Perl</target>
        </trans-unit>
        <trans-unit id="5eab57fb6512949ddd22c0f3a298921f86d2bf10" translate="yes" xml:space="preserve">
          <source>Perl had to change internally to decouple &quot;bytes&quot; from &quot;characters&quot;. It is important that you too change your ideas, if you haven't already, so that &quot;byte&quot; and &quot;character&quot; no longer mean the same thing in your mind.</source>
          <target state="translated">Perl пришлось изменить внутри,чтобы отделить &quot;байты&quot; от &quot;символов&quot;.Важно,чтобы вы тоже изменить свои идеи,если вы еще не сделали,так что &quot;байт&quot; и &quot;символ&quot; больше не означает то же самое в вашем сознании.</target>
        </trans-unit>
        <trans-unit id="eb521c7add3b7379a78d9a6b6db7917dc107bbad" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism for intermixing documentation with source code. While it's expecting the beginning of a new statement, if the compiler encounters a line that begins with an equal sign and a word, like this</source>
          <target state="translated">Perl имеет механизм для смешивания документации с исходным кодом.В ожидании начала нового утверждения,если компилятор встречает строку,которая начинается со знака равенства и слова,подобного этому</target>
        </trans-unit>
        <trans-unit id="1e3d0cb76e6880e13fbb5d4447acbcbd4213008d" translate="yes" xml:space="preserve">
          <source>Perl has a mechanism to help you generate simple reports and charts. To facilitate this, Perl helps you code up your output page close to how it will look when it's printed. It can keep track of things like how many lines are on a page, what page you're on, when to print page headers, etc. Keywords are borrowed from FORTRAN: format() to declare and write() to execute; see their entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. Fortunately, the layout is much more legible, more like BASIC's PRINT USING statement. Think of it as a poor man's nroff(1).</source>
          <target state="translated">Perl имеет механизм, помогающий создавать простые отчеты и диаграммы. Чтобы облегчить это, Perl помогает вам кодировать вашу страницу вывода так, как она будет выглядеть при печати. Он может отслеживать такие вещи, как количество строк на странице, на какой странице вы находитесь, когда печатать заголовки страниц и т. Д. Ключевые слова заимствованы из FORTRAN: format () для объявления и write () для выполнения; их записи в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; . К счастью, макет более разборчивый, больше похож на оператор BASIC PRINT USING. Думайте об этом как о нроффе для бедняков (1).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
