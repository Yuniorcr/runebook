<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="1ee59fdf448204f1b7cf0a44d5a105acb3af778e" translate="yes" xml:space="preserve">
          <source>Now you can compile Perl. Type:</source>
          <target state="translated">Теперь ты можешь собрать Perl.Введите:</target>
        </trans-unit>
        <trans-unit id="dc97bf08f7c15142a6f3d523c401171e1e4e28c7" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Tune up the file</source>
          <target state="translated">Теперь вы можете сгенерировать двоичное распределение. Это делается путем запуска теста дистрибутива CPAN &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Настроить файл</target>
        </trans-unit>
        <trans-unit id="93e496fadabb1e64e6e7d67223c19456b5dbe7c9" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt;. Tune up the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5488e33f64416e81673146fac575b55bb707541" translate="yes" xml:space="preserve">
          <source>Now you can rename the file</source>
          <target state="translated">Теперь вы можете переименовать файл</target>
        </trans-unit>
        <trans-unit id="b4dfea4420493c8513c6f853fcbb48064d4dcaa8" translate="yes" xml:space="preserve">
          <source>Now you can start it with the following (SDF) command:</source>
          <target state="translated">Теперь вы можете запустить его с помощью следующей команды (SDF):</target>
        </trans-unit>
        <trans-unit id="3fdb47077c25bbc7fd05ea6699ff777a03b6a0b4" translate="yes" xml:space="preserve">
          <source>Now you can switch back to blead locally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91ff17e6547bed1e530a38f7ea777276f8d4972" translate="yes" xml:space="preserve">
          <source>Now you can write</source>
          <target state="translated">Теперь вы можете писать</target>
        </trans-unit>
        <trans-unit id="6e8bd31d0e13ce896668841f465f0182170d2759" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь вы можете писать в этот дескриптор файла, используя любой из &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dad49068c95ec062280fac9c3dcad77dc06ce94c" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb28492c5cef9c671966ba77fa7de09ce89c81d" translate="yes" xml:space="preserve">
          <source>Now you can.</source>
          <target state="translated">Теперь ты можешь.</target>
        </trans-unit>
        <trans-unit id="1a87b9f63332f9de75bca22552a19ed7ae7967b2" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt; , which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">Теперь вы не можете изменить &lt;code&gt;$PI&lt;/code&gt; , что, вероятно, в целом хорошо. Это не то же самое, что подпрограмма с константой, которая подлежит оптимизации во время компиляции. Подпрограмма с константой - это прототип, который не принимает аргументов и возвращает постоянное выражение. Подробности смотрите в &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; Прагма является удобным сокращением для них.</target>
        </trans-unit>
        <trans-unit id="c97546944079cddc1746ac13882c5e6cfa5ab3f9" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt;, which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;use constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c321db61248ffe9e9cd3c5b03c9c5342de8be25b" translate="yes" xml:space="preserve">
          <source>Now you check whether $is_tiny_prime[$some_number].</source>
          <target state="translated">Теперь вы проверяете,$is_tiny_prime[$some_number]ли $is_tiny_prime[$some_number].</target>
        </trans-unit>
        <trans-unit id="83fe5a64ce5d7ca3309f06409d39b88da08832f7" translate="yes" xml:space="preserve">
          <source>Now you have all the necessary</source>
          <target state="translated">Теперь у вас есть все необходимое</target>
        </trans-unit>
        <trans-unit id="8fc27d587ac3ae46eb6cab078485ce4e120d86fc" translate="yes" xml:space="preserve">
          <source>Now you have the entire POD document as one great big parse-tree. You can even use the &lt;b&gt;-expand_seq&lt;/b&gt; option to &lt;b&gt;parse_text&lt;/b&gt; to insert whole different kinds of objects. Just don't expect &lt;b&gt;Pod::Parser&lt;/b&gt; to know what to do with them after that. That will need to be in your code. Or, alternatively, you can insert any object you like so long as it conforms to the &lt;b&gt;Pod::ParseTree&lt;/b&gt; interface.</source>
          <target state="translated">Теперь у вас есть весь документ POD как одно большое дерево синтаксического анализа. Вы даже можете использовать параметр &lt;b&gt;-expand_seq&lt;/b&gt; для &lt;b&gt;parse_text,&lt;/b&gt; чтобы вставлять различные типы объектов. Только не ждите, что &lt;b&gt;Pod :: Parser&lt;/b&gt; узнает, что с ними делать после этого. Это должно быть в вашем коде. Или, в качестве альтернативы, вы можете вставить любой объект, который вам нравится, если он соответствует интерфейсу &lt;b&gt;Pod :: ParseTree&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="eb427c950b9b31bacabe117fb02e576d6e7f4125" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">Теперь вы можете использовать для этого дескриптора такие функции, как &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; . Вероятно, самая распространенная функция ввода - это та, которая выглядит как оператор:</target>
        </trans-unit>
        <trans-unit id="367c47e849864052497095e9f7fa487dd90eceb2" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;getc&lt;/code&gt;, and &lt;code&gt;sysread&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6caee9b93719c7443bbaefae78111aa87180e8" translate="yes" xml:space="preserve">
          <source>Now you should be very careful that the outer bracket type is a round one, that is, a parenthesis. That's because you're assigning to an @array, so you need parentheses. If you wanted there</source>
          <target state="translated">Теперь нужно быть очень осторожным,чтобы тип внешней скобки был круглым,то есть скобкой.Это потому,что вы назначаете @array,так что вам нужны скобки.Если бы вы хотели</target>
        </trans-unit>
        <trans-unit id="d66b8a1ad54810e72ec52858762c88f3380e16c6" translate="yes" xml:space="preserve">
          <source>Now you'll see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62389bcb5052013362af7bc38fbef11d7810e62d" translate="yes" xml:space="preserve">
          <source>Now you're ready to build:</source>
          <target state="translated">Теперь ты готов строить:</target>
        </trans-unit>
        <trans-unit id="cb48a5248ec746855c13f0d7ab0feb804820903a" translate="yes" xml:space="preserve">
          <source>Now you're ready to run &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;make test&lt;/code&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3894685c626d75138daa573dc3cd4fad72278a40" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt; !) for further possibilities.</source>
          <target state="translated">Теперь ваш IO будет ASCII для разделов ASCII и EBCDIC для разделов EBCDIC. См. Документацию PerlIO (без &lt;code&gt;Encode::&lt;/code&gt; !) Для получения дополнительных сведений .</target>
        </trans-unit>
        <trans-unit id="7b95b8f4eb02584fba76319179b45221c640f17c" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt;!) for further possibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0c77aa49899b95cf7b7a3e733f8b2e46061080" translate="yes" xml:space="preserve">
          <source>Now!</source>
          <target state="translated">Now!</target>
        </trans-unit>
        <trans-unit id="09be148c7c1b618a5b7b7231898ec72cf009f060" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt; , but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">Теперь &lt;code&gt;-h24&lt;/code&gt; установит для параметра &lt;code&gt;h&lt;/code&gt; значение &lt;code&gt;24&lt;/code&gt; , но пакеты параметров, такие как &lt;code&gt;-vxa&lt;/code&gt; и &lt;code&gt;-h24w80&lt;/code&gt; ,помечаются как ошибки.</target>
        </trans-unit>
        <trans-unit id="330db949eeb51ae2f426c6b4541a1ffbf72e90be" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt;, but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7064702c1fdf6342dfeda7047d72edc982aef863" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">Теперь &lt;code&gt;-vax&lt;/code&gt; установит параметр &lt;code&gt;vax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e294ef877a18e50d3cf43096be573f3ba73196e" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02476416df4a3a9b63bb6cb2d8be8955b7c384a2" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Теперь о том, что вы можете делать с этими обработчиками: возможно, вы захотите записать, какой ключ не удалось для какого класса, а затем умереть. Возможно, вам не нравится &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , и вместо этого вы хотите отправить сообщение об ошибке в STDOUT (или куда-нибудь еще), а затем просто &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c9c99975917c3ed487322ad5c970c3faeddcbc" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;die&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd735cb44e720407db2d25db6e1b3a8402f3fbeb" translate="yes" xml:space="preserve">
          <source>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</source>
          <target state="translated">Теперь,поскольку верхний уровень содержит только ссылки,если вы попытаетесь распечатать ваш массив с помощью простой функции print(),вы получите что-то,что выглядит не очень хорошо,например,вот так:</target>
        </trans-unit>
        <trans-unit id="7f590569b440fce72262993e0bb83b771d091b6a" translate="yes" xml:space="preserve">
          <source>Now, consider this:</source>
          <target state="translated">А теперь подумай об этом:</target>
        </trans-unit>
        <trans-unit id="d7ffbca375f24628b0da0f697f3844b6c5775889" translate="yes" xml:space="preserve">
          <source>Now, create a fork on GitHub to push your branch to, and add it as a remote if you haven't already, as described in the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/working-with-forks&quot;&gt;https://help.github.com/en/articles/working-with-forks&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0caa48ba5eb7d274e599b06285edb5dacdee51ca" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;//a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">Теперь даже &lt;code&gt;[0-9]&lt;/code&gt; может быть затруднительным записывать несколько раз, поэтому в интересах сохранения нажатий клавиш и повышения читабельности регулярных выражений Perl имеет несколько сокращений для общих классов символов, как показано ниже. С момента введения Unicode, если не &lt;code&gt;//a&lt;/code&gt; модификатор // a , эти классы символов соответствуют более чем нескольким символам в диапазоне ASCII.</target>
        </trans-unit>
        <trans-unit id="e2eacdfa4a021a03b4f7ed6c8878ca3eccdafc77" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c643f4f95c9c07182bc1371cc9ce99bbbace4" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;junk&lt;/code&gt; is the same as the string we're trying to add, we can grab the string directly from the SV; &lt;code&gt;SvPVX&lt;/code&gt; is the address of the PV in the SV.</source>
          <target state="translated">Теперь, если &lt;code&gt;junk&lt;/code&gt; совпадает со строкой, которую мы пытаемся добавить, мы можем получить строку прямо из SV; &lt;code&gt;SvPVX&lt;/code&gt; - это адрес PV в SV.</target>
        </trans-unit>
        <trans-unit id="22a7c67c64c0df3c947439ef09bc7a1a5018552e" translate="yes" xml:space="preserve">
          <source>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</source>
          <target state="translated">Теперь представьте,что мы хотим упаковать данные для машины с другим порядком байт.Сначала мы должны выяснить,насколько велики типы данных на целевой машине на самом деле.Предположим,что длины-32 бита в ширину,а шорты-16 бит в ширину.Затем вы можете переписать шаблон как:</target>
        </trans-unit>
        <trans-unit id="5e966fc4eb896c9493f50919b32baf5ee748e75c" translate="yes" xml:space="preserve">
          <source>Now, inside of the &lt;code&gt;WriteMakeFile()&lt;/code&gt; function in your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4997e53db961cf2c8c2533b9ab14d20123173fb" translate="yes" xml:space="preserve">
          <source>Now, let's extend the previous example to return both the sum of the parameters and the difference.</source>
          <target state="translated">Теперь расширим предыдущий пример,чтобы вернуть как сумму параметров,так и разницу.</target>
        </trans-unit>
        <trans-unit id="ac0e50de65e6792eafd44dfb3d472e96b20f9034" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;Net::SMTP&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4d4098c9d3e30a9e536d0fed12c873a45201c2" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;net/smtp&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">Теперь у довольно многих людей есть Acme Transmogrifier, и вам пришлось что-то написать, чтобы обсудить протокол с нуля - вы почти наверняка захотите превратить это в модуль. Уровень, на котором вы его продвигаете, зависит от вас: вам могут понадобиться модули уровня протокола, аналогичные &lt;a href=&quot;net/smtp&quot;&gt;Net :: SMTP,&lt;/a&gt; которые затем взаимодействуют с модулями более высокого уровня, аналогичными &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail :: Send&lt;/a&gt; . Выбор за вами, но вы действительно хотите получить модуль для этого серверного протокола.</target>
        </trans-unit>
        <trans-unit id="f84215108517a61b97d5bb763774a7b31e4947af" translate="yes" xml:space="preserve">
          <source>Now, right after you've just written the above lines, you'd normally have to go open the file ThisProject/I18N/en.pm, and immediately add an entry:</source>
          <target state="translated">Теперь,сразу после того,как вы только что записали вышеуказанные строки,вам обычно нужно открыть файл ThisProject/I18N/en.pm и сразу же добавить запись:</target>
        </trans-unit>
        <trans-unit id="1401c823810e265e57226845c8cc3ee51b8e87e5" translate="yes" xml:space="preserve">
          <source>Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):</source>
          <target state="translated">Теперь,запустив make,вы получите результат,который выглядит примерно так (некоторые длинные строки были укорочены для ясности,а некоторые посторонние были удалены):</target>
        </trans-unit>
        <trans-unit id="6e07caa5beb0db9ce775e3579183bc779cf639f4" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt; . Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">Теперь предположим, что вы хотите найти единственный символ &lt;code&gt;/GX/&lt;/code&gt; . Perl ничего не знает о марсианском языке, поэтому он найдет два байта &amp;laquo;GX&amp;raquo; в &amp;laquo;Я - CVSGXX!&amp;raquo; строка, даже если этого символа нет: просто похоже, что это потому, что &amp;laquo;SG&amp;raquo; стоит рядом с &amp;laquo;XX&amp;raquo;, но настоящего &amp;laquo;GX&amp;raquo; нет. Это большая проблема.</target>
        </trans-unit>
        <trans-unit id="3510dbe78a5971908a5d18e000554027edb2cb1f" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt;. Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf6d464fd8f7b3ee530f1f0a89b5dfa201b3c0c" translate="yes" xml:space="preserve">
          <source>Now, suppose you want to use perlio layers in your XS. We'll use the perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; function as an example.</source>
          <target state="translated">Теперь предположим, что вы хотите использовать слои Perlio в своем XS. В качестве примера мы воспользуемся функцией Perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e40eda745c5999056a9033823cfa2202510fb44" translate="yes" xml:space="preserve">
          <source>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</source>
          <target state="translated">Итак,это наши данные,проанализированные.Полагаю,что сейчас мы можем захотеть суммировать наши доходы и расходы,и добавить в конце нашей бухгалтерской книги еще одну строку-в том же формате-о том,сколько мы принесли и сколько потратили:</target>
        </trans-unit>
        <trans-unit id="b6104104e2da85f59a70d3eb8135a126533dc183" translate="yes" xml:space="preserve">
          <source>Now, the Russian quant method here is responsible not only for implementing the strange logic necessary for figuring out how Russian number-phrases impose case and number on their noun-phrases, but also for inflecting the Russian word for &quot;directory&quot;. How that inflection is to be carried out is no small issue, and among the solutions I've seen, some (like variations on a simple lookup in a hash where all possible forms are provided for all necessary words) are straightforward but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbc9f96a1673b30ff5469c8a5fcf6cbd912ecbd" translate="yes" xml:space="preserve">
          <source>Now, the following calls to your function are all completely equivalent:</source>
          <target state="translated">Теперь все следующие вызовы к вашей функции полностью эквивалентны:</target>
        </trans-unit>
        <trans-unit id="cfc8866cddcad33148adff8ad6715f9f23dc807f" translate="yes" xml:space="preserve">
          <source>Now, there's no particularly obvious way to store anything but strings in a gettext lexicon; so it looks like we just have to start over and make something better, from scratch. I call my shot at a gettext-replacement system &quot;Maketext&quot;, or, in CPAN terms, Locale::Maketext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e7adec8d59750fec2768d3623709e37ef7d868" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt; , as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt; , which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt; . Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt; .</source>
          <target state="translated">Теперь использование &lt;code&gt;--verbose&lt;/code&gt; в командной строке , как и ожидалось, включит &lt;code&gt;$verbose&lt;/code&gt; . Но также можно использовать &lt;code&gt;--noverbose&lt;/code&gt; , который отключит &lt;code&gt;$verbose&lt;/code&gt; , установив для него значение &lt;code&gt;0&lt;/code&gt; . Используя подходящее значение по умолчанию, программа может определить, является ли &lt;code&gt;$verbose&lt;/code&gt; ложным по умолчанию или отключено с помощью &lt;code&gt;--noverbose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e3286afdf8a8f15ad325a81b0628c314540334" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt;, as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt;, which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt;. Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992feec99ff4aecbf2aadccfe96942e35ec305c6" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt; . So we could write the code more compactly as</source>
          <target state="translated">Теперь мы знаем, что в скалярном контексте &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; возвращает истинное или ложное значение. Однако в контексте списка он возвращает список совпадающих значений &lt;code&gt;($1,$2,$3)&lt;/code&gt; . Таким образом, мы могли бы написать код более компактно, как</target>
        </trans-unit>
        <trans-unit id="c881bffc946b525469a86f23ed507e231ad46769" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt;. So we could write the code more compactly as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf36e6267baebdc3ed4fd5c4c6b178499170bce" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be0b7f8c6b8fc26bdc74884bb876598542c7964" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">А что, если вы не хотите использовать это &amp;laquo;и&amp;raquo; с большой буквы? Просто используйте &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt; и приступайте к следующей проблеме. :)</target>
        </trans-unit>
        <trans-unit id="8949eed359cb576e341a415acaa483f999c583a5" translate="yes" xml:space="preserve">
          <source>Now, what we've done here is to launch the built-in perl debugger on our script. It's stopped at the first line of executable code and is waiting for input.</source>
          <target state="translated">Теперь,то,что мы сделали здесь,это запустили встроенный отладчик на perl в наш скрипт.Он останавливается в первой строке исполняемого кода и ждет ввода.</target>
        </trans-unit>
        <trans-unit id="fe56adc9244a6c6d673f2a408e82ab0b02f6ba4d" translate="yes" xml:space="preserve">
          <source>Now, what's this about?</source>
          <target state="translated">Так в чем дело?</target>
        </trans-unit>
        <trans-unit id="c09652f2cdfd968ba019444826ddffee8c37ace4" translate="yes" xml:space="preserve">
          <source>Null AV pointer.</source>
          <target state="translated">Нулевой указатель.</target>
        </trans-unit>
        <trans-unit id="449c4d119d699360473af11bb566b4e5b4167f76" translate="yes" xml:space="preserve">
          <source>Null CV pointer.</source>
          <target state="translated">Нулевой указатель CV.</target>
        </trans-unit>
        <trans-unit id="91a48ce7cb8839ea533848a64134cf5805e52ca4" translate="yes" xml:space="preserve">
          <source>Null HV pointer.</source>
          <target state="translated">Указка &quot;Null HV&quot;.</target>
        </trans-unit>
        <trans-unit id="d7c8d520f057dea587bf4d58fd9c051240f622ed" translate="yes" xml:space="preserve">
          <source>Null SV pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">Нулевой указатель SV. (Больше не доступно, если определено &lt;code&gt;PERL_CORE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ae2f5f2d47b6cb2ea376cf5cd766fe09fd6a57af" translate="yes" xml:space="preserve">
          <source>Null character pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">Указатель на нулевой символ. (Больше не доступно, если определено &lt;code&gt;PERL_CORE&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="ebc5c9f306915d4135b8053056b0178c088e8651" translate="yes" xml:space="preserve">
          <source>Null picture in formline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4bd9c62d3ecb53b530fd1a90e4da66bcf3402d" translate="yes" xml:space="preserve">
          <source>Null realloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebe00d5eb5dc6465abbd73f1052105fa12c1088" translate="yes" xml:space="preserve">
          <source>Nullav</source>
          <target state="translated">Nullav</target>
        </trans-unit>
        <trans-unit id="0f70fd3842939caf1b28e5e61343267fb7df7093" translate="yes" xml:space="preserve">
          <source>Nullch</source>
          <target state="translated">Nullch</target>
        </trans-unit>
        <trans-unit id="32ecb682e3f060838162e9bbbbf1d860a0d1dca5" translate="yes" xml:space="preserve">
          <source>Nullcv</source>
          <target state="translated">Nullcv</target>
        </trans-unit>
        <trans-unit id="e547450e00d976847c97a5b3855e227ed6ee122c" translate="yes" xml:space="preserve">
          <source>Nullhv</source>
          <target state="translated">Nullhv</target>
        </trans-unit>
        <trans-unit id="38b0ef271640da14cdf67cd20db21125619c6b53" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt; , where</source>
          <target state="translated">Нуллопы отображаются как &lt;code&gt;ex-opname&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="f59d50c5f13fde39f97b92afad489b0c203d91e4" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c3cf48b244deeb77cbf7fb2d31febc3616e04" translate="yes" xml:space="preserve">
          <source>Nullsv</source>
          <target state="translated">Nullsv</target>
        </trans-unit>
        <trans-unit id="c9d82135ee15642aa7ae8817dc570334ab80622b" translate="yes" xml:space="preserve">
          <source>Number of iterations run.</source>
          <target state="translated">Количество запущенных итераций.</target>
        </trans-unit>
        <trans-unit id="78e655a3cb9b2e5174023b5b4b515e74ae0fcc89" translate="yes" xml:space="preserve">
          <source>Number of lines to save?</source>
          <target state="translated">Количество сохраняемых строк?</target>
        </trans-unit>
        <trans-unit id="39678ab676a3f472a8537a68ada508040f950313" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.45000 has 8 and 0.000123 has 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3230c13d5bd80dac7aacde117d72a74866ed2d4e" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.</source>
          <target state="translated">Количество значащих цифр.Значимые нули не учитываются.Число может иметь точность больше,чем ненулевые цифры,если в нем есть нули или следящие нули.Например,123.456 имеет A 6,10203 имеет 5,123.0506 имеет 7,123.450000 имеет 8 и 0.000123 имеет 3.</target>
        </trans-unit>
        <trans-unit id="c5aadd077767ce8ba345b0317eb500c0c374d288" translate="yes" xml:space="preserve">
          <source>Number too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa074fe25a6265136343f6af71868d2eb3ffdf5" translate="yes" xml:space="preserve">
          <source>Number with no digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6588ae11e1dcdc853623ae99d37042a891fc6f6e" translate="yes" xml:space="preserve">
          <source>Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed 65535.</source>
          <target state="translated">Количество использований хранится как 16-битное беззнаковое целое число,поэтому не может превышать 65535.</target>
        </trans-unit>
        <trans-unit id="86074e1eaaba5bdf1182fbfd1a5e5a087cf06d78" translate="yes" xml:space="preserve">
          <source>Numbered capture callbacks</source>
          <target state="translated">Пронумерованные обратные вызовы на захват</target>
        </trans-unit>
        <trans-unit id="2f3ef08b1556d451a2f171bcd8cc5fa9d0a67578" translate="yes" xml:space="preserve">
          <source>Numbers containing a fractional or exponential part will always be represented as numeric (floating point) values, possibly at a loss of precision (in which case you might lose perfect roundtripping ability, but the JSON number will still be re-encoded as a JSON number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a23d9255bf80cf55daa9a73c5c3503075a5fb9f" translate="yes" xml:space="preserve">
          <source>Numbers don't need quotes around them:</source>
          <target state="translated">Цифры не нуждаются в кавычках вокруг них:</target>
        </trans-unit>
        <trans-unit id="93fc21b9cdd7d3eceb58c305ecfc300113f08a16" translate="yes" xml:space="preserve">
          <source>Numbers endianness and Width</source>
          <target state="translated">Эндианность и ширина чисел</target>
        </trans-unit>
        <trans-unit id="a356a38fbf19c9a7a85fc1034cb6b13b5959c015" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">Цифры в скобках указывают на общее количество точек кода Юникода,совпадающих со свойством.Для выделения тех свойств,которые вообще не совпадают с точками кода,перечисляются также в отдельном разделе,следующем за таблицей.</target>
        </trans-unit>
        <trans-unit id="34ed490a2fac8e8118b8b1dcb98a2f46ca2806fc" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For the entries that give the longest, most descriptive version of the property, the count is followed by a list of some of the code points matched by it. The list includes all the matched characters in the 0-255 range, enclosed in the familiar [brackets] the same as a regular expression bracketed character class. Following that, the next few higher matching ranges are also given. To avoid visual ambiguity, the SPACE character is represented as &lt;code&gt;\x20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e0145e1d23363006c456eb88791d281e2a1493" translate="yes" xml:space="preserve">
          <source>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</source>
          <target state="translated">Цифры в диапазоне 160-255 относятся к символам латинского алфавита-1 (также определяемым там Юникодом,с тем же значением).Цифры выше 255 должны пониматься как относящиеся к символам Юникода.</target>
        </trans-unit>
        <trans-unit id="bdfe233d649ccb45ebc573d4ee247d96a2053e8c" translate="yes" xml:space="preserve">
          <source>Numeric Fields</source>
          <target state="translated">Числовые поля</target>
        </trans-unit>
        <trans-unit id="8c7c98efa8c2ec06026f0650448ebfec04745d0d" translate="yes" xml:space="preserve">
          <source>Numeric comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="translated">числовое преобразование</target>
        </trans-unit>
        <trans-unit id="c721f5217c35d940494ce8935e78185eea92c32c" translate="yes" xml:space="preserve">
          <source>Numeric format result too large</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="translated">Числовые функции</target>
        </trans-unit>
        <trans-unit id="684a5952f400383c4099f6088a711c758da11a61" translate="yes" xml:space="preserve">
          <source>Numeric literals are specified in any of the following floating point or integer formats:</source>
          <target state="translated">Числовые литералы задаются в любом из следующих форматов с плавающей точкой или в формате целого числа:</target>
        </trans-unit>
        <trans-unit id="a4e50290598ea70f1c5580bbcbcb1b35364e36b2" translate="yes" xml:space="preserve">
          <source>Numeric operators and numeric conversions</source>
          <target state="translated">Числовые операторы и числовые преобразования</target>
        </trans-unit>
        <trans-unit id="44e5694a92fbb0b839eb3d472cdd4e3a72b88c8c" translate="yes" xml:space="preserve">
          <source>Numeric variables with more than one digit may not start with '0'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d013232ca01b901c06ddf5aa9483529f278d91" translate="yes" xml:space="preserve">
          <source>Numeric_Value</source>
          <target state="translated">Numeric_Value</target>
        </trans-unit>
        <trans-unit id="0524b0c0ac8bde27b90181fe29d1e0ee87d85606" translate="yes" xml:space="preserve">
          <source>Numification</source>
          <target state="translated">Numification</target>
        </trans-unit>
        <trans-unit id="9070f7ffe825f6632ea9c8c8c4cb452e5ea710fb" translate="yes" xml:space="preserve">
          <source>Numify returns the number of bytes in the instance data.</source>
          <target state="translated">Нумерация возвращает количество байт в данных экземпляра.</target>
        </trans-unit>
        <trans-unit id="1930939e1cfe41540640ae63b0d1c9cd976b8003" translate="yes" xml:space="preserve">
          <source>NushuSources.txt</source>
          <target state="translated">NushuSources.txt</target>
        </trans-unit>
        <trans-unit id="785fb0c8fda67339daa5891e78532ef7046332eb" translate="yes" xml:space="preserve">
          <source>Nuts and bolts of testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="54d43a5ef4e27b9c279536a9f91a0f278f1c11b7" translate="yes" xml:space="preserve">
          <source>O - Generic interface to Perl Compiler backends</source>
          <target state="translated">O-Общий интерфейс к бэкэндам Perl-компилятора</target>
        </trans-unit>
        <trans-unit id="7f2e040017a2a32e5149e8541c71a3f6ab2be70d" translate="yes" xml:space="preserve">
          <source>OA_BASEOP</source>
          <target state="translated">OA_BASEOP</target>
        </trans-unit>
        <trans-unit id="a0232d9c77de9ad3ad30f960003fca0ebf21434a" translate="yes" xml:space="preserve">
          <source>OA_BINOP</source>
          <target state="translated">OA_BINOP</target>
        </trans-unit>
        <trans-unit id="dd4e2946f44fa938f47620909c47a03ec9907915" translate="yes" xml:space="preserve">
          <source>OA_COP</source>
          <target state="translated">OA_COP</target>
        </trans-unit>
        <trans-unit id="8bb6941ea27d2f4edcd36aa185a95c1934071dae" translate="yes" xml:space="preserve">
          <source>OA_LISTOP</source>
          <target state="translated">OA_LISTOP</target>
        </trans-unit>
        <trans-unit id="1f95f49a3cc0d9c9dce498b8fb55f7d434ffef98" translate="yes" xml:space="preserve">
          <source>OA_LOGOP</source>
          <target state="translated">OA_LOGOP</target>
        </trans-unit>
        <trans-unit id="080d4766c1c017ed91c21efdfd770542db5231ba" translate="yes" xml:space="preserve">
          <source>OA_LOOP</source>
          <target state="translated">OA_LOOP</target>
        </trans-unit>
        <trans-unit id="b82424ac68328551cd5b311d9b76afd01dc2b8ec" translate="yes" xml:space="preserve">
          <source>OA_PADOP</source>
          <target state="translated">OA_PADOP</target>
        </trans-unit>
        <trans-unit id="1c24597939e0dd807c389498cedbeb0fddd031c5" translate="yes" xml:space="preserve">
          <source>OA_PMOP</source>
          <target state="translated">OA_PMOP</target>
        </trans-unit>
        <trans-unit id="388be58f270e37e48cf5f4058c11eb99107d89f1" translate="yes" xml:space="preserve">
          <source>OA_PVOP_OR_SVOP</source>
          <target state="translated">OA_PVOP_OR_SVOP</target>
        </trans-unit>
        <trans-unit id="565cd3fb7a20fefb8a748b15fbc632d71f3b0236" translate="yes" xml:space="preserve">
          <source>OA_SVOP</source>
          <target state="translated">OA_SVOP</target>
        </trans-unit>
        <trans-unit id="6e405aaa77ee94bd8832317336e851e6173b598b" translate="yes" xml:space="preserve">
          <source>OA_UNOP</source>
          <target state="translated">OA_UNOP</target>
        </trans-unit>
        <trans-unit id="2f1e5004dfcf9dde92d5fd30ce523548742521cc" translate="yes" xml:space="preserve">
          <source>OBJ</source>
          <target state="translated">OBJ</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="886bca430376624f1fa6be07dffa149e06727c43" translate="yes" xml:space="preserve">
          <source>OBJECT METHODS</source>
          <target state="translated">ЦЕЛЕВЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="bb24863eee0d4bd1920af16c1ccee60c7f9c3be6" translate="yes" xml:space="preserve">
          <source>OBJECT SERIALISATION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6faefbb52c9934839e9dcd31987ac3958fd8ae" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED FUNDAMENTALS</source>
          <target state="translated">ОБЪЕКТНО-ОРИЕНТИРОВАННЫЕ ОСНОВЫ</target>
        </trans-unit>
        <trans-unit id="edf9874a257ef8b1a94138e136d570010b98cb88" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED INTERFACE</source>
          <target state="translated">ОБЪЕКТНО-ОРИЕНТИРОВАННЫЙ ИНТЕРФЕЙС</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="74d964f379ca5f7a63963447b2e66da24098ac03" translate="yes" xml:space="preserve">
          <source>OCTETS</source>
          <target state="translated">OCTETS</target>
        </trans-unit>
        <trans-unit id="05862bdb9f65a88577df4e19fea889c438e90640" translate="yes" xml:space="preserve">
          <source>ODBM_File</source>
          <target state="translated">ODBM_File</target>
        </trans-unit>
        <trans-unit id="7e05f5ed4d1b9fde9620b516a5a0c77a7eb29821" translate="yes" xml:space="preserve">
          <source>ODBM_File - Tied access to odbm files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdefafa72aee75553cdc6a69cd8b93613e4f45c" translate="yes" xml:space="preserve">
          <source>OFFSETS</source>
          <target state="translated">OFFSETS</target>
        </trans-unit>
        <trans-unit id="90916aa5c9b7aec2f126aa735cbb92f018d5530c" translate="yes" xml:space="preserve">
          <source>OFFSETSDBG</source>
          <target state="translated">OFFSETSDBG</target>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="20e099ce66f09623331e4f7ac57998439d896891" translate="yes" xml:space="preserve">
          <source>OK (say, this system-dependent module builds in a subdirectory of some other distribution, or is listed as a dependency in a CPAN::Bundle, but the functionality is supported by different means on the current architecture).</source>
          <target state="translated">OK (скажем,этот зависящий от системы модуль строится в поддиректории какого-нибудь другого дистрибутива,или указан как зависимый в CPAN::Bundle,но функциональность поддерживается разными средствами на текущей архитектуре).</target>
        </trans-unit>
        <trans-unit id="01ac8af6582beb05b51e97a2306cc05bed91ec81" translate="yes" xml:space="preserve">
          <source>OK, as opposed to</source>
          <target state="translated">Хорошо,в отличие от</target>
        </trans-unit>
        <trans-unit id="42c8e2f5d8fdbf542c870810fe22e5463fc2fa22" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt; , didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; says:</source>
          <target state="translated">Хорошо, это начало, но что случилось с пробелами? Мы поставили &lt;code&gt;x&lt;/code&gt; , не так ли? Не следует ли перескакивать вперед? Посмотрим, что написано на &lt;a href=&quot;functions/pack&quot;&gt;упаковке&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="36f7ee24c9b6c25eb367d474e774055820afae57" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt;, didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;perlfunc#pack&quot;&gt;&quot;pack&quot; in perlfunc&lt;/a&gt; says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2244411f280d2b7d311acac7ca58215079a5a39f" translate="yes" xml:space="preserve">
          <source>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</source>
          <target state="translated">Хорошо,давайте еще раз взглянем на некоторые из наших данных;на самом деле,мы включим заголовки,и удобную линейку,чтобы мы могли отслеживать,где мы находимся.</target>
        </trans-unit>
        <trans-unit id="02b9f4d433d48fd34c45be1068128628f753ca51" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt; , which don't take a corresponding item from the list:</source>
          <target state="translated">Ладно, давайте перекусим. Вот один из способов получить правильное выравнивание, вставив коды шаблона &lt;code&gt;x&lt;/code&gt; , которые не берут соответствующий элемент из списка:</target>
        </trans-unit>
        <trans-unit id="5f004dfa733000f32dac52f2362a807ead5a0ec9" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt;, which don't take a corresponding item from the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cced79fbf573273c9277ae4c911cbf530c88fb" translate="yes" xml:space="preserve">
          <source>OK, the last one was actually an Obfuscated Perl Contest entry. :-)</source>
          <target state="translated">Хорошо,последняя запись была на самом деле Обфусцированным Perl Contest.:-)</target>
        </trans-unit>
        <trans-unit id="57ecc84fea778a647ea6d7f2310ef9bca45201e0" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt; . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">Хорошо, что дальше? Между датой и описанием стоит пустой столбец; мы хотим пропустить это. В &lt;code&gt;x&lt;/code&gt; означает шаблон &amp;laquo;пропустить вперед&amp;raquo;, поэтому мы хотим , чтобы один из них. Затем у нас есть еще одна группа символов, от 12 до 38. Это еще 27 символов, отсюда &lt;code&gt;A27&lt;/code&gt; . (Не делайте ошибку столбика забора - от 12 до 38 символов 27, а не 26. Считайте их!)</target>
        </trans-unit>
        <trans-unit id="05a96155067c83cf8e468762a0e54175339f79a8" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt;. (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f26553401469ee2b31b15d3391338fc7e46d2bc" translate="yes" xml:space="preserve">
          <source>OK, you know the basics of regexps and you want to know more. If matching regular expressions is analogous to a walk in the woods, then the tools discussed in Part 1 are analogous to topo maps and a compass, basic tools we use all the time. Most of the tools in part 2 are analogous to flare guns and satellite phones. They aren't used too often on a hike, but when we are stuck, they can be invaluable.</source>
          <target state="translated">Ладно,ты знаешь основы регэкспрессов и хочешь знать больше.Если совпадение регулярных выражений аналогично прогулке в лесу,то инструменты,обсуждаемые в части 1,аналогичны топокартам и компасу,базовым инструментам,которыми мы постоянно пользуемся.Большинство инструментов в части 2 аналогичны ракетным установкам и спутниковым телефонам.Они не очень часто используются в походах,но когда мы застряли,они могут быть бесценны.</target>
        </trans-unit>
        <trans-unit id="2171105911206b856b529e816e5973ea3d92c2e5" translate="yes" xml:space="preserve">
          <source>OK. That's the C part done. Now we must do two additional things before this patch is ready to go: we've changed the behaviour of Perl, and so we must document that change. We must also provide some more regression tests to make sure our patch works and doesn't create a bug somewhere else along the line.</source>
          <target state="translated">ХОРОШО.Это часть С закончена.Теперь мы должны сделать две дополнительные вещи,прежде чем патч будет готов к использованию:мы изменили поведение Perl,и поэтому мы должны задокументировать это изменение.Мы также должны предоставить еще несколько регрессионных тестов,чтобы убедиться,что наш патч работает и не создает ошибку где-нибудь еще.</target>
        </trans-unit>
        <trans-unit id="52e443591494f06d89603d027dbcc15ec5f21ac5" translate="yes" xml:space="preserve">
          <source>OLD BUILD INSTRUCTIONS</source>
          <target state="translated">СТАРЫЕ ИНСТРУКЦИИ ПО СТРОИТЕЛЬСТВУ</target>
        </trans-unit>
        <trans-unit id="1b8244806f0fe85fbdfb28350aa4197cefa6d7d6" translate="yes" xml:space="preserve">
          <source>OLD PERL VERSIONS</source>
          <target state="translated">СТАРЫЕ ВЕРСИИ PERL</target>
        </trans-unit>
        <trans-unit id="b25c8ed636326794258081a0a80bab33a84b2f10" translate="yes" xml:space="preserve">
          <source>ONE STEP FORWARD</source>
          <target state="translated">НА ОДИН ШАГ ВПЕРЕД</target>
        </trans-unit>
        <trans-unit id="3265add34ef90b3d5d5f9d59898e2a3656834e0f" translate="yes" xml:space="preserve">
          <source>ONE STEP SIDEWAYS</source>
          <target state="translated">ОДИН ШАГ В СТОРОНУ</target>
        </trans-unit>
        <trans-unit id="65b7fafd1d758275b2afd66a14ad17bf21acd2fc" translate="yes" xml:space="preserve">
          <source>ONESIDED LEXICONS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12b54c6a3deda565624403d547e7ef70be9c7d" translate="yes" xml:space="preserve">
          <source>ONFAIL</source>
          <target state="translated">ONFAIL</target>
        </trans-unit>
        <trans-unit id="b144599df5b9973435563870d7ba296904ec1710" translate="yes" xml:space="preserve">
          <source>ONLY</source>
          <target state="translated">ONLY</target>
        </trans-unit>
        <trans-unit id="e3c4c3d0eba1879f6f92c682389bed6ffbf94f06" translate="yes" xml:space="preserve">
          <source>OO INTERFACE</source>
          <target state="translated">ООО &quot;ИНТЕРФЕЙС</target>
        </trans-unit>
        <trans-unit id="1433bf1bd15078b056fe76d6547c4bb2a283c920" translate="yes" xml:space="preserve">
          <source>OO Interface</source>
          <target state="translated">интерфейс ООО</target>
        </trans-unit>
        <trans-unit id="e9a2811eef61d81b9e5a20155aec53e34b502e28" translate="yes" xml:space="preserve">
          <source>OO Perl</source>
          <target state="translated">ООО &quot;Перл</target>
        </trans-unit>
        <trans-unit id="3615e232deb829e0d1569b8035de6913840b260b" translate="yes" xml:space="preserve">
          <source>OO Perl is relatively simple and is implemented using references which know what sort of object they are based on Perl's concept of packages. However, OO Perl is largely beyond the scope of this document. Read &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">OO Perl относительно прост и реализован с использованием ссылок, которые знают, какой тип объектов они основаны на концепции пакетов Perl. Однако OO Perl в значительной степени выходит за рамки этого документа. Прочтите &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; и &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2141f42c40de947ddd0e477a1e88d39467ae8b5d" translate="yes" xml:space="preserve">
          <source>OO System Summary</source>
          <target state="translated">Системная сводка ООО</target>
        </trans-unit>
        <trans-unit id="e22cbd43f54a4419ac3832ce3ab610e1f892e4aa" translate="yes" xml:space="preserve">
          <source>OO interface to the select system call</source>
          <target state="translated">Интерфейс OO к выбранному системному вызову</target>
        </trans-unit>
        <trans-unit id="50841444197610a772ed0bf8061ebbec3fb69d4e" translate="yes" xml:space="preserve">
          <source>OO interface to users netrc file</source>
          <target state="translated">OO-интерфейс к файлу netrc пользователей</target>
        </trans-unit>
        <trans-unit id="e5646c2e78bf00bf2def681a7c47f39c5c233aee" translate="yes" xml:space="preserve">
          <source>OOP style</source>
          <target state="translated">стиль ООП</target>
        </trans-unit>
        <trans-unit id="01de497f472a97643f711e0af439f57cbf98b7cc" translate="yes" xml:space="preserve">
          <source>OP TREES</source>
          <target state="translated">ОПЫ</target>
        </trans-unit>
        <trans-unit id="d97b094405ac341f25845d574d3003452633970d" translate="yes" xml:space="preserve">
          <source>OP class abbreviations</source>
          <target state="translated">аббревиатуры класса ОП</target>
        </trans-unit>
        <trans-unit id="e5a964607f5e2d840aa946796053a87561ef64ff" translate="yes" xml:space="preserve">
          <source>OP flags abbreviations</source>
          <target state="translated">аббревиатуры флагов ОП</target>
        </trans-unit>
        <trans-unit id="c0c894eca9e57589b7dd798f6fc13ef59d8fced2" translate="yes" xml:space="preserve">
          <source>OP flags are either public or private. The public flags alter the behavior of each opcode in consistent ways, and are represented by 0 or more single characters.</source>
          <target state="translated">Флаги ОП являются либо государственными,либо частными.Общедоступные флаги изменяют поведение каждого опкода последовательными способами и представлены 0 или более единичными символами.</target>
        </trans-unit>
        <trans-unit id="4e1c899139139b6a62148bc5314166d68c3c0058" translate="yes" xml:space="preserve">
          <source>OP op_private flag definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bddb20f13d7f760a35db0afa01405e65b1c65f3" translate="yes" xml:space="preserve">
          <source>OP-RELATED CLASSES</source>
          <target state="translated">СВЯЗАННЫЕ С ОПЕРАЦИЕЙ КЛАССЫ</target>
        </trans-unit>
        <trans-unit id="134d5bae173a0d828238edb09ac60f90d32a7d18" translate="yes" xml:space="preserve">
          <source>OPEN this, filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9931dad0f7eb6ff4da51ab9c192c2a065a7d0255" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION - это один из LOCK_SH, LOCK_EX или LOCK_UN, возможно в сочетании с LOCK_NB. Эти константы традиционно имеют значения 1, 2, 8 и 4, но вы можете использовать символьные имена, если импортируете их из модуля &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; либо по отдельности, либо как группу с помощью тега &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . LOCK_SH запрашивает разделяемую блокировку, LOCK_EX запрашивает исключительную блокировку, а LOCK_UN освобождает ранее запрошенную блокировку. Если LOCK_NB побитовое ИЛИ с LOCK_SH или LOCK_EX, тогда &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; возвращается немедленно, а не блокирует ожидание блокировки; проверьте статус возврата, чтобы узнать, получили ли вы его.</target>
        </trans-unit>
        <trans-unit id="5806c98abb4bc38de2885393f139558efaa4744b" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION - это один из LOCK_SH, LOCK_EX или LOCK_UN, возможно в сочетании с LOCK_NB. Эти константы традиционно имеют значения 1, 2, 8 и 4, но вы можете использовать символьные имена, если импортируете их из модуля &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; либо по отдельности, либо как группу с помощью тега &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . LOCK_SH запрашивает разделяемую блокировку, LOCK_EX запрашивает исключительную блокировку, а LOCK_UN освобождает ранее запрошенную блокировку. Если LOCK_NB побитовое ИЛИ с LOCK_SH или LOCK_EX, тогда &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; возвращается немедленно, а не блокирует ожидание блокировки; проверьте статус возврата, чтобы узнать, получили ли вы его.</target>
        </trans-unit>
        <trans-unit id="58928b6b598b49fbbad1c76c170db949cd86f725" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:flock&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277a5e5c068658adb7eeea0e8ac338b111cfff2f" translate="yes" xml:space="preserve">
          <source>OPERATIONS</source>
          <target state="translated">OPERATIONS</target>
        </trans-unit>
        <trans-unit id="ae6eaba46b51b460ad70f762d13737864d558ddb" translate="yes" xml:space="preserve">
          <source>OPERATOR DIFFERENCES</source>
          <target state="translated">РАЗЛИЧИЯ ОПЕРАТОРОВ</target>
        </trans-unit>
        <trans-unit id="3b9833465b980fc8907d152fbd1be4ed82789a85" translate="yes" xml:space="preserve">
          <source>OPERATORS</source>
          <target state="translated">OPERATORS</target>
        </trans-unit>
        <trans-unit id="06c49349926c115048c467e62819168f88084bea" translate="yes" xml:space="preserve">
          <source>OPTIMISE</source>
          <target state="translated">OPTIMISE</target>
        </trans-unit>
        <trans-unit id="4f728fb4e19e018dc7c2672b0908d6be76bddf1f" translate="yes" xml:space="preserve">
          <source>OPTIMISEM</source>
          <target state="translated">OPTIMISEM</target>
        </trans-unit>
        <trans-unit id="02ce66c3b2f62920ab55a0e848d4ded3f5f982b7" translate="yes" xml:space="preserve">
          <source>OPTIMIZE</source>
          <target state="translated">OPTIMIZE</target>
        </trans-unit>
        <trans-unit id="8a61db568f56cdf729bb2bcffb35bc1a208ff62c" translate="yes" xml:space="preserve">
          <source>OPTIONAL FIELDS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463186385d27ae21b6cfb79380a5979894ad32c0" translate="yes" xml:space="preserve">
          <source>OPTIONAL PARAMETERS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0b2762a37fa9b498b0ef0041758a02e1b217bd" translate="yes" xml:space="preserve">
          <source>OPTIONAL SUBROUTINE/METHOD OVERRIDES</source>
          <target state="translated">ДОПОЛНИТЕЛЬНЫЕ ПОДПРОГРАММЫ/ПЕРЕХОДЫ МЕТОДОВ</target>
        </trans-unit>
        <trans-unit id="3c86eca6569badf198a635b289a628e0713ed7b0" translate="yes" xml:space="preserve">
          <source>OPTIONAL-INFO</source>
          <target state="translated">OPTIONAL-INFO</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="cfee3b3e47c3ccac4481ec3d455bf43de1a65fd1" translate="yes" xml:space="preserve">
          <source>OPTIONS AND ARGUMENTS</source>
          <target state="translated">ВАРИАНТЫ И АРГУМЕНТЫ</target>
        </trans-unit>
        <trans-unit id="6409ae0433181a6f096278e81922ef91fcf094d5" translate="yes" xml:space="preserve">
          <source>OPTIONS/ARGUMENTS</source>
          <target state="translated">OPTIONS/ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="d02651d637b66f91c995f98ff893920c6613a814" translate="yes" xml:space="preserve">
          <source>OPTS consists of any of the options that are available when creating the &lt;code&gt;$z&lt;/code&gt; object.</source>
          <target state="translated">OPTS состоит из любых параметров, доступных при создании объекта &lt;code&gt;$z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34e983dffbba74010d0b834918e8b9de427ff5bf" translate="yes" xml:space="preserve">
          <source>OPTS is a combination of the following options:</source>
          <target state="translated">OPTS является комбинацией следующих опций:</target>
        </trans-unit>
        <trans-unit id="443cfbc1735fa88324f99c052a719f69f770de00" translate="yes" xml:space="preserve">
          <source>OP_CLASS</source>
          <target state="translated">OP_CLASS</target>
        </trans-unit>
        <trans-unit id="257329c9527baa8930f69f20f88bd1b9492d9148" translate="yes" xml:space="preserve">
          <source>OP_DESC</source>
          <target state="translated">OP_DESC</target>
        </trans-unit>
        <trans-unit id="95a97252650f52a0edc590efc17643d272eecd14" translate="yes" xml:space="preserve">
          <source>OP_NAME</source>
          <target state="translated">OP_NAME</target>
        </trans-unit>
        <trans-unit id="664b383a7365636329fa816c917a23ae28c5aba2" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS</source>
          <target state="translated">OP_TYPE_IS</target>
        </trans-unit>
        <trans-unit id="745e8a6c1fc90c064d4d4edecae8bb1c615be59a" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS_OR_WAS</source>
          <target state="translated">OP_TYPE_IS_OR_WAS</target>
        </trans-unit>
        <trans-unit id="bf9f9c661a64325d7940c6088a152e09a3273a85" translate="yes" xml:space="preserve">
          <source>ORDER OF APPLICATION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686fecd15046059a1461463f65cd5916d98af39b" translate="yes" xml:space="preserve">
          <source>ORIGMARK</source>
          <target state="translated">ORIGMARK</target>
        </trans-unit>
        <trans-unit id="6b6a53f5c91030f120c92b395563cf165ba2b731" translate="yes" xml:space="preserve">
          <source>ORcpt is also part of the SMTP DSN extension according to RFC3461. It is used to pass along the original recipient that the mail was first sent to. The machine that generates a DSN will use this address to inform the sender, because he can't know if recipients get rewritten by mail servers. It is expected to be in a format as required by RFC3461, xtext-encoded.</source>
          <target state="translated">ORcpt также является частью SMTP DSN расширения согласно RFC3461.Оно используется для передачи оригинального получателя,которому почта была отправлена в первую очередь.Машина,генерирующая DSN,будет использовать этот адрес для информирования отправителя,поскольку он не может знать,переписываются ли получатели почтовыми серверами.Предполагается,что он должен быть в формате,требуемом RFC3461,с xtext-кодировкой.</target>
        </trans-unit>
        <trans-unit id="3e55c8accb9b59a4e2e3860b73d18e283bd63d08" translate="yes" xml:space="preserve">
          <source>OS ISSUES</source>
          <target state="translated">ОС ОС ОС</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7db916096936ab02b469184b00a31ffb7e99f9" translate="yes" xml:space="preserve">
          <source>OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">Настройка ОС Экстравиатуры::Подкласс MakeMaker</target>
        </trans-unit>
        <trans-unit id="a507b0570eef10c513490b530ff7cffb662e9519" translate="yes" xml:space="preserve">
          <source>OS level</source>
          <target state="translated">уровень ОС</target>
        </trans-unit>
        <trans-unit id="53b5eb00477f53acb0522cf8349b912973394461" translate="yes" xml:space="preserve">
          <source>OS-Related References</source>
          <target state="translated">Связанные с ОС ссылки</target>
        </trans-unit>
        <trans-unit id="49f5479219ce3d4b44c672d19081b527acbff3f8" translate="yes" xml:space="preserve">
          <source>OS/2</source>
          <target state="translated">OS/2</target>
        </trans-unit>
        <trans-unit id="9b1d79b903ce0b8766b4e5764e59485f0c5a70da" translate="yes" xml:space="preserve">
          <source>OS/2 .INF file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ee378ae6f39b56008cc84e4ccbbff11e3e4428" translate="yes" xml:space="preserve">
          <source>OS/2 _.INF_ file</source>
          <target state="translated">OS/2 _.INF_файл</target>
        </trans-unit>
        <trans-unit id="8170ede7c45b17e28c246c077e40c6bb259a2169" translate="yes" xml:space="preserve">
          <source>OS/2 is OS/2</source>
          <target state="translated">OS/2-это OS/2</target>
        </trans-unit>
        <trans-unit id="9f2b9449bdc8f69e4d1ebfaee7720b50c48e466a" translate="yes" xml:space="preserve">
          <source>OS/2 toolkit</source>
          <target state="translated">набор инструментов OS/2</target>
        </trans-unit>
        <trans-unit id="fd3c79c993342fdc4845e0000fd358e72448a4b9" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adfaba1d7ff8cc9090d93cbfe1b050db4768533" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390 будет поддерживать &lt;code&gt;#!&lt;/code&gt; трюк shebang в версии 2.8 и выше. Вызовы &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; и обратные кавычки могут использовать синтаксис оболочки POSIX во всех системах S / 390.</target>
        </trans-unit>
        <trans-unit id="1d34b2e0115c599698c2eaf50db89fcc832b02bf" translate="yes" xml:space="preserve">
          <source>OS/390, z/OS</source>
          <target state="translated">OS/390,z/OS</target>
        </trans-unit>
        <trans-unit id="0a302d149142b54ba805c25c7803eba208bb0727" translate="yes" xml:space="preserve">
          <source>OS/400</source>
          <target state="translated">OS/400</target>
        </trans-unit>
        <trans-unit id="ce46010d8cbef8c9b0bbd999f8b39bd331eb9402" translate="yes" xml:space="preserve">
          <source>OS2::BootDrive()</source>
          <target state="translated">OS2::BootDrive()</target>
        </trans-unit>
        <trans-unit id="6b75ff49b64b08a5cbda19098841eaa70af4d838" translate="yes" xml:space="preserve">
          <source>OS2::SysInfo()</source>
          <target state="translated">OS2::SysInfo()</target>
        </trans-unit>
        <trans-unit id="aca5fea461e6f13c528c2c4f05a7be94b7faae70" translate="yes" xml:space="preserve">
          <source>OS2::get_control87()</source>
          <target state="translated">OS2::get_control87()</target>
        </trans-unit>
        <trans-unit id="7ffcc4aa191d7c21c744cd8b5d4c95af4f197345" translate="yes" xml:space="preserve">
          <source>OSPEED</source>
          <target state="translated">OSPEED</target>
        </trans-unit>
        <trans-unit id="957c024b38ce820878f03177ce3d2b83c26a82d0" translate="yes" xml:space="preserve">
          <source>OTHER</source>
          <target state="translated">OTHER</target>
        </trans-unit>
        <trans-unit id="cb338bafdad45c9e72ba4f2b86d7dc19e8efe3a0" translate="yes" xml:space="preserve">
          <source>OTHER API EXPORTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea1e1d8de28e316e4bbdddc4c0f8d93bcafa453" translate="yes" xml:space="preserve">
          <source>OTHER API FUNCTIONS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6ab2bf42c29199bc2595a18bf166b2ca9d58db" translate="yes" xml:space="preserve">
          <source>OTHER COMPONENTS</source>
          <target state="translated">ПРОЧИЕ КОМПОНЕНТЫ</target>
        </trans-unit>
        <trans-unit id="f4819c79c3cf5d0855c9756e200236cb695ed79b" translate="yes" xml:space="preserve">
          <source>OTHER EXAMPLES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c2b40e6c72a2bb0b41071005914975b421d2b3" translate="yes" xml:space="preserve">
          <source>OTHER FACILITIES</source>
          <target state="translated">ДРУГИЕ УЧРЕЖДЕНИЯ</target>
        </trans-unit>
        <trans-unit id="b9ed1fc6bda9c1de960a484858190276f8547802" translate="yes" xml:space="preserve">
          <source>OTHER FUNCTIONS</source>
          <target state="translated">ДРУГИЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="c89d68a8b80355c832f177abfb0d1dd9e08c42b5" translate="yes" xml:space="preserve">
          <source>OURSTASH</source>
          <target state="translated">OURSTASH</target>
        </trans-unit>
        <trans-unit id="cf1596fa6b124742caf502c819fa40b64395f706" translate="yes" xml:space="preserve">
          <source>OUTPUT TIPS</source>
          <target state="translated">ВЫХОДНЫЕ СОВЕТЫ</target>
        </trans-unit>
        <trans-unit id="cbbef8ce7e5bb98d49b97d0627758196498a036b" translate="yes" xml:space="preserve">
          <source>OUTSIDE</source>
          <target state="translated">OUTSIDE</target>
        </trans-unit>
        <trans-unit id="aed9198315d600f631cbfb4ab62949c42689f27b" translate="yes" xml:space="preserve">
          <source>OUTSIDE_SEQ</source>
          <target state="translated">OUTSIDE_SEQ</target>
        </trans-unit>
        <trans-unit id="a32824f28f79811519a5acdabe1d4b373c40ef62" translate="yes" xml:space="preserve">
          <source>OVERRIDDEN METHODS</source>
          <target state="translated">ПЕРЕОПРЕДЕЛЁННЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="bf6107f87a0ec04cb2b618d76df7646acae50937" translate="yes" xml:space="preserve">
          <source>OVERRIDES</source>
          <target state="translated">OVERRIDES</target>
        </trans-unit>
        <trans-unit id="be5d4c45f4cd36cced53ba6c4c1d80a8493a95f3" translate="yes" xml:space="preserve">
          <source>OVERRIDING CORE FUNCTIONS</source>
          <target state="translated">ОСНОВНЫЕ ФУНКЦИИ</target>
        </trans-unit>
        <trans-unit id="f275fdb83760cf7f81c0389520bf2b7351b38004" translate="yes" xml:space="preserve">
          <source>OVERVIEW</source>
          <target state="translated">OVERVIEW</target>
        </trans-unit>
        <trans-unit id="fe6d13a6636d2e856ee66d1e674b0c568eee0ba0" translate="yes" xml:space="preserve">
          <source>OVERVIEW OF CLASSES</source>
          <target state="translated">ОБЗОР КЛАССОВ</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">Методы объекта</target>
        </trans-unit>
        <trans-unit id="7a403b426b3138de1314edbedb502e24fe00906c" translate="yes" xml:space="preserve">
          <source>Object Orientation is not the best solution to every problem. In</source>
          <target state="translated">Ориентация на объект-не лучшее решение каждой проблемы.На сайте</target>
        </trans-unit>
        <trans-unit id="0576faceb2bc930743ea41920355c65b4ff2f401" translate="yes" xml:space="preserve">
          <source>Object Oriented Encoder</source>
          <target state="translated">Объектно-ориентированный кодировщик</target>
        </trans-unit>
        <trans-unit id="1328c7cddf5e1741e60ae0ea7e9cd25feb10a44d" translate="yes" xml:space="preserve">
          <source>Object Oriented time objects</source>
          <target state="translated">Объектно-ориентированные объекты времени</target>
        </trans-unit>
        <trans-unit id="8a9d1904669ae5189957085d3ad744889ffa188e" translate="yes" xml:space="preserve">
          <source>Object Oriented/Tied Handle Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a2199d628852802c93c71acfcb62c9006d4a9" translate="yes" xml:space="preserve">
          <source>Object interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2554e1cb290677a2fc70d0a43154bdf1c0148ab" translate="yes" xml:space="preserve">
          <source>Object interface for AF_INET domain sockets</source>
          <target state="translated">Объектный интерфейс для доменных сокетов AF_INET</target>
        </trans-unit>
        <trans-unit id="93e56d8e38067f0fd87b11c1619713b42509ffd1" translate="yes" xml:space="preserve">
          <source>Object interface for AF_UNIX domain sockets</source>
          <target state="translated">Объектный интерфейс для доменных сокетов AF_UNIX</target>
        </trans-unit>
        <trans-unit id="3d662b2d2b28e92fa294d9f80685e9709d96e1ab" translate="yes" xml:space="preserve">
          <source>Object interface to socket communications</source>
          <target state="translated">Интерфейс объекта для связи с сокетами</target>
        </trans-unit>
        <trans-unit id="c9adffadbed4d834ac5b856b003595a5f887d57f" translate="yes" xml:space="preserve">
          <source>Object interface to system poll call</source>
          <target state="translated">Интерфейс объекта для вызова системного опроса</target>
        </trans-unit>
        <trans-unit id="cc8d552e462d1eb5f26cd8f9fdf1f0a8654a0735" translate="yes" xml:space="preserve">
          <source>Object interface:</source>
          <target state="translated">Интерфейс объекта:</target>
        </trans-unit>
        <trans-unit id="a4fd25b923092435b59d8ba7f9a4eeafbcc983ac" translate="yes" xml:space="preserve">
          <source>Object oriented interface</source>
          <target state="translated">Объектно-ориентированный интерфейс</target>
        </trans-unit>
        <trans-unit id="26b3504ec46d1edff4f4783df6ad8b24180e673c" translate="yes" xml:space="preserve">
          <source>Object property methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fa350c821e5eff6e8a902ebb2f0731d1bbc634" translate="yes" xml:space="preserve">
          <source>Object registry is best done when the object is initialized for use with a class. That way, garbage collection and thread safety are established for every object and every field that is initialized.</source>
          <target state="translated">Реестр объектов лучше всего делать,когда объект инициализирован для использования с классом.Таким образом,сборщик мусора и безопасность потока устанавливается для каждого объекта и каждого инициализированного поля.</target>
        </trans-unit>
        <trans-unit id="00830e1926297b7c355fe1aa06dab72200595135" translate="yes" xml:space="preserve">
          <source>Object status (i.e., the class an object is blessed into) is also cloned.</source>
          <target state="translated">Статус объекта (т.е.класс,в который благословлен объект)также клонируется.</target>
        </trans-unit>
        <trans-unit id="fe8c7731a828adbc9c6710de9659455410072a19" translate="yes" xml:space="preserve">
          <source>Object to manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef528339319411e5d4f89f3a15d4db11ad2cbd90" translate="yes" xml:space="preserve">
          <source>Object to represent a testing context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbf11227dc99e33421481b03ca2f68bc9536a37" translate="yes" xml:space="preserve">
          <source>Object used by Test2::API under the hood</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="88749641a0e24498fbd33e53d44467f3c2c5fba0" translate="yes" xml:space="preserve">
          <source>Objects Are Blessed; Variables Are Not</source>
          <target state="translated">Предметы благословлены;Переменные-нет.</target>
        </trans-unit>
        <trans-unit id="5bca7499b54d7016ce15937bcabd8353b693c22e" translate="yes" xml:space="preserve">
          <source>Objects based on the above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56ad09ee25c724ca5817035af9f32f714eaf7e7" translate="yes" xml:space="preserve">
          <source>Objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">Объекты,представляющие собой POD-ввод параграфов,команд и т.д.</target>
        </trans-unit>
        <trans-unit id="1ad3969f34af62c08d92133f049673d28c2645d6" translate="yes" xml:space="preserve">
          <source>Obscure - set count of bytes in the buffer. Deprecated. Only usable if PerlIO_canset_cnt() returns true. Currently used in only doio.c to force count less than -1 to -1. Perhaps should be PerlIO_set_empty or similar. This call may actually do nothing if &quot;count&quot; is deduced from pointer and a &quot;limit&quot;. Do not use this - use PerlIO_set_ptrcnt().</source>
          <target state="translated">Неизвестно-установить счетчик байт в буфере.Исключено.Используется только если PerlIO_canset_cnt()возвращает true.В настоящее время используется только в doio.c,чтобы принудительно устанавливать счетчик меньше чем от -1 до -1.Возможно,следует использовать PerlIO_set_empty или что-то подобное.На самом деле этот вызов может ничего не сделать,если из указателя и &quot;лимита&quot; вычитать &quot;count&quot;.Не используйте это-используйте PerlIO_set_ptrcnt().</target>
        </trans-unit>
        <trans-unit id="4e7d8c7849f1648c77052055f32051f9581d8bc7" translate="yes" xml:space="preserve">
          <source>Obsolete</source>
          <target state="translated">Obsolete</target>
        </trans-unit>
        <trans-unit id="e6bd238b055b51008fa691962e5504d6a4300b6b" translate="yes" xml:space="preserve">
          <source>Obsolete backwards compatibility functions</source>
          <target state="translated">Устаревшие функции обратной совместимости</target>
        </trans-unit>
        <trans-unit id="242a752af236cef2e4f67eafc9e86420fe839b22" translate="yes" xml:space="preserve">
          <source>Obsolete, deprecated method. Not used since Version 5.21.</source>
          <target state="translated">Устаревший,устаревший метод.Не используется с версии 5.21.</target>
        </trans-unit>
        <trans-unit id="ae05a67e6b1bdd3a5722aeecd922515ab6353aa5" translate="yes" xml:space="preserve">
          <source>Obsolete. All code points previously matched by this have been moved to &quot;Script=Common&quot;. Consider instead using &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot; (or both)</source>
          <target state="translated">Устаревший.Все точки кода,ранее совпадавшие с этим,были перенесены в &quot;Script=Common&quot;.Рассмотрим вместо этого &quot;Script_Extensions=Katakana&quot; или &quot;Script_Extensions=Hiragana&quot; (или оба).</target>
        </trans-unit>
        <trans-unit id="a9002afd81f2bf4ce6e9b9a4e6ca0a84152afb47" translate="yes" xml:space="preserve">
          <source>Obsoleted as of Unicode 9.0, but previously provided a visual display of the standard variant sequences derived from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc29852a42ef2fda895989b8798adc19e9d7e6c" translate="yes" xml:space="preserve">
          <source>Obtain a response from the server. Upon success the most significant digit of the status code is returned. Upon failure, timeout etc.,</source>
          <target state="translated">Получить ответ от сервера.После успеха возвращается наиболее значимая цифра кода статуса.При неудаче,таймауте и т.д,</target>
        </trans-unit>
        <trans-unit id="c69d89c90bc0675bccad1c0dfa062843dd612b7a" translate="yes" xml:space="preserve">
          <source>Obtain information about all the active newsgroups. The results is a reference to a hash where the key is a group name and each value is a reference to an array. The elements in this array are:- the last article number in the group, the first article number in the group and any information flags about the group.</source>
          <target state="translated">Получать информацию обо всех активных новостных группах.Результат-ссылка на хэш,где ключом является имя группы,а каждое значение-ссылка на массив.Элементами в этом массиве являются:-номер последней статьи в группе,номер первой статьи в группе и любые информационные флаги о группе.</target>
        </trans-unit>
        <trans-unit id="51850565c0039917e1d7c30526e1aece9dd14aed" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt; .</source>
          <target state="translated">Получите атрибуты для стандартного &lt;code&gt;stdin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7789255329d3ffd1b99a0a2cd58f6fb55a93559e" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4897259e0b2ea144f76021c4fb5eb538871e32ce" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for stdout.</source>
          <target state="translated">Получите атрибуты для stdout.</target>
        </trans-unit>
        <trans-unit id="12526129b1b52b63050b51bbb32341d9a8cd1a04" translate="yes" xml:space="preserve">
          <source>Obtain the header field &lt;code&gt;HEADER&lt;/code&gt; for all the messages specified.</source>
          <target state="translated">Получите поле заголовка &lt;code&gt;HEADER&lt;/code&gt; для всех указанных сообщений.</target>
        </trans-unit>
        <trans-unit id="ec15ee25f6bbd0b55463ebbf3ac8647c1d12711a" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be an ASCII string or</source>
          <target state="translated">Получите время на &lt;code&gt;HOST&lt;/code&gt; или на каком-либо хосте по умолчанию, если &lt;code&gt;HOST&lt;/code&gt; не указан или не определен, используя протокол, как определено в RFC867. Необязательный аргумент &lt;code&gt;PROTOCOL&lt;/code&gt; должен определять используемый протокол: &lt;code&gt;tcp&lt;/code&gt; или &lt;code&gt;udp&lt;/code&gt; . Результатом будет строка ASCII или</target>
        </trans-unit>
        <trans-unit id="99f41f8f4a19b089d2fd1f49ca16ff7053ef6795" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">Получите время на &lt;code&gt;HOST&lt;/code&gt; или на каком-либо хосте по умолчанию, если &lt;code&gt;HOST&lt;/code&gt; не указан или не определен, используя протокол, определенный в RFC868. Необязательный аргумент &lt;code&gt;PROTOCOL&lt;/code&gt; должен определять используемый протокол: &lt;code&gt;tcp&lt;/code&gt; или &lt;code&gt;udp&lt;/code&gt; . Результатом будет значение времени в тех же единицах, что и time () или</target>
        </trans-unit>
        <trans-unit id="795eb623dba4761a659c021e4b42f3958e340aa1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be an ASCII string or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74c2d6b8c1d1a064d7e0d2a2f0c8de41a911ec1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be a time value in the same units as returned by time() or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66bf08929fd5d420bb4c2ec86a67bddae583922" translate="yes" xml:space="preserve">
          <source>Obtaining and installing libnet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da382120051949707a0c7beb67aab96ce623a328" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">Очевидно, что первая из них не сможет отличить большинство платформ ASCII от CCSID 0037, 1047 или платформы POSIX-BC EBCDIC, поскольку &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; под всеми этими кодированными наборами символов. Но обратите внимание, что поскольку &lt;code&gt;&quot;\n&quot;&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; а &lt;code&gt;&quot;\r&quot;&lt;/code&gt; - это &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; на старом Macintosh (который является платформой ASCII), второй тест &lt;code&gt;$is_ascii&lt;/code&gt; приведет к проблемам там.</target>
        </trans-unit>
        <trans-unit id="1d78b76872c5b56931c9b5c0301dbd8a6a7bb448" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; eq chr(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;chr(13)&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;chr(10)&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc9e42e3d47c901ceac3b16df8f05113274fcf2" translate="yes" xml:space="preserve">
          <source>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</source>
          <target state="translated">Очевидно,это предполагает,что можно напечатать указатель на неподписанный длинный и наоборот,что часто срабатывает,но не должно восприниматься как универсальный закон.-Теперь,когда у нас есть этот указатель,следующий вопрос:как его правильно использовать? Нам нужен вызов какой-нибудь функции на Си,где указатель ожидается.На ум приходит системный вызов read(2):</target>
        </trans-unit>
        <trans-unit id="8622bcf5480e2dcfc1e93eb63bd84e889a59eca8" translate="yes" xml:space="preserve">
          <source>Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:</source>
          <target state="translated">Очевидно,что ошибки,которые включают исправления,лучше всего подходят.Если вы предпочитаете,вы можете заплатить за кровотечение с помощью анонимной проверки последней версии:</target>
        </trans-unit>
        <trans-unit id="8ad2def711f61d8bfaa27f7b29de908193ec9688" translate="yes" xml:space="preserve">
          <source>Obviously, in the situation of the last type of the signature of an OS/2 API, it is must more convenient for the users if the failure is indicated by die()ing: one does not need to check $^E to know that something went wrong. If, however, this solution is not desirable by some reason, the code in question should reset $^E to 0 before making this OS/2 API call, so that the caller of this Perl-accessible function has a chance to distinguish a success-but-0-return value from a failure. (One may return undef as an alternative way of reporting an error.)</source>
          <target state="translated">Очевидно,что в ситуации с последним типом подписи OS/2 API,пользователю должно быть удобнее,если сбой обозначен функцией die()ing:не нужно проверять $^E,чтобы понять,что что-то пошло не так.Если же по какой-то причине такое решение не желательно,то перед вызовом OS/2 API соответствующий код должен сбросить $^E на 0,чтобы у вызывающего эту Perl-доступную функцию был шанс отличить значение успеха-ноль-0-обратный сбой.(В качестве альтернативного способа сообщения об ошибке можно вернуть undef).</target>
        </trans-unit>
        <trans-unit id="d64ac810883d44e27969b0774d70505e74b53a16" translate="yes" xml:space="preserve">
          <source>Obviously, the second call to &lt;code&gt;complicated&lt;/code&gt; is a waste of time, and storing its return value is a waste of space. Specifying &lt;code&gt;LIST_CACHE
=&amp;gt; MERGE&lt;/code&gt; will make &lt;code&gt;memoize&lt;/code&gt; use the same cache for scalar and list context return values, so that the second call uses the scalar cache that was populated by the first call. &lt;code&gt;complicated&lt;/code&gt; ends up being called only once, and both subsequent calls return &lt;code&gt;3&lt;/code&gt; from the cache, regardless of the calling context.</source>
          <target state="translated">Очевидно, что второй вызов &lt;code&gt;complicated&lt;/code&gt; - пустая трата времени, а сохранение его возвращаемого значения - пустая трата места. Указание &lt;code&gt;LIST_CACHE =&amp;gt; MERGE&lt;/code&gt; заставит &lt;code&gt;memoize&lt;/code&gt; использовать один и тот же кеш для скалярных и возвращаемых значений контекста списка, так что второй вызов будет использовать скалярный кеш, который был заполнен первым вызовом. &lt;code&gt;complicated&lt;/code&gt; заканчивается тем, что вызывается только один раз, и оба последующих вызова возвращают &lt;code&gt;3&lt;/code&gt; из кеша, независимо от вызывающего контекста.</target>
        </trans-unit>
        <trans-unit id="a86730e802eb4eb4e4acf92e33bec8c9303fc96c" translate="yes" xml:space="preserve">
          <source>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</source>
          <target state="translated">Иногда важно передать ссылку на привязываемый объект на ТИАСКАЛАР,ТИХАШ и т.д.,которые его связывают.</target>
        </trans-unit>
        <trans-unit id="5cb8a483e38416f865c96e1886ae8adceb1b5292" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">Иногда программист может захотеть вернуть просто &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или пустой список в случае сбоя функции, а не отдельное значение статуса. Функция rpcb_gettime () предлагает именно такую ​​ситуацию. Если функция завершается успешно, мы хотели бы, чтобы она возвращала время, а если не удается, мы хотели бы вернуть undef. В следующем коде Perl значение $ timep будет либо undef, либо допустимым временем.</target>
        </trans-unit>
        <trans-unit id="0ea7d0ab3870cda5bd5d012242ed94c158dde1fa" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;undef&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca6836d0056140d86bcc04d81edeb7b7f85d973" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">Время от времени Attribute :: Handlers прилагает огромные усилия для преобразования аргумента данных ( &lt;code&gt;$_[4]&lt;/code&gt; ) в пригодную для использования форму перед передачей его обработчику.</target>
        </trans-unit>
        <trans-unit id="f13c9786193661170bf181a99c76dd0d6705b9c3" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler get in the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1a8a18cac1b8ec9d036c1e95c86caa06823297" translate="yes" xml:space="preserve">
          <source>Occasionally, you can't use just a &lt;code&gt;/g&lt;/code&gt; to get all the changes to occur that you might want. Here are two common cases:</source>
          <target state="translated">Иногда вы не можете использовать только a &lt;code&gt;/g&lt;/code&gt; , чтобы получить все необходимые изменения. Вот два распространенных случая:</target>
        </trans-unit>
        <trans-unit id="3642950c84185b95fade3aa22cda9a0e1954ee82" translate="yes" xml:space="preserve">
          <source>Oceania</source>
          <target state="translated">Oceania</target>
        </trans-unit>
        <trans-unit id="b5befcf80da75ec699a5c983fc36244ec375a0c0" translate="yes" xml:space="preserve">
          <source>Octal escapes</source>
          <target state="translated">утечки из осьминога</target>
        </trans-unit>
        <trans-unit id="db84424f081d663bc203c1af1117e2bdc42e8773" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;&quot;Absolute referencing&quot;&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3bc0d39ae545ee26be05b556b7a8cf4ddc990b" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">Восьмеричные escape-последовательности формы &lt;code&gt;\000&lt;/code&gt; вне классов символов в квадратных скобках потенциально конфликтуют с обратными &lt;a href=&quot;#Absolute-referencing&quot;&gt;ссылками в&lt;/a&gt; старом стиле (см. Абсолютные ссылки ниже). Оба они состоят из обратной косой черты, за которой следуют числа. Таким образом, Perl должен использовать эвристику, чтобы определить, является ли это обратной ссылкой или восьмеричным escape-кодом. Perl использует следующие правила для устранения неоднозначности:</target>
        </trans-unit>
        <trans-unit id="87a50fff0e8349cdbe12625e1077c3ebe0fdfa7d" translate="yes" xml:space="preserve">
          <source>Octal number &amp;gt; 037777777777 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb34d0b5eb49bdff2904bd7acc2fa7d27c59806" translate="yes" xml:space="preserve">
          <source>Octal numbers are typically prefixed by &quot;0&quot;, but since leading zeros are stripped, these methods can not automatically recognize octal numbers, so use the constructor from_oct() to interpret octal strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af566741591251972e43e0d36356b0e06a29bb7" translate="yes" xml:space="preserve">
          <source>Odd name/value argument for subroutine '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bda02e37792920d152c41b584876b2e10eb3c5" translate="yes" xml:space="preserve">
          <source>Odd number of arguments for overload::constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399492c4df4e28b7b58d749dc69161eed60f95f9" translate="yes" xml:space="preserve">
          <source>Odd number of elements in anonymous hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065c34a675ace7837e8fdf7122c9899906bd6b6e" translate="yes" xml:space="preserve">
          <source>Odd number of elements in hash assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cc17f1e22c5e8c8c6d8e8b50d3e2d9acf218c8" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;cgi&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001ed8e6a266e94752602c2df86a674e88e19c2d" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">Конечно, &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; и &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; расскажут вам больше.</target>
        </trans-unit>
        <trans-unit id="814879db219b87492dd375dcf6f869266e936b99" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;Moose&lt;/code&gt; isn't perfect.</source>
          <target state="translated">Конечно, &lt;code&gt;Moose&lt;/code&gt; не идеален.</target>
        </trans-unit>
        <trans-unit id="733d5b43433c0be3dd395c3e52526830c10b5e3c" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; , and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">Конечно, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; и &lt;code&gt;string_vianame&lt;/code&gt; также должны быть переопределены.</target>
        </trans-unit>
        <trans-unit id="e69acfd1f99778b500da1a17ef29d78b995fb659" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt;, &lt;code&gt;viacode&lt;/code&gt;, and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c6e1d7d58bd1d130be768a05a694a94d3aba2b" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; always precedes your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</source>
          <target state="translated">Конечно, и здесь Filter :: Simple должен знать, что вы используете Exporter, прежде чем применять фильтр. Это почти никогда не проблема, но если вы нервничаете по этому поводу, вы можете гарантировать, что все будет работать правильно, убедившись, что ваш &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; &lt;a href=&quot;../functions/use&quot;&gt;использования&lt;/a&gt; всегда предшествует вашему &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4302a9cf5fbe5aa02395c1781d6a9233de7d01db" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;use base Exporter&lt;/code&gt; always precedes your &lt;code&gt;use Filter::Simple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab33e7ed924208df5f517b6f58635c94da06be71" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt; , there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">Конечно, если &lt;code&gt;@ISA&lt;/code&gt; содержит только &lt;code&gt;DynaLoader&lt;/code&gt; , нет необходимости в назначении &lt;code&gt;@ISA&lt;/code&gt; ; более того, если вместо &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; использовать более обратно совместимый</target>
        </trans-unit>
        <trans-unit id="1eafec21d0ff2371b83827a03c0ee4872c0478b3" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt;, there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;our&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe9b52519ed5e683419d8b8de5fb62a2cea4185" translate="yes" xml:space="preserve">
          <source>Of course, if the class name is in a scalar Perl will do the right thing as well:</source>
          <target state="translated">Конечно,если имя класса находится в скаляре Perl,то и это будет правильно:</target>
        </trans-unit>
        <trans-unit id="d886edfc3d346b2f618c821d88c4f77af2ec29fb" translate="yes" xml:space="preserve">
          <source>Of course, if you simply follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;, you shouldn't need to reformat. The habit of formatting your code as you write it will help prevent bugs. Your editor can and should help you with this. The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of help with most (but not all) code, and even less programmable editors can provide significant assistance. Tom Christiansen and many other VI users swear by the following settings in vi and its clones:</source>
          <target state="translated">Конечно, если вы просто следуете рекомендациям в &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; , вам не нужно переформатировать. Привычка форматировать код по мере его написания поможет предотвратить ошибки. Ваш редактор может и должен вам в этом помочь. Perl-mode или более новый cperl-mode для emacs могут оказать значительную помощь с большей частью (но не со всем) кодом, и даже менее программируемые редакторы могут оказать значительную помощь. Том Кристиансен и многие другие пользователи VI придерживаются следующих настроек vi и его клонов:</target>
        </trans-unit>
        <trans-unit id="abb07ecb376ea8ffb38769be127701645f4d0359" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl will invoke &lt;code&gt;$obj&lt;/code&gt; 's implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">Конечно, в условиях , как, например, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl будет вызывать &lt;code&gt;$obj&lt;/code&gt; &amp;laquo;ы Реализация &lt;code&gt;+&lt;/code&gt; , а не (в данном примере) преобразование &lt;code&gt;$obj&lt;/code&gt; в число , используя numify метод &lt;code&gt;'0+'&lt;/code&gt; (исключение для это когда для &lt;code&gt;'+'&lt;/code&gt; не был предоставлен метод, а для &lt;a href=&quot;#fallback&quot;&gt;отката&lt;/a&gt; задано значение TRUE).</target>
        </trans-unit>
        <trans-unit id="e64305345caaad0c4dd212ba7ea682cb2c014fca" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt;, Perl will invoke &lt;code&gt;$obj&lt;/code&gt;'s implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt; is set to TRUE).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837c1a0c6d4394993c9260f47b27824bf6031d2f" translate="yes" xml:space="preserve">
          <source>Of course, in the case of a literal string, one could just as easily use the string comparison &lt;code&gt;$string eq 'bert'&lt;/code&gt; and it would be more efficient. The &lt;code&gt;^...$&lt;/code&gt; regexp really becomes useful when we add in the more powerful regexp tools below.</source>
          <target state="translated">Конечно, в случае буквальной строки можно было бы так же легко использовать сравнение &lt;code&gt;$string eq 'bert'&lt;/code&gt; и это было бы более эффективно. &lt;code&gt;^...$&lt;/code&gt; регулярное выражение действительно становится полезным , если мы добавим в более мощных инструментов регулярных выражений ниже.</target>
        </trans-unit>
        <trans-unit id="27457c444325a83774ce245c93383c8862b5cc3d" translate="yes" xml:space="preserve">
          <source>Of course, in this module-author's humble opinion, I'd be more inclined to use the existing &lt;b&gt;Pod::ParseTree&lt;/b&gt; object than a simple array. That way everything in it, paragraphs and sequences, all respond to the same core interface for all parse-tree nodes. The result would look something like:</source>
          <target state="translated">Конечно, по скромному мнению автора этого модуля, я был бы более склонен использовать существующий объект &lt;b&gt;Pod :: ParseTree,&lt;/b&gt; чем простой массив. Таким образом, все в нем, абзацы и последовательности, все реагируют на один и тот же основной интерфейс для всех узлов дерева синтаксического анализа. Результат будет примерно таким:</target>
        </trans-unit>
        <trans-unit id="11fde9a92a2449ce2e35bf1f4b5fe24a02e9e7d2" translate="yes" xml:space="preserve">
          <source>Of course, it is important to choose the right separator string for each purpose.</source>
          <target state="translated">Конечно,важно выбрать правильную разделительную строку для каждой цели.</target>
        </trans-unit>
        <trans-unit id="dc54d65f65f6922d956316c79b1323c206e201c5" translate="yes" xml:space="preserve">
          <source>Of course, it's up to you to decide whether or not to ignore them.</source>
          <target state="translated">Конечно,вы сами решаете,игнорировать их или нет.</target>
        </trans-unit>
        <trans-unit id="d78604b940d2c66d71607feff9316d4ae5a87f26" translate="yes" xml:space="preserve">
          <source>Of course, one could write such glue code directly in C. However, this would be a tedious task, especially if one needs to write glue for multiple C functions, and/or one is not familiar enough with the Perl stack discipline and other such arcana. XS comes to the rescue here: instead of writing this glue C code in long-hand, one can write a more concise short-hand</source>
          <target state="translated">Конечно,такой клеевой код можно было бы написать прямо на Си.Однако,это было бы утомительной задачей,особенно если нужно написать клей для нескольких функций на Си,и/или человек недостаточно знаком с дисциплиной стека Perl и другими подобными арканами.Здесь на помощь приходит XS:вместо того,чтобы писать этот клеевой C-код длинными руками,можно написать более лаконичный короткими руками</target>
        </trans-unit>
        <trans-unit id="77c72cea76e3d8ea1cda06ed844191d48368487d" translate="yes" xml:space="preserve">
          <source>Of course, test #1 is $tests[0], etc...</source>
          <target state="translated">Конечно,тест #1-это $tests[0]и т.д....</target>
        </trans-unit>
        <trans-unit id="de9f73990ad276e504276095781c4201fd0583f9" translate="yes" xml:space="preserve">
          <source>Of course, the best way to save memory is to not do anything to waste it in the first place. Good programming practices can go a long way toward this:</source>
          <target state="translated">Конечно,лучший способ сохранить память-это не делать ничего,чтобы ее потратить впустую.Надлежащая практика программирования может иметь далеко идущие последствия:</target>
        </trans-unit>
        <trans-unit id="b974b206a7b1862c93ebd148bc1b83add3324aa2" translate="yes" xml:space="preserve">
          <source>Of course, this</source>
          <target state="translated">Конечно,это</target>
        </trans-unit>
        <trans-unit id="5788145c5ae3423e71b1d5b7f96f5fcb341edfab" translate="yes" xml:space="preserve">
          <source>Of course, this requires that the underlying call supports buffers. See the note on buffers above.</source>
          <target state="translated">Конечно,для этого необходимо,чтобы основной вызов поддерживал буферы.См.примечание о буферах выше.</target>
        </trans-unit>
        <trans-unit id="357e4c4fc94af540a4f74537a6571078de606e56" translate="yes" xml:space="preserve">
          <source>Of course, typing in your own password to whoever asks you for it is unwise.</source>
          <target state="translated">Конечно,вводить свой собственный пароль тому,кто вас об этом попросит,неразумно.</target>
        </trans-unit>
        <trans-unit id="aaa47fc8bd024bc87e7c8490eb46dddef3e8914d" translate="yes" xml:space="preserve">
          <source>Of course, unless you know the number of elements in the &lt;code&gt;sometype **&lt;/code&gt; C array, within your XSUB, the return value from &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; will be hard to decipher. Since the details are all up to the XS author (the typemap user), there are several solutions, none of which particularly elegant. The most commonly seen solution has been to allocate memory for N+1 pointers and assign &lt;code&gt;NULL&lt;/code&gt; to the (N+1)th to facilitate iteration.</source>
          <target state="translated">Конечно, если вы не знаете количество элементов в &lt;code&gt;sometype **&lt;/code&gt; C в вашем XSUB, будет трудно расшифровать возвращаемое значение из &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; . Поскольку все детали зависят от автора XS (пользователя typemap), существует несколько решений, ни одно из которых не является особенно элегантным. Наиболее часто встречающимся решением было выделить память для указателей N + 1 и присвоить &lt;code&gt;NULL&lt;/code&gt; (N + 1) -му, чтобы облегчить итерацию.</target>
        </trans-unit>
        <trans-unit id="edd8408b88d74e19ec1265ebd83f3cd07501b352" translate="yes" xml:space="preserve">
          <source>Of course, unless your OS does not implement access(), in which case the pragma is simply ignored. Best not to use &lt;code&gt;_&lt;/code&gt; at all in a file where the filetest pragma is active!</source>
          <target state="translated">Конечно, если ваша ОС не реализует access (), и в этом случае прагма просто игнорируется. Лучше вообще не использовать &lt;code&gt;_&lt;/code&gt; в файле, где активна прагма filetest!</target>
        </trans-unit>
        <trans-unit id="abd96d1d300bf4e8daac5b50f895feff0cad5891" translate="yes" xml:space="preserve">
          <source>Of course, variables that are UTF-8 and are referred to in the string retain that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5481b8a258de1ea18c7a9b1b7f4086fab8bc96" translate="yes" xml:space="preserve">
          <source>Of course, you can also choose to import specific functions by name, as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a595714c023a195e48ee401212d01b31493781" translate="yes" xml:space="preserve">
          <source>Of course, you don't need the temporary array to have a name at all:</source>
          <target state="translated">Конечно,вам не нужно,чтобы у временного массива вообще было имя:</target>
        </trans-unit>
        <trans-unit id="fb6f67a6165dc8bfd66e5ae946dbcf7584578eef" translate="yes" xml:space="preserve">
          <source>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</source>
          <target state="translated">Из преобразований требуется только одно из строковых,булевых или числовых,потому что каждое из них может быть сгенерировано из двух других.</target>
        </trans-unit>
        <trans-unit id="f521e0762b4294067b640a105aa4f9fd48ea8238" translate="yes" xml:space="preserve">
          <source>Of these properties, the two important ones are Pattern_Syntax and Pattern_White_Space. They have been set up by Unicode for exactly this purpose of deciding which characters in a regular expression pattern should be quoted. No character that can be in an identifier has these properties.</source>
          <target state="translated">Из этих свойств два важных-Pattern_Syntax и Pattern_White_Space.Они были установлены Unicode именно для этой цели,чтобы решить,какие символы в шаблоне регулярных выражений должны быть кавычками.Ни один символ,который может находиться в идентификаторе,не обладает этими свойствами.</target>
        </trans-unit>
        <trans-unit id="c77879f95662f28e94653e74a629782adc3eeac4" translate="yes" xml:space="preserve">
          <source>Official home page for the ISO 3166 maintenance agency.</source>
          <target state="translated">Официальная домашняя страница для агентства по техническому обслуживанию ISO 3166.</target>
        </trans-unit>
        <trans-unit id="967fc19002ed71d08a174f5ecc4259363a549385" translate="yes" xml:space="preserve">
          <source>Official source of the top-level domain names.</source>
          <target state="translated">Официальный источник доменных имен верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="3c0ccf7d9a2c2c9e1eedbe4cef2e4d0413088708" translate="yes" xml:space="preserve">
          <source>Offline sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b00389e2960ae2ee90ec24a50a5ce42fa29d6d" translate="yes" xml:space="preserve">
          <source>Offset outside string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20daff2f32d6074bbb2255376c7a89b965519ab3" translate="yes" xml:space="preserve">
          <source>Offsets</source>
          <target state="translated">Offsets</target>
        </trans-unit>
        <trans-unit id="6a7926e00c1d5044bed78664357be7137c40f3e0" translate="yes" xml:space="preserve">
          <source>Offsets holds a mapping of offset in the &lt;code&gt;program&lt;/code&gt; to offset in the &lt;code&gt;precomp&lt;/code&gt; string. This is only used by ActiveState's visual regex debugger.</source>
          <target state="translated">Offsets содержит отображение смещения в &lt;code&gt;program&lt;/code&gt; на смещение в строке &lt;code&gt;precomp&lt;/code&gt; . Это используется только отладчиком визуальных регулярных выражений ActiveState.</target>
        </trans-unit>
        <trans-unit id="43d26f6f08e88e91bca4bafe94301f7c42d03d67" translate="yes" xml:space="preserve">
          <source>Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators:</source>
          <target state="translated">Часто бывает полезно разрешить разделенные запятыми списки значений,а также множественные вхождения опций.Это легко сделать с помощью операторов split()и join()Perl:</target>
        </trans-unit>
        <trans-unit id="632c3362322ab6672e961b19c05b72785cd26d84" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">Часто удобно использовать альтернативные мнемонические имена для опций. Например, &lt;code&gt;--height&lt;/code&gt; может быть альтернативным именем для &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Альтернативные имена могут быть включены в спецификацию опции, разделенные вертикальной чертой &lt;code&gt;|&lt;/code&gt; персонажи. Чтобы реализовать приведенный выше пример:</target>
        </trans-unit>
        <trans-unit id="7de86d17804fa632d98b8911860a7e7fb8a9bded" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--length&lt;/code&gt;. Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413285a912f30dbf718e8f5cd58feece5f266f30" translate="yes" xml:space="preserve">
          <source>Often there will be another error message associated with the syntax error giving more information. (Sometimes it helps to turn on &lt;b&gt;-w&lt;/b&gt;.) The error message itself often tells you where it was in the line when it decided to give up. Sometimes the actual error is several tokens before this, because Perl is good at understanding random input. Occasionally the line number may be misleading, and once in a blue moon the only way to figure out what's triggering the error is to call &lt;code&gt;perl -c&lt;/code&gt; repeatedly, chopping away half the program each time to see if the error went away. Sort of the cybernetic version of 20 questions.</source>
          <target state="translated">Часто появляется другое сообщение об ошибке, связанное с синтаксической ошибкой, дающее дополнительную информацию. (Иногда помогает включить &lt;b&gt;-w&lt;/b&gt; .) Само сообщение об ошибке часто сообщает вам, где оно было в строке, когда было решено отказаться. Иногда фактическая ошибка происходит за несколько токенов до этого, потому что Perl хорошо понимает случайный ввод. Иногда номер строки может вводить в заблуждение, и однажды в синюю луну единственный способ выяснить, что вызывает ошибку, - это многократно вызывать &lt;code&gt;perl -c&lt;/code&gt; , каждый раз отрубая половину программы, чтобы увидеть, исчезла ли ошибка. Этакая кибернетическая версия из 20 вопросов.</target>
        </trans-unit>
        <trans-unit id="fe51516899ec526908e4919457333ab9ef798f50" translate="yes" xml:space="preserve">
          <source>Often you want to manually set the $VERSION in the main module distribution because this is the version that everybody sees on CPAN and maybe you want to customize it a bit. But for all the other modules in your dist, $VERSION is really just bookkeeping and all that's important is it goes up every time the module is changed. Doing this by hand is a pain and you often forget.</source>
          <target state="translated">Часто вы хотите вручную установить $VERSION в основном дистрибутиве модулей,потому что это версия,которую все видят на CPAN,и,возможно,вы захотите немного ее настроить.Но для всех остальных модулей в вашем дистрибутиве $VERSION на самом деле просто бухгалтерский учет,и все,что важно,это то,что он поднимается каждый раз,когда модуль изменяется.Делать это вручную-больно и часто забываешь.</target>
        </trans-unit>
        <trans-unit id="a8e3c059f398572879c5f613bbb88d9e476377a9" translate="yes" xml:space="preserve">
          <source>Oh, hmm. That didn't quite work. Let's see what happened:</source>
          <target state="translated">О,хм.Это не совсем сработало.Давай посмотрим,что случилось:</target>
        </trans-unit>
        <trans-unit id="2c053114f243927de5bf7cd77c45af1c27a14806" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">О, последний совет: возьмите &lt;a href=&quot;../perlguts&quot;&gt;перлгут&lt;/a&gt; с собой. Когда вы вернетесь, мы ожидаем увидеть его хорошо проработанным.</target>
        </trans-unit>
        <trans-unit id="6e84377d7eb2428d1c7c2ce684cd3d38c4564c15" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306452191398ef5d817db7561b984ed6863ccdd5" translate="yes" xml:space="preserve">
          <source>Ok event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40dabdf47b8a6942bfc67e5bc1a841348e34c6a" translate="yes" xml:space="preserve">
          <source>Ok events are generated whenever you run a test that produces a result. Examples are &lt;code&gt;ok()&lt;/code&gt;, and &lt;code&gt;is()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8773501dbe9f64eda9a34f3bd611a37f1791691b" translate="yes" xml:space="preserve">
          <source>Ok, but how about when you want to really see your data, what's in that dynamic variable, just before using it?</source>
          <target state="translated">Хорошо,но как насчет того,когда вы действительно хотите увидеть свои данные,что в этой динамической переменной,прямо перед ее использованием?</target>
        </trans-unit>
        <trans-unit id="94213f220b40a7c6524e04580b008b30cdf470cf" translate="yes" xml:space="preserve">
          <source>Ok, so that's not very interesting, because it didn't find that particular document. But a long response wouldn't have fit on this page.</source>
          <target state="translated">Хорошо,это не очень интересно,потому что он не нашел этот конкретный документ.Но длинный ответ не помещался бы на этой странице.</target>
        </trans-unit>
        <trans-unit id="98a944759b5b6a428ccfa37e9a4506cd2b44afa1" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">Итак, может быть более одного объекта Test :: Builder, и вот как вы его получите. Вы можете использовать это вместо &lt;code&gt;new()&lt;/code&gt; если тестируете модуль на основе Test :: Builder, но в противном случае вам, вероятно, понадобится &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaf90bfe09c59916d02cd27cf9c5113342a8704b" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a981471d54adab918cf9e98c713f3fa8b6a31b7" translate="yes" xml:space="preserve">
          <source>Okay, concision isn't a buzzword. But it should be, so I decree that as a new buzzword, &quot;concision&quot; means that simple common things should be expressible in very few lines (or maybe even just a few characters) of code -- call it a special case of &quot;making simple things easy and hard things possible&quot;, and see also the role it played in the MIDI::Simple language, discussed elsewhere in this issue [TPJ#13].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f313a2347a7e1b7519ec6e24bd0468d6b0162bc3" translate="yes" xml:space="preserve">
          <source>Okay, if you insist: the &quot;internal format&quot; is utf8, not UTF-8. (When it's not some other encoding.)</source>
          <target state="translated">Хорошо,если вы настаиваете:&quot;внутренний формат&quot;-utf8,а не UTF-8.(Когда это не какая-то другая кодировка.)</target>
        </trans-unit>
        <trans-unit id="c04bc9d828571306fd8ab607e050385638b7b499" translate="yes" xml:space="preserve">
          <source>Olaf Alders &amp;lt;olaf@wundersolutions.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f111382df51fd175ea0dd918cefd5d91a357cd" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</source>
          <target state="translated">Старые байт-ориентированные программы должны при необходимости магически начинать работать с новыми символьно-ориентированными данными.</target>
        </trans-unit>
        <trans-unit id="484e0a4f10a1f76d63b7cbe120323d7095b0f174" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</source>
          <target state="translated">Старые байт-ориентированные программы не должны самопроизвольно ломаться на старых байт-ориентированных данных,над которыми они работали раньше.</target>
        </trans-unit>
        <trans-unit id="cdcb679c21ad16ffb1a74358af64068b9c8c43d4" translate="yes" xml:space="preserve">
          <source>Old package separator used in string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5d8d02aa4909a49747784b849d74c7097909f2" translate="yes" xml:space="preserve">
          <source>Old perl executable is started when a new executable is running has loaded an extension compiled for the old executable (ouph!). In this case the old executable will get a forwarder DLL instead of the old perl DLL, so would link with the new perl DLL. While not directly fatal, it will behave the same as new executable. This beats the whole purpose of explicitly starting an old executable.</source>
          <target state="translated">Старый исполняемый файл perl запускается,когда новый исполняемый файл загрузил расширение,скомпилированное для старого исполняемого файла (ouph!).В этом случае старый исполняемый файл получит перенаправляющую DLL вместо старой perl DLL,так же как и новый perl DLL.Несмотря на то,что он не является фатальным,он будет вести себя так же,как и новый исполняемый файл.Это превосходит всю цель явного запуска старого исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="fc1b9547dcacdd8deb0b3a992300248da0a808c5" translate="yes" xml:space="preserve">
          <source>Old versions need to directly access Test::Builder singleton hash elements. The latest version on CPAN will still do this on old Test::Builder, but will defer to &lt;a href=&quot;Test2::IPC&quot;&gt;Test2::IPC&lt;/a&gt; on Test2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e1c2932ecab8fa2b7abd4c5ef42f132f0546a7" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but have a minor test name behavior that breaks with Test2. Old versions will no longer install because of this. The latest version on CPAN will install just fine. Upgrading is not required, but is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686b6b48ccfd93fda8d202b7ab00cb50bff77185" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but would not install because &lt;a href=&quot;Test::Aggregate&quot;&gt;Test::Aggregate&lt;/a&gt; was in the dependency chain. An upgrade should not be needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4065d89a2f43100a5cf55aa7a52797bb4059e14" translate="yes" xml:space="preserve">
          <source>Old-style versus new-style block names</source>
          <target state="translated">Имена блоков в старом и новом стиле</target>
        </trans-unit>
        <trans-unit id="69d1a0ab771940cdc9cc69797ad23f167d7d2a58" translate="yes" xml:space="preserve">
          <source>Oldconfig.U</source>
          <target state="translated">Oldconfig.U</target>
        </trans-unit>
        <trans-unit id="0f656bb21c786456d378ff0e1756c02c791362d3" translate="yes" xml:space="preserve">
          <source>Older documentation (and some CPAN modules) encouraged this syntax, particularly for constructors, so you may still find it in the wild. However, we encourage you to avoid using it in new code.</source>
          <target state="translated">Старая документация (и некоторые CPAN модули)поощряли этот синтаксис,особенно для конструкторов,так что вы все еще можете найти его в дикой природе.Тем не менее,мы рекомендуем вам избегать использования его в новом коде.</target>
        </trans-unit>
        <trans-unit id="74bfa7b0d7fbfaf100a04613f263acdd445ac2c9" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing  (space) or any character from the set &lt;code&gt;!#%&amp;amp;'()*;&amp;lt;=&amp;gt;?&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845ea4ddc5e221b527b9b5fd418aec5c3f3db57a" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing any character matching &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</source>
          <target state="translated">Старые выпуски СДН (до OpenVOS Release 17,0) имена ограничения файлов до 32 или менее символов, запретить имена файлов из начиная с &lt;code&gt;-&lt;/code&gt; символа, а также запретить имена файлов из которых содержит любой соответствующий символ &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4148117b640e73f6a46898d2260720a46ef03ff" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt;
documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , to control how the link comes out.</source>
          <target state="translated">Старые переводчики могут добавить формулировку вокруг ссылки L &amp;lt;&amp;gt;, так что &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; может стать, например, &amp;laquo;man-страницей Foo :: Bar&amp;raquo;. Поэтому вам не следует писать такие вещи, как документация &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; , если вы хотите, чтобы переведенный документ читался разумно. Вместо этого напишите документацию &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; или &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , чтобы контролировать вывод ссылки.</target>
        </trans-unit>
        <trans-unit id="14a3863272e849d79d3bd80306df053765edc2b6" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt;, to control how the link comes out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74cfdc9feb194af111f83545c6d1330ca4e4400c" translate="yes" xml:space="preserve">
          <source>Older versions of CPAN.pm had the original root directory of all tarballs in the build directory. Now there are always random characters appended to these directory names. Why was this done?</source>
          <target state="translated">Старые версии CPAN.pm имели оригинальный корневой каталог всех tarballs в каталоге сборки.Теперь к этим именам каталогов всегда добавляются случайные символы.Почему это было сделано?</target>
        </trans-unit>
        <trans-unit id="0de4f0e8390c99f19bd133eee1f9e0b1e299d545" translate="yes" xml:space="preserve">
          <source>Older versions of perl may have security vulnerabilities, some of which are serious (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; and search &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=Perl&quot;&gt;CVEs&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa508d12280c1adaeb775241c86d759189c3c71c" translate="yes" xml:space="preserve">
          <source>Older versions of this document recommended to use &lt;code&gt;void&lt;/code&gt; return value in such cases. It was discovered that this could lead to segfaults in cases when XSUB was</source>
          <target state="translated">Более старые версии этого документа рекомендовали использовать в таких случаях возвращаемое значение &lt;code&gt;void&lt;/code&gt; . Было обнаружено, что это может привести к сбою сегментов в случаях, когда XSUB</target>
        </trans-unit>
        <trans-unit id="7dc06c5173c26db9fe80a519eb5a6ebe90623816" translate="yes" xml:space="preserve">
          <source>Oldsyms.U</source>
          <target state="translated">Oldsyms.U</target>
        </trans-unit>
        <trans-unit id="c1039769adff260cb2734954cd648c56f4365afe" translate="yes" xml:space="preserve">
          <source>Olivier Mengu&amp;eacute; &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf87efb8c04dd4dc674e0b0506f97a5eb0660ea" translate="yes" xml:space="preserve">
          <source>Olivier Mengue</source>
          <target state="translated">Оливье Менге</target>
        </trans-unit>
        <trans-unit id="0aa942a536d7cded5f6fc6f8772142dfcfdb221f" translate="yes" xml:space="preserve">
          <source>Olivier Mengue &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ed24c21f5dd18b200f0c25095d7a6774573e1a" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;constant()&lt;/code&gt; from the .xs file and corresponding specialised &lt;code&gt;AUTOLOAD&lt;/code&gt; from the .pm file.</source>
          <target state="translated">Опустите &lt;code&gt;constant()&lt;/code&gt; из файла .xs и соответствующую специализированную &lt;code&gt;AUTOLOAD&lt;/code&gt; из файла .pm.</target>
        </trans-unit>
        <trans-unit id="9c4aa09aebc98ad6e647cac1f8fffb08291cde09" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">Опустите все средства автозагрузки. Это то же самое, что и &lt;b&gt;-c,&lt;/b&gt; но также удаляет оператор &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; из файла .pm.</target>
        </trans-unit>
        <trans-unit id="0e2601b286234df74dc051d8e9fbf4262affc4dd" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;use AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89bf96a83d88777c4a53a3cada5e03b11bfab80" translate="yes" xml:space="preserve">
          <source>Omit redundant punctuation as long as clarity doesn't suffer.</source>
          <target state="translated">Опустите лишнюю пунктуацию,пока не пострадает ясность.</target>
        </trans-unit>
        <trans-unit id="5939f2980c3053a7b35d91579e70755fbf358beb" translate="yes" xml:space="preserve">
          <source>Omit the XS portion. Used to generate a skeleton pure Perl module. &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; are implicitly enabled.</source>
          <target state="translated">Опустите часть XS. Используется для создания скелета чистого модуля Perl. &lt;code&gt;-c&lt;/code&gt; и &lt;code&gt;-f&lt;/code&gt; включены неявно.</target>
        </trans-unit>
        <trans-unit id="ab66b48afb255f3fa8074752a39b329797b5aa56" translate="yes" xml:space="preserve">
          <source>Omit the autogenerated stub POD section.</source>
          <target state="translated">Пропустите секцию POD с автогенерированным шлейфом.</target>
        </trans-unit>
        <trans-unit id="aef75bc39700a2d7f9ba2d4fcc4c938989654f2d" translate="yes" xml:space="preserve">
          <source>Omits creation of the</source>
          <target state="translated">Опускает создание</target>
        </trans-unit>
        <trans-unit id="3b6794df4ab49e575f0969623fbbb9b4eead1f5f" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; section is equivalent to using an empty one, logically enough, so &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce977cba7ea14f47b6252159a9ce77942da917fb" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">Пропуск раздела &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; эквивалентен использованию пустого раздела, что достаточно логично, поэтому &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; сразу вернуться, чтобы проверить условие в начале цикла.</target>
        </trans-unit>
        <trans-unit id="648601245d456cf14017862c18156a366b17d689" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">Пропуск раздела &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; эквивалентен использованию пустого раздела, что достаточно логично, поэтому &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; сразу вернуться, чтобы проверить условие в начале цикла.</target>
        </trans-unit>
        <trans-unit id="2170721cf53167c035658d5db7e3986d2f62f2d5" translate="yes" xml:space="preserve">
          <source>Omitting the first argument (input text) means process &lt;code&gt;$_&lt;/code&gt; instead. Omitting the second argument (delimiter brackets) indicates that only &lt;code&gt;'{'&lt;/code&gt; is to be used. Omitting the third argument (prefix argument) implies optional whitespace at the start. Omitting the fourth argument (outermost delimiter brackets) indicates that the value of the second argument is to be used for the outermost delimiters.</source>
          <target state="translated">Пропуск первого аргумента (вводимый текст) означает вместо этого процесс &lt;code&gt;$_&lt;/code&gt; . Отсутствие второго аргумента (скобки-разделители) означает, что следует использовать только &lt;code&gt;'{'&lt;/code&gt; . Отсутствие третьего аргумента (аргумента префикса) подразумевает необязательный пробел в начале. Отсутствие четвертого аргумента (скобки крайних разделителей) указывает, что значение второго аргумента должно использоваться для крайних разделителей.</target>
        </trans-unit>
        <trans-unit id="650eb97953ce5c6e07ebcb4164c35bedbbc7ac72" translate="yes" xml:space="preserve">
          <source>On 64bit systems some data structures may exceed the 2G (i.e. I32_MAX) limit. On 32bit systems also strings between I32 and U32 (2G-4G). Since Storable 3.00 (not in perl5 core) we are able to store and retrieve these objects, even if perl5 itself is not able to handle them. These are strings longer then 4G, arrays with more then 2G elements and hashes with more then 2G elements. cperl forbids hashes with more than 2G elements, but this fail in cperl then. perl5 itself at least until 5.26 allows it, but cannot iterate over them. Note that creating those objects might cause out of memory exceptions by the operating system before perl has a chance to abort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19163591bedfb142adf27e96746ef3cf121a26f" translate="yes" xml:space="preserve">
          <source>On AIX 4.2 using xlC, we continue:</source>
          <target state="translated">На AIX 4.2,используя xlC,мы продолжаем:</target>
        </trans-unit>
        <trans-unit id="b7bebcc7500e38fa33da9de2419b5d4507654e3f" translate="yes" xml:space="preserve">
          <source>On AIX 4.3 using vac, we continue:</source>
          <target state="translated">На AIX 4.3,используя отпуск,мы продолжаем:</target>
        </trans-unit>
        <trans-unit id="eeac3c2c2feb8a620697ff4a8d972aa2a092d986" translate="yes" xml:space="preserve">
          <source>On AIX, is &lt;code&gt;.exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f8078cc0b8af6aad63b15eccc9063b75b69a03" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;&quot;OPERATOR DIFFERENCES&quot; in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164f1a22c1ddad7a43b51fc0e97d9cc8c54ba4c2" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">На платформах ASCII результирующие символы из приведенного выше списка представляют собой полный набор элементов управления ASCII. На платформах EBCDIC это не так; см. &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;РАЗЛИЧИЯ ОПЕРАТОРОВ в perlebcdic&lt;/a&gt; для полного обсуждения различий между ними для платформ ASCII и EBCDIC.</target>
        </trans-unit>
        <trans-unit id="e4ce9df615081837a49ff8902adf19d0bea73069" translate="yes" xml:space="preserve">
          <source>On ASCII-encoded platforms it is possible to strip characters outside of the printable set using:</source>
          <target state="translated">На платформах с ASCII-кодировкой возможна зачистка символов за пределами печатного набора:</target>
        </trans-unit>
        <trans-unit id="f524bd580ae58f0c6ff9d83f9b34774b97e1a12f" translate="yes" xml:space="preserve">
          <source>On DOS-like platforms, if the program does not contain directory separators, it will first be searched for in the current directory before being searched for on the PATH. On Unix platforms, the program will be searched for strictly on the PATH.</source>
          <target state="translated">На DOS-подобных платформах,если программа не содержит разделителей каталогов,поиск будет сначала произведен в текущем каталоге,а затем в PATH.На Unix-платформах поиск программы будет осуществляться строго по PATH.</target>
        </trans-unit>
        <trans-unit id="2f93d8018989db4b239468fb46d0cdba5c2f0db5" translate="yes" xml:space="preserve">
          <source>On DOS/Windows like architectures where this layer is part of the defaults, it also acts like the &lt;code&gt;:perlio&lt;/code&gt; layer, and removing the CRLF translation (such as with &lt;code&gt;:raw&lt;/code&gt;) will only unset the CRLF translation flag. Since Perl 5.14, you can also apply another &lt;code&gt;:crlf&lt;/code&gt; layer later, such as when the CRLF translation must occur after an encoding layer. On other architectures, it is a mundane CRLF translation layer and can be added and removed normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cac4dfb85f7858cf9af4b4f306e4164c94a071a" translate="yes" xml:space="preserve">
          <source>On DOSISH systems, backslash is a valid directory separator character. In this case, use of backslash as a quoting character (via GLOB_QUOTE) interferes with the use of backslash as a directory separator. The best (simplest, most portable) solution is to use forward slashes for directory separators, and backslashes for quoting. However, this does not match &quot;normal practice&quot; on these systems. As a concession to user expectation, therefore, backslashes (under GLOB_QUOTE) only quote the glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself. All other backslashes are passed through unchanged.</source>
          <target state="translated">На системах DOSISH обратный слеш является допустимым символом разделителя каталогов.В этом случае использование обратного слеша в качестве символа кавычки (через GLOB_QUOTE)препятствует использованию обратного слеша в качестве разделителя каталогов.Лучшим (простым,наиболее переносимым)решением является использование прямого слеша для разделителей каталогов,а обратного слеша-для кавычек.Однако это не соответствует &quot;нормальной практике&quot; на этих системах.Поэтому,в качестве уступки ожиданиям пользователя,обратные слеши (в разделе GLOB_QUOTE)цитируют только глобусные метасимволы '[',']','{','}','-','~',и сам обратный слэш.Все остальные обратные слеши передаются без изменений.</target>
        </trans-unit>
        <trans-unit id="bc353a101a732e619259516d5005fd73e9056d46" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</source>
          <target state="translated">На платформах EBCDIC символы в наборе символов Latin 1 рассматриваются как часть буквального UTF-EBCDIC символа.</target>
        </trans-unit>
        <trans-unit id="e55bcfcaea4d3f5091519d63553b94250f256406" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower than on ASCII. Prior to that, code points 2**31 and higher were simply unrepresentable, and a different, incompatible method was used to represent code points between 2**30 and 2**31 - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6112256ee63f46a5e15ec3716f73262824a70fb0" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, code points above 0x3FFF_FFFF have a different representation in Perl v5.24 than before, so any file containing these that was written before that version will require conversion before being readable by a later Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05835a5188ac319110e1d4a7bb82d82adb8499ed" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, prior to v5.22, using &lt;code&gt;\N{U+...}&lt;/code&gt; doesn't work properly.</source>
          <target state="translated">На платформах EBCDIC до v5.22 использование &lt;code&gt;\N{U+...}&lt;/code&gt; не работает должным образом.</target>
        </trans-unit>
        <trans-unit id="79296614d9a9f53308ccee5fcf367fe461dcdb98" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">На платформах EBCDIC внутренняя форма кодировки Unicode - UTF-EBCDIC вместо UTF-8. Разница в том, что UTF-8 является &amp;laquo;безопасным для ASCII&amp;raquo; в том смысле, что символы ASCII кодируются в UTF-8 как есть, а UTF-EBCDIC &amp;laquo;безопасен для EBCDIC&amp;raquo; в том смысле, что все основные символы (включая все те, которые имеют эквиваленты ASCII (например, &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="69ff29e47116562e384d48eb5aae2111322261e8" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt;, &lt;code&gt;&quot;0&quot;&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24eed6474921c436fc7017c3e9ee9fd9b18bd251" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt; , in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt; . The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">В Linux начиная с perl v5.14.0 унаследованное имя процесса будет установлено с помощью &lt;code&gt;prctl(2)&lt;/code&gt; в дополнение к изменению имени POSIX с помощью &lt;code&gt;argv[0]&lt;/code&gt; как это делал perl начиная с версии 4.000. Теперь системные утилиты, которые читают устаревшее имя процесса, такое как ps, top и killall, распознают имя, которое вы задали при присвоении &lt;code&gt;$0&lt;/code&gt; . Предоставляемая вами строка будет обрезана до 16 байт, это ограничение, наложенное Linux.</target>
        </trans-unit>
        <trans-unit id="971443928989b7bee0ac0a568694348131be6843" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt;, in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt;. The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdfac3cee0fd1507f95a5dcb4019d7d46aa51e5" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own set of environment variables.</source>
          <target state="translated">В MSWin32 каждый поток поддерживает свой набор переменных окружения.</target>
        </trans-unit>
        <trans-unit id="07fed63ea1db8f306a3fcf956ae30aa0f5f797ab" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own the current working directory setting.</source>
          <target state="translated">В MSWin32 каждый поток поддерживает свои собственные настройки текущей рабочей директории.</target>
        </trans-unit>
        <trans-unit id="23b53b159dd238a66ca7c109ea8e5776a37bac8e" translate="yes" xml:space="preserve">
          <source>On Mac OS X the file system encoding is always UTF-8 while the locale can otherwise be set up as normal for POSIX systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9baea2d4ac629b8f41cbaaf2320e912f58f4e6" translate="yes" xml:space="preserve">
          <source>On Mac OS, assumes that the last part of the path is a filename unless $no_file is true or a trailing separator &quot;:&quot; is present.</source>
          <target state="translated">В Mac OS предполагает,что последняя часть пути-это имя файла,если только $no_file не равен true или не присутствует разделитель трейлинга &quot;:&quot;.</target>
        </trans-unit>
        <trans-unit id="2c8cbf9feb69a54cf112ddb280be3a352f96b397" translate="yes" xml:space="preserve">
          <source>On Mac OS, there's nothing to be done. Returns what it's given.</source>
          <target state="translated">На Mac OS ничего не поделаешь.Возвращает то,что дано.</target>
        </trans-unit>
        <trans-unit id="1110960c59d5ed71b666c1e4c9c495538ef1f179" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the</source>
          <target state="translated">На OS/390 или z/OS смотрите раздел</target>
        </trans-unit>
        <trans-unit id="5637d80de5f3ae2f3a457607d81fcd5653f85175" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the &lt;a href=&quot;http://man.he.net/man1/iconv&quot;&gt;iconv(1)&lt;/a&gt; manpage. One way to invoke the &lt;code&gt;iconv&lt;/code&gt; shell utility from within perl would be to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d05f25204078cfb6759aed14497988db83abc4" translate="yes" xml:space="preserve">
          <source>On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).</source>
          <target state="translated">На операционных системах,где временные файлы автоматически удаляются при закрытии временного файла,вызов этой функции не будет иметь никакого эффекта,кроме удаления временных каталогов (которые могут включать временные файлы).</target>
        </trans-unit>
        <trans-unit id="d375d4a0af7ab518303234b7c17d1169f40e9bcc" translate="yes" xml:space="preserve">
          <source>On PA-RISC you need a different compiler for 32-bit applications and for 64-bit applications. On PA-RISC, 32-bit objects and 64-bit objects do not mix. Period. There is no different behaviour for HP C-ANSI-C or GNU gcc. So if you require your perl binary to use 64-bit libraries, like Oracle-64bit, you MUST build a 64-bit perl.</source>
          <target state="translated">На PA-RISC нужен другой компилятор для 32-битных и 64-битных приложений.На PA-RISC 32-битные объекты и 64-битные объекты не смешиваются.Период.Для HP C-ANSI-C или GNU gcc нет различного поведения.Так что если для использования 64-битных библиотек,таких как Oracle-64bit,вам нужен perl,то вы ДОЛЖНЫ собрать 64-битный perl.</target>
        </trans-unit>
        <trans-unit id="a9150346abbcb79f7b8cfc1b292f802424998448" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;&quot;MAKE&quot;&lt;/a&gt; parameter for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d7a8c18ee051a4b37ffd21066565b5d3a9d46d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; parameter for details.</source>
          <target state="translated">В системах POSIX этой программой, скорее всего, будет GNU Make; в Microsoft Windows это будет Microsoft NMake, DMake или GNU Make. См. Подробности в разделе о параметре &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="167592a5236c1f91d56ed9f91f8821eeb4df3832" translate="yes" xml:space="preserve">
          <source>On Perl 5.10 and above, using smart-match (&lt;code&gt;~~&lt;/code&gt;) with an &lt;code&gt;autodie::exception&lt;/code&gt; object will use &lt;code&gt;matches&lt;/code&gt; underneath. This module used to recommend using smart-match with the exception object on the left hand side, but in future Perls that is likely to stop working. The smart-match facility of this class should only be used with the exception object on the right hand side. Having the exception object on the right is both future-proof and portable to older Perls, back to 5.10. Beware that this facility can only be relied upon when it is certain that the exception object actually is an &lt;code&gt;autodie::exception&lt;/code&gt; object; it is no more capable than an explicit call to the &lt;code&gt;matches&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec792d74700736cdfd9a5c7544b143a95c42354e" translate="yes" xml:space="preserve">
          <source>On Perl versions before 5.7, Unicode characters with a value over 255 (like lambda or emdash) can't be conveyed. This module does work under such early Perl versions, but in the place of each such character, you get a &quot;?&quot;. Latin-1 characters (characters 160-255) are unaffected.</source>
          <target state="translated">На Perl-версиях до 5.7 символы юникода со значением более 255 (например,лямбда или emdash)не могут быть переданы.Этот модуль работает под такими ранними Perl-версиями,но вместо каждого такого символа вы получаете &quot;?&quot;.Символы латинского алфавита 1 (символы 160-255)не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="1b4fd9509076b696b649edffe06b6748d3a6e8fc" translate="yes" xml:space="preserve">
          <source>On The Road</source>
          <target state="translated">В дороге</target>
        </trans-unit>
        <trans-unit id="3f5f166131dd85ac983f4decac309eb76b2240b2" translate="yes" xml:space="preserve">
          <source>On Unix these calls probably have no effect whatsoever. Elsewhere they alter &quot;\n&quot; to CR,LF translation and possibly cause a special text &quot;end of file&quot; indicator to be written or honoured on read. The effect of making the call after doing any IO to the handle depends on the implementation. (It may be ignored, affect any data which is already buffered as well, or only apply to subsequent data.)</source>
          <target state="translated">На Unix эти звонки,вероятно,не имеют никакого эффекта.В других местах они изменяют &quot;\n&quot; на перевод CR,LF и,возможно,вызывают специальный текстовый индикатор &quot;конец файла&quot; при прочтении.Эффект вызова после выполнения любого ввода-вывода в интерпретатор зависит от реализации.(Он может быть проигнорирован,повлиять на любые данные,которые уже буферизированы,или применяться только к последующим данным).</target>
        </trans-unit>
        <trans-unit id="86c676209565e2d780081a941df86b84b21d9627" translate="yes" xml:space="preserve">
          <source>On Unix,</source>
          <target state="translated">На Unix,</target>
        </trans-unit>
        <trans-unit id="88e8f2f2ac45a9bfa4ec12f4ed8e00688059ccf6" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the %ENV hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">В СУБД по умолчанию изменения в хэше %ENV сохраняются после perl выходов.Последующие вызовы perl в том же процессе могут непреднамеренно наследовать настройки среды,которые должны были быть временными.</target>
        </trans-unit>
        <trans-unit id="7a7f6210c11a8722ba30917e3753a6ae39f636f9" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a45916e3343efd4a31048a877153354c7f3a445" translate="yes" xml:space="preserve">
          <source>On VMS only, record reads bypass PerlIO layers and any associated buffering, so you must not mix record and non-record reads on the same filehandle. Record mode mixes with line mode only when the same buffering layer is in use for both modes.</source>
          <target state="translated">Только на VMS,запись читает в обход PerlIO слоев и любой связанной буферизации,так что вы не должны смешивать запись и не-запись читает на той же файловой ручке.Режим записи смешивается с режимом линии только в том случае,если для обоих режимов используется один и тот же слой буферизации.</target>
        </trans-unit>
        <trans-unit id="9795304d9e947203c83b021d72efea5ba3031bdc" translate="yes" xml:space="preserve">
          <source>On VMS systems, arrays tied to environment variables are read-only. Attempting to change anything will cause a warning.</source>
          <target state="translated">На системах VMS массивы,привязанные к переменным окружения,доступны только для чтения.Попытка что-либо изменить вызовет предупреждение.</target>
        </trans-unit>
        <trans-unit id="74564fe6ae7ff11070f358853ddf9ff8e6cf5db3" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;a href=&quot;perlfunc#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ce16b2de32a17abe516725e03bc48e7d14b744" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">В VMS perl определяет смещение UTC по логическому имени &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; . Хотя эпоха VMS началась в 17 ноября 1858 г. 00: 00: 00.00, звонки на &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; время корректируются с учетом смещений с 01-ЯНВ-1970 00: 00: 00.00, как и в Unix.</target>
        </trans-unit>
        <trans-unit id="06a156290eaf8bb336152c15b3a6a3f335cfb709" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt;, &lt;code&gt;$ENV{TERM}&lt;/code&gt;, &lt;code&gt;$ENV{PATH}&lt;/code&gt;, and &lt;code&gt;$ENV{USER}&lt;/code&gt;, are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4640e9f8e338d51c98fb597af9efcb27c56ecf3e" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;code&gt;%ENV&lt;/code&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; , and &lt;code&gt;$ENV{USER}&lt;/code&gt; , are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">В VMS некоторые записи в хэше &lt;code&gt;%ENV&lt;/code&gt; динамически создаются, когда их ключ используется при чтении, если они ранее не существовали. Известно, что значения &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; и &lt;code&gt;$ENV{USER}&lt;/code&gt; генерируются динамически. Конкретные имена, которые создаются динамически, могут различаться в зависимости от версии библиотеки C в VMS, и их может существовать больше, чем задокументировано.</target>
        </trans-unit>
        <trans-unit id="00ea6af97bd8140ce5328dca64213948bcea1edc" translate="yes" xml:space="preserve">
          <source>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</source>
          <target state="translated">На VMS,которая имеет концепцию тома,это поле будет пустым,потому что спецификации файлов VMS преобразуются в абсолютный формат UNIX,а информация об томах включается прозрачно.</target>
        </trans-unit>
        <trans-unit id="7181afce3600b3de6f4aeeecdb2753ed0ec50123" translate="yes" xml:space="preserve">
          <source>On VOS, time values are 32-bit quantities.</source>
          <target state="translated">На VOS значения времени составляют 32-разрядные величины.</target>
        </trans-unit>
        <trans-unit id="260fa2754bf084766a1e3d1258ce83d5b5d3b0dc" translate="yes" xml:space="preserve">
          <source>On Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; to a true value speeds up &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; by not performing this operation. (Win32)</source>
          <target state="translated">В Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; необходимо открыть файл, чтобы определить количество ссылок и обновить атрибуты, которые могли быть изменены с помощью жестких ссылок. Установка &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; в истинное значение ускоряет &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; , не выполняя эту операцию. (Win32)</target>
        </trans-unit>
        <trans-unit id="43527614576e6873bffe9e01120e3463ca7900ba" translate="yes" xml:space="preserve">
          <source>On Win32 platforms this</source>
          <target state="translated">На Win32 платформах это</target>
        </trans-unit>
        <trans-unit id="82880baf8efa4ec11213dbe5173474c89dad4fe5" translate="yes" xml:space="preserve">
          <source>On Win32 ports only, may be set to an alternative shell that Perl must use internally for executing &quot;backtick&quot; commands or system(). Default is &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; on WindowsNT and &lt;code&gt;command.com /c&lt;/code&gt; on Windows95. The value is considered space-separated. Precede any character that needs to be protected, like a space or backslash, with another backslash.</source>
          <target state="translated">Только на портах Win32 может быть установлена ​​альтернативная оболочка, которую Perl должен использовать внутри для выполнения команд с обратным апострофом или system (). По умолчанию это &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; в WindowsNT и &lt;code&gt;command.com /c&lt;/code&gt; в Windows95. Значение считается разделенным пробелами. Перед любым символом, который необходимо защитить, например пробелом или обратной косой чертой, ставьте другую обратную косую черту.</target>
        </trans-unit>
        <trans-unit id="9e2fd429fcf5069c4431ad927b87b339316ae6b1" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.14) is &quot;unix crlf&quot;. Win32's &quot;stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform. The &lt;code&gt;crlf&lt;/code&gt; layer provides CRLF conversion as well as buffering.</source>
          <target state="translated">В Win32 по умолчанию в этом выпуске (5.14) используется &quot;unix crlf&quot;. &quot;Stdio&quot; Win32 имеет ряд ошибок / неправильных функций для Perl IO, которые отчасти зависят от версии и поставщика компилятора C. Использование нашего собственного слоя &lt;code&gt;crlf&lt;/code&gt; в качестве буфера позволяет избежать этих проблем и сделать вещи более единообразными. &lt;code&gt;crlf&lt;/code&gt; слой обеспечивает преобразование CRLF, а также буферизация.</target>
        </trans-unit>
        <trans-unit id="c5cad1f19297cc76fd2c0f0cbe96d6c8b8641a99" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.30) is &quot;:unix:crlf&quot;. Win32's &quot;:stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;:crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b57948ea68a275535d9745ad7c79b49f92a2345" translate="yes" xml:space="preserve">
          <source>On Win32, is &lt;code&gt;.def&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c661dbe60c2c9116c9b6dd06327729491426c6d8" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">В WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; может изменять идентификаторы пользователя и группы файла. В Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; не работает, хотя это уместно, поскольку не существует модели безопасности.</target>
        </trans-unit>
        <trans-unit id="67f45342ed2b9a9fadda985a145ee379fe5a5018" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;chown()&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;chown()&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2723b9ca133f3aa539e50122b610714bafdb1670" translate="yes" xml:space="preserve">
          <source>On Windows NT 4 SP6 and later this function returns the following additional values: SPMAJOR, SPMINOR, SUITEMASK, PRODUCTTYPE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a917d2cc116f1698163f4d2d945df6a75555b19b" translate="yes" xml:space="preserve">
          <source>On Windows and DOS, this class will not modify any environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691092ab9995db74d07e64291684fba5bdc303c2" translate="yes" xml:space="preserve">
          <source>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</source>
          <target state="translated">В Windows это значение может быть пустым,если uri принадлежит сетевому ресурсу,в этом случае будет определено свойство 'share'.К тому же,спецификации тома,использующие '|' в качестве ':',будут преобразованы при чтении в ':'.</target>
        </trans-unit>
        <trans-unit id="98136ca8ec46fb8ca78cee1f5eedf07f7ec52018" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Errno&lt;/code&gt; also defines and conditionally exports all the Winsock error constants defined in your system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5fbf1c54f4cbef1a178b46ad87cba27e8e2dbd" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;make_path&lt;/code&gt; gives you this warning, it may mean that you have exceeded your filesystem's maximum path length.</source>
          <target state="translated">В Windows, если &lt;code&gt;make_path&lt;/code&gt; выдает это предупреждение, это может означать, что вы превысили максимальную длину пути вашей файловой системы.</target>
        </trans-unit>
        <trans-unit id="3c8b57e0402fd5a94f4f0f14b11ffcf0d1fe5e8c" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">В Windows только синтаксис косвенного объекта &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; надежно избегает использования оболочки; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , даже с более чем одним элементом, вернется к оболочке, если первое порождение не удастся.</target>
        </trans-unit>
        <trans-unit id="3489286293a7a904918509c734ebd323e4463d4f" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">В Windows только синтаксис косвенного объекта &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; надежно избегает использования оболочки; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , даже с более чем одним элементом, вернется к оболочке, если первое порождение не удастся.</target>
        </trans-unit>
        <trans-unit id="7e1ef63036ab0ac76882604ffa03e365a2cc3538" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;exec LIST&lt;/code&gt;, even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aceed2ebeb2b1d6033e61b3459bb2d4bb7870fd" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feb74b008066b7c35338a20235da8f4be77079d" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">В Windows вы можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt; . После создания объекта для дескриптора выходного файла, на который вы хотите воздействовать, вызовите метод &lt;code&gt;Cls&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="868e4a545e3b36ea0e0005a952326d136f092bcb" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt; , you can get even larger dates for those really long running projects:</source>
          <target state="translated">На 64-битном &lt;code&gt;perl&lt;/code&gt; вы можете получить еще большие даты для действительно длительных проектов:</target>
        </trans-unit>
        <trans-unit id="1241860881c4ad85f6cc345b32d854e56c75ec64" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt;, you can get even larger dates for those really long running projects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df92a12e7efed4b5a0ee3432bfa643483f4e66b5" translate="yes" xml:space="preserve">
          <source>On a Perl built without &lt;code&gt;-DDEBUGGING&lt;/code&gt;, or when the &lt;code&gt;-Di&lt;/code&gt; command-line switch is not specified, or under taint, PerlIO_debug() is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e386d10b1658b7fab41743c4a6c61db5c0bb8" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, these documentation files will usually also be available as manpages for use with the</source>
          <target state="translated">На Unix-подобной системе эти файлы документации обычно также будут доступны в виде manpages для использования с</target>
        </trans-unit>
        <trans-unit id="660953bc195f4695e40bafcb35d1864a5ea40fb9" translate="yes" xml:space="preserve">
          <source>On a binary string, you would do things like:</source>
          <target state="translated">На бинарной строке ты бы делал такие вещи:</target>
        </trans-unit>
        <trans-unit id="c2fd3df54f8bb812f03e4f16967bb0e0784afad2" translate="yes" xml:space="preserve">
          <source>On a new install it is &quot;C:\Windows CE Tools&quot;. Goto &quot;C:\Windows CE Tools&quot; in a file manager and see if &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot; exists on your disk. If not the SDKROOT need to be changed to &quot;C:\Program Files\Windows CE Tools&quot;.</source>
          <target state="translated">При новой установке это &quot;C:\Windows CE Tools&quot;.Загляните в файловый менеджер &quot;C:\Windows CE Tools&quot; и посмотрите,существует ли на диске &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot;.Если нет,то SDKROOT нужно заменить на &quot;C:\Program Files\Windows CE Tools&quot;.</target>
        </trans-unit>
        <trans-unit id="299062bf85cb6925da5e4883a42054b0da9f24d7" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; , если вы используете (X) PUSH [iunp] , вам понадобится &lt;code&gt;dTARG&lt;/code&gt; в объявлениях переменных, чтобы макросы &lt;code&gt;*PUSH*&lt;/code&gt; могли использовать локальную переменную &lt;code&gt;TARG&lt;/code&gt; . См. Также &lt;code&gt;dTARGET&lt;/code&gt; и &lt;code&gt;dXSTARG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75330f133f27aefde9a996a79a95540c06e5ca79" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt;. See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8ad329e5099ea252a3ca17c446006da287d9da" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; verb below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d381c7864f9bd0c496e832a74c2bc6e826af96f2" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:NAME)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">В случае успешного совпадения переменной &lt;code&gt;$REGERROR&lt;/code&gt; будет присвоено значение FALSE, а переменной &lt;code&gt;$REGMARK&lt;/code&gt; будет присвоено имя последнего выполненного шаблона &lt;code&gt;(*MARK:NAME)&lt;/code&gt; . Подробнее см. Объяснение глагола &lt;code&gt;(*MARK:NAME)&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="df6a4ca6e213ccefa4b99c6f895a6d3c5870376c" translate="yes" xml:space="preserve">
          <source>On a text string, you would do things like:</source>
          <target state="translated">На текстовой строке ты бы делал такие вещи:</target>
        </trans-unit>
        <trans-unit id="16575e035ca925e5fa5bb99a005281cd0246209f" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">На всех платформах, кроме MSWin32, настройка текущего рабочего каталога используется всеми потоками, так что изменение его в одном потоке (например, использование &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; ) повлияет на все потоки в приложении.</target>
        </trans-unit>
        <trans-unit id="ab64dc72a66da50a5cd3f10fe53225e1e0e96f58" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;chdir()&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986faea7525ededb053c5e26524df4fe094d07f8" translate="yes" xml:space="preserve">
          <source>On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):</source>
          <target state="translated">На всех выпущенных версиях Solaris (8,9 и 10)необходимо убедиться,что установлены следующие пакеты (эта информация взята из Solaris FAQ):</target>
        </trans-unit>
        <trans-unit id="0adaab19e480042e586e12a800bf5b600ec97adc" translate="yes" xml:space="preserve">
          <source>On an exception during the execution of the request, the &lt;code&gt;status&lt;/code&gt; field will contain 599, and the &lt;code&gt;content&lt;/code&gt; field will contain the text of the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2b4cb070056fb4070c425608e71d9f9a08f8e3" translate="yes" xml:space="preserve">
          <source>On both platforms, ASCII and EBCDIC, &lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt; is set if Perl extended UTF-8 is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7579bfbb9367171f6983e33cf0c36d410d39ce7e" translate="yes" xml:space="preserve">
          <source>On certain platforms like Win32, OS/2, VMS, and AIX, it is necessary to perform some actions before invoking the linker. The &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; module does this, writing files used by the linker during the creation of shared libraries for dynamic extensions. The names of any files written will be returned as a list.</source>
          <target state="translated">На определенных платформах, таких как Win32, OS / 2, VMS и AIX, перед вызовом компоновщика необходимо выполнить некоторые действия. Модуль &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; делает это, записывая файлы, используемые компоновщиком во время создания общих библиотек для динамических расширений. Имена любых записанных файлов будут возвращены в виде списка.</target>
        </trans-unit>
        <trans-unit id="68f10a6e0b39851d70a2411f9d6927ec33bc1d28" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;rdev&lt;/code&gt; fields seem to be different in Windows. Also, it seems that the size of the file returned by stat() does not always agree, with &lt;code&gt;stat(FH)&lt;/code&gt; being more accurate than &lt;code&gt;stat(filename)&lt;/code&gt;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &lt;code&gt;unlink0&lt;/code&gt; it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48eee9c0d3be3641023bdfbc12b873ba074e7d8a" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">На некоторых платформах,например Windows,не все поля,возвращаемые функцией stat(),можно сравнить.Например,C</target>
        </trans-unit>
        <trans-unit id="0337022749da68904dc67bf7ba7a67afde209ea2" translate="yes" xml:space="preserve">
          <source>On creation of a new message queue &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">При создании новой очереди сообщений &lt;code&gt;FLAGS&lt;/code&gt; используется для установки разрешений. Будьте осторожны, чтобы не устанавливать какие-либо флаги, которые реализация Sys V IPC не позволяет: в некоторых системах установка битов выполнения приводит к сбою операций.</target>
        </trans-unit>
        <trans-unit id="82a6576fe44e35482e50d08d072f3b166203f73f" translate="yes" xml:space="preserve">
          <source>On creation of a new semaphore set &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">При создании нового набора семафоров &lt;code&gt;FLAGS&lt;/code&gt; используется для установки разрешений. Будьте осторожны, чтобы не устанавливать какие-либо флаги, которые реализация Sys V IPC не позволяет: в некоторых системах установка битов выполнения приводит к сбою операций.</target>
        </trans-unit>
        <trans-unit id="2a590d182300640c7833d62b48486238fd75ebb4" translate="yes" xml:space="preserve">
          <source>On creation of a new shared memory segment &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">При создании нового сегмента разделяемой памяти &lt;code&gt;FLAGS&lt;/code&gt; используется для установки разрешений. Будьте осторожны, чтобы не устанавливать какие-либо флаги, которые реализация Sys V IPC не позволяет: в некоторых системах установка битов выполнения приводит к сбою операций.</target>
        </trans-unit>
        <trans-unit id="475139521c9cdabb77d7980af3eb2a8b5f2f65f2" translate="yes" xml:space="preserve">
          <source>On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">Загрузчик по требованию для слоев PerlIO и корня PerlIO::*пространство имен</target>
        </trans-unit>
        <trans-unit id="f2bd0e6ad9c12f3371f3ea04fa2670eb6d77c58f" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt; . The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt; . Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">В каждой строке два выражения, которые делают то же самое. Левые версии работают с массивом &lt;code&gt;@a&lt;/code&gt; . Правые версии работают с массивом, на который ссылается &lt;code&gt;$aref&lt;/code&gt; . Как только они находят массив, с которым работают, обе версии делают с массивами то же самое.</target>
        </trans-unit>
        <trans-unit id="8897d9218b422eeafd07a396a29ac11d0861b3d9" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt;. The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt;. Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2fc3f2e5f903dbf2df61622a774607772dffe7" translate="yes" xml:space="preserve">
          <source>On entry</source>
          <target state="translated">На въезде</target>
        </trans-unit>
        <trans-unit id="5332f588a30c3ea7aadbd06e40cead0c170fd4cf" translate="yes" xml:space="preserve">
          <source>On entry &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;*len_p&lt;/code&gt; give the string to scan, &lt;code&gt;*flags&lt;/code&gt; gives conversion flags, and &lt;code&gt;result&lt;/code&gt; should be &lt;code&gt;NULL&lt;/code&gt; or a pointer to an NV. The scan stops at the end of the string, or at just before the first invalid character. Unless &lt;code&gt;PERL_SCAN_SILENT_ILLDIGIT&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt;, encountering an invalid character (except NUL) will also trigger a warning. On return &lt;code&gt;*len_p&lt;/code&gt; is set to the length of the scanned string, and &lt;code&gt;*flags&lt;/code&gt; gives output flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567461856d5e115d2b80a7fd737da1ad14817617" translate="yes" xml:space="preserve">
          <source>On entry, &lt;code&gt;pv&lt;/code&gt; points to the beginning of the string; &lt;code&gt;valptr&lt;/code&gt; points to a UV that will receive the converted value, if found; &lt;code&gt;endptr&lt;/code&gt; is either NULL or points to a variable that points to one byte beyond the point in &lt;code&gt;pv&lt;/code&gt; that this routine should examine. If &lt;code&gt;endptr&lt;/code&gt; is NULL, &lt;code&gt;pv&lt;/code&gt; is assumed to be NUL-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bacb97a5d2d18dbb756caabc159aefdc9b27f2c" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; behaves just like &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt;: it returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a23d955ecebada1fa25792c21efad58d10123ee" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d373dfecfc1b40b4191bc53322c596729a91c216" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;$out&lt;/code&gt; will be</source>
          <target state="translated">В случае ошибки &lt;code&gt;$out&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="6d9c828155c10075b78663a197d9675f7b0c4a6f" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ведет себя так же, как select (2): возвращает -1 и устанавливает &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44a9825ad010a78ae9dfacedfc100780572dc5b3" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не сообщит вам, какие файлы удалить не удалось. Если вы хотите узнать, какие файлы удалить не удалось, попробуйте их по одному:</target>
        </trans-unit>
        <trans-unit id="819a867a035e72ad9106196135c7d9f4e3277f0c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ведет себя так же, как select (2): возвращает -1 и устанавливает &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02d8cd61d158290b01862aca1060c57ef007153" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">В случае ошибки &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; не сообщит вам, какие файлы удалить не удалось. Если вы хотите узнать, какие файлы удалить не удалось, попробуйте их по одному:</target>
        </trans-unit>
        <trans-unit id="45e73f10ec8215e1c14a06d24df3320696729415" translate="yes" xml:space="preserve">
          <source>On error, it returns a</source>
          <target state="translated">По ошибке он возвращает</target>
        </trans-unit>
        <trans-unit id="18136bfa0b529aa75c0ac9c1c7bf6a9d9e72f925" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">В случае сбоя будет возвращено &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , а &lt;code&gt;$@&lt;/code&gt; будет содержать причину сбоя.</target>
        </trans-unit>
        <trans-unit id="50989ddb0a8dea38dc2bf4fcec10e5e4fe7a2870" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;undef&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42061a94fa2069016ce15d6e815f1341a1d2cabd" translate="yes" xml:space="preserve">
          <source>On failure, $decoder now contains an error message so the whole thing would be as follows;</source>
          <target state="translated">При сбое $decoder теперь содержит сообщение об ошибке,так что все будет выглядеть следующим образом;</target>
        </trans-unit>
        <trans-unit id="e2a12adff03571a4d3b5aeaef29c5800c5825559" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;$^E&lt;/code&gt; and &lt;code&gt;fileLastError()&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0d12758631e756bc101c1b7dbd8f7f1bdeb657" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;regLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4946878f668a0186d10fe06797278b27abd1a3bc" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В случае ошибки все эти значения (кроме оставшегося текста) становятся &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65448e86201e7fdba6e3baaecf1b7bd6e213136d" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1fcaac32326ffae83caa0ffe515456c5f51d0d" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a91a2a84ece7b39d4d347acdd9155aefa71bb9" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then &lt;code&gt;$REGERROR&lt;/code&gt; will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed, or to TRUE if there was none. Also, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to FALSE.</source>
          <target state="translated">В случае &lt;code&gt;$REGERROR&lt;/code&gt; переменная $ REGERROR будет установлена ​​в значение ARG шаблона глагола, если глагол был задействован в неудачном сопоставлении. Если часть шаблона ARG была опущена, тогда &lt;code&gt;$REGERROR&lt;/code&gt; будет присвоено имя последнего выполненного шаблона &lt;code&gt;(*MARK:NAME)&lt;/code&gt; или TRUE, если его не было. Кроме того, для переменной &lt;code&gt;$REGMARK&lt;/code&gt; будет установлено значение FALSE.</target>
        </trans-unit>
        <trans-unit id="5064a047349d10718c6c646e1984f32902ee6b9f" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">В случае неудачи вызов &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; возвращает неопределенное значение и, вероятно, устанавливает &lt;code&gt;$!&lt;/code&gt; чтобы указать причину, по которой файл не может быть привязан.</target>
        </trans-unit>
        <trans-unit id="d91548debf2b08e67d7bcf23bbc8c0787287ca77" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;tie&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6499c88e3c2522e878e6f7bffd23feb1b280e5ce" translate="yes" xml:space="preserve">
          <source>On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding.</source>
          <target state="translated">На входе преобразует байты,ожидаемые в указанном наборе символов и кодировке,в данные Perl строки (Юникод и внутренняя кодировка Perl в Юникоде,UTF-8).На выходе преобразует данные Perl-строки в указанный набор символов и кодировку.</target>
        </trans-unit>
        <trans-unit id="bbed2b20ba397a052877c8697b2b911fb1c6434c" translate="yes" xml:space="preserve">
          <source>On merging and rebasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31535bab82f01485bf978083451a0bfcdeb0cd1c" translate="yes" xml:space="preserve">
          <source>On modern Linux systems these are typically GDBM files, which are not portable across platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a604823a1a15074f7b145c1cca70f834c1350b88" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt; ) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">На большинстве платформ Unix &lt;code&gt;CHLD&lt;/code&gt; (иногда также известный как &lt;code&gt;CLD&lt;/code&gt; ) имеет особое поведение по отношению к значению &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Установка &lt;code&gt;$SIG{CHLD}&lt;/code&gt; к &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; на такой платформе имеет эффект не создавая процессов зомби , когда родительский процесс не может &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; на его дочерние процессы (т.е. автоматически пожали дочерние процессы). Вызов &lt;code&gt;$SIG{CHLD}&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; с параметром $ SIG {CHLD}, установленным на &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; обычно возвращает &lt;code&gt;-1&lt;/code&gt; на таких платформах.</target>
        </trans-unit>
        <trans-unit id="42dd9a903659956c4b893b1487852dbdc8ae83fe" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt;) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;wait()&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;wait()&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bca4f6aa51b9c47b8c54f57cf475cd9eb5d60c" translate="yes" xml:space="preserve">
          <source>On most operating systems, memory allocated to a program can never be returned to the system. That's why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems that use mmap(2) for allocating large chunks of memory) can reclaim memory that is no longer used, but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.</source>
          <target state="translated">На большинстве операционных систем память,выделенная программе,никогда не может быть возвращена в систему.Поэтому долгоработающие программы иногда выполняются заново.Некоторые операционные системы (в частности,системы,использующие mmap(2)для выделения больших участков памяти)могут восстанавливать память,которая больше не используется,но на таких системах perl должен быть сконфигурирован и скомпилирован так,чтобы использовать не perl,а malloc операционной системы.</target>
        </trans-unit>
        <trans-unit id="5ddf61a72a0a9ae32d8b7111f593a7bce6fa31c0" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;Thread::Queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a71ab0d471330a25bbd4385691ed243516aede" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;thread/queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">В большинстве систем частое и постоянное создание и уничтожение потоков может привести к постоянно растущему объему памяти, занимаемой интерпретатором Perl. Хотя просто запустить потоки, а затем &lt;code&gt;-&amp;gt;join()&lt;/code&gt; или &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; , для долгоживущих приложений лучше поддерживать пул потоков и повторно использовать их для необходимой работы, используя &lt;a href=&quot;thread/queue&quot;&gt;очереди.&lt;/a&gt; чтобы уведомить потоки о незавершенной работе. В дистрибутиве CPAN этого модуля есть простой пример (</target>
        </trans-unit>
        <trans-unit id="09b3ddc53760535691fb4b1738d8256a44f591bc" translate="yes" xml:space="preserve">
          <source>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</source>
          <target state="translated">На большинстве систем вам не разрешается изменять право собственности на файл,если только вы не являетесь суперпользователем,хотя вы должны иметь возможность изменять группу на любую из ваших вторичных групп.На небезопасных системах эти ограничения могут быть смягчены,но это не переносное предположение.На POSIX системах вы можете обнаружить это условие таким образом:</target>
        </trans-unit>
        <trans-unit id="55db381aabae41a989aa28b8f5a435f2f353e7d6" translate="yes" xml:space="preserve">
          <source>On multi-threaded builds on systems that do have per-thread locale operations, this function converts the thread it is running in to use the global locale. This is for code that has not yet or cannot be updated to handle multi-threaded locale operation. As long as only a single thread is so-converted, everything works fine, as all the other threads continue to ignore the global one, so only this thread looks at it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfd993657bc1e027b5466df69e07a3c252bb4a5" translate="yes" xml:space="preserve">
          <source>On newer 64 bit versions of OpenVMS, a process setting now controls if the quoting is needed to preserve the case of command line arguments.</source>
          <target state="translated">В новых 64-битных версиях OpenVMS настройка процесса теперь контролирует,нужна ли кавычка для сохранения аргументов командной строки.</target>
        </trans-unit>
        <trans-unit id="d67a298149fc32636cbc2cf9ffd43cf9447cc565" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt; ) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">В более старых версиях perl отрицательные значения эпохи ( &lt;code&gt;time_t&lt;/code&gt; ), которые официально не поддерживаются стандартами POSIX, не работают в некоторых системах. К ним относятся MacOS (до OSX) и Win32.</target>
        </trans-unit>
        <trans-unit id="ddfc76c9171838788051ad1318da16d035f5b0fe" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt;) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a99aa4e31ced8b38922d7821d5fd751e2740ad" translate="yes" xml:space="preserve">
          <source>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</source>
          <target state="translated">На операционных системах с концепцией тома вторым элементом файла://считается спецификация тома для файла.Таким образом,на Win32 эта рутина возвращает том,на других операционных системах-ничего.</target>
        </trans-unit>
        <trans-unit id="4f2532376ddc057f764de9bec478db299bbe8f82" translate="yes" xml:space="preserve">
          <source>On perl version 5.12.0 and newer, negative epoch values are fully supported.</source>
          <target state="translated">На perl версии 5.12.0 и выше отрицательные значения эпохи полностью поддерживаются.</target>
        </trans-unit>
        <trans-unit id="134a9f11ec0d2ae5a78490a1f61d61a762f1fd76" translate="yes" xml:space="preserve">
          <source>On perl versions older than 5.12.0, the range of dates that can be actually be handled depends on the size of &lt;code&gt;time_t&lt;/code&gt; (usually a signed integer) on the given platform. Currently, this is 32 bits for most systems, yielding an approximate range from Dec 1901 to Jan 2038.</source>
          <target state="translated">В версиях Perl старше 5.12.0 диапазон дат, которые могут быть фактически обработаны, зависит от размера &lt;code&gt;time_t&lt;/code&gt; (обычно целого числа со знаком) на данной платформе. В настоящее время для большинства систем это 32 бита, что дает приблизительный диапазон с декабря 1901 года по январь 2038 года.</target>
        </trans-unit>
        <trans-unit id="6022d860b9d735662ef67778672104ce7f7a553c" translate="yes" xml:space="preserve">
          <source>On platforms where &lt;code&gt;need_prelink()&lt;/code&gt; returns true, &lt;code&gt;prelink()&lt;/code&gt; will be called automatically.</source>
          <target state="translated">На платформах, где &lt;code&gt;need_prelink()&lt;/code&gt; возвращает true, &lt;code&gt;prelink()&lt;/code&gt; будет вызываться автоматически.</target>
        </trans-unit>
        <trans-unit id="d4f25eb75f8ca9d9043202ca7699535809aaaa12" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">На платформах, где это важно, обязательно вызывайте &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; для дескрипторов, которые вы передаете функциям Storable.</target>
        </trans-unit>
        <trans-unit id="393fb98f717dd89ac6a03e530e4afbcbe5a39830" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;binmode()&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741623a3d6fbed74253acab5fef8f32b395ea643" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt; . Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly.</source>
          <target state="translated">В компиляторах до C99 &lt;code&gt;bool&lt;/code&gt; определяется как эквивалент &lt;code&gt;char&lt;/code&gt; . Следовательно, присвоение &lt;code&gt;bool&lt;/code&gt; типу любого большего размера небезопасно и может быть усечено. &lt;code&gt;cBOOL&lt;/code&gt; макрос существует правильно брось.</target>
        </trans-unit>
        <trans-unit id="96fc20ca3129c68549ac1ab95e6fa005be780a85" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt;. Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly; you may also find that using it is shorter and clearer than writing out the equivalent conditional expression longhand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c58ed64b6e077e0a2ecc28338446ee744bcc90f" translate="yes" xml:space="preserve">
          <source>On rare occasion, such as a database read, you may be given encoded text you need to decode.</source>
          <target state="translated">В редких случаях,например,при чтении базы данных,вам может быть предоставлен закодированный текст,который необходимо декодировать.</target>
        </trans-unit>
        <trans-unit id="b2d3547ac3050c26cb1992ceb42fa15fd067f32b" translate="yes" xml:space="preserve">
          <source>On return, the reference will overwrite the hash slot in the symbol table specified by the *some_hash typeglob. This is a somewhat tricky way of passing around references cheaply when you don't want to have to remember to dereference variables explicitly.</source>
          <target state="translated">При возврате ссылка перезапишет хэш-слот в таблице символов,заданной типографским шрифтом *some_hash.Это несколько хитрый способ дешевой передачи ссылок,когда не нужно явно запоминать разыменование переменных.</target>
        </trans-unit>
        <trans-unit id="aca1e4ba9558a35891aca8fc5a87a5dbef0654bd" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative look-ahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;a&lt;/code&gt; s.</source>
          <target state="translated">В простых группах, таких как шаблон &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; , Сопоставимый эффект может быть достигнут с помощью отрицательного просмотра вперед, как в &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; . Это было всего в 4 раза медленнее для строки с 1000000 &lt;code&gt;a&lt;/code&gt; с.</target>
        </trans-unit>
        <trans-unit id="85475d75a07389a71a82f474a6904ca008087309" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative lookahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;&quot;a&quot;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e1720394957ce5ba2b00bf5b14ca83e7b1f8cb" translate="yes" xml:space="preserve">
          <source>On some (but not all) operating systems assigning to &lt;code&gt;$0&lt;/code&gt; modifies the argument area that the &lt;code&gt;ps&lt;/code&gt; program sees. On some platforms you may have to use special &lt;code&gt;ps&lt;/code&gt; options or a different &lt;code&gt;ps&lt;/code&gt; to see the changes. Modifying the &lt;code&gt;$0&lt;/code&gt; is more useful as a way of indicating the current program state than it is for hiding the program you're running.</source>
          <target state="translated">В некоторых (но не во всех) операционных системах присвоение &lt;code&gt;$0&lt;/code&gt; изменяет область аргументов, которую видит программа &lt;code&gt;ps&lt;/code&gt; . На некоторых платформах вам, возможно, придется использовать специальные параметры &lt;code&gt;ps&lt;/code&gt; или другой &lt;code&gt;ps&lt;/code&gt; , чтобы увидеть изменения. Изменение &lt;code&gt;$0&lt;/code&gt; более полезно для указания текущего состояния программы, чем для сокрытия выполняемой программы.</target>
        </trans-unit>
        <trans-unit id="84e7fe0a4e81ece19af2adc12a430c2ffe84e1ae" translate="yes" xml:space="preserve">
          <source>On some OS's where . has special meaning VERSION_SYM may be used in place of VERSION.</source>
          <target state="translated">На некоторых ОС,где.имеет специальное значение,вместо VERSION может использоваться VERSION_SYM.</target>
        </trans-unit>
        <trans-unit id="a3f9bf6c90ba9706d9e17b2321836d771bd8fd28" translate="yes" xml:space="preserve">
          <source>On some Unixes, &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;a href=&quot;#read-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; would block. This can be avoided if you always use &lt;code&gt;O_NONBLOCK&lt;/code&gt; on the socket. See &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; and &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae6ee7e119fbc5f2aa2be859ce356e5505eb961" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">В некоторых Unix-системах select (2) может сообщать о дескрипторе файла сокета как о &amp;laquo;готовом к чтению&amp;raquo;, даже если данные недоступны, и, таким образом, любое последующее &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; будет блокироваться. Этого можно избежать, если всегда использовать O_NONBLOCK для сокета. Смотрите select (2) и fcntl (2) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c9de2fe586a63b0f77cf89fdbb109c06623eb1f4" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">В некоторых Unix-системах select (2) может сообщать о дескрипторе файла сокета как о &amp;laquo;готовом к чтению&amp;raquo;, даже если данные недоступны, и, таким образом, любое последующее &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; будет блокироваться. Этого можно избежать, если всегда использовать O_NONBLOCK для сокета. Смотрите select (2) и fcntl (2) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="a5313472f5f477e89baab3e33db4f6dd3bf9c900" translate="yes" xml:space="preserve">
          <source>On some older low-end devices -- think early 2.2 era -- some tests, particularly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae4b16cd5d25f3c3c80ae711072c40499b4bc55" translate="yes" xml:space="preserve">
          <source>On some older systems, it may sleep up to a full second less than what you requested, depending on how it counts seconds. Most modern systems always sleep the full amount. They may appear to sleep longer than that, however, because your process might not be scheduled right away in a busy multitasking system.</source>
          <target state="translated">На некоторых старых системах,он может спать до полной секунды меньше,чем вы просили,в зависимости от того,как он считает секунды.Большинство современных систем всегда спят полную сумму.Они могут показаться,чтобы спать дольше,чем это,однако,потому что ваш процесс может не быть запланирован сразу же в занятой многозадачности системы.</target>
        </trans-unit>
        <trans-unit id="558bd651fa8715821f75a4be7598cfc24234462e" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ed for.</source>
          <target state="translated">В некоторых операционных системах определенные обработчики сигналов должны &amp;laquo;что-то делать&amp;raquo; перед возвратом. Одним из примеров может быть CHLD или CLD, что указывает на завершение дочернего процесса. В некоторых операционных системах ожидается, что обработчик сигналов будет &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; завершения дочернего процесса. В таких системах схема отложенного сигнала не будет работать для этих сигналов: она не выполняет &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Опять же, сбой будет выглядеть как цикл, поскольку операционная система повторно отправит сигнал, потому что есть завершенные дочерние процессы, которые еще не &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4baadfb850b3b420c9f511f27da50a1880c9c102" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;wait&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;wait&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;wait&lt;/code&gt;ed for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b286c0e46361b954aaba8f772a4a53334de3bd4e" translate="yes" xml:space="preserve">
          <source>On some operating systems such as Win32 installation may not be possible until after a reboot has occurred. This can have varying consequences: removing an old DLL does not impact programs using the new one, but if a new DLL cannot be installed properly until reboot then anything depending on it must wait. The package variable</source>
          <target state="translated">На некоторых операционных системах,таких как Win32,установка может быть невозможна до тех пор,пока не произойдет перезагрузка.Это может иметь различные последствия:удаление старых DLL не влияет на программы,использующие новую,но если новая DLL не может быть установлена должным образом до перезагрузки,то все,что зависит от нее,должно подождать.Переменная пакета</target>
        </trans-unit>
        <trans-unit id="abbe82684e199993d30da7c411dda78b8ffa5204" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">В некоторых операционных системах, особенно Solaris и Unixware, вызов &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; из дочернего процесса сбрасывает и закрывает открытые дескрипторы файлов в родительском процессе, тем самым повреждая дескрипторы файлов. В этих системах вместо этого предлагается вызвать &lt;code&gt;_exit()&lt;/code&gt; . &lt;code&gt;_exit()&lt;/code&gt; доступен в Perl через модуль &lt;code&gt;POSIX&lt;/code&gt; . Пожалуйста, обратитесь к руководству вашей системы для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="78cb1737975a62fce19002f1001d673ccd249508" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;exit()&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e360f8c5bbe5608f4331396810f247c8a100f0a1" translate="yes" xml:space="preserve">
          <source>On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want. You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (for example, &lt;code&gt;;&lt;/code&gt; on many Unix shells and &lt;code&gt;&amp;amp;&lt;/code&gt; on the Windows NT &lt;code&gt;cmd&lt;/code&gt; shell).</source>
          <target state="translated">На некоторых платформах (особенно подобных DOS) оболочка может быть не способна работать с многострочными командами, поэтому добавление новой строки в строку может не дать вам того, что вы хотите. Вы можете быть в состоянии оценить несколько команд в одной строке, разделив их символом команды сепаратором, если ваша оболочка поддерживает , что (например, &lt;code&gt;;&lt;/code&gt; на многих оболочках Unix и &lt;code&gt;&amp;amp;&lt;/code&gt; на Windows NT &lt;code&gt;cmd&lt;/code&gt; оболочки).</target>
        </trans-unit>
        <trans-unit id="b7498bd2534b138ca9192ebcb30213ef70ed5c94" translate="yes" xml:space="preserve">
          <source>On some platforms Perl supports retrieving the C level backtrace (similar to what symbolic debuggers like gdb do).</source>
          <target state="translated">На некоторых платформах Perl поддерживает получение обратной связи на уровне C (аналогично тому,как это делают такие отладчики,как gdb).</target>
        </trans-unit>
        <trans-unit id="f4483b458e9a6174b9a55320be46bd1995517e00" translate="yes" xml:space="preserve">
          <source>On some platforms inode numbers are of a type larger than perl knows how to handle as integer numerical values. If necessary, an inode number will be returned as a decimal string in order to preserve the entire value. If used in a numeric context, this will be converted to a floating-point numerical value, with rounding, a fate that is best avoided. Therefore, you should prefer to compare inode numbers using &lt;code&gt;eq&lt;/code&gt; rather than &lt;code&gt;==&lt;/code&gt;. &lt;code&gt;eq&lt;/code&gt; will work fine on inode numbers that are represented numerically, as well as those represented as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c255f8c4da0102268758efe747d09a122b8f3a63" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e0966de849860f2089841e81ee24c757771be3" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">На некоторых платформах,таких как Windows,где системный вызов fork()недоступен,Perl может быть собран для эмуляции fork()на уровне интерпретатора.Эта эмуляция имеет ограничения,связанные с убийством,которые должны быть рассмотрены,для кода,работающего под Windows и в коде,предназначенном для переноса.</target>
        </trans-unit>
        <trans-unit id="4dca8272040520711e1d36a027c5a86ea7b32ae2" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. While the emulation is designed to be as compatible as possible with the real fork() at the level of the Perl program, there are certain important differences that stem from the fact that all the pseudo child &quot;processes&quot; created this way live in the same real process as far as the operating system is concerned.</source>
          <target state="translated">На некоторых платформах,таких как Windows,где системный вызов fork()недоступен,Perl может быть собран для эмуляции fork()на уровне интерпретатора.Хотя эмуляция спроектирована так,чтобы быть максимально совместимой с реальной fork()на уровне программы на Perl,существуют некоторые важные различия,связанные с тем,что все псевдоподобные &quot;процессы&quot;,созданные таким образом,живут в одном и том же реальном процессе,что и операционная система.</target>
        </trans-unit>
        <trans-unit id="acf7877caa8abc5986e73b196ee16707d5ded84d" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt;. However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a78bf511c92cd39ee02c1151b5e571d5127a45" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">На некоторых платформах, таких как Windows, где системный вызов fork () недоступен, Perl может быть построен для эмуляции fork () в интерпретаторе Perl. Эмуляция разработана на уровне программы Perl, чтобы быть максимально совместимой с &quot;Unix&quot; fork (). Однако у него есть ограничения, которые необходимо учитывать в коде, предназначенном для переносимости. Смотрите &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="27073e810409a02dd0f24c371c3bfbfa303200d5" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">На некоторых платформах, таких как Windows, где системный вызов fork () недоступен, Perl может быть построен для эмуляции fork () в интерпретаторе Perl. Эмуляция разработана на уровне программы Perl, чтобы быть максимально совместимой с &quot;Unix&quot; fork (). Однако у него есть ограничения, которые необходимо учитывать в коде, предназначенном для переносимости. Смотрите &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8ed99749e4754bfa5b0b973c5aff98a5ab4786e4" translate="yes" xml:space="preserve">
          <source>On some platforms the thread-safe library interfaces may fail if the result buffer is too small (for example the user group databases may be rather large, and the reentrant interfaces may have to carry around a full snapshot of those databases). Perl will start with a small buffer, but keep retrying and growing the result buffer until the result fits. If this limitless growing sounds bad for security or memory consumption reasons you can recompile Perl with &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; defined to the maximum number of bytes you will allow.</source>
          <target state="translated">На некоторых платформах интерфейсы потоковобезопасных библиотек могут дать сбой, если буфер результатов слишком мал (например, базы данных групп пользователей могут быть довольно большими, а повторно входимые интерфейсы могут иметь полный снимок этих баз данных). Perl начнет с небольшого буфера, но продолжайте повторять попытки и увеличивать буфер результата, пока результат не будет соответствовать. Если этот безграничный рост звучит плохо по соображениям безопасности или потребления памяти, вы можете перекомпилировать Perl с &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; , определенным на максимальное количество байтов, которое вы позволите.</target>
        </trans-unit>
        <trans-unit id="24484214c7713626df068fed1666abc55fb655de" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;&quot;savesharedpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a433ae6e8abc1654ff92b55b4f90deb9b64777" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На некоторых платформах, например Windows, вся выделенная память, принадлежащая потоку, освобождается при завершении этого потока. Поэтому, если вам нужно, чтобы этого не происходило, вам нужно использовать функции общей памяти, такие как &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0080de19b8b9cfd716de6770d48e6fe48699a889" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;&quot;savesharedpvn&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5fee577d9d0e5cea7ff481ecfa7871d14cc642" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На некоторых платформах, например Windows, вся выделенная память, принадлежащая потоку, освобождается при завершении этого потока. Поэтому, если вам нужно, чтобы этого не происходило, вам нужно использовать функции общей памяти, такие как &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4da91ee61a2307a1a8d5d2d26b5d850a91c43b4" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;&quot;savesharedsvpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96135c965e974cf2dcbb35a5a0a72331dbb017cf" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На некоторых платформах, например Windows, вся выделенная память, принадлежащая потоку, освобождается при завершении этого потока. Поэтому, если вам нужно, чтобы этого не происходило, вам нужно использовать функции общей памяти, такие как &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a47d30d42c677c2e62622d2c25ff6400601837c5" translate="yes" xml:space="preserve">
          <source>On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).</source>
          <target state="translated">На некоторых платформах,например Windows NT,невозможно разблокировать открытый файл (сначала файл должен быть закрыт).На этих платформах фактическое развязывание откладывается до окончания работы программы и возвращения ей хорошего состояния.Проверка все равно выполняется для того,чтобы убедиться,что хэндл файла и имя файла указывают на одно и то же (но не в момент выполнения конечного блока,т.к.отложенное удаление может не иметь доступа к хэндлу файла).</target>
        </trans-unit>
        <trans-unit id="9e21af4bec3442feba775d62193829f8b7a0c4e5" translate="yes" xml:space="preserve">
          <source>On some platforms, it might not be possible to destroy</source>
          <target state="translated">На некоторых платформах,возможно,не удастся уничтожить</target>
        </trans-unit>
        <trans-unit id="5fad4eee060ffd46b78c54eef932b8d7ced75bff" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;a href=&quot;#-Dletters&quot;&gt;-Dp&lt;/a&gt; switch to Perl shows how the search progresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b340b3bd6640d116c671c5bca7f5a658b943c207" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;b&gt;-Dp&lt;/b&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">На некоторых платформах это также заставляет Perl добавлять суффиксы к имени файла при его поиске. Например, на платформах Win32 суффиксы &amp;laquo;.bat&amp;raquo; и &amp;laquo;.cmd&amp;raquo; добавляются, если поиск исходного имени завершается неудачно, и если имя еще не оканчивается одним из этих суффиксов. Если ваш Perl был скомпилирован с &lt;code&gt;DEBUGGING&lt;/code&gt; , использование переключателя &lt;b&gt;-Dp&lt;/b&gt; на Perl показывает, как продвигается поиск.</target>
        </trans-unit>
        <trans-unit id="680d4319c3ebb1bf0096b308bc1e22323b5e0529" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74540fb7a91002e20c8eda026f9bf8b28624a25" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) binmode() is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">На некоторых системах (в общем,системах на базе DOS и Windows)функция binmode()необходима,когда вы не работаете с текстовым файлом.Ради переносимости всегда полезно использовать его,когда это уместно,и никогда не использовать его,когда это не уместно.Также,люди могут устанавливать свои входы/выходы по умолчанию в кодировке UTF8 Unicode,а не в байтах.</target>
        </trans-unit>
        <trans-unit id="dfca44fbb2c1ebee7c90ad249ff37ac61a808901" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with &lt;code&gt;new_from_fd&lt;/code&gt;, or created with &lt;a href=&quot;IO::Socket#accept&quot;&gt;&quot;accept&quot; in IO::Socket&lt;/a&gt; from such an object, the &lt;a href=&quot;IO::Socket#protocol&quot;&gt;&quot;protocol&quot; in IO::Socket&lt;/a&gt;, &lt;a href=&quot;IO::Socket#sockdomain&quot;&gt;&quot;sockdomain&quot; in IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Socket#socktype&quot;&gt;&quot;socktype&quot; in IO::Socket&lt;/a&gt; methods may return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae1ed91e60744c25391f2c5a28e8865cb837e1c" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with new_from_fd(), or created with accept() from such an object, the protocol(), sockdomain() and socktype() methods may return undef.</source>
          <target state="translated">На некоторых системах для объекта IO::Socket,созданного с помощью new_from_fd(),или созданного с помощью accept()из такого объекта,методы protocol(),sockdomain()и socktype()могут возвращать undef.</target>
        </trans-unit>
        <trans-unit id="5cb77e1072ab2963baa8f6d218988c1f72414bff" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;code&gt;strftime()&lt;/code&gt; function has been extended in a non-standard way to use a &lt;code&gt;%C&lt;/code&gt; format, which they sometimes claim is the &quot;century&quot;. It isn't, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to determine reliably the current century or millennium.</source>
          <target state="translated">В некоторых системах функция &lt;code&gt;strftime()&lt;/code&gt; модуля &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; была расширена нестандартным способом для использования формата &lt;code&gt;%C&lt;/code&gt; , который они иногда называют &amp;laquo;веком&amp;raquo;. Это не так, потому что в большинстве таких систем это только первые две цифры четырехзначного года, и поэтому они не могут использоваться для надежного определения текущего столетия или тысячелетия.</target>
        </trans-unit>
        <trans-unit id="9a2307b9852232321e1093b21cd83d1ba46b51a6" translate="yes" xml:space="preserve">
          <source>On some systems, there can be cooperative and preemptive threads running simultaneously. (Threads running with realtime priorities often behave cooperatively, for example, while threads running at normal priorities behave preemptively.)</source>
          <target state="translated">На некоторых системах могут одновременно работать кооперативные и упреждающие потоки.(Потоки,работающие с приоритетами реального времени,часто ведут себя совместно,например,в то время как потоки,работающие с нормальными приоритетами,ведут себя упреждающе).</target>
        </trans-unit>
        <trans-unit id="14dcaed53f17e703b8cfce8077083c7079226d84" translate="yes" xml:space="preserve">
          <source>On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">На некоторых системах,возможно,придется менять одиночные кавычки на двойные,что необходимо</target>
        </trans-unit>
        <trans-unit id="a73b71b53a0ef6fd5b9c990fee1a5a53d7f99a60" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 3 elements is returned. The elements are:</source>
          <target state="translated">При успешной работе в контексте списка возвращается массив из 3 элементов.Элементы являются:</target>
        </trans-unit>
        <trans-unit id="104cbe85a4799563175bc8875552e7ec3d9444ff" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 6 elements is returned. The elements are:</source>
          <target state="translated">При успешной работе в контексте списка возвращается массив из 6 элементов.Элементы являются:</target>
        </trans-unit>
        <trans-unit id="f87025d22f7460aebebdbcf7b85259c2cc5a7d3a" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb19677ff47ab7a0061dc31fa21208b0fdd0ce0e" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">В случае успеха $ decoder - это объект, который задокументирован в &lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding&lt;/a&gt; . Итак, теперь вы можете это сделать;</target>
        </trans-unit>
        <trans-unit id="9ed1d2d6abe6133cffe9d52759b8403cf251f405" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; returns the</source>
          <target state="translated">В случае успеха автоумирающая форма &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="1e391581d76d0c24968f00549dd5c8fda5e3d997" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;system&lt;/code&gt; returns the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555bab907001ef6e8e0bb6e66b34e7245218e3f9" translate="yes" xml:space="preserve">
          <source>On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.</source>
          <target state="translated">На системах,не поддерживающих уровни безопасности HIGH или MEDIUM (например,Win NT или OS/2),любая попытка изменить уровень будет проигнорирована.Решение игнорировать,а не поднимать уровень исключений,позволяет писать портативные программы с высокой степенью безопасности для систем,которые могут это поддерживать,без тех программ,которые выходят из строя в системах,где дополнительные тесты не имеют отношения к делу.</target>
        </trans-unit>
        <trans-unit id="0c0c64b8ddf70f7334be3908bef0a4e5be9026f3" translate="yes" xml:space="preserve">
          <source>On systems that don't have locales, this pragma will cause your operations to behave as if in the &quot;C&quot; locale; attempts to change the locale will fail.</source>
          <target state="translated">На системах,не имеющих локалей,эта прагма приведет к тому,что ваши операции будут вести себя так,как будто в &quot;C&quot; локали;попытки изменить локаль будут безуспешными.</target>
        </trans-unit>
        <trans-unit id="8a74a95b0c966e10aac8d77a4f0a3bf544781a21" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the $base filename. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">В системах с грамматикой,которая указывает имена файлов,это игнорирует $base имя файла.В противном случае все компоненты пути считаются каталогами.</target>
        </trans-unit>
        <trans-unit id="1b51da93b22332f93d96c5b573c9ad75ab82f7bf" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the &lt;code&gt;$base&lt;/code&gt; filename as well. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">В системах, в которых есть грамматика, указывающая имена файлов, это также игнорирует имя файла &lt;code&gt;$base&lt;/code&gt; . В противном случае предполагается, что все компоненты пути являются каталогами.</target>
        </trans-unit>
        <trans-unit id="901b07c2e1b3c74e80e092e6a7bf36ca0bfb33ee" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, you may pass a filehandle or directory handle as the argument. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, passing handles raises an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04beca51e696b3f570d383d77ccd733902d428c1" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ad9738faaa35969ac19d2d964d2e11949f987b" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7ce7f23ab496e21c30f598c258278a01062849" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1d6ffed6769b46e37f0d82df8acb444f49f35b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt;s are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5314c4a5a0cc48c834a98edadeb967581bfc1cbf" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">В системах , которые поддерживают флаг крупным по-Exec на файлах, этот флаг устанавливается на всех вновь открытых файловых дескрипторов , чьи &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s являются</target>
        </trans-unit>
        <trans-unit id="be056ae4f4d92fcc824ea5af426faa5948d961c7" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">В системах , которые поддерживают флаг крупным по-Exec на файлах, этот флаг устанавливается на всех вновь открытых файловых дескрипторов , чьи &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s являются</target>
        </trans-unit>
        <trans-unit id="11350e333ae0f2472a99aa4945fb651bbd8808b9" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcf7eb3896f4c5961c6c4a30af97fd660da9d5d" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах , которые поддерживают тесную-на-Exec флаг на файлах, флаг будет установлен для вновь открытого дескриптора файла , как определено значением &lt;code&gt;$^F&lt;/code&gt; . Смотрите &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c665037f5c6992c82bd182869050b43d00b7e424" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах , которые поддерживают тесную-на-Exec флаг на файлах, флаг будет установлен для вновь открытого дескриптора файла , как определено значением &lt;code&gt;$^F&lt;/code&gt; . Смотрите &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a490a64d93357b4e803f1bde203444d3253ea771" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытого файлового дескриптора, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8889b4502c97331fb6c0d71d79b94f89a2ce179" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытого файлового дескриптора, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a9abf94cd4611a410ac6fca9a398911a42fa5c0" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901c01459d3ad6fdd533264983a881490e329c6b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытых файловых дескрипторов, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4b0eeffda71eae98ca0b23d4d9a435052a31c58" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">В системах, которые поддерживают для файлов флаг закрытия при запуске, этот флаг будет установлен для вновь открытых файловых дескрипторов, что определяется значением $ ^ F. Смотрите &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc9058ec5b96236598bf0d8742f7fe61dd91e63f" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c803cb6cc476af479d34a3bc1112251dd81782" translate="yes" xml:space="preserve">
          <source>On systems that support a real &lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock(2)&lt;/a&gt;, locks are inherited across &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; calls, whereas those that must resort to the more capricious &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; function lose their locks, making it seriously harder to write servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0bcb70dd655374823428e8ecf318b875be23f0d" translate="yes" xml:space="preserve">
          <source>On systems that support a real flock(2), locks are inherited across fork() calls, whereas those that must resort to the more capricious fcntl(2) function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">На системах,которые поддерживают реальный флок(2),блокировки наследуются через вызовы fork(),в то время как те,кто должен прибегнуть к более капризной функции fcntl(2),теряют свои блокировки,что значительно усложняет запись серверов.</target>
        </trans-unit>
        <trans-unit id="92426fd5bb12f295ba78cf2e855950f52eab1f1b" translate="yes" xml:space="preserve">
          <source>On systems that support fchdir(2), you may pass a filehandle or directory handle as the argument. On systems that don't support fchdir(2), passing handles raises an exception.</source>
          <target state="translated">На системах,поддерживающих fchdir(2),вы можете передать в качестве аргумента дескриптор файла или дескриптор каталога.На системах,которые не поддерживают fchdir(2),передача дескрипторов вызывает исключение.</target>
        </trans-unit>
        <trans-unit id="92172c92aed2c4eacbbf108b43a01fa41c1e7227" translate="yes" xml:space="preserve">
          <source>On systems that support fchmod(2), you may pass filehandles among the files. On systems that don't support fchmod(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">На системах,поддерживающих fchmod(2),вы можете передавать файловые дескрипторы между файлами.На системах,не поддерживающих fchmod(2),передача файловых дескрипторов вызывает исключение.Файловые дескрипторы должны передаваться в виде глобусов или глобусных ссылок,чтобы их можно было распознать;пустые слова считаются именами файлов.</target>
        </trans-unit>
        <trans-unit id="dc52e8f7e1c0866f647ccf5e1cd248ecabff8b5f" translate="yes" xml:space="preserve">
          <source>On systems that support fchown(2), you may pass filehandles among the files. On systems that don't support fchown(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">На системах,поддерживающих fchown(2),вы можете передавать файловые дескрипторы между файлами.На системах,которые не поддерживают fchown(2),передача файловых дескрипторов вызывает исключение.Для распознавания файловые дескрипторы должны передаваться в виде глобусов или глобусных ссылок;пустые слова считаются именами файлов.</target>
        </trans-unit>
        <trans-unit id="9d32f7bede11ac1c00998cc26b587f02c25e363b" translate="yes" xml:space="preserve">
          <source>On systems that support futimes(2), you may pass filehandles among the files. On systems that don't support futimes(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">На системах,поддерживающих futimes(2),можно передавать файловые дескрипторы между файлами.На системах,которые не поддерживают futimes(2),передача файловых дескрипторов вызывает исключение.Файловые дескрипторы должны передаваться в виде глобусов или глобусных ссылок,чтобы их можно было распознать;пустые слова считаются именами файлов.</target>
        </trans-unit>
        <trans-unit id="c71329e94ef821ac647632fa2fb53326dd2a9466" translate="yes" xml:space="preserve">
          <source>On systems that supported it, older versions of Perl used the SA_RESTART flag when installing %SIG handlers. This meant that restartable system calls would continue rather than returning when a signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0 and later do</source>
          <target state="translated">На системах,которые его поддерживали,старые версии Perl использовали флаг SA_RESTART при установке обработчиков %SIG.Это означало,что перезагрузка системных вызовов будет продолжаться,а не возвращаться при поступлении сигнала.Для того,чтобы доставить отложенные сигналы быстро,Perl 5.8.0 и более поздние версии делают следующее</target>
        </trans-unit>
        <trans-unit id="6ba77bd32e9b25ffdeddd2abe71a6e9ea02320ab" translate="yes" xml:space="preserve">
          <source>On systems traditionally bereft of a usable &lt;b&gt;man&lt;/b&gt; command, the debugger invokes &lt;b&gt;perldoc&lt;/b&gt;. Occasionally this determination is incorrect due to recalcitrant vendors or rather more felicitously, to enterprising users. If you fall into either category, just manually set the $DB::doccmd variable to whatever viewer to view the Perl documentation on your system. This may be set in an rc file, or through direct assignment. We're still waiting for a working example of something along the lines of:</source>
          <target state="translated">В системах, традиционно лишенных &lt;b&gt;доступной&lt;/b&gt; для использования команды &lt;b&gt;man&lt;/b&gt; , отладчик вызывает &lt;b&gt;perldoc&lt;/b&gt; . Иногда это определение оказывается неверным из-за непокорности продавцов или, что более удачно, из-за предприимчивых пользователей. Если вы попадаете в любую категорию, просто вручную установите переменную $ DB :: doccmd для любого средства просмотра, чтобы просмотреть документацию Perl в вашей системе. Это может быть установлено в файле rc или путем прямого назначения. Мы все еще ждем рабочего примера чего-то вроде:</target>
        </trans-unit>
        <trans-unit id="495743307752ec1e7f711d11bd0bef034af0b675" translate="yes" xml:space="preserve">
          <source>On systems which do support negative epoch values, this module should be able to cope with dates before the start of the epoch, down the minimum value of time_t for the system.</source>
          <target state="translated">В системах,которые поддерживают отрицательные значения эпох,этот модуль должен уметь справляться с датами до начала эпохи,вниз по минимальному значению time_t для системы.</target>
        </trans-unit>
        <trans-unit id="46c423b9491070d51507de37df7f4e753a419998" translate="yes" xml:space="preserve">
          <source>On systems with restrictions on file name length, the file corresponding to a subroutine may have a shorter name that the routine itself. This can lead to conflicting file names. The</source>
          <target state="translated">В системах с ограничениями по длине имени файла,файл,соответствующий подпрограмме,может иметь более короткое имя,чем сама подпрограмма.Это может привести к конфликтующим именам файлов..</target>
        </trans-unit>
        <trans-unit id="fec43c22ce98f30270ab97bbbb4fe9d6075857b3" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a &lt;a href=&quot;file://&quot;&gt;file:////&lt;/a&gt; url. On other operating systems returns empty.</source>
          <target state="translated">В системах с концепцией &lt;a href=&quot;file://&quot;&gt;общего&lt;/a&gt; сетевого ресурса (в настоящее время только Windows) возвращает общее имя из файла: //// url. В других операционных системах возвращается пустым.</target>
        </trans-unit>
        <trans-unit id="8a4f2ea2521e9d2bed452fc1750b2f44d1e70008" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a file://// url. On other operating systems returns empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928cc7ef7cb478fdbb60e26c8543bd66bba1f884" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt; . Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt; , which resulted in garbage results part of the time.</source>
          <target state="translated">В системах с концепцией тома, если &lt;code&gt;$path&lt;/code&gt; и &lt;code&gt;$base&lt;/code&gt; находятся на двух разных томах, мы не будем пытаться разрешить два пути, а вместо этого просто вернем &lt;code&gt;$path&lt;/code&gt; . Обратите внимание, что предыдущие версии этого модуля игнорировали объем &lt;code&gt;$base&lt;/code&gt; , что в некоторых случаях приводило к получению мусора.</target>
        </trans-unit>
        <trans-unit id="7d73de0a58277977e444ac1cca08eacb14a895ab" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt;. Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt;, which resulted in garbage results part of the time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3890814a89a9eb1b787653006ab22422f5ccc270" translate="yes" xml:space="preserve">
          <source>On systems without locale support, or on typical single-threaded builds, or on platforms that do not support per-thread locale operations, this function does nothing. On such systems that do have locale support, only a locale global to the whole program is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b62c831c8eef6cc7d4b1d7cdb6bf880f9b84f3" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt; ) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">В текстовых полях каретка включает своего рода режим заполнения. Вместо произвольного выражения передаваемое значение должно быть скалярной переменной, содержащей текстовую строку. Perl помещает следующую часть текста в поле, а затем обрезает переднюю часть строки, чтобы при следующей ссылке на переменную можно было напечатать больше текста. (Да, это означает, что сама переменная изменяется во время выполнения вызова write () и не восстанавливается.) Следующая часть текста определяется грубым алгоритмом разрыва строки. Вы можете использовать символ возврата каретки ( &lt;code&gt;\r&lt;/code&gt; ) для принудительного разрыва строки. Вы можете изменить допустимые символы для разбиения, изменив переменную &lt;code&gt;$:&lt;/code&gt; (это $ FORMAT_LINE_BREAK_CHARACTERS, если вы используете английский модуль) к списку нужных символов.</target>
        </trans-unit>
        <trans-unit id="c85b198c2a1ea3057ddf98fa6e2eafccce107220" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt;) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0193cc78fe98d1b4b454c6f69412908ead97760" translate="yes" xml:space="preserve">
          <source>On the AS/400, if PERL5 is in your library list, you may need to wrap your Perl scripts in a CL procedure to invoke them like so:</source>
          <target state="translated">В AS/400,если PERL5 находится в списке вашей библиотеки,вам может понадобиться завернуть ваши Perl скрипты в процедуру CL,чтобы вызвать их таким образом:</target>
        </trans-unit>
        <trans-unit id="16a3b552e4784bd03ff647bc0e4cf0bd441e7074" translate="yes" xml:space="preserve">
          <source>On the DSM management page start the Control Panel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124c561154829ad2caaa2d7dfa3f126afe450312" translate="yes" xml:space="preserve">
          <source>On the flip side, don't be tempted to prematurely declare a test incorrect just because you're having trouble finding the bug. Invalidating a test isn't something to be taken lightly, and don't use it as a cop out to avoid work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea65f5f2a1cec2b70340514d27743f128cc959b6" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt; .</source>
          <target state="translated">В данной программе, идентифицированной по &lt;code&gt;program_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12dc585208a0e91c8b1cc0d400c475b21cd97b26" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9fcecabc9c2ff5c185e1af9b86fe28cd4ccda1" translate="yes" xml:space="preserve">
          <source>On the mainframe Perl currently works under the &quot;Unix system services for OS/390&quot; (formerly known as OpenEdition), VM/ESA OpenEdition, or the BS200 POSIX-BC system (BS2000 is supported in Perl 5.6 and greater). See &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; for details. Note that for OS/400 there is also a port of Perl 5.8.1/5.10.0 or later to the PASE which is ASCII-based (as opposed to ILE which is EBCDIC-based), see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;.</source>
          <target state="translated">На мэйнфрейме Perl в настоящее время работает под &amp;laquo;системными службами Unix для OS / 390&amp;raquo; (ранее известными как OpenEdition), VM / ESA OpenEdition или системой BS200 POSIX-BC (BS2000 поддерживается в Perl 5.6 и выше). Подробности см. На &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; . Обратите внимание, что для OS / 400 существует также порт Perl 5.8.1 / 5.10.0 или более поздней версии для PASE, основанный на ASCII (в отличие от ILE, основанного на EBCDIC), см. &lt;a href=&quot;perlos400&quot;&gt;Perlos400&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="580309d3af9907826e397d1c3342546e17a8ad3c" translate="yes" xml:space="preserve">
          <source>On the opposite end of the scale, a declaration like</source>
          <target state="translated">На противоположном конце шкалы,декларация вроде</target>
        </trans-unit>
        <trans-unit id="30429117a84b2dd407e0605edcb4b807f19cd366" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want the other meaning, you can do this:</source>
          <target state="translated">С другой стороны,если вы хотите другого значения,вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="fbae3feec67f27fa104cf2845f242f528c54850f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the array element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">С другой стороны, если вы действительно надеялись рассматривать элемент массива как список, вам нужно посмотреть, как работают ссылки, потому что Perl не будет волшебным образом преобразовывать скаляры в списки за вас. См. &lt;a href=&quot;perlref&quot;&gt;Perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce76eb877363ead375654de95e60f5e7b6c574b5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the hash element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">С другой стороны, если вы действительно надеялись рассматривать хэш-элемент как список, вам нужно посмотреть, как работают ссылки, потому что Perl не будет волшебным образом преобразовывать скаляры в списки за вас. См. &lt;a href=&quot;perlref&quot;&gt;Perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="528cd15a9b0aff8a5cdc97823c4262e5cf5bb2ab" translate="yes" xml:space="preserve">
          <source>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.</source>
          <target state="translated">С другой стороны,автоматическое смешивание различных кодировок национальных стандартов работает,если только $data не слишком короток,чтобы можно было угадать.</target>
        </trans-unit>
        <trans-unit id="095e1a5231bfc256caf5b97c9e59036a8cd94e78" translate="yes" xml:space="preserve">
          <source>On the other hand, sometimes you want to clobber whatever might already be there. To empty out a file before you start writing to it, you can open it in write-only mode:</source>
          <target state="translated">С другой стороны,иногда тебе хочется засорить то,что уже может быть там.Чтобы очистить файл перед началом записи в него,вы можете открыть его в режиме только для записи:</target>
        </trans-unit>
        <trans-unit id="94024e45d5031c319fa3ba71f3df1c69292913dd" translate="yes" xml:space="preserve">
          <source>On the other hand:</source>
          <target state="translated">С другой стороны:</target>
        </trans-unit>
        <trans-unit id="f18fa46000a23ad2307a5bee120c399fc4cc324f" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; , and &lt;code&gt;&quot;not&quot;&lt;/code&gt; , which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">Справа от оператора списка запятая имеет очень низкий приоритет, так что она контролирует все найденные там выражения, разделенные запятыми. Единственными операторами с более низким приоритетом являются логические операторы &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; и &lt;code&gt;&quot;not&quot;&lt;/code&gt; , которые могут использоваться для оценки вызовов операторов списка без необходимости использования скобок:</target>
        </trans-unit>
        <trans-unit id="dd64949dc6542722891696f1747da1386b28ed4e" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt;, &lt;code&gt;&quot;or&quot;&lt;/code&gt;, and &lt;code&gt;&quot;not&quot;&lt;/code&gt;, which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c9d06262a8b8894dbad99cc8b7ff5cbcc3e919" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;&lt;/a&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;&quot;Newlines&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b2c5bcb8fba3a9644276ad63b66e732faef04f" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;).</source>
          <target state="translated">На этих платформах имейте в виду, что набор символов EBCDIC может влиять на то, что происходит с некоторыми функциями Perl (такими как &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ), а также на использование битов с Константы ASCII с использованием операторов типа &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;|&lt;/code&gt; , не говоря уже о работе с интерфейсами сокетов для компьютеров ASCII (см. &lt;a href=&quot;#Newlines&quot;&gt;Новые строки&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bf1c918758fe737aef37e1c0ba64400f9f7705ae" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">На тех платформах и компиляторах, где &lt;code&gt;bool&lt;/code&gt; действительно является логическим (C ++, C99), легко забыть приведение. Вы можете заставить &lt;code&gt;bool&lt;/code&gt; быть &lt;code&gt;char&lt;/code&gt; , скомпилировав с &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . Вы также можете запустить &lt;code&gt;Configure&lt;/code&gt; с чем-то вроде</target>
        </trans-unit>
        <trans-unit id="ba599ad520fca93f96bd6d59495057f2e3221a03" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt;. You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750180603d4fade1f60619d413443d4388791bcb" translate="yes" xml:space="preserve">
          <source>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. It will be called with the preconstructed new &lt;code&gt;regexp&lt;/code&gt; structure as an argument, the &lt;code&gt;pprivate&lt;/code&gt; member will point at the &lt;b&gt;old&lt;/b&gt; private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</source>
          <target state="translated">В многопоточных сборках может потребоваться дублирование регулярного выражения, чтобы шаблон можно было использовать в нескольких потоках. Ожидается, что эта процедура будет обрабатывать дублирование любых личных данных, на которые &lt;code&gt;pprivate&lt;/code&gt; член pprivate структуры &lt;code&gt;regexp&lt;/code&gt; . Он будет вызываться с предварительно сконструированной новой структурой &lt;code&gt;regexp&lt;/code&gt; в качестве аргумента, член &lt;code&gt;pprivate&lt;/code&gt; будет указывать на &lt;b&gt;старую&lt;/b&gt; частную структуру, и эта подпрограмма несет ответственность за создание копии и возврат на нее указателя (который Perl затем будет использовать для перезаписи поле, переданное в эту процедуру.)</target>
        </trans-unit>
        <trans-unit id="3f7d01cda50f9d06f5abacea7dcc3dcdce0e0aef" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e92c3a98c94fccb8ba5784670e12e223f435cc2" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called; see &lt;a href=&quot;#WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&lt;/a&gt; for a more contained way to ensure that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ce1f6dab9f2ca8a499735e7d64c50092c9a849" translate="yes" xml:space="preserve">
          <source>On unthreaded builds this field doesn't exist.</source>
          <target state="translated">На непонятных стройках этого поля не существует.</target>
        </trans-unit>
        <trans-unit id="fb3efd91222592d2901cd1f317fee4fadb20e2bc" translate="yes" xml:space="preserve">
          <source>On versions of Perl before 5.26, activating taint mode will also remove the current directory (&quot;.&quot;) from the default value of &lt;code&gt;@INC&lt;/code&gt;. Since version 5.26, the current directory isn't included in &lt;code&gt;@INC&lt;/code&gt; by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf07ba18b50ccd1689ea2941fb77a3117773a24" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt; ) have been called, all further output from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">После &lt;code&gt;test_out&lt;/code&gt; или &lt;code&gt;test_err&lt;/code&gt; (или &lt;code&gt;test_fail&lt;/code&gt; или &lt;code&gt;test_diag&lt;/code&gt; ) весь дальнейший вывод &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; будет захвачен &lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester&lt;/a&gt; . Это означает, что вы не сможете выполнять дальнейшие тесты для нормального вывода обычным способом, пока не &lt;code&gt;test_test&lt;/code&gt; (ну, если вы вручную не вмешиваетесь в дескрипторы выходных файлов)</target>
        </trans-unit>
        <trans-unit id="083880b888c49c9dba31b5a1a1d83eae3051aea8" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt;) have been called, all further output from &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9443afa365a30ff5f37332fa968121f2dbb81425" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;../harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">После &lt;code&gt;test_test&lt;/code&gt; выходные данные теста будут перенаправлены обратно на исходные дескрипторы файлов, к которым был подключен &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; (возможно, STDOUT и STDERR), что означает, что любые последующие тесты, которые вы запускаете, будут работать нормально и вызовут успех / ошибки для &lt;a href=&quot;../harness&quot;&gt;Test :: Harness&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6814624afd4c6e39f83bea80e53ce4d9099ae560" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0908b28a0f268394a7964fa489d2fda27d507a0" translate="yes" xml:space="preserve">
          <source>Once EOF is detected (&lt;code&gt;$status&lt;/code&gt; is zero) the filter will insert an extra line into the source stream. When this extra line is executed it will print a count of the number of substitutions actually made. Note that &lt;code&gt;$status&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in this case.</source>
          <target state="translated">Как только EOF обнаружен ( &lt;code&gt;$status&lt;/code&gt; равен нулю), фильтр вставит дополнительную строку в исходный поток. Когда эта дополнительная строка будет выполнена, она напечатает количество фактически сделанных замен. Обратите внимание, что в этом случае &lt;code&gt;$status&lt;/code&gt; установлен в &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48f0ab6402e0ed10a074d92b2f594ddaae93f903" translate="yes" xml:space="preserve">
          <source>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to $`, part to $&amp;amp;, and part to $'. Thus the penalty is most severe with long strings and patterns that match often. Avoid $&amp;amp;, $', and $` if you can, but if you can't, once you've used them at all, use them at will because you've already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the $&amp;amp; variable is no longer &quot;expensive&quot; the way the other two are.</source>
          <target state="translated">Как только Perl видит, что вам нужна одна из этих переменных в любом месте программы, он предоставляет их при каждом совпадении с образцом. Это означает, что при каждом совпадении с шаблоном вся строка будет скопирована, часть - в $ `, часть - в $ &amp;amp;, а часть - в $ '. Таким образом, штраф наиболее серьезен для длинных строк и часто совпадающих шаблонов. Избегайте $ &amp;amp;, $ 'и $ `, если можете, но если вы не можете, когда вы их вообще использовали, используйте их по своему желанию, потому что вы уже заплатили цену. Помните, что некоторые алгоритмы их действительно ценят. Начиная с версии 5.005, переменная $ &amp;amp; больше не &quot;дорогая&quot;, как две другие.</target>
        </trans-unit>
        <trans-unit id="296ec9cb13f85c2f6eee6c3dfe23452785f51838" translate="yes" xml:space="preserve">
          <source>Once a feature, construct or module has been marked as deprecated, we may remove it from the Perl core. Unsurprisingly, we say we've &lt;b&gt;removed&lt;/b&gt; these things. When a module is removed, it will no longer ship with Perl, but will continue to be available on CPAN.</source>
          <target state="translated">Как только функция, конструкция или модуль помечены как устаревшие, мы можем удалить их из ядра Perl. Неудивительно, что мы говорим, что &lt;b&gt;удалили&lt;/b&gt; эти вещи. После удаления модуля он больше не будет поставляться с Perl, но будет по-прежнему доступен на CPAN.</target>
        </trans-unit>
        <trans-unit id="a0837f9cee9c8dc066f294cad80d931eedcddeed" translate="yes" xml:space="preserve">
          <source>Once a handle is open, its layers can be altered using &lt;code&gt;binmode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7394cfde1fc1b93e93cb9b4f086c54f1b9ffd59b" translate="yes" xml:space="preserve">
          <source>Once a module has been included in the Perl core, however, everyone involved in maintaining Perl should be aware that the module is still the property of the original author unless the original author explicitly gives up their ownership of it. In particular:</source>
          <target state="translated">Однако,как только модуль включен в ядро Perl,все,кто участвует в поддержке Perl,должны знать,что модуль все еще является собственностью оригинального автора,если только оригинальный автор явно не отказывается от своего права собственности на него.В частности:</target>
        </trans-unit>
        <trans-unit id="fb8472b689cb77838766fd3ad6c514d183c9cd46" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395a04379c153d488a5c8556f8b5ec9aaac6c9a5" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">Как только референт был благословлен, &lt;code&gt;blessed&lt;/code&gt; функция из основного модуля &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; может сообщить нам имя своего класса. Эта подпрограмма возвращает класс объекта при передаче объекта и false в противном случае.</target>
        </trans-unit>
        <trans-unit id="591c19dc13259933f77d04158c9b97cb405eddcb" translate="yes" xml:space="preserve">
          <source>Once a thread is detached, it may not be joined, and any return data that it might have produced (if it was done and waiting for a join) is lost.</source>
          <target state="translated">Как только поток отсоединяется,он не может быть присоединен,и любые данные,которые он мог получить (если это было сделано и ожидание присоединения),теряются.</target>
        </trans-unit>
        <trans-unit id="12df76345c558476956303e6bd354373a1af6336" translate="yes" xml:space="preserve">
          <source>Once a todo test starts succeeding, simply move it outside the block. When the block is empty, delete it.</source>
          <target state="translated">Как только тест на тодо начнется успешно,просто переместите его за пределы блока.Когда блок будет пуст,удалите его.</target>
        </trans-unit>
        <trans-unit id="de1c57e84d4335aa8d593dcd913db4541c9be506" translate="yes" xml:space="preserve">
          <source>Once a variable is removed, its use triggers an error telling you the variable is unsupported.</source>
          <target state="translated">Как только переменная удаляется,ее использование вызывает ошибку,говорящую о том,что она не поддерживается.</target>
        </trans-unit>
        <trans-unit id="aeba7900e971ad3f9f9e894e67cc3b717aab109e" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; has done all the work for you. They produce the standard &lt;code&gt;Makefile.PL&lt;/code&gt; you see when you download and install modules, and this produces a Makefile with a &lt;code&gt;dist&lt;/code&gt; target.</source>
          <target state="translated">И снова &lt;code&gt;module-starter&lt;/code&gt; или &lt;code&gt;h2xs&lt;/code&gt; сделали всю работу за вас. Они создают стандартный &lt;code&gt;Makefile.PL&lt;/code&gt; ,который вы видите при загрузке и установке модулей, и это создает Makefile с целью &lt;code&gt;dist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1aff24b00940dd82d1491dbe39c6cb52b648ed" translate="yes" xml:space="preserve">
          <source>Once approved, changes are merged into &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;, the repository which drives &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;, and they are distributed with the next Perl 5 release.</source>
          <target state="translated">После утверждения изменения объединяются в &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt; , репозиторий, который управляет &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; , и распространяются со следующим выпуском Perl 5.</target>
        </trans-unit>
        <trans-unit id="2b54e888aa5f3b1e9daaa58b06235556e830e504" translate="yes" xml:space="preserve">
          <source>Once at the command line, type &lt;code&gt;h&lt;/code&gt; for one-page help screen; the rest should be self-explanatory.</source>
          <target state="translated">В командной строке введите &lt;code&gt;h&lt;/code&gt; , чтобы открыть одностраничный экран справки; остальное не требует пояснений.</target>
        </trans-unit>
        <trans-unit id="480a6fac81e70daea3f924bcfe32eba60a95619a" translate="yes" xml:space="preserve">
          <source>Once called the FILE * should</source>
          <target state="translated">После вызова ФИЛА*должен</target>
        </trans-unit>
        <trans-unit id="fadbaf9125427892864d707c6d22361430d22b8f" translate="yes" xml:space="preserve">
          <source>Once ended, no more items may be placed in the queue.</source>
          <target state="translated">После окончания,больше нельзя ставить предметы в очередь.</target>
        </trans-unit>
        <trans-unit id="6742558d45b013c0f52c3e462293464937a542ee" translate="yes" xml:space="preserve">
          <source>Once installed you may delete the temporary archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14db76a9667a7b9782c3a5e1dfcf95186773ac9a" translate="yes" xml:space="preserve">
          <source>Once it has created those helpers TAP::Harness starts running the tests. For each test it creates a new parser (TAP::Parser) which is responsible for running the test script and parsing its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916fa7b57196ffe55f0094ed9d80bbb62daf5b2c" translate="yes" xml:space="preserve">
          <source>Once mapped, you can treat &lt;code&gt;$string&lt;/code&gt; as you would any other string. Since you don't necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</source>
          <target state="translated">После сопоставления вы можете обращаться с &lt;code&gt;$string&lt;/code&gt; как с любой другой строкой. Поскольку вам не обязательно загружать данные, mmap-процесс может быть очень быстрым и не может увеличить объем памяти.</target>
        </trans-unit>
        <trans-unit id="48df5812892e79e577960bece1b7fde5e79ea047" translate="yes" xml:space="preserve">
          <source>Once miniperl.exe creation is over, run nmake from the NetWare folder. This will build the Perl interpreter for NetWare as</source>
          <target state="translated">После создания miniperl.exe запустите nmake из папки NetWare.Это создаст интерпретатор Perl для NetWare как</target>
        </trans-unit>
        <trans-unit id="b72bd7ffb13635f0115e40bb684ebf6013fb4223" translate="yes" xml:space="preserve">
          <source>Once perl is installed you can read this document in the following way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4f57a7ab5a360e46162416f69b58e4d7acd9a" translate="yes" xml:space="preserve">
          <source>Once picked, it is important to stick to your version scheme, without reducing the number of digits. This is because &quot;downstream&quot; packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.</source>
          <target state="translated">После выбора,важно придерживаться схемы версий,не уменьшая при этом количество цифр.Это происходит потому,что &quot;последующие&quot; упаковщики,такие как система портов FreeBSD,интерпретируют номера версий различными способами.Если вы измените количество цифр в вашей схеме версий,вы можете запутать эти системы,чтобы они вывели из строя версии вашего модуля,что,очевидно,плохо.</target>
        </trans-unit>
        <trans-unit id="07633063ecd66c0146fe9d11656fc4703df1f61f" translate="yes" xml:space="preserve">
          <source>Once produced Makefiles for MacOS Classic</source>
          <target state="translated">Однажды выпущенные Makefiles для MacOS Classic</target>
        </trans-unit>
        <trans-unit id="654d50c5d753e55a4e1dbf0b00907d7f4969d3a9" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre/post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt; .</source>
          <target state="translated">После регистрации нет механизма для отключения этих хуков, поэтому, если это необходимо, вам нужно будет сделать это самостоятельно. Запись в &lt;code&gt;%^H&lt;/code&gt; , вероятно, является лучшим способом, поэтому эффект имеет лексическую область видимости; однако также можно использовать макросы &lt;code&gt;BhkDISABLE&lt;/code&gt; и &lt;code&gt;BhkENABLE&lt;/code&gt; для временного включения и выключения записей. Вы также должны знать, что, вообще говоря, по крайней мере одна область будет открыта до загрузки вашего расширения, поэтому вы увидите некоторые пары &lt;code&gt;pre/post_end&lt;/code&gt; , у которых не было соответствующего &lt;code&gt;start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6126376d608e0a08175eebdf21cea20073d31c49" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre&lt;/code&gt;/&lt;code&gt;post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf6b188e1d6cda2b1c31b9f2ea910f75bac5ce6" translate="yes" xml:space="preserve">
          <source>Once the 'aaab' at the start of the string has matched, and the &lt;code&gt;(*SKIP)&lt;/code&gt; executed, the next starting point will be where the cursor was when the &lt;code&gt;(*SKIP)&lt;/code&gt; was executed.</source>
          <target state="translated">После совпадения &amp;laquo;aaab&amp;raquo; в начале строки и выполнения &lt;code&gt;(*SKIP)&lt;/code&gt; следующей начальной точкой будет то место, где находился курсор при выполнении &lt;code&gt;(*SKIP)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8672a62497c5f795c9c2acf9e29afcdfcf0e6269" translate="yes" xml:space="preserve">
          <source>Once the AV has been created, the following operations are possible on it:</source>
          <target state="translated">После того,как AV был создан,над ним можно выполнить следующие операции:</target>
        </trans-unit>
        <trans-unit id="67df8d841097b17fc29c0a4ea72cc77f4ff9a4eb" translate="yes" xml:space="preserve">
          <source>Once the HV has been created, the following operations are possible on it:</source>
          <target state="translated">После создания HV над ним можно выполнить следующие операции:</target>
        </trans-unit>
        <trans-unit id="7b0782b5689e0608cbf6133cde75f1c5a3739fbd" translate="yes" xml:space="preserve">
          <source>Once the build is completed you need to create the DLL SIS file by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57df9a521b252465d2cd33284b38479df5df9b79" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt; ). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt; , as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt; , they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">После применения фильтрации исходные строки, регулярные выражения, POD и т. Д. Повторно вставляются в код, заменяя каждый заполнитель соответствующим исходным компонентом (из &lt;code&gt;@components&lt;/code&gt; ). Обратите внимание, что это означает, что с переменной &lt;code&gt;@components&lt;/code&gt; следует обращаться с особой осторожностью в фильтре. В массиве &lt;code&gt;@components&lt;/code&gt; хранятся &amp;laquo;обратные переводы&amp;raquo; каждого заполнителя, вставленного в &lt;code&gt;$_&lt;/code&gt; , а также промежуточный исходный код между заполнителями. Если &lt;code&gt;@components&lt;/code&gt; заполнителей изменяются в @components , они будут аналогичным образом изменены, когда заполнители будут удалены из &lt;code&gt;$_&lt;/code&gt; после завершения фильтра.</target>
        </trans-unit>
        <trans-unit id="cd6cbdddebea04b989e355c0ed247c28cfea9f3d" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt;). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt;, as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt;, they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bda05c922f6c0e7108b9b6664cf70b280c74345" translate="yes" xml:space="preserve">
          <source>Once the first line has been processed, the flow will look like this:</source>
          <target state="translated">После обработки первой строки поток будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="2abcd9048b9f7de01dd766ea3b827a4a4ca6e4d7" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">После того, как общий сокет сервера был создан с использованием параметров, перечисленных выше, сервер ожидает подключения к нему нового клиента. Сервер блокирует метод &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; , который в конечном итоге принимает двунаправленное соединение от удаленного клиента. (Не забудьте автозаполнить этот дескриптор, чтобы обойти буферизацию.)</target>
        </trans-unit>
        <trans-unit id="f10049f7656078a8b871ef2357d99fe6e6157f3d" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;accept&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f78b2677c2893cae03c215c7f1cb2296b9c1aa" translate="yes" xml:space="preserve">
          <source>Once the headers have been installed, you can create a SIS for the PerlApp:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee769afc72db89229ffb2a909f356b2b29d26cc" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the exit status. If the parser ran an executable, it returns the exit status of the executable.</source>
          <target state="translated">Как только синтаксический анализатор закончит работу,он вернет статус выхода.Если парсер запустил исполняемый файл,он вернет статус выхода исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="4d1cfe61310d7995317dabd0218a153aefb9089c" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.</source>
          <target state="translated">Как только парсер будет закончен,он вернет номер версии для обработанного TAP.Номер версии был введен с TAP версии 13,поэтому если номер версии не найден,предполагается,что это версия 12.</target>
        </trans-unit>
        <trans-unit id="295310f03609b1e9bcb5a3f97bee3cf209b7fdc9" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; status.</source>
          <target state="translated">Как только парсер завершит работу, он вернет статус ожидания. Если парсер запустил исполняемый файл, он возвращает состояние ожидания исполняемого файла. В противном случае это просто возвращает статус &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58ee32eca6824b955eaf78744f8a028137e28ac5" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;exit&lt;/code&gt; status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e563448cf76902cc1f89b5320bc98d51a6a5d5a8" translate="yes" xml:space="preserve">
          <source>Once the prefix an dthe outermost opening delimiter bracket have been recognized, code blocks are extracted by stepping through the input text and trying the following alternatives in sequence:</source>
          <target state="translated">После того,как префикс d крайней открывающей разделительной скобки распознан,блоки кода извлекаются путем пошагового прохождения по входному тексту и последовательного пробования следующих альтернатив:</target>
        </trans-unit>
        <trans-unit id="c16b3faffb99d8d54125fd9ac6e0e713e87e3953" translate="yes" xml:space="preserve">
          <source>Once the program is otherwise done, and once its localization for the first language works right (via the data and methods in Projname::L10N::en_us), you can get together the data for translation. If your first language lexicon isn't an _AUTO lexicon, then you already have all the messages explicitly in the lexicon (or else you'd be getting exceptions thrown when you call $lh-&amp;gt;maketext to get messages that aren't in there). But if you were (advisedly) lazy and are using an _AUTO lexicon, then you've got to make a list of all the phrases that you've so far been letting _AUTO generate for you. There are very many ways to assemble such a list. The most straightforward is to simply grep the source for every occurrence of &quot;maketext&quot; (or calls to wrappers around it, like the above &lt;code&gt;pmt&lt;/code&gt; function), and to log the following phrase.</source>
          <target state="translated">Как только программа будет завершена и как только ее локализация для первого языка работает правильно (с помощью данных и методов в Projname :: L10N :: en_us), вы можете собрать данные для перевода. Если ваш первый языковой лексикон не является лексиконом _AUTO, значит, у вас уже есть все сообщения явно в лексиконе (иначе вы получите исключения, когда вы вызываете $ lh-&amp;gt; maketext для получения сообщений, которых там нет ). Но если вы были (умышленно) ленивы и используете лексикон _AUTO, то вам нужно составить список всех фраз, которые вы до сих пор позволяли _AUTO генерировать для вас. Есть очень много способов составить такой список. Самый простой - просто найти источник для каждого вхождения &amp;laquo;maketext&amp;raquo; (или обращения к оболочкам вокруг него, как в &lt;code&gt;pmt&lt;/code&gt; выше pmt функция) и записать следующую фразу.</target>
        </trans-unit>
        <trans-unit id="2748f5e91bdbaf9d65e1b144f8ee5e1cdc0ecbe6" translate="yes" xml:space="preserve">
          <source>Once the reference is stored in a variable like $aref or $href, you can copy it or store it just the same as any other scalar value:</source>
          <target state="translated">Как только ссылка хранится в переменной типа $aref или $href,вы можете скопировать ее или сохранить так же,как и любое другое скалярное значение:</target>
        </trans-unit>
        <trans-unit id="15fa63ef5d4644b5d99dc644eff10efe12c6233c" translate="yes" xml:space="preserve">
          <source>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now &lt;code&gt;SIZE_ONLY&lt;/code&gt; will be false, and the actual construction can occur.</source>
          <target state="translated">После определения размера программы шаблон снова анализируется, но на этот раз по-настоящему. Теперь &lt;code&gt;SIZE_ONLY&lt;/code&gt; будет ложным, и может произойти фактическое построение.</target>
        </trans-unit>
        <trans-unit id="7c79022e55900699b84f2aa1eb3cdbe226323760" translate="yes" xml:space="preserve">
          <source>Once the socket has been connected to the peer, &lt;code&gt;connect&lt;/code&gt; will return true and the socket will now be ready to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba841c18d878724cf95fcf3049c21ef759f81a9" translate="yes" xml:space="preserve">
          <source>Once the source was patched, &lt;code&gt;./Configure&lt;/code&gt; and &lt;code&gt;make test_prep&lt;/code&gt; were called and completed successfully, enabling confirmation of the findings in RT #72414.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce09f4f2086e283549a294da4a8bb0ec70720b9" translate="yes" xml:space="preserve">
          <source>Once this is done, do the following to build any extension:</source>
          <target state="translated">Как только это будет сделано,сделайте следующее,чтобы построить любое расширение:</target>
        </trans-unit>
        <trans-unit id="c86d1961dcc0430277520b8cb5786b3c716d4a7c" translate="yes" xml:space="preserve">
          <source>Once this process completes for a given function, it is defined, so future calls to the subroutine will bypass the AUTOLOAD mechanism.</source>
          <target state="translated">Как только этот процесс завершается для данной функции,он определяется,поэтому будущие вызовы подпрограммы будут осуществляться в обход механизма AUTOLOAD.</target>
        </trans-unit>
        <trans-unit id="9bc6c924aca0f68365c3f48d14dbdebf3eb3856a" translate="yes" xml:space="preserve">
          <source>Once uploaded, it'll sit unnoticed in your author directory. If you want it connected to the rest of the CPAN, you'll need to go to &quot;Register Namespace&quot; on PAUSE. Once registered, your module will appear in the by-module and by-category listings on CPAN.</source>
          <target state="translated">После загрузки он будет незамеченным в вашем авторском каталоге.Если вы хотите,чтобы он был подключен к остальной части CPAN,вам нужно перейти в &quot;Регистрационное пространство имен&quot; на PAUSE.После регистрации ваш модуль появится в списке байт-модулей и байт-категорий CPAN.</target>
        </trans-unit>
        <trans-unit id="852b82c0a8fc155a5b67d823ae98f4fd4d342839" translate="yes" xml:space="preserve">
          <source>Once upon a time, C code compilable under both BSD and SysV. In general, code that can be easily converted to run on another &lt;b&gt;platform&lt;/b&gt;, where &amp;ldquo;easily&amp;rdquo; can be defined however you like, and usually is. Anything may be considered portable if you try hard enough, such as a mobile home or London Bridge.</source>
          <target state="translated">Когда-то давно код C компилировался как под BSD, так и под SysV. В общем, код, который можно легко преобразовать для работы на другой &lt;b&gt;платформе&lt;/b&gt; , где &amp;laquo;легко&amp;raquo; можно определить, как вам нравится, и обычно это так. Все, что угодно, можно считать портативным, если вы достаточно постараетесь, например, мобильный дом или Лондонский мост.</target>
        </trans-unit>
        <trans-unit id="028479890974f67d52e50ca30dc71571debad796" translate="yes" xml:space="preserve">
          <source>Once upon a time, I wrote a program called pstruct. It was a perl program that tried to parse out C structures and display their member offsets for you. This was especially useful for people looking at binary dumps or poking around the kernel.</source>
          <target state="translated">Давным-давно я написал программу под названием Pstruct.Это была программа на perl,которая пыталась разобрать структуры на C и отобразить их членские смещения для вас.Это было особенно полезно для людей,смотрящих на двоичные свалки или копающихся в ядре.</target>
        </trans-unit>
        <trans-unit id="5311fe73402702af14e5a56e844da83a8b07a8a6" translate="yes" xml:space="preserve">
          <source>Once upon a time, MakeMaker could produce an approximation of a correct Makefile on MacOS Classic (MacPerl). Due to a lack of maintainers, this fell out of sync with the rest of MakeMaker and hadn't worked in years. Since there's little chance of it being repaired, MacOS Classic is fading away, and the code was icky to begin with, the code has been deleted to make maintenance easier.</source>
          <target state="translated">Давным-давно,MakeMaker мог создать аппроксимацию правильного Makefile на MacOS Classic (MacPerl).Из-за отсутствия сопровождающих это не синхронизировалось с остальными версиями MakeMaker и не работало годами.Так как шансов на его ремонт мало,MacOS Classic затухает,а код для начала был ледяным,код был удален,чтобы облегчить обслуживание.</target>
        </trans-unit>
        <trans-unit id="f360544bd22369fcd1b6d32877524b0035f30449" translate="yes" xml:space="preserve">
          <source>Once upon a time, there was a library called</source>
          <target state="translated">Давным-давно существовала библиотека,которая называлась</target>
        </trans-unit>
        <trans-unit id="c419b35f29ce772e59b3d6f120a7bf0188bed72b" translate="yes" xml:space="preserve">
          <source>Once we've blessed the hash referred to by &lt;code&gt;$self&lt;/code&gt; we can start calling methods on it. This is useful if you want to put object initialization in its own separate method:</source>
          <target state="translated">После того, как мы благословили хэш, на который ссылается &lt;code&gt;$self&lt;/code&gt; мы можем начать вызывать для него методы. Это полезно, если вы хотите поместить инициализацию объекта в отдельный отдельный метод:</target>
        </trans-unit>
        <trans-unit id="6b240bbed00f45e13a77c757892ecbf1631c45c9" translate="yes" xml:space="preserve">
          <source>Once you can identify individual blocks, try allowing them to be nested. That isn't difficult either.</source>
          <target state="translated">Как только вы сможете определить отдельные блоки,попробуйте позволить им быть вложенными.Это тоже не сложно.</target>
        </trans-unit>
        <trans-unit id="383155a2b30e1482a3f900136a965760218a5249" translate="yes" xml:space="preserve">
          <source>Once you have a reference, you can use the following macro to dereference the reference:</source>
          <target state="translated">После получения ссылки можно использовать следующий макрос для снятия ссылки:</target>
        </trans-unit>
        <trans-unit id="8475608c1eecbfff6034af7fbbf89552dc6e6321" translate="yes" xml:space="preserve">
          <source>Once you have changed into the repository directory, you can inspect it. After a clone the repository will contain a single local branch, which will be the current branch as well, as indicated by the asterisk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ad49af6893225c730f233c983aba4b11bcf0d8" translate="yes" xml:space="preserve">
          <source>Once you have done that, you can access the Berkeley DB API functions as &lt;b&gt;DB_File&lt;/b&gt; methods directly like this:</source>
          <target state="translated">Как только вы это сделаете, вы сможете напрямую обращаться к функциям Berkeley DB API как &lt;b&gt;к&lt;/b&gt; методам &lt;b&gt;DB_File&lt;/b&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="9d9573b46c2994b393d22341f4e2899c15619352" translate="yes" xml:space="preserve">
          <source>Once you have it on, simply bring up a PASE shell and extract the tarball.</source>
          <target state="translated">Как только вы его наденете,просто поднимите оболочку PASE и извлеките тарбол.</target>
        </trans-unit>
        <trans-unit id="2403323a2c0ab8ef6892066d26c525181d3596a2" translate="yes" xml:space="preserve">
          <source>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</source>
          <target state="translated">После того,как у вас есть список ключей,вы можете обработать этот список,прежде чем обрабатывать хэш-элементы.Например,вы можете отсортировать ключи,чтобы обработать их в лексическом порядке:</target>
        </trans-unit>
        <trans-unit id="fba888926fbbe98be022401817b7a70ac357c498" translate="yes" xml:space="preserve">
          <source>Once you have the toolchain set up properly, the only remaining hurdle is actually locating where in the device it was installed in. For example, CCTools installs its toolchain in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2bd757e5448bc96817cbaf4661aeb1b493b281" translate="yes" xml:space="preserve">
          <source>Once you have this code, slap it into the second argument of</source>
          <target state="translated">Как только вы получите этот код,вставьте его во второй аргумент из</target>
        </trans-unit>
        <trans-unit id="1eb08c46cb14cd90ec6426a049fef10ebf7f995f" translate="yes" xml:space="preserve">
          <source>Once you have unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c09803658da900e84c748f878a847903987255" translate="yes" xml:space="preserve">
          <source>Once you have write access, you will need to modify the URL for the origin remote to enable pushing. Edit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0a83fd366650f3f9c13c1a72ec5ce82cd02510" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; instead of the variable-sized &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; for your input.</source>
          <target state="translated">После того, как ваш двоичный файл правильно открыт в нужном режиме, вы можете использовать все те же функции ввода-вывода Perl, которые вы использовали для текстовых файлов. Однако вы можете захотеть использовать &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; фиксированного размера вместо &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; чтения переменного размера для ввода.</target>
        </trans-unit>
        <trans-unit id="23e5339b1fa0074bcbf688df51973daa79c9a799" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;read&lt;/code&gt; instead of the variable-sized &lt;code&gt;readline&lt;/code&gt; for your input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a97180f59d4ebc49010b5f130f6497cfeb42c05" translate="yes" xml:space="preserve">
          <source>Once you have your hook functions, you need a &lt;code&gt;BHK&lt;/code&gt; structure to put them in. It's best to allocate it statically, since there is no way to free it once it's registered. The function pointers should be inserted into this structure using the &lt;code&gt;BhkENTRY_set&lt;/code&gt; macro, which will also set flags indicating which entries are valid. If you do need to allocate your &lt;code&gt;BHK&lt;/code&gt; dynamically for some reason, be sure to zero it before you start.</source>
          <target state="translated">Когда у вас есть функции-перехватчики, вам понадобится структура &lt;code&gt;BHK&lt;/code&gt; для их размещения. Лучше всего выделять ее статически, так как нет возможности освободить ее после регистрации. Указатели функций должны быть вставлены в эту структуру с &lt;code&gt;BhkENTRY_set&lt;/code&gt; макроса BhkENTRY_set , который также установит флаги, указывающие, какие записи допустимы. Если по какой-то причине вам действительно нужно динамически распределять &lt;code&gt;BHK&lt;/code&gt; , не забудьте обнулить его перед началом.</target>
        </trans-unit>
        <trans-unit id="e41f59d96ffbb22709bea4ad583772ec9921c59e" translate="yes" xml:space="preserve">
          <source>Once you know what the type of an object is, you then know what subclass it belongs to, and therefore what methods it supports.</source>
          <target state="translated">Как только вы знаете,какой тип объекта,вы знаете,к какому подклассу он принадлежит,и,следовательно,какие методы он поддерживает.</target>
        </trans-unit>
        <trans-unit id="850880274fc323f37b6b25fc23ccf3a516cbf65a" translate="yes" xml:space="preserve">
          <source>Once you start accumulating users, they'll send you bug reports. If you're lucky, they'll even send you patches. Welcome to the joys of maintaining a software project...</source>
          <target state="translated">Как только вы начнете накапливать пользователей,они будут посылать вам сообщения об ошибках.Если повезет,они даже пришлют вам исправления.Добро пожаловать в радость поддержания программного проекта...</target>
        </trans-unit>
        <trans-unit id="ba22e7b4a3b9d48110bef39d92876fccf1215f67" translate="yes" xml:space="preserve">
          <source>Once you're doing this, you may alter Concise output by adding new rendering styles, and by optionally adding callback routines which populate new variables, if such were referenced from those (just added) styles.</source>
          <target state="translated">Сделав это,вы можете изменить лаконичный вывод,добавив новые стили рендеринга,а также опционально добавив подпрограммы обратного вызова,которые заполняют новые переменные,если на них ссылались из этих (только что добавленных)стилей.</target>
        </trans-unit>
        <trans-unit id="566e6d16d506c3974bf904eb0b48aa55735c513e" translate="yes" xml:space="preserve">
          <source>Once you're done here, check out &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; next.</source>
          <target state="translated">Как только вы закончите, ознакомьтесь с &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29ed2494b99283db9c4753c1220697c79a656d72" translate="yes" xml:space="preserve">
          <source>Once you've actually set any options you want (if any), you can go ahead and use the following methods to search for Pod files in particular ways.</source>
          <target state="translated">После того,как вы установили любые опции (если таковые имеются),вы можете использовать следующие методы для поиска файлов Pod определенными способами.</target>
        </trans-unit>
        <trans-unit id="23b007b44c67108f453a7c776499a8dd3ea3293f" translate="yes" xml:space="preserve">
          <source>Once you've done that, you can safely omit the encoding part of the open mode:</source>
          <target state="translated">Сделав это,вы можете безопасно пропустить часть кодирования в открытом режиме:</target>
        </trans-unit>
        <trans-unit id="57d330172757358785b8cc8eade4d52dfcf7f16d" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make dist&lt;/code&gt; , and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">Убедившись, что ваш модуль проходит собственные тесты - всегда полезно убедиться - вы можете &lt;code&gt;make dist&lt;/code&gt; , и Makefile, надеюсь, создаст вам хороший архив вашего модуля, готовый к загрузке.</target>
        </trans-unit>
        <trans-unit id="43b912c28f1dbb1c2e7aca4c90fa70b6b6f3dc13" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make distcheck&lt;/code&gt; to make sure everything looks OK, followed by &lt;code&gt;make dist&lt;/code&gt;, and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9742159929b90169a3b9a1d6ff201b11bb8fe7b" translate="yes" xml:space="preserve">
          <source>Once you've finished writing your commit message and exited your editor, git will write your change to disk and tell you something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63abbf1c003f24ebc901d81ec59d8ecd65e101a" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">После того, как вы установили NDK и настроили свое устройство, все, что вам осталось сделать, это настроить устройство и среду кросс-компиляции. Blackberry предоставляет сценарий &lt;code&gt;bbndk-env.sh&lt;/code&gt; (иногда называемый чем-то вроде &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ), который можно использовать для этого. Однако есть небольшая загвоздка, с которой мы должны работать: сценарий изменяет PATH так, чтобы 'gcc' или 'ar' указывали на их эквиваленты кросс-компиляции, что затрудняет процесс сборки.</target>
        </trans-unit>
        <trans-unit id="0ecc1cbc4b8ed0cfb9b6e01c2a2f1591b2619c6e" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt;) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dca0ad4315ae940ee938651b8e1193e8aa9a420" translate="yes" xml:space="preserve">
          <source>Once you've localized your program/site/etc. for all desired languages, be sure to show the result (whether live, or via screenshots) to the translators. Once they approve, make every effort to have it then checked by at least one other speaker of that language. This holds true even when (or especially when) the translation is done by one of your own programmers. Some kinds of systems may be harder to find testers for than others, depending on the amount of domain-specific jargon and concepts involved -- it's easier to find people who can tell you whether they approve of your translation for &quot;delete this message&quot; in an email-via-Web interface, than to find people who can give you an informed opinion on your translation for &quot;attribute value&quot; in an XML query tool's interface.</source>
          <target state="translated">После того,как Вы локализовали свою программу/сайт/и т.д.для всех желаемых языков,обязательно покажите результат (в прямом эфире или с помощью скриншотов)переводчикам.Как только они одобрят его,приложите все усилия,чтобы он был проверен,по крайней мере,еще одним носителем этого языка.Это справедливо даже тогда,когда (или особенно когда)перевод осуществляется одним из ваших собственных программистов.Для некоторых типов систем может быть сложнее найти тестеров,чем для других,в зависимости от количества специфических для данной области жаргонов и концепций-проще найти людей,которые могут сказать вам,одобряют ли они ваш перевод для &quot;удаления этого сообщения&quot; в интерфейсе email-via-Web,чем найти людей,которые могут дать вам обоснованное мнение о вашем переводе для &quot;значения атрибута&quot; в интерфейсе XML-инструмента запроса.</target>
        </trans-unit>
        <trans-unit id="c53ec1e93f888bd372b8348217b36ca16ed6c602" translate="yes" xml:space="preserve">
          <source>Once you've understood those, embedding Perl in C is easy.</source>
          <target state="translated">Как только вы их поймете,внедрить Perl в C легко.</target>
        </trans-unit>
        <trans-unit id="8154145e302b1a07e64a971e9a8a8af681b5891f" translate="yes" xml:space="preserve">
          <source>Once you've unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">После распаковки дистрибутива запустите &quot;sh Configure&quot; (см.УСТАНОВКУ для полного обсуждения опций конфигурации).Есть файл &quot;подсказок&quot; для os390,который определяет правильные значения для большинства вещей.Некоторые вещи,на которые следует обратить внимание,включают в себя:</target>
        </trans-unit>
        <trans-unit id="db5c3d0411160491df177efaf9a707107fc6ab38" translate="yes" xml:space="preserve">
          <source>Once your extension is complete and passes all its tests, installing it is quite simple: you simply run &quot;make install&quot;. You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you.</source>
          <target state="translated">После того,как ваше расширение будет завершено и пройдет все тесты,его установка довольно проста:вы просто запускаете &quot;make install&quot;.Вам нужно будет либо иметь права на запись в каталоги,где установлен Perl,либо попросить вашего системного администратора запустить make за вас.</target>
        </trans-unit>
        <trans-unit id="4f49dbc375a0394fd3dd511b9f8226cfef74fa93" translate="yes" xml:space="preserve">
          <source>One additional translation is performed: instead of</source>
          <target state="translated">Выполняется один дополнительный перевод:вместо</target>
        </trans-unit>
        <trans-unit id="ec03014fcac8a461acd2bab0b3f3f4c4647a9956" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure Perl code outside the lexical scope of &lt;code&gt;use locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3A-Numeric-Formatting&quot;&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt;&lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68ac543ed261e894527754904db5e74312dfaac" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure perl code outside the lexical scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC &lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">Одна из областей, где произошел конфликт, касается локалей C. (См. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; .) Perl, за одним исключением, и если не указано иное, устанавливает базовый языковой стандарт, в котором выполняется программа, на языковой стандарт, переданный ему из среды. Это важное отличие от общей программы на языке C, где основной локалью является локаль &quot;C&quot;, если программа не изменяет ее. Начиная с версии 5.20, этот базовый языковой стандарт полностью скрыт от чистого кода Perl за пределами лексической области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; за исключением нескольких вызовов функций в модуле POSIX, которые по необходимости его используют. Но базовый языковой стандарт с одним исключением предоставляется коду XS, влияя на все подпрограммы библиотеки C, поведение которых зависит от языкового стандарта. Ваш XS-код лучше не предполагает, что базовая локаль - &quot;C&quot;. Исключением является категория языкового стандарта &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC&lt;/a&gt; , и причина, по которой это исключение, заключается в том, что опыт показал, что это может быть проблематичным для кода XS, тогда как у нас не было сообщений о проблемах с &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;другими категориями языковых стандартов.&lt;/a&gt;. И причина того, что эта категория является проблематичной, заключается в том, что символ, используемый в качестве десятичной точки, может варьироваться. Во многих европейских языках используется запятая, тогда как в английском и, следовательно, Perl ожидает точку (U + 002E: FULL STOP). Многие модули могут обрабатывать только символ системы счисления, являющийся точкой, и perl пытается это сделать. Вплоть до Perl v5.20 попытка заключалась в том, чтобы просто установить &lt;code&gt;LC_NUMERIC&lt;/code&gt; при запуске на локаль &lt;code&gt;&quot;C&quot;&lt;/code&gt; . В противном случае любой &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale ()&lt;/a&gt; изменил бы его; это вызвало некоторые сбои. Поэтому, начиная с v5.22, perl старается, чтобы &lt;code&gt;LC_NUMERIC&lt;/code&gt; всегда был установлен на &lt;code&gt;&quot;C&quot;&lt;/code&gt; для кода XS.</target>
        </trans-unit>
        <trans-unit id="6b3b34651f404f7056a8a03b94a1667665687e73" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt; ). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">Одно большое различие между наборами символов на основе ASCII и EBCDIC - это относительное положение символов при сортировке в собственном порядке. Наибольшее беспокойство вызывают прописные и строчные буквы, цифры и символ подчеркивания ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ). На платформах ASCII в собственном порядке сортировки цифры идут перед прописными буквами, которые идут перед подчеркиванием, которое стоит перед строчными буквами. В EBCDIC сначала идет подчеркивание, затем строчные буквы, затем прописные буквы и последними цифры. При сортировке на платформе, основанной на ASCII, двухбуквенное сокращение для врача идет перед двухбуквенным сокращением для диска; то есть:</target>
        </trans-unit>
        <trans-unit id="4d27487c78325597c40568b8011491df0ed50a95" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63660a2be4a88226e8e69f57c474e97932c916a" translate="yes" xml:space="preserve">
          <source>One can also use &quot;short&quot; names:</source>
          <target state="translated">Можно также использовать &quot;короткие&quot; имена:</target>
        </trans-unit>
        <trans-unit id="577442f1eff045466125f84e1aef5d482722c146" translate="yes" xml:space="preserve">
          <source>One can always start</source>
          <target state="translated">Всегда можно начать</target>
        </trans-unit>
        <trans-unit id="29c09e61bbeafec8533e6d27dfc8a923e0fca57d" translate="yes" xml:space="preserve">
          <source>One can build perl with thread support enabled by providing &lt;code&gt;-D usethreads&lt;/code&gt; option to</source>
          <target state="translated">Можно создать Perl с включенной поддержкой потоков, &lt;code&gt;-D usethreads&lt;/code&gt; параметр -D usethreads для</target>
        </trans-unit>
        <trans-unit id="359cf3d8d5555fb74ca7adc2fbcedf983680dde4" translate="yes" xml:space="preserve">
          <source>One can change the output file handle of the messages by setting $Getopt::Std::OUTPUT_HELP_VERSION. One can print the messages of &lt;code&gt;--help&lt;/code&gt; (without the &lt;code&gt;Usage:&lt;/code&gt; line) and &lt;code&gt;--version&lt;/code&gt; by calling functions help_mess() and version_mess() with the switches string as an argument.</source>
          <target state="translated">Можно изменить дескриптор выходного файла сообщений, установив $ Getopt :: Std :: OUTPUT_HELP_VERSION. Сообщения &lt;code&gt;--help&lt;/code&gt; (без строки &lt;code&gt;Usage:&lt;/code&gt; :) и &lt;code&gt;--version&lt;/code&gt; можно распечатать , вызвав функции help_mess () и version_mess () со строкой переключателей в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="d414d38c04c2c09cb11f7d028ae1e652935790fa" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt; .</source>
          <target state="translated">Можно проверить, поддерживает ли загруженный в данный момент пакет ReadLine эти методы, проверив соответствующие &lt;code&gt;Features&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c393381162c37f504c3308b016602c8a38b83d3" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db862b22399f31abaed4d1d2c6d6ed9c25d9c230" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;a href=&quot;Data::Dumper&quot;&gt;&lt;code&gt;Data::Dumper&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;storable&quot;&gt;&lt;code&gt;Storable&lt;/code&gt;&lt;/a&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c198d2cf41321cd565d4f52242fa64736d1a9f4a" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">Обе эти проблемы можно обойти двумя способами. Либо передавайте и сохраняйте числа всегда в текстовом формате, а не в исходном двоичном формате, либо рассмотрите возможность использования таких модулей, как &lt;code&gt;Data::Dumper&lt;/code&gt; и &lt;code&gt;Storable&lt;/code&gt; (включенных в Perl 5.8). Хранение всех данных в виде текста значительно упрощает дело.</target>
        </trans-unit>
        <trans-unit id="09119ba09b711474d1016a03da12b7c5aabeff6a" translate="yes" xml:space="preserve">
          <source>One can get RSX from, say</source>
          <target state="translated">Можно получить RSX,скажем.</target>
        </trans-unit>
        <trans-unit id="fc1d1f2f775a433521e449135abda7dc4b545354" translate="yes" xml:space="preserve">
          <source>One can get different parts of EMX from, say</source>
          <target state="translated">Можно получить разные части EMX от,скажем.</target>
        </trans-unit>
        <trans-unit id="b1f6c95529bb8b413cce8749a9949bb156c89f7b" translate="yes" xml:space="preserve">
          <source>One can have Unicode in identifier names, but not in package/class or subroutine names. While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.</source>
          <target state="translated">Можно использовать Unicode в именах идентификаторов,но не в именах пакетов/классов или подпрограмм.Хотя некоторая ограниченная функциональность в этом отношении существует на Perl 5.8.0,это более случайно,чем разработано;использование Юникода для этих целей не поддерживается.</target>
        </trans-unit>
        <trans-unit id="419250bbe62537b6d8975e14166ba62003b501d4" translate="yes" xml:space="preserve">
          <source>One can read this document in the following formats:</source>
          <target state="translated">Этот документ можно прочитать в следующих форматах:</target>
        </trans-unit>
        <trans-unit id="6893de36816aebf716cd1fd72a1de7d9c51768bf" translate="yes" xml:space="preserve">
          <source>One can replace a numeric repeat count with a template letter enclosed in brackets to use the packed byte length of the bracketed template for the repeat count.</source>
          <target state="translated">Можно заменить числовой счетчик повторов на шаблонную букву,заключенную в скобки,чтобы использовать длину упакованного байта шаблона в скобках для счетчика повторов.</target>
        </trans-unit>
        <trans-unit id="05782b074320e38eef954451f657efc4b11fa74a" translate="yes" xml:space="preserve">
          <source>One case that this does not handle is a gv without SvFAKE set. After</source>
          <target state="translated">Один из случаев,с которым он не справляется,это гВ без комплекта SvFAKE.После</target>
        </trans-unit>
        <trans-unit id="702f5c0458dfb1f9b9fa361a8264610e99c16724" translate="yes" xml:space="preserve">
          <source>One common debugging approach here, would be to liberally sprinkle a few print statements, to add a check just before we print out our data, and another just after:</source>
          <target state="translated">Одним из распространенных подходов к отладке здесь было бы либеральное разбрызгивание нескольких печатных утверждений,добавление проверки непосредственно перед распечаткой наших данных,и еще одно сразу после:</target>
        </trans-unit>
        <trans-unit id="38e71844bc36e8f5a99e4a47f54b762cb30af6e8" translate="yes" xml:space="preserve">
          <source>One common mistake when using this port with a GUI library like &lt;code&gt;Tk&lt;/code&gt; is assuming that Perl's normal behavior of opening a command-line window will go away. This isn't the case. If you want to start a copy of &lt;code&gt;perl&lt;/code&gt; without opening a command-line window, use the &lt;code&gt;wperl&lt;/code&gt; executable built during the installation process. Usage is exactly the same as normal &lt;code&gt;perl&lt;/code&gt; on Windows, except that options like &lt;code&gt;-h&lt;/code&gt; don't work (since they need a command-line window to print to).</source>
          <target state="translated">Одна из распространенных ошибок при использовании этого порта с библиотекой GUI, такой как &lt;code&gt;Tk&lt;/code&gt; , заключается в предположении, что нормальное поведение Perl при открытии окна командной строки исчезнет. Это не так. Если вы хотите запустить копию &lt;code&gt;perl&lt;/code&gt; , не открывая окно командной строки, используйте исполняемый файл &lt;code&gt;wperl&lt;/code&gt; , созданный в процессе установки. Использование точно такое же, как и в обычном &lt;code&gt;perl&lt;/code&gt; в Windows, за исключением того, что такие параметры, как &lt;code&gt;-h&lt;/code&gt; , не работают (так как им нужно окно командной строки для печати).</target>
        </trans-unit>
        <trans-unit id="8a4117118bb75dbafb375915c27d62ebe634dd07" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">Эту информацию передают в &lt;b&gt;xsubpp&lt;/b&gt; , заменяя &lt;code&gt;*&lt;/code&gt; перед аргументом на &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; означает, что аргумент должен быть передан библиотечной функции по ее адресу. Две указанные выше функции могут быть XSUB-образными как</target>
        </trans-unit>
        <trans-unit id="fcbea60b30cb68b4498f395be71fe8caca1d66b2" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt;. &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10907c81f2d55151091ac660924f2a1e254db78" translate="yes" xml:space="preserve">
          <source>One could use this to create subclasses of &lt;b&gt;Pod::Paragraphs&lt;/b&gt; and &lt;b&gt;Pod::InteriorSequences&lt;/b&gt; for specific commands (or to create your own custom node-types in the parse-tree) and add some kind of &lt;b&gt;emit()&lt;/b&gt; method to each custom node/subclass object in the tree. Then all you'd need to do is recursively walk the tree in the desired order, processing the children (most likely from left to right) by formatting them if they are text-strings, or by calling their &lt;b&gt;emit()&lt;/b&gt; method if they are objects/references.</source>
          <target state="translated">Это можно использовать для создания подклассов &lt;b&gt;Pod :: Paragraphs&lt;/b&gt; и &lt;b&gt;Pod :: InteriorSequences&lt;/b&gt; для определенных команд (или для создания ваших собственных типов узлов в дереве синтаксического анализа) и добавления какого-либо метода &lt;b&gt;emit ()&lt;/b&gt; к каждому настраиваемому узлу / объект подкласса в дереве. Затем все, что вам нужно сделать, это рекурсивно пройти по дереву в желаемом порядке, обрабатывая дочерние элементы (скорее всего, слева направо), форматируя их, если они являются текстовыми строками, или вызывая их метод &lt;b&gt;emit (),&lt;/b&gt; если они объекты / ссылки.</target>
        </trans-unit>
        <trans-unit id="d5d134d4ce2691a8fd3e620efdc0c0a7dc96f2ab" translate="yes" xml:space="preserve">
          <source>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</source>
          <target state="translated">Один контрагент в столбце с пометкой &quot;ASCII-диапазон Юникод&quot; в таблице совпадает только с символами из набора ASCII-символов.</target>
        </trans-unit>
        <trans-unit id="e759a7518c2a7615eb212a5b5c617930b5079aa4" translate="yes" xml:space="preserve">
          <source>One especially common bit of Perl code is opening a pipe to &lt;b&gt;sendmail&lt;/b&gt;:</source>
          <target state="translated">Один из наиболее распространенных фрагментов кода Perl - это открытие канала для &lt;b&gt;sendmail&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="42325abeeacce413a34de5a75512b4be08cb249a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;PerlIO::via::QuotedPrint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6006eb32ad88f65a8e3a677b12b70bf0c21cd44a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">Один пример модуля, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO :: via :: QuotedPrint&lt;/a&gt; , включен в Perl 5.8.0, и другие примеры модулей доступны из CPAN, такие как &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64&lt;/a&gt; . Например, модуль PerlIO :: via :: StripHTML позволяет вам сказать:</target>
        </trans-unit>
        <trans-unit id="5ffc602a59cde7db4cddb26183a3140b07c9e1e7" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">Единственным исключением является скалярная переменная по умолчанию: начиная с perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; всегда удаляет всю магию из $ _, чтобы можно было безопасно повторно использовать $ _ в подпрограмме.</target>
        </trans-unit>
        <trans-unit id="dd6c9b4252819413fc14053d624bb7bb0e0b2769" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;local($_)&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b4b3fb221020ddd9f00f023bbae8ca4cbaad9d" translate="yes" xml:space="preserve">
          <source>One facility, one priority.</source>
          <target state="translated">Один объект,один приоритет.</target>
        </trans-unit>
        <trans-unit id="c1af03124d01c283a40e813bb6152573293c3a58" translate="yes" xml:space="preserve">
          <source>One final point -- obviously &lt;code&gt;InputLength&lt;/code&gt; can only be used whenever you know the length of the compressed data beforehand, like here with a zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aecc974b0a5e7d4fdcb37dff6e7916eb87115e6" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt; , where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">Одна форма, доступная начиная с Perl 5.14, выглядит как &lt;code&gt;\o{...}&lt;/code&gt; , где точки представляют одну или несколько восьмеричных цифр. Его можно использовать для любого символа Юникода.</target>
        </trans-unit>
        <trans-unit id="6706d7cc152004a9fcc100843796f293fa434aa5" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt;, where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322c61ed78983eea548dac2ca0c0f3a32df9d886" translate="yes" xml:space="preserve">
          <source>One generally uses it like so:</source>
          <target state="translated">Обычно так используют:</target>
        </trans-unit>
        <trans-unit id="5328aa4f92833315a7e49e7973d7b5d5df515277" translate="yes" xml:space="preserve">
          <source>One good reason is when you already have an existing application written in another language that's all done (and done well), or you have an application language specifically designed for a certain task (e.g. prolog, make).</source>
          <target state="translated">Одна из веских причин заключается в том,что у вас уже есть существующее приложение,написанное на другом языке,которое все сделано (и сделано хорошо),или у вас есть язык приложения,специально разработанный для определенной задачи (например,пролог,make).</target>
        </trans-unit>
        <trans-unit id="5181341efe5d191b40c7bb4f79e039f1b83f3ecd" translate="yes" xml:space="preserve">
          <source>One last thing before we show you how to open files: opening files does not (usually) automatically lock them in Perl. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for how to lock.</source>
          <target state="translated">И последнее, прежде чем мы покажем вам, как открывать файлы: открытие файлов (обычно) не блокирует их автоматически в Perl. См. &lt;a href=&quot;perlfaq5&quot;&gt;Perlfaq5,&lt;/a&gt; чтобы узнать, как заблокировать.</target>
        </trans-unit>
        <trans-unit id="b7d0dbf83cb5d86dbb1f5f3433c118dbdc75390f" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . These days, it's considered cleaner to call the internal function directly as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">Сначала выполняется один уровень интерпретации двойных кавычек, но вы не можете сказать &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; потому что это косвенный дескриптор файла, как описано в предыдущем абзаце. (В более старых версиях Perl программисты вставляли фигурные скобки для принудительной интерпретации как имени файла glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . В наши дни считается более чистым вызывать внутреннюю функцию напрямую как &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt; , что, вероятно, является правильный способ сделать это в первую очередь.) Например:</target>
        </trans-unit>
        <trans-unit id="c5cfad95a16b5735e117bc2fe294d5a66682c4eb" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt;. These days, it's considered cleaner to call the internal function directly as &lt;code&gt;glob($foo)&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3729bf6ea691a9592670464973a67c30ec7dce" translate="yes" xml:space="preserve">
          <source>One line description of the module. Will be included in PPD file.</source>
          <target state="translated">Описание модуля в одной строке.Будет включено в файл PPD.</target>
        </trans-unit>
        <trans-unit id="812bfff50b3cdd6b1a9ee7ea09cf72b33f18f12d" translate="yes" xml:space="preserve">
          <source>One log at a time.</source>
          <target state="translated">По одному бревну за раз.</target>
        </trans-unit>
        <trans-unit id="283b267b63bd1be649ecf96f103c3d06603de13e" translate="yes" xml:space="preserve">
          <source>One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has a C structure that packages all the interpreter state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined, and enables the support for passing in a &quot;hidden&quot; first argument that represents all three data structures. MULTIPLICITY makes multi-threaded perls possible (with the ithreads threading model, related to the macro USE_ITHREADS.)</source>
          <target state="translated">Один макрос управляет основным ароматом Perl:MULTIPLICITY.MULTIPLICITY build имеет структуру на C,которая упаковывает все состояния интерпретатора.При использовании perls с поддержкой множественности,PERL_IMPLICIT_CONTEXT также обычно определяется и включает поддержку передачи в &quot;скрытом&quot; первом аргументе,который представляет все три структуры данных.MULTIPLICITY делает возможным многопотоковый perls (с моделью ithreads threading,относящейся к макросу USE_ITHREADS).</target>
        </trans-unit>
        <trans-unit id="d690e728f490966c2e852c98cb2c60fa0b1d2fcd" translate="yes" xml:space="preserve">
          <source>One may also use pod directives to quickly comment out a section of code.</source>
          <target state="translated">Также можно использовать директивы pod для быстрого комментирования участка кода.</target>
        </trans-unit>
        <trans-unit id="9dbb00f26b5f18e0abff366f4de58cbb31829dd9" translate="yes" xml:space="preserve">
          <source>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is</source>
          <target state="translated">Можно задаться вопросом,почему мы называем вышеприведенный калькулятор символическим.Причина в том,что фактическое вычисление значения выражения откладывается до тех пор,пока значение не будет равно</target>
        </trans-unit>
        <trans-unit id="bf00ffa0a786e25adb9ef6ba76b09b1f7cf9677e" translate="yes" xml:space="preserve">
          <source>One might initially guess that Perl would find the &lt;code&gt;at&lt;/code&gt; in &lt;code&gt;cat&lt;/code&gt; and stop there, but that wouldn't give the longest possible string to the first quantifier &lt;code&gt;.*&lt;/code&gt;. Instead, the first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regexp match. In this example, that means having the &lt;code&gt;at&lt;/code&gt; sequence with the final &lt;code&gt;at&lt;/code&gt; in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the</source>
          <target state="translated">Изначально можно было бы предположить, что Perl найдет &lt;code&gt;at&lt;/code&gt; в &lt;code&gt;cat&lt;/code&gt; и остановится на нем, но это не даст самую длинную строку для первого квантификатора &lt;code&gt;.*&lt;/code&gt; . Вместо этого первый квантификатор &lt;code&gt;.*&lt;/code&gt; Захватывает как можно большую часть строки, сохраняя соответствие регулярному выражению. В этом примере это означает наличие последовательности &lt;code&gt;at&lt;/code&gt; с конечной &lt;code&gt;at&lt;/code&gt; в строке. Другой важный принцип, проиллюстрированный здесь, заключается в том, что, когда в регулярном выражении есть два или более элемента,</target>
        </trans-unit>
        <trans-unit id="3150bc5b7154ac86649428809493c4398ced1ef5" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt; . This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">Можно подумать, что &lt;code&gt;\s&lt;/code&gt; эквивалентен &lt;code&gt;[\h\v]&lt;/code&gt; . Это действительно так, начиная с Perl v5.18, но до этого единственная разница заключалась в том, что вертикальная табуляция ( &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) не соответствовала &lt;code&gt;\s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="032953fa379d00cbfc247f44c2a8260cf97dce47" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt;. This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt;) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9432dfd3d2e52e33cd8be01a23869f988f439b1e" translate="yes" xml:space="preserve">
          <source>One more thing here. The arrow is optional</source>
          <target state="translated">И еще кое-что.Стрелка необязательна</target>
        </trans-unit>
        <trans-unit id="a5eb562f91efde24f12f2e0986c6a04d104745fa" translate="yes" xml:space="preserve">
          <source>One must be careful with scalars and strings that are passed to print that contain ASCII encodings. One common place for this to occur is in the output of the MIME type header for CGI script writing. For example, many Perl programming guides recommend something similar to:</source>
          <target state="translated">Следует быть осторожным со скалярами и строками,которые передаются на печать и содержат кодировку ASCII.Общим местом для этого является вывод заголовка MIME-типа для написания CGI-скриптов.Например,многие руководства по программированию на Perl рекомендуют что-то подобное:</target>
        </trans-unit>
        <trans-unit id="8aa98e22038b28e02e918eedca3ae733d476de73" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">Одно имя для файла. Это имя занесено в &lt;b&gt;каталог&lt;/b&gt; . Вы можете использовать его при &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; чтобы сообщить &lt;b&gt;операционной системе&lt;/b&gt; , какой именно файл вы хотите открыть, и связать файл с &lt;b&gt;дескриптором файла&lt;/b&gt; , который будет нести последующий идентификатор этого файла в вашей программе, пока вы не закроете его.</target>
        </trans-unit>
        <trans-unit id="336da35cb3021da58e89132b50e38c873db1f14d" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;open&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26a31e071285811042cc63d258cbdf20a705a7a" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt; 's most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt; . When someone tries to use &lt;code&gt;Moose&lt;/code&gt; 's introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt; -using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">Одна из самых привлекательных особенностей &lt;code&gt;Moo&lt;/code&gt; - его совместимость с &lt;code&gt;Moose&lt;/code&gt; . Когда кто-то пытается использовать API самоанализа &lt;code&gt;Moose&lt;/code&gt; в классе или роли &lt;code&gt;Moo&lt;/code&gt; , он прозрачно преобразуется в класс или роль &lt;code&gt;Moose&lt;/code&gt; . Это упрощает включение кода, использующего &lt;code&gt;Moo&lt;/code&gt; ,в базу кода &lt;code&gt;Moose&lt;/code&gt; и наоборот.</target>
        </trans-unit>
        <trans-unit id="3e12d82a19550be538457962eb8c1b445867682c" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt;'s most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt;. When someone tries to use &lt;code&gt;Moose&lt;/code&gt;'s introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt;-using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf48b13931751973cecbe1ffc3a845b843b66dc" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc.</source>
          <target state="translated">URL-адрес одного из центров переноса HP - &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/.&lt;/a&gt; В настоящее время доступный порт создан с помощью GNU gcc.</target>
        </trans-unit>
        <trans-unit id="886b780bbc161a993310017e62754b9a44143e58" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc. As porting modern GNU gcc is extremely hard on HP-UX, they are stuck at version gcc-4.2.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bda56a061a9cf12b48d3cef39a83cda8c248d2" translate="yes" xml:space="preserve">
          <source>One of Perl's internal formats happens to be UTF-8. Unfortunately, Perl can't keep a secret, so everyone knows about this. That is the source of much confusion. It's better to pretend that the internal format is some unknown encoding, and that you always have to encode and decode explicitly.</source>
          <target state="translated">Один из внутренних форматов Perl-UTF-8.К сожалению,Perl не умеет хранить секреты,поэтому все об этом знают.Это источник большой путаницы.Лучше притвориться,что внутренний формат-это какая-то неизвестная кодировка,и что всегда нужно кодировать и декодировать явно.</target>
        </trans-unit>
        <trans-unit id="cc31f4f8c344159a9afe652428d4adbed5ef0111" translate="yes" xml:space="preserve">
          <source>One of the filters between the data and what you get as input or what you end up with as output.</source>
          <target state="translated">Один из фильтров между данными и тем,что вы получаете на входе или что вы получаете на выходе.</target>
        </trans-unit>
        <trans-unit id="3850b3f9f916208f5af479bdf2a17050a569dd0c" translate="yes" xml:space="preserve">
          <source>One of the hacks is to disable floating point exceptions on Perl startup (as is the default with EMX). This helps only with compile-time-linked DLLs changing the flags before main() had a chance to be called.</source>
          <target state="translated">Одним из способов взлома является отключение исключений с плавающей запятой при запуске Perl (как и в EMX по умолчанию).Это помогает только скомпилированным по времени DLL,меняющим флаги до того,как main()получила возможность быть вызванной.</target>
        </trans-unit>
        <trans-unit id="b9aab9b2588d728ddcd8fd3f3150c7ee7136503c" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt; , you know you're in for big trouble. An immeasurably superior approach is to use the &lt;code&gt;Socket&lt;/code&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Одна из основных проблем с древним, устаревшим кодом сокетов в Perl заключалась в том, что он использовал жестко запрограммированные значения для некоторых констант, что серьезно ухудшало переносимость. Если вы когда-нибудь увидите код, который явно устанавливает &lt;code&gt;$AF_INET = 2&lt;/code&gt; , значит, вас ждут большие проблемы. Неизмеримо лучший подход - использовать модуль &lt;code&gt;Socket&lt;/code&gt; , который более надежно предоставляет доступ к различным константам и функциям, которые вам понадобятся.</target>
        </trans-unit>
        <trans-unit id="3521b3f28c5fee40e9a650a969731031f1a61ee7" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt;, you know you're in for big trouble. An immeasurably superior approach is to use the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548d34337bf348093d461254c9e13628f931676b" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4fa2a95a0e37301600fc24249222e084bd9620" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called 'references', and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">Одной из наиболее важных новинок в Perl 5 стала возможность управления сложными структурами данных,такими как многомерные массивы и вложенные хэши.Для их реализации в Perl 5 была введена функция под названием &quot;ссылки&quot;,а использование ссылок является ключом к управлению сложными,структурированными данными в Perl.К сожалению,есть много забавного синтаксиса для изучения,и главная страница руководства может быть трудной для понимания.Руководство достаточно полное,и иногда люди находят это проблемой,потому что может быть сложно сказать,что важно,а что нет.</target>
        </trans-unit>
        <trans-unit id="41a97cc2346bbbbc5f26243bf51ad23f4ba0e8d3" translate="yes" xml:space="preserve">
          <source>One of the problems with a filter like:</source>
          <target state="translated">Одна из проблем с таким фильтром,как</target>
        </trans-unit>
        <trans-unit id="a626f07a30077e1f9ff80b843148b2bf2dc96ddf" translate="yes" xml:space="preserve">
          <source>One of the things that makes Perl really powerful is the fact that Perl hackers tend to want to share the solutions to problems they've faced, so you and I don't have to battle with the same problem again.</source>
          <target state="translated">Одной из вещей,которая делает Perl действительно мощным,является тот факт,что хакеры Perl,как правило,хотят поделиться решениями проблем,с которыми они столкнулись,так что нам с вами не придется бороться с той же самой проблемой снова.</target>
        </trans-unit>
        <trans-unit id="aa5b2755a479a90ca14fceb1d31618523426dc94" translate="yes" xml:space="preserve">
          <source>One of the two modules that is used by perlivp was not present in the installation. This is a serious error since it adversely affects perlivp's ability to function. You may be able to correct this by performing a proper perl installation.</source>
          <target state="translated">Один из двух модулей,используемых perlivp,не присутствовал в инсталляции.Это серьезная ошибка,так как она отрицательно влияет на работу perlivp.Вы можете исправить это,выполнив правильную установку на perl.</target>
        </trans-unit>
        <trans-unit id="3cf9aca6d76537483035c3c858a1ba395bda4fb6" translate="yes" xml:space="preserve">
          <source>One of these is because that, contrary to the claims, Unicode is not completely locale insensitive. Turkish and some related languages have two types of &lt;code&gt;&quot;I&quot;&lt;/code&gt; characters. One is dotted in both upper- and lowercase, and the other is dotless in both cases. Unicode allows a locale to use either the Turkish rules, or the rules used in all other instances, where there is only one type of &lt;code&gt;&quot;I&quot;&lt;/code&gt;, which is dotless in the uppercase, and dotted in the lower. The perl core does not (yet) handle the Turkish case, and this message warns you of that. Instead, the &lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt; module allows you to mostly implement the Turkish casing rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d738b6e570cef7894a16f160998423dd24b30a2e" translate="yes" xml:space="preserve">
          <source>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &lt;code&gt;-&lt;/code&gt; ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="translated">Один или несколько встроенных модификаторов сопоставления с образцом, которые должны быть включены (или выключены, если им предшествует &lt;code&gt;-&lt;/code&gt; ) для оставшейся части образца или оставшейся части включающей группы образцов (если есть).</target>
        </trans-unit>
        <trans-unit id="721d29636c1b919768ad8c3269b118c8775df092" translate="yes" xml:space="preserve">
          <source>One or more files turned up missing according to a run of &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; over your installation. Correct by conducting a proper installation.</source>
          <target state="translated">Один или несколько файлов оказались пропущенными в соответствии с запуском &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; во время установки. Исправьте, выполнив надлежащую установку.</target>
        </trans-unit>
        <trans-unit id="a650068eaca265c5b79bfe09b24d5cc755bb9020" translate="yes" xml:space="preserve">
          <source>One or more licenses that apply to some or all of the files in the distribution. If multiple licenses are listed, the distribution documentation should be consulted to clarify the interpretation of multiple licenses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88abd7d83fea4aa59fb220bc8cdda84165c2e0f9" translate="yes" xml:space="preserve">
          <source>One or more modifiers below may optionally follow certain letters in the TEMPLATE (the second column lists letters for which the modifier is valid):</source>
          <target state="translated">Один или несколько модификаторов ниже могут по желанию следовать определенным буквам в TEMPLATE (во второй колонке перечислены буквы,для которых модификатор действителен):</target>
        </trans-unit>
        <trans-unit id="3fcfdc5f9b9b3f122957e3a54f34893e2f61290e" translate="yes" xml:space="preserve">
          <source>One or more sections or subsections giving greater detail of available methods and routines and any other relevant information.</source>
          <target state="translated">Один или несколько разделов или подразделов с более подробным описанием доступных методов и процедур,а также любая другая соответствующая информация.</target>
        </trans-unit>
        <trans-unit id="c5eeb4b94f000feadb0a97d5609bef506c388a67" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">Еще одна интересная вещь, которую позволяет флаг &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; - это цепочка замен:</target>
        </trans-unit>
        <trans-unit id="494e3ba4d63dc7d4d1f0f89cdfe24cd0f1c04a4f" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;s///r&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9412fcd9541135d5364daa53310c1798b61f41" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">Еще одна вещь, которую следует учитывать, - это то, что резюме может быть просто неопределенным, а не освобожденным, например &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . В этом случае его RefCount возможно , не достиг нуля, но мы все - таки удалить его блокнот и его &lt;code&gt;CvROOT&lt;/code&gt; и т.д. Поскольку различные дети могут до сих пор их &lt;code&gt;CvOUTSIDE&lt;/code&gt; , указывающей на этом неопределенном резюме, мы продолжаем свой &lt;code&gt;CvOUTSIDE&lt;/code&gt; до поры до времени, так что цепочка лексических значений не разорвана. Например, следующее должно вывести 123:</target>
        </trans-unit>
        <trans-unit id="014675b4f1afe81572052832b23ba392c4d8e3a4" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;undef &amp;amp;foo&lt;/code&gt;. In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2da08b06ed54d7d3369e11557c08e9b0920593" translate="yes" xml:space="preserve">
          <source>One particularly interesting aspect is that if the op has no kids (i.e., &lt;code&gt;readline()&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) the op is freed and replaced with an entirely new one that references &lt;code&gt;*ARGV&lt;/code&gt; (lines 12-16).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54709e3c9ceaf35c18e13834b92c003e53cefa1d" translate="yes" xml:space="preserve">
          <source>One particularly pernicious problem with the 4NT command shell for Windows is that it (nearly) always treats a % character as indicating that environment variable expansion is needed. Under this shell, it is therefore important to always double any % characters which you want Perl to see (for example, for hash variables), even when they are quoted.</source>
          <target state="translated">Одной из особенно вредных проблем командной оболочки 4NT для Windows является то,что она (почти)всегда рассматривает символ % как указание на то,что необходимо расширение переменных окружения.Поэтому в этой оболочке важно всегда удваивать любые символы %,которые вы хотите видеть в Perl (например,для хэш-переменных),даже если они заключены в кавычки.</target>
        </trans-unit>
        <trans-unit id="3b85137385a802506b55867204695f7dbafde5be" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt; . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">Одна из возможностей - рассматривать любое совпадение с этими кодовыми точками как неопределенное. Но поскольку в Perl нет концепции неопределенного совпадения, он преобразует это значение в ошибку или &lt;code&gt;FALSE&lt;/code&gt; . Это почти, но не совсем то, что Perl делал начиная с v5.14 (когда использование этих кодовых точек стало в целом надежным) до v5.18. Разница в том, что Perl считал все совпадения &lt;code&gt;\p{}&lt;/code&gt; неудачными, а все совпадения &lt;code&gt;\P{}&lt;/code&gt; - успешными.</target>
        </trans-unit>
        <trans-unit id="fbed2ea5d12cf5ca5a7dda7729be8ef0a1f5a584" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt;. This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1709a410cf93d9bdbeb6df92828279b6d704a7e5" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">Одна из возможных причин этого заключается в том, что вы ожидали, что вы импортировали константу в свое пространство имен с &lt;b&gt;использованием&lt;/b&gt; или &lt;b&gt;импортом, в&lt;/b&gt; то время как такой импорт не производился, например, может быть, что ваша операционная система не поддерживает эту конкретную константу. Надеюсь, вы использовали явный список импорта для констант, которые ожидаете увидеть; см. &lt;a href=&quot;functions/use&quot;&gt;использование&lt;/a&gt; и &lt;a href=&quot;functions/import&quot;&gt;импорт&lt;/a&gt; . Хотя явный список импорта, вероятно, обнаружил бы эту ошибку раньше, он, естественно, не исправляет того факта, что ваша операционная система все еще не поддерживает эту константу. Может быть, у вас есть опечатка в константах списка &lt;b&gt;использования&lt;/b&gt; или &lt;b&gt;импорта&lt;/b&gt; символа для &lt;b&gt;импорта&lt;/b&gt; или в имени константы в строке, где возникла эта ошибка?</target>
        </trans-unit>
        <trans-unit id="039c34047140e161ac3c3f3d67a00d920ec9253f" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7cfe9d2aa74b9a194cf633078d5ffa3af4a9c3" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use &lt;code&gt;Encode::decode('UTF-8', ...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ffb8bf7d3f585bbcc39c2a43071e1fcedc7e55" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use Encode::decode_utf8.</source>
          <target state="translated">Одной из возможных причин является то,что вы сами устанавливаете флаг UTF8 для данных,которые,как вы думали,находятся в UTF-8,но это не так (это были,например,старые 8-битные данные).Чтобы защититься от этого,вы можете использовать Encode::decode_utf8.</target>
        </trans-unit>
        <trans-unit id="2c03f254e4e39f57b8a0f0a972c88db9a731c9ed" translate="yes" xml:space="preserve">
          <source>One possibly useful value for the &quot;fail&quot; attribute is the method name &quot;failure_handler_auto&quot;. This is a method defined in the class Locale::Maketext itself. You set it with:</source>
          <target state="translated">Одним из возможных полезных значений для атрибута &quot;fail&quot; является имя метода &quot;failure_handler_auto&quot;.Это метод,определенный в самом классе Locale::Maketext.Вы его устанавливаете с помощью:</target>
        </trans-unit>
        <trans-unit id="b269ab649a9c9d812d50cb6b126828e7c900c2dc" translate="yes" xml:space="preserve">
          <source>One problem that comes up all the time is needing a hash whose values are lists. Perl has hashes, of course, but the values have to be scalars; they can't be lists.</source>
          <target state="translated">Одна из проблем,которая постоянно возникает,это необходимость в хэше,значения которого представляют собой списки.Хэши на Perl,конечно,есть,но значения должны быть скалярами;они не могут быть списками.</target>
        </trans-unit>
        <trans-unit id="b4ad2adff47d9f54cd5e7bc6c9a916046c09e993" translate="yes" xml:space="preserve">
          <source>One problem with creating a zip archive directly from STDIN can be demonstrated by looking at the contents of the zip file, output.zip, that we have just created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b95f68790db1176c6962a262914d43124b34ed" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusing results in some cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0157bdbeb61d81e4c036f5229eec00b96121c7" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusting results in some cases:</source>
          <target state="translated">Одна из проблем заключается в том,что это приводит к неожиданным,а в некоторых случаях-к запутанным результатам:</target>
        </trans-unit>
        <trans-unit id="28b64c8c7b545333b3723cd48a2c35dd515526c6" translate="yes" xml:space="preserve">
          <source>One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</source>
          <target state="translated">Одной из причин этой незавершенности является присущая ей (в настоящее время)непредсказуемость:поскольку имена пакетов,и имена подпрограмм могут потребовать сопоставления с именами файлов и каталогов,возможность Юникода в файловой системе становится импортируемой-и,к сожалению,нет переносимых ответов.</target>
        </trans-unit>
        <trans-unit id="ea120cdc114e86190ef9485fa0b67ab7b3ed56c2" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">Одна из причин, по которой Perl не пытается разрешить роль Unicode в этих ситуациях, заключается в том, что ответы сильно зависят от операционной системы и файловой системы (систем). Например, могут ли имена файлов быть в Юникоде и в какой именно кодировке - это не совсем переносимая концепция. Аналогично для &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; : насколько хорошо &amp;laquo;интерфейс командной строки&amp;raquo; (и какой из них?) Будет обрабатывать Unicode?</target>
        </trans-unit>
        <trans-unit id="19ce00dd1106586a8ff2ee123627cfb803c2703c" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;qx&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8927d95df9fc41f4dc802a7941a3910e635adce" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</source>
          <target state="translated">Один счетчик ссылок украден, поэтому вам может потребоваться выполнить &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="670ea0271b09cb55acf778b559eb456bd6341e38" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dade105e4e2f60c0a165dad2f91b1cd7cbd6b9" translate="yes" xml:space="preserve">
          <source>One should write this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4267ef088e1112c0c8dad77c36351342e81e6a78" translate="yes" xml:space="preserve">
          <source>One simple way to check that things are in the right place is to print out the hard-coded &lt;code&gt;@INC&lt;/code&gt; that perl looks through for libraries:</source>
          <target state="translated">Один простой способ проверить, что все находится в нужном месте, - распечатать жестко запрограммированный &lt;code&gt;@INC&lt;/code&gt; , который perl просматривает для библиотек:</target>
        </trans-unit>
        <trans-unit id="40125cf7ac08509271fa2127b7fe01c46836ef0d" translate="yes" xml:space="preserve">
          <source>One solution for that could use &lt;code&gt;Number::Format&lt;/code&gt; like that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc49c03d5b80e5ca3e1e2c3c5c594145d4d2cfdb" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">Одним из решений вашей проблемы может быть автоматическое обновление | обновление. См. &lt;a href=&quot;../bignum&quot;&gt;Прагмы bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; и &lt;a href=&quot;../bigrat&quot;&gt;bigrat,&lt;/a&gt; чтобы узнать, как это легко сделать.</target>
        </trans-unit>
        <trans-unit id="2481b8adeee425ef556bd2bb817f713879888ab4" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c39e037892e8d1c938d57ac2c0beb9ba304a9c" translate="yes" xml:space="preserve">
          <source>One subtest fails due to the uncommon structure of the Synology file system. The file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a95fea5b4501f9e97b845e1295326b4030d00a" translate="yes" xml:space="preserve">
          <source>One such concept is that of a</source>
          <target state="translated">Одной из таких концепций является концепция</target>
        </trans-unit>
        <trans-unit id="4c38cfb2cc0fa83015bbf2caee9f3438eaaff452" translate="yes" xml:space="preserve">
          <source>One such defect of standard &lt;code&gt;numf&lt;/code&gt; is to not be able to use a certain decimal precision. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d757b7ae7bf4edf5a451dca67abbf950db74e0a2" translate="yes" xml:space="preserve">
          <source>One such sequence is &lt;code&gt;\b&lt;/code&gt;, which matches a boundary of some sort. &lt;code&gt;\b{wb}&lt;/code&gt; and a few others give specialized types of boundaries. (They are all described in detail starting at &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash&lt;/a&gt;.) Note that these don't match characters, but the zero-width spaces between characters. They are an example of a &lt;a href=&quot;#Assertions&quot;&gt;zero-width assertion&lt;/a&gt;. Consider again,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9079fbfabecb5820f55e5b80f8f3529f8caa0" translate="yes" xml:space="preserve">
          <source>One thing Perl porters should note is that</source>
          <target state="translated">Перл-портеры должны обратить внимание на то,что</target>
        </trans-unit>
        <trans-unit id="46c4b185ea7870c493b95dc5795ba2145a16a509" translate="yes" xml:space="preserve">
          <source>One thing you may not want to rely on is the EBCDIC encoding of punctuation characters since these may differ from code page to code page (and once your module or script is rumoured to work with EBCDIC, folks will want it to work with all EBCDIC character sets).</source>
          <target state="translated">Одна вещь,на которую вы,возможно,не захотите полагаться-это кодировка знаков препинания EBCDIC,так как они могут отличаться от кодовой страницы к кодовой странице (и как только по слухам ваш модуль или скрипт будет работать с EBCDIC,люди захотят,чтобы он работал со всеми наборами символов EBCDIC).</target>
        </trans-unit>
        <trans-unit id="47095331b77aa8c0bd7b8cd8bf856b6f81ef9c2e" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, a stripped-down version the code which implements the addition operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3339e6cb559916439f958aa73fa10717ebc88663" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, the code which implements the addition operator:</source>
          <target state="translated">Единственное,что вы заметите в источнике Perl,это то,что он полон макросов.Некоторые называют повсеместное использование макросов самой трудной для понимания вещью,другие считают,что это добавляет ясности.Рассмотрим пример,код,реализующий оператор сложения:</target>
        </trans-unit>
        <trans-unit id="3d7413c1ef4de3f560bf3b6da33dd42dda59d66b" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6281791d1604f0f2ed2c5d9e3d66b1042f62e087" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">Один из &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;приемов&lt;/a&gt; - использовать File :: ReadBackwards , который начинается в конце файла. Этот модуль предоставляет объект, который обертывает реальный дескриптор файла, чтобы вам было проще перемещаться по файлу. Как только вы окажетесь в нужном месте, вы сможете получить фактический дескриптор файла и работать с ним как обычно. В этом случае вы получаете позицию файла в конце последней строки, которую хотите сохранить, и усекаете файл до этой точки:</target>
        </trans-unit>
        <trans-unit id="867c8b371a8323be6dd9b1df9a9ab1f91f9da2fc" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits, including hexadecimal and binary digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd71d85a3c1d14096e3d0dd58527e3bd9ae1e0f0" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7425b7bd02b814bd9989aec894f5edbf698c87" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt; .</source>
          <target state="translated">Одним из полезного значения &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; является &lt;code&gt;less -+C -E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16342fee4b1c5a929e46db4d5c80b063641a8ef3" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54e615dc99abeb96e3dcca5dc954ca0886ad54d" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt; . The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt; , then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">Один из способов сделать это - использовать оператор подстановки и флаг double &lt;code&gt;/e&lt;/code&gt; . Первый &lt;code&gt;/e&lt;/code&gt; оценивает &lt;code&gt;$1&lt;/code&gt; на стороне замены и превращает его в &lt;code&gt;$foo&lt;/code&gt; . Второй / e начинается с &lt;code&gt;$foo&lt;/code&gt; и заменяет его своим значением. Тогда &lt;code&gt;$foo&lt;/code&gt; превращается в 'Fred', и это, наконец, то, что осталось в строке:</target>
        </trans-unit>
        <trans-unit id="bec707f167a013990074f651461c1eabbee251f8" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt;. The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt;, then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147fc583705f82dfe6c5d25a61550d429d726533" translate="yes" xml:space="preserve">
          <source>One way is to treat the return values as a list and index into it:</source>
          <target state="translated">Один из способов-рассматривать возвращаемые значения как список и индексировать в него:</target>
        </trans-unit>
        <trans-unit id="f26562604a7b87b255854e546e57c428a05a7c6b" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">Один из способов заглянуть внутрь внутренней кодировки символов Юникода - использовать &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; для получения байтов любой кодировки строки, или &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; чтобы получить байты кодировки UTF-8:</target>
        </trans-unit>
        <trans-unit id="77d927c43f13ed4bce0c8303d398089ab5954c32" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;unpack(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5979d9afcdae3acb920da4d4cb51dd1f70406d" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">Один из способов избежать конфликтов пространства имен в этом сценарии - преобразовать имя файла в гарантированно уникальное имя пакета, а затем скомпилировать код в этот пакет с помощью &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; . В приведенном ниже примере каждый файл будет скомпилирован только один раз. Или приложение может выбрать очистку таблицы символов, связанной с файлом, после того, как он больше не нужен. Используя &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv в perlapi&lt;/a&gt; , мы вызовем подпрограмму &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; которая находится в файле &lt;code&gt;persistent.pl&lt;/code&gt; , и передадим имя файла и логический флаг очистки / кеширования в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="dd0896a1b110e7eaa3676883c702b6cfbe8bca14" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;&quot;call_argv&quot; in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf742d4fed91595248e4e766bfc873dce09be23" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; before your method:</source>
          <target state="translated">Один из способов сделать это - ввести редкий вызов где-нибудь рядом с тем, что вы ищете. Например, вы можете добавить &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; перед своим методом:</target>
        </trans-unit>
        <trans-unit id="676f2533e9c53ebcfbdadc653fb856c314a5321b" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;study&lt;/code&gt; before your method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4920008fd4d756e499ea61ff8d38a964bd84a8" translate="yes" xml:space="preserve">
          <source>One way to find out how much memory is being used by Perl data structures is to install the Devel::Size module from CPAN: it gives you the minimum number of bytes required to store a particular data structure. Please be mindful of the difference between the size() and total_size().</source>
          <target state="translated">Один из способов узнать,сколько памяти используется Perl структурами данных,-установить модуль Devel::Size из CPAN:он дает минимальное количество байт,требуемое для хранения определенной структуры данных.Пожалуйста,помните о разнице между size()и total_size().</target>
        </trans-unit>
        <trans-unit id="00322fdac947c21ed0522e06d3fcf307d762cdd8" translate="yes" xml:space="preserve">
          <source>One way to get around this macro hell is to use the dumping functions in</source>
          <target state="translated">Один из способов обойти этот макрос-ад-использовать функции дампинга в</target>
        </trans-unit>
        <trans-unit id="eeda9b7821d8b2cc38107791f4013f43a6f0fb4b" translate="yes" xml:space="preserve">
          <source>One way you can contribute is to send test results for each module that you install. If you install the CPAN::Reporter module, you have the option to automatically generate and deliver test reports to CPAN Testers whenever you run tests on a CPAN package.</source>
          <target state="translated">Одним из способов внести свой вклад является отправка результатов тестирования для каждого модуля,который вы устанавливаете.Если вы установите модуль CPAN::Reporter,у вас будет возможность автоматически генерировать и доставлять отчеты о тестировании CPAN Testers всякий раз,когда вы запускаете тесты на CPAN пакете.</target>
        </trans-unit>
        <trans-unit id="31e7d725bdb8f49cf001861a4a5f8e1249780511" translate="yes" xml:space="preserve">
          <source>One work around is to apply encodings to STDOUT and STDERR as early as possible and before Test::More (or any other Test module) loads.</source>
          <target state="translated">Одной из задач является применение кодировок к STDOUT и STDERR как можно раньше и до загрузки Test::More (или любого другого тестового модуля).</target>
        </trans-unit>
        <trans-unit id="32a8b32d9a6fd88cc288ea2d28ee5e2eb22aa577" translate="yes" xml:space="preserve">
          <source>One would use either of these:</source>
          <target state="translated">Можно использовать любую из них:</target>
        </trans-unit>
        <trans-unit id="d2c29e5eed5921eb0c039672d0a71cd9e82eb212" translate="yes" xml:space="preserve">
          <source>One-Liner Command tips</source>
          <target state="translated">Советы однолинейной команды</target>
        </trans-unit>
        <trans-unit id="c123784569a1603a8fb4810445cb2d1918c306b4" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">Система с одним аргументом () (см. &lt;a href=&quot;functions/system&quot;&gt;System&lt;/a&gt; ), exec () (см. &lt;a href=&quot;functions/exec&quot;&gt;Exec&lt;/a&gt; ) с перенаправлением или метасимволами оболочки;</target>
        </trans-unit>
        <trans-unit id="ed7881b6406ffe431f1d2534257a9ed284c28da6" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;perlfunc#system&quot;&gt;&quot;system&quot; in perlfunc&lt;/a&gt;), exec() (see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486e0bed310a26c3d92d0d575fbba324cf28a58e" translate="yes" xml:space="preserve">
          <source>One-line BLOCK may be put on one line, including curlies.</source>
          <target state="translated">БЛОКИРОВКА на одну линию может быть поставлена на одну линию,включая кудряшки.</target>
        </trans-unit>
        <trans-unit id="58784e03024491cc3bfab913b657f51ddfe4ea02" translate="yes" xml:space="preserve">
          <source>One-way visibility means these firewalls try to make themselves invisible to users inside the firewall. An FTP data connection is normally created by sending your IP address to the remote server and then listening for the return connection. But the remote server will not be able to connect to you because of the firewall. For these types of firewall, FTP connections need to be done in a passive mode.</source>
          <target state="translated">Односторонняя видимость означает,что эти брандмауэры пытаются сделать себя невидимыми для пользователей внутри брандмауэра.FTP-соединение для передачи данных обычно создается путем отправки вашего IP-адреса на удаленный сервер,а затем прослушиванием обратного соединения.Но удаленный сервер не сможет соединиться с Вами из-за брандмауэра.Для таких брандмауэров FTP-соединения должны создаваться в пассивном режиме.</target>
        </trans-unit>
        <trans-unit id="e8b6f242edd1b92d8a41abce051eb1d237af2a29" translate="yes" xml:space="preserve">
          <source>Only 'chunked' &lt;code&gt;Transfer-Encoding&lt;/code&gt; is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61018f75253ce1e2ca9788d8ce3f56d39e963aa" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;#define&lt;/code&gt; symbols get translated; you must still correctly pack up your own arguments to pass as args for locking functions, etc.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; только символы #define ; вы все равно должны правильно упаковать свои собственные аргументы для передачи в качестве аргументов для функций блокировки и т. д.</target>
        </trans-unit>
        <trans-unit id="67da903cfa08873440f868f7f70e613649689d61" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in &lt;code&gt;PL_op-&amp;gt;op_targ&lt;/code&gt;), wasting a name SV for them doesn't make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e17eb2662bd037dd06b791727211df88880e9a" translate="yes" xml:space="preserve">
          <source>Only Intel C++ Compiler v12.1 has been tested. Other versions probably will work. Using Intel C++ Compiler instead of Visual C has the benefit of C99 compatibility which is needed by some CPAN XS modules, while maintaining compatibility with Visual C object code and Visual C debugging infrastructure unlike GCC.</source>
          <target state="translated">Только Intel C++Compiler v12.1 был протестирован.Вероятно,сработают и другие версии.Использование Intel C++Compiler вместо Visual C имеет преимущество совместимости с C99,которое необходимо некоторым модулям CPAN XS,при этом поддерживая совместимость с объектным кодом Visual C и отладочной инфраструктурой Visual C в отличие от GCC.</target>
        </trans-unit>
        <trans-unit id="2928fa0640b76bf7cac1897ae55dedc071303baa" translate="yes" xml:space="preserve">
          <source>Only a few characters (all of them being ASCII punctuation characters) are metacharacters. The most commonly used one is a dot &lt;code&gt;&quot;.&quot;&lt;/code&gt;, which normally matches almost any character (including a dot itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833cc9382a3040aac18b72415747288176c0756d" translate="yes" xml:space="preserve">
          <source>Only available in 5.9 and later.</source>
          <target state="translated">Доступно только в версии 5.9 и выше.</target>
        </trans-unit>
        <trans-unit id="30aa8b56cc2760e31377798957b93c84973ea0a2" translate="yes" xml:space="preserve">
          <source>Only certain operations (all originating outside Perl) should be affected, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791c96ad0d89f4c2a397055a16ea908da3689beb" translate="yes" xml:space="preserve">
          <source>Only certain operations originating outside Perl should be affected, as follows:</source>
          <target state="translated">Только определенные операции,происходящие за пределами Perl,должны быть затронуты следующим образом:</target>
        </trans-unit>
        <trans-unit id="be338b7ec52f196b66facaa0396ba0dea14b732e" translate="yes" xml:space="preserve">
          <source>Only gives you a reader, no &lt;code&gt;set_foo&lt;/code&gt; method is defined at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc54816219df4139d06acf1bbc8f828314bd1c1" translate="yes" xml:space="preserve">
          <source>Only gives you a write (&lt;code&gt;set_foo&lt;/code&gt;), no &lt;code&gt;foo&lt;/code&gt; method is defined at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332e2ea6f0f288093c9c025ee61a2877052c734b" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; and &quot;other&quot; read-write access. (RISC OS)</source>
          <target state="translated">Хорошо подходит только для изменения &quot;владельца&quot; и &quot;другого&quot; доступа к чтению и записи.(RISC OS)</target>
        </trans-unit>
        <trans-unit id="066c19c4ab7873f5036df4d41c91cf9966174fcb" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; read-write access, &quot;group&quot;, and &quot;other&quot; bits are meaningless. (Win32)</source>
          <target state="translated">Только изменение &quot;владельца&quot; доступа на чтение-запись,&quot;группы&quot; и &quot;других&quot; битов не имеет смысла.(Win32)</target>
        </trans-unit>
        <trans-unit id="e35c0d1762bd110103b5f686e3235899e75efbd0" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.</source>
          <target state="translated">Между фигурными скобками действительны только шестнадцатеричные цифры.Если встречается недопустимый символ,то выдается предупреждение и недопустимый символ и все последующие символы (действительные или недопустимые)внутри фигурных скобок отбрасываются.</target>
        </trans-unit>
        <trans-unit id="575a185473fa8007dc4a01bd9786576149895549" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt; . When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt; , and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt; . Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">После &lt;code&gt;\x&lt;/code&gt; допустимы только шестнадцатеричные цифры . Если за &lt;code&gt;\x&lt;/code&gt; следует менее двух действительных цифр, любые допустимые цифры будут дополнены нулями. Это означает, что &lt;code&gt;\x7&lt;/code&gt; будет интерпретироваться как &lt;code&gt;\x07&lt;/code&gt; , а одиночный &lt;code&gt;&quot;\x&quot;&lt;/code&gt; будет интерпретироваться как &lt;code&gt;\x00&lt;/code&gt; . Если число действительных цифр меньше двух, за исключением конца строки, будет выдано предупреждение. Обратите внимание, что хотя в предупреждении говорится, что недопустимый символ игнорируется, он игнорируется только как часть экранирования и все равно будет использоваться в качестве следующего символа в строке. Например:</target>
        </trans-unit>
        <trans-unit id="2b0998a6fdfd5f4525206c6e0b3be59bf209f58a" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt;. When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt;, and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt;. Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fefd95a29f89da3d95e7f9f02daa15254f112a5" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt; , including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt; , even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">В таблице символов пакета хранятся только идентификаторы, начинающиеся с букв (или подчеркивания). Все остальные символы хранятся в &lt;code&gt;main&lt;/code&gt; пакете , включая все переменные пунктуации, например $ _. Вдобавок, если они не определены, идентификаторы STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC и SIG должны быть включены в &lt;code&gt;main&lt;/code&gt; пакет , даже если они используются для других целей, кроме встроенных. Если у вас есть пакет с именем &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; , вы не можете использовать квалифицированную форму идентификатора, потому что вместо этого он будет интерпретироваться как сопоставление с шаблоном, подстановка или транслитерация.</target>
        </trans-unit>
        <trans-unit id="5258552aeae790433b734336886e3f62b2ea5d9a" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt;, including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt;, even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, or &lt;code&gt;y&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9758de0e100772430c6fab7d629b550064e3e906" translate="yes" xml:space="preserve">
          <source>Only implemented on sockets. (Win32, VMS)</source>
          <target state="translated">Реализуется только на розетках.(Win32,VMS)</target>
        </trans-unit>
        <trans-unit id="59e3f78d233739ccaf48b169b4ca0ebaefa1c7ab" translate="yes" xml:space="preserve">
          <source>Only in very early releases; is a subset of</source>
          <target state="translated">Только в очень ранних релизах;это подмножество</target>
        </trans-unit>
        <trans-unit id="e3b46eafe2952d2a80f0f05636b70051fd116c6a" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Только в очень редких случаях код должен работать с кодовыми точками Unicode (в отличие от нативных). В этих нескольких случаях вместо этого используйте &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d353340ff172b5c39b6a28e69782441add5fac" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead. If you are not absolutely sure this is one of those cases, then assume it isn't and use plain &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2ea2fb860587376b8c211541f4f73f5bfc66a" translate="yes" xml:space="preserve">
          <source>Only log errors:</source>
          <target state="translated">Только ошибки журнала:</target>
        </trans-unit>
        <trans-unit id="150ec79437779628315de700ea569bc7019ae33a" translate="yes" xml:space="preserve">
          <source>Only meaningful if PADNAMEt_OUTER is set.</source>
          <target state="translated">Имеет смысл только в том случае,если установлен PADNAMEt_OUTER.</target>
        </trans-unit>
        <trans-unit id="b3938c3e89a8c33d91a1c3ac566ca87a5a31bade" translate="yes" xml:space="preserve">
          <source>Only my/our variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way my/our variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in PL_op-&amp;gt;op_targ), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">Только мои / наши ячейки переменных получают допустимые имена. Остальные - это операционные цели / GV / константы, которые статически выделяются или разрешаются во время компиляции. У них нет имен, по которым их можно было бы найти в коде Perl во время выполнения через eval &quot;&quot;, как это могут быть мои / наши переменные. Поскольку их нельзя искать по &amp;laquo;имени&amp;raquo;, а только по их индексу, выделенному во время компиляции (который обычно находится в PL_op-&amp;gt; op_targ), тратить для них имя SV не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="1f33cd4a2033d06e1657cc72bf00ffb7bbc8903a" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt; , returning just the $dirs.</source>
          <target state="translated">Только в VMS (где нет двусмысленности между частями пути файла и каталога) и AmigaOS (возможно, из-за особенностей реализации в этом модуле) &lt;code&gt;dirname()&lt;/code&gt; работает как &lt;code&gt;fileparse($path)&lt;/code&gt; , возвращая только $ dirs.</target>
        </trans-unit>
        <trans-unit id="3f431144993e10d84cbfadd9a3e65deba1582a5e" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt;, returning just the $dirs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb371934ef388875a4c4834fa50d202d61748f1c" translate="yes" xml:space="preserve">
          <source>Only one encoding is allowed. If you combine modules in a program that have different encodings, only one will be actually used.</source>
          <target state="translated">Допускается только одна кодировка.Если вы комбинируете модули в программе,имеющие разные кодировки,то фактически будет использоваться только одна.</target>
        </trans-unit>
        <trans-unit id="99a4e5aa3778d9b7cf73bb7582fb4140a87cc1e7" translate="yes" xml:space="preserve">
          <source>Only one timer may be counting at once. Each call disables the previous timer, and an argument of &lt;code&gt;0&lt;/code&gt; may be supplied to cancel the previous timer without starting a new one. The returned value is the amount of time remaining on the previous timer.</source>
          <target state="translated">Одновременно может вести счет только один таймер. Каждый вызов отключает предыдущий таймер, и может быть передан аргумент &lt;code&gt;0&lt;/code&gt; для отмены предыдущего таймера без запуска нового. Возвращаемое значение - это количество времени, оставшееся на предыдущем таймере.</target>
        </trans-unit>
        <trans-unit id="f44c9ad6ed1548b5f164387565fa3e8cb708d77b" translate="yes" xml:space="preserve">
          <source>Only package variables (globals, even if localized) are visible to symbolic references. Lexical variables (declared with my()) aren't in a symbol table, and thus are invisible to this mechanism. For example:</source>
          <target state="translated">В символических ссылках видны только переменные пакета (глобусы,даже если они локализованы).Лексические переменные (объявленные функцией my())не находятся в таблице символов,и поэтому невидимы для этого механизма.Например:</target>
        </trans-unit>
        <trans-unit id="8a4fbadaeb2851f2ac1b0ed5194eefd55b4c5de6" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">Только доступ для чтения (через выборку значения или &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; ) приводит к вызовам функций; доступ к изменению выполняется как с обычным хешем.</target>
        </trans-unit>
        <trans-unit id="52379b3e8ed9b5889624849f89178e4a78f9060a" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;exists&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7947c4bc8660c246e83d1a75c7b2184fd12d7e5" translate="yes" xml:space="preserve">
          <source>Only reliable on sockets. (RISC OS)</source>
          <target state="translated">Надежность только на розетках.(RISC OS)</target>
        </trans-unit>
        <trans-unit id="3d6a8b56f94127e52f27217f818b2868b3bb285a" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;&quot;add_style&quot;&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;&quot;add_callback&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb6f92993012f8b0d4ace849f814451bcfe4e88" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;.</source>
          <target state="translated">Только некоторые из них используются стандартными стилями, другие предназначены для вас, чтобы вы могли вникнуть в механику optree, если вы хотите добавить новый стиль (см. &lt;a href=&quot;#add_style&quot;&gt;Add_style&lt;/a&gt; ниже), который их использует. Вы также можете добавить новые, используя &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e48dbe443fdc8ea64a9d98b0d46ac35972125215" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Bzip2&lt;/code&gt; module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aad383963ab78287aafa9360d0376650b94059" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Lzma&lt;/code&gt; module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3b6a74b3cb931875055e55d8dd7ade28775580" translate="yes" xml:space="preserve">
          <source>Only text files containing at least one valid POD command are found.</source>
          <target state="translated">Найдены только текстовые файлы,содержащие хотя бы одну действительную команду POD.</target>
        </trans-unit>
        <trans-unit id="f768ea168f773a1d4344405cac8e79c05d1cb7bc" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;&quot;\&quot;&lt;/code&gt; is always a metacharacter. The others are metacharacters just sometimes. The following tables lists all of them, summarizes their use, and gives the contexts where they are metacharacters. Outside those contexts or if prefixed by a &lt;code&gt;&quot;\&quot;&lt;/code&gt;, they match their corresponding punctuation character. In some cases, their meaning varies depending on various pattern modifiers that alter the default behaviors. See &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f9d19343c8e9d3fc7cfa076da595c837a27fd3" translate="yes" xml:space="preserve">
          <source>Only the INPUT part of this is implemented (Perl to XSUB) and there are no known users in core or on CPAN.</source>
          <target state="translated">Реализована только часть INPUT (от Perl до XSUB)и нет известных пользователей в ядре или на CPAN.</target>
        </trans-unit>
        <trans-unit id="71019c006a2a3164840206c64e5cdd82e48eb2b0" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; is considered. (This is important only if &lt;code&gt;&quot;S&quot;&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e92fe265d981838f6731ee2a1313d924147a101" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;S&lt;/code&gt; is considered. (This is important only if &lt;code&gt;S&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">Рассматривается только лучшее совпадение для &lt;code&gt;S&lt;/code&gt; .(Это важно, только если &lt;code&gt;S&lt;/code&gt; имеет захватывающие круглые скобки, а обратные ссылки используются где-то еще во всем регулярном выражении.)</target>
        </trans-unit>
        <trans-unit id="8e81698472dd458b4e2c811d33c204c45a731d7f" translate="yes" xml:space="preserve">
          <source>Only the latest runtime is supported, currently &lt;code&gt;0.9d fix 03&lt;/code&gt;. Perl may run under earlier versions of EMX, but this is not tested.</source>
          <target state="translated">Поддерживается только последняя &lt;code&gt;0.9d fix 03&lt;/code&gt; среды выполнения, в настоящее время 0.9d fix 03 . Perl может работать под более ранними версиями EMX, но это не проверено.</target>
        </trans-unit>
        <trans-unit id="ffed3ab3981beea3a9602d82e26d788b9e9c1484" translate="yes" xml:space="preserve">
          <source>Only the modification time is updated. (VMS, RISC OS)</source>
          <target state="translated">Обновляется только время модификации.(ЗИС,RISC OS)</target>
        </trans-unit>
        <trans-unit id="a5196d88a77f964c944cd0486d4d8632d3d224b8" translate="yes" xml:space="preserve">
          <source>Only the values for English are returned. &lt;code&gt;YESSTR&lt;/code&gt; and &lt;code&gt;NOSTR&lt;/code&gt; have been removed from POSIX 2008, and are retained here for backwards compatibility. Your platform's &lt;code&gt;nl_langinfo&lt;/code&gt; may not support them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa8446a580db25edb8f05217d7fb57147e13abf" translate="yes" xml:space="preserve">
          <source>Only up to Perl 5.9.4</source>
          <target state="translated">Только до Perl 5.9.4.</target>
        </trans-unit>
        <trans-unit id="ac1ac5484f948b783774a56425a6df37a8f81a3b" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the integer value of the REGEX stored in the MAGIC.</source>
          <target state="translated">Действительно только на r-magic,возвращает целое значение REGEX,сохраненное в MAGIC.</target>
        </trans-unit>
        <trans-unit id="9f66fc81372c8ac766a246f4baea414733aad7cf" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the string that generated the regexp.</source>
          <target state="translated">Действует только на r-magic,возвращает строку,которая сгенерировала регенерацию.</target>
        </trans-unit>
        <trans-unit id="b4b3937a0e7df666bbee5731bdcd7cfebd5a56b8" translate="yes" xml:space="preserve">
          <source>Only votes if $source is an array, or a scalar with newlines. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6f39472d96fc49b5d83aad7e124fec307fa8f3" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977cc058c727306e27dd1d2114879e4b0b58691f" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a regular file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30aa9fef235074c84d54a1603c93e02bcc5a7db6" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like an executable file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61aeee0d09958da7f9004eaa2f24e389c377add" translate="yes" xml:space="preserve">
          <source>Only when perl was compiled with ithreads.</source>
          <target state="translated">Только когда Perl был скомпилирован с помощью ithreads.</target>
        </trans-unit>
        <trans-unit id="cd0ef3273488ddac67311854e00313faa5aef30e" translate="yes" xml:space="preserve">
          <source>Oodles of very useful information in there - this seems to be the way forward.</source>
          <target state="translated">Удлы очень полезной информации-это,кажется,и есть путь вперед.</target>
        </trans-unit>
        <trans-unit id="95ff9f7a98d97e5bb7dd5d8797ddd23ecbc3a49a" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;  U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">Ой, мы забыли одну вещь: что, если в начале шаблона есть пробелы? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot; U*&quot;, @stuff)&lt;/code&gt; будет иметь &lt;code&gt;U&lt;/code&gt; в качестве первого активного символа, даже если это не первый элемент в шаблоне. В этом случае мы должны продвигать &lt;code&gt;patcopy&lt;/code&gt; вместе с &lt;code&gt;pat&lt;/code&gt; , когда видим пробелы:</target>
        </trans-unit>
        <trans-unit id="fe3ce4b3ad2d706be60b57c6678f0db7ee5828e3" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;pack(&quot; U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce63b9b9665fa74c8ca88979a5af8db7577060be" translate="yes" xml:space="preserve">
          <source>OpHAS_SIBLING</source>
          <target state="translated">OpHAS_SIBLING</target>
        </trans-unit>
        <trans-unit id="8df5fc95b743ffdf06c754aebef9648088f82a06" translate="yes" xml:space="preserve">
          <source>OpLASTSIB_set</source>
          <target state="translated">OpLASTSIB_set</target>
        </trans-unit>
        <trans-unit id="6a2ac06a5c16d049ff2c9de33162907d6eaa1974" translate="yes" xml:space="preserve">
          <source>OpMAYBESIB_set</source>
          <target state="translated">OpMAYBESIB_set</target>
        </trans-unit>
        <trans-unit id="95d54e30cf7a8a2ef55bbad2e9fb47bd84433509" translate="yes" xml:space="preserve">
          <source>OpMORESIB_set</source>
          <target state="translated">OpMORESIB_set</target>
        </trans-unit>
        <trans-unit id="ad6188b517e063a47318e5c2bad924c90d8e314e" translate="yes" xml:space="preserve">
          <source>OpSIBLING</source>
          <target state="translated">OpSIBLING</target>
        </trans-unit>
        <trans-unit id="74d23243f911dfb26f7142c0a3c3910d6d1436bc" translate="yes" xml:space="preserve">
          <source>Opcode</source>
          <target state="translated">Opcode</target>
        </trans-unit>
        <trans-unit id="d74efeac75c3ed1e29e1ef5d2a48fa327033703a" translate="yes" xml:space="preserve">
          <source>Opcode - Disable named opcodes when compiling perl code</source>
          <target state="translated">Опкод-Отключить именованные опкоды при компиляции perl кода.</target>
        </trans-unit>
        <trans-unit id="f07e565d51e16d912b38ef0d870eb764e49b25e3" translate="yes" xml:space="preserve">
          <source>Opcode Functions</source>
          <target state="translated">Опкод Функции</target>
        </trans-unit>
        <trans-unit id="cf9b77061f7b3126b49d50a6fa68f7ca8c26b7a3" translate="yes" xml:space="preserve">
          <source>Open</source>
          <target state="translated">Open</target>
        </trans-unit>
        <trans-unit id="96b61e5d9d0edd94f6948898f1398f5d478335a2" translate="yes" xml:space="preserve">
          <source>Open &quot;membername&quot; from the zip file for reading.</source>
          <target state="translated">Откройте &quot;membername&quot; из zip-файла для чтения.</target>
        </trans-unit>
        <trans-unit id="55f7ee4c6a28ca478d6d447371d4c70238f47b16" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See</source>
          <target state="translated">Откройте /dev/tty и используйте TIOCNOTTY ioctl на нем.См..</target>
        </trans-unit>
        <trans-unit id="bc45a01f475e91b2d1ed078654549eddc2aa2632" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See &lt;a href=&quot;http://man.he.net/man1/tty&quot;&gt;tty(1)&lt;/a&gt; for details. Or better yet, you can just use the &lt;code&gt;POSIX::setsid()&lt;/code&gt; function, so you don't have to worry about process groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb6e0b133b1b1b5b97afd41a0d0173daaa4add6" translate="yes" xml:space="preserve">
          <source>Open Edition (UNIX System Services) from V2R8 onward does support #!/path/to/perl script invocation. There is a PTF available from IBM for V2R7 that will allow shell/kernel support for #!. USS releases prior to V2R7 did not support the #! means of script invocation. If you are running V2R6 or earlier then see:</source>
          <target state="translated">Open Edition (UNIX System Services)с V2R8 и далее поддерживает #!/path/to/perl вызов скрипта.Есть PTF,доступный в IBM для V2R7,который позволит shell/kernel поддерживать #! Релизы USS до V2R7 не поддерживали #! средства вызова скриптов.Если вы используете V2R6 или более раннюю версию,то смотрите:</target>
        </trans-unit>
        <trans-unit id="adcf2a78c9cad4950930fad20f18fb46173fc5ee" translate="yes" xml:space="preserve">
          <source>Open Perl IDE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72f9cc67788da43d43bb9ed1f39ccdfc57b884" translate="yes" xml:space="preserve">
          <source>Open Perl IDE is an integrated development environment for writing and debugging Perl scripts with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.</source>
          <target state="translated">Open Perl IDE-это интегрированная среда разработки для написания и отладки Perl скриптов с дистрибутивом ActiveState ActivePerl под Windows 95/98/NT/2000.</target>
        </trans-unit>
        <trans-unit id="23e95096990f8472afd6cb3709ce6af6451d33e6" translate="yes" xml:space="preserve">
          <source>Open a directory for reading.</source>
          <target state="translated">Откройте каталог для чтения.</target>
        </trans-unit>
        <trans-unit id="8ad49f69af5decd196c780b9f3d0aaa3e3816d7b" translate="yes" xml:space="preserve">
          <source>Open a file for read and write.</source>
          <target state="translated">Откройте файл для чтения и записи.</target>
        </trans-unit>
        <trans-unit id="1e59fee2b2d0c9f3865876e8e0e389d326d3f7c1" translate="yes" xml:space="preserve">
          <source>Open a file for reading for writing. This returns file descriptors, not Perl filehandles. Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">Откройте файл для чтения для записи. Это возвращает дескрипторы файлов, а не дескрипторы файлов Perl. Используйте &lt;code&gt;POSIX::close&lt;/code&gt; чтобы закрыть файл.</target>
        </trans-unit>
        <trans-unit id="6c23e6c0a506e51b8807fe030bb649eaa2c7d5d5" translate="yes" xml:space="preserve">
          <source>Open a file for write, with truncation.</source>
          <target state="translated">Откройте файл для записи,с усечением.</target>
        </trans-unit>
        <trans-unit id="4308ff2808cb74655d1f6985fb86c3f779077365" translate="yes" xml:space="preserve">
          <source>Open a file read-only with mode 0666.</source>
          <target state="translated">Откройте файл только для чтения в режиме 0666.</target>
        </trans-unit>
        <trans-unit id="83b3247daf1ae38653a1c2f6dc56f1f4dd823340" translate="yes" xml:space="preserve">
          <source>Open a process for both reading and writing using open2()</source>
          <target state="translated">Откройте процесс чтения и записи с помощью open2().</target>
        </trans-unit>
        <trans-unit id="2f8a8512d160e2040075be8a77906336494c9074" translate="yes" xml:space="preserve">
          <source>Open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">Откройте процесс чтения,записи и обработки ошибок с помощью функции open3().</target>
        </trans-unit>
        <trans-unit id="3de25d7ff3a7f69d51ceb431d7513e0facbf39f4" translate="yes" xml:space="preserve">
          <source>Open a shell on the Synology using ssh and become root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e426002e74b080358a024e5f7a561b3384b60d" translate="yes" xml:space="preserve">
          <source>Open directory handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a5a34e79d6531a1ea990bc264a097033a1025e" translate="yes" xml:space="preserve">
          <source>Open filehandles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92666893f36170e45fd93845fbf133686bc20a39" translate="yes" xml:space="preserve">
          <source>Open handles to files, directories and network sockets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ce744f7faf84a934a5966a77055041e905f34c" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open возвращает ненулевое значение в случае успеха, в противном случае - неопределенное значение. Если &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; связано с конвейером, возвращаемое значение является pid подпроцесса.</target>
        </trans-unit>
        <trans-unit id="78b623ce85a0de7052165209a2216ebe49f4e867" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open возвращает ненулевое значение в случае успеха, в противном случае - неопределенное значение. Если &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; связано с конвейером, возвращаемое значение является pid подпроцесса.</target>
        </trans-unit>
        <trans-unit id="f405ae83374967e27b5349888fde9a222df40df7" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;open&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47834b64146be82f867d9923797633975d9cd92f" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt; . The</source>
          <target state="translated">Open должен (возможно, косвенно) вызвать &lt;code&gt;PerlIO_allocate()&lt;/code&gt; чтобы выделить слот в таблице и связать его с информацией о слоях для открытого файла, вызвав &lt;code&gt;PerlIO_push&lt;/code&gt; . В</target>
        </trans-unit>
        <trans-unit id="6ae8476e410284d0c0ba1054077caf01d110fd6a" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt;. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b90a08dc8612f90c1076481f4ad779beb7a5f7e" translate="yes" xml:space="preserve">
          <source>Open the scalar handle on a new scalar, pointed to by SCALARREF. If no SCALARREF is given, a &quot;private&quot; scalar is created to hold the file data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa04c7c6f525f721026d1ba438790f3fcc864164" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt; , and with facility &lt;code&gt;LOCAL0&lt;/code&gt; :</source>
          <target state="translated">Откройте системный журнал с параметрами &lt;code&gt;ndelay&lt;/code&gt; и &lt;code&gt;pid&lt;/code&gt; , а также &lt;code&gt;LOCAL0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8811a98a6a9653fddfc77b8259113c776713824a" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt;, and with facility &lt;code&gt;LOCAL0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="49536a6420d53dc725b117e3d37bfc34dfb9bef1" translate="yes" xml:space="preserve">
          <source>OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</source>
          <target state="translated">Дампы ядра OpenBSD из getprotobyname_r и getervbyname_r с помощью ithreads</target>
        </trans-unit>
        <trans-unit id="64310839a246c6fc794d722f4304cd08f25d7b05" translate="yes" xml:space="preserve">
          <source>OpenVMS</source>
          <target state="translated">OpenVMS</target>
        </trans-unit>
        <trans-unit id="d32dc42d00fa4f78f0a59f030ed60cd6a30b3295" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS
/CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alpha v7.3-1 и новее, а также все версии OpenVMS I64 поддерживают чувствительность к регистру как настройку процесса (см. &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl в настоящее время не поддерживает чувствительность к регистру в VMS, но может в будущем, поэтому программы Perl должны использовать метод &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; для определения состояния, а не переменную &lt;code&gt;$^O&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9ff604a4dd28e6202581dca695c5bed829ec062" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt;). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580bd0fefd9022c163462e267d5f62605679e1bf" translate="yes" xml:space="preserve">
          <source>Opening Binary Files</source>
          <target state="translated">Открытие бинарных файлов</target>
        </trans-unit>
        <trans-unit id="3b6c1a6dbd679781e98b430deca927902564168e" translate="yes" xml:space="preserve">
          <source>Opening Pipes</source>
          <target state="translated">Разрывные трубы</target>
        </trans-unit>
        <trans-unit id="97614657c24973c63e30d6aea12f0ee16c28cc0b" translate="yes" xml:space="preserve">
          <source>Opening Text Files</source>
          <target state="translated">Открытие текстовых файлов</target>
        </trans-unit>
        <trans-unit id="36680b4c4dae060cef49428930207438c7efaa37" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Reading</source>
          <target state="translated">Открытие текстовых файлов для чтения</target>
        </trans-unit>
        <trans-unit id="2a72037dbe3a876109b6617803140785c781433b" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Writing</source>
          <target state="translated">Открытие текстовых файлов для записи</target>
        </trans-unit>
        <trans-unit id="d41c1a93b08d5c6da84630f4e7549a5cfa0c9f29" translate="yes" xml:space="preserve">
          <source>Opening a Berkeley DB Database File</source>
          <target state="translated">Открытие файла базы данных Berkeley DB</target>
        </trans-unit>
        <trans-unit id="03b0ff1f775aaa0c11a96201f8ff9e088550422d" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into a command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af9988c3fefcdee028653737bea0a8e9c417094" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into an in-memory scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821c0d97ab3d21f2ce24f411389616d6c9dc3c0d" translate="yes" xml:space="preserve">
          <source>Opening a pipe for reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1420eefdd30517effef954306a645ff5d1c69e" translate="yes" xml:space="preserve">
          <source>Opening a pipe for writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c901450d25c1b4adffc158756d930772312effed" translate="yes" xml:space="preserve">
          <source>Opening a process does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">Открытие процесса не позволяет автоматически промывать выходные ручки на некоторых платформах.(SunOS,Solaris,HP-UX)</target>
        </trans-unit>
        <trans-unit id="b294c249cb9dd744fe8333a0cf9a3eaca337d759" translate="yes" xml:space="preserve">
          <source>Opening and setup functions</source>
          <target state="translated">Функции открытия и настройки</target>
        </trans-unit>
        <trans-unit id="9d1b0daa9340247fc5dd5775b7b3c96ab82ed183" translate="yes" xml:space="preserve">
          <source>Opening brace lines up with &quot;if&quot; when conditional spans multiple lines; should be at end-of-line otherwise</source>
          <target state="translated">Открывать линии скобки с надписью &quot;if&quot;,когда условные линии охватывают несколько линий;в противном случае они должны быть в конце линии.</target>
        </trans-unit>
        <trans-unit id="4ac11216b92d2f325685b22de245cded12e40d13" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;&quot;LIGHTWEIGHT CALLBACKS&quot; in perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1d6b2927f0e3d3a000bd5c08d3176bb52e234e" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающаяся скобка для облегченного обратного вызова. См. &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;ОБЛЕГЧЕННЫЕ ОТВЕТЫ в perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="626f042395527b903c8db8f898fdb1f1cdc87f96" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;&lt;a href=&quot;#PUTBACK&quot;&gt;&quot;PUTBACK&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2922ae0d4b2356e8683f8338a16e139ec4c04e6a" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;PUTBACK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающая скобка для аргументов обратного вызова. Смотрите &lt;code&gt;PUTBACK&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31ad94341ea4379f427305bb05c070cf8053b4ad" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;&lt;a href=&quot;#FREETMPS&quot;&gt;&quot;FREETMPS&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cd04a850fb6ef4b1c1ae0773c22c62016e5236" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;FREETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающая скобка для временных конструкций при обратном вызове. Смотрите &lt;code&gt;FREETMPS&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e132601e5a7953c8bcffa1c453157f71ea1d34e" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;&lt;a href=&quot;#LEAVE&quot;&gt;&quot;LEAVE&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3379b419b90643ab2744dfbdcecf5edbb46257a1" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;LEAVE&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">Открывающая скобка при обратном вызове. Смотрите &lt;code&gt;LEAVE&lt;/code&gt; и &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb5320c0f77aa06e6c4f3f19f91a0a627e401dd" translate="yes" xml:space="preserve">
          <source>Opening curly on same line as keyword, if possible, otherwise line up.</source>
          <target state="translated">Открытие фигурным шрифтом на той же строке,что и ключевое слово,если это возможно,в противном случае-в строке.</target>
        </trans-unit>
        <trans-unit id="702f344a10799adb9c373ae43617c29a1d640fe4" translate="yes" xml:space="preserve">
          <source>Opening files for read-write is currently not supported if they use stdio (normal perl file handles).</source>
          <target state="translated">Открытие файлов для чтения-записи в настоящее время не поддерживается,если они используют stdio (обычные дескрипторы perl файлов).</target>
        </trans-unit>
        <trans-unit id="414a4a46ddb98d37ef4a18659fc5e836c58095fc" translate="yes" xml:space="preserve">
          <source>Opening in-memory files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85c9c937148eb202d62793f91340ba09b2f7a5e" translate="yes" xml:space="preserve">
          <source>Opening the data file in write-only or append mode is not supported.</source>
          <target state="translated">Открытие файла данных в режиме только для записи или в режиме добавления не поддерживается.</target>
        </trans-unit>
        <trans-unit id="c745d61fd7e06451beaeff422ae86fd1baafa519" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;$output&lt;/code&gt; in append mode.</source>
          <target state="translated">Открывает &lt;code&gt;$output&lt;/code&gt; в режиме добавления.</target>
        </trans-unit>
        <trans-unit id="96c4834766ebccdcd74e84c8bb745c2565822fc0" translate="yes" xml:space="preserve">
          <source>Opens a Perl file handle based on an already open Win32 native file handle [much like C's &lt;code&gt;fdopen()&lt;/code&gt; does with a file descriptor]. Returns a true value if the open operation succeeded. For failure, returns a false value and sets &lt;code&gt;$!&lt;/code&gt; [and possibly &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt;] to the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8372328aea71570194ef6ece0a3348d285cc61e1" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#telldir-DIRHANDLE&quot;&gt;&lt;code&gt;telldir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seekdir-DIRHANDLE%2CPOS&quot;&gt;&lt;code&gt;seekdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#rewinddir-DIRHANDLE&quot;&gt;&lt;code&gt;rewinddir&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#closedir-DIRHANDLE&quot;&gt;&lt;code&gt;closedir&lt;/code&gt;&lt;/a&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. Dirhandles are the same objects as filehandles; an I/O object can only be open as one of these handle types at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d174f108cd7d61c427811f31c1c3a17b3fd039" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">Открывает каталог с именем EXPR для обработки &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; . В случае успеха возвращает true. DIRHANDLE может быть выражением, значение которого может использоваться как косвенный дескриптор dirhandle, обычно это настоящее имя dirhandle. Если DIRHANDLE - неопределенная скалярная переменная (или массив, или хеш-элемент), переменной назначается ссылка на новый анонимный дескриптор dir; то есть он самовживителен. У DIRHANDLE есть собственное пространство имен, отдельное от FILEHANDLE.</target>
        </trans-unit>
        <trans-unit id="bde0bd94d408d74305c3ef236f8e210809c61889" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">Открывает каталог с именем EXPR для обработки &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; . В случае успеха возвращает true. DIRHANDLE может быть выражением, значение которого может использоваться как косвенный дескриптор dirhandle, обычно это настоящее имя dirhandle. Если DIRHANDLE - неопределенная скалярная переменная (или массив, или хеш-элемент), переменной назначается ссылка на новый анонимный дескриптор dir; то есть он самовживителен. У DIRHANDLE есть собственное пространство имен, отдельное от FILEHANDLE.</target>
        </trans-unit>
        <trans-unit id="249fc18914652625c802e629d561a8d541cf9f3e" translate="yes" xml:space="preserve">
          <source>Opens a file descriptor [&lt;code&gt;$ivFD&lt;/code&gt;] based on an already open Win32 native file handle, &lt;code&gt;$hNativeHandle&lt;/code&gt;. This just calls the Win32-specific C routine &lt;code&gt;_open_osfhandle()&lt;/code&gt; or Perl's &quot;improved&quot; version called &lt;code&gt;win32_open_osfhandle()&lt;/code&gt;. Prior to Perl5.005 and in Cygwin Perl, C's &lt;code&gt;_open_osfhandle()&lt;/code&gt; is called which will fail if &lt;code&gt;GetFileType($hNativeHandle)&lt;/code&gt; would return &lt;code&gt;FILE_TYPE_UNKNOWN&lt;/code&gt;. For Perl5.005 and later, &lt;code&gt;OsFHandleOpenFd&lt;/code&gt; calls &lt;code&gt;win32_open_osfhandle()&lt;/code&gt; from the Perl DLL which doesn't have this restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2665f3d96f1b25c433ed44735df54d5716eb0ca" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6eec3f73e02b66c5dbdd58e24c78d1b02394cb" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;code&gt;$|&lt;/code&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">Открывает пару подключенных каналов, как соответствующий системный вызов. Обратите внимание: если вы настроили цикл конвейерных процессов, может возникнуть взаимоблокировка, если вы не будете очень осторожны. Кроме того, обратите внимание, что каналы Perl используют буферизацию ввода-вывода, поэтому вам может потребоваться установить &lt;code&gt;$|&lt;/code&gt; очищать WRITEHANDLE после каждой команды, в зависимости от приложения.</target>
        </trans-unit>
        <trans-unit id="97d9deba78acd708222827724c50fc7000bf21a2" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Открывает сокет указанного типа и присоединяет его к дескриптору файла SOCKET. DOMAIN, TYPE и PROTOCOL задаются так же, как и для одноименного системного вызова. Сначала вы должны &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; чтобы импортировать правильные определения. См. Примеры в &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bf5e36d7b7be8ff46fbdc02b28950f2a5493007" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Открывает сокет указанного типа и присоединяет его к дескриптору файла SOCKET. DOMAIN, TYPE и PROTOCOL задаются так же, как и для одноименного системного вызова. Сначала вы должны &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; чтобы импортировать правильные определения. См. Примеры в &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4febc0253215fa9b6c0a61a1123c275d66541f" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;use Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b29b07c25945e487dbff4de1e81a446b3bf071a" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and returns it. Domain, type, and protocol are specified the same as for the syscall of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f043104d316702a10e0ee9e23884fe89eeee7102" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</source>
          <target state="translated">Открывает файл,имя которого указано в EXPR,и связывает его с FILEHANDLE.</target>
        </trans-unit>
        <trans-unit id="f8d3156ec9740e3cf785b92426587c9913bf7a48" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's</source>
          <target state="translated">Открывает файл,имя которого задано FILENAME,и связывает его с FILEHANDLE.Если FILEHANDLE является выражением,его значение используется как реальная нужная файловая ручка;неопределенный скаляр будет соответствующим образом автоповинован.Эта функция вызывает базовую операционную систему</target>
        </trans-unit>
        <trans-unit id="4b9ccea513e25adc54a594c4a2c7b7e82197b4e8" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; function with the parameters FILENAME, MODE, and PERMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5a806f4d052ec496b3b922107438a0577f84fc" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : see &lt;a href=&quot;#Facilities&quot;&gt;Facilities&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">Открывает системный журнал. &lt;code&gt;$ident&lt;/code&gt; добавляется к каждому сообщению. &lt;code&gt;$logopt&lt;/code&gt; содержит ноль или более параметров, описанных ниже. &lt;code&gt;$facility&lt;/code&gt; указывает часть системы, о которой следует сообщать, например, &lt;code&gt;LOG_USER&lt;/code&gt; или &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : см. Список известных средств в разделе &amp;laquo; &lt;a href=&quot;#Facilities&quot;&gt;Средства&amp;raquo;&lt;/a&gt; , а в документации по &lt;code&gt;syslog(3)&lt;/code&gt; - средства, доступные в вашей системе. Проверьте &lt;a href=&quot;#SEE-ALSO&quot;&gt;СМОТРИ ТАКЖЕ&lt;/a&gt; полезные ссылки. Функцию можно указать в виде строки или числового макроса.</target>
        </trans-unit>
        <trans-unit id="d67ac2c393c850f9198943cd6ad27b36c7d7a81b" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt;: see &lt;a href=&quot;#Facilities&quot;&gt;&quot;Facilities&quot;&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7ead7f438c26f4d24f0c5553cfa1b2b48237a8" translate="yes" xml:space="preserve">
          <source>Operand with no preceding operator in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7befdfbc60eb47b3289957505fb12ce62daabea" translate="yes" xml:space="preserve">
          <source>Operating System Interfaces</source>
          <target state="translated">Интерфейсы операционной системы</target>
        </trans-unit>
        <trans-unit id="b9967a65c2c4c5007de8b77bf65865521f0d26c6" translate="yes" xml:space="preserve">
          <source>Operating on references to hashes.</source>
          <target state="translated">Работает по ссылкам на хэши.</target>
        </trans-unit>
        <trans-unit id="ac9fb6f30a90f215146103f81004effdabcea9ae" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for UTF-16 surrogate U+%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b576c5bb0b11a4350e3bf4fdc21259831b2084c" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for non-Unicode code point 0x%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d671b8f2f76102a15b0bf4d4a39249d6ad4b4ece" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot;: no method found, %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28848b2a51553304abcd6de3ae0236ffb496efe" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments which is exactly what you expect.</source>
          <target state="translated">Операции с перегруженными операторами сохраняют аргументы,которые в точности соответствуют вашим ожиданиям.</target>
        </trans-unit>
        <trans-unit id="d4e4327f6fb8077a49e03daa6c0ea206ecb5c16a" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</source>
          <target state="translated">Операции с перегруженными операторами сохраняют аргументы,а это именно то,чего вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="f921f14a57cf5d524fbd5fad00e7ed999feb448d" translate="yes" xml:space="preserve">
          <source>Operator Names and Operator Lists</source>
          <target state="translated">Имена и списки операторов</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="translated">Перегрузка оператора</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">Приоритет оператора и партнерская деятельность</target>
        </trans-unit>
        <trans-unit id="11c9953040dd3157f9326929003c9899b7cffb21" translate="yes" xml:space="preserve">
          <source>Operator associativity</source>
          <target state="translated">Ассоциативность оператора</target>
        </trans-unit>
        <trans-unit id="08ca8c19d61f0facd586cd4f482f39a253b12167" translate="yes" xml:space="preserve">
          <source>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; call. Values specified as strings are interpreted as method names. Thus</source>
          <target state="translated">Реализации операторов (значения) могут быть подпрограммами, ссылками на подпрограммы или анонимными подпрограммами - другими словами, все, что разрешено внутри вызова &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; . Значения, указанные как строки, интерпретируются как имена методов. Таким образом</target>
        </trans-unit>
        <trans-unit id="4f99a8916efac564a63d50ce560cad0dd70e1540" translate="yes" xml:space="preserve">
          <source>Operator names are typically small lowercase words like enterloop, leaveloop, last, next, redo etc. Sometimes they are rather cryptic like gv2cv, i_ncmp and ftsvtx.</source>
          <target state="translated">Имена операторов обычно представляют собой маленькие строчные слова,такие как enterloop,leaveloop,last,next,redo и т.д.Иногда они довольно загадочны,как gv2cv,i_ncmp и ftsvtx.</target>
        </trans-unit>
        <trans-unit id="0bc65caf3b0a75a378aedfadf66730c78a4537cf" translate="yes" xml:space="preserve">
          <source>Operator or semicolon missing before %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="translated">Первенство оператора</target>
        </trans-unit>
        <trans-unit id="b559bbb40846a93d37a125fab7a9a1b57c0dd2f9" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity work in Perl more or less like they do in mathematics.</source>
          <target state="translated">Приоритет оператора и ассоциативность работают на Perl более или менее так же,как и в математике.</target>
        </trans-unit>
        <trans-unit id="6852b1cd2bb1031ac4d81d694fd94535c3eb3d11" translate="yes" xml:space="preserve">
          <source>Operator tags can be used to refer to groups (or sets) of operators. Tag names always begin with a colon. The Opcode module defines several optags and the user can define others using the define_optag function.</source>
          <target state="translated">Метки операторов могут использоваться для обозначения групп (или наборов)операторов.Имена тегов всегда начинаются с двоеточия.Модуль Opcode определяет несколько оптагов,а пользователь может определить другие с помощью функции define_optag.</target>
        </trans-unit>
        <trans-unit id="093964ff1bd20f7f1bfa027cf984852f6646a0fc" translate="yes" xml:space="preserve">
          <source>Operator vs literal overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="63e0a2d0a1f37e46caa267d78be1feaf655b0cda" translate="yes" xml:space="preserve">
          <source>Operators dealing with filenames are examples.</source>
          <target state="translated">Примером могут служить операторы,работающие с именами файлов.</target>
        </trans-unit>
        <trans-unit id="55ddd8565a51d103a65dc3c453ea6bce04b13905" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">Такие операторы, как &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; переводят аргументы в формат с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="004496b42fcc360f8e82fa5c56c3b096a2155421" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; force arguments to floating point format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1c419f9c87704707f20d16f008ba41b567fa7e" translate="yes" xml:space="preserve">
          <source>Operators which expect a string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192b9459597426145afa81f1d9a3ad900bb8bd5d" translate="yes" xml:space="preserve">
          <source>Operators which expect an integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864704fd78dbf2c79b9e58c4ea43f3220669cded" translate="yes" xml:space="preserve">
          <source>Ops such as chdir obviously effect the process as a whole and not just the code in the compartment. Ops such as rand and srand have a similar but more subtle effect.</source>
          <target state="translated">Очевидно,что такие операции,как chdir,влияют на процесс в целом,а не только на код в отсеке.Такие операторы,как rand и srand,имеют похожий,но более тонкий эффект.</target>
        </trans-unit>
        <trans-unit id="977af567e0cb291a9f2082343e1b048e5433a7e1" translate="yes" xml:space="preserve">
          <source>Opsets may be manipulated using the perl bit vector operators &amp;amp; (and), | (or), ^ (xor) and ~ (negate/invert).</source>
          <target state="translated">Опциями можно управлять с помощью операторов битовых векторов Perl &amp;amp; (и), | (или), ^ (xor) и ~ (отрицание / инвертирование).</target>
        </trans-unit>
        <trans-unit id="0b7b13995f2b05a4fbd9b6bef85fdd40cc461955" translate="yes" xml:space="preserve">
          <source>OptiPerl</source>
          <target state="translated">OptiPerl</target>
        </trans-unit>
        <trans-unit id="6221772a58b20793863ce371d773cbe75426798d" translate="yes" xml:space="preserve">
          <source>OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax-highlighting editor.</source>
          <target state="translated">OptiPerl-это Windows IDE с симулированной CGI-средой,включающей отладчик и редактор синтаксиса.</target>
        </trans-unit>
        <trans-unit id="3aefe0ba1ba6e76e7b11557d066b96b14e2c986e" translate="yes" xml:space="preserve">
          <source>Optimisation data; subject to change.</source>
          <target state="translated">Данные оптимизации;могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="6169946bff1ab1bb2fe62a2ebdb2dd4fa18f40fb" translate="yes" xml:space="preserve">
          <source>Optimisation flags; subject to change.</source>
          <target state="translated">Флаги оптимизации;могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="6bc76b02fc66f0ca691dc22aabcdcd333e409136" translate="yes" xml:space="preserve">
          <source>Optimization of regular expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a333060bee7f2ee65af71205072e100d62bacc" translate="yes" xml:space="preserve">
          <source>Optimized-away statements are rendered as '???'. This includes statements that have a compile-time side-effect, such as the obscure</source>
          <target state="translated">Оптимизированные заявления выдаются в виде '??'.Это включает в себя утверждения,которые имеют побочный эффект компилирующего времени,такие как неясные</target>
        </trans-unit>
        <trans-unit id="40dbe8ccfe714d9a944d448d1c3b1b3c2bfff946" translate="yes" xml:space="preserve">
          <source>Optimizing</source>
          <target state="translated">Optimizing</target>
        </trans-unit>
        <trans-unit id="3e1ccc3d0caaae646e1ab71f59e1842b2b4f1166" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt; .</source>
          <target state="translated">Дальнейшая оптимизация - задача для &lt;code&gt;p5p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d18d459b985af7984ff90200899087216246ead" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b89db00fb49023ab4c0f78acb572909bcf10d35" translate="yes" xml:space="preserve">
          <source>Option Format</source>
          <target state="translated">Вариант Формат</target>
        </trans-unit>
        <trans-unit id="f506dd24a9e7c79211553ebe1422f91140092c4a" translate="yes" xml:space="preserve">
          <source>Option Stickiness</source>
          <target state="translated">Вариант Липкость</target>
        </trans-unit>
        <trans-unit id="8b0267bbb54c30709fbd963f611e8c9f6fcd1f57" translate="yes" xml:space="preserve">
          <source>Option words are separated by commas (not whitespace) and follow the usual conventions of compiler backend options.</source>
          <target state="translated">Слова опций разделены запятыми (не пробелами)и следуют обычным конвенциям опций бэкэнда компилятора.</target>
        </trans-unit>
        <trans-unit id="bd62828c4813996c3de7a8b7f837c827369e6d5e" translate="yes" xml:space="preserve">
          <source>Option, Argument, Parameter, and Configuration File Processing</source>
          <target state="translated">Опция,Аргумент,Параметр и Обработка файла конфигурации</target>
        </trans-unit>
        <trans-unit id="16df76c37a27e75c2b404f915ffcff82e54620ed" translate="yes" xml:space="preserve">
          <source>Optional - called when the layer is about to be removed.</source>
          <target state="translated">Необязательно-вызывается,когда слой собирается удалить.</target>
        </trans-unit>
        <trans-unit id="279393da5192f90d67ca2ac7c82f748509f343b9" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for opens which pass a numeric file descriptor. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">Необязательно-если нет нижнего слоя,то открывается.Если присутствует,то вызывается после того,как слой подталкивается к открытиям,которые передают числовой файловый дескриптор.Эта функция может быть изменена,так как нет простого способа заставить нижний слой сделать открытие,а затем вернуть контроль.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
