<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="95b2f35c340f46f849fe05ab2a263ba75176b401" translate="yes" xml:space="preserve">
          <source>The $input_filename_or_reference parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd706f4aac9bb23ac72e5f391e9438d3b6687fe7" translate="yes" xml:space="preserve">
          <source>The $io_handle is read until EOF and the content is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">Ручка $io_handle считывается до EOF,а содержимое добавляется к сообщению,для которого мы вычисляем дайджест.Возвращаемым значением является сам объект $ctx.</target>
        </trans-unit>
        <trans-unit id="f48497c09ab813ab9f670545e1d053cf6b1c4105" translate="yes" xml:space="preserve">
          <source>The $io_handle will be read until EOF and its content appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="translated">Ручка $io_handle будет считываться до тех пор,пока EOF и ее содержимое не будут приложены к сообщению,для которого мы вычисляем дайджест.Возвращаемым значением является сам объект $md5.</target>
        </trans-unit>
        <trans-unit id="73b7765fc89db094ffe9099cbf5e1b07621f5606" translate="yes" xml:space="preserve">
          <source>The $keep argument is a boolean flag. If true, then the tokens are split on the specified delimiter, but all other characters (including quotes and backslashes) are kept in the tokens. If $keep is false then the &amp;amp;*quotewords() functions remove all quotes and backslashes that are not themselves backslash-escaped or inside of single quotes (i.e., &amp;amp;quotewords() tries to interpret these characters just like the Bourne shell). NB: these semantics are significantly different from the original version of this module shipped with Perl 5.000 through 5.004. As an additional feature, $keep may be the keyword &quot;delimiters&quot; which causes the functions to preserve the delimiters in each string as tokens in the token lists, in addition to preserving quote and backslash characters.</source>
          <target state="translated">Аргумент $ keep является логическим флагом. Если true, то токены разделяются по указанному разделителю, но все остальные символы (включая кавычки и обратную косую черту) сохраняются в токенах. Если $ keep ложно, то функции &amp;amp; * quotewords () удаляют все кавычки и обратные косые черты, которые сами не экранированы обратной косой чертой или внутри одинарных кавычек (т.е. &amp;amp; quotewords () пытается интерпретировать эти символы так же, как оболочка Bourne). NB: эта семантика значительно отличается от исходной версии этого модуля, поставляемой с Perl 5.000&amp;ndash;5.004. В качестве дополнительной функции $ keep может быть ключевым словом &quot;delimiters&quot;, которое заставляет функции сохранять разделители в каждой строке как токены в списках токенов в дополнение к сохранению символов кавычек и обратной косой черты.</target>
        </trans-unit>
        <trans-unit id="4e5f5797e7dfa3a15e15f61203e30952d45673d5" translate="yes" xml:space="preserve">
          <source>The $members value returned by</source>
          <target state="translated">Стоимость членов,возвращаемая</target>
        </trans-unit>
        <trans-unit id="83788be2ef337c14a7fbd0046f5c9a6c4208063c" translate="yes" xml:space="preserve">
          <source>The $output_filename_or_reference parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea59b84534455476bdc42448f750e6798f5fa6a2" translate="yes" xml:space="preserve">
          <source>The %result hash will be populated with the various keys/subhashes reflecting the install. Currently these keys and their structure are:</source>
          <target state="translated">Хэш %result будет заполнен различными клавишами/подсказками,отражающими установку.В настоящее время эти ключи и их структура:</target>
        </trans-unit>
        <trans-unit id="aad53f0657034b93e1e3cf8ea5f7f3e1670d20ff" translate="yes" xml:space="preserve">
          <source>The %s function is unimplemented</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2003a4836fd23e3d85388f2cbd39901c6bc22d" translate="yes" xml:space="preserve">
          <source>The &amp;amp; Unary Operator</source>
          <target state="translated">Оператор &amp;amp; Унарный</target>
        </trans-unit>
        <trans-unit id="ddb7807e2ac7fcb7b1862d48b33f4bdc45bd2c34" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem</source>
          <target state="translated">Эта проблема</target>
        </trans-unit>
        <trans-unit id="4101646effcfa6c9b3723eeb19290b923da87717" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem.</source>
          <target state="translated">Эта проблема.</target>
        </trans-unit>
        <trans-unit id="819c8af579e67bbf16b0d43d190eb1e52a12ff6c" translate="yes" xml:space="preserve">
          <source>The &amp;amp;nested_quotewords() and &amp;amp;quotewords() functions accept a delimiter (which can be a regular expression) and a list of lines and then breaks those lines up into a list of words ignoring delimiters that appear inside quotes. &amp;amp;quotewords() returns all of the tokens in a single long list, while &amp;amp;nested_quotewords() returns a list of token lists corresponding to the elements of @lines. &amp;amp;parse_line() does tokenizing on a single string. The &amp;amp;*quotewords() functions simply call &amp;amp;parse_line(), so if you're only splitting one line you can call &amp;amp;parse_line() directly and save a function call.</source>
          <target state="translated">Функции &amp;amp; nested_quotewords () и &amp;amp; quotewords () принимают разделитель (который может быть регулярным выражением) и список строк, а затем разбивают эти строки на список слов, игнорируя разделители, которые появляются внутри кавычек. &amp;amp; quotewords () возвращает все токены в одном длинном списке, а &amp;amp; nested_quotewords () возвращает список списков токенов, соответствующих элементам @lines. &amp;amp; parse_line () выполняет токенизацию одной строки. Функции &amp;amp; * quotewords () просто вызывают &amp;amp; parse_line (), поэтому, если вы разделяете только одну строку, вы можете напрямую вызвать &amp;amp; parse_line () и сохранить вызов функции.</target>
        </trans-unit>
        <trans-unit id="9c87ced9da37d8df457e1116fcc0073fb1557eae" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="translated">Знак &amp;lt;- ЗДЕСЬ показывает, где в регулярном выражении была обнаружена проблема.</target>
        </trans-unit>
        <trans-unit id="c4f590c76222edc7a4139c10a801899ef6080952" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Знак &amp;lt;- ЗДЕСЬ показывает, где в регулярном выражении была обнаружена проблема. См. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bf8f7c8c4159c0583c72496084082131f49306a" translate="yes" xml:space="preserve">
          <source>The &amp;lt;FH&amp;gt; construct is not the name of the filehandle, it is a readline operation on that handle. The data read is assigned to $_ only if the file read is the sole condition in a while loop:</source>
          <target state="translated">Конструкция &amp;lt;FH&amp;gt; - это не имя дескриптора файла, это операция чтения строки над этим дескриптором. Считанные данные присваиваются $ _, только если чтение файла является единственным условием в цикле while:</target>
        </trans-unit>
        <trans-unit id="ab73cfd3e43216b54a963f39932451a527bcc6a3" translate="yes" xml:space="preserve">
          <source>The '&lt;b&gt;-w&lt;/b&gt;' switch would have told us about this, had we used it at the start, and saved us a lot of trouble:</source>
          <target state="translated">&lt;b&gt;Ключ&lt;/b&gt; ' &lt;b&gt;-w&lt;/b&gt; ' сказал бы нам об этом, если бы мы использовали его в начале, и избавил бы нас от многих проблем:</target>
        </trans-unit>
        <trans-unit id="bd6318c738360c72f699370e44631e5d478a985b" translate="yes" xml:space="preserve">
          <source>The 'array_base' feature</source>
          <target state="translated">Функция 'array_base'</target>
        </trans-unit>
        <trans-unit id="0d3b66a213047641035eea0c1bcf8c880d1b087a" translate="yes" xml:space="preserve">
          <source>The 'bitwise' feature</source>
          <target state="translated">&quot;побитовая&quot; особенность</target>
        </trans-unit>
        <trans-unit id="2376f82ab2d823fadd94b13d055e3e37926a8909" translate="yes" xml:space="preserve">
          <source>The 'blead' branch will become the next production release of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5d26aebe5343fcb8365359fdfecbe6a1f9ce93" translate="yes" xml:space="preserve">
          <source>The 'bval' Option</source>
          <target state="translated">Вариант &quot;bval</target>
        </trans-unit>
        <trans-unit id="e00309e30b37c032e9723d99c993712660e13d4a" translate="yes" xml:space="preserve">
          <source>The 'current_sub' feature</source>
          <target state="translated">Функция 'current_sub'</target>
        </trans-unit>
        <trans-unit id="6c052a5c9bdb1ba3c0df3df62a320e47a9bd25cd" translate="yes" xml:space="preserve">
          <source>The 'd' and the 'm' command normally only show you information they have in their in-memory database and thus will never connect to the internet. If you set the 'show_upload_date' variable to true, 'm' and 'd' will additionally show you the upload date of the module or distribution. Per default this feature is off because it may require a net connection to get at the upload date.</source>
          <target state="translated">Команда 'd' и 'm' обычно показывает только информацию,которая есть у них в базе данных in-memory,и,таким образом,никогда не будет подключена к интернету.Если переменная 'show_upload_date' установлена в true,то 'm' и 'd' дополнительно покажут дату загрузки модуля или дистрибутива.По умолчанию эта функция отключена,так как для получения даты загрузки может потребоваться подключение к сети.</target>
        </trans-unit>
        <trans-unit id="509605357b02233eb13a519ed86bc5588e63f2bb" translate="yes" xml:space="preserve">
          <source>The 'declared_refs' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e825d609e1bdb12613a2765369452bfb2902c9" translate="yes" xml:space="preserve">
          <source>The 'fc' feature</source>
          <target state="translated">Функция &quot;fc</target>
        </trans-unit>
        <trans-unit id="c532c19d0965a864c1673a10c98911020476e550" translate="yes" xml:space="preserve">
          <source>The 'hushed' flag has a global scope during compilation: the exit() or die() commands that are compiled after 'vmsish hushed' will be hushed when they are executed. Doing a &quot;no vmsish 'hushed'&quot; turns off the hushed flag.</source>
          <target state="translated">Флаг 'hushed' во время компиляции имеет глобальный масштаб:команды exit()или die(),которые компилируются после 'vmsish hushed',будут замаскированы при их выполнении.При выполнении команды &quot;no vmsish hushed&quot; флаг hushed отключается.</target>
        </trans-unit>
        <trans-unit id="f3c4a2190f41366ac81419b36b206c02ca25e77f" translate="yes" xml:space="preserve">
          <source>The 'indirect' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05575bbb92499cca81508b16233a4f48eaa12953" translate="yes" xml:space="preserve">
          <source>The 'info' facet is a list instead of a single item, any quantity of extra information can be attached to an event. Some information may be critical diagnostics, others may be simply commentary in nature, this is determined by the &lt;code&gt;debug&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf69940e6c70d26326135ebbe9700ea9cbaa2c64" translate="yes" xml:space="preserve">
          <source>The 'isa' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476d927d17a3d46a0ed772d0abdb4399c93a366e" translate="yes" xml:space="preserve">
          <source>The 'lexical_subs' feature</source>
          <target state="translated">Функция 'lexical_subs'...</target>
        </trans-unit>
        <trans-unit id="d15b2cae0ecbb384e6a16c159b73754a15b73452" translate="yes" xml:space="preserve">
          <source>The 'postderef' and 'postderef_qq' features</source>
          <target state="translated">Функции 'postderef' и 'postderef_qq'.</target>
        </trans-unit>
        <trans-unit id="032a279126f29bd2ca1a4d576f6688e5bd0a4721" translate="yes" xml:space="preserve">
          <source>The 'postderef' feature allows the use of &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;postfix dereference syntax&lt;/a&gt;. For example, it will make the following two statements equivalent:</source>
          <target state="translated">Функция postderef позволяет использовать &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;синтаксис постфиксного разыменования&lt;/a&gt; . Например, он сделает следующие два оператора эквивалентными:</target>
        </trans-unit>
        <trans-unit id="be7e2c7e833c38213d25b7e41371f00fd6ae1cc7" translate="yes" xml:space="preserve">
          <source>The 'postderef' feature was used in Perl 5.20 and Perl 5.22 to enable postfix dereference syntax outside double-quotish interpolations. In those versions, using it triggered the &lt;code&gt;experimental::postderef&lt;/code&gt; warning in the same way as the 'postderef_qq' feature did. As of Perl 5.24, this syntax is not only no longer experimental, but it is enabled for all Perl code, regardless of what feature declarations are in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d578b5339ed54ec5db37c2e8106e846c9a1c704" translate="yes" xml:space="preserve">
          <source>The 'postderef_qq' feature extends the applicability of &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;postfix dereference syntax&lt;/a&gt; so that postfix array and scalar dereference are available in double-quotish interpolations. For example, it makes the following two statements equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72039153ef5da3a0b8c844ea7ff1d46ddb7f3f43" translate="yes" xml:space="preserve">
          <source>The 'postderef_qq' feature extends this, for array and scalar dereference, to working inside of double-quotish interpolations.</source>
          <target state="translated">Функция 'postderef_qq' расширяет это,для массивов и скалярных разыменований,до работы внутри интерполяций двойной квоты.</target>
        </trans-unit>
        <trans-unit id="1856b511545a836fd1960f70b611782e60e03174" translate="yes" xml:space="preserve">
          <source>The 'refaliasing' feature</source>
          <target state="translated">Функция &quot;refaliasing</target>
        </trans-unit>
        <trans-unit id="43acd92859b0081e26405b0092a9e001da38bcb0" translate="yes" xml:space="preserve">
          <source>The 'say' feature</source>
          <target state="translated">Функция &quot;скажи</target>
        </trans-unit>
        <trans-unit id="48c11f3663366e7407088877b28bc4e952cd3e8c" translate="yes" xml:space="preserve">
          <source>The 'signatures' feature</source>
          <target state="translated">Функция &quot;подписи</target>
        </trans-unit>
        <trans-unit id="1ef5c6a6bc489a315173331d45afe7880d296d9b" translate="yes" xml:space="preserve">
          <source>The 'state' feature</source>
          <target state="translated">Функция &quot;состояние</target>
        </trans-unit>
        <trans-unit id="0202f826bf3e7b7586cfc812c13b1dfe89d2bf49" translate="yes" xml:space="preserve">
          <source>The 'switch' feature</source>
          <target state="translated">Функция &quot;переключатель</target>
        </trans-unit>
        <trans-unit id="7029a8b5bd568b6e4297fb88434b17a5f75b3a17" translate="yes" xml:space="preserve">
          <source>The 'unicode_eval' and 'evalbytes' features</source>
          <target state="translated">Характеристики 'unicode_eval' и 'evalbytes'</target>
        </trans-unit>
        <trans-unit id="e493b49d6dbbae3a5be3b8f2dff13d8ec26ef7db" translate="yes" xml:space="preserve">
          <source>The 'unicode_strings' feature</source>
          <target state="translated">Функция 'unicode_strings'</target>
        </trans-unit>
        <trans-unit id="5ea68e68d7d7c5a9842b2a6416db5968c04cbe4d" translate="yes" xml:space="preserve">
          <source>The 'unique' attribute may only be applied to 'our' variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6dd476d660cd451b4df840859a13759199b455" translate="yes" xml:space="preserve">
          <source>The (numeric) value of &lt;code&gt;$!&lt;/code&gt; when the context was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfde022325aa7cfbc096171cf51353e9b32230c" translate="yes" xml:space="preserve">
          <source>The --state switch supports a number of options; for example to run failed tests first followed by all remaining tests ordered by the timestamps of the test scripts - and save the results - I can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f31ae17f71ba4abf6738dd8a78689f3b1ddbaf2" translate="yes" xml:space="preserve">
          <source>The -Dprefix option will install Perl in a directory parallel to the IBM AIX system Perl installation.</source>
          <target state="translated">Опция -Dprefix установит Perl в каталог параллельно с установкой Perl системы IBM AIX.</target>
        </trans-unit>
        <trans-unit id="b25fb323a909fad41c8f87bd91694a424a13934a" translate="yes" xml:space="preserve">
          <source>The -j switch enables parallel testing; the number that follows it is the maximum number of tests to run in parallel. Sometimes tests that pass when run sequentially will fail when run in parallel. For example if two different test scripts use the same temporary file or attempt to listen on the same socket I'll have problems running them in parallel. If I see unexpected failures I need to check my tests to work out which of them are trampling on the same resource and rename temporary files or add locks as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc3be0ef0e3e9886678cc868f1c296c736baaaa" translate="yes" xml:space="preserve">
          <source>The .c files will automatically be included in the list of files deleted by a make clean.</source>
          <target state="translated">Файлы с расширением .c будут автоматически включены в список файлов,удаляемых make clean.</target>
        </trans-unit>
        <trans-unit id="eaa1f52ae3c132b312829a1a099fb15cc4451f8a" translate="yes" xml:space="preserve">
          <source>The .i Targets</source>
          <target state="translated">Цели .i</target>
        </trans-unit>
        <trans-unit id="c5957baac4fddeea5c92174eefc52a682210436d" translate="yes" xml:space="preserve">
          <source>The .netrc file contains login and initialization information used by the auto-login process. It resides in the user's home directory. The following tokens are recognized; they may be separated by spaces, tabs, or new-lines:</source>
          <target state="translated">Файл .netrc содержит информацию о входе и инициализации,используемую в процессе автозапуска.Он находится в домашнем каталоге пользователя.Распознаются следующие маркеры;они могут быть разделены пробелами,закладками или новыми строками:</target>
        </trans-unit>
        <trans-unit id="54f9e8c707fce1b5fb29121fecf5b3c5f6fb75cd" translate="yes" xml:space="preserve">
          <source>The .pm and .xs files contain the meat of the extension. The .xs file holds the C routines that make up the extension. The .pm file contains routines that tell Perl how to load your extension.</source>
          <target state="translated">Файлы .pm и .xs содержат мясо расширения.Файл .xs содержит процедуры C,составляющие расширение.Файл .pm содержит подпрограммы,которые сообщают Perl,как загрузить ваше расширение.</target>
        </trans-unit>
        <trans-unit id="dd2519bf881a43a692b68b1c0e909064ae51fbd0" translate="yes" xml:space="preserve">
          <source>The .pm file originally exported the name &lt;code&gt;TESTVAL&lt;/code&gt; in the &lt;code&gt;@EXPORT&lt;/code&gt; array. This could lead to name clashes. A good rule of thumb is that if the #define is only going to be used by the C routines themselves, and not by the user, they should be removed from the &lt;code&gt;@EXPORT&lt;/code&gt; array. Alternately, if you don't mind using the &quot;fully qualified name&quot; of a variable, you could move most or all of the items from the &lt;code&gt;@EXPORT&lt;/code&gt; array into the &lt;code&gt;@EXPORT_OK&lt;/code&gt; array.</source>
          <target state="translated">Файл .pm изначально экспортировал имя &lt;code&gt;TESTVAL&lt;/code&gt; в массив &lt;code&gt;@EXPORT&lt;/code&gt; . Это может привести к конфликту имен. Хорошее практическое правило состоит в том, что если #define будет использоваться только самими подпрограммами C, а не пользователем, они должны быть удалены из массива &lt;code&gt;@EXPORT&lt;/code&gt; . С другой стороны , если вы не возражаете , используя &amp;laquo;полное имя&amp;raquo; переменной, вы можете переместить большинство или все элементы из &lt;code&gt;@EXPORT&lt;/code&gt; массива в &lt;code&gt;@EXPORT_OK&lt;/code&gt; массив.</target>
        </trans-unit>
        <trans-unit id="2cd74e874774bfc3b88afdad1635f506f150f617" translate="yes" xml:space="preserve">
          <source>The .xs file of &lt;a href=&quot;#EXAMPLE-4&quot;&gt;&quot;EXAMPLE 4&quot;&lt;/a&gt; contained some new elements. To understand the meaning of these elements, pay attention to the line which reads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ef13c3a85e7562d01716fd477e5df2797f8e0b" translate="yes" xml:space="preserve">
          <source>The .xs file of &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; contained some new elements. To understand the meaning of these elements, pay attention to the line which reads</source>
          <target state="translated">Файл .xs ПРИМЕРА &lt;a href=&quot;#EXAMPLE-4&quot;&gt;4&lt;/a&gt; содержал несколько новых элементов. Чтобы понять значение этих элементов, обратите внимание на строку, которая гласит</target>
        </trans-unit>
        <trans-unit id="9a412534f9637df17d083fc0dd838ed8c9b7cead" translate="yes" xml:space="preserve">
          <source>The /usr/bin/perl is obvious (hopefully).</source>
          <target state="translated">/usr/bin/perl очевиден (надеюсь).</target>
        </trans-unit>
        <trans-unit id="ec5eb62e4999d20a060f6b13a5aef679a45b4eda" translate="yes" xml:space="preserve">
          <source>The 0th entry of the PADLIST is a PADNAMELIST which represents the &quot;names&quot; or rather the &quot;static type information&quot; for lexicals. The individual elements of a PADNAMELIST are PADNAMEs. Future refactorings might stop the PADNAMELIST from being stored in the PADLIST's array, so don't rely on it. See &lt;a href=&quot;#PadlistNAMES&quot;&gt;&quot;PadlistNAMES&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90c8fc76aaca137d93e66aec85f8cb2eec3fed5" translate="yes" xml:space="preserve">
          <source>The 0th entry of the PADLIST is a PADNAMELIST which represents the &quot;names&quot; or rather the &quot;static type information&quot; for lexicals. The individual elements of a PADNAMELIST are PADNAMEs. Future refactorings might stop the PADNAMELIST from being stored in the PADLIST's array, so don't rely on it. See &lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES&lt;/a&gt;.</source>
          <target state="translated">0-я запись PADLIST - это PADNAMELIST, который представляет &amp;laquo;имена&amp;raquo; или, скорее, &amp;laquo;информацию статического типа&amp;raquo; для лексических слов. Отдельные элементы PADNAMELIST - это PADNAME. Дальнейшие рефакторинги могут помешать сохранению PADNAMELIST в массиве PADLIST, поэтому не полагайтесь на него. См. &lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c98b5db329af061627f1088cd649948958ceb6" translate="yes" xml:space="preserve">
          <source>The 1 or 2 rows of numbers following that correspond to the number of buckets of each size between &lt;code&gt;SMALLEST&lt;/code&gt; and &lt;code&gt;GREATEST&lt;/code&gt; . In the first row, the sizes (memory footprints) of buckets are powers of two--or possibly one page greater. In the second row, if present, the memory footprints of the buckets are between the memory footprints of two buckets &quot;above&quot;.</source>
          <target state="translated">Следующие 1 или 2 ряда чисел соответствуют количеству сегментов каждого размера от &lt;code&gt;SMALLEST&lt;/code&gt; до &lt;code&gt;GREATEST&lt;/code&gt; . В первой строке размеры (объем памяти) сегментов равны степени двойки или, возможно, на одну страницу больше. Во втором ряду, если он присутствует, следы памяти сегментов находятся между следами памяти двух сегментов &quot;выше&quot;.</target>
        </trans-unit>
        <trans-unit id="2d14fecd7b938aa9c4e943161fbc2d01a94612f1" translate="yes" xml:space="preserve">
          <source>The 1 or 2 rows of numbers following that correspond to the number of buckets of each size between &lt;code&gt;SMALLEST&lt;/code&gt; and &lt;code&gt;GREATEST&lt;/code&gt;. In the first row, the sizes (memory footprints) of buckets are powers of two--or possibly one page greater. In the second row, if present, the memory footprints of the buckets are between the memory footprints of two buckets &quot;above&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474f74fc74e6b97d1b22c49840ad80fdd2b7a470" translate="yes" xml:space="preserve">
          <source>The 1-argument form of cacheout will open a file for writing (&lt;code&gt;'&amp;gt;'&lt;/code&gt; ) on it's first use, and appending (&lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ) thereafter.</source>
          <target state="translated">Форма кэширования с одним аргументом откроет файл для записи ( &lt;code&gt;'&amp;gt;'&lt;/code&gt; ) при первом использовании и добавления ( &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ) после этого.</target>
        </trans-unit>
        <trans-unit id="4ff6ad6db51d63412b617f745958fc59e4fe98c5" translate="yes" xml:space="preserve">
          <source>The 1-argument form of cacheout will open a file for writing (&lt;code&gt;'&amp;gt;'&lt;/code&gt;) on it's first use, and appending (&lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt;) thereafter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece20b2e43644dc279ab7b6d2adb512919e3c93c" translate="yes" xml:space="preserve">
          <source>The 13 variant characters</source>
          <target state="translated">13 вариантов символов</target>
        </trans-unit>
        <trans-unit id="a9393cb211cfe66570248ab99ec7632708f22fae" translate="yes" xml:space="preserve">
          <source>The 1st column is the op's sequence number, starting at 1, and is displayed in base 36 by default. Here they're purely linear; the sequences are very helpful when looking at code with loops and branches.</source>
          <target state="translated">Первый столбец-это порядковый номер операции,начинающийся с 1,и по умолчанию отображается в базе 36.Здесь они чисто линейные,последовательности очень полезны при просмотре кода с циклами и ветвями.</target>
        </trans-unit>
        <trans-unit id="004f29b5a23df31b01d8aa7e1fc9952890ebb7d2" translate="yes" xml:space="preserve">
          <source>The 2-argument form of cacheout will use the supplied mode for the initial and subsequent openings. Most valid modes for 3-argument &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; are supported namely; &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'+&amp;gt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;+'&lt;/code&gt; , &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; , &lt;code&gt; '|-' &lt;/code&gt; and &lt;code&gt; '-|' &lt;/code&gt;</source>
          <target state="translated">Форма кэширования с двумя аргументами будет использовать предоставленный режим для начального и последующих открытий. Поддерживаются наиболее допустимые режимы для &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 3 аргументами , а именно; &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'+&amp;gt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;+'&lt;/code&gt; , &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; , &lt;code&gt; '|-' &lt;/code&gt; и &lt;code&gt; '-|' &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="121cd9829212f2f550e8dcc8a4cb650149b4b147" translate="yes" xml:space="preserve">
          <source>The 2-argument form of cacheout will use the supplied mode for the initial and subsequent openings. Most valid modes for 3-argument &lt;code&gt;open&lt;/code&gt; are supported namely; &lt;code&gt;'&amp;gt;'&lt;/code&gt;, &lt;code&gt;'+&amp;gt;'&lt;/code&gt;, &lt;code&gt;'&amp;lt;'&lt;/code&gt;, &lt;code&gt;'&amp;lt;+'&lt;/code&gt;, &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt;, &lt;code&gt; '|-' &lt;/code&gt; and &lt;code&gt; '-|' &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ff8f169a4e9a0d5e765f1f57d4ab8242fb17bb" translate="yes" xml:space="preserve">
          <source>The 256-color control sequences are documented at &lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (search for 256-color).</source>
          <target state="translated">Последовательности управления 256 цветами задокументированы на &lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (поиск 256 цветов).</target>
        </trans-unit>
        <trans-unit id="a6fefbc384a8139a82e087bfa8ca02dafb3d60bc" translate="yes" xml:space="preserve">
          <source>The 256-color control sequences are documented at &lt;a href=&quot;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;https://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (search for 256-color).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55485ffff099decf688573c56761765b3767694a" translate="yes" xml:space="preserve">
          <source>The 7 bit version switches character set via escape sequence so it cannot form a CCS. Since this is more difficult to handle in programs than the 8 bit version, the 7 bit version is not very popular except for iso-2022-jp, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9651fbba2c1758272669624f504505a7394156" translate="yes" xml:space="preserve">
          <source>The 8 bit version can form a CCS. EUC and ISO-8859 are two examples thereof. Pre-5.6 perl could use them as string literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d64a8cbca0fac7db1be3c3a959838f4d376e652" translate="yes" xml:space="preserve">
          <source>The :browse tag represents the next step beyond :default. It is a superset of the :default ops and adds :filesys_read the :sys_db. The intent being that scripts can access more (possibly sensitive) information about your system but not be able to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81b42d9c2528e2e2cc53554ea82b10b2357c0c7" translate="yes" xml:space="preserve">
          <source>The :browse tag represents the next step beyond :default. It it a superset of the :default ops and adds :filesys_read the :sys_db. The intent being that scripts can access more (possibly sensitive) information about your system but not be able to change it.</source>
          <target state="translated">Тэг :browse представляет собой следующий шаг после :default.Он является суперсеттом :default ops и добавляет :filesys_read :sys_db.Смысл заключается в том,что скрипты могут получить доступ к более (возможно,конфиденциальной)информации о вашей системе,но не могут ее изменить.</target>
        </trans-unit>
        <trans-unit id="913829e3b140a41628c9596982f027a8f2285b7a" translate="yes" xml:space="preserve">
          <source>The :locale sub-pragma</source>
          <target state="translated">Локальная суб-прагма</target>
        </trans-unit>
        <trans-unit id="37c60296990ea34e90b8a450eb79515589ce29e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Extended-Grapheme-Clusters-%28Logical-characters%29&quot;&gt;&quot;Extended Grapheme Clusters (Logical characters)&quot;&lt;/a&gt; section above talked about canonical decompositions. However, many more characters have a different type of decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example is the &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt;. It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a &quot;compatible&quot; decomposition, specifically a &quot;super&quot; decomposition. There are several such compatibility decompositions (see &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;https://www.unicode.org/reports/tr44&lt;/a&gt;), including one called &quot;compat&quot;, which means some miscellaneous type of decomposition that doesn't fit into the other decomposition categories that Unicode has chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85820f28213c3599595658668ce44deb0578d4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;Extended Grapheme Clusters (Logical characters)&lt;/a&gt; section above talked about canonical decompositions. However, many more characters have a different type of decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example is the &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; . It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a &quot;compatible&quot; decomposition, specifically a &quot;super&quot; decomposition. There are several such compatibility decompositions (see &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;), including one called &quot;compat&quot;, which means some miscellaneous type of decomposition that doesn't fit into the other decomposition categories that Unicode has chosen.</source>
          <target state="translated">В разделе &amp;laquo; &lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;Расширенные кластеры графем (логические символы)&lt;/a&gt; &amp;raquo; выше говорилось о канонических декомпозициях. Однако гораздо больше символов имеют другой тип декомпозиции, &amp;laquo;совместимую&amp;raquo; или &amp;laquo;неканоническую&amp;raquo; декомпозицию. Последовательности, образующие эти разложения, не считаются канонически эквивалентными заранее составленному символу. Примером может служить &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; . Это что-то вроде обычной цифры 1, но не совсем; его разложение на цифру 1 называется &amp;laquo;совместимым&amp;raquo; разложением, в частности &amp;laquo;суперразложением&amp;raquo;. Существует несколько таких декомпозиций совместимости (см. &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;Http://www.unicode.org/reports/tr44&lt;/a&gt;), включая тот, который называется &quot;compat&quot;, что означает некоторый разный тип декомпозиции, который не вписывается в другие категории декомпозиции, выбранные Unicode.</target>
        </trans-unit>
        <trans-unit id="6f116e91479173f83f0ee6321a3113bbe8db276b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">Функция &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; не подходит для хеширования больших объемов данных, не в последнюю очередь потому, что вы не можете получить информацию обратно. Посмотрите на модуль &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; для более надежных алгоритмов.</target>
        </trans-unit>
        <trans-unit id="58fb9e5b9c576e1ea7f2599e64e16265a4b03e77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d7d18b809428abc8ce2a93a95e7422c9de3745" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; function executes a system command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01d04c5af24a4340d0f912c2ccf886a5fc1edcb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt;. If this is a problem, you can call &lt;a href=&quot;posix#_exit&quot;&gt;&lt;code&gt;POSIX::_exit($status)&lt;/code&gt;&lt;/a&gt; to avoid &lt;code&gt;END&lt;/code&gt; and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee540728eb307530289af963d36689ec3a1444d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getprotobynumber-NUMBER&quot;&gt;&lt;code&gt;getprotobynumber&lt;/code&gt;&lt;/a&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1f9e63055c82c44f33e919de1bfed56733c2d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;last EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;last LABEL&lt;/code&gt;. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889dc5e06ef6b79bfd7037342382aa88c842b099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;continue&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c37dbdd3d3faf157e953bebef6eeac7f43fa10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt; function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2173488a74d711836ae18ee727857a8643388af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the external protocol. Uses &lt;a href=&quot;Net::Ping::External&quot;&gt;Net::Ping::External&lt;/a&gt; to do an external ping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7c9b7850979e6e7def2184badf7bf1bc4a1d3d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the forking syn protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641eb29f28723359d8e506ee9152e1f38204dfa6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1957ff6c7452234943290c79fb5d121b6e83c5a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmpv6 protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd013c64eb2eb70a4842cac8e8d68d7939687f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the stream protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf91af075e5c18933e470cdffacd91d45bab2cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the syn protocol. Sends a TCP SYN packet to host specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e289226b6ef91e47994450b9dc7ca74494856a25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the tcp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bacd7d416bf9eb142f724a00d7ab4625004301a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the udp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be711bbef7a00d2eb13cc8d85cfba9b425e71aaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4486da16fa0f4a006b57a0a44a17953ec38fd8dc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce0427217e7e69e6e5a80f1afd684e23957d161" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8854fb6583fec2754cd3983ea80d85f9b0022749" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;Prop_value_aliases ()&lt;/a&gt; функция может быть использована , чтобы получить все синонимы названия двунаправленного типа.</target>
        </trans-unit>
        <trans-unit id="76a16bb68fd364d030e4901c8f1d916862b53339" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="translated">&lt;a href=&quot;#prop_value_aliases()&quot;&gt;Prop_value_aliases ()&lt;/a&gt; функция может быть использована , чтобы получить все синонимы названия категории.</target>
        </trans-unit>
        <trans-unit id="2277466bc19ae0c38a8069cd1ac99be48d5794e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="translated">Функция &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; может использоваться для получения всех синонимов номера объединяющего класса.</target>
        </trans-unit>
        <trans-unit id="4904f3373dd8be370b7583b9b3b50ffe1a1a4b51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1feb25bb50a467b88daf8d606e828a649203e2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d02ad47d23ca3616a65821c3a3e94a1c4a3210" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="translated">Функции &lt;a href=&quot;#prop_values()&quot;&gt;prop_values ​​()&lt;/a&gt; и &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; могут использоваться как альтернатива этой функции; первая возвращает простой список коротких имен типа двунаправленного текста; а второй получает все синонимы данного имени типа двунаправленного текста.</target>
        </trans-unit>
        <trans-unit id="ff1836f9843147fc775222ff3469395bcf43b303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="translated">Функции &lt;a href=&quot;#prop_values()&quot;&gt;prop_values ​​()&lt;/a&gt; и &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; могут использоваться как альтернатива этой функции; первая возвращает простой список коротких названий категорий; а второй получает все синонимы данного названия категории.</target>
        </trans-unit>
        <trans-unit id="234f248bda745adf52767c8afed6c1179ce0b206" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; command restarts the loop block without evaluating the conditional again. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;redo EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;redo LABEL&lt;/code&gt;. Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a519b9af5d08ee020d0e49465d3e607833a7248" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist()&quot;&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8295b9c404465c68e21720ae88623e9c9b91d667" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="translated">Функция &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist ()&lt;/a&gt; предназначена для поиска кодовой точки в списке инверсии.</target>
        </trans-unit>
        <trans-unit id="a99fc3c1e89a0b4e840a4661bca0de0880d27694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">Модуль &lt;a href=&quot;../file/stat&quot;&gt;File :: stat&lt;/a&gt; предоставляет удобный механизм доступа по имени:</target>
        </trans-unit>
        <trans-unit id="f74e082436b86f6a01a3f1c31662df75f43fb323" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="translated">&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; не использует формальную грамматику , поскольку ТАР является по существу протокол потока на основе. На самом деле, иметь бесконечный поток вполне законно. По той же причине, по которой мы не применяем регулярные выражения к потокам, мы не используем здесь формальную грамматику. Вместо этого мы анализируем TAP по строкам.</target>
        </trans-unit>
        <trans-unit id="9b27238d4d5342b8376d19c0241b7f8feab19452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="translated">Раздел &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; содержит пример привязки ручек.</target>
        </trans-unit>
        <trans-unit id="6d31ab6a810582c2c717e2c46d057f9872d7ae58" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="translated">В разделе &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; используется хороший пример связывания скаляров путем связывания идентификаторов процессов с приоритетом.</target>
        </trans-unit>
        <trans-unit id="ef794a4d4eb5de692a3463fa7a1780b4cded7598" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;../time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">В &lt;a href=&quot;../time/gmtime&quot;&gt;:: gmtime Время&lt;/a&gt; и &lt;a href=&quot;../time/localtime&quot;&gt;Time :: МестноеВремя&lt;/a&gt; модули обеспечивают удобную, по имени механизма доступа к gmtime () и МестноеВремя () функции, соответственно.</target>
        </trans-unit>
        <trans-unit id="7f59d8b64082e6585a0f86dcd5c37ba82d09b8aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f0381e14460ccca0ae56322db0a7c83995df5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf4aaa34018ae1ca4bf41f4b79cdbb9a0cff285" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;B::Xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f196a1609183db140dea47e36f3fc23cd9f51305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94925a2d828e44c2072ac8bf9e5922e018a8e287" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5057256958429150491aec28876109720171696" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061063093e9b457e789ea7dfaed817ebef3e8fa9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414fad6d87355758dbe61a47fbcaa678d06818a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad6fcc6ed17db5c607714adee78b91a0147dac4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fa62cd04b5ec9ae734d2f288b28465a83825b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt;, into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2f33574a7da40336507f2c618ec329b05bfc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f493ee4e3ed13a3c3c25372d0b8e47b8faa82e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41be3e08eb17eb5dab7c9db97b667db51319891c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7bd1eef5bd53ddee501c6b8d48384c043b208a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8b4aba1c450fd5e83e76f37c3b27a8ef91aa4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6eb5ba6674a28ab9cde2b0f4fa3385630b28d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785624fefaf011b1c3c4e26dff67213b765e81c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7daf70cf70f962093675df7cd3c0bff0a54c56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; modules provide methods to manipulate path specifications and return the results in native format for each platform. This is often unnecessary as Unix-style paths are understood by Perl on every supported platform, but if you need to produce native paths for a native utility that does not understand Unix syntax, or if you are operating on paths or path components in unknown (and thus possibly native) syntax, &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; is your friend. Here are two brief examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b19e201b91274dc82f186817a1d33cf7babd619" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16818dfffaaf61b6c966f79b42c1f8e2b7feb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba763c04be417f13a8a4419a2a27f106dcca680" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5994860ba25215b560ca2d61fa7577cd91572e65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Pty&quot;&gt;IO::Pty&lt;/a&gt; and &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ff19b2be9bd948571db368af45b45f30d772d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;fork()&lt;/code&gt;, and &lt;code&gt;exec()&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;&quot;Bidirectional Communication with Another Process&quot; in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;&quot;Bidirectional Communication with Yourself&quot; in perlipc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfdae92972068b982647ca50573a173382b253e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81136d6431fd17ef0e4aa23b6bb0cdcdd4be5ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Net::Domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e94a57c84c2082998da5d9e3718fef9c662bb23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; interface is event-based, similar to that of &lt;a href=&quot;HTML::Parser&quot;&gt;HTML::Parser&lt;/a&gt; or &lt;a href=&quot;XML::Parser&quot;&gt;XML::Parser&lt;/a&gt;'s &quot;Handlers&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3225637b7a30ef3b9b4ead58416b060ae1216f73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570fbc1b333b95e1cacbc6d622c051543a52e083" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83438d62ddac1d3b0024cb20543586b81f4a2ed4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360df13e9e42398d87ddf7c87ae270331934433d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5808fca337034f35682036721a9427ccd81f04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafbf1ee7c517c584849dcba00f2431a29c861d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::Cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000a3fd43d21166c2b39d6546fdf69078cc7d878" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e513d6d25a35bd468fa6dfadf342f7abd0a9398b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; object, as well as all &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; types need to have access to information about where they were created. This object represents that information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e3f2d15c3d0ceb7fdd915ea6fc508fa38a5afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2::Event::Pass&lt;/a&gt; is a specially crafted and optimized event, using this will help the performance of passing tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e3ab29916cf475d197cf70cfb13cb08a0c4ba1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;perlfunc#syscall&quot;&gt;&quot;syscall&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6f85e54060d65479b4d06b632210eb849f1f0e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;localtime&lt;/code&gt; that returns an object, and &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8d644c0f0739788e0fe94553d172a549be62ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc9a688570f19df6de24c492632ed7647b5575b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;Time::localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the &lt;a href=&quot;#gmtime-EXPR&quot;&gt;&lt;code&gt;gmtime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; functions, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9edd1164f7fd428ef66d1f77bb74482f07ecc4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4148a12496e441ea4f3ef8053e86029175f36271" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma is very smart when it comes to working with Perl's built-in functions. The behaviour for these functions are fixed, and &lt;code&gt;autodie&lt;/code&gt; knows exactly how they try to signal failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b61ff031aeab44addeeb9ed990fdd03cf707db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;b/xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="translated">Модуль &lt;a href=&quot;b/xref&quot;&gt;B :: Xref&lt;/a&gt; можно использовать для создания отчетов с перекрестными ссылками для программ Perl.</target>
        </trans-unit>
        <trans-unit id="1c782dc05843dae452f5fa426b35990195e14641" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module allows you to present your error messages from the caller's perspective; this gives you a way to signal a problem with the caller and not your module. For instance, if you say this:</source>
          <target state="translated">Модуль &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; позволяет отображать сообщения об ошибках с точки зрения вызывающего абонента; это дает вам способ сообщить о проблеме с вызывающим абонентом, а не с вашим модулем. Например, если вы скажете это:</target>
        </trans-unit>
        <trans-unit id="99917712f2804784fe8d984e9caf76b36fd4b3a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">Функция &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; не подходит для хеширования больших объемов данных, не в последнюю очередь потому, что вы не можете получить информацию обратно. Посмотрите на модуль &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; для более надежных алгоритмов.</target>
        </trans-unit>
        <trans-unit id="5477977d65c206b7b8a0bfb0ffcfed2d08e7d436" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="translated">Модуль &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; может красиво печатать структуры данных Perl:</target>
        </trans-unit>
        <trans-unit id="c389b29dcc18d72eca5cc18bef171945489bed86" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="translated">Модуль &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; в CPAN (или версии Perl 5.005) отлично подходит для распечатки структур данных. Модуль &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; в CPAN (или Perl версии 5.8) предоставляет функцию &lt;code&gt;dclone&lt;/code&gt; , которая рекурсивно копирует свой аргумент.</target>
        </trans-unit>
        <trans-unit id="3a7849edfc0302d7fe31cbb60d0e88c8f3db830b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86cb4de69efaf27095dfcab4d09f7c50f2a074bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;https://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb29e7cd4504f7ca3895f71c6eb9fad7707159a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; module has been deprecated since perl 5.18 and the perl internals it requires have been removed with perl 5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90e864f3a759969a519520835fc4b34320f5652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt; , into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="translated">Модуль &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; , более известный как MakeMaker, превращает сценарий Perl, обычно называемый &lt;code&gt;Makefile.PL&lt;/code&gt; , в Makefile. Инструмент &lt;code&gt;make&lt;/code&gt; для Unix использует этот файл для управления зависимостями и действиями по обработке и установке дистрибутива Perl.</target>
        </trans-unit>
        <trans-unit id="b36a8fb9e123f79842afcd307b1051443b42499f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="translated">Модуль &lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt; , поставляемый с Perl, выполняет всю сложную работу по обходу структуры каталогов. Он поставляется с Perl. Вы просто вызываете подпрограмму &lt;code&gt;find&lt;/code&gt; с подпрограммой обратного вызова и каталогами, которые хотите пройти:</target>
        </trans-unit>
        <trans-unit id="c85303530151e0f7d4bf77f032f56bce0f2d433a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="translated">Модуль &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; также имеет унаследованный интерфейс к старой подпрограмме &lt;code&gt;rmtree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e3abc4db13d619062f522429a3b20e4ff646e91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="translated">В модуле &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; , который поставляется с Perl, есть &lt;code&gt;remove_tree&lt;/code&gt; , который может позаботиться обо всей тяжелой работе за вас:</target>
        </trans-unit>
        <trans-unit id="e423ba5fb093092e153154cd61200bfa0809ecf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">Модуль &lt;a href=&quot;file/stat&quot;&gt;File :: stat&lt;/a&gt; предоставляет удобный механизм доступа по имени:</target>
        </trans-unit>
        <trans-unit id="147153b8beaaff8771aea84e885cb82d17734d7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt; , which you can then use to construct the right library path:</source>
          <target state="translated">Модуль &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; , поставляемый с Perl, может работать. Он находит каталог текущего запущенного скрипта и помещает его в &lt;code&gt;$Bin&lt;/code&gt; , который затем можно использовать для построения правильного пути к библиотеке:</target>
        </trans-unit>
        <trans-unit id="177b530c271fe1dca56344e28974f18250fe298e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt;, which you can then use to construct the right library path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627242b752186d85aed5b69d9aaec46b0dd05af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm :: Loops&lt;/a&gt; также предоставляет функции &lt;code&gt;NextPermute&lt;/code&gt; и &lt;code&gt;NextPermuteNum&lt;/code&gt; , которые эффективно находят все уникальные перестановки массива, даже если он содержит повторяющиеся значения, изменяя его на месте: если его элементы отсортированы в обратном порядке, тогда массив переворачивается , делая его отсортированным, и он возвращает false; в противном случае возвращается следующая перестановка.</target>
        </trans-unit>
        <trans-unit id="7f004cbac628e9968204a02264b31a3bb1043a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Массив :: итератор :: Круговая&lt;/a&gt; создает объект итератора для круговых массивов:</target>
        </trans-unit>
        <trans-unit id="a8c05beafd26231c80f038931300ac0e459427b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; предоставляет абстрактный интерфейс для большинства серверов баз данных и типов, включая Oracle, DB2, Sybase, mysql, Postgresql, ODBC и плоские файлы. Модуль DBI обращается к каждому типу базы данных через драйвер базы данных или DBD. Вы можете увидеть полный список доступных драйверов на CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . Вы можете узнать больше о DBI на &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d99e17e2d810ab06df1befd3ba4deffe8e1f4100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt; на CPAN тоже может сделать это за вас. Его подпрограмма &lt;code&gt;Dive&lt;/code&gt; может сказать вам не только о существовании ключей, но и получить значение:</target>
        </trans-unit>
        <trans-unit id="2f20a46404ea5d10e8ff52857742923d6a8c636c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc также&lt;/a&gt; предоставляет две функции для их вычисления:</target>
        </trans-unit>
        <trans-unit id="cffc0b8a618b23964a5ae541c5cad5a91da659e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt; (Нью - Йорк Таймс Profiler) делает как заявление и подпрограммой профилирование. Он доступен из CPAN, и вы также вызываете его с помощью переключателя &lt;code&gt;-d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36fe1514538dca6b4e14625a53ea351dc45f0bbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt; может прозрачно декодировать части сообщения электронной почты в кодировке base 64, поэтому разработчику не нужно об этом беспокоиться.</target>
        </trans-unit>
        <trans-unit id="5544c90428de4242a1010e3b0f0f5fbfd72933f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File :: Find :: Затворы&lt;/a&gt; , которые вы можете загрузить с CPAN, предоставляет множество готовых к использованию подпрограмм , которые можно использовать с &lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56af297ba8a5f6d4fadfc00398e4a75a93e0389e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File :: Find :: Rule&lt;/a&gt; , который вы можете скачать с CPAN, имеет аналогичный интерфейс, но также выполняет обход за вас:</target>
        </trans-unit>
        <trans-unit id="b152dc512307ef4ac58f7c9208c20855dec936d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File :: Finder&lt;/a&gt; , который можно загрузить с CPAN, может помочь вам создать подпрограмму обратного используя что - то ближе к синтаксису &lt;code&gt;find&lt;/code&gt; утилиты командной строки:</target>
        </trans-unit>
        <trans-unit id="1598869d41d1eca117a3416dff8d5309f0c6cfec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File :: ReadBackwards&lt;/a&gt; также имеет преимущество установки в качестве разделителя входных записей регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="91110246c66bf6d661128beb45e4417253ba4c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO :: Interactive&lt;/a&gt; делает все возможное, чтобы дать вам ответ. Его функция &lt;code&gt;is_interactive&lt;/code&gt; возвращает дескриптор выходного файла; этот дескриптор файла указывает на стандартный вывод, если модуль считает сеанс интерактивным. В противном случае дескриптор файла - это нулевой дескриптор, который просто отбрасывает вывод:</target>
        </trans-unit>
        <trans-unit id="6b13cf53c66e0915c0e8281e749fbd4b759e7ba2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc :: Daemon&lt;/a&gt; , доступный на CPAN, предоставляет функцию для выполнения этих действий за вас.</target>
        </trans-unit>
        <trans-unit id="078338e81125883115260ece46dd352b4457327c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys :: Hostname :: Long&lt;/a&gt; использует другой подход и изо всех сил пытается вернуть полное имя хоста:</target>
        </trans-unit>
        <trans-unit id="d7d7335f50cc47451871f0f97f15916c1b4287d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="translated">В модуле &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task :: Kensho&lt;/a&gt; есть список рекомендуемых модулей, которые вам следует изучить как хорошую отправную точку.</target>
        </trans-unit>
        <trans-unit id="96f2822c5bca6e995fc1a0007a9363af6e5934b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; от CPAN предлагает простой в использовании интерфейс, который должен быть более эффективным, чем использование &lt;b&gt;stty&lt;/b&gt; для каждого ключа. Он даже включает ограниченную поддержку Windows.</target>
        </trans-unit>
        <trans-unit id="32118c4d7f9e3bede84a1a66430b5426071bf4d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode :: Tussle&lt;/a&gt; CPAN включает множество программ, помогающих работать с Unicode, в том числе эти программы для полной или частичной замены стандартных утилит:</target>
        </trans-unit>
        <trans-unit id="919f72853738df881eb6e91400681adc998b688b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="translated">Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; на CPAN предлагает один пример подмножества предупреждений, которое, по мнению авторов модуля, относительно безопасно уничтожить.</target>
        </trans-unit>
        <trans-unit id="843917bc0f80fad466bd923d5aab8d1c0906f90e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="translated">У объектов &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt; также есть метод &lt;code&gt;flush&lt;/code&gt; . Вы можете очистить буфер в любое время без автоматической буферизации</target>
        </trans-unit>
        <trans-unit id="5839e7279588dcb1c4433f17b527ae9a9d772eed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Bidirectional Communication with Another Process in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Bidirectional Communication with Yourself in perlipc&lt;/a&gt;</source>
          <target state="translated">Модуль &lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt; (часть стандартного дистрибутива perl) - это простой в использовании подход, который внутренне использует &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; для выполнения работы. Убедитесь, что вы прочитали предупреждения о взаимной блокировке в документации (см. &lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt; ). См. &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Двунаправленную связь с другим процессом в perlipc&lt;/a&gt; и двунаправленную &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;связь с самим собой в perlipc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09e04b4b58ffa26e2662b854208dafbdb133126a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="translated">Пакет &lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt; обрабатывает это, а также кодировку MIME / QP. Расшифровка базы 64 становится такой же простой, как:</target>
        </trans-unit>
        <trans-unit id="0b7108620b7e75ec5ba066fc83c0e7f6113d802f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma provides some functions for manipulating the method cache directly.</source>
          <target state="translated">&lt;a href=&quot;mro&quot;&gt;MRO&lt;/a&gt; Прагма предоставляет некоторые функции для работы с кэшем метода напрямую.</target>
        </trans-unit>
        <trans-unit id="f076d77a637b12522b1379f81df9ca81640a9292" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;net/domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="translated">Модуль &lt;a href=&quot;net/domain&quot;&gt;Net :: Domain&lt;/a&gt; , который является частью стандартной библиотеки, начиная с Perl 5.7.3, может предоставить вам полное доменное имя (FQDN), имя хоста или имя домена.</target>
        </trans-unit>
        <trans-unit id="76dc71fd851bfecf3d4eefc768e03ef389a05460" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">&lt;a href=&quot;open&quot;&gt;Открытая&lt;/a&gt; Прагма влияет на все &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; вызовы после прагмы путем установки слоев по умолчанию. Если вы хотите воздействовать только на определенные потоки, используйте явные слои непосредственно в вызове &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5f1dd446b40bac39fbf56bdb1eee6bbfa27f8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;open()&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;open()&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf8373e5ee8839618cf4f3d8412574499af0964" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; module is one of several ways that Perl lets you define inheritance relationships.</source>
          <target state="translated">&lt;a href=&quot;parent&quot;&gt;Родительский&lt;/a&gt; модуль является одним из нескольких способов , которые Perl позволяет определить отношения наследования.</target>
        </trans-unit>
        <trans-unit id="4ba42fed843fbbf72076d217b81b8e5c3f052f2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;${^UNICODE}&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0fe01583804e7c24edcd36bf4d1dc86edd7004" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C &lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt;.</source>
          <target state="translated">Параметр командной строки &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; может указывать, что определенные входные данные программы являются Unicode, и значения этого могут быть прочитаны вашим кодом Perl, см. &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;$ {^ UNICODE} в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc877ff3004436e21e412f3d7536c1241e3ab1bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd5f1da5843d43e215f1c5605c7bd2602ba3c8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="translated">В документации &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; есть общие советы по безопасности данных. Если вы используете модуль &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; , используйте заполнитель для заполнения данных. Если вы запускаете внешние программы с помощью &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , используйте формы списка. Есть много других мер предосторожности, которые вы должны предпринять, их слишком много, чтобы перечислить здесь, и большинство из них подпадают под категорию неиспользования каких-либо данных, которые вы не собираетесь использовать. Не доверять никому.</target>
        </trans-unit>
        <trans-unit id="a18edb94d1038cfdd671ad02ef0a771da5913e80" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d872a7f80e3dcd2bcfe4f77e0ab218cfcf5f3d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e969c75d9a86d34240a9b4b0c3bacd72a35586a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; variable and the &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; values for various DOSish perls are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dddc8cefb2df3a4b2f380a117370ecb94e0324" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and a number of other mathematical and trigonometric functions.</source>
          <target state="translated">Модуль &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; (часть стандартного дистрибутива Perl) реализует &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; и ряд других математических и тригонометрических функций.</target>
        </trans-unit>
        <trans-unit id="3cfd8963d803d863b1baabc1a6fb32761a10e916" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt;, &lt;code&gt;floor()&lt;/code&gt;, and a number of other mathematical and trigonometric functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb81881ffc1ffa7659057b3aad0d531c1c255d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module can also format a date as the day of the year or week of the year.</source>
          <target state="translated">Модуль &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; также может форматировать дату как день года или неделю года.</target>
        </trans-unit>
        <trans-unit id="f19febd4ca12ddc4d78578d816e9ed0531d16d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module makes extensive use of this type.</source>
          <target state="translated">Модуль &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; широко использует этот тип.</target>
        </trans-unit>
        <trans-unit id="dda44e28f3e372b46a40263a9e3342beb0a11995" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix#getattr&quot;&gt;&lt;code&gt;POSIX::getattr&lt;/code&gt;&lt;/a&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;a href=&quot;Term::ReadKey&quot;&gt;&lt;code&gt;Term::ReadKey&lt;/code&gt;&lt;/a&gt; module on CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9379f8868c28dae16be3be866b6601876aaeaba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;provide&quot;&gt;provide&lt;/a&gt; module from CPAN can be used to select one of several possible modules to load based on the version of Perl that is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0fd33e8403b054935aab9d8ee0ab65dd34b689" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; module to alter behaviour and aid debugging.</source>
          <target state="translated">Модуль &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; для изменения поведения и помощи при отладке.</target>
        </trans-unit>
        <trans-unit id="82ec47dd24e184de112e4cf2a9605a038adc3316" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb49b0f767217eaf2addd5f51c9329970eca01df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sys/hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="translated">Модуль &lt;a href=&quot;sys/hostname&quot;&gt;Sys :: Hostname&lt;/a&gt; , входящий в стандартную библиотеку, также может получить имя хоста:</target>
        </trans-unit>
        <trans-unit id="220edf79ba9ff4834b00c1168d4289b47c73eb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;term/cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="translated">Модуль &lt;a href=&quot;term/cap&quot;&gt;Term :: Cap&lt;/a&gt; также может получить специальную последовательность, если вы хотите иметь дело с низкоуровневыми деталями управления терминалом. Метод &lt;code&gt;Tputs&lt;/code&gt; возвращает строку для данной возможности:</target>
        </trans-unit>
        <trans-unit id="e87c5439cafd856838e66bb969aac3bccda2430c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="translated">Эти &lt;a href=&quot;threads&quot;&gt;нити&lt;/a&gt; и &lt;a href=&quot;threads/shared&quot;&gt;нити :: общие&lt;/a&gt; модули включены в дистрибутив ядра Perl. Кроме того, они поддерживаются как отдельные модули на CPAN, так что вы можете проверять наличие обновлений там.</target>
        </trans-unit>
        <trans-unit id="f6686ccb369690f0486ecaf90ca58010d28981b5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9bb0674257a5140b5151993d5c3d3a37202400" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the basic functions you need to write threaded programs. In the following sections, we'll cover the basics, showing you what you need to do to create a threaded program. After that, we'll go over some of the features of the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module that make threaded programming easier.</source>
          <target state="translated">Модуль &lt;a href=&quot;threads&quot;&gt;потоков&lt;/a&gt; предоставляет основные функции, необходимые для написания многопоточных программ. В следующих разделах мы рассмотрим основы и покажем, что вам нужно сделать для создания многопоточной программы. После этого мы рассмотрим некоторые функции модуля &lt;a href=&quot;threads&quot;&gt;потоков,&lt;/a&gt; которые упрощают многопоточное программирование.</target>
        </trans-unit>
        <trans-unit id="2a739a40945ec3475dfa2806df561fe8eb1d910a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="translated">Модуль &lt;a href=&quot;threads&quot;&gt;потоков&lt;/a&gt; предоставляет инструменты, необходимые для создания новых потоков. Как и любой другой модуль, вам нужно сообщить Perl, что вы хотите его использовать; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; импортирует все элементы, необходимые для создания основных потоков.</target>
        </trans-unit>
        <trans-unit id="5c7c73d979dc1bd0fbebb065f801ce33de931673" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;use threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95afd4b80a6c32d7d4b6fc126fc11993d69484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">В &lt;a href=&quot;time/gmtime&quot;&gt;:: gmtime Время&lt;/a&gt; и &lt;a href=&quot;time/localtime&quot;&gt;Time :: МестноеВремя&lt;/a&gt; модули обеспечивают удобную, по имени механизма доступа к gmtime () и МестноеВремя () функции, соответственно.</target>
        </trans-unit>
        <trans-unit id="27e7660ba02616c82b0460251677001be2bab8d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;.</source>
          <target state="translated">Модуль &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; (часть стандартного дистрибутива Perl 5.8) измеряет время с &lt;code&gt;gettimeofday()&lt;/code&gt; системного вызова gettimeofday () , который возвращает время в микросекундах с начала эпохи. Если вы не можете установить &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; для старых Perls и используете систему Unixish, вы можете напрямую вызвать &lt;code&gt;gettimeofday(2)&lt;/code&gt; . См. &lt;a href=&quot;functions/syscall&quot;&gt;Syscall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70cd112c1d983694e459a2b5affce0b2c176b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object, and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="translated">Модуль &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; экспортирует новое &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; которое возвращает объект, а &lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt; экспортирует константу &lt;code&gt;ONE_DAY&lt;/code&gt; , которая представляет собой заданное количество секунд. Это означает, что он всегда показывает время 24 часа назад, а это не всегда вчера. Это может вызвать проблемы в конце летнего времени, когда один день длится 25 часов.</target>
        </trans-unit>
        <trans-unit id="ad7b96811e1e0447b346c7c68b0b6f49a0e303ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="translated">Модуль &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; , поставляемый с Perl, заменяет &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; версией, возвращающей объект. Он также перегружает операторы сравнения, поэтому вы можете сравнивать их напрямую:</target>
        </trans-unit>
        <trans-unit id="3b4c77d08ed357c92167918b7693fcf1d9ab7f90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;universal#VERSION-%28-%5B-REQUIRE-%5D-%29&quot;&gt;default &lt;code&gt;VERSION&lt;/code&gt; method&lt;/a&gt;, inherited from the &lt;a href=&quot;universal&quot;&gt;&lt;code&gt;UNIVERSAL&lt;/code&gt;&lt;/a&gt; class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b06bcf860d30364b7b86c5e727206450a5e8ad8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module provides the most reliable way to compare version numbers in all the various ways they might be provided or might exist within modules. Given two strings containing version numbers, &lt;code&gt;$v1&lt;/code&gt; and &lt;code&gt;$v2&lt;/code&gt;, they should be converted to &lt;code&gt;version&lt;/code&gt; objects before using ordinary comparison operators. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7624d8ccf09fad70c6649ad6b1aa4fa701ecfb1c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; flag controls some of the Perl Unicode features.</source>
          <target state="translated">&lt;b&gt;-C&lt;/b&gt; флаг контролирует некоторые из Perl Unicode особенности.</target>
        </trans-unit>
        <trans-unit id="eeee1b2385aaa3798bce91466fcda51762a843eb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; option only works if it is specified on the command line as well (with the same sequence of letters or numbers following). Either specify this option on the command line, or, if your system supports it, make your script executable and run it directly instead of passing it to perl.</source>
          <target state="translated">Параметр &lt;b&gt;-C&lt;/b&gt; работает, только если он также указан в командной строке (с той же последовательностью букв или цифр). Либо укажите эту опцию в командной строке, либо, если ваша система поддерживает ее, сделайте свой скрипт исполняемым и запустите его напрямую вместо передачи в perl.</target>
        </trans-unit>
        <trans-unit id="adbe88919d7c337e67d217e417ae52c5e78e86cc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="translated">&lt;b&gt;-DL&lt;/b&gt; ключ командной строки является устаревшим , так как около Perl 5.6.0 (она была доступна только если Perl был построен с &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). Переключатель использовался для отслеживания распределения памяти Perl и возможных утечек памяти. В наши дни использование инструментов отладки malloc, таких как</target>
        </trans-unit>
        <trans-unit id="10ff88d6a964ef244acd1861f020528cdc0021d6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt;). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a02c2d05901d298065bac05eaefdaf89b098f1d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-a&lt;/b&gt; option followed by the name of a perl api function will extract the documentation of this function from &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;b&gt;-a,&lt;/b&gt; за которым следует имя функции perl api, извлекает документацию по этой функции из &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7458f799f2d3bc9e0821f8f30b793deae5a843f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-f&lt;/b&gt; option followed by the name of a perl built-in function will extract the documentation of this function from &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;b&gt;-f,&lt;/b&gt; за которым следует имя встроенной функции perl, извлекает документацию по этой функции из &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1902e94f8bb188d5617c0fc133e4af994267a619" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-q&lt;/b&gt; option takes a regular expression as an argument. It will search the &lt;b&gt;q&lt;/b&gt;uestion headings in perlfaq[1-9] and print the entries matching the regular expression.</source>
          <target state="translated">Параметр &lt;b&gt;-q&lt;/b&gt; принимает в качестве аргумента регулярное выражение. Он будет искать &lt;b&gt;д&lt;/b&gt; uestion заголовков в perlfaq [1-9] и распечатать данные , соответствующие регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="5344e76d29fb1384ca26893a56599519b1faad07" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-v&lt;/b&gt; option followed by the name of a Perl predefined variable will extract the documentation of this variable from &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Параметр &lt;b&gt;-v,&lt;/b&gt; за которым следует имя предопределенной переменной Perl, извлекает документацию по этой переменной из &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ae0073660f495c2b0b0a5aff71edb22c20f2cb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-verbose&lt;/b&gt; flag first prints out the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introduction before any other diagnostics. The $diagnostics::PRETTY variable can generate nicer escape sequences for pagers.</source>
          <target state="translated">&lt;b&gt;-Verbose&lt;/b&gt; флаг первым печатает &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; введения перед любой другой диагностикой. Переменная $ Diagnostics :: PRETTY может генерировать более удобные escape-последовательности для пейджеров.</target>
        </trans-unit>
        <trans-unit id="ceb38ecccfec93207c00c9dee183b84b32a5f056" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-w&lt;/b&gt; flag just sets the global &lt;code&gt;$^W&lt;/code&gt; variable as in 5.005. This means that any legacy code that currently relies on manipulating &lt;code&gt;$^W&lt;/code&gt; to control warning behavior will still work as is.</source>
          <target state="translated">&lt;b&gt;-W&lt;/b&gt; флаг просто устанавливает глобальный &lt;code&gt;$^W&lt;/code&gt; переменную в 5.005. Это означает, что любой устаревший код, который в настоящее время полагается на манипулирование &lt;code&gt;$^W&lt;/code&gt; для управления поведением предупреждений, по-прежнему будет работать как есть.</target>
        </trans-unit>
        <trans-unit id="72bbdbcc137e1ec7edde830d8069bcdc7d47c4dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; is similar in purpose to &lt;b&gt;SelfLoader&lt;/b&gt;: both delay the loading of subroutines.</source>
          <target state="translated">&lt;b&gt;AutoLoader&lt;/b&gt; подобен в целях &lt;b&gt;SelfLoader&lt;/b&gt; : как задержка загрузки подпрограмм.</target>
        </trans-unit>
        <trans-unit id="0f53ec7201e8a617c94e28662bed3af80a664f4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; module works with the &lt;b&gt;AutoSplit&lt;/b&gt; module and the &lt;code&gt;__END__&lt;/code&gt; token to defer the loading of some subroutines until they are used rather than loading them all at once.</source>
          <target state="translated">Модуль &lt;b&gt;AutoLoader&lt;/b&gt; работает с модулем &lt;b&gt;AutoSplit&lt;/b&gt; и токеном &lt;code&gt;__END__&lt;/code&gt; , чтобы отложить загрузку некоторых подпрограмм до тех пор, пока они не будут использованы, а не загружать их все сразу.</target>
        </trans-unit>
        <trans-unit id="93865b59868e970114227e97ec05c9ea3f594f39" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ExtUtils::Embed&lt;/b&gt; kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</source>
          <target state="translated">Комплект &lt;b&gt;ExtUtils :: Embed&lt;/b&gt; на CPAN также содержит весь исходный код примеров в этом документе, тесты, дополнительные примеры и другую информацию, которая может оказаться полезной.</target>
        </trans-unit>
        <trans-unit id="78c68d8eddf3cc79f99821ef8cc24a0430101c54" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362af90dceed3d87816d0dcbc3d699668f7c9c9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Расширение &lt;b&gt;ввода-вывода&lt;/b&gt; , &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; , &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;операторы ввода-вывода в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4ddb503abc843b9ef214b377226c71b441a111a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Pod::Hyperlink&lt;/b&gt; class is mainly designed to parse the contents of the &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence, providing a simple interface for accessing the different parts of a POD hyperlink for further processing. It can also be used to construct hyperlinks.</source>
          <target state="translated">Класс &lt;b&gt;Pod :: Hyperlink&lt;/b&gt; в основном предназначен для анализа содержимого последовательности &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; , обеспечивая простой интерфейс для доступа к различным частям гиперссылки POD для дальнейшей обработки. Его также можно использовать для создания гиперссылок.</target>
        </trans-unit>
        <trans-unit id="159cbd250976e52bd0b54f9fbb2c920f60501cf2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt; . You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; может заменить AutoLoader - только изменения &amp;laquo;использовать автозагрузчик&amp;raquo; на &amp;laquo;использовании SelfLoader&amp;raquo; (хотя отмечают , что &lt;b&gt;SelfLoader&lt;/b&gt; экспортирует функцию AUTOLOAD - но если у вас есть своя собственная автозагрузка и используют AutoLoader тоже, вы , вероятно , знаете , что вы делать), а &lt;code&gt;__END__&lt;/code&gt; маркер &lt;code&gt;__DATA__&lt;/code&gt; . Для использования вам потребуется perl версии 5.001m или более поздней (версия 5.001 со всеми патчами до патча m).</target>
        </trans-unit>
        <trans-unit id="b4c86354fde60d804671cf8056d3c10e6c5b0099" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt;. You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc1e94494f4935e31dcd4aca4dd8097e05b3034" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; exports the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine to the package using the &lt;b&gt;SelfLoader&lt;/b&gt;, and this loads the called subroutine when it is first called.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; экспортирует &lt;code&gt;AUTOLOAD&lt;/code&gt; подпрограмму в пакет с помощью &lt;b&gt;SelfLoader&lt;/b&gt; , и это загружает вызываемую подпрограмму , когда она первая называется.</target>
        </trans-unit>
        <trans-unit id="be3fad23fb52579393cf97f6d16c823542fd3d2f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt; . This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; не читает , где текущее положение &lt;code&gt;FOOBAR::DATA&lt;/code&gt; указатель_на_файла есть до конца файла или &lt;code&gt;__END__&lt;/code&gt; . Это означает, что если вы хотите использовать этот дескриптор файла (и ТОЛЬКО, если хотите), вы должны либо</target>
        </trans-unit>
        <trans-unit id="11f27c5dcec516e53a8a4d6fd79ba993403bc153" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt;. This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f59147d20cbbd96eaf3ce69c4654c447143a93e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt; , and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt; , and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; будет читать из FOOBAR :: DATA дескриптор файла для загрузки данных после &lt;code&gt;__DATA__&lt;/code&gt; и нагрузки в любой подпрограмме , когда она вызывается. Затраты включают однократный анализ данных после &lt;code&gt;__DATA__&lt;/code&gt; и задержку загрузки для _first_ вызова любой автоматически загружаемой функции. Преимущества (надеюсь) - это ускоренная фаза компиляции без необходимости загружать функции, которые никогда не используются.</target>
        </trans-unit>
        <trans-unit id="661b13cb881f0c177baa79d2f9cc5c08efa1139f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt;, and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt;, and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9076a846b441722c5113e39b9bcd0673ac55d99" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will stop reading from &lt;code&gt;__DATA__&lt;/code&gt; if it encounters the &lt;code&gt;__END__&lt;/code&gt; token - just as you would expect. If the &lt;code&gt;__END__&lt;/code&gt; token is present, and is followed by the token DATA, then the &lt;b&gt;SelfLoader&lt;/b&gt; leaves the FOOBAR::DATA filehandle open on the line after that token.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; прекратит чтение из &lt;code&gt;__DATA__&lt;/code&gt; , если он встречает &lt;code&gt;__END__&lt;/code&gt; лексема - так же , как и следовало ожидать. Если &lt;code&gt;__END__&lt;/code&gt; токен __END__ , за которым следует токен DATA, то &lt;b&gt;SelfLoader&lt;/b&gt; оставляет дескриптор файла FOOBAR :: DATA открытым в строке после этого токена.</target>
        </trans-unit>
        <trans-unit id="ae4ca9e2af773bc53d6ebfbbbcbbb68e0e663b29" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works by the user placing the &lt;code&gt;__DATA__&lt;/code&gt; token</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; работает пользователем размещающих &lt;code&gt;__DATA__&lt;/code&gt; маркер</target>
        </trans-unit>
        <trans-unit id="b8a45570c1acb4c43b6a7805f6337844a9606503" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt; . Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt; работает аналогично автозагрузчик, но подхватывает подлодки из после &lt;code&gt;__DATA__&lt;/code&gt; вместо в &amp;laquo;/ авто Lib&amp;raquo; каталога. Отсутствие необходимости запускать AutoSplit на модуле при установке дает преимущество в обслуживании, а во время выполнения - отсутствие необходимости постоянно открывать и закрывать файлы для загрузки сабвуферов. &lt;code&gt;__DATA__&lt;/code&gt; в синтаксическом анализе кода после __DATA__ приводит к потере времени выполнения . Подробную информацию об &lt;b&gt;автозагрузчике&lt;/b&gt; и другое представление об этих различиях можно найти в документации этого модуля.</target>
        </trans-unit>
        <trans-unit id="7dcbf6c27d3fbecf0a1da02dbc8cbd5d7c319816" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt;. Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dafc36f54a138d4c7c8beed77372c0b7d94298" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Array&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">Реализация &lt;b&gt;Tie :: Array&lt;/b&gt; - это заглушка, которая просто хрипит.</target>
        </trans-unit>
        <trans-unit id="6b199766c781a0ae9ebeafd1ad9efb33847e8a69" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Hash&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">Реализация &lt;b&gt;Tie :: Hash&lt;/b&gt; - это заглушка, которая просто хрипит.</target>
        </trans-unit>
        <trans-unit id="4134fa729bc36043c1bbc4226f0d69bd4bd166dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdArray&lt;/b&gt; package provides efficient methods required for tied arrays which are implemented as blessed references to an &quot;inner&quot; perl array. It inherits from &lt;b&gt;Tie::Array&lt;/b&gt;, and should cause tied arrays to behave exactly like standard arrays, allowing for selective overloading of methods.</source>
          <target state="translated">Пакет &lt;b&gt;Tie :: StdArray&lt;/b&gt; предоставляет эффективные методы, необходимые для связанных массивов, которые реализованы как благословенные ссылки на &amp;laquo;внутренний&amp;raquo; массив Perl. Он наследуется от &lt;b&gt;Tie :: Array&lt;/b&gt; и должен приводить к тому, что связанные массивы ведут себя точно так же, как стандартные массивы, обеспечивая выборочную перегрузку методов.</target>
        </trans-unit>
        <trans-unit id="61ae2de46d00875a51e425357ad71e5ccdd2ad38" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="translated">&lt;b&gt;Tie :: StdHandle&lt;/b&gt; пакет обеспечивает большинство методов для дескрипторов файлов , описанных в &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (исключение составляет &lt;code&gt;UNTIE&lt;/code&gt; и &lt;code&gt;DESTROY&lt;/code&gt; ). Это приводит к тому, что связанные дескрипторы файлов ведут себя точно так же, как стандартные дескрипторы файлов, и допускают выборочную перезапись методов.</target>
        </trans-unit>
        <trans-unit id="4245a18625b67300aa61449aa8288d150f2262ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt;). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacf0e41a2a5258a61ae34656b72764dd7acc141" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::SubstrHash&lt;/b&gt; package provides a hash-table-like interface to an array of determinate size, with constant key size and record size.</source>
          <target state="translated">Пакет &lt;b&gt;Tie :: SubstrHash&lt;/b&gt; предоставляет интерфейс, подобный хэш-таблице, для массива определенного размера с постоянным размером ключа и размером записи.</target>
        </trans-unit>
        <trans-unit id="a8a3a1e60f743e1378ee92d392f9857036d4b3d2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;begincheck&lt;/b&gt; program makes it all clear, eventually:</source>
          <target state="translated">Программа &lt;b&gt;begincheck&lt;/b&gt; со временем проясняет все:</target>
        </trans-unit>
        <trans-unit id="1112db1b82f4fc99681fd70d53f56d13ced227cf" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma changes this to use the specified encoding instead. For example:</source>
          <target state="translated">&lt;b&gt;Кодирующая&lt;/b&gt; Прагма изменяет это значение для использования заданной кодировки вместо. Например:</target>
        </trans-unit>
        <trans-unit id="b7162377ab2247a065b27f7ed4e48c5d078da511" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Therefore,</source>
          <target state="translated">&lt;b&gt;Кодирование&lt;/b&gt; прагма работает путем декодирования строковых литералов в &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; и так далее. В perl v5.8.0 это не относится к &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . Следовательно,</target>
        </trans-unit>
        <trans-unit id="0567b6469c4f0ce811f82d15382d41c3cb9254e1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;tr///&lt;/code&gt;. Therefore,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80faef413c7207aab71b9f1d03988df6331ef791" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Файл&lt;/b&gt; (или &lt;b&gt;строка&lt;/b&gt; , в случае &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ) , который в настоящее время &lt;b&gt;составляются&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b93fec3ba5d429ebcf5cae82011aef3ec4a01036" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;eval&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5cf33051195df3d457e45e85209f2138dc4a05" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;first time&lt;/b&gt; the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</source>
          <target state="translated">При &lt;b&gt;первом&lt;/b&gt; обращении к ловушке в потоке сериализации она может вернуть пустой список. Это будет сигналом подсистеме Storable к дальнейшему отказу от этой ловушки для этого класса и, следовательно, к возврату к стандартной сериализации базовых данных Perl. При следующей сериализации ловушка снова будет нормально обработана.</target>
        </trans-unit>
        <trans-unit id="31b896e0d53803b62960180dd945e43dfa7f81e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;garbage collection&lt;/b&gt; of globals (and the running of any associated object destructors) that takes place when a Perl &lt;b&gt;interpreter&lt;/b&gt; is being shut down. Global destruction should not be confused with the Apocalypse, except perhaps when it should.</source>
          <target state="translated">&lt;b&gt;Вывоз мусора&lt;/b&gt; из глобалов (и работает в любых связанных с ними объектов деструкторов) , что имеет место , когда Perl &lt;b&gt;интерпретатор&lt;/b&gt; завершит свою работу в . Глобальное разрушение не следует путать с Апокалипсисом, за исключением случаев, когда это следует делать.</target>
        </trans-unit>
        <trans-unit id="987526f88e29534e7fb822b3987e499066378921" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt; . Some more examples are</source>
          <target state="translated">В &lt;b&gt;группировке&lt;/b&gt; метасимволов &lt;code&gt;()&lt;/code&gt; позволяют часть регулярного выражения следует рассматривать как единое целое. Части регулярного выражения группируются путем заключения их в круглые скобки. Регулярное выражение &lt;code&gt;house(cat|keeper)&lt;/code&gt; означает &lt;code&gt;house&lt;/code&gt; за которым следует &lt;code&gt;cat&lt;/code&gt; или &lt;code&gt;keeper&lt;/code&gt; . Еще несколько примеров</target>
        </trans-unit>
        <trans-unit id="8b06519ab9371f66acf34ade00457226ccfb28ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt;. Some more examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba87bd98015a685039202791b8b4c178941ed0ba" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;interpolation&lt;/b&gt; of a scalar or array variable into a string.</source>
          <target state="translated">&lt;b&gt;Интерполяция&lt;/b&gt; переменной скалярного или массива в строку.</target>
        </trans-unit>
        <trans-unit id="fd9fd954815d11416f915389911ed3472be1a48a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;new()&lt;/b&gt; method can either be passed a set of key/value pairs or a single scalar value, namely the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. An object of the class &lt;code&gt;Pod::Hyperlink&lt;/code&gt; is returned. The value &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indicates a failure, the error message is stored in &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">В метод &lt;b&gt;new ()&lt;/b&gt; можно передать либо набор пар ключ / значение, либо одно скалярное значение, а именно содержимое последовательности &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; . Возвращается объект класса &lt;code&gt;Pod::Hyperlink&lt;/code&gt; . Значение &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; указывает на сбой, сообщение об ошибке сохраняется в &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22dcd0ec3aed7a2c1842ef98e2374e061c59b868" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;package&lt;/b&gt; in which the current statement is &lt;b&gt;compiled&lt;/b&gt;. Scan backward in the text of your program through the current &lt;b&gt;lexical scope&lt;/b&gt; or any enclosing lexical scopes until you find a package declaration. That&amp;rsquo;s your current package name.</source>
          <target state="translated">&lt;b&gt;Пакет&lt;/b&gt; , в котором текущий оператор &lt;b&gt;скомпилирован&lt;/b&gt; . Сканируйте назад по тексту вашей программы через текущую &lt;b&gt;лексическую область видимости&lt;/b&gt; или любые включающие лексические области, пока не найдете объявление пакета. Это ваше текущее имя пакета.</target>
        </trans-unit>
        <trans-unit id="837534d7853b1df8d6be64303da76d4fb655fe6c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parse_text()&lt;/b&gt; method takes a given paragraph of text, and returns a parse-tree that contains one or more children, each of which may be a text-string, or an InteriorSequence object. There are also callback-options that may be passed to &lt;b&gt;parse_text()&lt;/b&gt; to customize the way it expands or transforms interior-sequences, as well as the returned result. These callbacks can be used to create a parse-tree with custom-made objects (which may or may not support the parse-tree interface, depending on how you choose to do it).</source>
          <target state="translated">Метод &lt;b&gt;parse_text ()&lt;/b&gt; принимает заданный абзац текста и возвращает дерево синтаксического анализа, которое содержит один или несколько дочерних элементов, каждый из которых может быть текстовой строкой или объектом InteriorSequence. Есть также параметры обратного вызова, которые можно передать в &lt;b&gt;parse_text (),&lt;/b&gt; чтобы настроить способ расширения или преобразования внутренних последовательностей, а также возвращаемый результат. Эти обратные вызовы могут использоваться для создания дерева синтаксического анализа с настраиваемыми объектами (которые могут поддерживать или не поддерживать интерфейс дерева синтаксического анализа, в зависимости от того, как вы решите это сделать).</target>
        </trans-unit>
        <trans-unit id="b2fcda0a32417727cdd721f28d0c908b93bc1f19" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;perlivp&lt;/b&gt; program is set up at Perl source code build time to test the Perl version it was built under. It can be used after running:</source>
          <target state="translated">Программа &lt;b&gt;perlivp&lt;/b&gt; устанавливается во время сборки исходного кода Perl для тестирования версии Perl, под которой она была создана. Его можно использовать после бега:</target>
        </trans-unit>
        <trans-unit id="dc37ad02e0c6923bebd0d4430ccd02307461404f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; command is provided for checking Pod syntax for errors and warnings. For example, it checks for completely blank lines in Pod blocks and for unknown commands and formatting codes. You should still also pass your document through one or more translators and proofread the result, or print out the result and proofread that. Some of the problems found may be bugs in the translators, which you may or may not wish to work around.</source>
          <target state="translated">Команда &lt;b&gt;podchecker&lt;/b&gt; предназначена для проверки синтаксиса Pod на наличие ошибок и предупреждений. Например, он проверяет наличие полностью пустых строк в блоках Pod, а также неизвестных команд и кодов форматирования. Вы все равно должны передать свой документ одному или нескольким переводчикам и вычитать результат или распечатать результат и вычитать его. Некоторые из обнаруженных проблем могут быть ошибками в переводчиках, которые вы можете или не захотите исправлять.</target>
        </trans-unit>
        <trans-unit id="0a20174d8e3b5a76e2734d6eb6a0cf7707e14ad1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; script that comes with this distribution is a lean wrapper around this module. See the online manual with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299b97d8bab37b1330370eb9473b8a413d005a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="translated">В &lt;b&gt;кванторные&lt;/b&gt; метасимволы &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;{}&lt;/code&gt; позволяют нам определять количество повторов части регулярного выражения, которое мы считаем совпадением. Квантификаторы помещаются сразу после символа, класса символа или группы, которую мы хотим указать. Они имеют следующие значения:</target>
        </trans-unit>
        <trans-unit id="eaae51c09e62ae41b20067864a8beaa2340f2425" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b54e7f659f70ec7a4f3708e917b8834ab10ef21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="translated">В &lt;b&gt;скалярные значения&lt;/b&gt; , которые вы поставляете к &lt;b&gt;функции&lt;/b&gt; или &lt;b&gt;подпрограммы&lt;/b&gt; при вызове его. Например, когда вы вызываете &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , фактическим аргументом является строка &lt;code&gt;&quot;puff&quot;&lt;/code&gt; . См. Также &lt;b&gt;аргументы&lt;/b&gt; и &lt;b&gt;формальные аргументы&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="322845e84e15f9ba6a6f987f2f0f5a926b87542a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt;, the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a023f0632e523744570838f6670cc7a9e367c0e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="translated">&lt;b&gt;SIGTRAP&lt;/b&gt; прагма представляет собой простой интерфейс для установки обработчиков сигналов. Вы можете установить один из двух обработчиков, поставляемых самим &lt;b&gt;sigtrap&lt;/b&gt; (один, который обеспечивает трассировку стека Perl, а другой просто &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; s), или, альтернативно, вы можете предоставить свой собственный обработчик для его установки. Можно указать только установить обработчик сигналов, которые либо не перехватываются, либо игнорируются. У него есть несколько списков сигналов для перехвата, плюс вы можете предоставить свой собственный список сигналов.</target>
        </trans-unit>
        <trans-unit id="9bf9f6bd9139c0d963b36b36175d399537dfc4fb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;die()&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c162ba3d4340b1ed67afae232423e0f505fd2b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; produced by a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;expression&lt;/b&gt; when evaluated. In Perl, a return value may be either a &lt;b&gt;list&lt;/b&gt; or a &lt;b&gt;scalar&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Значение&lt;/b&gt; производится с помощью &lt;b&gt;подпрограммы&lt;/b&gt; или &lt;b&gt;выражений&lt;/b&gt; при оценке. В Perl возвращаемое значение может быть &lt;b&gt;списком&lt;/b&gt; или &lt;b&gt;скаляром&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7487920171bd7708f5f44fcbcd3a51b3cd669ff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt; . Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="translated">&lt;b&gt;Значение&lt;/b&gt; возвращается в родительский &lt;b&gt;процесс&lt;/b&gt; , когда один из его дочерних процессов умирает. Это значение помещается в специальную переменную &lt;code&gt;$?&lt;/code&gt; . Его восемь верхних &lt;b&gt;битов&lt;/b&gt; - это статус завершения неработающего процесса, а его нижние восемь битов определяют сигнал (если есть), из-за которого процесс умер. В системах Unix это значение состояния совпадает со словом состояния, возвращаемым</target>
        </trans-unit>
        <trans-unit id="92fc59668896181422dc0c709aa06976d25a8bdd" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt;. Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f87bdfa0eb35c4f5fe0a1642de1f3532d7289" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">Эти &lt;b&gt;значения&lt;/b&gt; вы поставляете вместе с названием программы , когда вы говорите &lt;b&gt;оболочки&lt;/b&gt; , чтобы выполнить &lt;b&gt;команду&lt;/b&gt; . Эти значения передаются программе Perl через &lt;code&gt;@ARGV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41ad86c2a0eef157efad4b1818e0188a3bba4d01" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8215a7b783f151c4ff06cfd84ff859eb48442e77" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">&lt;b&gt;Слово якорь &lt;/b&gt; &lt;code&gt;\b&lt;/code&gt; соответствует границе между характером слова и без символа слова &lt;code&gt;\w\W&lt;/code&gt; или &lt;code&gt;\W\w&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e0d33c43c6614d46185d88549fdc18a2c8537ffc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98df2a206a33c61c05323edbf28b990dfe8bb9b6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c. The C code created makes heavy use of the C functions within Perl.</source>
          <target state="translated">Программа &lt;b&gt;xsubpp&lt;/b&gt; берет код XS из файла .xs и переводит его в код C, помещая его в файл с суффиксом .c. Созданный код C интенсивно использует функции C в Perl.</target>
        </trans-unit>
        <trans-unit id="e9db711485ba959f3d0b453c931365b6638809a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.). These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion below, but all the nitty-gritty details can be found in &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;. If you have a new-enough version of perl (5.16 and up) or an upgraded XS compiler (&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 or better), then you can inline typemaps in your XS instead of writing separate files. Either way, this typemap thing is split into three parts:</source>
          <target state="translated">Программа &lt;b&gt;xsubpp&lt;/b&gt; использует правила для преобразования типов данных Perl (скалярные, массивы и т. Д.) В типы данных языка C (int, char и т. Д.). Эти правила хранятся в файле карты типов ($ PERLLIB / ExtUtils / typemap). Ниже приводится краткое обсуждение, но все подробности можно найти в &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; . Если у вас достаточно новая версия perl (5.16 и выше) или обновленный компилятор XS ( &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 или лучше), вы можете встроить карты типов в свой XS вместо того, чтобы писать отдельные файлы. В любом случае, эта карта типов разделена на три части:</target>
        </trans-unit>
        <trans-unit id="1082cc04157e373604ca98ab1606eeb58e2bd5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; $output &lt;/code&gt; argument may be:</source>
          <target state="translated">&lt;code&gt; $output &lt;/code&gt; аргумент может быть:</target>
        </trans-unit>
        <trans-unit id="fe02d79593918e0f0b57f9efa92b9388e3573b1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;)&quot;&lt;/code&gt; is out-of-place. Something apparently was supposed to be combined with the digits, or the &lt;code&gt;&quot;+&quot;&lt;/code&gt; shouldn't be there, or something like that. Perl can't figure out what was intended.</source>
          <target state="translated">Знак &lt;code&gt;&quot;)&quot;&lt;/code&gt; неуместен. Очевидно, что-то должно было сочетаться с цифрами, или не должно было быть &lt;code&gt;&quot;+&quot;&lt;/code&gt; , или что-то в этом роде. Perl не может понять, что было задумано.</target>
        </trans-unit>
        <trans-unit id="b82e89101d474c0486e6c08a915553c14b105df6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt;, the &lt;code&gt;&quot;+&quot;&lt;/code&gt; quantifier to &lt;code&gt;{1,}&lt;/code&gt;, and the &lt;code&gt;&quot;?&quot;&lt;/code&gt; quantifier to &lt;code&gt;{0,1}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bbd851b5114dd4dbacbd6abc257c5bbd630765" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;&lt;code&gt;(?&lt;i&gt;PARNO&lt;/i&gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54034a923125cadab60eef06f26fcb91d4e7c351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;.</source>
          <target state="translated">Знак &lt;code&gt;&quot;+&quot;&lt;/code&gt; действителен только тогда, когда за ним следуют цифры, обозначающие группу захвата. См. &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? ПАРНО)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07bb712ac114a7fe219229eb5a67b484b3ca58ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;+&quot;&lt;/code&gt; don't have any effect, as they modify whether to match more or fewer when there is a choice, and by specifying to match exactly a given numer, there is no room left for a choice.</source>
          <target state="translated">Знак &lt;code&gt;&quot;?&quot;&lt;/code&gt; и &lt;code&gt;&quot;+&quot;&lt;/code&gt; не имеют никакого эффекта, поскольку они изменяют, нужно ли соответствовать большему или меньшему количеству, когда есть выбор, и, указав совпадение точно с заданным числом, не остается места для выбора.</target>
        </trans-unit>
        <trans-unit id="622f5262d7227133a18718033006d1fe595c3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;U&quot;&lt;/code&gt; template has been ported to mean &quot;Unicode&quot; on all platforms so that</source>
          <target state="translated">&lt;code&gt;&quot;U&quot;&lt;/code&gt; шаблон был перенесен означает &amp;laquo;Unicode&amp;raquo; на всех платформах , так что</target>
        </trans-unit>
        <trans-unit id="d9a4c62629e10d33b540e16fc1ce8f7a3f41635f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;\x&quot;&lt;/code&gt; construct without curly braces should be followed by exactly two hex digits; this one is followed by three. This currently evaluates as equivalent to</source>
          <target state="translated">За конструкцией &lt;code&gt;&quot;\x&quot;&lt;/code&gt; без фигурных скобок должны следовать ровно две шестнадцатеричные цифры; за этим следуют три. В настоящее время это оценивается как эквивалент</target>
        </trans-unit>
        <trans-unit id="18a8e19a030c3c8f53e48396122990cc28295c5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;a&quot;&lt;/code&gt; is a valid modifier flag, but the &lt;code&gt;&quot;n&quot;&lt;/code&gt; is not, and raises this error. Likely what was meant instead was:</source>
          <target state="translated">&amp;laquo;A &lt;code&gt;&quot;a&quot;&lt;/code&gt; является допустимым флагом модификатора, а &lt;code&gt;&quot;n&quot;&lt;/code&gt; - нет, и вызывает эту ошибку. Вероятно, вместо этого имелось в виду:</target>
        </trans-unit>
        <trans-unit id="14e2e8dae7c922be26733e3e660b25612cc5ce26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="translated">&lt;code&gt;&quot;c&quot;&lt;/code&gt; и &lt;code&gt;&quot;C&quot;&lt;/code&gt; шаблоны для &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; зависят от набора символов кодирования. Примеры использования в EBCDIC:</target>
        </trans-unit>
        <trans-unit id="3a90b3cf3b7660a315d348d508a144827f3fa53e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;pack()&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8f5308cfb898e8f57b9a7b021b28f517778138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; . The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="translated">&lt;code&gt;&quot;code&quot;&lt;/code&gt; подпрограмма будет использоваться только для фильтров части исходного кода, которые не являются quotelikes, POD или &lt;code&gt;__DATA__&lt;/code&gt; . &lt;code&gt;quotelike&lt;/code&gt; подпрограмма фильтрует только quotelikes Perl ( в том числе здесь документов).</target>
        </trans-unit>
        <trans-unit id="00d33c98d86ed179e5a669f2bc40830325b6bdf3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt;. The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5cb8ed1d57c1871e5453eb580a0076b635dfd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; pragma</source>
          <target state="translated">&lt;code&gt;&quot;use locale&quot;&lt;/code&gt; Прагма</target>
        </trans-unit>
        <trans-unit id="9e55a545076df6df5f2e5f8da5ca2fba9b8a556b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; was used to find the beginning of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5361c21bc61e8999f4b7544ffeef33e12b0b1a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;b&gt;-x&lt;/b&gt; was used to find the beginning of the program.</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; строка всегда проверяется на наличие переключателей, когда строка анализируется. Таким образом, если вы работаете на машине, которая допускает только один аргумент с &lt;code&gt;#!&lt;/code&gt; line или, что еще хуже, даже не распознает &lt;code&gt;#!&lt;/code&gt; В строке, вы все равно можете добиться согласованного поведения переключателя независимо от того, как был вызван Perl, даже если &lt;b&gt;-x&lt;/b&gt; использовался для поиска начала программы.</target>
        </trans-unit>
        <trans-unit id="108405af164a595d0a02e5242d4aac5c7a9939f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; form was added in Perl v5.20.0 for historical reasons but its use is discouraged. (If your reason to use &lt;code&gt;$]&lt;/code&gt; is to run code on old perls then referring to it as &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; would be self-defeating.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8b854056feda55458ac395207c0edacf4109d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; doesn't support &lt;code&gt;'IGNORE'&lt;/code&gt;; it has the same effect as &lt;code&gt;'DEFAULT'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cfb8f268bdf180a533e3982943c594a32d2955" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is called even inside an &lt;code&gt;eval()&lt;/code&gt;. It was never intended to happen this way, but an implementation glitch made this possible. This used to be deprecated, as it allowed strange action at a distance like rewriting a pending exception in &lt;code&gt;$@&lt;/code&gt;. Plans to rectify this have been scrapped, as users found that rewriting a pending exception is actually a useful feature, and not a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb2868e39025eacf0d00ec1478ba8ee01a99e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$VERSION&lt;/code&gt; variable is used to ensure that the .pm file and the shared library are &quot;in sync&quot; with each other. Any time you make changes to the .pm or .xs files, you should increment the value of this variable.</source>
          <target state="translated">&lt;code&gt;$VERSION&lt;/code&gt; переменная используется для того, чтобы файл .pm и разделяемые библиотеки являются &amp;laquo;синхронно&amp;raquo; друг с другом. Каждый раз, когда вы вносите изменения в файлы .pm или .xs, вы должны увеличивать значение этой переменной.</target>
        </trans-unit>
        <trans-unit id="2ee72eb90ddce6bbc0931d4e233b1341c5327087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt; ) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="translated">&lt;code&gt;$^O&lt;/code&gt; переменные ( &lt;code&gt;$OSNAME&lt;/code&gt; , если вы используете &lt;code&gt;English&lt;/code&gt; ) содержит указание названия операционной системы ( а не его номер релиза) , что ваш Perl двоичного была построен для.</target>
        </trans-unit>
        <trans-unit id="3c4fecf66108e7576d4b50d6bd4010c1a13f5ea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt;) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2aab00569329bab82f1ebc14faa8b668168dc31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable and the &lt;code&gt;$Config{archname}&lt;/code&gt; values for various DOSish perls are as follows:</source>
          <target state="translated">&lt;code&gt;$^O&lt;/code&gt; переменная и &lt;code&gt;$Config{archname}&lt;/code&gt; значения для различных Перлз DOSish заключаются в следующем:</target>
        </trans-unit>
        <trans-unit id="eba7fdbb831c55f9a441c12e1806775b9e1de0a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$array[1]&lt;/code&gt; is a single-element access to the array. It's going to return the item in index 1 (or undef if there is no item there). If you intend to get exactly one element from the array, this is the form you should use.</source>
          <target state="translated">&lt;code&gt;$array[1]&lt;/code&gt; является доступ с одним элементом массива. Он вернет элемент в индексе 1 (или undef, если там нет элемента). Если вы хотите получить ровно один элемент из массива, вам следует использовать эту форму.</target>
        </trans-unit>
        <trans-unit id="2844c7d661123084d4f84dec0ab13e6bfc03da52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference.</source>
          <target state="translated">Параметр &lt;code&gt;$buffer&lt;/code&gt; может быть скалярной или скалярной ссылкой.</target>
        </trans-unit>
        <trans-unit id="27274181277155f678e99b9a2b287e41860c82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference. The contents of the &lt;code&gt;$buffer&lt;/code&gt; parameter are destroyed after calling this function.</source>
          <target state="translated">Параметр &lt;code&gt;$buffer&lt;/code&gt; может быть скалярной или скалярной ссылкой. После вызова этой функции содержимое параметра &lt;code&gt;$buffer&lt;/code&gt; уничтожается.</target>
        </trans-unit>
        <trans-unit id="8c4fb1959a7d1bef1019739dc5a4ea212bbc1a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt; . When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">Параметр &lt;code&gt;$buffer&lt;/code&gt; изменяется с помощью &lt;code&gt;inflate&lt;/code&gt; . По завершении он будет содержать то, что осталось от входного буфера после инфляции. Это означает, что &lt;code&gt;$buffer&lt;/code&gt; будет пустой строкой при статусе возврата &lt;code&gt;Z_OK&lt;/code&gt; . Когда статус возврата - &lt;code&gt;Z_STREAM_END&lt;/code&gt; , параметр &lt;code&gt;$buffer&lt;/code&gt; будет содержать то, что (если что-то) было сохранено во входном буфере после спущенного потока данных.</target>
        </trans-unit>
        <trans-unit id="735065db643a224d7abc76057afb08424a7f97a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt;. On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt;. When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd78ddf95d786af083e0413cd47b10ceef529f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$context&lt;/code&gt; passed in will be an instance of &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt;. The &lt;code&gt;$exit&lt;/code&gt; argument will be the original exit code before anything modified it. &lt;code&gt;$$new_exit&lt;/code&gt; is a reference to the new exit code. You may modify this to change the exit code. Please note that &lt;code&gt;$$new_exit&lt;/code&gt; may already be different from &lt;code&gt;$exit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f084c43da0252a420f089c62656f2a4438958f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;&quot;parsers&quot;&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4deaa69228d0bed93aa2331246fd160457f98868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;parsers&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="translated">&lt;code&gt;$description&lt;/code&gt; , как правило , имя тестового файла (но только по соглашению) . Он используется в качестве уникального идентификатора (смотрите , например , &lt;a href=&quot;#parsers&quot;&gt;парсер&lt;/a&gt; .) Повторное описание является фатальной ошибкой.</target>
        </trans-unit>
        <trans-unit id="04558cf60bc9c7167d85368eb6635a2473770d4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter needs a bit of explanation.</source>
          <target state="translated">Параметр &lt;code&gt;$eof&lt;/code&gt; требует небольшого пояснения.</target>
        </trans-unit>
        <trans-unit id="65f92aaac6b66cd674844396e8d45e3f370fce50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter only needs to be used if &lt;b&gt;all&lt;/b&gt; of the following conditions apply</source>
          <target state="translated">Параметр &lt;code&gt;$eof&lt;/code&gt; необходимо использовать, только если выполняются &lt;b&gt;все&lt;/b&gt; следующие условия.</target>
        </trans-unit>
        <trans-unit id="8a410599f21ede34ce0c4e99388bf1aa3ff8199e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$gzerrno&lt;/code&gt; scalar holds the error code associated with the most recent</source>
          <target state="translated">&lt;code&gt;$gzerrno&lt;/code&gt; скаляр содержит код ошибки , связанный с самым последним</target>
        </trans-unit>
        <trans-unit id="6264c4349310ae2e82ed9dccab08bd7526a285d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$in_fh&lt;/code&gt; parameter may be any object that provides a &lt;b&gt;getline()&lt;/b&gt; method to retrieve a single line of input text (hence, an appropriate wrapper object could be used to parse PODs from a single string or an array of strings).</source>
          <target state="translated">Параметр &lt;code&gt;$in_fh&lt;/code&gt; может быть любым объектом, который предоставляет метод &lt;b&gt;getline ()&lt;/b&gt; для получения одной строки входного текста (следовательно, соответствующий объект-оболочка может использоваться для синтаксического анализа POD из одной строки или массива строк).</target>
        </trans-unit>
        <trans-unit id="e89b34e9c40c9e18afebc88c2be1c3150fecd52e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can be either scalars or scalar references.</source>
          <target state="translated">Параметры &lt;code&gt;$input&lt;/code&gt; и &lt;code&gt;$output&lt;/code&gt; могут быть либо скалярами, либо скалярными ссылками.</target>
        </trans-unit>
        <trans-unit id="d5ad245702c5052688f1d153e2fbd703e2f8f301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;$input_filename_or_reference&lt;/code&gt; параметр</target>
        </trans-unit>
        <trans-unit id="daa9f5f9a1ef279c49e625124d1e76146ad5e7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="translated">Параметр &lt;code&gt;$level&lt;/code&gt; определяет степень сжатия. Допустимые значения: от 0 до 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; и &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . Если &lt;code&gt;$level&lt;/code&gt; не указан, будет использоваться &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898131faa0f3e8f99a6d077f4bd62a3c78ce8ae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt;, &lt;code&gt;Z_BEST_SPEED&lt;/code&gt;, &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt;, and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt;. If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb33cd5cc665b9c3bd624d64f0ec40381e42cbac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt; . The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="translated">&lt;code&gt;$mon&lt;/code&gt; с нуля: январь равен &lt;code&gt;0&lt;/code&gt; . &lt;code&gt;$year&lt;/code&gt; составляет 1900 на основе: 2001 равен &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; и &lt;code&gt;$yday&lt;/code&gt; умолчанию равны нулю (и обычно игнорируются), а &lt;code&gt;$isdst&lt;/code&gt; умолчанию - -1.</target>
        </trans-unit>
        <trans-unit id="7421dc164fd8281f20128cde64ce3b745047d3c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt;. &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cd0f7ae4d6af5b92c0f4a1db509d798cb0ac59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$name&lt;/code&gt; variable should be the key used to access the facet in a facets hashref. For instance the assertion facet has the key 'assert', the information facet has the 'info' key, and the error facet has the key 'errors'. You may include or omit the 's' at the end of the name, the method is smart enough to try both the 's' and no-'s' forms, it will check what you provided first, and if that is not found it will add or strip the 's and try again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d866868676edf3ef0ef337619cbb9d7d463b060f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;$output_filename_or_reference&lt;/code&gt; параметр</target>
        </trans-unit>
        <trans-unit id="c96d672905fea90a5656f24eb9f7936742884276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;$parser&lt;/code&gt; является &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; объект.</target>
        </trans-unit>
        <trans-unit id="6143cd77ebc527cea165f0db3248c326b91b9c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cde3685cee91824cf2720ce6f47ce3c1655541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$tabstop&lt;/code&gt; variable controls how many column positions apart each tabstop is. The default is 8.</source>
          <target state="translated">В &lt;code&gt;$tabstop&lt;/code&gt; контроль переменных , сколько позиций столбцов друг от друга каждый табуляцией есть. По умолчанию - 8.</target>
        </trans-unit>
        <trans-unit id="07507ab596d7a55a579157466578b8c289c17f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">Параметр &lt;code&gt;$whence&lt;/code&gt; должен быть одним из SEEK_SET, SEEK_CUR или SEEK_END.</target>
        </trans-unit>
        <trans-unit id="78200cc1ea59e994c5d2418e77df8c6e8fa8185d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter takes one the usual values, namely SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">Параметр &lt;code&gt;$whence&lt;/code&gt; принимает одно из обычных значений, а именно SEEK_SET, SEEK_CUR или SEEK_END.</target>
        </trans-unit>
        <trans-unit id="d36c42de8f17d5532305a2dae875ef12d3135188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$|&lt;/code&gt; is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</source>
          <target state="translated">&lt;code&gt;$|&lt;/code&gt; является одной из специальных переменных для каждого дескриптора файла, поэтому каждый дескриптор имеет свою собственную копию своего значения. Если вы хотите, например, объединить стандартный вывод и стандартную ошибку, вам нужно отключить буферизацию каждого (хотя STDERR может быть небуферизован по умолчанию):</target>
        </trans-unit>
        <trans-unit id="697d0e02c23a6252ba73964b72ba7fef06e6718b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt; . This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; хэш обеспечивает ту же область видимости смысловой , как &lt;code&gt;$^H&lt;/code&gt; . Это делает его полезным для реализации прагм с лексической областью видимости. См. &lt;a href=&quot;perlpragma&quot;&gt;Perlpragma&lt;/a&gt; . При доступе во время выполнения все записи преобразуются в строку, поэтому можно использовать только простые значения. Это означает, например, отсутствие указателей на объекты.</target>
        </trans-unit>
        <trans-unit id="1c509249d339b2febfc4d2738ff085bd8d0cc7d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt;. This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6228356b1a9a18f543cd58f3d14ae5ed0885fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt; , and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; расширяется , чтобы быть имя файла ( &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; используется, так что будьте осторожны , чтобы избежать каких - либо других &lt;code&gt;%&lt;/code&gt; признаков). &amp;laquo;Команды&amp;raquo; проверяются на работоспособность - они должны содержать &lt;code&gt;%s&lt;/code&gt; , открытие для чтения должно заканчиваться знаком вертикальной черты, а открытие для записи должно начинаться со знака вертикальной черты.</target>
        </trans-unit>
        <trans-unit id="2719188c4cf371193166be19d0cfafdbeb67f360" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;sprintf&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt;, and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ebcc90a0416e4d456de5b17214b9e0b4a29e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt; , but provide a pointer to this value when the C function is called.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; унарный оператор в ВХОДЕ: секция используется , чтобы сказать &lt;b&gt;xsubpp&lt;/b&gt; , что он должен преобразовать значение Perl в / из C помощью типа C слева от &lt;code&gt;&amp;amp;&lt;/code&gt; , но предоставить указатель на это значение , когда функция C называются.</target>
        </trans-unit>
        <trans-unit id="f377db487fb9db0d6201d5c112d20cdac0c1ec99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt;, but provide a pointer to this value when the C function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b29d8efcd6e9fd3b54226af4554626aa17bc6d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can also be used on &lt;code&gt;()&lt;/code&gt; groups to force a particular byte-order on all components in that group, including all its subgroups.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; И &lt;code&gt;&amp;lt;&lt;/code&gt; модификаторы также может быть использованы на &lt;code&gt;()&lt;/code&gt; группах , чтобы заставить конкретный порядок байт на все компоненты в этой группе, включая всю ее подгруппу.</target>
        </trans-unit>
        <trans-unit id="46a36b2037ff10a0c2a8e03718578280ecd8883f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can only be used on floating-point formats on big- or little-endian machines. Otherwise, attempting to use them raises an exception.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; Или &lt;code&gt;&amp;lt;&lt;/code&gt; модификаторы могут быть использованы только на плавающей точкой форматов на big- или прямой порядок байтов машин. В противном случае при попытке их использования возникает исключение.</target>
        </trans-unit>
        <trans-unit id="99da10732816cfac1a93d49f7cb24d6856262342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator is most often seen in a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; Оператор чаще всего проявляется в &lt;code&gt;while&lt;/code&gt; петля:</target>
        </trans-unit>
        <trans-unit id="afce8c3936870dcddae71b2f62bcc6619bb65ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt; . People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="translated">Оператор &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; выполняет операцию подстановки (см. Выше). В версиях Perl ранее, чем v5.6.0, внутренний оператор glob () разветвляет csh (1), чтобы выполнить фактическое расширение glob, но csh не может обрабатывать более 127 элементов и поэтому выдает сообщение об ошибке &lt;code&gt;Argument list too long&lt;/code&gt; . Люди, установившие tcsh как csh, не столкнутся с этой проблемой, но их пользователи могут быть этим удивлены.</target>
        </trans-unit>
        <trans-unit id="83ef73a269b83405910162deabaede06a6badff3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt;. People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6640438652752fb93dc538db26332c2e258075d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from STDIN.</source>
          <target state="translated">Символ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; вернет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; для конца файла только один раз. Если вы &lt;code&gt;@ARGV&lt;/code&gt; его снова после этого, он будет считать, что вы обрабатываете другой список @ARGV , и, если вы не установили &lt;code&gt;@ARGV&lt;/code&gt; , будет читать ввод из STDIN.</target>
        </trans-unit>
        <trans-unit id="3dc916b5527d8e3b6254129215dab620bcd909c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;undef&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt;, will read input from STDIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb62b601a884f58c8064f8b862089ac2459b0228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt; ..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; and that</source>
          <target state="translated">&lt;code&gt;'I'&lt;/code&gt; префикс используются при создании &lt;code&gt;stdin&lt;/code&gt; .. &lt;code&gt;stderr&lt;/code&gt; с помощью специального &lt;code&gt;PerlIO_fdopen&lt;/code&gt; вызовов; в &lt;code&gt;'#'&lt;/code&gt; означает префикс , что это &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; и что</target>
        </trans-unit>
        <trans-unit id="e4a1e4127c99792fcfccb34fc1ce371d9c5cbbcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt;..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;sysopen&lt;/code&gt; and that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039ae207dd483bda31bf76d897310e5b8ac60fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; key for that missing method. If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="translated">&lt;code&gt;'nomethod'&lt;/code&gt; ключ используется для указания кетчупа всех функций , которая будет вызвана для любого оператора , который отдельно не перегруженные. Указанной функции будет передано четыре параметра. Первые три аргумента совпадают с теми, которые были бы переданы соответствующему методу, если бы он был определен. Четвертый аргумент является &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; ключа для этого отсутствующего метода. Если экспериментальная &amp;laquo;побитовая&amp;raquo; функция включена (см. &lt;a href=&quot;feature&quot;&gt;Функцию&lt;/a&gt; ), пятый аргумент ИСТИНА передается подпрограммам, обрабатывающим &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;~&lt;/code&gt; , чтобы указать, что вызывающий ожидает числовое поведение.</target>
        </trans-unit>
        <trans-unit id="7a25ce7c1bcfa6d33e234b18065c7c24fe6b0cdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;use overload&lt;/code&gt; key for that missing method. If the &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56ee7f30e7bca1dfc3e81783dadbc2bc19f727f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(a|b)*&lt;/code&gt; part can match at every char in the string, and then fail every time because there is no &lt;code&gt;z&lt;/code&gt; in the string. So obviously we can avoid using the regex engine unless there is a &lt;code&gt;z&lt;/code&gt; in the string. Likewise in a pattern like:</source>
          <target state="translated">Часть &lt;code&gt;(a|b)*&lt;/code&gt; может соответствовать каждому символу в строке, а затем терпит неудачу каждый раз, потому что в строке нет &lt;code&gt;z&lt;/code&gt; . Таким образом, очевидно, что мы можем избежать использования механизма регулярных выражений, если в строке нет &lt;code&gt;z&lt;/code&gt; . Аналогично в таком шаблоне:</target>
        </trans-unit>
        <trans-unit id="13f6771d5d5f30a227731a56b375d2b66657907c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt; . This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="translated">&lt;code&gt;*_BS&lt;/code&gt; файл может поместить код в генерируемый &lt;code&gt;*.bs&lt;/code&gt; файла, поместив его в &lt;code&gt;$bscode&lt;/code&gt; . Это удобный механизм &amp;laquo;побега&amp;raquo;, который может оказаться полезным в сложных ситуациях.</target>
        </trans-unit>
        <trans-unit id="b4a8908910386e1e7fa8ea911939f668d427bb11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt;. This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecae669ab5e752a1da7ac780070c852f9269859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*foo{THING}&lt;/code&gt; notation can also be used to obtain references to the individual elements of *foo. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*foo{THING}&lt;/code&gt; обозначение также может быть использовано для получения ссылки на отдельные элементы * Foo. См. &lt;a href=&quot;perlref&quot;&gt;Perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="255645a7c66228ebcb1a14a341007dcfb97aeb51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*x = \$y&lt;/code&gt; mechanism may be used to pass and return cheap references into or from subroutines if you don't want to copy the whole thing. It only works when assigning to dynamic variables, not lexicals.</source>
          <target state="translated">Механизм &lt;code&gt;*x = \$y&lt;/code&gt; может использоваться для передачи и возврата дешевых ссылок в подпрограммы или из них, если вы не хотите копировать все это целиком. Он работает только при назначении динамических переменных, а не лексических.</target>
        </trans-unit>
        <trans-unit id="fa1621299f61dcb4d1993cf9ac21afe7e26870e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; form is now obsolete and strongly deprecated.</source>
          <target state="translated">Форма &lt;code&gt;+&lt;/code&gt; теперь устарела и полностью устарела.</target>
        </trans-unit>
        <trans-unit id="6cc8f120eca26410795cc27186ae2b363ac834f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; prototype is a special alternative to &lt;code&gt;$&lt;/code&gt; that will act like &lt;code&gt;\[@%]&lt;/code&gt; when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; Прототип является специальной альтернативой &lt;code&gt;$&lt;/code&gt; , который будет действовать как &lt;code&gt;\[@%]&lt;/code&gt; , когда данный буквальный массив или хэш переменного, но в противном случае заставить скалярный контекст на аргументе. Это полезно для функций, которые должны принимать в качестве аргумента литеральный массив или ссылку на массив:</target>
        </trans-unit>
        <trans-unit id="bb2105637115aa748fce8bf2036dcef89f13282b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; specifier is ignored if the option destination is not a scalar.</source>
          <target state="translated">Спецификатор &lt;code&gt;+&lt;/code&gt; игнорируется, если пункт назначения параметра не является скаляром.</target>
        </trans-unit>
        <trans-unit id="6806c6a2e8d1792a36b6bbc8a8afc151b341b78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; unary operator doesn't do anything in Perl. It exists to avoid syntactic ambiguities.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; Унарный оператор не делает ничего в Perl. Он существует, чтобы избежать синтаксической двусмысленности.</target>
        </trans-unit>
        <trans-unit id="37675ebea1632ec83c2cb0e9f47bb19d76dac534" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is also used when dereferencing a reference. It looks like the same operator, but these are two different operations.</source>
          <target state="translated">&lt;code&gt;-&amp;gt;&lt;/code&gt; синтаксис также используется при разыменовании ссылки. Похоже на один и тот же оператор, но это две разные операции.</target>
        </trans-unit>
        <trans-unit id="d4b0e534108246bac541ccb7068bc25380ccc720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</source>
          <target state="translated">Метод &lt;code&gt;-&amp;gt;new()&lt;/code&gt; является псевдонимом для &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7955495872f4b4ea374a5a73bb5908daadd88feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8192632e359d95a2b8b1baa2f14ef188f64fb3bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--libpods&lt;/code&gt; option is no longer recognized as of Perl 5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127cc52ec86933168c2c1aece6f9b232d7cd7b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rules&lt;/code&gt; option is used to control which tests are run sequentially and which are run in parallel, if the &lt;code&gt;--jobs&lt;/code&gt; option is specified. The option may be specified multiple times, and the order matters.</source>
          <target state="translated">Параметр &lt;code&gt;--rules&lt;/code&gt; используется для управления тем, какие тесты запускаются последовательно, а какие параллельно, если &lt;code&gt;--jobs&lt;/code&gt; опция --jobs . Опция может быть указана несколько раз, и порядок имеет значение.</target>
        </trans-unit>
        <trans-unit id="608a757f76e2d49976d1abe026a19ab9cb45d134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch may be used more than once.</source>
          <target state="translated">Переключатель &lt;code&gt;--state&lt;/code&gt; можно использовать более одного раза.</target>
        </trans-unit>
        <trans-unit id="cc3c8ce0b0c852fbdda4091c52f36592afcdc410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch requires an argument which must be a comma separated list of one or more of the following options.</source>
          <target state="translated">Переключатель &lt;code&gt;--state&lt;/code&gt; требует аргумента, который должен быть списком, разделенным запятыми, из одного или нескольких следующих параметров.</target>
        </trans-unit>
        <trans-unit id="377dc2d9444ba53f1e07b9f9c8ed4eb80a1854c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trap&lt;/code&gt; option will attempt to trap SIGINT (Ctrl-C) during a test run and display the test summary even if the run is interrupted</source>
          <target state="translated">Параметр &lt;code&gt;--trap&lt;/code&gt; попытается перехватить SIGINT (Ctrl-C) во время тестового запуска и отобразить сводку теста, даже если запуск прерван.</target>
        </trans-unit>
        <trans-unit id="e392f25b1c4fe3943f476468712579d620408f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; command line switch</source>
          <target state="translated">Параметр командной строки &lt;code&gt;-A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb91ceec65f320f24de6ea1ba97059dfa04bc1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;-X&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--use-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597b9a9c8e6ccba33470cbc78977519edc52f8e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="translated">В &lt;code&gt;-A&lt;/code&gt; Исключает код автозагрузчика, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; Исключает XS элементы, &lt;code&gt;--skip-exporter&lt;/code&gt; Исключает код экспортеров, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; устанавливает современную среду тестирования, а &lt;code&gt;-n&lt;/code&gt; указывает имя модуля.</target>
        </trans-unit>
        <trans-unit id="c623c1943d0dabf76760d7670756f1a93a94f39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt; ). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="translated">&lt;code&gt;-Dusecbacktrace&lt;/code&gt; также позволяет держать информацию отладки при компиляции / связывания (часто: &lt;code&gt;-g&lt;/code&gt; ). Многие компиляторы / компоновщики поддерживают как оптимизацию, так и сохранение отладочной информации. Отладочная информация необходима для имен символов и местоположений источников.</target>
        </trans-unit>
        <trans-unit id="82d0f491a8ddd8c808b16ec9be7ca117f4caf1b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt;). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63378b07c96f9b709eea4a8451598ec112926512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;../perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">Переключатели &lt;code&gt;-T&lt;/code&gt; и &lt;code&gt;-B&lt;/code&gt; работают следующим образом. Примерно первый блок файла проверяется на предмет допустимости UTF-8, который включает символы, отличные от ASCII. Если, значит, это файл &lt;code&gt;-T&lt;/code&gt; . В противном случае та же самая часть файла проверяется на наличие нечетных символов, таких как странные управляющие коды или символы с установленным старшим битом. Если более трети символов странные, это файл &lt;code&gt;-B&lt;/code&gt; ; в противном случае это файл &lt;code&gt;-T&lt;/code&gt; . Кроме того, любой файл, содержащий нулевой байт в исследуемой части, считается двоичным файлом. (Если выполняется в рамках &lt;a href=&quot;../perllocale&quot;&gt;языкового стандарта использования,&lt;/a&gt; который включает &lt;code&gt;LC_CTYPE&lt;/code&gt; , нечетные символы - это все, что не является печатаемым или пробелом в текущем языковом стандарте.) Если &lt;code&gt;-T&lt;/code&gt; или &lt;code&gt;-B&lt;/code&gt; используются для дескриптора файла, проверяется текущий буфер ввода-вывода, а не первый блок. И &lt;code&gt;-T&lt;/code&gt; , и &lt;code&gt;-B&lt;/code&gt; возвращают истину для пустого файла или файла в EOF при тестировании дескриптора файла. Поскольку для выполнения теста &lt;code&gt;-T&lt;/code&gt; вам необходимо прочитать файл , в большинстве случаев вы хотите сначала использовать &lt;code&gt;-f&lt;/code&gt; для файла, как в &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c91ca83f347b61a13eb65089f07047ddb67d9622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">Переключатели &lt;code&gt;-T&lt;/code&gt; и &lt;code&gt;-B&lt;/code&gt; работают следующим образом. Примерно первый блок файла проверяется на предмет допустимости UTF-8, который включает символы, отличные от ASCII. Если, значит, это файл &lt;code&gt;-T&lt;/code&gt; . В противном случае та же самая часть файла проверяется на наличие нечетных символов, таких как странные управляющие коды или символы с установленным старшим битом. Если более трети символов странные, это файл &lt;code&gt;-B&lt;/code&gt; ; в противном случае это файл &lt;code&gt;-T&lt;/code&gt; . Кроме того, любой файл, содержащий нулевой байт в исследуемой части, считается двоичным файлом. (Если выполняется в рамках &lt;a href=&quot;perllocale&quot;&gt;языкового стандарта использования,&lt;/a&gt; который включает &lt;code&gt;LC_CTYPE&lt;/code&gt; , нечетные символы - это все, что не является печатаемым или пробелом в текущем языковом стандарте.) Если &lt;code&gt;-T&lt;/code&gt; или &lt;code&gt;-B&lt;/code&gt; используются для дескриптора файла, проверяется текущий буфер ввода-вывода, а не первый блок. И &lt;code&gt;-T&lt;/code&gt; , и &lt;code&gt;-B&lt;/code&gt; возвращают истину для пустого файла или файла в EOF при тестировании дескриптора файла. Поскольку для выполнения теста &lt;code&gt;-T&lt;/code&gt; вам необходимо прочитать файл , в большинстве случаев вы хотите сначала использовать &lt;code&gt;-f&lt;/code&gt; для файла, как в &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d03161bfdc601bdcaa9b51890ed40d35154d9a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; tests work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If so, it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt;, odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;next unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc0f3fa215c39800076a942f11672815853d1f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wall&lt;/code&gt; is by default on.</source>
          <target state="translated">&lt;code&gt;-Wall&lt;/code&gt; по умолчанию на.</target>
        </trans-unit>
        <trans-unit id="6dfbaa82d695de76db5a43cbdf063e4ffac5d9ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wtraditional&lt;/code&gt; is another example of the annoying tendency of gcc to bundle a lot of warnings under one switch (it would be impossible to deploy in practice because it would complain a lot) but it does contain some warnings that would be beneficial to have available on their own, such as the warning about string constants inside macros containing the macro arguments: this behaved differently pre-ANSI than it does in ANSI, and some C compilers are still in transition, AIX being an example.</source>
          <target state="translated">&lt;code&gt;-Wtraditional&lt;/code&gt; является еще одним примером раздражающих тенденции НКИ в расслоении многих предупреждений под одним переключателя (это было бы невозможно развернуть на практике , поскольку она будет жаловаться много) , но она содержит некоторые предупреждения , которые были бы полезно иметь в наличии сами по себе, например, предупреждение о строковых константах внутри макросов, содержащих аргументы макроса: это вело себя до ANSI иначе, чем в ANSI, и некоторые компиляторы C все еще находятся в процессе перехода, например AIX.</target>
        </trans-unit>
        <trans-unit id="29f275b0f904c074e809dc11f6813898aaca641a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-a&lt;/code&gt; option is used to include all files that git tracks that you have changed. If at this time, you only want to commit some of the files you have worked on, you can omit the &lt;code&gt;-a&lt;/code&gt; and use the command &lt;code&gt;git add &lt;i&gt;FILE ...&lt;/i&gt;&lt;/code&gt; before doing the commit. &lt;code&gt;git add --interactive&lt;/code&gt; allows you to even just commit portions of files instead of all the changes in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea68b3a7d6bdc421299da6629ccc22d6bd7b572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt; ) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="translated">&lt;code&gt;-ansi&lt;/code&gt; (и его кореш, &lt;code&gt;-pedantic&lt;/code&gt; ) было бы хорошо , чтобы быть всегда, но , к сожалению , они не являются безопасными на всех платформах, они могут, например , привести к смертельному конфликтов с системными заголовками (Solaris является ярким примером). Если используется Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; , интерфейс &lt;code&gt;cflags&lt;/code&gt; выбирает &lt;code&gt;-ansi -pedantic&lt;/code&gt; для платформ, где они считаются безопасными.</target>
        </trans-unit>
        <trans-unit id="3c0974d53dc0e4835c4ef757f3690c3874414b6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt;) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb94d9f2c59455332a30530ef3be81c2f437b975" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-h&lt;/code&gt; option will show a usage message.</source>
          <target state="translated">Параметр &lt;code&gt;-h&lt;/code&gt; покажет сообщение об использовании.</target>
        </trans-unit>
        <trans-unit id="2bf6b5a2450e550c35673777465af352e8fad7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is used to specify the commit message. If you omit it, git will open a text editor for you to compose the message interactively. This is useful when the changes are more complex than the sample given here, and, depending on the editor, to know that the first line of the commit message doesn't exceed the 50 character legal maximum. See &lt;a href=&quot;perlhack#Commit-message&quot;&gt;&quot;Commit message&quot; in perlhack&lt;/a&gt; for more information about what makes a good commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d034bd54a852b799ddb0bca00601006bc9ad62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-newlex&lt;/code&gt; option produces a more readable &lt;code&gt;name =&amp;gt; value&lt;/code&gt; format, and is shown in the second example above.</source>
          <target state="translated">Параметр &lt;code&gt;-newlex&lt;/code&gt; создает более читаемый формат &lt;code&gt;name =&amp;gt; value&lt;/code&gt; и показан во втором примере выше.</target>
        </trans-unit>
        <trans-unit id="3ed7e26de1fd10b827d09512227b49a4f8d06d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-nosp&lt;/code&gt; option eliminates reporting of SPECIALs, such as &lt;code&gt;0: SPECIAL
#1 &amp;amp;PL_sv_undef&lt;/code&gt; above. Reporting of SPECIALs can sometimes overwhelm your declared lexicals.</source>
          <target state="translated">Опция &lt;code&gt;-nosp&lt;/code&gt; исключает создание отчетов о СПЕЦИАЛЬНЫХ сообщениях, таких как &lt;code&gt;0: SPECIAL #1 &amp;amp;PL_sv_undef&lt;/code&gt; выше. Сообщение о СПЕЦИАЛЬНОСТЯХ может иногда подавлять заявленную вами лексику.</target>
        </trans-unit>
        <trans-unit id="063586d44811e787a3acc7fa9925ec22a0e1ef32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-pretty&lt;/code&gt; directive is called too late to affect matters. You have to do this instead, and</source>
          <target state="translated">&lt;code&gt;-pretty&lt;/code&gt; директива называется слишком поздно , чтобы повлиять на ситуацию. Вы должны сделать это вместо этого, и</target>
        </trans-unit>
        <trans-unit id="64b5e1fcc02dcf849bd221c8c257f81fb47b92a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</source>
          <target state="translated">Параметры &lt;code&gt;-q&lt;/code&gt; и &lt;code&gt;-qq&lt;/code&gt; работают некорректно, если perl не скомпилирован с поддержкой PerlIO: STDOUT будет закрыт, а не перенаправлен на &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29496d6f7bd6b984673c9ef63d5a96a39bc5fbb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6261ab8564541d33e35c7ac1e97aa8a5e571dd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qq&lt;/code&gt; option behaves like &lt;code&gt;-q&lt;/code&gt;, except that it also closes STDERR after deparsing has finished. This suppresses the &quot;Syntax OK&quot; message normally produced by perl.</source>
          <target state="translated">Параметр &lt;code&gt;-qq&lt;/code&gt; ведет себя так же, как &lt;code&gt;-q&lt;/code&gt; , за исключением того, что он также закрывает STDERR после завершения депарсинга. Это подавляет сообщение &amp;laquo;Синтаксис ОК&amp;raquo;, обычно создаваемое perl.</target>
        </trans-unit>
        <trans-unit id="cb173d8eff47f06c7e37f7374c7227453a2ad4d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-u&lt;/code&gt; switch causes the VMS debugger to be invoked after the Perl program is compiled, but before it has run. It does not create a core dump file.</source>
          <target state="translated">Параметр &lt;code&gt;-u&lt;/code&gt; вызывает вызов отладчика VMS после компиляции программы Perl, но до ее запуска. Он не создает файл дампа ядра.</target>
        </trans-unit>
        <trans-unit id="1e542d84460c8b59074b5a3d74792d84cf2329fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt; flip-flop operators. Note that the &lt;code&gt;...&lt;/code&gt; flip-flop operator is completely different from the &lt;code&gt;...&lt;/code&gt; elliptical statement just described.</source>
          <target state="translated">Операторы &lt;code&gt;..&lt;/code&gt; и &lt;code&gt;...&lt;/code&gt; flip-flop. Обратите внимание, что оператор &lt;code&gt;...&lt;/code&gt; flip-flop полностью отличается от только что описанного эллиптического оператора &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8189082aec1c35ce34b10a2a482272d1f9442cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; range operator treats certain character ranges with care on EBCDIC platforms. For example the following array will have twenty six elements on either an EBCDIC platform or an ASCII platform:</source>
          <target state="translated">Оператор &lt;code&gt;..&lt;/code&gt; range осторожно обрабатывает определенные диапазоны символов на платформах EBCDIC. Например, следующий массив будет содержать двадцать шесть элементов либо на платформе EBCDIC, либо на платформе ASCII:</target>
        </trans-unit>
        <trans-unit id="1bfc1b4066699d36e1a1c96b8bf42e5d376ee7e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; matching operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. It operates on &lt;code&gt;$_&lt;/code&gt; by default, or can be bound to another variable using the &lt;code&gt;=~&lt;/code&gt; binding operator (also documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;).</source>
          <target state="translated">Оператор сопоставления &lt;code&gt;//&lt;/code&gt; задокументирован в &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; . По умолчанию он работает с &lt;code&gt;$_&lt;/code&gt; или может быть привязан к другой переменной с помощью оператора привязки &lt;code&gt;=~&lt;/code&gt; (также задокументирован в &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32ef826cb43c384876c66cdfd8ef3d6094273ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of \d, \s, and \w to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;//aa&lt;/code&gt; , to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="translated">&lt;code&gt;//a&lt;/code&gt; модификатор, доступные отправной в Perl 5.14, используются для ограничения матчей \ д, \ S, и \ ш только те , в диапазоне ASCII. Полезно предохранить вашу программу от ненужного воздействия на нее полного Unicode (и связанных с ним соображений безопасности), когда все, что вам нужно, - это обрабатывать английский текст. (&quot;A&quot; может быть удвоено, &lt;code&gt;//aa&lt;/code&gt; , чтобы обеспечить еще больше ограничений, предотвращая нечувствительное к регистру сопоставление ASCII с символами, отличными от ASCII; в противном случае Unicode &quot;Знак Кельвина&quot; без учета регистра соответствовал бы &quot;k&quot; или &quot;K&quot; .)</target>
        </trans-unit>
        <trans-unit id="4d28a339cbae1f464fa994976dfeef2db93a1d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; template character allows packing and unpacking of a sequence of items where the packed structure contains a packed item count followed by the packed items themselves. This is useful when the structure you're unpacking has encoded the sizes or repeat counts for some of its fields within the structure itself as separate fields.</source>
          <target state="translated">Символ &lt;code&gt;/&lt;/code&gt; template позволяет упаковывать и распаковывать последовательность элементов, в которой упакованная структура содержит количество упакованных элементов, за которым следуют сами упакованные элементы. Это полезно, когда структура, которую вы распаковываете, закодировала размеры или количество повторов для некоторых своих полей внутри самой структуры как отдельные поля.</target>
        </trans-unit>
        <trans-unit id="11f550725d5f2471c6ff447b2d5f1594f1eb63d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;/aa&lt;/code&gt;, to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8377a1a6991c29f230dc12ce290846f6b362ebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, on the other hand, may be useful. Its purpose is to allow code that is to work mostly on ASCII data to not have to concern itself with Unicode.</source>
          <target state="translated">С другой стороны, может быть полезен модификатор &lt;code&gt;/a&lt;/code&gt; . Его цель - позволить коду, который должен работать в основном с данными ASCII, не беспокоиться о Unicode.</target>
        </trans-unit>
        <trans-unit id="4128278fcab003f758fd62a9e37cfc1e76abe115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/l&lt;/code&gt;, and &lt;code&gt;/u&lt;/code&gt; modifiers (added in Perl 5.14) control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d46362c6dee371fc1e41d5a94fbe9c509a82363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="translated">&lt;code&gt;/d&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; , и &lt;code&gt;/l&lt;/code&gt; модификаторы, вероятно, не будет много пользы для вас, и поэтому вам не нужно беспокоиться о них очень много. Они существуют для внутреннего использования Perl, так что сложные структуры данных регулярных выражений могут быть автоматически сериализованы, а затем точно воссозданы, включая все их нюансы. Но поскольку Perl не умеет хранить секреты и могут быть редкие случаи, когда они могут быть полезны, они задокументированы здесь.</target>
        </trans-unit>
        <trans-unit id="12ab225e2a1f0826b5de7058218cdd1f025dae16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt;, and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a635bd3deb5f6d1f8ced7e30d0ca4af436ee119" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt; , perhaps something like &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , then I could get myself in trouble.</source>
          <target state="translated">&lt;code&gt;/e&lt;/code&gt; также будет молча игнорировать нарушение строго, заменяя имена неопределенных переменных с пустой строкой. Поскольку я использую флаг &lt;code&gt;/e&lt;/code&gt; (даже дважды!), У меня те же проблемы с безопасностью, что и с &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; в строковой форме. Если в &lt;code&gt;$foo&lt;/code&gt; есть что-то странное , например, что-то вроде &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , то я могу попасть в беду.</target>
        </trans-unit>
        <trans-unit id="b81362cf7da8bf9fa9ba69433decc106d6e660e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;eval&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt;, perhaps something like &lt;code&gt;@{[ system &quot;rm -rf /&quot; ]}&lt;/code&gt;, then I could get myself in trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613bcc3a2284ecc4926054a5b934f30e880d5007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; модификатор определяет соответствующий глобальный шаблон - то есть соответствие столько раз , сколько возможно в пределах строки. Как он себя ведет, зависит от контекста. В контексте списка он возвращает список подстрок, соответствующих любым захватывающим скобкам в регулярном выражении. Если круглых скобок нет, он возвращает список всех совпадающих строк, как если бы круглые скобки были вокруг всего шаблона.</target>
        </trans-unit>
        <trans-unit id="987314591903795033c1fec25347d7b594aec577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas give consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="translated">&lt;code&gt;/l&lt;/code&gt; и &lt;code&gt;/u&lt;/code&gt; модификаторы будут автоматически выбраны для регулярных выражений , составленных в рамках различных прагм, и мы рекомендуем в целом, вы используете эти прагмы вместо указания этих модификаторов в явном виде. Во-первых, модификаторы влияют только на сопоставление с образцом и не распространяются даже на любую выполненную замену, тогда как использование прагм дает согласованные результаты для всех соответствующих операций в пределах их области действия. Например,</target>
        </trans-unit>
        <trans-unit id="2a3e23c2d6681fc3d86e431f129513cbcb6ae252" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas gives consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a222e38b5a40a1bf140094ce44f5b0c1b82a0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/o&lt;/code&gt; option for regular expressions (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;) tells Perl to compile the regular expression only once. This is only useful when the pattern contains a variable. Perls 5.6 and later handle this automatically if the pattern does not change.</source>
          <target state="translated">Параметр &lt;code&gt;/o&lt;/code&gt; для регулярных выражений (задокументированный в &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; и &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt; ) указывает Perl компилировать регулярное выражение только один раз. Это полезно, только когда шаблон содержит переменную. Perls 5.6 и более поздние версии обрабатывают это автоматически, если шаблон не меняется.</target>
        </trans-unit>
        <trans-unit id="02f1967b4475720a962bf35cfc3049c63165e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/x&lt;/code&gt; modifier causes whitespace to be ignored in a regex pattern (except in a character class and a few other places), and also allows you to use normal comments there, too. As you can imagine, whitespace and comments help a lot.</source>
          <target state="translated">В &lt;code&gt;/x&lt;/code&gt; модифицирующие причины пробельные быть проигнорированы в регулярных выражений шаблона ( за исключением класса символов и несколько других мест), а также позволяет использовать обычные комментарии там тоже. Как вы понимаете, очень помогают пробелы и комментарии.</target>
        </trans-unit>
        <trans-unit id="26a965e97d532904de76cbb5ec7fa62c78040c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0x&lt;/code&gt; prefix means a hexadecimal number, the digits are 0-9</source>
          <target state="translated">&lt;code&gt;0x&lt;/code&gt; префикса означает шестнадцатеричное число, цифры 0-9</target>
        </trans-unit>
        <trans-unit id="c084ffd08879b68d48b86f14b0edd6d007fd471f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt; . It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="translated">&lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; тег, теперь не рекомендуется, это старая версия &lt;code&gt;:bsd_glob&lt;/code&gt; . Он экспортирует те же константы и функции, но его переопределение glob () не поддерживает итерацию; он возвращает последнее имя файла в скалярном контексте. Это означает, что цикл будет длиться вечно:</target>
        </trans-unit>
        <trans-unit id="4231c54d461bf5e25a3f991c3ecf987daad7c115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ALL&lt;/code&gt; tag will get all of the above exports.</source>
          <target state="translated">&lt;code&gt;:ALL&lt;/code&gt; теги получат все выше экспорт.</target>
        </trans-unit>
        <trans-unit id="f4ffb1e41b5af144e1e66d6009daba34fcfe78d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bsd_glob&lt;/code&gt; export tag exports bsd_glob() and the constants listed below. It also overrides glob() in the calling package with one that behaves like bsd_glob() with regard to spaces (the space is treated as part of a file name), but supports iteration in scalar context; i.e., it preserves the core function's feature of returning the next item each time it is called.</source>
          <target state="translated">&lt;code&gt;:bsd_glob&lt;/code&gt; экспорта теги экспорт bsd_glob () и константы , перечисленные ниже. Он также заменяет glob () в вызывающем пакете пакетом, который ведет себя как bsd_glob () в отношении пробелов (пробел рассматривается как часть имени файла), но поддерживает итерацию в скалярном контексте; т. е. он сохраняет свойство основной функции возвращать следующий элемент при каждом его вызове.</target>
        </trans-unit>
        <trans-unit id="e5933b7ecdff0d26d0d1ee137373273e087ab3ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , and any other directives of the form &lt;code&gt;:...&lt;/code&gt; , are called I/O</source>
          <target state="translated">В &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , а также любые другие директивы вида &lt;code&gt;:...&lt;/code&gt; , называется I / O</target>
        </trans-unit>
        <trans-unit id="586c160f0002e3dc300faf81c49d6dc770a315b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; layer corresponds to &quot;binary mode&quot; and the &lt;code&gt;:crlf&lt;/code&gt; layer corresponds to &quot;text mode&quot; on platforms that distinguish between the two modes when opening files (which is many DOS-like platforms, including Windows). These two layers are no-ops on platforms where binmode() is a no-op, but perform their functions everywhere if PerlIO is enabled.</source>
          <target state="translated">&lt;code&gt;:bytes&lt;/code&gt; соответствует слою в &amp;laquo;двоичном режим&amp;raquo; и &lt;code&gt;:crlf&lt;/code&gt; соответствует слою &amp;laquo;текстовому режим&amp;raquo; на платформах, отличающих между двумя режимами при открытии файлов (что многие DOS-подобные платформы, включая Windows). Эти два уровня не работают на платформах, где binmode () не работает, но выполняют свои функции везде, если включен PerlIO.</target>
        </trans-unit>
        <trans-unit id="11a84ca57962b97df10238d25c4ab7c8ca38ba9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt;, &lt;code&gt;:crlf&lt;/code&gt;, &lt;code&gt;:utf8&lt;/code&gt;, and any other directives of the form &lt;code&gt;:...&lt;/code&gt;, are called I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6da40dddc20e97c2aa930b3dff507bcb27589f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaration.</source>
          <target state="translated">Пакет &lt;code&gt;:default&lt;/code&gt; представляет набор функций, который активируется перед любой &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; объявления функции .</target>
        </trans-unit>
        <trans-unit id="09364c3e01a418de2009247f52456634c275c2f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;use feature&lt;/code&gt; or &lt;code&gt;no feature&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229b3ff64bd12a209b4e991d14388add7cc976a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:glob&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt;. It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a790449d8cd7160d313e0f6fd7d2b5f5cd711410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one boolean argument.</source>
          <target state="translated">Для &lt;code&gt;:gzip_external&lt;/code&gt; требуется один логический аргумент.</target>
        </trans-unit>
        <trans-unit id="bc95aee8e2b941e818640ac51c8f3c3052958780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one string argument.</source>
          <target state="translated">Для &lt;code&gt;:gzip_external&lt;/code&gt; требуется один строковый аргумент.</target>
        </trans-unit>
        <trans-unit id="d6ef1d12b23a99b06dce59bf86591d40b628073e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f5f557ffbe0666f0dfcd916d2b61a638ef52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_read_open&lt;/code&gt; аргумент должен заканчиваться знаком трубы (|) и имеет &lt;code&gt;%s&lt;/code&gt; для имени файла. См. &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;ИСПОЛЬЗОВАНИЕ ВНЕШНЕГО GZIP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c09f18a82aa110a317c88049c0e7c4128399d22c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740fe127c4ced02d559ebb2a859c745ac796eb7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:gzip_write_open&lt;/code&gt; Аргумент должен начинаться со знаком трубы (|) и имеет &lt;code&gt;%s&lt;/code&gt; для имени файла. Перенаправление вывода (&amp;gt;) также часто является хорошей идеей, в зависимости от синтаксиса оболочки вашей операционной системы. См. &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;ИСПОЛЬЗОВАНИЕ ВНЕШНЕГО GZIP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="244205effe1c86456dd4171100ec82efbb0324f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, only with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; не сможет работать с &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; , только с &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; прагмой. &lt;code&gt;:utf8&lt;/code&gt; и &lt;code&gt;:encoding(...)&lt;/code&gt; методы работают со всеми &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; прагме.</target>
        </trans-unit>
        <trans-unit id="868d235ace169d2c7fa342c5a97f5b35d506dd95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;binmode()&lt;/code&gt;, only with the &lt;code&gt;open&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;binmode()&lt;/code&gt;, and the &lt;code&gt;open&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a7c262fbc0be9a9844fe48c62a845c0f4528fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; sub-pragma</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; суб-прагма</target>
        </trans-unit>
        <trans-unit id="90148b6fce0bbabdeb9d2a0e71e782bdff20ba4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:mmap&lt;/code&gt; слой не будет существовать , если платформа не поддерживает &lt;code&gt;mmap()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81e4222eb657623bdd73dc5a2ea005b2d704479c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt;. See &lt;a href=&quot;PerlIO::mmap&quot;&gt;PerlIO::mmap&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd944a87b4f64134b2d5190fde7ca74a27bd05a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; layer is</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; слой</target>
        </trans-unit>
        <trans-unit id="9474a45f1b69ac0f4649940b34d53df78423a114" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; pseudo-layer is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8af45fe08808536fe0e78893d59ec120f251eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:std&lt;/code&gt; subpragma on its own has no effect, but if combined with the &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding&lt;/code&gt; subpragmas, it converts the standard filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected for input/output handles. For example, if both input and out are chosen to be &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR are also in &lt;code&gt;:encoding(utf8)&lt;/code&gt; . On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt; . The &lt;code&gt;:locale&lt;/code&gt; subpragma implicitly turns on &lt;code&gt;:std&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;:std&lt;/code&gt; subpragma сама по себе не имеет никакого эффекта, но если в сочетании с &lt;code&gt;:utf8&lt;/code&gt; или &lt;code&gt;:encoding&lt;/code&gt; subpragmas, он преобразует стандартные дескрипторы файлов (STDIN, STDOUT, STDERR) соблюдать кодирования , выбранной для ввода / вывода ручками. Например, если для ввода и вывода выбраны &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; будет означать, что STDIN, STDOUT и STDERR также находятся в &lt;code&gt;:encoding(utf8)&lt;/code&gt; . С другой стороны, если выбран только вывод в &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; приведет к тому, что только STDOUT и STDERR будут в &lt;code&gt;koi8r&lt;/code&gt; . &lt;code&gt;:locale&lt;/code&gt; subpragma неявно включает &lt;code&gt;:std&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2743b792818bf7f895d0f0b22baae763060aa81f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt; . To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . To disable autodie for only a single function (eg, open) use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</source>
          <target state="translated">Параметр &lt;code&gt;:void&lt;/code&gt; поддерживается в &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt; , но не &lt;code&gt;autodie&lt;/code&gt; . Чтобы обойти это, &lt;code&gt;autodie&lt;/code&gt; может быть явно отключен до конца текущего блока &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . Чтобы отключить autodie для только одной функции (например, открытой) не использовать &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0969ef951925275c4d8bd4c9c51662e300f9c641" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt;. To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;no autodie&lt;/code&gt;. To disable autodie for only a single function (eg, open) use &lt;code&gt;no autodie qw(open)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67318be992f4377bb68fbe49ed99f910c657a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt; for more details on &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; используется для создания экземпляра фильтра. Он косвенно вызывается Perl, когда встречает в &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; строку &lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter (см. &lt;a href=&quot;../../functions/import&quot;&gt;Импорт&lt;/a&gt; для более подробной информации об &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="69849addd7818fee9c7e8c167a05d6c0d2986859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; will</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; будет</target>
        </trans-unit>
        <trans-unit id="0eafa6355d483056647b2819a7f67215461c3497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt; . You may call</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; вызов возвращает объект, говорят &lt;code&gt;$o&lt;/code&gt; . Вы можете позвонить</target>
        </trans-unit>
        <trans-unit id="51ffe3fc21c6601c2932126d4f4eca5123604eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">Конструкция &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; также может использоваться для локализации удаления элементов массива / хэша в текущем блоке. См. Раздел &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Локализованное удаление элементов составных типов в perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1621ad946434d6c08e6becea5950298e8d654de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">Конструкция &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; локализует удаление в текущем блоке во время выполнения. Пока блок не завершится, локально удаленные элементы временно не существуют. См. Раздел &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Локализованное удаление элементов составных типов в perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="413b32076323a1b9dc32ef8307740eba59479274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; выполняет системную команду</target>
        </trans-unit>
        <trans-unit id="2195a8cff19304cef2dc99fbcce68cf6dbdaf4fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; реализована не во всех версиях Windows. Проверьте документацию для вашей конкретной версии Perl.</target>
        </trans-unit>
        <trans-unit id="1cc7a7cd989d44101ffb59063ba0d9ec90f901e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; будет пытаться гарантировать, что никакое преобразование управления кареткой не происходит при вводе или выводе в этот дескриптор файла. Поскольку это включает в себя повторное открытие файла и последующее восстановление его индикатора положения файла, если эта функция возвращает FALSE, базовый дескриптор файла может больше не указывать на открытый файл или может указывать на другую позицию в файле, чем до &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b9155394683e2730126a87d41bdd8b7ec8ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; functions work on whole characters.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; работают с целыми символами.</target>
        </trans-unit>
        <trans-unit id="b8d018fd592275cef4c6f8f9148b669393d46ef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; использует системную службу &lt;code&gt;sys$hash_password&lt;/code&gt; для генерации хешированного представления PLAINTEXT. Если USER - действительное имя пользователя, значения алгоритма и соли берутся из записи UAF этого пользователя. Если это не так, то используется предпочтительный алгоритм и соль 0. Зашифрованное значение четверного слова возвращается в виде строки из 8 символов.</target>
        </trans-unit>
        <trans-unit id="51567ba352ff0d9256d32ae3d4a4cc5e55c3b1bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">Конструкция &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; также может использоваться для локализации удаления элементов массива / хэша в текущем блоке. См. Раздел &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Локализованное удаление элементов составных типов в perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="205f4f4c053e1354b5fd41e9a973041210cd6cb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">Конструкция &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; локализует удаление в текущем блоке во время выполнения. Пока блок не завершится, локально удаленные элементы временно не существуют. См. Раздел &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Локализованное удаление элементов составных типов в perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c330ed0d1614413aef6482d1172074b901ca8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="translated">Конструкция &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; не является настоящим циклом, для которого можно использовать управление циклом.</target>
        </trans-unit>
        <trans-unit id="bf5bbfe9093c8abccc03e7c7efe8dbe3d8e0233d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">Однако оператор &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; может быть немного сложнее. Вы не можете добавлять или удалять ключи хэша, пока вы его используете, без возможности пропуска или повторной обработки некоторых пар после того, как Perl внутренне перефразирует все элементы. Кроме того, у хэша есть только один итератор, поэтому, если вы смешиваете &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; из них в одном и том же хэше, вы рискуете сбросить итератор и испортить вашу обработку. Смотрите &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; запись в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="6a7ce17abb69e82a8250b438247bf503d68963f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; возвращает пары в явно случайном порядке, поэтому, если порядок важен для вас, вам придется придерживаться метода &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d704aced95cc8764eb35404aac65f2304fbf2d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; method wrapped an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; around a &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">Метод &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; обернул &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; вокруг &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; и поэтому ждал завершения потока, передавая любые значения, которые поток мог вернуть, и помещая любые ошибки в &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80c53083069f05797eef5848d626cca139bde071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature enables the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; keyword, which evaluates the argument passed to it as a string of bytes. It dies if the string contains any characters outside the 8-bit range. Source filters work within &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;: they apply to the contents of the string being evaluated.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; включает ключевое слово &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; , которое оценивает переданный ему аргумент как строку байтов. Он умирает, если строка содержит какие-либо символы вне 8-битного диапазона. Исходные фильтры работают в &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; : они применяются к содержимому оцениваемой строки.</target>
        </trans-unit>
        <trans-unit id="013c20c8a39c1e9d213753c8f42aa60136c4133a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; выполняет системную команду</target>
        </trans-unit>
        <trans-unit id="cc6b445e37f9fe0173dc131ac1ed2864194322f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;. :)</source>
          <target state="translated">Задача функции &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; - превратить ваш процесс в другую команду и никогда не возвращаться. Если это не то, что вы хотите сделать, не используйте &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; . :)</target>
        </trans-unit>
        <trans-unit id="c64c8f5547bb2a6573770267608423f5c2aa4dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; модификатора итератор: он выполняет оператор для каждого элемента в списке (с &lt;code&gt;$_&lt;/code&gt; псевдонима для каждого пункта , в своей очереди).</target>
        </trans-unit>
        <trans-unit id="fcbb7f06dac39b4543299760a90086a0717180ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; , даже если она принимает только один аргумент, имеет приоритет оператора списка, поэтому будьте осторожны:</target>
        </trans-unit>
        <trans-unit id="d7025a8a8790fde9485d755f6c425f01c04b8467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; будет работать правильно, если у вас есть работающая процедура CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; или если логическое имя SYS $ TIMEZONE_DIFFERENTIAL определено как количество секунд, которое необходимо добавить к UTC для получения местного времени. (Это логическое имя определяется автоматически, если вы используете версию VMS со встроенной поддержкой UTC.) Если ни один из этих случаев не соответствует действительности, выводится предупреждающее сообщение и возвращается &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3ff2f4c2a7967681e4811d9bc792e927dbfcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; сильно отличается от других форм &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . Фактически, это вообще не goto в обычном смысле слова, и у него нет стигмы, связанной с другими goto. Вместо этого он выходит из текущей подпрограммы (теряя любые изменения, установленные local ()), и немедленно вызывает вместо нее именованную подпрограмму, используя текущее значение @_. Это используется &lt;code&gt;AUTOLOAD&lt;/code&gt; подпрограммы , которые желают загрузить другую подпрограмму , а затем делать вид , что другая подпрограмма была вызвана , в первую очередь ( за исключением того, что любые модификации &lt;code&gt;@_&lt;/code&gt; в текущей подпрограмме распространяется на другую подпрограмму) . После &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , даже не &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; сможет сказать, что эта процедура была вызвана первой.</target>
        </trans-unit>
        <trans-unit id="8c6cdb8b9140a3413b924a1be37defd8094c23ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; ожидает, что &lt;code&gt;EXPR&lt;/code&gt; будет оценивать ссылку на код или имя метки. Если он оценивается как ссылка на код, он будет обрабатываться как &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , как показано ниже. Это особенно полезно для реализации хвостовой рекурсии через &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9a08aec53b4872b20c38601dfe1ff47bb7271a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; находит оператор с меткой LABEL и возобновляет выполнение там. Его нельзя использовать для выхода из блока или подпрограммы, заданной для &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Его можно использовать практически в любом другом месте в пределах динамической области видимости, в том числе вне подпрограмм, но обычно лучше использовать какую-либо другую конструкцию, например &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Автор Perl никогда не чувствовал необходимости использовать эту форму &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (то есть в Perl; C - другое дело). (Разница в том, что C не предлагает именованные циклы в сочетании с управлением циклами. Perl делает это, и это заменяет большинство структурированных применений &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; в других языках.)</target>
        </trans-unit>
        <trans-unit id="fd5e7141b6809acf60b4ffb9ca0527589ab4d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - &amp;amp; NAME очень волшебна и заменяет вызов указанной подпрограммы на текущую подпрограмму. Это используется подпрограммами &lt;code&gt;AUTOLOAD()&lt;/code&gt; которые хотят загрузить другую подпрограмму, а затем делают вид, что другая подпрограмма была вызвана в первую очередь (за исключением того, что любые изменения &lt;code&gt;@_&lt;/code&gt; в текущей подпрограмме распространяются на другую подпрограмму). &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , даже &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; не сможет определить, что эта процедура была вызвана первой.</target>
        </trans-unit>
        <trans-unit id="0f2fbb144491503128d3d631573fe99dbb58cb74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR ожидает имя метки, область действия которой будет разрешена динамически. Это позволяет вычислять &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; для FORTRAN, но не обязательно рекомендуется, если вы оптимизируете для удобства сопровождения:</target>
        </trans-unit>
        <trans-unit id="747fd1051ce1561b7aad0a462ec80a7083e807f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -LABEL находит оператор, помеченный LABEL, и возобновляет выполнение там. Его нельзя использовать для перехода к какой-либо конструкции, требующей инициализации, такой как подпрограмма или цикл &lt;code&gt;foreach&lt;/code&gt; . Его также нельзя использовать для создания оптимизированной конструкции. Его можно использовать практически в любом другом месте в пределах динамической области видимости, в том числе вне подпрограмм, но обычно лучше использовать какую-либо другую конструкцию, например &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Автор Perl никогда не чувствовал необходимости использовать эту форму &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (в Perl, то есть C - другое дело).</target>
        </trans-unit>
        <trans-unit id="b3e30e59d91f75eda248244fb51004176883c63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="translated">Команда &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; в скалярном контексте возвращает счетчик. Если вам нужен список совпадающих элементов, просто используйте его в контексте списка:</target>
        </trans-unit>
        <trans-unit id="612dabc89cee10beadc6c980b04dfdba8cc2e280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; также сбрасывает итератор, что означает, что вы можете увидеть странные результаты, если используете ее между использованиями других хэш-операторов, таких как &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84a92b66f23e84ffcea0f8036601109332768c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; функция может быть использована для проверки этой функциональности из программы.</target>
        </trans-unit>
        <trans-unit id="8f9dd8be24cd7b207201afca586d0393221c8761" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; в родительском блоке &lt;code&gt;if&lt;/code&gt; предназначена для отправки сигнала нашему дочернему процессу, который в настоящее время выполняется в блоке &lt;code&gt;else&lt;/code&gt; , как только удаленный сервер закрывает свой конец соединения.</target>
        </trans-unit>
        <trans-unit id="8bfb3b07d45ff01232bb221af626a6a5fb4ea5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; команда немедленно выходит из цикла в вопросе. Блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , если он есть, не выполняется:</target>
        </trans-unit>
        <trans-unit id="ac302bdab0f919a07174f63d0969bebc85f1b892" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; команда , как &lt;code&gt;break&lt;/code&gt; оператор в C (при использовании в циклах); он немедленно выходит из рассматриваемого цикла. Если LABEL опущен, команда относится к самому внутреннему охватывающему циклу. &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; форма доступна , начиная с Perl 5.18.0, позволяет имя метки быть вычислен во время выполнения, а в остальном идентичны &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . Блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , если он есть, не выполняется:</target>
        </trans-unit>
        <trans-unit id="506963259280dc353e83831a1d7243717b046918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Ключевое слово</target>
        </trans-unit>
        <trans-unit id="249bfee98e5c2e5ddbdeda77c1a70bb97c684fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function. Using &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; берет общую переменную и блокирует ее. Никакой другой поток не может заблокировать переменную, пока переменная не будет разблокирована потоком, удерживающим блокировку. Разблокирование происходит автоматически, когда блокирующий поток выходит из блока, содержащего вызов функции &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; . Использовать &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; просто: в этом примере несколько потоков выполняют некоторые вычисления параллельно и иногда обновляют промежуточную сумму:</target>
        </trans-unit>
        <trans-unit id="844dd628839d69aa91981cfdf9d35b8aa941b210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="translated">На самом деле &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; не требуется; вы можете просто использовать:</target>
        </trans-unit>
        <trans-unit id="15c7027f68a72fedc245e7d612cf00a82d9df24d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; просто модификатор на то , что вы могли бы присвоенным. Поэтому, когда вы назначаете переменные в его списке аргументов, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; не меняет, рассматриваются ли эти переменные как скаляр или как массив. Так</target>
        </trans-unit>
        <trans-unit id="82cb7d6fd4d7d98853ace6ba4000362cdc7fa762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if/unless/elsif/else&lt;/code&gt;), loop (&lt;code&gt;for/foreach/while/until/continue&lt;/code&gt;), subroutine, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; объявляет, что перечисленные переменные лексически ограничены охватывающим блоком, условным ( &lt;code&gt;if/unless/elsif/else&lt;/code&gt; ), циклом ( &lt;code&gt;for/foreach/while/until/continue&lt;/code&gt; ), подпрограммой, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt; d файл. Если указано более одного значения, список должен быть заключен в круглые скобки. Все перечисленные элементы должны иметь допустимые lvalue. Только буквенно - цифровые идентификаторы могут лексическую область видимости - магические встроенные модули , такие как &lt;code&gt;$/&lt;/code&gt; должны быть в настоящее время &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; роскопии с &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="598c24981891ed39a33542154be0ea54335c8268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; команда как и по- &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; заявление в C; он запускает следующую итерацию цикла:</target>
        </trans-unit>
        <trans-unit id="4ac987f577bf457aa0aa7edd6027d43957e00541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; команда приступает к выполнению следующей итерации цикла:</target>
        </trans-unit>
        <trans-unit id="90d027781b9d30c834bc3f75976b8010ac44b08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords work differently.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; , и &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ключевые слова работают по- разному.</target>
        </trans-unit>
        <trans-unit id="5eeb76addad99da0bbdd65d75ec9e60f2b34827f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma doesn't</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; Прагма не</target>
        </trans-unit>
        <trans-unit id="7bf3b5adc84fde6d734586f4bec0209359aa5187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; удаляет все экземпляры каждого указанного каталога из @INC.</target>
        </trans-unit>
        <trans-unit id="1aa289805fbc7ad3a1863fbfa81d350e063c7221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="translated">Конструкции &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; еще не реализованы. Это ограничение можно легко обойти в новом коде, явно создав канал. В следующем примере показано, как писать разветвленному дочернему элементу:</target>
        </trans-unit>
        <trans-unit id="91b6442686235ec3446ecfbcfcc1b68ae5f717df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (also known as &quot;disciplines&quot;) for all I/O. Any two-argument open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults. Even three-argument opens may be affected by this pragma when they don't specify IO layers in MODE.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; прагма служит одним из интерфейсов , чтобы объявить по умолчанию &amp;laquo;слои&amp;raquo; (также известные как &amp;laquo;дисциплины&amp;raquo;) для всех I / O. Любые двухаргументные операторы open (), readpipe () (также известные как qx //) и аналогичные операторы, обнаруженные в лексической области этой прагмы, будут использовать объявленные значения по умолчанию. Эта прагма может повлиять даже на открытие с тремя аргументами, если они не указывают уровни ввода-вывода в MODE.</target>
        </trans-unit>
        <trans-unit id="d568cb2b48539b711386365d8e03258e04c0c727" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="translated">Функции &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; прозрачно работают со всеми кодовыми точками, а не только с одним ASCII - и фактически, даже не только с Unicode.</target>
        </trans-unit>
        <trans-unit id="48c955c71d75929afac22e8dfa9aad63b2004a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; появился в perl 5.005. Он компилирует регулярное выражение, но не применяет его. Когда вы используете предварительно скомпилированную версию регулярного выражения, perl выполняет меньше работы. В этом примере я вставил &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; чтобы преобразовать каждый шаблон в его предварительно скомпилированную форму. В остальном скрипт такой же, но быстрее:</target>
        </trans-unit>
        <trans-unit id="6086a140e1b37399f10a989a119aa2028d369c83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is</source>
          <target state="translated">Команда &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; перезапускает блок цикла без повторной оценки условия. Блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , если он есть,</target>
        </trans-unit>
        <trans-unit id="362e8253628830d9a4d5614fd639fe79bc546984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">Команда &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; перезапускает блок цикла без повторной оценки условия. Блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , если он есть, не выполняется. Если LABEL опущен, команда относится к самому внутреннему охватывающему циклу. Форма &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; &lt;a href=&quot;functions/redo&quot;&gt;повтора&lt;/a&gt; , доступная начиная с Perl 5.18.0, позволяет вычислять имя метки во время выполнения и во всем остальном идентична &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; . Программы, которые хотят солгать себе о том, что было только что введено, обычно используют эту команду:</target>
        </trans-unit>
        <trans-unit id="f9c130f1621f9ce97dabd985717a6055d0d6afd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор подстановки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; задокументирован в &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="121511ae0b5d1fbb23eba64b638e8a05d463c939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt; , if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; - еще одно место, где используется регулярное выражение. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; разделяет &lt;code&gt;string&lt;/code&gt; операнд на список подстрок и возвращает этот список. Регулярное выражение должно соответствовать тому, что составляет разделители для желаемых подстрок. &lt;code&gt;limit&lt;/code&gt; , если он присутствует, сдерживает расщепление в не более &lt;code&gt;limit&lt;/code&gt; числа строк. Например, чтобы разбить строку на слова, используйте</target>
        </trans-unit>
        <trans-unit id="7f7da5ebd320780203ed7d5e0028f1f486db3bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; ключевых слов создает лексическую переменную (следуя той же области видимости , как &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ) , который сохраняется от одного вызова подпрограммы к следующему. Если переменная состояния находится внутри анонимной подпрограммы, то каждая копия подпрограммы имеет свою собственную копию переменной состояния. Однако значение переменной состояния будет по-прежнему сохраняться между вызовами одной и той же копии анонимной подпрограммы. (Не забывайте, что &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; создает новую подпрограмму каждый раз при выполнении.)</target>
        </trans-unit>
        <trans-unit id="87a4764ce311581074e8327a658c6ee1ed914b66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; зонды получить четвертый аргумент: имя пакета функции.</target>
        </trans-unit>
        <trans-unit id="fa495b532decb2c8f20d40c7506dd35df2aff6f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; встроенных в считаются несостоявшимися в следующих случаях:</target>
        </trans-unit>
        <trans-unit id="007bfa453d22a010bcc25f103e9e741d0e19770d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; оператор создает подпроцесс, и передает свои аргументы подпроцесса для исполнения в качестве команды DCL. Поскольку подпроцесс создается напрямую через &lt;code&gt;lib$spawn()&lt;/code&gt; , можно указать любую допустимую командную строку DCL. Если строка начинается с символа &amp;laquo;@&amp;raquo;, она безоговорочно рассматривается как команда DCL. В противном случае, если первый токен содержит символ, используемый в качестве разделителя в спецификации файла (например &lt;code&gt;:&lt;/code&gt; или &lt;code&gt;]&lt;/code&gt; ), делается попытка расширить его, используя тип по умолчанию</target>
        </trans-unit>
        <trans-unit id="c442498b077f35c1d517c581c1d1aa5d5b6d170c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; возвращает время, прошедшее в реальном времени с некоторой точки в прошлом (например, запуск системы), пользовательское и системное время для этого процесса, а также пользовательское и системное время, используемое дочерними процессами. Все время возвращается в тактах часов.</target>
        </trans-unit>
        <trans-unit id="80b97318408e6d656bf28c96d67c4dfdc24c2653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; переводит символы целиком. (Обратите внимание, что функция &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; была удалена. Для аналогичных функций см. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11a568ea0ae08ef300d37d167d740832b4c2b16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; alternative might look like this:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; Альтернатива может выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="42f87c254ee8d81cee26e792f60cacaefbfbe36a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; counts the null bytes. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; подсчитывает байты нулевые. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; вызов возвращает список пар имя-значение , каждая из которых разбирают на &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; блока.</target>
        </trans-unit>
        <trans-unit id="a53ff006297297281156ad4ddc8aef0830e3811c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="translated">Версия &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; - явный победитель. Одно решение гибкое, другое быстрое - и, соответственно, программист выбирает, что использовать.</target>
        </trans-unit>
        <trans-unit id="6f47b182b84a1df9e8040499b142da5e15a5a35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Попался</target>
        </trans-unit>
        <trans-unit id="5e2ca855aa217bd553e610f05dba85cf9019d5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma disables character semantics for the rest of the lexical scope in which it appears. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; Pragma Отключает символы семантика для остальной части лексической области , в которой он появляется. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; могут быть использованы для отмены эффекта &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; в текущей лексической области.</target>
        </trans-unit>
        <trans-unit id="9fdef637aec2a8c40d4ef4a640873fd3daeaa545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="translated">Операторы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; влияют на тесты файлов, определенные в их блоке, до конца ближайшего включающего блока (они лексически привязаны к блоку).</target>
        </trans-unit>
        <trans-unit id="8744ea2543ae1b476ba91732c622f01f08c1038b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms). The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; Прагма говорит парсер Perl , чтобы позволить UTF-8 в тексте программы в текущей лексической области (разрешить UTF-EBCDIC на платформах на базе EBCDIC). &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; Прагма говорит Perl , чтобы переключиться на обработку исходного текста в виде буквенных байтов в текущей лексической области.</target>
        </trans-unit>
        <trans-unit id="43067066e43761608ec314550d1ef0009ca78c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="translated">В &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; Pragma или &lt;b&gt;-w&lt;/b&gt; переключатель предупредит вас , если он интерпретирует зарезервированное слово как строка. Но он больше не будет предупреждать вас об использовании строчных слов, потому что строка эффективно заключена в кавычки.</target>
        </trans-unit>
        <trans-unit id="19cdd025fab18dcd164b56bb8b49804d47261c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; Прагма производит некоторую прекрасную диагностику. Можно также использовать флаг &lt;b&gt;-w&lt;/b&gt; , но его использование обычно не рекомендуется, потому что он применяется ко всему исполняемому коду Perl, включая тот, который не находится под вашим контролем.</target>
        </trans-unit>
        <trans-unit id="98ff32ffdb1aaec51b5964ab04fedf9b556042ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">Функция &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; , даже если она принимает только один аргумент, имеет приоритет оператора списка, поэтому будьте осторожны:</target>
        </trans-unit>
        <trans-unit id="57bb7a10c9bf27aba4e74945efa7f4324ecc8306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; сильно отличается от других форм &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . Фактически, это вообще не goto в обычном смысле слова, и у него нет стигмы, связанной с другими goto. Вместо этого он выходит из текущей подпрограммы (теряя любые изменения, установленные local ()), и немедленно вызывает вместо нее именованную подпрограмму, используя текущее значение @_. Это используется &lt;code&gt;AUTOLOAD&lt;/code&gt; подпрограммы , которые желают загрузить другую подпрограмму , а затем делать вид , что другая подпрограмма была вызвана , в первую очередь ( за исключением того, что любые модификации &lt;code&gt;@_&lt;/code&gt; в текущей подпрограмме распространяется на другую подпрограмму) . После &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , даже не &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; сможет сказать, что эта процедура была вызвана первой.</target>
        </trans-unit>
        <trans-unit id="e45cfef5656ef233c1972b6e6db8f04158149f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; ожидает, что &lt;code&gt;EXPR&lt;/code&gt; будет оценивать ссылку на код или имя метки. Если он оценивается как ссылка на код, он будет обрабатываться как &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , как показано ниже. Это особенно полезно для реализации хвостовой рекурсии через &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0fba7d2ee7cbb751d9b45951b63706bcd429d8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">Форма &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; находит оператор с меткой LABEL и возобновляет выполнение там. Его нельзя использовать для выхода из блока или подпрограммы, заданной для &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Его можно использовать практически в любом другом месте в пределах динамической области видимости, в том числе вне подпрограмм, но обычно лучше использовать какую-либо другую конструкцию, например &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Автор Perl никогда не чувствовал необходимости использовать эту форму &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (то есть в Perl; C - другое дело). (Разница в том, что C не предлагает именованные циклы в сочетании с управлением циклами. Perl делает это, и это заменяет большинство структурированных применений &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; в других языках.)</target>
        </trans-unit>
        <trans-unit id="0ec2144df4bcb647e47e9a3fffb037716e0ff735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; команда , как &lt;code&gt;break&lt;/code&gt; оператор в C (при использовании в циклах); он немедленно выходит из рассматриваемого цикла. Если LABEL опущен, команда относится к самому внутреннему охватывающему циклу. &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; форма доступна , начиная с Perl 5.18.0, позволяет имя метки быть вычислен во время выполнения, а в остальном идентичны &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . Блок &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , если он есть, не выполняется:</target>
        </trans-unit>
        <trans-unit id="0dc04adeb5f33f6be3e55c3b75049d3460dd5faf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; команда как и по- &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; заявление в C; он запускает следующую итерацию цикла:</target>
        </trans-unit>
        <trans-unit id="d03baace3369995824b0971e1012da68e7afe6a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90f5477a728439ae001b7de4028bc5063fe8048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="translated">Прагма &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; может использоваться для установки модификаторов по умолчанию (включая их) для регулярных выражений, скомпилированных в пределах его области действия. Эта прагма имеет приоритет над другими прагмами, перечисленными ниже, которые также изменяют значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="00f56e4e287b4dad7bb9b00175cad4e28ccf4f49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">Команда &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; перезапускает блок цикла без повторной оценки условия. Блок &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , если он есть, не выполняется. Если LABEL опущен, команда относится к самому внутреннему охватывающему циклу. Форма &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; &lt;a href=&quot;redo&quot;&gt;повтора&lt;/a&gt; , доступная начиная с Perl 5.18.0, позволяет вычислять имя метки во время выполнения и во всем остальном идентична &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; . Программы, которые хотят солгать себе о том, что было только что введено, обычно используют эту команду:</target>
        </trans-unit>
        <trans-unit id="98d8fed67bad4314d20d9f4fe777fa7ab53123e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (sometimes pronounced &quot;fat comma&quot;) is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.</source>
          <target state="translated">Оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; (иногда произносится как &amp;laquo;жирная запятая&amp;raquo;) является синонимом запятой, за исключением того, что он интерпретирует слово слева от него как строку, если оно начинается с буквы или подчеркивания и состоит только из букв, цифр и подчеркивания. Сюда входят операнды, которые в противном случае могли бы быть интерпретированы как операторы, константы, v-строки с одним числом или вызовы функций. Если вы сомневаетесь в таком поведении, левый операнд можно указать явно.</target>
        </trans-unit>
        <trans-unit id="8399dbf8e2e784c4274bc7b091a4f7216970d51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.</source>
          <target state="translated">Оператор &lt;code&gt;=&amp;gt;&lt;/code&gt; полезен при документировании соответствия между ключами и значениями в хэшах и другими парными элементами в списках.</target>
        </trans-unit>
        <trans-unit id="efd3e2bb957eaa0ff2ef103df55bdfaea8225389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=back&lt;/code&gt; command does not take any arguments.</source>
          <target state="translated">Команда &lt;code&gt;=back&lt;/code&gt; не принимает никаких аргументов.</target>
        </trans-unit>
        <trans-unit id="2748bc14f635bff7b4cada98a19718c4d6f31834" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt; . End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="translated">В &lt;code&gt;=begin&lt;/code&gt; директива может пометить раздел для конкретной цели. Если синтаксический анализатор Pod не хочет его обрабатывать, он просто игнорирует его. Пометьте комментарии &lt;code&gt;comment&lt;/code&gt; . Завершите комментарий с помощью &lt;code&gt;=end&lt;/code&gt; с той же меткой. Вам все еще нужен &lt;code&gt;=cut&lt;/code&gt; , чтобы вернуться к коду Perl из комментария Pod:</target>
        </trans-unit>
        <trans-unit id="f59fd3ccb5e9b7feba1f1fe25b7136044c1d07fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt;. End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8064ce24f5339d152aec47e53a990ce73ae1e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) or the end of the file.</source>
          <target state="translated">У команды &lt;code&gt;=over&lt;/code&gt; нет соответствующего &lt;code&gt;=head1&lt;/code&gt; &lt;code&gt;=back&lt;/code&gt; перед следующим заголовком ( = head1 или &lt;code&gt;=head2&lt;/code&gt; ) или концом файла.</target>
        </trans-unit>
        <trans-unit id="e8028d211e346b9053331798c8e936f0c3ebfac6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt;) or the end of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8153dbca699722108378e052ce04788e510ab3df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EXPORT&lt;/code&gt; array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace. Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export. Do</source>
          <target state="translated">&lt;code&gt;@EXPORT&lt;/code&gt; массив говорит Perl , какие из переменных и подпрограмм удлиняющей должны быть помещены в пространство имен вызывающего пакета. Поскольку вы не знаете, использовал ли пользователь ваши имена переменных и подпрограмм, жизненно важно тщательно выбрать, что экспортировать. Делать</target>
        </trans-unit>
        <trans-unit id="59c8e98631ebe2ad43446558b18c0e9a67b97b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@array[1]&lt;/code&gt; представляет собой срез массива, хотя он имеет только один индекс. Вы можете извлечь несколько элементов одновременно, указав дополнительные индексы в виде списка, например &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd3d23d5c24e2e27f46834d267601cebe9f5684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651c155493f8eecba5929c58d7483ab06d1863f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACTUAL&lt;/code&gt; tells &lt;code&gt;NEXT&lt;/code&gt; that there must actually be a next method to call, or it should throw an exception.</source>
          <target state="translated">&lt;code&gt;ACTUAL&lt;/code&gt; говорит &lt;code&gt;NEXT&lt;/code&gt; , что должно быть на самом деле следующим способом вызова, или он должен бросить исключение.</target>
        </trans-unit>
        <trans-unit id="8e537d261fb0eb0877ceb1c6331c23797b3540cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alias&lt;/code&gt; module implements localization of the basic types within the</source>
          <target state="translated">Модуль &lt;code&gt;Alias&lt;/code&gt; реализует локализацию основных типов в пределах</target>
        </trans-unit>
        <trans-unit id="2c6a8f1a286c25be4929a3d652924543120a4cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt; . Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">Модуль &lt;code&gt;Archive::Tar&lt;/code&gt; может дополнительно использовать &lt;code&gt;Compress::Zlib&lt;/code&gt; (через модуль &lt;code&gt;IO::Zlib&lt;/code&gt; ) для доступа к файлам tar, сжатым с помощью &lt;code&gt;gzip&lt;/code&gt; . К сожалению, файлы tar, сжатые с помощью утилиты &lt;code&gt;compress&lt;/code&gt; Unix, не могут быть прочитаны с помощью &lt;code&gt;Compress::Zlib&lt;/code&gt; и поэтому к ним нельзя получить прямой доступ с помощью &lt;code&gt;Archive::Tar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c846109c9cdb2321e2be7662c4588cdc7ec88db7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accessed by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b17fdbcd746a9f7c286b280ba85ada7dc1cad7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43769b61441be000184345132a2a54dc3708064b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B::COP&lt;/code&gt; class is used for &quot;nextstate&quot; and &quot;dbstate&quot; ops. As of Perl 5.22, it is also used for &quot;null&quot; ops that started out as COPs.</source>
          <target state="translated">Класс &lt;code&gt;B::COP&lt;/code&gt; используется для операций &quot;nextstate&quot; и &quot;dbstate&quot;. Начиная с Perl 5.22, он также используется для &amp;laquo;нулевых&amp;raquo; операций, которые начинались как COP.</target>
        </trans-unit>
        <trans-unit id="1a2938ca3d630d110b73048269c361ea78fb5cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module contains a set of utility functions for querying the current state of the Perl interpreter; typically these functions return objects from the B::SV and B::OP classes, or their derived classes. These classes in turn define methods for querying the resulting objects about their own internal state.</source>
          <target state="translated">Модуль &lt;code&gt;B&lt;/code&gt; содержит набор служебных функций для запроса текущего состояния интерпретатора Perl; обычно эти функции возвращают объекты из классов B :: SV и B :: OP или их производных классов. Эти классы, в свою очередь, определяют методы для запроса результирующих объектов об их собственном внутреннем состоянии.</target>
        </trans-unit>
        <trans-unit id="40f9413962f128106cd0802b4a2c73013cd7ed0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module exports a variety of functions: some are simple utility functions, others provide a Perl program with a way to get an initial &quot;handle&quot; on an internal object.</source>
          <target state="translated">Модуль &lt;code&gt;B&lt;/code&gt; экспортирует множество функций: некоторые из них являются простыми служебными функциями, другие предоставляют программе Perl способ получения начального &amp;laquo;дескриптора&amp;raquo; внутреннего объекта.</target>
        </trans-unit>
        <trans-unit id="5c92116836eedf111e1da108ac269b10e9e38e79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module supplies classes which allow a Perl program to delve into its own innards. It is the module used to implement the &quot;backends&quot; of the Perl compiler. Usage of the compiler does not require knowledge of this module: see the</source>
          <target state="translated">Модуль &lt;code&gt;B&lt;/code&gt; предоставляет классы, которые позволяют программе Perl вникать в свои собственные внутренности. Это модуль, используемый для реализации &amp;laquo;бэкэндов&amp;raquo; компилятора Perl. Использование компилятора не требует знания этого модуля: см.</target>
        </trans-unit>
        <trans-unit id="36e744ee541a84c63162e7b4ffbdc783bc6d5f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; и &lt;code&gt;END&lt;/code&gt; Подпрограмма не столько Подпрограммы как именованные специальные кодовых блоки, из которых вы можете иметь более одного в пакете, и которые вы можете &lt;b&gt;не&lt;/b&gt; называть явно. Смотрите &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT и END в perlmod&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8aea840d46b0e93fbdf7c5fc764686c8f3b8c58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; to happen at compile time. The &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method any way it likes, though most modules just choose to derive their &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;a href=&quot;exporter&quot;&gt;&lt;code&gt;Exporter&lt;/code&gt;&lt;/a&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method can be found, then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a9cf1f5e3f21b86fcbb8df98f12cbc38b145e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; вынуждает &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; произойдет во время компиляции. &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; убеждается модуль загружается в память , если он еще не был. &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; не является встроенным; это просто вызов обычного статического метода в пакет &lt;code&gt;Module&lt;/code&gt; , чтобы сообщить модулю, что нужно импортировать список функций обратно в текущий пакет. Модуль может реализовать свой метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; как угодно, хотя большинство модулей просто выбирают наследование своего метода &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; через наследование от класса &lt;code&gt;Exporter&lt;/code&gt; , определенного в модуле &lt;code&gt;Exporter&lt;/code&gt; . См. &lt;a href=&quot;exporter&quot;&gt;Экспортер&lt;/a&gt; . Если нет &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; можно найти метод импорта, вызов пропускается, даже если есть метод AUTOLOAD.</target>
        </trans-unit>
        <trans-unit id="a9fa3a73043129ebc13296822d30d370f57d9e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; вынуждает &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; произойдет во время компиляции. &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; убеждается модуль загружается в память , если он еще не был. &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; не является встроенным; это просто вызов обычного статического метода в пакет &lt;code&gt;Module&lt;/code&gt; , чтобы сообщить модулю, что нужно импортировать список функций обратно в текущий пакет. Модуль может реализовать свой метод &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; как угодно, хотя большинство модулей просто выбирают наследование своего метода &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; через наследование от класса &lt;code&gt;Exporter&lt;/code&gt; , определенного в модуле &lt;code&gt;Exporter&lt;/code&gt; . См. &lt;a href=&quot;../exporter&quot;&gt;Экспортер&lt;/a&gt; . Если нет &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; можно найти метод импорта, вызов пропускается, даже если есть метод AUTOLOAD.</target>
        </trans-unit>
        <trans-unit id="9201471b5261b8b4c37aca6c270b666c4082753d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; will assure that the loading of</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; будет гарантировать , что загрузки</target>
        </trans-unit>
        <trans-unit id="1df83aa021f2d25a04664c457983f82d52813309" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a5cc1adfa77075f0adc752b299d298837ebeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, or string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="translated">В &lt;code&gt;CHECK&lt;/code&gt; и &lt;code&gt;INIT&lt;/code&gt; блоки кода составитель &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , строки &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , или строку &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; не будет выполняться , если они происходят после окончания основной фазы компиляции; это может быть проблемой в mod_perl и других постоянных средах, которые используют эти функции для загрузки кода во время выполнения.</target>
        </trans-unit>
        <trans-unit id="b104eb26cbd94be033237435dd68c95041e8eb25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;require&lt;/code&gt;, string &lt;code&gt;do&lt;/code&gt;, or string &lt;code&gt;eval&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981efa7d62f736b9f150f24425de3b13fd11e4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8f4372f9a2ba513ea1d0d1264224c42f7ba97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="translated">В &lt;code&gt;CNS11643&lt;/code&gt; кодирующие файлы не являются полными. Для обычных манипуляций с &lt;code&gt;CNS11643&lt;/code&gt; используйте &lt;code&gt;EUC-TW&lt;/code&gt; в &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode :: HanExtra&lt;/a&gt; , который содержит плоскости 1-7.</target>
        </trans-unit>
        <trans-unit id="82651f5375f4780d1c104db566c2ac41e7d83b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CORE&lt;/code&gt; namespace gives access to the original built-in functions of Perl. The &lt;code&gt;CORE&lt;/code&gt; package is built into Perl, and therefore you do not need to use or require a hypothetical &quot;CORE&quot; module prior to accessing routines in this namespace.</source>
          <target state="translated">Пространство имен &lt;code&gt;CORE&lt;/code&gt; дает доступ к исходным встроенным функциям Perl. Пакет &lt;code&gt;CORE&lt;/code&gt; встроен в Perl, и поэтому вам не нужно использовать или требовать гипотетический модуль &amp;laquo;CORE&amp;raquo; перед доступом к подпрограммам в этом пространстве имен.</target>
        </trans-unit>
        <trans-unit id="8ae42d583657def46159ee7ad1318ba4bd6a3fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Compress::Zlib&lt;/code&gt; module can be split into two general areas of functionality, namely a simple read/write interface to</source>
          <target state="translated">Модуль &lt;code&gt;Compress::Zlib&lt;/code&gt; можно разделить на две основные области функциональности, а именно простой интерфейс чтения / записи для</target>
        </trans-unit>
        <trans-unit id="46e8d3223a09166ecaf398dcfdae3710dcb3dcb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DATA&lt;/code&gt; file handle by default has whatever PerlIO layers were in place when Perl read the file to parse the source. Normally that means that the file is being read bytewise, as if it were encoded in Latin-1, but there are two major ways for it to be otherwise. Firstly, if the &lt;code&gt;__END__&lt;/code&gt;/&lt;code&gt;__DATA__&lt;/code&gt; token is in the scope of a &lt;code&gt;use utf8&lt;/code&gt; pragma then the &lt;code&gt;DATA&lt;/code&gt; handle will be in UTF-8 mode. And secondly, if the source is being read from perl's standard input then the &lt;code&gt;DATA&lt;/code&gt; file handle is actually aliased to the &lt;code&gt;STDIN&lt;/code&gt; file handle, and may be in UTF-8 mode because of the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable or perl's command-line switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6db4ade377c3bdb345b712f7106420996bb7261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB::OUT&lt;/code&gt; filehandle is opened to</source>
          <target state="translated">&lt;code&gt;DB::OUT&lt;/code&gt; указатель_на_файл открыт для</target>
        </trans-unit>
        <trans-unit id="3f0a37f63cf06fefd13078baff9b2ef8733fd16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt; packages are always omitted, as are any &quot;private&quot; packages that have leading underscores in the namespace (e.g. &lt;code&gt;Foo::_private&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ced3778c80b0e6ddceec7627220df1317342e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEBUG&lt;/code&gt; constant wipes the floor with even the &lt;code&gt;$debug&lt;/code&gt; variable, clocking in at minus zero seconds, and generates a &quot;warning: too few iterations for a reliable count&quot; message into the bargain. To see what is really going on, and why we had too few iterations when we thought we asked for 100000, we can use the very useful &lt;code&gt;B::Deparse&lt;/code&gt; to inspect the new code:</source>
          <target state="translated">Константа &lt;code&gt;DEBUG&lt;/code&gt; стирает пол даже с переменной &lt;code&gt;$debug&lt;/code&gt; , отсчитывая минус ноль секунд, и генерирует сообщение &amp;laquo;предупреждение: слишком мало итераций для надежного подсчета&amp;raquo;. Чтобы увидеть, что на самом деле происходит, и почему у нас было слишком мало итераций, когда мы думали, что мы просили 100000, мы можем использовать очень полезный &lt;code&gt;B::Deparse&lt;/code&gt; для проверки нового кода:</target>
        </trans-unit>
        <trans-unit id="c9d4dcbece0076153dceb385297ea42930b3d2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOES&lt;/code&gt; method returns</source>
          <target state="translated">Метод &lt;code&gt;DOES&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="13b108bacf05fadc1d57d69518e2671634247ba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Deparse&lt;/code&gt; flag makes Dump() run slower, since the XSUB implementation does not support it.</source>
          <target state="translated">&lt;code&gt;Deparse&lt;/code&gt; флаг делает дамп () работать медленнее, поскольку реализация XSUB не поддерживает его.</target>
        </trans-unit>
        <trans-unit id="1afec46de9e3c4185e7d2feb3396554e349575f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::NYTProf&lt;/code&gt; and &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; modules can help you find uses of these problematic match variables in your code.</source>
          <target state="translated">В &lt;code&gt;Devel::NYTProf&lt;/code&gt; и &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; модули могут помочь вам найти применение этого проблемного переменное соответствия в коде.</target>
        </trans-unit>
        <trans-unit id="7a6b56d230ad8470a46e41fa3a6181ade20a4909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::SmallProf&lt;/code&gt; profiler examines the runtime of your Perl program and produces a line-by-line listing to show how many times each line was called, and how long each line took to execute. It is called by supplying the familiar &lt;code&gt;-d&lt;/code&gt; flag to Perl at runtime.</source>
          <target state="translated">&lt;code&gt;Devel::SmallProf&lt;/code&gt; профайлер исследует время выполнения вашей программы на Perl и выпускает линию за линией листинга , чтобы показать , сколько раз была вызвана в каждой строке, и как долго каждая линия приняла выполнить. Он вызывается путем предоставления Perl знакомого флага &lt;code&gt;-d&lt;/code&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="e3e899b88f5d9c103f9957a381fb75493e4ca219" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel&lt;/code&gt; namespace has several modules which you can use to profile your Perl programs.</source>
          <target state="translated">В пространстве имен &lt;code&gt;Devel&lt;/code&gt; есть несколько модулей, которые вы можете использовать для профилирования ваших программ Perl.</target>
        </trans-unit>
        <trans-unit id="f7b3b4bbb4e3a91049c3f2bf1c1599a52a4bab75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; interface is based on the interface originally developed by Neil Winton for his &lt;code&gt;MD5&lt;/code&gt; module.</source>
          <target state="translated">Интерфейс &lt;code&gt;Digest::&lt;/code&gt; основан на интерфейсе, первоначально разработанном Нилом Винтоном для его модуля &lt;code&gt;MD5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="359f33360a7a83f14790bf4d659bef0945120eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; modules calculate digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some data, called a message. The digest is (usually) some small/fixed size string. The actual size of the digest depend of the algorithm used. The message is simply a sequence of arbitrary bytes or bits.</source>
          <target state="translated">В &lt;code&gt;Digest::&lt;/code&gt; модулей расчет дайджестов, называемых также &amp;laquo;отпечатками пальцами&amp;raquo; или &amp;laquo;хэш&amp;raquo;, какие - либо данных, называемых сообщением. Дайджест (обычно) представляет собой строку небольшого / фиксированного размера. Фактический размер дайджеста зависит от используемого алгоритма. Сообщение - это просто последовательность произвольных байтов или битов.</target>
        </trans-unit>
        <trans-unit id="5112b49f2609b19e911cd2f6a34cb7ffa7088cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module allows you to use the RSA Data Security Inc. MD5 Message Digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.</source>
          <target state="translated">Модуль &lt;code&gt;Digest::MD5&lt;/code&gt; позволяет вам использовать алгоритм RSA Data Security Inc. MD5 Message Digest из программ на Perl. Алгоритм принимает на вход сообщение произвольной длины и выдает на выходе 128-битный &amp;laquo;отпечаток пальца&amp;raquo; или &amp;laquo;дайджест сообщения&amp;raquo; на входе.</target>
        </trans-unit>
        <trans-unit id="2adafeb0e9eb580775e9922353cdda9ed2fef18a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module is written by Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</source>
          <target state="translated">Модуль &lt;code&gt;Digest::MD5&lt;/code&gt; написан Жисль Аас &amp;lt;gisle@ActiveState.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="048cfda097524929fcf424f6794f7c010276767b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">Модуль &lt;code&gt;Digest::MD5&lt;/code&gt; предоставляет процедурный интерфейс для простого использования, а также объектно-ориентированный интерфейс, который может обрабатывать сообщения произвольной длины и может напрямую читать файлы.</target>
        </trans-unit>
        <trans-unit id="417545c4adfbc434083e36d20bccbfb0f99aa98e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt; , and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Digest::base&lt;/code&gt; класс обеспечивают реализацию методов &lt;code&gt;addfile&lt;/code&gt; и &lt;code&gt;add_bits&lt;/code&gt; с точки зрения &lt;code&gt;add&lt;/code&gt; и методов &lt;code&gt;hexdigest&lt;/code&gt; и &lt;code&gt;b64digest&lt;/code&gt; с точки зрения &lt;code&gt;digest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c6996a284acc9e86940a92ab690a3ac4f18b4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt;, and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628d5f24b15638f2c6ff193717192cc425ae4155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DirHandle&lt;/code&gt; method provide an alternative interface to the opendir(), closedir(), readdir(), and rewinddir() functions.</source>
          <target state="translated">Метод &lt;code&gt;DirHandle&lt;/code&gt; предоставляет альтернативный интерфейс для функций opendir (), closedir (), readdir () и rewinddir ().</target>
        </trans-unit>
        <trans-unit id="358ca39e53232388840862f052183678f86697cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt; . And &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will call &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="translated">Функция &lt;code&gt;Dump()&lt;/code&gt; принимает один или два аргумента: что-то для сброса и необязательный предел для рекурсии и элементов массива (по умолчанию 4). Первый аргумент вычисляется в скалярном контексте rvalue с исключениями для @array и% hash, которые выгружают сам массив или хэш. Итак, &lt;code&gt;Dump @array&lt;/code&gt; работает, как и &lt;code&gt;Dump $foo&lt;/code&gt; . И &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; вызовет &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; в контексте rvalue, тогда как &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; вызовет его в контексте lvalue.</target>
        </trans-unit>
        <trans-unit id="a13938ff22176b323e1b3258e2271152d9209b89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt;. And &lt;code&gt;Dump pos&lt;/code&gt; will call &lt;code&gt;pos&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\pos}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbf79b7555598c068ba8d9743bee2fb95392923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function, by default, dumps up to 4 elements from a toplevel array or hash. This number can be increased by supplying a second argument to the function.</source>
          <target state="translated">Функция &lt;code&gt;Dump()&lt;/code&gt; по умолчанию выгружает до 4 элементов из массива или хэша верхнего уровня. Это число можно увеличить, указав второй аргумент функции.</target>
        </trans-unit>
        <trans-unit id="c95778d99c76e8e03e061209f2b6b5768436be5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END&lt;/code&gt; block isn't called when untrapped signals kill the program, though, so if you use &lt;code&gt;END&lt;/code&gt; blocks you should also use</source>
          <target state="translated">Блок &lt;code&gt;END&lt;/code&gt; не вызывается, когда необработанные сигналы убивают программу, поэтому, если вы используете блоки &lt;code&gt;END&lt;/code&gt; , вы также должны использовать</target>
        </trans-unit>
        <trans-unit id="f434d74067f98a36c01cbe9c20f7d7cf7b02ed54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPR&lt;/code&gt; following the modifier is referred to as the &quot;condition&quot;. Its truth or falsehood determines how the modifier will behave.</source>
          <target state="translated">&lt;code&gt;EXPR&lt;/code&gt; после модификатора называется как &amp;laquo;состояние&amp;raquo;. Его правда или ложь определяет, как модификатор будет себя вести.</target>
        </trans-unit>
        <trans-unit id="0be035a23dc6f5f75a5bb7fdc10fe00056028240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module knows about many encodings and has interfaces for doing conversions between those encodings:</source>
          <target state="translated">Модуль &lt;code&gt;Encode&lt;/code&gt; знает о многих кодировках и имеет интерфейсы для преобразования между этими кодировками:</target>
        </trans-unit>
        <trans-unit id="5cdf933f51543c5ce4713919bd68bbd3f797378f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module provides the interface between Perl strings and the rest of the system. Perl strings are sequences of</source>
          <target state="translated">Модуль &lt;code&gt;Encode&lt;/code&gt; обеспечивает интерфейс между строками Perl и остальной частью системы. Строки Perl - это последовательности</target>
        </trans-unit>
        <trans-unit id="4968644a1dddd78111692e0824f91d81d4b5fde6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) to scalars. If the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="translated">Функция &lt;code&gt;Env::import()&lt;/code&gt; связывает переменные среды с подходящими именами с глобальными переменными Perl с такими же именами. По умолчанию он связывает все существующие переменные среды ( &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) со скалярами. Если функция &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; получает аргументы, она принимает их как список переменных для связывания; ничего страшного, если их еще нет. Префикс скалярного типа '$' выводится для любого элемента этого списка, не имеющего префикса '$' или '@'. Массивы реализованы в терминах &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; с использованием &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; в качестве разделителя.</target>
        </trans-unit>
        <trans-unit id="5d5e15ad1a58fa2627594efcd21d9bd55ca58029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;keys %ENV&lt;/code&gt;) to scalars. If the &lt;code&gt;import&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;split&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb5e18a95e482684c2bead13158da2042ed8e01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fe8159aef76b700007013f5b9be387367b2a84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraFieldLocal&lt;/code&gt; option is used to store additional metadata in the local header for the zip file/buffer. The &lt;code&gt;ExtraFieldCentral&lt;/code&gt; does the same for the matching central header.</source>
          <target state="translated">Параметр &lt;code&gt;ExtraFieldLocal&lt;/code&gt; используется для хранения дополнительных метаданных в локальном заголовке zip-файла / буфера. &lt;code&gt;ExtraFieldCentral&lt;/code&gt; делает то же самое для сопоставления центрального заголовка.</target>
        </trans-unit>
        <trans-unit id="7dceaf4fc99f40b45472fc6396adb3cf093b19ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="translated">&lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; пара избавиться от любых значений , возвращенных подпрограммой Perl (смотрите следующий пример), плюс он также будет сбрасывать бренную КУ , которые мы создали. Наличие &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; в начале кода гарантирует, что никакие другие смертные не будут уничтожены.</target>
        </trans-unit>
        <trans-unit id="140fe01c0b7ba42e4663eeef8254f0e842ecf849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ea08916fc715ad11c85a7aa69540693ba076ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREEZE&lt;/code&gt; method can return any number of values (i.e. zero or more). These values and the paclkage/classname of the object will then be encoded as a tagged JSON value in the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577b209cddb0e754330f4709ee24d502c593af10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;G_RETHROW&lt;/code&gt; flag can be used if you only need eval_sv() to execute code specified by a string, but not catch any errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e4c30b0dc82b24659a532f35106fc4afecb721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Host&lt;/code&gt; header is generated from the URL in accordance with RFC 2616. It is a fatal error to specify &lt;code&gt;Host&lt;/code&gt; in the &lt;code&gt;headers&lt;/code&gt; option. Other headers may be ignored or overwritten if necessary for transport compliance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e824605b84cee8c0b954423f3ab5ef2eb2758b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="translated">В &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; ключевые слова могут быть смешаны с объявлениями ANSI-стиле, как и в</target>
        </trans-unit>
        <trans-unit id="9f81634b914a660a9d16e3716c6017257055b0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt;/&lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291d3950c0f7a1274711a429d0d47b0e9604c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections have identical formats, that is, each unindented line starts a new in- or output map respectively. A new in- or output map must start with the name of the XS type to map on a line by itself, followed by the code that implements it indented on the following lines. Example:</source>
          <target state="translated">В &lt;code&gt;INPUT&lt;/code&gt; и &lt;code&gt;OUTPUT&lt;/code&gt; секции имеют одинаковые форматы, то есть, каждая отступа строка начинает новый входе или выходе карты соответственно. Новая карта входа или выхода должна начинаться с имени типа XS, который будет отображаться в отдельной строке, за которым следует код, реализующий его, с отступом в следующих строках. Пример:</target>
        </trans-unit>
        <trans-unit id="0839ebfa51c8f90f143d226a6a7f33a7ff311878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="translated">&lt;code&gt;INT2PTR&lt;/code&gt; макросъемки (определено в perl.h) бросает целое число в указатель данного типа, заботясь о возможном разного размера целых чисел и указателей. Существуют также &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; для отображения другого пути, которые могут быть полезны в разделах OUTPUT.</target>
        </trans-unit>
        <trans-unit id="8dee4e81117d0288fc40b8cb09d886277f261bfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt;, &lt;code&gt;PTR2UV&lt;/code&gt;, &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7466a438605e61935ae6328f4fe2d9214ef781c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3A-Keyword&quot;&gt;&quot;The OUTPUT: Keyword&quot;&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f85903ef5f9040c0ff99931c044e8d15426a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="translated">Параметры &lt;code&gt;IN_OUT&lt;/code&gt; идентичны параметрам, введенным с помощью &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;унарного оператора &amp;amp;&lt;/a&gt; и помещенным в раздел &lt;code&gt;OUTPUT:&lt;/code&gt; (см &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;. Ключевое слово OUTPUT:)&lt;/a&gt; . Параметры &lt;code&gt;IN_OUTLIST&lt;/code&gt; очень похожи, с той лишь разницей, что функция значения C, записываемая через указатель, не изменяет параметр Perl, а помещается в список вывода.</target>
        </trans-unit>
        <trans-unit id="e01d4a34408ea1bec61899bb0715159c8fcfc543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Dir&lt;/code&gt; package provides two interfaces to perl's directory reading routines.</source>
          <target state="translated">Пакет &lt;code&gt;IO::Dir&lt;/code&gt; предоставляет два интерфейса для процедур чтения каталогов perl.</target>
        </trans-unit>
        <trans-unit id="2e8c3db24464dee992cbd4fb5389ee4e7af6c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="translated">Пакет &lt;code&gt;IO::Select&lt;/code&gt; реализует объектный подход к вызову функции &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; системы . Он позволяет пользователю видеть, что обрабатывает ввод-вывод, видеть &lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt; , готово к чтению, записи или иметь ожидающее исключение.</target>
        </trans-unit>
        <trans-unit id="d4a23c694ba8531eb134632f2092cafc7861a78d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;select&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b99267c0bd0ea1d7a95c4de6c3170224a12616" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IVdf&lt;/code&gt; will expand to whatever is the correct format for the IVs. Note that the spaces are required around the format in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e9868cf44653a0a473010fe2cd91001e0a676d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt; , to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="translated">Модуль &lt;code&gt;Interpolation&lt;/code&gt; также может творить за вас много волшебства. Вы можете указать имя переменной, в данном случае &lt;code&gt;E&lt;/code&gt; , чтобы настроить связанный хеш, который будет выполнять интерполяцию за вас. Для этого есть несколько других методов.</target>
        </trans-unit>
        <trans-unit id="329ab637f04429657f9fe6aaf5dca20594f33c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt;, to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bc590cafc9b13c0e888463643b3750cf44fd73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitutions; and case-independent regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; локали также предоставляет карту , используемую в транслитерации символов между нижним и прописными буквами. Это влияет на функции отображения регистра - &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; ; интерполяция с отображением регистра с использованием &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; или &lt;code&gt;\U&lt;/code&gt; в строках, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; в двойные кавычки, и заменах s /// ; и сопоставление шаблонов регулярных выражений без учета регистра с использованием модификатора &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc3c541f503e52e8ac4f6d3ffd90d52fc4128eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;fc()&lt;/code&gt;, &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, and &lt;code&gt;ucfirst()&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;s///&lt;/code&gt; substitutions; and case-insensitive regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941219cd505be61ac26ba8728d69370c60e37046" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_NUMERIC&lt;/code&gt; controls the numeric output:</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; управляет цифровым выходом:</target>
        </trans-unit>
        <trans-unit id="412121500ef04a2233556ed3ed8bb5c784494003" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">Параметр &lt;code&gt;LimitOutput&lt;/code&gt; изменяет поведение метода &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; таким образом, чтобы можно было ограничить объем памяти, используемый выходным буфером.</target>
        </trans-unit>
        <trans-unit id="1b18a1d213993f63112fefb5d5804b6552cbf33b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">Параметр &lt;code&gt;LimitOutput&lt;/code&gt; изменяет поведение метода &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; таким образом, чтобы можно было ограничить объем памяти, используемый выходным буфером.</target>
        </trans-unit>
        <trans-unit id="3600b0d3775b442853dade84e908851ee6d60512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option is designed to help with this use-case.</source>
          <target state="translated">Параметр &lt;code&gt;LimitOutput&lt;/code&gt; предназначен для помощи в этом сценарии использования.</target>
        </trans-unit>
        <trans-unit id="4e39cafde8d7c8f339d79044ffb14c41f2b59abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is SOMAXCONN.</source>
          <target state="translated">Параметр &lt;code&gt;Listen&lt;/code&gt; установлен на максимальное количество ожидающих подключений, которые мы можем принять, пока мы не отклоним входящих клиентов. Думайте об этом как об очереди ожидающего вызова для вашего телефона. Модуль Socket нижнего уровня имеет специальный символ для максимального значения системы, которым является SOMAXCONN.</target>
        </trans-unit>
        <trans-unit id="39d8f8a92949aebb617dd074e69f347a559dd1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Country&lt;/code&gt; module provides access to several code sets that can be used for identifying countries, such as those defined in ISO 3166-1.</source>
          <target state="translated">Модуль &lt;code&gt;Locale::Country&lt;/code&gt; предоставляет доступ к нескольким кодовым наборам, которые можно использовать для идентификации стран, например, определенных в ISO 3166-1.</target>
        </trans-unit>
        <trans-unit id="7ce570b70dc3b1217c7829eb357747faae317306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Currency&lt;/code&gt; module provides access to standard codes used for identifying currencies and funds, such as those defined in ISO 4217.</source>
          <target state="translated">Модуль &lt;code&gt;Locale::Currency&lt;/code&gt; обеспечивает доступ к стандартным кодам, используемым для идентификации валют и средств, например, определенным в ISO 4217.</target>
        </trans-unit>
        <trans-unit id="e1ffcce2675347ee9e15ffb62b7a866fc9499f7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Language&lt;/code&gt; module provides access to standard codes used for identifying languages, such as those as defined in ISO 639.</source>
          <target state="translated">Модуль &lt;code&gt;Locale::Language&lt;/code&gt; обеспечивает доступ к стандартным кодам, используемым для идентификации языков, например, как определено в ISO 639.</target>
        </trans-unit>
        <trans-unit id="aa76c519ff8997e91915d966da6aed9450ba1a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Script&lt;/code&gt; module provides access to standards codes used for identifying scripts, such as those defined in ISO 15924.</source>
          <target state="translated">Модуль &lt;code&gt;Locale::Script&lt;/code&gt; обеспечивает доступ к кодам стандартов, используемым для идентификации скриптов, например, определенным в ISO 15924.</target>
        </trans-unit>
        <trans-unit id="e8120d017d19784f5ec18621659dfbf762367c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MGVTBL&lt;/code&gt; has five (or sometimes eight) pointers to the following routine types:</source>
          <target state="translated">&lt;code&gt;MGVTBL&lt;/code&gt; имеет пять (или иногда восемь) указатели на следующих обычных типов:</target>
        </trans-unit>
        <trans-unit id="cb0939f4e09d7100879a1f0cd7a45d518f685d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62960d717ea2191ee6cb352f5b362492a57f4b7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="translated">&lt;code&gt;Math::Trig&lt;/code&gt; решает эту проблему с помощью &lt;code&gt;Math::Complex&lt;/code&gt; пакет , который знает , как обращаться с комплексными числами, см &lt;a href=&quot;complex&quot;&gt;Math :: Complex&lt;/a&gt; для получения дополнительной информации. На практике вам не нужно беспокоиться о получении комплексных чисел в качестве результатов, потому что &lt;code&gt;Math::Complex&lt;/code&gt; заботится о деталях, таких как, например, отображение комплексных чисел. Например:</target>
        </trans-unit>
        <trans-unit id="59d3e5116a50776a62b5e7307aca3591f0689480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">Авторы &lt;code&gt;Moose&lt;/code&gt; надеются, что однажды &lt;code&gt;Moo&lt;/code&gt; можно будет сделать устаревшим, достаточно улучшив &lt;code&gt;Moose&lt;/code&gt; , но на данный момент он представляет собой достойную альтернативу &lt;code&gt;Moose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd61d23b6e3309b14f23bde3328a9b1cfdb75d47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9a3a0a2d0497d18f72b7ad30f16ed602816e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NEXT&lt;/code&gt; module adds a pseudoclass named &lt;code&gt;NEXT&lt;/code&gt; to any program that uses it. If a method &lt;code&gt;m&lt;/code&gt; calls &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt;, the call to &lt;code&gt;m&lt;/code&gt; is redispatched as if the calling method had not originally been found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cda22c66d7ae69cf0c1a687755ef0ea97e644b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NNTP&lt;/code&gt; protocol uses the &lt;code&gt;WILDMAT&lt;/code&gt; format for patterns. The WILDMAT format was first developed by Rich Salz based on the format used in the UNIX &quot;find&quot; command to articulate file names. It was developed to provide a uniform mechanism for matching patterns in the same manner that the UNIX shell matches filenames.</source>
          <target state="translated">Протокол &lt;code&gt;NNTP&lt;/code&gt; использует формат &lt;code&gt;WILDMAT&lt;/code&gt; для шаблонов. Формат WILDMAT был впервые разработан Ричем Зальцем на основе формата, используемого в команде UNIX &amp;laquo;find&amp;raquo; для составления имен файлов. Он был разработан для обеспечения единого механизма сопоставления шаблонов таким же образом, как оболочка UNIX сопоставляет имена файлов.</target>
        </trans-unit>
        <trans-unit id="8856a9c3b92894fbca75a7c6a84e03f49c7d82b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Net::FTP&lt;/code&gt; module provides two low-level methods called &lt;code&gt;stor&lt;/code&gt; and &lt;code&gt;retr&lt;/code&gt; that both return filehandles. These filehandles can used with the &lt;code&gt;IO::Compress/Uncompress&lt;/code&gt; modules to compress or uncompress files read from or written to an FTP Server on the fly, without having to create a temporary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812543816e7e36906e0a41744e1b881bd6061a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt; ) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="translated">Функция &lt;code&gt;O::import&lt;/code&gt; загружает соответствующий модуль &lt;code&gt;B::Backend&lt;/code&gt; и вызывает его функцию &lt;code&gt;compile&lt;/code&gt; , передавая ему ОПЦИИ. Ожидается, что эта функция вернет дополнительную ссылку, которую мы назовем CALLBACK. Затем включается флаг &amp;laquo;только компиляция&amp;raquo; (эквивалент параметра командной строки &lt;code&gt;-c&lt;/code&gt; ) и регистрируется блок CHECK, который вызывает CALLBACK. Таким образом, основная программа Perl, упомянутая в командной строке, считывается, анализируется и компилируется во внутреннюю форму синтаксического дерева. Поскольку установлен флаг &lt;code&gt;-c&lt;/code&gt; , программа не запускается (за исключением, конечно, блоков BEGIN), но вызывается функция CALLBACK, зарегистрированная серверной частью компилятора.</target>
        </trans-unit>
        <trans-unit id="d7e78f61b2ef3885efb7f8bb2d5b2723a7d2f5bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt;) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d373b71890ff94863d227c7cfce5d1d697b7746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OP *&lt;/code&gt; is op_free()ed at the end of</source>
          <target state="translated">&lt;code&gt;OP *&lt;/code&gt; является op_free () ред в конце</target>
        </trans-unit>
        <trans-unit id="998cf5d3020bb78a9ba1d3cad328d90e354a7767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="translated">Параметр &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; отличается от параметров &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; только тем, что начальное значение параметра Perl не читается (и не передается функции C, которая вместо этого получает некоторый мусор). Например, та же функция C, что и выше, может взаимодействовать как</target>
        </trans-unit>
        <trans-unit id="77d530437d7fdd465ebf5f4d28d1ba3ab2ce9989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0628c399d26c3378a27108a14e1ac2344b8aefb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt; . The full prototype is as follows:</source>
          <target state="translated">Метод &lt;code&gt;Open()&lt;/code&gt; имеет множество аргументов, поскольку он сочетает в себе функции perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;PerlIO_open&lt;/code&gt; , perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;PerlIO_fdopen&lt;/code&gt; и &lt;code&gt;PerlIO_reopen&lt;/code&gt; . Полный прототип выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a364ca34d8039b509a216c6b70daa6a333bd164c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt;, perl's &lt;code&gt;sysopen&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt;. The full prototype is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b50db457121e66e0a351ce78b3a957dc8ab0fb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL5DB&lt;/code&gt; environment variable can be used to define a debugger. For example, the minimal &quot;working&quot; debugger (it actually doesn't do anything) consists of one line:</source>
          <target state="translated">&lt;code&gt;PERL5DB&lt;/code&gt; переменная среды может быть использована для определения отладчика. Например, минимальный &amp;laquo;рабочий&amp;raquo; отладчик (на самом деле ничего не делает) состоит из одной строки:</target>
        </trans-unit>
        <trans-unit id="d2bc99a442d5c0b29501891792cdc1fff80da05a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; and &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic types are defined specifically for use by extensions and will not be used by perl itself. Extensions can use &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic to 'attach' private information to variables (typically objects). This is especially useful because there is no way for normal perl code to corrupt this private information (unlike using extra elements of a hash object).</source>
          <target state="translated">В &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; и &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; типы магии определены специально для использования расширений и не будет использоваться сам Perl. Расширения могут использовать магию &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; для &amp;laquo;прикрепления&amp;raquo; частной информации к переменным (обычно объектам). Это особенно полезно, поскольку обычный код Perl не может повредить эту личную информацию (в отличие от использования дополнительных элементов хеш-объекта).</target>
        </trans-unit>
        <trans-unit id="8a6e94721b04748465ec2688a94fd6f249730156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; interface for hashes</source>
          <target state="translated">Интерфейс &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; для хешей</target>
        </trans-unit>
        <trans-unit id="bda510e29f461a0c3d4c9c5037a48e14d8e62436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; flag is always treated as being set for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc956792cc9e74cf6710a9899c98dc65f9e9723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POPi&lt;/code&gt; macro is used here to pop the return value from the stack. In this case we wanted an integer, so &lt;code&gt;POPi&lt;/code&gt; was used.</source>
          <target state="translated">&lt;code&gt;POPi&lt;/code&gt; макрос используется здесь , чтобы совать возвращаемое значение из стека. В данном случае нам нужно целое число, поэтому &lt;code&gt;POPi&lt;/code&gt; использовали POPi .</target>
        </trans-unit>
        <trans-unit id="441004a0b6f6f50d94cdd26e8efdb4418e11d7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::getattr&lt;/code&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;code&gt;Term::ReadKey&lt;/code&gt; module from your nearest &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; site.</source>
          <target state="translated">Функция &lt;code&gt;POSIX::getattr&lt;/code&gt; может сделать это более переносимо в системах, претендующих на соответствие POSIX. См. Также модуль &lt;code&gt;Term::ReadKey&lt;/code&gt; на ближайшем к вам сайте &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30a4c7c0312ad4ebafbfc4ecde82010a30e5b1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;.)</source>
          <target state="translated">Функция &lt;code&gt;POSIX::localeconv()&lt;/code&gt; позволяет вам получить подробные сведения о зависящей от локали информации о числовом форматировании, заданной текущими базовыми языковыми стандартами &lt;code&gt;LC_NUMERIC&lt;/code&gt; и &lt;code&gt;LC_MONETARY&lt;/code&gt; (независимо от того, вызывается ли из области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; или нет). (Если вам просто нужно имя текущей локали для определенной категории, используйте &lt;code&gt;POSIX::setlocale()&lt;/code&gt; с одним параметром - см. &lt;a href=&quot;#The-setlocale-function&quot;&gt;Функция setlocale&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="2b43e9db384d2d0a57a2a9c77f122fdc5d00196d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;use locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;&quot;The setlocale function&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f685f77eea7b515d4045c7a67182dbbc7755a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section</source>
          <target state="translated">&lt;code&gt;PUSHMARK&lt;/code&gt; макрос говорит Perl , чтобы сделать мысленную пометку текущего указателя стека. Даже если вы не передаете никаких параметров (как в примере, показанном в разделе</target>
        </trans-unit>
        <trans-unit id="163850ef5b169ef12088a9930a0f3972d7c61a0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section &lt;a href=&quot;#No-Parameters%2C-Nothing-Returned&quot;&gt;&quot;No Parameters, Nothing Returned&quot;&lt;/a&gt;) you must still call the &lt;code&gt;PUSHMARK&lt;/code&gt; macro before you can call any of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07465ad7c738ebeee81550400552ecd67a850bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUTBACK&lt;/code&gt; macro sets the global copy of the stack pointer to be the same as our local copy. If we didn't do this,</source>
          <target state="translated">&lt;code&gt;PUTBACK&lt;/code&gt; макрос устанавливает глобальный экземпляр указателя стека , чтобы быть таким же , как наша локальная копия. Если бы мы этого не сделали,</target>
        </trans-unit>
        <trans-unit id="8baae86fdb4cb4e701226e31c2071774be7ff5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PeerAddr&lt;/code&gt; can be a hostname or the IP-address on the &quot;xx.xx.xx.xx&quot; form. The &lt;code&gt;PeerPort&lt;/code&gt; can be a number or a symbolic service name. The service name might be followed by a number in parenthesis which is used if the service is not known by the system. The &lt;code&gt;PeerPort&lt;/code&gt; specification can also be embedded in the &lt;code&gt;PeerAddr&lt;/code&gt; by preceding it with a &quot;:&quot;.</source>
          <target state="translated">&lt;code&gt;PeerAddr&lt;/code&gt; может быть имя хоста или IP-адрес на &amp;laquo;xx.xx.xx.xx&amp;raquo; форме. &lt;code&gt;PeerPort&lt;/code&gt; может быть числом или символическое имя службы. За именем службы может следовать номер в скобках, который используется, если служба не известна системе. Спецификацию &lt;code&gt;PeerPort&lt;/code&gt; также можно встроить в &lt;code&gt;PeerAddr&lt;/code&gt; ,поставив перед ним &quot;:&quot;.</target>
        </trans-unit>
        <trans-unit id="354584d7434f3b3042f7e803f86eee0735ecb30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt; . This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt; . It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="translated">&lt;code&gt;PerlInterpreter*&lt;/code&gt; строится с помощью &lt;code&gt;perl_construct&lt;/code&gt; . Это значение в основном используется для полноты и для использования через базовую переменную C &lt;code&gt;PL_phase&lt;/code&gt; . Код Perl не может быть выполнен до тех пор, пока построение интерпретатора не будет завершено.</target>
        </trans-unit>
        <trans-unit id="98058838817e528c0fbf9fe55b4c498c1c669b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt;. This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt;. It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619b9e421badf230488baf0eee0a8b4f64f3d92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator. The built-in &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="translated">В &lt;code&gt;REGlob&lt;/code&gt; выше примере REGlob не реализована вся поддержка, необходимая для полного переопределения оператора &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; в Perl . Встроенный &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; ведет себя по-разному в зависимости от того, появляется ли он в скалярном контексте или в контексте списка, но наш &lt;code&gt;REGlob&lt;/code&gt; - нет. Действительно, многие встроенные Perl имеют такое контекстно-зависимое поведение, и оно должно быть адекватно поддержано правильно написанным переопределением. Чтобы получить полнофункциональный пример переопределения &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; , изучите реализацию &lt;code&gt;File::DosGlob&lt;/code&gt; в стандартной библиотеке.</target>
        </trans-unit>
        <trans-unit id="2793461193bbb08faabc42ded2214d9447a84314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;glob&lt;/code&gt; operator. The built-in &lt;code&gt;glob&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;glob&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541482224c51c4cb7a6cd08e437f820560b203ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Envelope&lt;/code&gt; parameters are used for DSN (Delivery Status Notification).</source>
          <target state="translated">Параметры &lt;code&gt;Return&lt;/code&gt; и &lt;code&gt;Envelope&lt;/code&gt; используются для уведомления о состоянии доставки (DSN).</target>
        </trans-unit>
        <trans-unit id="0fb74752f70cdbcc4b24e6fe1a79d1c71cc57bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reuse&lt;/code&gt; parameter is needed so that we restart our server manually without waiting a few minutes to allow system buffers to clear out.</source>
          <target state="translated">Параметр &lt;code&gt;Reuse&lt;/code&gt; необходим, чтобы мы перезапускали наш сервер вручную, не дожидаясь нескольких минут, пока системные буферы очистятся.</target>
        </trans-unit>
        <trans-unit id="6ef497f2f64147d9fc11b64ad7836f6a54270b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">Сигнал &lt;code&gt;SIGALRM&lt;/code&gt; отправляется через указанное количество секунд. Реализовано с помощью &lt;code&gt;setitimer()&lt;/code&gt; если доступно, и &lt;code&gt;ualarm()&lt;/code&gt; если нет. &lt;code&gt;$interval_floating_seconds&lt;/code&gt; аргумент является необязательным и будет равен нулю , если не указано, что приводит к &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; -как поведение. Эту функцию можно импортировать, что приведет к хорошей замене &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; поставляемого с perl, см. &lt;a href=&quot;#EXAMPLES&quot;&gt;ПРИМЕРЫ&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="9c45565a357a5307165173264e504c30b567da1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm()&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;alarm&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739f23e9e223585aacd76fc17b10f95586c4f592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SSL_options&lt;/code&gt; attribute could also be used for such things as providing a client certificate for authentication to a server or controlling the choice of cipher used for the SSL connection. See &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb26b9a2abefa95e1228823d5039552d2541e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER::&lt;/code&gt; bit tells Perl to look for the &lt;code&gt;print_info()&lt;/code&gt; in the &lt;code&gt;File::MP3&lt;/code&gt; class's inheritance chain. When it finds the parent class that implements this method, the method is called.</source>
          <target state="translated">&lt;code&gt;SUPER::&lt;/code&gt; немного говорит Perl искать &lt;code&gt;print_info()&lt;/code&gt; в &lt;code&gt;File::MP3&lt;/code&gt; наследственной цепи класса. Когда он находит родительский класс, реализующий этот метод, вызывается метод.</target>
        </trans-unit>
        <trans-unit id="3f5b4cff6fbfe1c281604ef06c021cd92e1eaa6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; modifier can</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; модификатор может</target>
        </trans-unit>
        <trans-unit id="371b5ebfc9cdf0db9a0a55eae240989e954cb726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class is resolved from the package where the call is made. It is</source>
          <target state="translated">&lt;code&gt;SUPER&lt;/code&gt; псевдо-класс разрешен из пакета , в котором сделан звонок. это</target>
        </trans-unit>
        <trans-unit id="00f36328e65732130767ca69dab4491f0365d24c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class that was described earlier is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7a3a508d1d6570aa1ef0df5ea57827a95bbfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SV_FORCE_UTF8_UPGRADE&lt;/code&gt; flag is now ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9315ac1b0e03b32c4d0f032e1290883c21a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Script_Extensions&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="translated">В &lt;code&gt;Script&lt;/code&gt; или &lt;code&gt;Script_Extensions&lt;/code&gt; свойства могут быть те , которые вы хотите использовать при обработке естественного языка; &lt;code&gt;Block&lt;/code&gt; свойство иногда может быть полезно при работе с гайками и болтами Unicode.</target>
        </trans-unit>
        <trans-unit id="0c768e6f5d4be03a1a932a1028083efcf53f3ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; or &lt;code&gt;Script&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2c75703b39600771c0a8ce5df27de06d22689b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;) is used as the basis for this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daac5f890ff04f28fabf32094505977d698c4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</source>
          <target state="translated">&lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; предикат скажет вам , был ли использован сетевой порядок в последнем магазине или получить работу. Если вы не знаете, как этим пользоваться, просто забудьте об этом.</target>
        </trans-unit>
        <trans-unit id="4f2453d7aa3fb23473e60b4a26a3d26672cf6341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TODO:&lt;/code&gt; and &lt;code&gt;$TODO&lt;/code&gt; syntax is generally pretty good about figuring out whether or not we're in a TODO test. However, often we find that this is not possible to determine (such as when we want to use &lt;code&gt;$TODO&lt;/code&gt; but the tests are being executed in other packages which can't be inferred beforehand).</source>
          <target state="translated">&lt;code&gt;TODO:&lt;/code&gt; и &lt;code&gt;$TODO&lt;/code&gt; синтаксис , как правило , очень хорошо о выяснить , действительно ли вы нас в тесте TODO. Однако часто мы обнаруживаем, что это невозможно определить (например, когда мы хотим использовать &lt;code&gt;$TODO&lt;/code&gt; но тесты выполняются в других пакетах, что не может быть сделано заранее).</target>
        </trans-unit>
        <trans-unit id="316a59c6c105ba5a65d5de6abf6871022622f157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TO_JSON&lt;/code&gt; method may safely call die if it wants. If &lt;code&gt;TO_JSON&lt;/code&gt; returns other blessed objects, those will be handled in the same way. &lt;code&gt;TO_JSON&lt;/code&gt; must take care of not causing an endless recursion cycle (== crash) in this case. The name of &lt;code&gt;TO_JSON&lt;/code&gt; was chosen because other methods called by the Perl core (== not by the user of the object) are usually in upper case letters and to avoid collisions with any &lt;code&gt;to_json&lt;/code&gt; function or method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94063ef306bbe0bc69a744042850751f57d8165a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; macros are available for situations where using them would clarify intent. (But they always just mean the same as the integers 1 and 0 regardless, so using them isn't compulsory.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca16843b685fa84c8313aca285e376c5597ef322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEMAP&lt;/code&gt; section should contain one pair of C type and XS type per line as follows. An example from the core typemap file:</source>
          <target state="translated">Раздел &lt;code&gt;TYPEMAP&lt;/code&gt; должен содержать одну пару типов C и XS в каждой строке, как показано ниже. Пример из основного файла карты типов:</target>
        </trans-unit>
        <trans-unit id="ea8183d7125676dfc1989dcabf04b34c38b4f669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; function returns a thread object that represents the thread making the &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; call.</source>
          <target state="translated">Функция &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; возвращает объект потока, который представляет поток, &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; вызов Thread-&amp;gt; self .</target>
        </trans-unit>
        <trans-unit id="5f72cf2b372d3d426c2948d6098fd6cd1afad651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module provides multithreading support for Perl.</source>
          <target state="translated">Модуль &lt;code&gt;Thread&lt;/code&gt; обеспечивает поддержку многопоточности для Perl.</target>
        </trans-unit>
        <trans-unit id="7fe8315550458ad4289f70c4a27bed2792ae2d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module served as the frontend to the old-style thread model, called</source>
          <target state="translated">Модуль &lt;code&gt;Thread&lt;/code&gt; служил интерфейсом к старой модели потоков, называемой</target>
        </trans-unit>
        <trans-unit id="ab5cb47a9617fcafbcf6221a375828cf9de09e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="translated">Модуль &lt;code&gt;Time::HiRes&lt;/code&gt; реализует интерфейс Perl для системных вызовов &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; и &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; , другими словами, времени и таймеров с высоким разрешением. См. Раздел &lt;a href=&quot;#EXAMPLES&quot;&gt;ПРИМЕРЫ&lt;/a&gt; ниже и тестовые сценарии для использования; см. документацию к вашей системе для описания основных &lt;code&gt;nanosleep&lt;/code&gt; или &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; и &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="840bb1616acfc5f4c8448fa1adbdaac8f85745ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;nanosleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db031bd2869c09fc69e58469a4b3b15d15dfaaa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag overrides the behavior when a non-allowed (by other flags) malformation is found. If this flag is set, the routine assumes that the caller will raise a warning, and this function will silently just set &lt;code&gt;retlen&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; (cast to &lt;code&gt;STRLEN&lt;/code&gt;) and return zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adde2e15da0476d4564064bbc384c4ca957b8d40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VERSION&lt;/code&gt; method returns the version number of the class (package).</source>
          <target state="translated">Метод &lt;code&gt;VERSION&lt;/code&gt; возвращает номер версии класса (пакета).</target>
        </trans-unit>
        <trans-unit id="d8baa2e2f7c0fd0a2f0c9455f11a42eb910290cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Win32::*&lt;/code&gt; модули в &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="365cfe3394d31517ee04bbcb7fdcf61281c556f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c47ba9b1855f9e0e157ed96c1dac4112ef8de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; sequence is supposed to be empty.</source>
          <target state="translated">Последовательность &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; должна быть пустой.</target>
        </trans-unit>
        <trans-unit id="4f3af2152fe286b612ed068b47a818a0a9d55853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5C1-Instead-of-%241&quot;&gt;&quot;Warning on \1 Instead of $1&quot;&lt;/a&gt; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c164b87544e368a57522144bf31b4093cb008b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Warning on \1 Instead of $1&lt;/a&gt; below for details.</source>
          <target state="translated">&lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; обозначения также работает при определенных обстоятельствах за пределами рисунка. Подробнее см. &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Предупреждение о \ 1 вместо $ 1&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="c49d42a1bfbc0b22f583d2817d2ce107934b83b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\C&lt;/code&gt; is unsupported in lookbehind, because the already treacherous definition of &lt;code&gt;\C&lt;/code&gt; would become even more so when going backwards.</source>
          <target state="translated">&lt;code&gt;\C&lt;/code&gt; не поддерживается в ' назад, потому что уже коварный определение &lt;code&gt;\C&lt;/code&gt; станет еще более, когда идет в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="b97997ed1726a2dd70e1e88046ee54105827a12b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt; -like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as an lvalue: see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Repeated Patterns Matching a Zero-length Substring&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="translated">Утверждение &lt;code&gt;\G&lt;/code&gt; может использоваться для цепочки глобальных совпадений (с использованием &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; ), как описано в &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;разделе Операторы, подобные кавычкам Regexp, в perlop&lt;/a&gt; . Это также полезно при написании сканеров, подобных &lt;code&gt;lex&lt;/code&gt; , когда у вас есть несколько шаблонов, которые вы хотите сопоставить с последовательными подстроками вашей строки; см. предыдущую ссылку. Фактическое местоположение, в котором будет соответствовать &lt;code&gt;\G&lt;/code&gt; , также можно изменить, используя &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; в качестве lvalue: см. &lt;a href=&quot;functions/pos&quot;&gt;Pos&lt;/a&gt; . Обратите внимание, что правило для совпадений нулевой длины (см. &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Повторяющиеся шаблоны,&lt;/a&gt; совпадающие с подстрокой нулевой длины ) несколько изменено в том, что содержимое слева от &lt;code&gt;\G&lt;/code&gt; не учитываются при определении продолжительности матча. Таким образом, следующее не будет совпадать вечно:</target>
        </trans-unit>
        <trans-unit id="e1ff47fb2c42daca3a8b3c8a3d0395f0593d6c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;m//g&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt;-like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;pos()&lt;/code&gt; as an lvalue: see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;&quot;Repeated Patterns Matching a Zero-length Substring&quot;&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9300fc0425608314652e19b5173bc5fd7efd18c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N&lt;/code&gt; character class, not to be confused with the named character sequence &lt;code&gt;\N{NAME}&lt;/code&gt; , denotes any non-newline character in a regular expression.</source>
          <target state="translated">Класс символов &lt;code&gt;\N&lt;/code&gt; , не путать с именованной последовательностью символов &lt;code&gt;\N{NAME}&lt;/code&gt; , обозначает любой символ не новой строки в регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="6fc55e5a124a8f9ba1fb9b74d5a25063c2e050b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N{...}&lt;/code&gt; construct explicitly refers to a Unicode code point, even if it is one that is also in ASCII. Therefore the string containing it must be Unicode.</source>
          <target state="translated">Конструкция &lt;code&gt;\N{...}&lt;/code&gt; явно ссылается на кодовую точку Unicode, даже если она также находится в ASCII. Следовательно, строка, содержащая его, должна быть Unicode.</target>
        </trans-unit>
        <trans-unit id="7f0273d79d748bac786c369cab505ed24fe2cfda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d&lt;/code&gt; gets rid of needing to anchor the pattern, since it forces the result to only match &lt;code&gt;[0-9]&lt;/code&gt;, and the &lt;code&gt;[0-5]&lt;/code&gt; further restricts it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52316cb23d6228b5040f834369875ce8a00e4e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</source>
          <target state="translated">&lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; аббревиатуры можно использовать как внутри , так и вне классов символов в квадратных скобках. Вот некоторые из них:</target>
        </trans-unit>
        <trans-unit id="dc3bb1079451a53e38a66554502d10e12737dc82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of character classes. Here are some in use:</source>
          <target state="translated">&lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; аббревиатуры можно использовать как внутри , так и вне классов символов. Вот некоторые из них:</target>
        </trans-unit>
        <trans-unit id="0f2c8f2ff00b285673d694a7e44211cdef772f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., and this notation is still accepted (and likely always will be). But it leads to some ambiguities if there are more than 9 capture groups, as &lt;code&gt;\10&lt;/code&gt; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII). Perl resolves this ambiguity by interpreting &lt;code&gt;\10&lt;/code&gt; as a backreference only if at least 10 left parentheses have opened before it. Likewise &lt;code&gt;\11&lt;/code&gt; is a backreference only if at least 11 left parentheses have opened before it. And so on. &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as backreferences. There are several examples below that illustrate these perils. You can avoid the ambiguity by always using &lt;code&gt;\g{}&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; if you mean capturing groups; and for octal constants always using &lt;code&gt;\o{}&lt;/code&gt; , or for &lt;code&gt;\077&lt;/code&gt; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.</source>
          <target state="translated">&lt;code&gt;\g&lt;/code&gt; и &lt;code&gt;\k&lt;/code&gt; нотации были введены в Perl 5.10.0. До этого не было ни названных, ни пронумерованных групп отлова. Абсолютные пронумерованные группы упоминались с использованием &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; и т. Д., И это обозначение все еще принимается (и, вероятно, всегда будет). Но это приводит к некоторым двусмысленностям, если существует более 9 групп захвата, поскольку &lt;code&gt;\10&lt;/code&gt; может означать либо десятую группу захвата, либо символ, порядковый номер которого в восьмеричном формате равен 010 (возврат в ASCII). Perl разрешает эту двусмысленность, интерпретируя &lt;code&gt;\10&lt;/code&gt; как обратную ссылку, только если перед ним открылось не менее 10 левых скобок. Аналогично &lt;code&gt;\11&lt;/code&gt; является обратной ссылкой, только если перед ней открылось не менее 11 левых скобок. И так далее. &lt;code&gt;\1&lt;/code&gt; по &lt;code&gt;\9&lt;/code&gt; всегда интерпретируются как обратные ссылки. Ниже приведены несколько примеров, иллюстрирующих эти опасности. Вы можете избежать двусмысленности, всегда используя &lt;code&gt;\g{}&lt;/code&gt; или &lt;code&gt;\g&lt;/code&gt; если вы имеете в виду захват групп; а для восьмеричных констант всегда используется &lt;code&gt;\o{}&lt;/code&gt; , или для &lt;code&gt;\077&lt;/code&gt; и ниже - 3 цифры, дополненные ведущими нулями, поскольку начальный ноль подразумевает восьмеричную константу.</target>
        </trans-unit>
        <trans-unit id="15b6b1b5929104c2b72fb96a6e633ae2051f4ffd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517d2abbf8670e3eaf5c272713d99b8bf67cd7d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">Форма &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; может быть эквивалентно записана как &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; что позволяет избежать неоднозначности при построении регулярного выражения путем объединения более коротких строк. В противном случае, если бы у вас было регулярное выражение &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;$a&lt;/code&gt; содержало &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , а &lt;code&gt;$b&lt;/code&gt; содержало &lt;code&gt;&quot;37&quot;&lt;/code&gt; , вы бы получили &lt;code&gt;/\g137/&lt;/code&gt; что, вероятно, не то, что вы планировали.</target>
        </trans-unit>
        <trans-unit id="03256d4028754b69d229d57c7593954c93901408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1162dcf378fe4b180c42e9c8606223aea754f52f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__DATA__&lt;/code&gt; token tells the perl compiler that the perl code for compilation is finished. Everything after the &lt;code&gt;__DATA__&lt;/code&gt; token is available for reading via the filehandle FOOBAR::DATA, where FOOBAR is the name of the current package when the &lt;code&gt;__DATA__&lt;/code&gt; token is reached. This works just the same as &lt;code&gt;__END__&lt;/code&gt; does in package 'main', but for other modules data after &lt;code&gt;__END__&lt;/code&gt; is not automatically retrievable, whereas data after &lt;code&gt;__DATA__&lt;/code&gt; is. The &lt;code&gt;__DATA__&lt;/code&gt; token is not recognized in versions of perl prior to 5.001m.</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; маркер сообщает PERL компилятор , что код Perl для компиляции закончен. Все, что находится после токена &lt;code&gt;__DATA__&lt;/code&gt; , доступно для чтения через дескриптор файла FOOBAR :: DATA, где FOOBAR - это имя текущего пакета при &lt;code&gt;__DATA__&lt;/code&gt; токена __DATA__ . Это работает точно так же, как &lt;code&gt;__END__&lt;/code&gt; в пакете main, но для других модулей данные после &lt;code&gt;__END__&lt;/code&gt; не могут быть получены автоматически, тогда как данные после &lt;code&gt;__DATA__&lt;/code&gt; доступны . &lt;code&gt;__DATA__&lt;/code&gt; маркер не распознается в версиях PERL до 5.001m.</target>
        </trans-unit>
        <trans-unit id="aaae759fadc0ccc32d523d9d6a0dc772ae2d9269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; forms are automatically used, starting in Perl 5.28, if you compile your code, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e846812293eaeddc68b23ea744d79168534a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="translated">В &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;Z&lt;/code&gt; типов проглатывают только одно значение, но упаковать его в виде строки подсчета длины, заполнение нулями или пробелами в случае необходимости. При распаковке, полоски конечные пробелы и нули, &lt;code&gt;Z&lt;/code&gt; полосок все после первой нулевой, а &lt;code&gt;a&lt;/code&gt; возвращает данные без зачистки вообще. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a1b3cf59097aca7e4188f4992a603a0b5d6ae0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893b37c14397452b4b42e37cd794a8b9b2d1eb65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alarm()&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cca45db774b8d4bbc26743f5dae5512cca0753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt; -like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt; . We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;antlers&lt;/code&gt; флаг импорта говорит &lt;code&gt;Class::Accessor&lt;/code&gt; , что вы хотите , чтобы определить свои атрибуты , используя &lt;code&gt;Moose&lt;/code&gt; -как синтаксиса. Единственный параметр, который вы можете передать &lt;code&gt;has&lt;/code&gt; - &lt;code&gt;is&lt;/code&gt; . Мы рекомендуем вам использовать этот синтаксис, подобный Moose, если вы выбираете &lt;code&gt;Class::Accessor&lt;/code&gt; поскольку это означает, что у вас будет более плавный путь обновления, если вы позже решите перейти на &lt;code&gt;Moose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96ee1d0dc9d201f79ce6ef0d53eb7c5448972089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt;-like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt;. We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d4c5418acb92744951617bccd4c2bb4e907086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as_number()&lt;/code&gt; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</source>
          <target state="translated">Функция &lt;code&gt;as_number()&lt;/code&gt; возвращает BigInt из Math :: BigFloat. В качестве режима округления используется trunc, чтобы сделать его эквивалентным:</target>
        </trans-unit>
        <trans-unit id="a93f0f0ee3776b1d1340911a8e79d371cb0d5ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;authors&lt;/code&gt; and &lt;code&gt;licenses&lt;/code&gt; methods may also be called as &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;license&lt;/code&gt;, respectively, to match the field name in the distmeta structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4be85862bcecd6790751ef47534ab240cde4eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma has</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; прагма имеет</target>
        </trans-unit>
        <trans-unit id="92907be6274b88924410c3eb7108af17c084f529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma provides a convenient way to replace functions that normally return false on failure with equivalents that throw an exception on failure.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; прагма обеспечивает удобный способ замены функции , которые обычно возвращают в случае возникновения ошибки с эквивалентами , которые бросают исключение на провал.</target>
        </trans-unit>
        <trans-unit id="3ccf77f6494c4bb94f71a5890c3e377c22247ef4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt; . It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="translated">Интерфейс &lt;code&gt;autosplit&lt;/code&gt; разбивает указанный файл на иерархию с корнем в каталоге &lt;code&gt;$dir&lt;/code&gt; . Он создает каталоги по мере необходимости, чтобы отразить иерархию классов, и создает файл</target>
        </trans-unit>
        <trans-unit id="9ec1a56ade0e6bb491c622b2d56bc77a622eb46d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt;. It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc73dbc80868b5e2537b36abd82d968f2ba4c751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit_lib_modules&lt;/code&gt; form is used in the building of perl. It takes as input a list of files (modules) that are assumed to reside in a directory &lt;b&gt;lib&lt;/b&gt; relative to the current directory. Each file is sent to the autosplitter one at a time, to be split into the directory &lt;b&gt;lib/auto&lt;/b&gt;.</source>
          <target state="translated">Форма &lt;code&gt;autosplit_lib_modules&lt;/code&gt; используется при построении perl. В качестве входных данных он принимает список файлов (модулей), которые, как предполагается, находятся в каталоге &lt;b&gt;lib&lt;/b&gt; относительно текущего каталога. Каждый файл по одному отправляется в автораспределитель для разделения в каталог &lt;b&gt;lib / auto&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="423004d21ce960dd9509db30e9f26d66964e12d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autotie&lt;/code&gt; mechanism supports this too. The following code:</source>
          <target state="translated">Механизм &lt;code&gt;autotie&lt;/code&gt; это тоже поддерживает. Следующий код:</target>
        </trans-unit>
        <trans-unit id="eadb034339c34e003fe891167b8ebaef4be23657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_clear&lt;/code&gt; function deletes all the elements in the AV* array, but does not actually delete the array itself. The &lt;code&gt;av_undef&lt;/code&gt; function will delete all the elements in the array plus the array itself. The &lt;code&gt;av_extend&lt;/code&gt; function extends the array so that it contains at least &lt;code&gt;key+1&lt;/code&gt; elements. If &lt;code&gt;key+1&lt;/code&gt; is less than the currently allocated length of the array, then nothing is done.</source>
          <target state="translated">Функция &lt;code&gt;av_clear&lt;/code&gt; удаляет все элементы в массиве AV *, но не удаляет сам массив. Функция &lt;code&gt;av_undef&lt;/code&gt; удалит все элементы в массиве, а также сам массив. Функция &lt;code&gt;av_extend&lt;/code&gt; расширяет массив так, чтобы он содержал как минимум элементы &lt;code&gt;key+1&lt;/code&gt; . Если &lt;code&gt;key+1&lt;/code&gt; меньше текущей выделенной длины массива, ничего не делается.</target>
        </trans-unit>
        <trans-unit id="d6bd36bbe209d0e332f324c88cb8fab5da451e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt; . It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="translated">Функция &lt;code&gt;av_store&lt;/code&gt; , когда ей задан аргумент связанного массива, просто копирует магию массива в значение, которое нужно &amp;laquo;сохранить&amp;raquo;, используя &lt;code&gt;mg_copy&lt;/code&gt; . Он также может возвращать NULL, указывая на то, что значение на самом деле не нужно хранить в массиве. [MAYCHANGE] После вызова &lt;code&gt;av_store&lt;/code&gt; в связанном массиве вызывающей стороне обычно требуется вызвать &lt;code&gt;mg_set(val)&lt;/code&gt; чтобы фактически вызвать метод STORE уровня perl для объекта TIEARRAY. Если &lt;code&gt;av_store&lt;/code&gt; действительно вернул NULL, вызов &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; также обычно необходим, чтобы избежать утечки памяти. [/МОЖЕТ ПОМЕНЯТЬСЯ]</target>
        </trans-unit>
        <trans-unit id="e12306e741c00686916bfa82246266097410a872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt;. It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bf6421125301461c635d2914e7cd34219ce4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt; , but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt; , and does not increment the reference count of &lt;code&gt;val&lt;/code&gt; . Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt; 's, not &lt;code&gt;SV*&lt;/code&gt; 's as their return value.</source>
          <target state="translated">Функция &lt;code&gt;av_top_index&lt;/code&gt; возвращает наивысшее значение индекса в массиве (точно так же, как массив $ # в Perl). Если массив пуст, возвращается -1. Функция &lt;code&gt;av_fetch&lt;/code&gt; возвращает значение в индексном &lt;code&gt;key&lt;/code&gt; , но если &lt;code&gt;lval&lt;/code&gt; не равно нулю, тогда &lt;code&gt;av_fetch&lt;/code&gt; сохранит значение undef в этом индексе. Функция &lt;code&gt;av_store&lt;/code&gt; сохраняет значение &lt;code&gt;val&lt;/code&gt; в индексном &lt;code&gt;key&lt;/code&gt; и не увеличивает счетчик ссылок &lt;code&gt;val&lt;/code&gt; . Таким образом, вызывающая &lt;code&gt;av_store&lt;/code&gt; несет ответственность за это, и если av_store возвращает NULL, вызывающей стороне придется уменьшить счетчик ссылок, чтобы избежать утечки памяти. Обратите внимание, что &lt;code&gt;av_fetch&lt;/code&gt; и &lt;code&gt;av_store&lt;/code&gt; оба возвращают &lt;code&gt;SV**&lt;/code&gt; , а не &lt;code&gt;SV*&lt;/code&gt; в качестве возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="b720f9a7cf39478f335b0b67c7ecec4e7dd453ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt;, but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt;, and does not increment the reference count of &lt;code&gt;val&lt;/code&gt;. Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt;'s, not &lt;code&gt;SV*&lt;/code&gt;'s as their return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b7a8fbb40ab78219d70980fb393c043d50ef45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; argument specifies the local_addr to bind to. By specifying a bind argument you don't need the bind method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be24d4311997148f32f98999c298c4120e52577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; function can be called on an opened handle to push additional layers onto the stack, which may also modify the existing layers. &lt;code&gt;binmode&lt;/code&gt; called with no layers will remove or unset any existing layers which transform the byte stream, making the handle suitable for binary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185e8e007341d198fca87c48c9798b7fe0dfa929" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;binmode&lt;/code&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e501abc26cf1405f0402c343ec30915264f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords from C become in Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ключевые слова из C становятся в Perl в &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; и в &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , соответственно. В отличие от C, они делают</target>
        </trans-unit>
        <trans-unit id="cf097e70ce7b8cc145798b0019e84f65b1044b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; keywords from C become in Perl &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787c128b8b97671abe15918465f291ec006979e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffered&lt;/code&gt; attribute of the &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event will be set to the value of this flag. This means any formatter, listener, etc which looks at the event will know if it was buffered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1750aab93908ada1ee29e1880f7061b67617e505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacheout&lt;/code&gt; function will make sure that there's a filehandle open for reading or writing available as the pathname you give it. It automatically closes and re-opens files if you exceed your system's maximum number of file descriptors, or the suggested maximum</source>
          <target state="translated">Функция &lt;code&gt;cacheout&lt;/code&gt; гарантирует, что дескриптор файла, открытый для чтения или записи, доступен в качестве пути, который вы ему даете. Он автоматически закрывает и повторно открывает файлы, если вы превысите максимальное количество файловых дескрипторов в вашей системе или предложенный максимум.</target>
        </trans-unit>
        <trans-unit id="2c5778ca552de672cec71f94fb24332cb951e6b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt; . This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Метод &lt;code&gt;can&lt;/code&gt; проверяет, есть ли у класса или объекта, для которого он был вызван, метод с именем &lt;code&gt;$method&lt;/code&gt; . Это проверяет наличие метода в классе и всех его родителей. Если метод существует, то возвращается ссылка на подпрограмму. Если это не так, возвращается &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b581c43bfa8c63ce0337f8cf0f51834457cb5241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt;. This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a231f00f91910adc2ab3862d9199fc8f2fdda4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_run&lt;/code&gt; function can tell you if a certain binary is installed and if so where, whereas the &lt;code&gt;run&lt;/code&gt; function can actually execute any of the commands you give it and give you a clear return value, as well as adhere to your verbosity settings.</source>
          <target state="translated">Функция &lt;code&gt;can_run&lt;/code&gt; может сказать вам, установлен ли определенный двоичный файл и если да, то где, тогда как функция &lt;code&gt;run&lt;/code&gt; может фактически выполнить любую из команд, которые вы ей даете, и дать вам четкое возвращаемое значение, а также придерживаться ваших настроек детализации.</target>
        </trans-unit>
        <trans-unit id="ae669119c46135f428f552580c056d83e94ae6fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char*&lt;/code&gt; string does not tell you the whole story, and you can't copy or reconstruct an SV just by copying the string value. Check if the old SV has the UTF8 flag set (</source>
          <target state="translated">&lt;code&gt;char*&lt;/code&gt; строка не сказать вам всю историю, и вы не можете копировать или реконструировать SV только путем копирования значения строки. Проверьте, установлен ли на старом SV флаг UTF8 (</target>
        </trans-unit>
        <trans-unit id="3b094d933bb88b4ae1f6722063975d6ce16a864f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="translated">В &lt;code&gt;charnames&lt;/code&gt; Pragma опоры аргументы &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , имена скриптов и &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;пользовательские псевдонимы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3385057bdbf70e4b65ad1d11db30e12395abd68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt;, &lt;code&gt;:loose&lt;/code&gt;, &lt;code&gt;:short&lt;/code&gt;, script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f351acbd57d2d1102a02f0ad7f0071439704163" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chr()&lt;/code&gt; and &lt;code&gt;ord()&lt;/code&gt; functions work on whole characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf018bbe36ec38be15a617cdd0dc65af5cb382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cmp&lt;/code&gt; (and hence &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;) operators do not necessarily give the correct results when both operands are UTF-EBCDIC encoded strings and there is a mixture of ASCII and/or control characters, along with other characters.</source>
          <target state="translated">Операторы &lt;code&gt;cmp&lt;/code&gt; (и, следовательно, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ) не обязательно дают правильные результаты, если оба операнда являются строками в кодировке UTF-EBCDIC, и имеется смесь символов ASCII и / или управляющих символов вместе с другими символами.</target>
        </trans-unit>
        <trans-unit id="ec09ece4b13035db3b64ac6559a812694d130f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; function determines if colouring should occur or not. Passing it a true or false value will enable or disable colouring respectively, and the function called with no argument will return the current setting.</source>
          <target state="translated">Функция &lt;code&gt;color&lt;/code&gt; определяет, должно ли происходить окрашивание. Передача ему значения true или false соответственно включит или отключит окраску, а функция, вызываемая без аргументов, вернет текущую настройку.</target>
        </trans-unit>
        <trans-unit id="fcc832a2467057f7acfd689fa1bb07925f149ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complicated&lt;/code&gt; function will return the same numeric &lt;code&gt;$result&lt;/code&gt; regardless of whether it is called in list or in scalar context.</source>
          <target state="translated">&lt;code&gt;complicated&lt;/code&gt; функция будет возвращать один и тот же числовой &lt;code&gt;$result&lt;/code&gt; независимо от того, является ли оно называется в списке или в скалярном контексте.</target>
        </trans-unit>
        <trans-unit id="f67952b359119ecd8ea38089ffb10eb7987a4172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="translated">Функция &lt;code&gt;cond_broadcast&lt;/code&gt; работает аналогично &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , однако, разблокирует &lt;b&gt;все&lt;/b&gt; потоки, которые заблокированы в &lt;code&gt;cond_wait&lt;/code&gt; для заблокированной переменной, а не только один.</target>
        </trans-unit>
        <trans-unit id="2c18198f3431b0af0518f8194180bdd1d59f0718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt;. &lt;code&gt;cond_broadcast&lt;/code&gt;, though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85c76c4fd238a57c5f21f762fcaeb20729d17df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">Функция &lt;code&gt;cond_signal&lt;/code&gt; принимает &lt;b&gt;заблокированную&lt;/b&gt; переменную в качестве параметра и разблокирует один поток, который использует &lt;code&gt;cond_wait&lt;/code&gt; ing для этой переменной. Если более одного потока заблокировано в &lt;code&gt;cond_wait&lt;/code&gt; для этой переменной, только один (и который не определен) будет разблокирован.</target>
        </trans-unit>
        <trans-unit id="17177c8bfdab5cbbef640ed5fdbe840af84bd3e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5be06c4673c5f0381dc64821a424c5ce57dffbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">Функция &lt;code&gt;cond_signal&lt;/code&gt; принимает заблокированную переменную в качестве параметра и разблокирует один поток, который использует &lt;code&gt;cond_wait&lt;/code&gt; ing для этой переменной. Если более одного потока заблокировано в &lt;code&gt;cond_wait&lt;/code&gt; для этой переменной, только один (и который не определен) будет разблокирован.</target>
        </trans-unit>
        <trans-unit id="90834b3f231b489213b8a6d3ee5e7273db92badc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076e7dbb91376a2a5dc565f0cafe6a8c9c90bfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="translated">Функция &lt;code&gt;cond_wait&lt;/code&gt; принимает &lt;b&gt;заблокированную&lt;/b&gt; переменную в качестве параметра, разблокирует переменную и блокируется до тех пор, пока другой поток не &lt;code&gt;cond_signal&lt;/code&gt; или &lt;code&gt;cond_broadcast&lt;/code&gt; для той же заблокированной переменной. Переменная, заблокированная &lt;code&gt;cond_wait&lt;/code&gt; , повторно блокируется после выполнения &lt;code&gt;cond_wait&lt;/code&gt; . Если есть несколько потоков &lt;code&gt;cond_wait&lt;/code&gt; ing для одной и той же переменной, все, кроме одного, будут повторно блокировать ожидание, чтобы повторно получить блокировку для переменной. (Итак, если вы используете только &lt;code&gt;cond_wait&lt;/code&gt; для синхронизации как можно скорее откажитесь от блокировки). Два действия - разблокировка переменной и вход в заблокированное состояние ожидания - атомарны, а два действия - выход из заблокированного состояния ожидания и повторная блокировка переменной - нет.</target>
        </trans-unit>
        <trans-unit id="439f35352dbf1d510415ebca01133fb2e86790ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa04a005ef5fee3bbdeb8f830aca63065ce2e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="translated">Функция &lt;code&gt;cond_wait&lt;/code&gt; принимает &lt;b&gt;заблокированную&lt;/b&gt; переменную в качестве параметра, разблокирует переменную и блокируется до тех пор, пока другой поток не &lt;code&gt;cond_signal&lt;/code&gt; или &lt;code&gt;cond_broadcast&lt;/code&gt; для той же заблокированной переменной. Переменная, заблокированная &lt;code&gt;cond_wait&lt;/code&gt; , повторно блокируется после того, как &lt;code&gt;cond_wait&lt;/code&gt; удовлетворяется. Если есть несколько потоков &lt;code&gt;cond_wait&lt;/code&gt; ing для одной и той же переменной, все, кроме одного, будут повторно заблокированы, ожидая повторного получения блокировки для переменной. (Так что, если вы используете &lt;code&gt;cond_wait&lt;/code&gt; только для синхронизации, снимите блокировку как можно скорее.)</target>
        </trans-unit>
        <trans-unit id="ad78498a67881045948d88db7f3bfb4f745feb3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05e65092ed5c30b3ec99766dc7198ef2d697366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(integer)&lt;/code&gt; . It is true if the corresponding backreference &lt;code&gt;\integer&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; or &lt;code&gt;('name')&lt;/code&gt; . The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt; ) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; ,...) or by name (&lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; может иметь несколько форм. Первая форма - это просто целое число в скобках &lt;code&gt;(integer)&lt;/code&gt; . Верно, если соответствующая обратная ссылка &lt;code&gt;\integer&lt;/code&gt; совпало ранее в регулярном выражении. То же самое можно сделать с именем, связанным с группой захвата, записанным как &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; или &lt;code&gt;('name')&lt;/code&gt; . Вторая форма - это простое утверждение нулевой ширины &lt;code&gt;(?...)&lt;/code&gt; , либо прогнозирование вперед, либо прогнозирование назад, либо утверждение кода (обсуждается в следующем разделе). Третий набор форм предоставляет тесты, которые возвращают истину, если выражение выполняется в рекурсии ( &lt;code&gt;(R)&lt;/code&gt; ) или вызывается из некоторой группы захвата, на которую ссылаются либо по номеру ( &lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; , ...) или по имени ( &lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad47d7c085885e724ad5ee56f7fe5e436f8b9c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; function will always return the current context. If there is already a context active, it will be returned. If there is not an active context, one will be generated. When a context is generated it will default to using the file and line number where the currently running sub was called from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec10fe3aaaca1b55ef86de9fafc8bbe404ebad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; method is your primary interface into the Test2 framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf42e706aa15e3b9613116ccaae1bce3997d5965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; function takes two parameters: a file to copy from and a file to copy to. Either argument may be a string, a FileHandle reference or a FileHandle glob. Obviously, if the first argument is a filehandle of some sort, it will be read from, and if it is a file</source>
          <target state="translated">Функция &lt;code&gt;copy&lt;/code&gt; принимает два параметра: файл, из которого нужно копировать, и файл, в который нужно копировать. Любой аргумент может быть строкой, ссылкой FileHandle или глобусом FileHandle. Очевидно, что если первый аргумент - это какой-то дескриптор файла, он будет прочитан из, и если это файл</target>
        </trans-unit>
        <trans-unit id="bb585d66ac9e0baf39acd70331ff3f0f5eef7b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt; ). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt; ) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="translated">&lt;code&gt;cpp&lt;/code&gt; фильтр не применяется к тексту модуля Фреда, только в текст файла , который использовал его ( &lt;code&gt;cpp_test&lt;/code&gt; ). Хотя оператор use в строке 3 будет проходить через фильтр cpp, включенный модуль ( &lt;code&gt;Fred&lt;/code&gt; ) не пройдет. Исходные потоки выглядят следующим образом после анализа строки 3 и до анализа строки 4:</target>
        </trans-unit>
        <trans-unit id="cb5beac8049360b845cf124791fe07ff9a12d34c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt;). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt;) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0e889b0f475939308ccb8373e116461d3751c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method takes a reference to a subroutine and creates a new thread that starts executing in the referenced subroutine. Control then passes both to the subroutine and the caller.</source>
          <target state="translated">Метод &lt;code&gt;create()&lt;/code&gt; принимает ссылку на подпрограмму и создает новый поток, который начинает выполнение в указанной подпрограмме. Затем управление передается как подпрограмме, так и вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="4daee3058488514b062a77504cbed0c79eee6390" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypt&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3224bd5303e6f5ddff9eaa9e8454f4b95ad9fcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;curlen&lt;/code&gt; length parameter passed in was too small, and the function was prevented from examining all the necessary bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b2e5dabf98fd166f3cc23d1829d0ea566d66df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;declare()&lt;/code&gt; method always creates dotted-decimal version objects. When used in a module, you &lt;b&gt;must&lt;/b&gt; put it on the same line as &quot;use version&quot; to ensure that $VERSION is read correctly by PAUSE and installer tools. You should also add 'version' to the 'configure_requires' section of your module metadata file. See instructions in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af1cb7eb6b21f006259e64b150fa56903267e60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69524f53f96840e72cc2460d82457b60c364f5a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b3d6c14b075946962dafa1dc3a2886740f908a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;diagnostics&lt;/code&gt; Pragma</source>
          <target state="translated">В &lt;code&gt;diagnostics&lt;/code&gt; Pragma</target>
        </trans-unit>
        <trans-unit id="086b0e345be46fb23c5d4022bc1b3516ac49d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_format&lt;/code&gt; class method and the corresponding &lt;code&gt;display_format&lt;/code&gt; object method can now be called using a parameter hash instead of just a one parameter.</source>
          <target state="translated">Метод класса &lt;code&gt;display_format&lt;/code&gt; и соответствующий метод объекта &lt;code&gt;display_format&lt;/code&gt; теперь могут быть вызваны с использованием хэша параметра вместо одного параметра.</target>
        </trans-unit>
        <trans-unit id="a9abe66ed186f7fcb344af8814b57766600779f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85937d63d0c2a7155254307de5c15a8dc64cc7fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;done&lt;/code&gt; method returns true if the thread you're checking has finished, and false otherwise.</source>
          <target state="translated">Метод &lt;code&gt;done&lt;/code&gt; возвращает true, если проверяемый поток завершился, и false в противном случае.</target>
        </trans-unit>
        <trans-unit id="322d30ea9fcb9b2fb4107fa041a490d3eef3fbe8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dontfrag&lt;/code&gt; argument sets the IP_DONTFRAG bit, but note that IP_DONTFRAG is not yet defined by Socket, and not available on many systems. Then it is ignored. On linux it also sets IP_MTU_DISCOVER to IP_PMTUDISC_DO but need we don't chunk oversized packets. You need to set $data_size manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c42a2b150a081cef9d9a1db39370eb144f13339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">Метод &lt;code&gt;down&lt;/code&gt; уменьшает количество семафоров на указанное число (которое должно быть целым числом&amp;gt; = 1) или на единицу, если число не указано.</target>
        </trans-unit>
        <trans-unit id="1d986e9044d0332c0e0b20d1b476092f758b1763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_force&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified. This method does not block, and may cause the semaphore's count to drop below zero.</source>
          <target state="translated">Метод &lt;code&gt;down_force&lt;/code&gt; уменьшает количество семафоров на указанное число (которое должно быть целым числом&amp;gt; = 1) или на единицу, если число не указано. Этот метод не блокирует и может привести к падению счетчика семафора ниже нуля.</target>
        </trans-unit>
        <trans-unit id="59032671c2f862c61987094dab4187139af577bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_nb&lt;/code&gt; method attempts to decrease the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">Метод &lt;code&gt;down_nb&lt;/code&gt; пытается уменьшить количество семафоров на указанное число (которое должно быть целым числом&amp;gt; = 1) или на единицу, если число не указано.</target>
        </trans-unit>
        <trans-unit id="ad817bd0c55a8a17c45e80be5bfb80185a6f0a13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_timed&lt;/code&gt; method attempts to decrease the semaphore's count by 1 or by the specified number within the specified timeout period given in seconds (which must be an integer &amp;gt;= 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b4509e2a48be8cd2c584657729b851defbc375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each()&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, or &lt;code&gt;each&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;each&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb0881abe1e42d6f6890023e371e6cf04aeaeaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;keys&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac628ac906a6e8c64ae1a2404030120f69cfb8c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; branch should be used for the really ultimate fallback, not for code specific to some platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ce45b8c5dc5a90ffb8cc26e428eb8e7134ca2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eogc&lt;/code&gt; flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</source>
          <target state="translated">В &lt;code&gt;eogc&lt;/code&gt; флаги раздели перед передачей в подпрограмму ср. Механизму регулярных выражений не нужно знать, установлен ли какой-либо из них, поскольку эти флаги должны влиять только на то, что Perl делает с шаблоном и его переменными соответствия, а не на то, как он компилируется и выполняется.</target>
        </trans-unit>
        <trans-unit id="5dcaf0131993c2fe373ceb68066111b75397ce84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal()&lt;/code&gt; method takes two thread objects and returns true if the objects represent the same thread, and false if they don't.</source>
          <target state="translated">Метод &lt;code&gt;equal()&lt;/code&gt; принимает два объекта потока и возвращает true, если объекты представляют один и тот же поток, и false в противном случае.</target>
        </trans-unit>
        <trans-unit id="49890ceef3269a9849305b4a6f9b549bc3f0c714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errno&lt;/code&gt; value is optional. In versions of &lt;code&gt;autodie::exception&lt;/code&gt; 1.99 and earlier the code would try to automatically use the current value of &lt;code&gt;$!&lt;/code&gt;, but this was unreliable and is no longer supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5c1caef84073c78e4b57183c72209f1a463dd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eval&lt;/code&gt; method wrapped an &lt;code&gt;eval&lt;/code&gt; around a &lt;code&gt;join&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80af1149bc4ce69fb624da74e40c6a5dafd9409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;examples&lt;/code&gt; sub-directory has copies of all these filters implemented both as</source>
          <target state="translated">В подкаталоге &lt;code&gt;examples&lt;/code&gt; есть копии всех этих фильтров, реализованных как</target>
        </trans-unit>
        <trans-unit id="1c3c6e01b0d3bd33a4ed4055dd31b80304ebc9d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exec&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;exec&lt;/code&gt;. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc84f2c59070bf508814fa3ebed34092fe0cca71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma exists to combine the required incantations into a single interface stable across releases of perl. For every experimental feature, this should enable the feature and silence warnings for the enclosing lexical scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472a34a62dd6bdcf8df5e53d452c5f9dca79546f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra_mappings&lt;/code&gt; arguments takes a hash ref with the same type of structure as described in &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;, except with its values as one of the &lt;a href=&quot;#MERGE-STRATEGIES&quot;&gt;defined merge strategies&lt;/a&gt; or a code ref to a merging function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a371087f59ef9684a3303b0318405ae011e9ec34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_delimited&lt;/code&gt; function formalizes the common idiom of extracting a single-character-delimited substring from the start of a string. For example, to extract a single-quote delimited string, the following code is typically used:</source>
          <target state="translated">Функция &lt;code&gt;extract_delimited&lt;/code&gt; формализует общую идиому извлечения подстроки, разделенной одним символом, из начала строки. Например, для извлечения строки, разделенной одинарными кавычками, обычно используется следующий код:</target>
        </trans-unit>
        <trans-unit id="01013bd276b6d8fe2331fe338d632601823957b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_multiple&lt;/code&gt; subroutine takes a string to be processed and a list of extractors (subroutines or regular expressions) to apply to that string.</source>
          <target state="translated">&lt;code&gt;extract_multiple&lt;/code&gt; подпрограмма принимает строку , которая будет обрабатываться и список экстракторов (подпрограмм или регулярных выражений) , чтобы применить к этой строке.</target>
        </trans-unit>
        <trans-unit id="0234e9715d2d58dfe4e40eada785cc5d3ba85e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fail&lt;/code&gt; option indicates the action to be taken if a matching end tag is not encountered (i.e. before the end of the string or some &lt;code&gt;reject&lt;/code&gt; pattern matches). By default, a failure to match a closing tag causes &lt;code&gt;extract_tagged&lt;/code&gt; to immediately fail.</source>
          <target state="translated">Параметр &amp;laquo; &lt;code&gt;fail&lt;/code&gt; указывает действие, которое необходимо предпринять, если соответствующий конечный тег не обнаружен (т. Е. До конца строки или совпадения с каким-либо шаблоном &lt;code&gt;reject&lt;/code&gt; ). По умолчанию, &lt;code&gt;extract_tagged&lt;/code&gt; закрывающему тегу приводит к немедленному отказу extract_tagged .</target>
        </trans-unit>
        <trans-unit id="7fdb136937ca0405fd0e09f20f2a40c4f858261d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failed&lt;/code&gt; command reports all distributions that failed on one of &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;install&lt;/code&gt; for some reason in the currently running shell session.</source>
          <target state="translated">Команда с &lt;code&gt;failed&lt;/code&gt; сообщает обо всех дистрибутивах, которые по какой-либо причине не удалось выполнить одну из &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; или &lt;code&gt;install&lt;/code&gt; в текущем сеансе оболочки.</target>
        </trans-unit>
        <trans-unit id="5ad80da9f3017cad820985c782b83967ca308a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; hint to getaddrinfo(), or the family of the socket address passed to getnameinfo() is not supported.</source>
          <target state="translated">&lt;code&gt;family&lt;/code&gt; намек на getaddrinfo (), или семейство адреса сокета передается getnameinfo () не поддерживается.</target>
        </trans-unit>
        <trans-unit id="acd804f7e1462316c1795d1b040a724ba816aee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; command just updates the &lt;code&gt;camel&lt;/code&gt; refs, as the objects themselves should have been fetched when pulling from &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa028e0e10b907654ea97ca6e2e56dbd54cf34e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt; . We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; утилита доступна на FreeBSD. NetBSD и Dragonfly BSD могут также получить его от &lt;code&gt;pkgsrc&lt;/code&gt; . Мы проверяем &lt;code&gt;fetch&lt;/code&gt; на этих трех платформах.</target>
        </trans-unit>
        <trans-unit id="88909127a630a0e568460e4ef567fdf6cebea70a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt;. We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e227d5e7190288807dd09d5662a48f3b24c6088" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fforce&lt;/code&gt; pragma is a variant that emulates a &lt;code&gt;force get&lt;/code&gt; which erases the entire memory followed by the action specified, effectively restarting the whole get/make/test/install procedure from scratch.</source>
          <target state="translated">&lt;code&gt;fforce&lt;/code&gt; Прагма является вариантом , который эмулирует &lt;code&gt;force get&lt;/code&gt; , которая стирает всю память с последующим действием указанного, эффективно перезапуском всего получить / грим / тест / установить процедуру с нуля.</target>
        </trans-unit>
        <trans-unit id="67136aec5c09887a5fbdbeaf79603ace225d72fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; pragma enables compile-time and run-time verified class fields.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; Прагма позволяет во время компиляции и время выполнения проверены полей класса.</target>
        </trans-unit>
        <trans-unit id="1da25c8608c050c137eec0fcb8b96dfa9d530dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="translated">Имя &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; и параметры &lt;code&gt;mode&lt;/code&gt; являются прямым эквивалентом своих аналогов в dbopen (). Последний параметр $ DB_HASH выполняет функцию параметров &lt;code&gt;type&lt;/code&gt; и &lt;code&gt;openinfo&lt;/code&gt; в dbopen ().</target>
        </trans-unit>
        <trans-unit id="d57b7b57482f3e0bdad4f727d65fbd7d3f8d08ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711049b66f21cfb21f8abf404e302b9cb973606c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fileparse()&lt;/code&gt; routine divides a file path into its $dirs, $filename and (optionally) the filename $suffix.</source>
          <target state="translated">В &lt;code&gt;fileparse()&lt;/code&gt; подпрограмма делит путь к файлу в его $ директорий, $ имя_файла и (необязательно) имя файла $ суффиксов.</target>
        </trans-unit>
        <trans-unit id="2894a076625213bf8472ba18a1068c216ff2972b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method is always the last thing called on the formatter,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c20640b93e6e1928bfa39a7352c6c3efb0f1519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; set to display &lt;code&gt;isPRINT()&lt;/code&gt;able characters as themselves, &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; to display the &lt;code&gt;\\[nrfta\\]&lt;/code&gt; as the backslashed versions (like &lt;code&gt;&quot;\n&quot;&lt;/code&gt;) (&lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; is preferred over &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; for &lt;code&gt;&quot;\\&quot;&lt;/code&gt;). &lt;code&gt;UNI_DISPLAY_QQ&lt;/code&gt; (and its alias &lt;code&gt;UNI_DISPLAY_REGEX&lt;/code&gt;) have both &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; and &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602708ab2289d55123d1e5cfa483278e5dc2b095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have UNI_DISPLAY_ISPRINT set to display isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</source>
          <target state="translated">В аргументе &lt;code&gt;flags&lt;/code&gt; может быть установлено значение UNI_DISPLAY_ISPRINT для отображения символов isPRINT () как самих себя, UNI_DISPLAY_BACKSLASH для отображения \\ [nrfta \\] в качестве версий с обратной косой чертой (например, '\ n') (UNI_DISPLAY_BACKSLASH предпочтительнее, чем UNI_DISPLAY_ISPLAY_). UNI_DISPLAY_QQ (и его псевдоним UNI_DISPLAY_REGEX) имеют как UNI_DISPLAY_BACKSLASH, так и UNI_DISPLAY_ISPRINT.</target>
        </trans-unit>
        <trans-unit id="45b476535dde9c4df2a5ce21abd7562e13744b06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;&quot;pv_uni_display&quot;&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2dfe02c9ae062f42652141438a9f9714c71cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;().</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; аргумент , как и в &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="99738c77e0f1da5722068673963c4a8f215d0b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; can be:</source>
          <target state="translated">Эти &lt;code&gt;flags&lt;/code&gt; могут быть:</target>
        </trans-unit>
        <trans-unit id="cefd6d4dfafa940aea51a92bdcb195eed2de69a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; method returned the flags for the thread - an integer value corresponding to the internal flags for the thread.</source>
          <target state="translated">Метод &lt;code&gt;flags&lt;/code&gt; вернул флаги для потока - целочисленное значение, соответствующее внутренним флагам потока.</target>
        </trans-unit>
        <trans-unit id="8425d60192539121edf35ab62976eb395bc2a704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; option is optional and defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cca4f06215bca47eddea026c40afe1b9a43be1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</source>
          <target state="translated">Параметр &lt;code&gt;flags&lt;/code&gt; может использоваться, чтобы определить, на какие из этих операций должны отвечать обратные вызовы. В настоящее время определены следующие флаги:</target>
        </trans-unit>
        <trans-unit id="459faaa5e3280fee22284d6b094987c77fa7de30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter in all the</source>
          <target state="translated">Параметр &lt;code&gt;flags&lt;/code&gt; во всех</target>
        </trans-unit>
        <trans-unit id="bfe1865df397f3698f54ec1b600413c38607abed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">Параметр &lt;code&gt;flags&lt;/code&gt; - это битовое поле, которое указывает, с каким из флагов &lt;code&gt;msixpn&lt;/code&gt; было скомпилировано регулярное выражение. Он также содержит дополнительную информацию, например, действует ли &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fd73fe1f5c776efd0dba4ac9a66a7649c62b563" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;use locale&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600009146ad8caeb28aa4266bb11bcc93c6081be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use, and must always be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b4f74a7487e51319a762323a60ac4f87b549c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use. Currently it is only used by perl internally, so extensions should always pass zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b886ddfa56e0b9ebfe8f2070d41589a1086768dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush_cache()&lt;/code&gt; function will raise a run-time error unless the tied package provides a &lt;code&gt;CLEAR&lt;/code&gt; method.</source>
          <target state="translated">Функция &lt;code&gt;flush_cache()&lt;/code&gt; вызовет ошибку времени выполнения, если связанный пакет не предоставляет метод &lt;code&gt;CLEAR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="124f73ccb9aad8a6d48616fcbcb3b56af5616b10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for(each)&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn). There is no syntax to specify a C-style for loop or a lexically scoped iteration variable in this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee8bf6c49cb0d370b573c84b81eeff22daa626c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force&lt;/code&gt; pragma may precede another command (currently: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , or &lt;code&gt;install&lt;/code&gt; ) to execute the command from scratch and attempt to continue past certain errors. See the section below on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">&lt;code&gt;force&lt;/code&gt; прагма может предшествовать другую команду ( в настоящее время &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , или &lt;code&gt;install&lt;/code&gt; ) , чтобы выполнить команду с нуля и попытаться продолжить прошлые некоторые ошибки. См. Раздел ниже о &lt;code&gt;force&lt;/code&gt; и &lt;code&gt;fforce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f4026c135fb9c9e701839369f22ab72881f9e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt; , that could be written like this:</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; является не экспериментальным путем установить topicalizer. Если вы хотите использовать экспериментально &lt;code&gt;given&lt;/code&gt; , это можно записать так:</target>
        </trans-unit>
        <trans-unit id="8adf50b4a12807b9b440b3e9dd59f76950784e30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt;, that could be written like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de226564415ab69d6441fa2857763cf2ce5fdae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword, so you can use either. If VAR is omitted, &lt;code&gt;$_&lt;/code&gt; is set to each value.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; ключевое слово на самом деле является синонимом &lt;code&gt;for&lt;/code&gt; ключевого слова, так что вы можете использовать либо. Если VAR не указан, каждому значению присваивается &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb1c9008000e928d5125162497dd929b484cbedf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;&quot;Foreach Loops&quot; in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375dcc1d1d2f6f42cca4896811ca8fdfa2d3b491" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; ключевое слово на самом деле является синонимом &lt;code&gt;for&lt;/code&gt; ключевого слова. См. &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b86bb402e5da8037aee4e69efe060f892f194612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; after the backslash:</source>
          <target state="translated">Цикл &lt;code&gt;foreach&lt;/code&gt; также может принимать ссылочный конструктор для своей переменной цикла, хотя синтаксис ограничен одним из следующих, с необязательным &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; после обратной косой черты:</target>
        </trans-unit>
        <trans-unit id="21bbc47a2581808651eb8a89a9f603b84e2a2657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, or &lt;code&gt;our&lt;/code&gt; after the backslash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c367bfb9bb4dab65fff1b13521d38572d69dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="translated">По умолчанию цикл &lt;code&gt;foreach&lt;/code&gt; динамически определяет область видимости своей индексной переменной как &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; . Однако, если индексная переменная имеет префикс с ключевым словом &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; или если в области видимости уже есть лексическое слово с таким именем, то вместо него создается новое лексическое слово . Таким образом, в цикле</target>
        </trans-unit>
        <trans-unit id="fc6d0492eecb0b7b77ecb47ab19f74f65e2c9439" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;local&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;my&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c4603cb509242d80999a110064359f577c21d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="translated">Цикл &lt;code&gt;foreach&lt;/code&gt; выполняет итерацию по обычному значению списка и устанавливает скалярную переменную VAR в качестве каждого элемента списка по очереди. Если перед переменной стоит ключевое слово &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , то она имеет лексическую область видимости и поэтому видна только внутри цикла. В противном случае переменная неявно является локальной для цикла и восстанавливает свое прежнее значение при выходе из цикла. Если переменная была ранее объявлена ​​с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , она использует эту переменную вместо глобальной, но по-прежнему локализована для цикла. Эта неявная локализация происходит</target>
        </trans-unit>
        <trans-unit id="d0916d837b24f716ed6d234f4dd39fce8bf3c636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;my&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;my&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb381f2681e84a2954e18395a958e606ca6cba3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame&lt;/code&gt; option can be used to control the output of frame information. For example, contrast this expression trace:</source>
          <target state="translated">Опцию &lt;code&gt;frame&lt;/code&gt; можно использовать для управления выводом информации о кадре. Например, сравните этот след выражения:</target>
        </trans-unit>
        <trans-unit id="591f72361e30bcbf229773b985f4b81bad64b394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gateway&lt;/code&gt; argument is only valid for IPv6, and requires a IPv6 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01af8f56de621025abc07dc645713da63a5fe927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_delimited_pat&lt;/code&gt; subroutine takes a single (string) argument and &amp;gt; builds a Friedl-style optimized regex that matches a string delimited by any one of the characters in the single argument. For example:</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; подпрограмма принимает один (строки) аргумент и&amp;gt; строит Фридл стиль оптимизированного регулярное выражение , которое соответствует строке с разделителями любой из символов в один аргументе. Например:</target>
        </trans-unit>
        <trans-unit id="617ccfb027c1e5d2773071a87cbcedc95dc112aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_dup&lt;/code&gt; method assists in reading duplicate values from BTREE databases. The method can take the following forms:</source>
          <target state="translated">Метод &lt;code&gt;get_dup&lt;/code&gt; помогает считывать повторяющиеся значения из баз данных BTREE. Метод может принимать следующие формы:</target>
        </trans-unit>
        <trans-unit id="38757d13de90c9736c762577e50e5a7475bfa2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getname&lt;/code&gt; function returns the file specification associated with a Perl I/O handle. If an error occurs, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea986ecd3305b94f4546f1c6e3ce692488dd0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="translated">Функция &lt;code&gt;getopt()&lt;/code&gt; аналогична, но ее аргументом является строка, содержащая все переключатели, принимающие аргумент. Если для переключателя не &lt;code&gt;$opt_y&lt;/code&gt; аргумент, например &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; , соответствующему параметру $ opt_y будет присвоено неопределенное значение. Неуказанные переключатели принимаются без уведомления. Использование &lt;code&gt;getopt()&lt;/code&gt; не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="d8dad5d808a96d01abfb75223a15354d771a92d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;y&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c037451f79364fbd043155e0ffbbe91d2a70fbad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">Функция &lt;code&gt;getopts()&lt;/code&gt; обрабатывает односимвольные переключатели с кластеризацией переключателей. Передайте один аргумент, который представляет собой строку, содержащую все распознаваемые переключатели. Для каждого найденного переключателя, если аргумент ожидается и предоставлен, &lt;code&gt;getopts()&lt;/code&gt; устанавливает &lt;code&gt;$opt_x&lt;/code&gt; (где &lt;code&gt;x&lt;/code&gt; - имя переключателя) в значение аргумента. Если аргумент ожидается, но не &lt;code&gt;$opt_x&lt;/code&gt; , $ opt_x устанавливается в неопределенное значение. Если переключатель не принимает аргумент, &lt;code&gt;$opt_x&lt;/code&gt; устанавливается в &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91aef3725c2efdb205ada4f0830cb2c2f0326f3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe182c59e721bf2edc44a9253eded06fe11c1a8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function returns true unless an invalid option was found.</source>
          <target state="translated">Функция &lt;code&gt;getopts()&lt;/code&gt; возвращает истину, если не была найдена недопустимая опция.</target>
        </trans-unit>
        <trans-unit id="a7db78679ac7caa25a3af4ac6eb9b08a0ab0fc92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gmtime&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;gmtime()&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf55542a974db500db0203f6bd0350de0ee8029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt;) and immediately calls in its place the named subroutine using the current value of &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;, not even &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87b19f1c73c949cde9da8170870a148c4211b7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt;, below. This is especially useful for implementing tail recursion via &lt;code&gt;goto __SUB__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5712e372b5c3349bd4c5753ceb08d65a1f34e0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. The author of Perl has never felt the need to use this form of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; in other languages.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a01fb6d408173d3e22945b3c56ff55146388d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;goto&lt;/code&gt;, not even &lt;code&gt;caller()&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445db83ca6a37cdb271d1da44d8e4a2e039ee781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;goto&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3604bc760ddc7f229653ccec982fbb33374f75b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;last&lt;/code&gt; or &lt;code&gt;die&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;goto&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fadcd77a199834658c813ed1ecacfc31717619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688985f64d8825090cd98452194bcbd67a98423b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;grammar_class&lt;/code&gt; можно настроить, как описано в &lt;a href=&quot;#new&quot;&gt;новой&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="777e123af8a17b58624e4e03631072776b99c240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grep&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361db5e35a8a030899f4185a6ca897ccf88b2984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) long.</source>
          <target state="translated">В &lt;code&gt;h&lt;/code&gt; и &lt;code&gt;H&lt;/code&gt; форматы упаковки строку , что многие nybbles (4-битовых групп, представимых в виде шестнадцатеричных цифр, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt; &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) долго.</target>
        </trans-unit>
        <trans-unit id="282363bb17be47a4571b65bee183b55491c1858f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt;) long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0ba82d51f8c56aed17fcdac89e94cd7a38305" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;has()&lt;/code&gt; подпрограмма объявляет атрибут, и &lt;code&gt;Moose&lt;/code&gt; автоматически создает аксессор для этих атрибутов. Он также позаботится о создании для вас метода &lt;code&gt;new()&lt;/code&gt; . Этот конструктор знает об объявленных вами атрибутах, поэтому вы можете установить их при создании нового &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b9970d46e3cdb5c6bbb0a61789e35dad5828ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a592c009139dada36763e63a154e69a7ae21aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hide_buffered()&lt;/code&gt; method must return a boolean. This is used to tell buffered subtests whether or not to send it events as they are being buffered. See &lt;a href=&quot;Test2::API#run_subtest%28...%29&quot;&gt;&quot;run_subtest(...)&quot; in Test2::API&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb4b1270d7a6c1577ddc7dc43612517ef56c1fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; argument implicitly specifies the family if the family argument is not given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9683174ca55dfc5709630b38ddbf4013af69ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; ; they are tolerated for completeness' sake.</source>
          <target state="translated">&lt;code&gt;i!&lt;/code&gt; и &lt;code&gt;I!&lt;/code&gt; коды не отличаются от &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;I&lt;/code&gt; ; они допустимы для полноты картины.</target>
        </trans-unit>
        <trans-unit id="788c747d1d57898e8c459685e81e82083e2bc64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt;; they are tolerated for completeness' sake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441288d51b032bd9af407d3a9d7124153bae7480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is incorporated in</source>
          <target state="translated">Функция &lt;code&gt;id()&lt;/code&gt; включена в</target>
        </trans-unit>
        <trans-unit id="5b77bbf33fef07ab4b901464b3d1fbf57256a9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="translated">Функция &lt;code&gt;id()&lt;/code&gt; предоставляется в дополнение к существующему &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Помимо короткого названия, в одних обстоятельствах он может быть немного быстрее (и немного медленнее в других). Тестируйте, если это важно. Работа &lt;code&gt;id()&lt;/code&gt; также позволяет использовать имя класса как</target>
        </trans-unit>
        <trans-unit id="b2d4a03cd0e504b918c77f964222c03e6f8204c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt;. Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1766324c2122418c9321a7a3323084287c423699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load another module. The construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d508e8165fd2906f6e1a4da8eddef354ad1b2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load or unload another module. The construct</source>
          <target state="translated">Модуль &lt;code&gt;if&lt;/code&gt; используется для условной загрузки или выгрузки другого модуля. Конструкция</target>
        </trans-unit>
        <trans-unit id="4b048e8a441fb17f85efa08c37a67df6bc5d9c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt; , the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="translated">Оператор &lt;code&gt;if&lt;/code&gt; прост. Поскольку Blocks всегда ограничены фигурными скобками, там никогда не бывает двусмысленность , которая , &lt;code&gt;if&lt;/code&gt; &lt;code&gt;else&lt;/code&gt; идет с. Если вы не используете , &lt;code&gt;unless&lt;/code&gt; вместо &lt;code&gt;if&lt;/code&gt; , чувство теста восстанавливается. Например, &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; за ним не может следовать &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; может даже сопровождаться одним или несколькими операторами &lt;code&gt;elsif&lt;/code&gt; , хотя вы можете дважды подумать, прежде чем использовать эту конкретную языковую конструкцию, поскольку каждому, кто читает ваш код, придется подумать как минимум дважды, прежде чем они смогут понять, что происходит.</target>
        </trans-unit>
        <trans-unit id="a3f74430f10fb167c78fb2a5e2886ee696f50106" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt;, the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt;. &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f3b671cb1eeb07ae7f1604035f9acb4eeee7c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt; . If the server desires a copy of that article, and &lt;code&gt;MESSAGE&lt;/code&gt; has been given the it will be sent.</source>
          <target state="translated">Команда &lt;code&gt;ihave&lt;/code&gt; сообщает серверу, что у клиента есть статья с идентификатором &lt;code&gt;MSGID&lt;/code&gt; . Если серверу нужна копия этой статьи, и &lt;code&gt;MESSAGE&lt;/code&gt; было передано, оно будет отправлено.</target>
        </trans-unit>
        <trans-unit id="31b23815f5a49e656771e950c98aed03ec7f0fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt;. If the server desires a copy of that article and &lt;code&gt;MESSAGE&lt;/code&gt; has been given then it will be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aeda9f25872f01fa1451e80b809c2f965a34d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;use MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt; for more details on &lt;code&gt;import&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a41824798980582f7eebe5a9af3082e01f3a340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intercept { ... }&lt;/code&gt; tool lets you temporarily intercept all events generated by the test system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9e48c7280cc08e3dbfd771c25dd8dc760ce4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in main program scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default set via &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt;, with explicit layers in open() and with binmode() one can manipulate streams as usual. This has no effect on code run in modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31aa9addcda21b8978ff9bf041daba569f826e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in the current file scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default, with explicit layers in open() and with binmode() one can manipulate streams as usual.</source>
          <target state="translated">Параметры &lt;code&gt;io&lt;/code&gt; означают, что любые последующие операции open () (или аналогичные операции ввода-вывода) в текущей области файла будут иметь неявно примененный к ним уровень PerlIO &lt;code&gt;:utf8&lt;/code&gt; , другими словами, UTF-8 ожидается от любого входного потока, и UTF-8 создается для любого выходного потока. Это просто значение по умолчанию, с явными слоями в open () и с binmode () можно управлять потоками как обычно.</target>
        </trans-unit>
        <trans-unit id="ea8cc24a093a2a51529b8db29000183dfdfc585d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isa&lt;/code&gt; method returns</source>
          <target state="translated">Метод &lt;code&gt;isa&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="d80df4437426b10544ca2a3550913f7483c70900" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keep_alive&lt;/code&gt; parameter enables a persistent connection, but only to a single destination scheme, host and port. Also, if any connection-relevant attributes are modified, or if the process ID or thread ID change, the persistent connection will be dropped. If you want persistent connections across multiple destinations, use multiple HTTP::Tiny objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e537c44915ef2c8c7d2ba733eb7ee50f9fc357" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keys()&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;each()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f328cf1649c302313e1693d9d3ed492ede670c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b31ef1c90508af7c0b307ce12a58574a2fffa8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b75cea7c9c256a2c7f367ec1f2a28305318646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;klen&lt;/code&gt; parameter is the length of the key being passed in (Note that you cannot pass 0 in as a value of &lt;code&gt;klen&lt;/code&gt; to tell Perl to measure the length of the key). The &lt;code&gt;val&lt;/code&gt; argument contains the SV pointer to the scalar being stored, and &lt;code&gt;hash&lt;/code&gt; is the precomputed hash value (zero if you want &lt;code&gt;hv_store&lt;/code&gt; to calculate it for you). The &lt;code&gt;lval&lt;/code&gt; parameter indicates whether this fetch is actually a part of a store operation, in which case a new undefined value will be added to the HV with the supplied key and &lt;code&gt;hv_fetch&lt;/code&gt; will return as if the value had already existed.</source>
          <target state="translated">Параметр &lt;code&gt;klen&lt;/code&gt; - это длина передаваемого ключа (обратите внимание, что вы не можете передавать 0 в качестве значения &lt;code&gt;klen&lt;/code&gt; , чтобы Perl измерял длину ключа). &lt;code&gt;val&lt;/code&gt; аргумент содержит указатель SV скаляру хранится, и &lt;code&gt;hash&lt;/code&gt; является предварительно вычисленное хэш - значение (ноль , если вы хотите &lt;code&gt;hv_store&lt;/code&gt; вычислить его для Вас). Параметр &lt;code&gt;lval&lt;/code&gt; указывает, действительно ли эта выборка является частью операции сохранения, и в этом случае новое неопределенное значение будет добавлено к HV с предоставленным ключом, и &lt;code&gt;hv_fetch&lt;/code&gt; вернется, как если бы значение уже существовало.</target>
        </trans-unit>
        <trans-unit id="ce7404a130e41b36d0d6586ea9856d3d751bce9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;last&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;continue&lt;/code&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c1db6e5ea234d6a6e740b669d07b2f2f87de01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length(NAME)&lt;/code&gt; Keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b3be6dbaf0292e629ff79d5077e6e86e950020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="translated">Номера &lt;code&gt;line numbers&lt;/code&gt; представляют собой список номеров строк, разделенных запятыми (некоторым из которых предшествуют кодовые буквы), где этот объект каким-либо образом используется. Простому использованию не предшествует кодовая буква. Введения (например, когда лексическое слово сначала определяется с помощью &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ) обозначаются буквой &amp;laquo;i&amp;raquo;. Вызов подпрограмм и методов обозначается символом &amp;laquo;&amp;amp;&amp;raquo;. Определения подпрограмм обозначаются буквой &amp;laquo;s&amp;raquo;, а определения формата - буквой &amp;laquo;f&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="236b6ae4af5c95ab170ad24f4ae0aa38234165ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;my&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df1ad78d22b500a60841a63c43cbb5af0dd2c94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock()&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;lock()&lt;/code&gt; function. Using &lt;code&gt;lock()&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed26c2274a611c42add606638c2955102446922f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt; , except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt; , but also gets a shared lock on the file before reading.</source>
          <target state="translated">Процедуры &lt;code&gt;lock_store&lt;/code&gt; и &lt;code&gt;lock_nstore&lt;/code&gt; эквивалентны &lt;code&gt;store&lt;/code&gt; и &lt;code&gt;nstore&lt;/code&gt; , за исключением того, что они получают исключительную блокировку файла перед записью. Аналогично, &lt;code&gt;lock_retrieve&lt;/code&gt; делает то же самое, что и &lt;code&gt;retrieve&lt;/code&gt; , но также получает общую блокировку файла перед чтением.</target>
        </trans-unit>
        <trans-unit id="c09918116ac6368cc484da6987f7bb75bbaec828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt;, except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt;, but also gets a shared lock on the file before reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931b71dd87fea82969167ed5b3226571750cd592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method can some additional ESMTP OPTIONS which is passed in hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; метод некоторые дополнительные ESMTP OPTIONS , который передается в хэш , как мода, используя ключ и значение пар. Возможные варианты:</target>
        </trans-unit>
        <trans-unit id="1672385883542a7bfdb246cc1c07640a71a68feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; accept both real and complex arguments. When they cannot recognize the arguments they will die with error messages like the following</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; и &lt;code&gt;emake&lt;/code&gt; принимать как действительные , так и комплексные аргументы. Когда они не могут распознать аргументы, они умрут с сообщениями об ошибках, подобными следующим</target>
        </trans-unit>
        <trans-unit id="c85fa07be63e0e0f2104a7ea90d6fd3b867aea55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exist before, much like the Unix command &lt;code&gt;mkdir -p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36df2e300d21e511804bebffd14eb9e7ae60ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exists before, much like the Unix command &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</source>
          <target state="translated">Функция &lt;code&gt;make_path&lt;/code&gt; создает указанные каталоги, если они не существовали ранее, как и команда Unix &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="072d415ade3aa9a1737c770e2e53b08afe60d304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="translated">В &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; методы работают , как &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; , соответственно, но они не знают о каком - либо шаблоне, но только буквальная подстрока.</target>
        </trans-unit>
        <trans-unit id="3e1a1e48900b4f1b87b0c10e8e5f854b940363da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;gmatch&lt;/code&gt;, &lt;code&gt;subst&lt;/code&gt;, &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;m//g&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;s///g&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece173d4e6c78d6e5935815075ac81cc7c62a227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">Значение &lt;code&gt;memory&lt;/code&gt; не является абсолютным или точным ограничением используемой памяти. Объекты &lt;code&gt;Tie::File&lt;/code&gt; содержат некоторые структуры помимо кэша чтения и буфера отложенной записи, размеры которых не учитываются в &lt;code&gt;memory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e86eeea566744434422bb67f1ca33c0f448174c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d121e9a361d9d72576c01fa16affeece8189c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt; , which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="translated">Поле &lt;code&gt;mg_virtual&lt;/code&gt; в структуре &lt;code&gt;MAGIC&lt;/code&gt; - это указатель на &lt;code&gt;MGVTBL&lt;/code&gt; , который представляет собой структуру указателей на функции и означает &amp;laquo;волшебную виртуальную таблицу&amp;raquo; для обработки различных операций, которые могут быть применены к этой переменной.</target>
        </trans-unit>
        <trans-unit id="7a8acc1e771fdb8b24c87ae131045c8c79a6a526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt;, which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2676c3bd8442c2414026f369d263715f307f12fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mkpath()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;make_path()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;make_path()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5023c90eb5f90ef422233e2dd5d44f7824eab24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; related one will be matched against</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; , связанные один будет сравниваться</target>
        </trans-unit>
        <trans-unit id="47efd6577f009e8c4308e174f5b14a11ddfaec14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; function also takes two parameters: the current name and the intended name of the file to be moved. If the destination already exists and is a directory, and the source is not a directory, then the source file will be renamed into the directory specified by the destination.</source>
          <target state="translated">Функция &lt;code&gt;move&lt;/code&gt; также принимает два параметра: текущее имя и предполагаемое имя файла, который нужно переместить. Если место назначения уже существует и является каталогом, а источник не является каталогом, то исходный файл будет переименован в каталог, указанный в месте назначения.</target>
        </trans-unit>
        <trans-unit id="f9ad05dfff8b94ab9a9d935cf92a180ec9ff2c2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fd69505c43bd3a6104acf78cba741dff69018d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;my&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19231a9a0cfdbf1775816cb2ae3551e57856cb0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;unless&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;), loop (&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;foreach&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;/&lt;code&gt;until&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt;), subroutine, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;/&lt;code&gt;use&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;local&lt;/code&gt;ized with &lt;code&gt;local&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82300ffe8ea8c4a83935f63ac88aba05d079a68e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namlen&lt;/code&gt; arguments are used to associate a string with the magic, typically the name of a variable. &lt;code&gt;namlen&lt;/code&gt; is stored in the &lt;code&gt;mg_len&lt;/code&gt; field and if &lt;code&gt;name&lt;/code&gt; is non-null then either a &lt;code&gt;savepvn&lt;/code&gt; copy of &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; itself is stored in the &lt;code&gt;mg_ptr&lt;/code&gt; field, depending on whether &lt;code&gt;namlen&lt;/code&gt; is greater than zero or equal to zero respectively. As a special case, if &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; then &lt;code&gt;name&lt;/code&gt; is assumed to contain an &lt;code&gt;SV*&lt;/code&gt; and is stored as-is with its REFCNT incremented.</source>
          <target state="translated">В &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;namlen&lt;/code&gt; аргументы используются , чтобы связать строку с магией, как правило , имя переменной. &lt;code&gt;namlen&lt;/code&gt; хранится в поле &lt;code&gt;mg_len&lt;/code&gt; , и если &lt;code&gt;name&lt;/code&gt; не равно нулю, то либо копия &lt;code&gt;savepvn&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; либо само &lt;code&gt;name&lt;/code&gt; сохраняется в поле &lt;code&gt;mg_ptr&lt;/code&gt; , в зависимости от того, больше ли &lt;code&gt;namlen&lt;/code&gt; нуля или равно нулю соответственно. В особом случае, если &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; , то &lt;code&gt;name&lt;/code&gt; предполагается содержать &lt;code&gt;SV*&lt;/code&gt; и хранится как есть с его REFCNT увеличивается.</target>
        </trans-unit>
        <trans-unit id="30007f38d6317a12ba00ec6e0a7e1a8a5a903fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; и &lt;code&gt;cplxe&lt;/code&gt; также понимать один (строка) аргумент форм</target>
        </trans-unit>
        <trans-unit id="ed69370147fad222f299ba19e375b2bf7b98be5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; и &lt;code&gt;cplxe&lt;/code&gt; также понять случай каких - либо аргументов: это означает простой нуль или (0, 0).</target>
        </trans-unit>
        <trans-unit id="6c65b03e7c38b210fdc728780536955dda01e185" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af811bc283e732950a12fee28684ae132d20bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object. If new() is called with no parameters, the collator should do the default collation.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; метод возвращает объект подборщика. Если new () вызывается без параметров, сопоставитель должен выполнять сопоставление по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ae0f663693f54f75cfb0a197fa36ce7749539dce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5852a1533162d9c64ba81a3a508d931f75c8fc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66998427833c37a6112ac1501f01bdbb2d3aed3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is called when &lt;code&gt;Test2::API::Stack&lt;/code&gt; Initializes the root hub for the first time. Most formatters will simply have this call &lt;code&gt;$class-&amp;gt;new&lt;/code&gt;, which is the default behavior. Some formatters however may want to take extra action during construction of the root formatter, this is where they can do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9d718f2247f950a12fdfc4b79710e6bdd5032a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is used when constructing a root formatter. The default is to just delegate to the regular &lt;code&gt;new()&lt;/code&gt; method, most formatters can ignore this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb14c874127fdd24641fa3165f1f47f1c0c5962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b10b638a2af4c10544e1d329f2b109151bd6354" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;continue&lt;/code&gt; keywords work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe7378b188460d4f95907a0bf8fffd8170aa799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nntpstat&lt;/code&gt; command is similar to the &lt;code&gt;article&lt;/code&gt; command except that no text is returned. When selecting by message number within a group, the &lt;code&gt;nntpstat&lt;/code&gt; command serves to set the &quot;current article pointer&quot; without sending text.</source>
          <target state="translated">Команда &lt;code&gt;nntpstat&lt;/code&gt; похожа на команду &lt;code&gt;article&lt;/code&gt; за исключением того, что текст не возвращается. При выборе по номеру сообщения в группе команда &lt;code&gt;nntpstat&lt;/code&gt; служит для установки &amp;laquo;указателя текущей статьи&amp;raquo; без отправки текста.</target>
        </trans-unit>
        <trans-unit id="fef6e564421c89438d32761ce9e7776b6464e92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct assumes that a module or pragma has correctly implemented an &lt;code&gt;unimport()&lt;/code&gt; method -- but most modules and pragmata have not. That explains why the &lt;code&gt;no if&lt;/code&gt; construct is of limited applicability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f0c6076233a4be0a02d3164def9d1f31e4b673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct is mainly used to deactivate categories of warnings when those categories would produce superfluous output under specified versions of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696981a277bda71ab876e23444c84e4c429ec79c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc82aa3e704adf455ebd4a8a84e684b82c4c216" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no sort&lt;/code&gt; pragma doesn't</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44265817f41c8d93c79e5cd86bbcac999ebebf51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_proxy&lt;/code&gt; environment variable is supported in the format of a comma-separated list of domain extensions proxy should not be used for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f846f976939c6373f157aacddb5340df46521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notest&lt;/code&gt; pragma skips the test part in the build process.</source>
          <target state="translated">&lt;code&gt;notest&lt;/code&gt; Прагма пропускает тест участие в процессе сборки.</target>
        </trans-unit>
        <trans-unit id="402cbf532fb5078e8455cec160e9e8dbd08504b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nvsize&lt;/code&gt; element is only present for file format v2.2 and higher.</source>
          <target state="translated">Элемент &lt;code&gt;nvsize&lt;/code&gt; присутствует только для файлов формата v2.2 и выше.</target>
        </trans-unit>
        <trans-unit id="c6ccaa6545aa4fe6352eb7229eabe18e5414aa4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o conf&lt;/code&gt; command has various bells and whistles:</source>
          <target state="translated">У команды &lt;code&gt;o conf&lt;/code&gt; есть различные навороты:</target>
        </trans-unit>
        <trans-unit id="20b61e97734fd2f3d96ceb929809c05aaac0cfef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &quot;&lt;code&gt;foo&lt;/code&gt;&quot;, and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;/g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d6fb5846e3f0194a9a7d71677ca6c483145c33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &lt;code&gt;'foo'&lt;/code&gt; , and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;*&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;//g&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;o?&lt;/code&gt; совпадает с началом &lt;code&gt;'foo'&lt;/code&gt; , и поскольку позиция в строке не перемещается совпадением, &lt;code&gt;o?&lt;/code&gt; будет совпадать снова и снова из-за квантификатора &lt;code&gt;*&lt;/code&gt; . Другой распространенный способ создания подобного цикла - использование модификатора цикла &lt;code&gt;//g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8add6c5a9ee20cf8238a46e09a0cd46fe0b061c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; аргумент хранится в &lt;code&gt;mg_obj&lt;/code&gt; поле &lt;code&gt;MAGIC&lt;/code&gt; структуры. Если он не совпадает с аргументом &lt;code&gt;sv&lt;/code&gt; , счетчик ссылок объекта &lt;code&gt;obj&lt;/code&gt; увеличивается. Если это то же самое, или если аргумент &lt;code&gt;how&lt;/code&gt; - &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , или если это указатель NULL, тогда &lt;code&gt;obj&lt;/code&gt; просто сохраняется без увеличения счетчика ссылок.</target>
        </trans-unit>
        <trans-unit id="dca84bbcee637e6ee5a3f3b53c079982ba47b456" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdatum&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdata&lt;/code&gt;, or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80e9ad5ac5b4640a379da6ded2e4e7da8ef85d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="translated">В &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , и &lt;code&gt;loaded-file&lt;/code&gt; были добавлены зонды.</target>
        </trans-unit>
        <trans-unit id="f888b5670cd3a579164b6986631d6a361f670ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt;, &lt;code&gt;loading-file&lt;/code&gt;, and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6cb40ac71f3af050d6baa8551cc82228d3a4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;open(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1d994756f4894d537087cc5686928a7d382dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (previously known as &quot;disciplines&quot;) for all I/O. Any open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults via the &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb381293ba1d62c6bb1f8b641a8f8c1b0afc8bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ord&lt;/code&gt; and &lt;code&gt;chr&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df48f02864fb5733b7bb66ec5f70b228889d68c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;os_unsupported()&lt;/code&gt; function provides a way to correctly exit your &lt;code&gt;Makefile.PL&lt;/code&gt; before calling &lt;code&gt;WriteMakefile&lt;/code&gt;. It is essentially a &lt;code&gt;die&lt;/code&gt; with the message &quot;OS unsupported&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6e73c286e870319f1bf5046f6a37ff92d8c6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overloading&lt;/code&gt; pragma can be used to enable or disable overloaded operations within a lexical scope - see &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;overloading&lt;/code&gt; прагма может использоваться для включения или отключения перегруженные операции в рамках лексической сферы - см &lt;a href=&quot;overloading&quot;&gt;перегрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20efdbd26d83eb3c5a0a6712c2d992c599e01133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d5bf30a5d50f38a10cfc2d7578244917da917c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">В &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;P&lt;/code&gt; форматы следует использовать с осторожностью. Поскольку Perl не имеет возможности проверить, соответствует ли значение, переданное в &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; , допустимому месту в памяти, передача неизвестного значения указателя может иметь катастрофические последствия.</target>
        </trans-unit>
        <trans-unit id="edad35170db1a049ca495222b3c0b5b8c415db1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">В &lt;code&gt;p&lt;/code&gt; и &lt;code&gt;P&lt;/code&gt; форматы следует использовать с осторожностью. Поскольку Perl не имеет возможности проверить, соответствует ли значение, переданное в &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; , допустимому месту в памяти, передача неизвестного значения указателя может иметь катастрофические последствия.</target>
        </trans-unit>
        <trans-unit id="bc14cc8e3b01ab283787dc8c289608a88dca9ea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;; similarly with &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, where a null pointer unpacks into &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a342dbe90eb2666a6875f71f1fa1cb3e6e7241a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Формат &lt;code&gt;p&lt;/code&gt; упаковывает указатель на строку с завершающим нулем. Вы несете ответственность за то, чтобы строка не была временным значением, поскольку она потенциально может быть освобождена до того, как вы дойдете до использования упакованного результата. Формат &lt;code&gt;P&lt;/code&gt; упаковывает указатель на структуру размера, указанного длиной. Нулевой указатель создается, если соответствующее значение для &lt;code&gt;p&lt;/code&gt; или &lt;code&gt;P&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ; аналогично с unpack (), где нулевой указатель распаковывается в &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e0e3d979b5c34967b7ced67a74a5510cb236cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Формат &lt;code&gt;p&lt;/code&gt; упаковывает указатель на строку с завершающим нулем. Вы несете ответственность за то, чтобы строка не была временным значением, поскольку она потенциально может быть освобождена до того, как вы дойдете до использования упакованного результата. Формат &lt;code&gt;P&lt;/code&gt; упаковывает указатель на структуру размера, указанного длиной. Нулевой указатель создается, если соответствующее значение для &lt;code&gt;p&lt;/code&gt; или &lt;code&gt;P&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ; аналогично с unpack (), где нулевой указатель распаковывается в &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd57772719120a4cc44e7170b8984f064c5142a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="translated">Параметр &lt;code&gt;paren&lt;/code&gt; будет равен &lt;code&gt;1&lt;/code&gt; для &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; для &lt;code&gt;$2&lt;/code&gt; и т. Д. И будет иметь следующие символьные значения для специальных переменных:</target>
        </trans-unit>
        <trans-unit id="02d079f599dacaf5683c95e116afdd6471bd3c7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d81fd54d838a03f6a557d9a972a797c3d53d12e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse()&lt;/code&gt; method takes in anything that might be a version and returns a corresponding version object, doing any necessary conversion along the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc153b0fac70aafae4ce7fa649dc1cbd578affc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass*&lt;/code&gt; and &lt;code&gt;fail*&lt;/code&gt; are optimal if they meet your situation, using one of them will always be the most optimal. That said they are optimal by eliminating many features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49927bc872809a6862bb2b73a995c90fcc3d0b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two &lt;code&gt;char*&lt;/code&gt; indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</source>
          <target state="translated">Параметр &lt;code&gt;pattern&lt;/code&gt; - это скаляр, который использовался в качестве шаблона. Предыдущие версии Perl передавали два &lt;code&gt;char*&lt;/code&gt; указывающих начало и конец строкового шаблона; следующий фрагмент можно использовать для получения старых параметров:</target>
        </trans-unit>
        <trans-unit id="db17bf3bf687b24a2fdb5945dac7eff0732c46a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl&lt;/code&gt; related one will be matched against &lt;code&gt;$^X&lt;/code&gt; (but with the absolute path).</source>
          <target state="translated">&lt;code&gt;perl&lt;/code&gt; связаны один будет сравниваться с &lt;code&gt;$^X&lt;/code&gt; (но с абсолютным путем).</target>
        </trans-unit>
        <trans-unit id="5f5ee6756d1fcb64032b91cf7b890baca1e81e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl_alloc&lt;/code&gt; and &lt;code&gt;perl_clone&lt;/code&gt; API functions will automatically set the TLS slot to the interpreter they created, so that there is no need to do anything special if the interpreter is always accessed in the same thread that created it, and that thread did not create or call any other interpreters afterwards. If that is not the case, you have to set the TLS slot of the thread before calling any functions in the Perl API on that particular interpreter. This is done by calling the &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; macro in that thread as the first thing you do:</source>
          <target state="translated">В &lt;code&gt;perl_alloc&lt;/code&gt; и &lt;code&gt;perl_clone&lt;/code&gt; функции API автоматически устанавливает слот TLS для интерпретатора , который они создали, так что нет необходимости делать что - нибудь особенное , если интерпретатор всегда доступен в том же потоке , который создал его, и этот поток не создавал или вызова любые другие переводчики впоследствии. Если это не так, вы должны установить слот TLS потока перед вызовом каких-либо функций в Perl API на этом конкретном интерпретаторе. Это делается путем вызова макроса &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; в этом потоке как первое, что вы делаете:</target>
        </trans-unit>
        <trans-unit id="97a02a3c258cf1103ffa6170e07625f674c4d40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perldoc&lt;/code&gt; command line tool is part of the standard Perl distribution. To read the perlfaq:</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; инструмент командной строки является частью стандартного дистрибутива Perl. Чтобы прочитать perlfaq:</target>
        </trans-unit>
        <trans-unit id="50ad124de63dc48f75c0f2545fa281fab8aa3db8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phase-change&lt;/code&gt; probe was added.</source>
          <target state="translated">&lt;code&gt;phase-change&lt;/code&gt; добавл ли зонд.</target>
        </trans-unit>
        <trans-unit id="04bb003d93ac0037aab6a2f453c58a6ac0c41912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugin_list&lt;/code&gt; configuration parameter holds a list of strings of the form</source>
          <target state="translated">&lt;code&gt;plugin_list&lt;/code&gt; параметр конфигурации содержит список строк вида</target>
        </trans-unit>
        <trans-unit id="a0b743645c5c1c48eeb64bb89437f58e73a4be52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;port&lt;/code&gt; argument is only valid for a udp, tcp or stream ping, and will not do what you think it does. ping returns true when we get a &quot;Connection refused&quot;! The default is the echo port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63eacc1cc33a9d0218e84fb4e04a60cb849a989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt; . When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="translated">&lt;code&gt;pp_tie&lt;/code&gt; делает &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , , а затем начинается второй цикл runops , чтобы выполнить тело &lt;code&gt;TIEARRAY&lt;/code&gt; . Когда он выполняет операцию ввода в строке 3, &lt;code&gt;CATCH_GET&lt;/code&gt; имеет значение true, поэтому &lt;code&gt;pp_entertry&lt;/code&gt; вызывает &lt;code&gt;docatch&lt;/code&gt; , который выполняет &lt;code&gt;JMPENV_PUSH&lt;/code&gt; и запускает третий цикл runops, который затем выполняет команду die op. На данный момент стек вызовов C выглядит так:</target>
        </trans-unit>
        <trans-unit id="158d812c1686b0935b414c31c5100461991aaa3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt;, then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt;. When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfe7fb594151a128519964cf51c5b075b56f64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prereqs&lt;/code&gt; key in the top-level metadata and within &lt;code&gt;optional_features&lt;/code&gt; define the relationship between a distribution and other packages. The prereq spec structure is a hierarchical data structure which divides prerequisites into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6012284b93fc2045dcbcea769da43a4a9d853f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prompt()&lt;/code&gt; function provides an easy way to request user input used to write a makefile. It displays the $message as a prompt for input. If a $default is provided it will be used as a default. The function returns the $value selected by the user.</source>
          <target state="translated">Функция &lt;code&gt;prompt()&lt;/code&gt; предоставляет простой способ запросить пользовательский ввод, используемый для записи make-файла. Он отображает сообщение $ как приглашение для ввода. Если указан $ default, он будет использоваться по умолчанию. Функция возвращает значение $, выбранное пользователем.</target>
        </trans-unit>
        <trans-unit id="251a318ac7ae399ceb208b84bc39666205a2a077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test suite run.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; команду поддерживает &lt;code&gt;--state&lt;/code&gt; параметр , который указывает , что для сохранения устойчивого состояния через пробегов. Этот модуль инкапсулирует результаты для одного запуска набора тестов.</target>
        </trans-unit>
        <trans-unit id="225b0b123ca124089a53e65a14a10e06fffd421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; команду поддерживает &lt;code&gt;--state&lt;/code&gt; параметр , который указывает , что для сохранения устойчивого состояния через пробегов. Этот модуль инкапсулирует результаты одного теста.</target>
        </trans-unit>
        <trans-unit id="630214733172c835a26947747354eba32ad3911c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module implements that state and the operations that may be performed on it.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; команду поддерживает &lt;code&gt;--state&lt;/code&gt; параметр , который указывает , что для сохранения устойчивого состояния через пробегов. Этот модуль реализует это состояние и операции, которые могут быть выполнены с ним.</target>
        </trans-unit>
        <trans-unit id="ebc7b6c659bfd339fe90d4f36223bdf0f00d2207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qr//&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;map&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a8c0b3ff5aa42089f6c9d44d37572f7b89a880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee1aae608f6953af89e472ae38b6d9068b7d8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt; for more detail.</source>
          <target state="translated">Прагма &lt;code&gt;re '/flags'&lt;/code&gt; (введенная в Perl 5.14) включает указанные флаги регулярного выражения до конца лексической области видимости. См. &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;Режим '/ flags' в re&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="8026b2e7b59b6835c618b76fac10379af835df78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabbdc8a005d2bf3f21650b9e863366189c7ced7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recent&lt;/code&gt; command downloads a list of recent uploads to CPAN and displays them</source>
          <target state="translated">&lt;code&gt;recent&lt;/code&gt; команда загружает список последних загрузок в CPAN и отображает их</target>
        </trans-unit>
        <trans-unit id="3ae27e036bb44d621cb68002f9a110e07c700371" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recipient&lt;/code&gt; method can also pass additional case-sensitive OPTIONS as an anonymous hash using key and value pairs. Possible options are:</source>
          <target state="translated">Метод &lt;code&gt;recipient&lt;/code&gt; также может передавать дополнительные ОПЦИИ, чувствительные к регистру, в виде анонимного хэша, используя пары ключ и значение. Возможные варианты:</target>
        </trans-unit>
        <trans-unit id="fbfa5e6131ec26898b29be346c8692d308b580c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;redo&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;continue&lt;/code&gt; block, if any, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6b672315250ddc806f0b1d734bf40a266a6de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt; .</source>
          <target state="translated">Структура &lt;code&gt;regexp&lt;/code&gt; описанная в &lt;a href=&quot;perlreapi&quot;&gt;perlreapi,&lt;/a&gt; является общей для всех движков регулярных выражений. Два его поля предназначены для частного использования обработчиком регулярных выражений, который скомпилировал шаблон. Это члены &lt;code&gt;intflags&lt;/code&gt; и pprivate. &lt;code&gt;pprivate&lt;/code&gt; является недействительным указателем на произвольную структуру, использование которых и управление является ответственностью компилирования двигателя. perl никогда не изменит ни одно из этих значений. В случае стандартного движка структура, на которую указывает &lt;code&gt;pprivate&lt;/code&gt; , называется &lt;code&gt;regexp_internal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d7f5d7cf7b3bd50ec33b3f8b3d3e3e1b16ccb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e74666fabd3ef514f919b776494b74805eeb39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; method allows for the registration of a message handler for a given subroutine. The full subroutine name including the package should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f7500531b634ca33f77ec64b4dcfc7b5a94686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_status&lt;/code&gt; field &lt;b&gt;must&lt;/b&gt; have one of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2292ba9ae057df1902ceef2446c66c533b62b3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -r&lt;/code&gt; or &lt;code&gt;del /s&lt;/code&gt; on Windows.</source>
          <target state="translated">Функция &lt;code&gt;remove_tree&lt;/code&gt; удаляет указанные каталоги и все файлы и подкаталоги, которые они могут содержать, подобно команде Unix &lt;code&gt;rm -r&lt;/code&gt; или &lt;code&gt;del /s&lt;/code&gt; в Windows.</target>
        </trans-unit>
        <trans-unit id="f1fcc73f0626aba933df61d1eca5f7c5f0df238b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -rf&lt;/code&gt; or the Windows commands &lt;code&gt;rmdir /s&lt;/code&gt; and &lt;code&gt;rd /s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f800b61fba3cbdc9dbaf2d3127156f3c10c2be33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; command temporarily turns on the &lt;code&gt;test_report&lt;/code&gt; config variable, then runs the &lt;code&gt;force test&lt;/code&gt; command with the given arguments. The &lt;code&gt;force&lt;/code&gt; pragma reruns the tests and repeats every step that might have failed before.</source>
          <target state="translated">Команда &lt;code&gt;report&lt;/code&gt; временно включает переменную конфигурации &lt;code&gt;test_report&lt;/code&gt; , а затем запускает команду &lt;code&gt;force test&lt;/code&gt; с заданными аргументами. &lt;code&gt;force&lt;/code&gt; Прагма вновь запускает тесты и повторяет каждый шаг , который , возможно, не удалось раньше.</target>
        </trans-unit>
        <trans-unit id="3e0418f790bb3ba77ebbb5b8be57ce758907a81a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request&lt;/code&gt; method returns a hashref containing the response. The hashref will have the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb965f28ada4d369f813e7b58370f45663a7e17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;requires&lt;/code&gt; and &lt;code&gt;build_requires&lt;/code&gt; dependency declarations</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; и &lt;code&gt;build_requires&lt;/code&gt; зависимостей деклараций</target>
        </trans-unit>
        <trans-unit id="6825adde139cbe709d6cacc6c4ea55d8ef7cff02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; function is called to generate a linearised ISA for the given stash, using this MRO. It is called with a pointer to the stash, and a</source>
          <target state="translated">Функция &lt;code&gt;resolve&lt;/code&gt; вызывается для генерации линеаризованного ISA для данного тайника с использованием этого MRO. Он вызывается с указателем на тайник, а</target>
        </trans-unit>
        <trans-unit id="20a1d55e5f69a55a8401c7bd274cec494c442203" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e85b7e6554a08b089b5049ccd1a608787302c15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;result_factory_class&lt;/code&gt; можно настроить, как описано в &lt;a href=&quot;#new&quot;&gt;новой&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ca2114e55ee9c4857e906508831f67273f52466" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;retrans&lt;/code&gt; argument the exponential backoff rate, default 1.2. It matches the $def_factor global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4f5cbea499bebe5f70cb857ce9ac77d66aaa7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rmtree()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;remove_tree()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;remove_tree()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6451f829e84fc9b2a12b294243486a8357dccdcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;roffitall&lt;/code&gt; utility is not installed on your system but lives in the</source>
          <target state="translated">&lt;code&gt;roffitall&lt;/code&gt; утилита не установлена на вашей системе , но живет в</target>
        </trans-unit>
        <trans-unit id="38bb81c7279e4123eea02d7b94773b0e43184b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; method returns 0 on success and a positive number on failure. See the section on EXIT CODES for details on the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec12f7a8b2d7f40a1c42ea8d991b557d8527791c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s///&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f11595235e0f9e5e74b59c34bf7ac4552157c76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send()&lt;/code&gt; method is used to issue an event to the hub. This method will handle thread/fork sync, filters, listeners, TAP output, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9411561fa33dd9a0d96df4e7b49fae524226bee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip(...)&lt;/code&gt; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features. The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is</source>
          <target state="translated">Функция &lt;code&gt;skip(...)&lt;/code&gt; предназначена для тестов, которые могут быть или не могут быть выполнены, в зависимости от наличия функций для конкретной платформы. Первый аргумент должен иметь значение true (подумайте &amp;laquo;да, пожалуйста, пропустите&amp;raquo;), если требуемая функция</target>
        </trans-unit>
        <trans-unit id="4dd34dc5f337a99adbdb95ed69eaa2b33a678e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smoke&lt;/code&gt; command takes the list of recent uploads to CPAN as provided by the &lt;code&gt;recent&lt;/code&gt; command and tests them all. While the command is running $SIG{INT} is defined to mean that the current item shall be skipped.</source>
          <target state="translated">Команда &lt;code&gt;smoke&lt;/code&gt; берет список последних загрузок в CPAN, предоставленный &lt;code&gt;recent&lt;/code&gt; командой, и проверяет их все. Пока команда выполняется, $ SIG {INT} означает, что текущий элемент должен быть пропущен.</target>
        </trans-unit>
        <trans-unit id="c81eca2265a8bfa89f7e2b8216b25f7468527582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt; , resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="translated">&lt;code&gt;socktype&lt;/code&gt; намек на getaddrinfo () фильтрует результаты , чтобы включать только один тип сокета и протокол. Без этого большинство операционных систем возвращают три комбинации для &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; и &lt;code&gt;SOCK_RAW&lt;/code&gt; , что приводит к трехкратному выводу адресов. &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; флаг getnameinfo () заставляет его возвращать обычный IP - адрес строки в формате, а не обратного решения его обратно в имя хоста.</target>
        </trans-unit>
        <trans-unit id="96db56547c2805160963104b9881650067bc074a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt;, resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03364b2c6aff3f77be6e48e31bc6fc170edb9637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb1bd48c372b36b030a4985fb7d0b8ecfff9314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; используется для создания &lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Источник&lt;/a&gt; , который передается в &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; , который , в свою очередь выясняет , как справиться с источником и создает &amp;lt;TAP :: Parser :: итератор&amp;gt; для него. Итератор используется анализатором для чтения в потоке TAP.</target>
        </trans-unit>
        <trans-unit id="92eb80578e9c5fa00cf858e0d3634beaaf8da658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; parameters are handled.</source>
          <target state="translated">Параметр &lt;code&gt;sources&lt;/code&gt; влияет на то , как обрабатываются параметры &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf38e3d7dde64637f98a88870a2d809b9706769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; parameters are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7630407dfd17260fb141bba76fd71474e26eb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split()&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;split /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt;, if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5429b24bd7773605c81ffce19b7803e3914ae70b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;my&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;sub { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a6aa9719696ddb8bff79a8c79538ca92e0d2e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strend&lt;/code&gt; and &lt;code&gt;patend&lt;/code&gt; pointers should point to the byte following the last character of each string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6e352d41818ff4bf26ca16e10b39452c55d91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma disables certain Perl expressions that could behave unexpectedly or are difficult to debug, turning them into errors. The effect of this pragma is limited to the current file or scope block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027d4af5bb9710fddfec7b10292492a3bd8321cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma is useful in avoiding such errors.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; прагма полезно избежать таких ошибок.</target>
        </trans-unit>
        <trans-unit id="bda6d4349e03cdc3822accb764cf2332f0d166cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct()&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;struct()&lt;/code&gt; функция</target>
        </trans-unit>
        <trans-unit id="7a95e760c73406947e7da7714b03782e42d5fa06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; function has three forms of parameter-list.</source>
          <target state="translated">Функция &lt;code&gt;struct&lt;/code&gt; имеет три формы списка параметров.</target>
        </trans-unit>
        <trans-unit id="4f0312b0e41bdaef162518003e58d7dd5119b5b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sub-entry&lt;/code&gt; and &lt;code&gt;sub-return&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e032455d26f301f9311f3905ad487e2683ae6647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX or if the status code is 304 (unmodified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f86ba3ab4dadf0c5969933e8badc4119d9d2f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8db9fbaa56d501321f36a7b37f026962feda33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supports_tables&lt;/code&gt; method should be true if the formatter supports directly rendering table data from the &lt;code&gt;info&lt;/code&gt; facets. This is a newer feature and many older formatters may not support it. When not supported the formatter falls back to rendering &lt;code&gt;detail&lt;/code&gt; instead of the &lt;code&gt;table&lt;/code&gt; data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2248434d315d7f4555ab09ed558fffeb25af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument is a pointer to the SV that is to acquire a new magical feature.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; аргумент является указателем на SV , который должен приобрести новую магическую функцию.</target>
        </trans-unit>
        <trans-unit id="3bd810d1cf1c18312d2c5eb1e03b023fe5ee01ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;&quot;Stashes and Globs&quot;&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1732cdeea04b3b5302655756ff012b4b97e760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Stashes and Globs&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; аргумент должен быть контрольное значение. В &lt;code&gt;stash&lt;/code&gt; аргумент определяет , какой класс ссылка будет принадлежать. См. &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Тайники и Глобусы&lt;/a&gt; для получения информации о преобразовании имен классов в тайники.</target>
        </trans-unit>
        <trans-unit id="3c426a5175e1475eb159d7aa2bfc10b9aeb2592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa9fb7196f50b878b4d2185150e32ef86a1a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">Функции &lt;code&gt;sv_cat*()&lt;/code&gt; недостаточно универсальны, чтобы работать со значениями, имеющими &amp;laquo;магию&amp;raquo;. См. Раздел &amp;laquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Волшебные виртуальные таблицы&amp;raquo;&lt;/a&gt; далее в этом документе.</target>
        </trans-unit>
        <trans-unit id="2ca2c3639e16b490b555d2489361f0871018a997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451bffe03c920b337c26d3f6c5c7b3d0a90a952c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">Функции &lt;code&gt;sv_set*()&lt;/code&gt; недостаточно универсальны, чтобы работать со значениями, имеющими &amp;laquo;магию&amp;raquo;. См. Раздел &amp;laquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Волшебные виртуальные таблицы&amp;raquo;&lt;/a&gt; далее в этом документе.</target>
        </trans-unit>
        <trans-unit id="a022ed577de5458a14b966f973f3ce2a62bb2a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817c94b76b6dd84c4c7d9bb171edda3a93d8445e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264e3c8ac2fdd944cc02ae92713944fc8cf6494f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="translated">&lt;code&gt;taint&lt;/code&gt; Прагма вызывает какие - либо подстроки из матча с испорченным переменным будут испорчена , а также. Обычно это не так, поскольку регулярные выражения часто используются для извлечения безопасных битов из испорченной переменной. Используйте &lt;code&gt;taint&lt;/code&gt; , когда вы не извлекаете безопасные биты, а выполняете другую обработку. Обе &lt;code&gt;taint&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; имеют лексическую область видимости, что означает, что они действуют только до конца блока, содержащего прагмы.</target>
        </trans-unit>
        <trans-unit id="45b556a65806a34a0370ae702153cb4405855fa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc9bc272d719ab5016869a769d84acd8ec8d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; and &lt;code&gt;finalize&lt;/code&gt; methods are optional methods called that you can implement if the format you're generating needs to handle these cases, for example if you are generating XML and need close open tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423cad30ef0048166a8eebe3340a46a30155372e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; method is called when an event's &lt;code&gt;terminate&lt;/code&gt; method returns true, for example when a &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2::Event::Plan&lt;/a&gt; has a &lt;code&gt;'skip_all'&lt;/code&gt; plan, or when a &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2::Event::Bail&lt;/a&gt; event is sent. The &lt;code&gt;terminate&lt;/code&gt; method is passed a single argument, the &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; object which triggered the terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e22b53957ab545ec5f1fe43f2463dbb75fb5bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test_diag&lt;/code&gt; function prepends comment hashes and spacing to the start and newlines to the end of the expected output passed to it and adds it to the list of expected error output. So, instead of writing</source>
          <target state="translated">Функция &lt;code&gt;test_diag&lt;/code&gt; добавляет хеши комментариев и интервалы к началу и новые строки к концу переданного ожидаемого вывода и добавляет его в список ожидаемых выводов ошибок. Итак, вместо того, чтобы писать</target>
        </trans-unit>
        <trans-unit id="9a044497bbeccf899d123e744ac60158148d66b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , or &lt;code&gt;HV*&lt;/code&gt; . The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt; , while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;thing&lt;/code&gt; аргумент может быть любой из &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; или &lt;code&gt;HV*&lt;/code&gt; . Эти функции идентичны , за исключением того &lt;code&gt;newRV_inc&lt;/code&gt; увеличивает счетчик ссылок на &lt;code&gt;thing&lt;/code&gt; , в то время как &lt;code&gt;newRV_noinc&lt;/code&gt; нет. По историческим причинам &lt;code&gt;newRV&lt;/code&gt; является синонимом &lt;code&gt;newRV_inc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39f6cd9542d25aca0f6da28dc2eb900530cd2e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt;, &lt;code&gt;AV*&lt;/code&gt;, or &lt;code&gt;HV*&lt;/code&gt;. The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt;, while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764690cb5a9a1e69711deb7f1d4bd7570cd33533" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; class method provides your program with a way to get an object representing the thread it's currently in. You can use this object in the same way as the ones returned from thread creation.</source>
          <target state="translated">Метод &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; предоставляет вашей программе способ получить объект, представляющий поток, в котором он сейчас находится. Вы можете использовать этот объект так же, как и те, которые возвращаются при создании потока.</target>
        </trans-unit>
        <trans-unit id="5cb77a0f1c56daabcc9daa1cb20e1afceca163c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tid&lt;/code&gt; method returns the tid of a thread. The tid is a monotonically increasing integer assigned when a thread is created. The main thread of a program will have a tid of zero, while subsequent threads will have tids assigned starting with one.</source>
          <target state="translated">Метод &lt;code&gt;tid&lt;/code&gt; возвращает tid потока. Tid - это монотонно возрастающее целое число, присваиваемое при создании потока. Главный поток программы будет иметь нулевое значение, тогда как последующим потокам будут назначены идентификаторы, начинающиеся с единицы.</target>
        </trans-unit>
        <trans-unit id="852bdb693d32a436b5f27ac2d4c29c14b07baed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tie&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt;. You may call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7906336a9d98d4a1cf6a79c6964edf2df1f812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time*_modern()&lt;/code&gt; subs do not do this year munging and simply take the year value as provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cae6d3e02f73d7641c7861d0693bc4b08d5c81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; functions perform range checking on the input $sec, $min, $hour, $mday, and $mon values by default.</source>
          <target state="translated">Функции &lt;code&gt;timelocal()&lt;/code&gt; и &lt;code&gt;timegm()&lt;/code&gt; выполняют проверку диапазона входных значений $ sec, $ min, $ hour, $ mday и $ mon.</target>
        </trans-unit>
        <trans-unit id="3444ad2f99e605827ac849ba41549cb93537c5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="translated">Функция &lt;code&gt;timelocal()&lt;/code&gt; реализована с использованием того же кеша. Мы просто предполагаем, что переводим время по Гринвичу, а затем подделываем его, когда закончим с аргументами о часовом поясе и переходе на летнее время. Обратите внимание, что часовой пояс оценивается для каждой даты, потому что страны иногда меняют свои официальные часовые пояса. Если предположить, что &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; исправляет эти изменения, эта процедура также будет правильной.</target>
        </trans-unit>
        <trans-unit id="d6031b9f93c7f0ead71810ff0ffcc9e88c83f87c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;localtime()&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e29c335d0e24d411a115fbcbdaff898b8a8cf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times()&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ddb341d5b31f6433cf87d10fae07c89fb702d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tmpnam&lt;/code&gt; function returns a unique string which can be used as a filename when creating temporary files. If, for some reason, it is unable to generate a name, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8678670162f30c825dc963303a8366061c0624" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr///&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;tr///CU&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;pack('U0', ...)&lt;/code&gt; and &lt;code&gt;pack('C0', ...)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1863d41e42c91ece1fce678f54e90a29e06de0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; alternative might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c010b9c38ee87dfd390ac847c9b0e002caa8d481" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; counts the null bytes. The &lt;code&gt;unpack&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;map&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accc9aa113f108f1f58344bb9d92f9dd409a973d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7969d03acba8ec22322bc524970a2e67bf531eeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be equal to the &lt;code&gt;how&lt;/code&gt; value when the &lt;code&gt;SV&lt;/code&gt; was initially made magical.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; аргумента должен быть равен &lt;code&gt;how&lt;/code&gt; значение , когда &lt;code&gt;SV&lt;/code&gt; был первоначально сделан волшебно.</target>
        </trans-unit>
        <trans-unit id="45b58766c7b5bfa7d8fbeea9c00e3139b61f934f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;man&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e37e784cf8826358b635a533d80412ae68521a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;url&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e605c3e8404b3b1569b2a8f6ee2a28bb09c8e25f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; шаблона &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; будет оказывать EBCDIC данных в EBCDIC символов эквивалентны их ASCII аналоги. Например, на компьютере ASCII или EBCDIC будет напечатано &quot;Да, действительно \ n&quot;:</target>
        </trans-unit>
        <trans-unit id="bcdcd5bf5921d41526775a635bdda4515bcae7f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;pack()&lt;/code&gt; or &lt;code&gt;unpack()&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0998cba5f7c7355370ef1940f9de1afcbe1199eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undef&lt;/code&gt; value is treated by this function as distinct from the empty string, and no warning will be produced. It is left as-is in the returned list. Subsequent &lt;code&gt;undef&lt;/code&gt; values are still considered identical to the first, and will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c83289af1a4c0f7e1129f103e79b7a1caa912f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;untie&lt;/code&gt; Gotcha</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1909f52d28496be25968c9641232bd70a050cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;up&lt;/code&gt; method increases the semaphore's count by the number specified (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">Метод &lt;code&gt;up&lt;/code&gt; увеличивает количество семафоров на указанное число (которое должно быть целым числом&amp;gt; = 1) или на единицу, если число не указано.</target>
        </trans-unit>
        <trans-unit id="3bfafbe930277e35ea02604239f7cd015c3326fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade&lt;/code&gt; command first runs an &lt;code&gt;r&lt;/code&gt; command with the given arguments and then installs the newest versions of all modules that were listed by that.</source>
          <target state="translated">Команда &lt;code&gt;upgrade&lt;/code&gt; сначала запускает команду &lt;code&gt;r&lt;/code&gt; с указанными аргументами, а затем устанавливает новейшие версии всех модулей, которые были перечислены при этом.</target>
        </trans-unit>
        <trans-unit id="ed2a8ecd68dda5352fc1303d01e5cd582863eba1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;urllist&lt;/code&gt; parameter of the configuration table contains a list of URLs used for downloading. If the list contains any &lt;code&gt;file&lt;/code&gt; URLs, CPAN always tries there first. This feature is disabled for index files. So the recommendation for the owner of a CD-ROM with CPAN contents is: include your local, possibly outdated CD-ROM as a &lt;code&gt;file&lt;/code&gt; URL at the end of urllist, e.g.</source>
          <target state="translated">Параметр &lt;code&gt;urllist&lt;/code&gt; таблицы конфигурации содержит список URL-адресов, используемых для загрузки. Если в списке есть URL-адреса &lt;code&gt;file&lt;/code&gt; , CPAN всегда пробует их первым. Эта функция отключена для индексных файлов. Таким образом, рекомендация для владельца компакт-диска с содержимым CPAN: включите локальный, возможно устаревший компакт-диск в качестве URL-адреса &lt;code&gt;file&lt;/code&gt; в конце списка URL-адресов, например</target>
        </trans-unit>
        <trans-unit id="52b900f042b9fdb4fefbfa11c5b63b7617ef4658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d475de0db7f66747e084c66e42ee75d8f3488116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use filetest&lt;/code&gt; or &lt;code&gt;no filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfbde926d15ce3b3022057fc9c74ed9c253c404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope. The &lt;code&gt;no utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope. (On EBCDIC platforms, technically it is allowing UTF-EBCDIC, and not UTF-8, but this distinction is academic, so in this document the term UTF-8 is used to mean both).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5989f0b30cb3c2f7f588b2b53bc0b52ccd653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468aa2690cfac4f39947fa49f9490387f38518f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::upgrade()&lt;/code&gt; aren't needed if the argument is above 0xFF, so the above could have been written as</source>
          <target state="translated">&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; и &lt;code&gt;utf8::upgrade()&lt;/code&gt; не требуется , если аргумент выше 0xFF, поэтому выше можно было бы записать в виде</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
