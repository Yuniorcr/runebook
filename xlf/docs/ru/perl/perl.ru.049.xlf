<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">При выборе новой соли создайте случайную двухсимвольную строку, символы которой берутся из набора &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (например, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). Этот набор символов является всего лишь рекомендацией; символы, разрешенные в соли, зависят исключительно от библиотеки crypt вашей системы, и Perl не может ограничить то, какие соли принимает &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">В сочетании с объявлением переменной простое скалярное присвоение переменным &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; (как в &lt;code&gt;state $x = 42&lt;/code&gt; ) выполняется только в первый раз. Когда такие операторы оцениваются последующие раз, присвоение игнорируется. Поведение такого типа присваивания нескалярным переменным не определено.</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">При сравнении &lt;code&gt;$]&lt;/code&gt; &lt;b&gt;настоятельно рекомендуется использовать&lt;/b&gt; операторы сравнения строк . Присущие двоичному представлению с плавающей запятой ограничения иногда могут приводить к неправильным сравнениям некоторых чисел на некоторых архитектурах.</target>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">При компиляции Perl в Tru64 можно (в зависимости от версии компилятора)увидеть два таких предупреждения</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">При компиляции Perl необходимо использовать компилятор ANSI C.AIX не поставляет ANSI совместимый компилятор C с AIX по умолчанию,но бинарные сборки gcc для AIX широко доступны.Версия gcc также включена в AIX Toolbox,который поставляется с AIX.</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">При компиляции Perl необходимо использовать компилятор ANSI C.AIX не поставляет ANSI совместимый C-компилятор с AIX по умолчанию,но бинарные сборки gcc для AIX широко доступны.</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">При компиляции Perl вы должны использовать компилятор ANSI C. Компилятор C, поставляемый со всеми системами HP-UX, является компилятором K&amp;amp;R, который следует использовать только для сборки новых ядер.</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">При компиляции в PASE нет команды &quot;oslevel&quot;.Поэтому вы можете создать скрипт под названием &quot;oslevel&quot;,повторяющий уровень AIX,поддерживаемый вашей версией PASE.Если вы не уверены,обратитесь к документации или используйте &quot;4.3.3.0&quot;.</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">При дополнении строк, если все символы имеют порядковые значения меньше 256, их дополнения также будут. Но если они этого не сделают, все символы будут либо в 32-, либо в 64-битных дополнениях, в зависимости от вашей архитектуры. Так, например, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; - это &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; на 32-битных машинах и &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; на 64-битных машинах.</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">При настройке для комплектации опции с одной символикой чувствительны к регистру,в то время как опции с длинной символикой не чувствительны к регистру.Чтобы односимвольные опции также не чувствительны к регистру,используйте их:</target>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">При создании и расширении прикладных программных интерфейсов (API)для Symbian или Серии 60 или Серии 80 или Серии 90 рекомендуется не использовать в названиях API товарные знаки,зарегистрированные товарные знаки или торговые наименования.Вместо этого разработчикам следует рассмотреть возможность основывать API-именование на существующем (C++,или,возможно,Java)общедоступном компоненте и API-именование,модифицированное в соответствии с правилами языка программирования,для которого предназначены новые API.</target>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">При работе со структурами C следует выбрать &lt;b&gt;T_PTROBJ&lt;/b&gt; или &lt;b&gt;T_PTRREF&lt;/b&gt; для типа XS. Оба типа предназначены для обработки указателей на сложные объекты. Тип T_PTRREF позволит объекту Perl не иметь благословения, в то время как тип T_PTROBJ требует, чтобы объект был благословлен. Используя T_PTROBJ, можно добиться определенной формы проверки типов, потому что XSUB будет пытаться проверить, что объект Perl имеет ожидаемый тип.</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При работе с двоичными файлами (или текстовыми файлами в двоичном режиме) не забудьте явно установить $ / на соответствующее значение для вашего формата файла перед использованием &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">Работая со ссылками, важно обращаться с ними осторожно. Блок &lt;code&gt;INIT:&lt;/code&gt; сначала вызывает SvGETMAGIC (пути), если paths является связанной переменной. Затем он проверяет, что &lt;code&gt;SvROK&lt;/code&gt; возвращает true, что указывает на то, что paths является допустимой ссылкой. (Простая проверка &lt;code&gt;SvROK&lt;/code&gt; не приведет к запуску FETCH для связанной переменной.) Затем он проверяет, что объект, на который ссылаются пути, является массивом, используя &lt;code&gt;SvRV&lt;/code&gt; для разыменования путей и &lt;code&gt;SvTYPE&lt;/code&gt; для определения его типа. В качестве дополнительного теста он проверяет, что массив, на который ссылаются пути, непустой, используя &lt;code&gt;av_top_index&lt;/code&gt; функция (которая возвращает -1, если массив пуст). Макрос XSRETURN_UNDEF используется для прерывания XSUB и возврата неопределенного значения, если все три из этих условий не выполняются.</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">При работе со строками, содержащими символы, которые не могут быть представлены с помощью восьмибитного набора символов, perl использует внутреннее представление, которое является разрешающей версией кодировки Unicode UTF-8 [2]. При этом используются одиночные байты для представления символов из набора символов ASCII и последовательности из двух или более байтов для всех остальных символов. (См. &lt;a href=&quot;perlunitut&quot;&gt;Perlunitut&lt;/a&gt; для получения дополнительной информации о взаимосвязи между UTF-8 и кодировкой perl, utf8. Разница не важна для этого обсуждения.)</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">При отладке скрипта, использующего #! и, таким образом, обычно находится в $ PATH, опция -S заставляет perl искать его в $ PATH, поэтому вам не нужно вводить путь или имя &lt;code&gt;which $scriptname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">При определении нескольких констант нельзя использовать значения других констант,определенных в том же объявлении.Это происходит потому,что вызывающий пакет не знает ни о каких константах внутри этой группы до тех пор,пока</target>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">При разработке интерфейса между Perl и библиотекой C часто бывает достаточно прямого перевода с C на XS (например, созданного с помощью &lt;code&gt;h2xs -x&lt;/code&gt; ). Однако иногда интерфейс будет выглядеть очень похожим на C, а иногда и не интуитивно понятным, особенно когда функция C изменяет один из своих параметров или возвращает ошибку внутри диапазона (например, &amp;laquo;отрицательные возвращаемые значения означают отказ&amp;raquo;). В случаях, когда программист желает создать интерфейс, более похожий на Perl, следующая стратегия может помочь определить наиболее важные части интерфейса.</target>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">При разработке интерактивных и/или потенциально долговременных приложений лучше поддерживать постоянный интерпретатор,чем многократно выделять и конструировать новый интерпретатор.Основной причиной является скорость:так как Perl будет загружаться в память только один раз.</target>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">При программировании на XS/Symbian C++сначала включаются заголовки Symbian,затем любые стандартные заголовки C/POSIX,затем заголовки Perl и,наконец,любые заголовки приложений.</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">При загрузке с CPAN сохраняйте файл с расширением &lt;code&gt;.tgz&lt;/code&gt; вместо &lt;code&gt;.tar.gz&lt;/code&gt; . Все остальные точки в имени файла следует заменить подчеркиванием. Например, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; следует загрузить как &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">Когда Perl вызывает каждый фильтр, локальная копия &lt;code&gt;$_&lt;/code&gt; будет содержать ключ или значение, которое нужно отфильтровать. Фильтрация достигается путем изменения содержимого &lt;code&gt;$_&lt;/code&gt; . Код возврата из фильтра игнорируется.</target>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">При квантификации встроенного кода,успешные совпадения будут вызывать код один раз для каждой соответствующей итерации квантификатора.Например:</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">При оценке typeglob создает скалярное значение, которое представляет все объекты с этим именем, включая любой дескриптор файла, формат или подпрограмму. При назначении он заставляет указанное имя ссылаться на любое &lt;code&gt;*&lt;/code&gt; значение, которое ему было присвоено. Пример:</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">При вызове функции exec()внутри псевдо-процесса методы DESTROY и блоки END все равно будут вызываться после возврата внешнего процесса.</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">Когда выполнение программы достигает вызова подпрограммы, вызов &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">Когда выполнение программы использует &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; для входа в подпрограмму, отличную от XS, и бит 0x80 установлен в &lt;code&gt;$^P&lt;/code&gt; , выполняется вызов &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; , при этом &lt;code&gt;$DB::sub&lt;/code&gt; содержит имя вводимой подпрограммы.</target>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">Когда выходной код ненулевой,появляется окно с сообщением,в противном случае консоль закрывается,так что вам,возможно,придется поймать выход со статусом 0 в вашей программе,чтобы увидеть любой выход.</target>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">Когда используются хэши полей, основная структура остается той же. Каждый лексический хеш будет сделан хешем поля. Вызов &lt;code&gt;refaddr&lt;/code&gt; можно опустить в методах доступа. Методы DESTROY и CLONE не нужны.</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">При нахождении программы для запуска Perl сначала просит ОС искать исполняемые файлы в &lt;code&gt;PATH&lt;/code&gt; (OS / 2 добавляет расширение</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">По завершении &lt;code&gt;$input&lt;/code&gt; будет полностью обработан (при условии, что ошибок не было). Если дефляция прошла успешно, она записывает дефлированные данные в &lt;code&gt;$output&lt;/code&gt; и возвращает значение статуса &lt;code&gt;Z_OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">Если за ним следует BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; на самом деле является оператором управления потоком, а не функцией. Если к BLOCK прикреплен блок &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; (обычно через &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;foreach&lt;/code&gt; ), он всегда выполняется непосредственно перед тем, как условие будет снова вычислено, как и третья часть цикла &lt;code&gt;for&lt;/code&gt; в C. используется для увеличения переменной цикла, даже если цикл был продолжен с помощью &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператора (который похож на оператор &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; в C ).</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">Если за ним следует BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; на самом деле является оператором управления потоком, а не функцией. Если к BLOCK прикреплен блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; (обычно через &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;foreach&lt;/code&gt; ), он всегда выполняется непосредственно перед тем, как условие будет снова вычислено, как и третья часть цикла &lt;code&gt;for&lt;/code&gt; в C. используется для увеличения переменной цикла, даже если цикл был продолжен с помощью &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператора (который похож на оператор &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; в C ).</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">Когда функции в исходном файле XS должны быть разделены на пакеты,следует использовать ключевое слово PACKAGE.Это ключевое слово используется с ключевым словом MODULE и должно следовать сразу после его использования.</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">При задании неоднозначного локального времени функция timelocal()должна всегда возвращать эпоху для функции</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">При обработке выходных параметров с помощью секции PPCODE убедитесь, что правильно обработали магию &amp;laquo;set&amp;raquo;. См. Подробности о магии &amp;laquo;установки&amp;raquo; в &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">В случае сомнений заключите в скобки. По крайней мере, это позволит какому-нибудь бедняге прыгнуть по клавише% в &lt;b&gt;vi&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">В случае сомнений запустите конструкцию &lt;b&gt;awk&lt;/b&gt; через &lt;b&gt;a2p&lt;/b&gt; и посмотрите, что она вам даст.</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">Когда сомневаешься,ты можешь использовать</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">При вызове как &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; следующие параметры:</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">При вызове как &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; следующие параметры:</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">При вызове с использованием одной строки &lt;b&gt;parseopts&lt;/b&gt; обрабатывает строку как имя параметра синтаксического анализа и возвращает соответствующее значение, если оно существует (возвращает &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если нет).</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">При вызове с несколькими аргументами &lt;b&gt;parseopts&lt;/b&gt; обрабатывает их как пары ключ / значение, а указанные имена параметров синтаксического анализа устанавливаются на заданные значения. Любые неуказанные параметры синтаксического анализа не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">При вызове без дополнительных аргументов &lt;b&gt;parseopts&lt;/b&gt; возвращает хеш- &lt;b&gt;таблицу&lt;/b&gt; всех текущих параметров синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">При вызове с параметрами принимаются следующие и необязательные:</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">Когда шут не шут?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">Когда он появляется по отдельности, он приводит к совпадению последовательностей &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; и классов символов Posix только в диапазоне ASCII. Таким образом, они возвращаются к своим значениям до 5.6 и до Unicode. Под &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; всегда означает именно цифры &lt;code&gt;&quot;0&quot;&lt;/code&gt; до &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; означает пять символов &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , а начиная с Perl v5.18, вертикальная табуляция; &lt;code&gt;\w&lt;/code&gt; означает 63 символа &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; и аналогично, все классы Posix, такие как &lt;code&gt;[[:print:]]&lt;/code&gt; , соответствуют только соответствующим символам диапазона ASCII.</target>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">Когда дело доходит до компромиссов во времени,Perl почти всегда предпочитает бросать память в проблему.Скаляры в Perl используют больше памяти,чем строки в C,массивы берут больше,а хэши используют еще больше.Хотя еще многое предстоит сделать,в последних релизах эти проблемы были решены.Например,начиная с версии 5.004,дубликаты хэш-ключей разделяются между всеми хэшами,использующими их,поэтому не требуют перераспределения.</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">Когда дело доходит до неопределенных переменных, которые вызывают предупреждение при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , вы можете преобразовать предупреждение в ошибку.</target>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">Когда он сходится,вы получаете функциональный вариант</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">Когда он запускается,отладчик читает ваш rc-файл (</target>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">Когда элементы сталкиваются в заданном хеш-ведре, порядок, в котором они хранятся в цепочке, больше не предсказуем в Perl 5.18. Это сделано для того, чтобы усложнить наблюдение за столкновением. Это поведение можно переопределить с помощью переменной среды PERL_PERTURB_KEYS, см. &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS в perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">При загрузке &lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt; вы должны &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; перед тем, как &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . ( &lt;code&gt;threads&lt;/code&gt; выдадут предупреждение, если вы сделаете это наоборот.)</target>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">При поиске &lt;code&gt;DBD::Oracle&lt;/code&gt; относительно пути поиска мы должны найти</target>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">При присвоении имени вашему модулю учитывайте следующее:</target>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">Если для параметра не указано место назначения, GetOptions сохранит результирующее значение в глобальной переменной с именем &lt;code&gt;opt_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">Если не &lt;code&gt;NULL&lt;/code&gt; , функция, на которую указывает эта переменная, будет вызываться каждый раз, когда OP освобождается с соответствующим OP в качестве аргумента. Это позволяет расширениям освобождать любые дополнительные атрибуты, которые они локально прикрепили к OP. Также гарантируется, что сначала сработает родительский OP, а затем его дочерние элементы.</target>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">Когда ненулевое значение этого параметра заставит bzip2 использовать алгоритм декомпрессии,который использует меньше памяти за счет увеличения времени,затрачиваемого на декомпрессию.</target>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">Когда open () получает явный список слоев (с синтаксисом с тремя аргументами), они переопределяют список, объявленный с помощью этой прагмы. open () также можно дать одно двоеточие (:) для имени слоя, чтобы переопределить эту прагму и использовать значение по умолчанию ( &lt;code&gt;:raw&lt;/code&gt; в Unix &lt;code&gt;:crlf&lt;/code&gt; в Windows).</target>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">При открытии для записи в пустые части файла будут записаны NULL (0x00)байт.</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">При открытии файла редко бывает хорошей идеей продолжить, если запрос не удался, поэтому &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; часто используется с &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Даже если &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; не будет делать то, что вы хотите (скажем, в сценарии CGI, где вы хотите отформатировать подходящее сообщение об ошибке (но есть модули, которые могут помочь с этой проблемой)), всегда проверяйте возвращаемое значение при открытии файла.</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">При открытии файла редко бывает хорошей идеей продолжить, если запрос не удался, поэтому &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; часто используется с &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Даже если &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; не будет делать то, что вы хотите (скажем, в сценарии CGI, где вы хотите отформатировать подходящее сообщение об ошибке (но есть модули, которые могут помочь с этой проблемой)), всегда проверяйте возвращаемое значение при открытии файла.</target>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">Когда передается одна ссылка на хэш, &lt;b&gt;parseopts&lt;/b&gt; использует этот хеш для полного сброса существующих параметров синтаксического анализа, все предыдущие значения параметров синтаксического анализа теряются.</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">Когда Perl начинает синтаксический анализ любой блочной конструкции, которая обеспечивает лексическую область видимости (например, тело eval, требуемый файл, тело подпрограммы, тело цикла или условный блок), существующее значение &lt;code&gt;$^H&lt;/code&gt; сохраняется, но его значение остается неизменным. Когда компиляция блока завершена, он восстанавливает сохраненное значение. Между точками , где сохраняется его значение и восстановленными, код , который выполняется в пределах НАЧАТЬ блоков может свободно изменять значение &lt;code&gt;$^H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">Когда perl выполняет что-то вроде &lt;code&gt;addop&lt;/code&gt; , как он передает свои результаты следующей операции? Ответ заключается в использовании стеков. Perl имеет несколько стеков для хранения вещей, над которыми он сейчас работает, и мы рассмотрим три наиболее важных из них.</target>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">Когда Perl выполняет выражение &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; , он транслирует вызовы &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; в библиотеке времени выполнения C и оттуда в ядро ​​операционной системы. perl устанавливает &lt;code&gt;$!&lt;/code&gt; для библиотеки C в &lt;code&gt;errno&lt;/code&gt; , если один из этих вызовов не удается.</target>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">Когда perl скомпилирован с поддержкой отладки отпечатков памяти (по умолчанию с Perl's malloc()),Devel::Peek предоставляет доступ к этому API.</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">Когда perl настроен на использование ithreads, он будет использовать вызовы библиотеки с повторным входом вместо нереентрантных версий. В функции &lt;code&gt;readdir_r&lt;/code&gt; FreeBSD в версиях 4.5 и более ранних есть ошибка, которая может вызывать SEGV при чтении больших каталогов. Доступен патч для FreeBSD libc (см. &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;Http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ), интегрированный во FreeBSD 4.6.</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">Если этот параметр присутствует, то количество сжатых байтов, считываемых из входного файла / буфера, ограничивается &lt;code&gt;$size&lt;/code&gt; . Эту опцию можно использовать в ситуации, когда полезные данные находятся непосредственно после потока сжатых данных, и вы заранее знаете точную длину потока сжатых данных.</target>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">Когда предлагается что-то, что может иметь несколько различных интерпретаций, Perl использует &lt;b&gt;принцип DWIM&lt;/b&gt; (то есть &amp;laquo;Делай то, что я имею в виду&amp;raquo;), чтобы выбрать наиболее вероятную интерпретацию. Эта стратегия настолько успешна, что программисты Perl часто не подозревают об амбивалентности того, что они пишут. Но время от времени представления Perl существенно отличаются от того, что искренне имел в виду автор.</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">При печати сложное число обычно отображается под его картезианским стилем.</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">Когда появится запрос,выберите тему,в которой резюмируются ваши изменения.</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">При помещении элементов в &lt;code&gt;%^H&lt;/code&gt; , чтобы избежать конфликта с другими пользователями хеша, существует соглашение о том, какие ключи использовать. Модуль должен использовать только ключи, которые начинаются с имени модуля (имени его основного пакета) и символа &amp;laquo;/&amp;raquo;. Например, модуль &lt;code&gt;Foo::Bar&lt;/code&gt; должен использовать такие ключи, как &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">При чтении из файла или дескриптора &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; перед чтением установите режим bin .</target>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">При чтении из сокета помните, что разделителем входных записей по умолчанию &lt;code&gt;$/&lt;/code&gt; является &lt;code&gt;\n&lt;/code&gt; , но надежный код сокета распознает либо &lt;code&gt;\012&lt;/code&gt; либо &lt;code&gt;\015\012&lt;/code&gt; как конец строки:</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: AnyInflate будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: AnyUncompress будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Bunzip2 будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Gunzip будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Inflate будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: RawInflate будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Unzip будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">При ссылке &lt;code&gt;$!&lt;/code&gt; извлекает текущее значение целочисленной переменной C &lt;code&gt;errno&lt;/code&gt; . Если &lt;code&gt;$!&lt;/code&gt; присваивается числовое значение, это значение сохраняется в &lt;code&gt;errno&lt;/code&gt; . При ссылке на строку &lt;code&gt;$!&lt;/code&gt; выдает строку системной ошибки, соответствующую &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">При обращении к символам с использованием числового кода E &amp;lt;n&amp;gt; числа в диапазоне 32-126 относятся к тем хорошо известным символам US-ASCII (также определенным там с помощью Unicode с тем же значением), которые все средства форматирования Pod должны точно отображать . Символы, числа E &amp;lt;&amp;gt; которых находятся в диапазонах 0-31 и 127-159, не должны использоваться (ни как литералы, ни как коды E &amp;lt;number&amp;gt;), за исключением буквенных байтовых последовательностей для новой строки (ASCII 13, ASCII 13 10 или ASCII 10) и табуляции (ASCII 9).</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">При регистрации новых категорий предупреждений можно задавать больше имён для предупреждений::register подобным образом:</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">При удалении деревьев каталогов,если вы хотите просмотреть каждый файл,чтобы решить,следует ли его удалить (и,возможно,оставить большие мазки в покое),</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">При рендеринге Pod в формат,допускающий комментарии (т.е.практически в любой формат,отличный от простого текста),шаблон Pod должен вставить текст комментария с указанием его названия и номера версии,а также названия и номера версии любых модулей,которые он может использовать для обработки Pod.Минимальные примеры:</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">При переводе Pod в формат с двумя типами дефисов (-),один из которых является неразрывным дефисом,а другой-ломающимся дефисом (как в случае с &quot;объектно-ориентированным&quot;,который может быть разделен на линии как &quot;объектно-&quot;,newline,&quot;oriented&quot;),форматировщикам рекомендуется обычно переводить &quot;-&quot; в неразрывный дефис,но они могут применять эвристику для преобразования некоторых из них в ломающиеся дефисы.</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">При сообщении об ошибке,пожалуйста,пробегитесь по этому списку:</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">При сообщении об ошибках/проблемах указывайте как можно больше информации.Мне может быть трудно воспроизвести проблему,так как почти каждая установка отличается.</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">При разрешении запроса на глобальную DLL таблица уже загруженных конкретных DLL (фактически)игнорируется;кроме того,специфическими DLL являются</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">При возврате массива C в Perl &lt;code&gt;size_$var&lt;/code&gt; XS должен предоставить целочисленную переменную с именем size_ $ var, содержащую количество элементов в массиве. Это используется для определения того, сколько элементов следует поместить в стек возвращаемых аргументов. Это не требуется при вводе, поскольку Perl знает, сколько аргументов находится в стеке при вызове подпрограммы. Обычно эта переменная называется &lt;code&gt;size_RETVAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">При возврате результата,отличного от нулевого,тип возврата является релевантным.Если это АВ,то элементами АВ являются слабые эталонные АВ,которые указывают на данный пункт.Если речь идет о любом другом типе,то элемент сам по себе является слабой опорной точкой.</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">При округлении числа возможны различные &quot;стили&quot; или &quot;виды&quot; округления.(Обратите внимание,что случайное округление,как в математике::Round,не реализовано).</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">Когда он работает,он производит этот выход</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">При запуске скрипт выдаст это сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">При запуске &lt;code&gt;perl Makefile.PL&lt;/code&gt; в переменной среды &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; устанавливается полный путь к исполняемому &lt;code&gt;Makefile.PL&lt;/code&gt; . Это предотвращает неконтролируемые процессы в более новых версиях Module :: Install.</target>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">При выполнении проверок на наличие заражений, либо из-за того, что программа выполняла setuid или setgid, либо был указан переключатель &lt;b&gt;-T&lt;/b&gt; или &lt;b&gt;-t&lt;/b&gt; , ни PERL5LIB, ни PERLLIB не запрашиваются. Вместо этого программа должна сказать:</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">При запуске этой программы перенаправьте &lt;code&gt;STDOUT&lt;/code&gt; , чтобы можно было проверить правильность вывода при следующих тестовых запусках, и используйте служебную программу системного &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; для проверки общего времени выполнения.</target>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">При запуске под Eunice эта переменная содержит команду,которая преобразует скрипт оболочки в нужную форму текстового файла,чтобы он мог быть исполнен оболочкой.На других системах она не работает.</target>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">Когда действуют безопасные сигналы (поведение по умолчанию - см. &amp;laquo; &lt;a href=&quot;#Unsafe-signals&quot;&gt;Небезопасные сигналы&amp;raquo;&lt;/a&gt; для получения дополнительной информации), тогда сигналы могут отправляться и обрабатываться отдельными потоками.</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">Если результаты вас устраивают, повторно запустите цель &lt;code&gt;installcmd&lt;/code&gt; . Теперь вы можете скопировать &lt;code&gt;perl5.8.2.exe&lt;/code&gt; в &lt;code&gt;perl.exe&lt;/code&gt; и установить другие исполняемые файлы сборки OMF: &lt;code&gt;perl__.exe&lt;/code&gt; и т . Д. Они готовы к использованию.</target>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">При сохранении источника включайте исправления,которые не генерируют подпрограмм.</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">При сохранении исходного текста включайте исходный текст,который не компилировался.</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">При поиске односимвольных разделителей экранированные разделители и &lt;code&gt;\\&lt;/code&gt; пропускаются. Например, при поиске завершающего &lt;code&gt;/&lt;/code&gt; пропускаются комбинации &lt;code&gt;\\&lt;/code&gt; и &lt;code&gt;\/&lt;/code&gt; . Если разделители заключены в скобки, вложенные пары также пропускаются. Например, при поиске закрытия &lt;code&gt;]&lt;/code&gt; в паре с открывающим &lt;code&gt;[&lt;/code&gt; , все комбинации &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt; и &lt;code&gt;\[&lt;/code&gt; пропускаются, а также пропущены вложенные &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; . Однако, когда в качестве разделителей используются обратные косые черты (например, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; ) ничего не пропускается. Во время поиска конца удаляются обратные косые черты, избегающие разделителей или другие обратные косые черты (точнее говоря, они не копируются в безопасное место).</target>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">Если установлено значение &lt;code&gt;&quot;1&quot;&lt;/code&gt; или &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; ключи обхода будут рандомизированы. Каждый раз, когда в него вставляется хеш, порядок ключей будет изменяться случайным образом. Порядок может не повторяться при следующем запуске программы, даже если был указан PERL_HASH_SEED. Это режим по умолчанию для Perl.</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">Если установлено значение &lt;code&gt;&quot;2&quot;&lt;/code&gt; или &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; то вставка ключей в хэш приведет к изменению порядка клавиш, но таким образом, который будет повторяться от запуска программы к запуску программы.</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;remove_tree&lt;/code&gt; будет пропускать файлы, для которых процессу не хватает требуемых привилегий, необходимых для удаления файлов, таких как привилегии удаления в VMS. Другими словами, код не будет пытаться изменить права доступа к файлам. Таким образом, если процесс будет прерван, ни один объект файловой системы не останется в более разрешительном режиме.</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">При установке значения true,будут удалены все файлы и подкаталоги,за исключением изначально указанных каталогов.Это пригодится при очистке каталога приложений для удаления царапин.</target>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">Если установлено, Data :: Dumper будет выдавать одиночные, несамо-ссылочные значения в виде атомов / терминов, а не операторов. Это означает, что &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">Когда установлено,управляет тайм-аутом сети (отсчитывается в секундах).</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">Если установлено, позволяет использовать двойные кавычки для представления строковых значений. Пробелы, отличные от пробела, будут представлены как &lt;code&gt;[\n\t\r]&lt;/code&gt; , &amp;laquo;небезопасные&amp;raquo; символы будут иметь обратную косую черту, а непечатаемые символы будут выводиться как восьмеричные целые числа в кавычках. По умолчанию - 0.</target>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">Когда я должен декодировать или кодировать?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">Когда я не должен программировать на Перле?</target>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">Когда что-то содержится в чем-то другом, особенно когда это может показаться неожиданным: &amp;laquo;Я встроил в свой редактор полный интерпретатор Perl!&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">Говоря о регексуалах,необходимо различать их исходную и внутреннюю форму.В этом документе мы будем использовать термин &quot;образец&quot;,когда говорим об их текстовой,исходной форме,и термин &quot;программа&quot;,когда говорим об их внутреннем представлении.Они соответствуют терминам</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">Когда указано (локализовано)в модуле</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">При непосредственном запуске сценариев Perl использует тот же алгоритм, что и для поиска сценария, заданного параметром командной строки &lt;b&gt;-S&lt;/b&gt; : он будет искать в текущем каталоге, затем в компонентах &lt;code&gt;$ENV{PATH}&lt;/code&gt; используя следующий порядок добавления расширений : без расширения,</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">При хранении дубликатов в сетевом порядке их значение сохраняется в виде текста.Однако,не следует ожидать,что нечисловые значения с плавающей точкой,такие как бесконечность и &quot;не число&quot;,успешно пройдут через пару nstore()/retrieve().</target>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">При тестировании приложений часто возникает необходимость предоставить в тестовой среде функциональные возможности, которые обычно предоставляются внешними модулями. Вместо того, чтобы вручную настраивать &lt;code&gt;%INC&lt;/code&gt; , чтобы пометить эти внешние модули как загруженные, чтобы они не загружались Perl, этот модуль предлагает вам очень простой способ пометить модули как загруженные и / или выгруженные.</target>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">Когда эта строка компилируется из нотации в скобках в реальный Perl подуровень,она,по сути,превращается в:</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">Когда при преобразовании в %o задаются флаг#и точность,точность увеличивается,если это необходимо для ведущего &quot;0&quot;.</target>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">Если параметр &lt;code&gt;all&lt;/code&gt; опущен или равен false, то связанные хеш-элементы будут содержимым крайнего левого определенного буфера с именем связанного хеш-ключа. Другими словами, связанный хеш будет вести себя как &lt;code&gt;%+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;all&lt;/code&gt; параметр all , то связанные элементы хэша будут ссылками на массив, перечисляющими содержимое каждого буфера захвата, имя которого совпадает с именем связанного хеш-ключа. Если ни один из этих буферов не участвовал в сопоставлении, содержимое этого массива ref будет содержать столько значений &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , сколько имеется буферов захвата с таким именем. Другими словами, связанный хеш будет вести себя как &lt;code&gt;%-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">Когда &lt;code&gt;exUnix2&lt;/code&gt; опция exUnix2, она инициирует создание дополнительного поля Unix2 (ID - &amp;laquo;Ux&amp;raquo;) в локальном zip-заголовке. Это будет заполнено &lt;code&gt;$uid&lt;/code&gt; и &lt;code&gt;$gid&lt;/code&gt; . Пустое дополнительное поле Unix2 также будет создано в центральном заголовке zip-архива.</target>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">Когда &lt;code&gt;exUnixN&lt;/code&gt; опция exUnixN, она инициирует создание дополнительного поля UnixN (ID - &amp;laquo;ux&amp;raquo;) как в локальном, так и в центральном zip-заголовках. Это будет заполнено &lt;code&gt;$uid&lt;/code&gt; и &lt;code&gt;$gid&lt;/code&gt; . UID и GID хранятся как 32-битные целые числа.</target>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">Когда опция &lt;code&gt;frame&lt;/code&gt; установлена, отладчик будет печатать введенные (и, возможно, завершенные) подпрограммы в разных стилях. Смотрите на &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; невероятно длинные примеры таких.</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">Когда модуль CPAN используется в первый раз, диалог конфигурации пытается определить несколько специфичных для сайта опций. Результат диалога сохраняется в хеш-ссылке &lt;code&gt; $CPAN::Config &lt;/code&gt; в файле CPAN / Config.pm.</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">Когда оболочка CPAN входит в подоболочку с помощью команды look,она устанавливает окружение CPAN_SHELL_LEVEL в 1,или увеличивает эту переменную,если она уже установлена.</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">При запуске CPAN оболочки обычно отображается приветственное сообщение,содержащее запущенную версию и статус поддержки readline.</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">Когда SV читается или записывается в, &lt;code&gt;uf_val&lt;/code&gt; или &lt;code&gt;uf_set&lt;/code&gt; будет вызываться с &lt;code&gt;uf_index&lt;/code&gt; в качестве первого аргумента и указателем на SV в качестве второго. Ниже показан простой пример того, как добавить магию &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; . Обратите внимание, что структура ufuncs копируется sv_magic, поэтому вы можете безопасно разместить ее в стеке.</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">Когда механизм Storable не находит никакой &lt;code&gt;STORABLE_thaw&lt;/code&gt; ловушки STORABLE_thaw , он пытается загрузить класс, динамически запрашивая пакет (используя благословенное имя пакета), а затем повторно пытается выполнить поиск. Если в это время не удается определить местонахождение крюка, двигатель каркает. Обратите внимание, что этот механизм не сработает, если вы определите несколько классов в одном файле, но &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; вас предупредил.</target>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">Когда фактический статус завершения VMS дочернего элемента является ошибкой, внутри &lt;code&gt;$!&lt;/code&gt; будет установлено значение Errno Unix, ближайшее к этой ошибке, так что сценарии Perl, которые проверяют сообщения об ошибках, будут видеть ожидаемое сообщение об ошибке в стиле Unix вместо сообщения VMS.</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Когда аргументы выполняются через системную оболочку, результаты зависят от ее особенностей и возможностей. См. &quot; &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;STRING&quot; в perlop&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Когда аргументы выполняются через системную оболочку, результаты зависят от ее особенностей и возможностей. См. &quot; &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;STRING&quot; в perlop&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">Если класс должен соответствовать без учета регистра в соответствии с правилами сопоставления &lt;code&gt;/i&lt;/code&gt; , а символ, который явно упоминается внутри класса, соответствует многосимвольной последовательности без учета регистра в соответствии с правилами Unicode, класс также будет соответствовать этой последовательности. Например, Unicode говорит, что буква &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; должна соответствовать последовательности &lt;code&gt;ss&lt;/code&gt; согласно правилам &lt;code&gt;/i&lt;/code&gt; . Таким образом,</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">Когда код будет работать только на двух или трех операционных системах,может потребоваться учитывать только различия этих систем.Важно решить,где будет выполняться код,и быть взвешенным в своем решении.</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">При установке конфигурационной переменной ftp_passive все загрузки будут выполняться с установленным значением переменной окружения FTP_PASSIVE.В целом,это хорошая идея,так как она влияет на соединения,основанные на Net::FTP и LWP.Тот же эффект можно получить,запустив оболочку cpan с этим значением переменной окружения.Только для Net::FTP всегда можно установить пассивный режим,запустив libnetcfg.</target>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">Когда база данных содержит только UTF-8, функция или метод-оболочка - удобный способ заменить все ваши вызовы &lt;code&gt;fetchrow_array&lt;/code&gt; и &lt;code&gt;fetchrow_hashref&lt;/code&gt; . Функция оболочки также упростит адаптацию к будущим улучшениям в драйвере базы данных. Обратите внимание, что на момент написания этой статьи (январь 2012 г.) в DBI не было стандартизированного способа работы с данными UTF-8. Пожалуйста, проверьте &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;документацию DBI,&lt;/a&gt; чтобы убедиться, что это все еще правда.</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">Когда выполнение вашей программы достигает точки, которая может удерживать точку останова, вызывается подпрограмма &lt;code&gt;DB::DB()&lt;/code&gt; если любая из переменных &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; или &lt;code&gt;$DB::signal&lt;/code&gt; истинна. . Эти переменные не являются &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; izable. Эта функция отключена при выполнении внутри &lt;code&gt;DB::DB()&lt;/code&gt; , включая функции, вызываемые из него, если &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; не истинно.</target>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">Когда файл</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">Когда файлы,которые вы обрабатываете,маленькие,не имеет большого значения,как вы это делаете,но это имеет огромное значение,когда они начинают становиться больше.</target>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">Когда вызывается внутренняя подпрограмма,она будет видеть значение лексической подпрограммы внешней подпрограммы,как это было до и во время *первого*вызова внешней подпрограммы;в этом случае,после завершения первого вызова внешней подпрограммы,внутренняя и внешняя подпрограммы больше не будут иметь общего значения для лексической подпрограммы.Другими словами,она больше не будет общей.Это особенно важно,если лексическая подпрограмма обращается к лексическим переменным,объявленным в окружающем ее пространстве.</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">Когда вызывается внутренняя подпрограмма,она будет видеть значение переменной внешней подпрограммы,как это было до и во время *первого*вызова внешней подпрограммы;в этом случае,после завершения первого вызова внешней подпрограммы,внутренняя и внешняя подпрограммы больше не будут иметь общего значения для переменной.Другими словами,переменная больше не будет общей.</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">Когда последняя ссылка на объект исчезает,объект уничтожается.Если у вас есть только одна ссылка на объект,хранящийся в лексическом скаляре,то объект уничтожается,когда этот скаляр выходит за пределы области видимости.Если объект хранится в глобальном пакете,то этот объект не может выйти за пределы области видимости до тех пор,пока программа не выйдет из программы.</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">Когда уровень &lt;code&gt;PUSHED&lt;/code&gt; как часть &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; вызова, будет вызываться PUSHED.</target>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">При &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; уровня текущее значение $ PerlIO :: encoding :: fallback сохраняется и используется как аргумент CHECK при вызове методов Encode encode () и decode ().</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">Когда модуль lib загружается впервые, он записывает текущее значение @INC в массив &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . Чтобы восстановить @INC до этого значения, вы можете сказать</target>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">Когда выполняется сопоставление, первая часть регулярного выражения ( &lt;code&gt;\b(foo)&lt;/code&gt; ) находит возможное совпадение прямо в начале строки и загружает $ 1 с &amp;laquo;Foo&amp;raquo;. Однако, как только механизм сопоставления видит, что после &amp;laquo;Foo&amp;raquo;, сохраненного в $ 1, нет пробелов, он понимает свою ошибку и начинает заново через один символ после того, где было предварительное совпадение. На этот раз это продолжается до следующего появления &amp;laquo;foo&amp;raquo;. Полное регулярное выражение совпадает на этот раз, и вы получите ожидаемый результат &amp;laquo;таблица следует за foo&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">Когда объект выходит из-под действия,вызывается деструктор.Деструктор попытается развязать файл (используя L</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">Когда критерии оптимизации удовлетворены, &lt;code&gt;reg_try()&lt;/code&gt; для выполнения сопоставления.</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">Когда на выходе есть имя файла,он усекает содержимое файла перед записью любых сжатых данных.Если выходной файл является файлообработчиком,его положение не будет изменено.Если выходной файл является буфером,он будет уничтожен перед записью любых сжатых данных.</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">Когда на выходе есть имя файла,он усекает содержимое файла перед записью любых несжатых данных.Если выходной файл является файлообработчиком,его положение не будет изменено.Если выходной файл является буфером,он будет уничтожен перед записью любых несжатых данных.</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">После завершения работы программы вывод можно просмотреть и отсортировать с помощью любых стандартных утилит фильтрации текста.Достаточным может быть что-то вроде следующего:</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">Когда сценарий закончится,и вы захотите изменить некоторые значения в сгенерированном</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">Когда сценарий завершает работу, профилировщик создаст базу данных с информацией профиля, которую вы можете превратить в отчеты с помощью инструментов профилировщика. Подробнее см. &amp;lt;perlperf&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">Если строка содержит именованную кодовую точку Unicode &lt;code&gt;\N{...}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">Когда строка содержит кодовую точку только для Юникода</target>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">Когда строка поступает из внешнего источника,помеченного как Unicode</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">Когда действует режим заражения ( &lt;code&gt;-T&lt;/code&gt; ), значок &quot;.&quot; каталог удаляется из &lt;code&gt;@INC&lt;/code&gt; , а переменные среды &lt;code&gt;PERL5LIB&lt;/code&gt; и &lt;code&gt;PERLLIB&lt;/code&gt; игнорируются Perl. Вы по-прежнему можете настроить &lt;code&gt;@INC&lt;/code&gt; вне программы, используя параметр командной строки &lt;code&gt;-I&lt;/code&gt; , как описано в &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; . Две переменные среды игнорируются, потому что они скрыты, и пользователь, запускающий программу, может не знать, что они установлены, в то время как параметр &lt;code&gt;-I&lt;/code&gt; четко виден и поэтому разрешен.</target>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">По окончании тестового файла выводится сводка вместе.</target>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">Когда нет BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; - это функция, которая проходит через текущий блок &lt;code&gt;when&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt; вместо повторения динамически включающего &lt;code&gt;foreach&lt;/code&gt; или выхода из лексически включающего &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; . В Perl 5.14 и ранее эта форма &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; была доступна только тогда, когда была включена функция &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Операторы &lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;функций&amp;raquo;&lt;/a&gt; и &amp;laquo; Switch&amp;raquo; в perlsyn .</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">Когда нет BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; - это функция, которая проходит через текущий блок &lt;code&gt;when&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt; вместо повторения динамически включающего &lt;code&gt;foreach&lt;/code&gt; или выхода из лексически включающего &lt;code&gt;given&lt;/code&gt; . В Perl 5.14 и ранее эта форма &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; была доступна только тогда, когда была включена функция &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Операторы &lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;функций&amp;raquo;&lt;/a&gt; и &amp;laquo; Switch&amp;raquo; в perlsyn .</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">Когда нет метода,он берет имя метода в качестве имени кодировки и кодирует экземпляр</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">Когда они встроены в другой шаблон,то,что они совпадают,не меняется,независимо от скобок или от того,какие модификаторы действуют в этом внешнем шаблоне.</target>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">Когда этот код выполняется,выводиться не будет.Вот почему:</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">Когда этот код запускается, только &lt;code&gt;Derived&lt;/code&gt; объект &lt;code&gt;$b&lt;/code&gt; выдаст предупреждение.</target>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">Когда этот код запускается с флагом &lt;b&gt;-w&lt;/b&gt; , для строки &lt;code&gt;$a&lt;/code&gt; будет &lt;b&gt;выдано&lt;/b&gt; предупреждение : &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">Когда используется эта форма прагмы, Perl использует только несимвольные части локалей, например &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl предполагает, что вы перевели все символы, с которыми он должен работать, в Unicode (фактически, собственный набор символов платформы (ASCII или EBCDIC) плюс Unicode). Для данных в файлах это удобно сделать, также указав</target>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">При вызове этой функции,функция,на которую делается ссылка,называется</target>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">Если установлено значение &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; будет автоматически получен из &lt;code&gt;O_FILES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">Когда это значение равно true,CPAN установит значение PERL_MM_USE_DEFAULT равным true.Это приводит к тому,что ExtUtils::MakeMaker (и совместимый)предлагает использовать значения по умолчанию вместо того,чтобы останавливаться и просить вас ответить на вопросы.Он также устанавливает значение NONINTERACTIVE_TESTING равным true,чтобы сигнализировать в общем случае,что дистрибутивы не должны пытаться взаимодействовать с Вами.</target>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">When to Still Use local()</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">Когда использовать OO</target>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">При значении true этот параметр устанавливает бит FLG.FHCRC в 1 в заголовке gzip и устанавливает поле заголовка CRC16 в значение CRC всего заголовка gzip,за исключением самого поля CRC16.</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">Если это так,выполните генерацию и добавление в MANIFEST файла SIGNATURE в дистрибутиве во время 'make distdir',через 'cpansign -s'.</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;perllocal&lt;/code&gt; значение true, запрещает добавление установок в perllocal .</target>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">Если это так,подавляет генерацию и добавление в MANIFEST мета-файлов модуля META.yml и META.json во время 'make distdir'.</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">Когда это так,подавляет генерацию мета-файлов модуля MYMETA.yml и MYMETA.json во время 'perl Makefile.PL'.</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">Если &lt;code&gt;packlist&lt;/code&gt; true, запрещает запись файлов списка пакетов для установки.</target>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">Пытаясь объяснить стеки,большинство учебников по информатике бормочут что-то о подпружиненных столбах столовых тарелок:последнее,что вы нажимаете на стеки-это первое,что вы выскакиваете.Это делается для наших целей:ваша программа на Си будет нажимать на &quot;стек Perl&quot; некоторые аргументы,закрывать глаза,пока происходит какое-то волшебство,а затем выкладывать результаты-возвращаемое значение вашей подпрограммной панели Perl-снимает стек.</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">При вязании ручки, первый аргумент &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; должен начинаться со звездочкой. Итак, если вы привязываете STDOUT, используйте &lt;code&gt;*STDOUT&lt;/code&gt; . Если вы присвоили его скалярной переменной, скажем, &lt;code&gt;$handle&lt;/code&gt; , используйте &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; связывает скалярную переменную &lt;code&gt;$handle&lt;/code&gt; , а не дескриптор внутри нее.</target>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">При использовании в качестве метода класса ( &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , иногда называемого статическим методом) &lt;code&gt;isa&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">При использовании в качестве фильтра мы хотим использовать его вот так:</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">При использовании в качестве метода экземпляра или класса ( &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ) &lt;code&gt;isa&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">При таком использовании параметры и их возможные значения удаляются из &lt;code&gt;@myopts&lt;/code&gt; , глобальный &lt;code&gt;@ARGV&lt;/code&gt; вообще не затрагивается.</target>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">При таком использовании:</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">При использовании в элементе хэша он сообщает вам, определено ли значение, а не существует ли ключ в хеше. Использование &lt;a href=&quot;#exists&quot;&gt;существует&lt;/a&gt; для последней цели.</target>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">При использовании в элементе хэша он сообщает вам, определено ли значение, а не существует ли ключ в хеше. Использование &lt;a href=&quot;exists&quot;&gt;существует&lt;/a&gt; для последней цели.</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">При использовании с элементом массива или хэша &lt;code&gt;is_shared&lt;/code&gt; проверяет, принадлежит ли указанный элемент общему массиву или хешу. (Он не проверяет содержимое этого элемента.)</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">При использовании для передачи списка perl в C модуль записи XS должен предоставить функцию (названную в честь типа массива, но с &amp;laquo;Ptr&amp;raquo;, замененным на &amp;laquo;*&amp;raquo;) для выделения памяти, необходимой для хранения списка. Должен быть возвращен указатель. Писатель XS должен освободить память при выходе из функции. Переменная &lt;code&gt;ix_$var&lt;/code&gt; устанавливается равной количеству элементов в новом массиве.</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">При использовании с &lt;code&gt;.&lt;/code&gt; , счетчик повторов определяет начальную позицию для вычисления смещения значения следующим образом:</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">При использовании с &lt;code&gt;@&lt;/code&gt; счетчик повторов представляет собой смещение от начала самой внутренней &lt;code&gt;()&lt;/code&gt; группы.</target>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">При использовании с &lt;code&gt;Z&lt;/code&gt; , A &lt;code&gt;*&lt;/code&gt; в качестве счетчика повторов гарантированно добавить завершающий нулевой байт, так что результирующая строка всегда один байт длиннее , чем длина байта самого элемента.</target>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">При использовании с методами класса проблема еще хуже. Поскольку Perl позволяет записывать имена подпрограмм как голые слова, Perl должен угадывать, является ли голое слово после метода именем класса или именем подпрограммы. Другими словами, Perl может разрешить синтаксис как &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;или как &lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">При использовании с опциями командной строки:</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">Если userelocatableinc правда,эта переменная содержит место,куда должна быть скопирована программа установки,в которую должны быть скопированы бинарные файлы perl,а также все пути,которые могут быть перемещены во время выполнения программы,вычисленные из них во время установки.При использовании она инициализируется до исходного значения binexp,а затем binexp устанавливается в следующее состояние</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">При использовании &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;&lt;/code&gt; в группе &lt;code&gt;()&lt;/code&gt; это влияет на все типы внутри группы, которые принимают модификаторы порядка байтов, включая все подгруппы. Для всех остальных типов он молча игнорируется. Вам не разрешено переопределять порядок байтов в группе, которая уже имеет суффикс модификатора порядка байтов.</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">При использовании &lt;code&gt;Exporter&lt;/code&gt; со стандартными &lt;code&gt;strict&lt;/code&gt; и &lt;code&gt;warnings&lt;/code&gt; прагмах, то &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; ключевое слово необходимо , чтобы объявить переменные пакета &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; и т.д.</target>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">При использовании &lt;code&gt;IPC::Open3&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , если вы указываете строку в качестве аргумента &lt;code&gt;command&lt;/code&gt; , предполагается, что она соответствующим образом экранирована. Вы можете использовать константу &lt;code&gt;QUOTE&lt;/code&gt; в качестве переносимого символа кавычек (см. Выше). Однако, если вы предоставляете ссылку на массив, применяются особые правила:</target>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">При использовании &lt;code&gt;IPC::Run&lt;/code&gt; , если вы указываете строку в качестве аргумента &lt;code&gt;command&lt;/code&gt; , строка будет разделена на пробелы, чтобы определить отдельные элементы вашей команды. Хотя обычно это просто &amp;laquo;Делай то, что ты имеешь в виду&amp;raquo;, это может сломаться, если у вас есть файлы или команды с пробелами в них.</target>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">При использовании &lt;code&gt;autodie&lt;/code&gt; или &lt;code&gt;Fatal&lt;/code&gt; с пользовательскими подпрограммами объявление этих подпрограмм должно появиться перед первым использованием &lt;code&gt;Fatal&lt;/code&gt; или &lt;code&gt;autodie&lt;/code&gt; , либо они были экспортированы из модуля. Попытка использовать &lt;code&gt;Fatal&lt;/code&gt; или &lt;code&gt;autodie&lt;/code&gt; для других пользовательских подпрограмм приведет к ошибке времени компиляции.</target>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">При использовании &lt;code&gt;fd_retrieve&lt;/code&gt; объекты извлекаются последовательно, один объект (т.е. одно рекурсивное дерево) на связанный &lt;code&gt;store_fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">При использовании GCC эта запись указывает, что MakeMaker должен сначала искать &lt;code&gt;libgl.a&lt;/code&gt; (а затем &lt;code&gt;gl.a&lt;/code&gt; ) во всех местах, указанных в &lt;code&gt;$Config{libpth}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">При использовании Module::Build это обычно так и будет:</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">При использовании PUSHCOLOR,POPCOLOR и LOCALCOLOR особенно важно не ставить запятую между константами.</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">При использовании Term::ReadLine,вы можете включить орнаменты так,чтобы ваш вход выделялся на фоне выхода из CPAN.pm.</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">При использовании синтаксиса Unix или MSDOS это имитирует функцию оболочки &lt;code&gt;dirname(1)&lt;/code&gt; которая немного отличается от того, как работает &lt;code&gt;fileparse()&lt;/code&gt; . Он возвращает все, кроме последнего уровня пути к файлу, даже если последний уровень явно является каталогом. Фактически, он возвращает не часть каталога, а просто путь на один уровень выше, действуя как &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; для путей к файлам.</target>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">При использовании компилятора, отличного от GCC, в указанной выше записи будет выполняться поиск &lt;code&gt;gl.lib&lt;/code&gt; (за которым следует &lt;code&gt;libgl.lib&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">При использовании пользовательского движка, который не поддерживает конструкцию &lt;code&gt;(?:)&lt;/code&gt; для встроенных модификаторов, вероятно, лучше всего использовать &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify для предоставленного шаблона, обратите внимание, что это создаст нежелательные шаблоны в таких случаях, как:</target>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">При использовании подписи аргументы по-прежнему доступны в специальной переменной массива &lt;code&gt;@_&lt;/code&gt; в дополнение к лексическим переменным подписи. Есть разница между двумя способами доступа к аргументам: &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">При использовании любой из этих подпрограмм (кроме &lt;code&gt;call_argv&lt;/code&gt; ) программист должен управлять стеком Perl. К ним относятся следующие макросы и функции:</target>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">При использовании обманчивых утверждений и отрицаний,все это может стать еще более хитрым.Представьте,что вам хотелось бы найти последовательность нецифр,за которой не следует &quot;123&quot;.Вы можете попробовать написать это как</target>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">При использовании perl на OS/390,пожалуйста,имейте в виду,что наборы символов EBCDIC и ASCII отличаются.Подробнее о таких проблемах с наборами символов смотрите perlebcdic.pod.Встроенные функции Perl,которые могут вести себя по-разному в EBCDIC,также упомянуты в документе perlport.pod.</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">При использовании perldoc в режиме &lt;code&gt;-m&lt;/code&gt; (исходный код модуля отображения) &lt;code&gt;perldoc&lt;/code&gt; попытается использовать пейджер, установленный в &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . Полезной настройкой для этой команды является ваш любимый редактор, например &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Не судите меня.)</target>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">При использовании протокола &quot;syn&quot; используйте этот метод для определения доступности удаленного хоста.Предполагается,что этот метод будет вызываться столько раз,сколько было вызвано функцией ping().Каждый вызов возвращает хост (как передается в ping()),который вернулся с TCP ACK.Порядок,в котором возвращаются хосты,может не совпадать с порядком,в котором они были поставлены в очередь SYN с помощью метода ping().Если таймаут достигнут до получения TCP ACK,или если удаленный хост не прослушивает порт,на котором была сделана попытка,то TCP-соединение не будет установлено и ack()вернётся undef.В контексте списка будет возвращен хост,время ack и пунктирная ip-строка,а не только хост.Если указан необязательный аргумент $host,то возвращаемое значение будет относиться только к этому хосту.Этот вызов просто ничего не делает,если вы используете какой-либо протокол,кроме syn.</target>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">При использовании прототипа &lt;code&gt;+&lt;/code&gt; ваша функция должна проверить, имеет ли аргумент допустимый тип.</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">При использовании компилятора Borland второй элемент возвращается как &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; , а MakeMaker заботится о перемещении &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; в нужное место в командной строке компоновщика.</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">При использовании GUI-версии SAM нажмите на значок &quot;Конфигурация ядра&quot;,затем на значок &quot;Настраиваемые параметры&quot;.Прокрутите вниз и выберите строку Maxdsiz.В меню Actions (Действия)выберите пункт Modify Configurable Parameter (Изменить конфигурируемые параметры).Вставьте новую формулу в поле Формула/Ценность.Затем следуйте инструкциям по перестройке ядра и перезагрузке системы.</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">При использовании компилятора Visual C второй элемент возвращается как &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">При использовании констант, если вы не хотите помнить о добавлении &lt;code&gt;, RESET&lt;/code&gt; в конце каждой строки печати, вы можете установить для $ Term :: ANSIColor :: AUTORESET истинное значение. Затем режим отображения будет автоматически сброшен, если после константы нет запятой. Другими словами, с этим набором переменных:</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">При использовании данного компилятора для сборки Perl необходимо убедиться,что в файле config.sh в переменные cpprun и cppstdin добавлен флаг -Aa (хотя смотрите ниже раздел о 64-битном perl).Если вы используете последнюю версию дистрибутива Perl,то эти флаги устанавливаются автоматически.</target>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">При проверке существующей строки дайджеста вы должны использовать дайджест в качестве соли (например, &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). СОЛЬ, использованная для создания дайджеста, отображается как часть дайджеста. Это гарантирует, что crypt () будет хешировать новую строку с той же солью, что и дайджест. Это позволяет вашему коду работать со стандартной &lt;a href=&quot;crypt&quot;&gt;криптой&lt;/a&gt; и с более экзотическими реализациями. Другими словами, ничего не предполагайте ни о самой возвращаемой строке, ни о том, сколько байтов SALT может иметь значение.</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">При проверке существующей строки дайджеста вы должны использовать дайджест в качестве соли (например, &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). СОЛЬ, использованная для создания дайджеста, отображается как часть дайджеста. Это гарантирует, что crypt () будет хешировать новую строку с той же солью, что и дайджест. Это позволяет вашему коду работать со стандартной &lt;a href=&quot;#crypt&quot;&gt;криптой&lt;/a&gt; и с более экзотическими реализациями. Другими словами, ничего не предполагайте ни о самой возвращаемой строке, ни о том, сколько байтов SALT может иметь значение.</target>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">Когда мы что-то благословляем,мы не благословляем переменную,содержащую ссылку на эту вещь,и не благословляем ссылку,которую эта переменная хранит;мы благословляем вещь,на которую эта переменная ссылается (иногда известную как</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">Когда мы вызываем &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; для переменной, мы фактически благословляем базовую структуру данных, на которую ссылается переменная. Мы не благословляем ни саму ссылку, ни переменную, содержащую эту ссылку. Вот почему второй вызов &lt;code&gt;blessed( $bar )&lt;/code&gt; возвращает false. В этот момент &lt;code&gt;$bar&lt;/code&gt; больше не хранит ссылку на объект.</target>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">Когда мы вызываем метод, Perl &lt;b&gt;принимает меры&lt;/b&gt; для &lt;b&gt;передачи вызывающего&lt;/b&gt; метода в качестве первого аргумента. &lt;b&gt;Invocant&lt;/b&gt; - это причудливое название для предмета слева от стрелки. Вызывающим может быть имя класса или объект. Мы также можем передать методу дополнительные аргументы:</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">Когда мы говорим &quot;Mac OS&quot; ниже,мы имеем в виду Mac OS 7,8 и 9,и</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">Когда мы хотим поместить возвращаемые вызывающему абоненту значения в стек,мы используем серию макросов,которые начинаются с &quot;XPUSH&quot;.Существует пять различных версий,для размещения целых чисел,беззнаковых целых чисел,дубликатов,строк и Perl-скаляров на стеке.В нашем примере мы поместили Perl-скаляр на стек.(На самом деле это единственный макрос,который может быть использован для возврата множественных значений).</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">Когда встречаются слова, длина которых превышает &lt;code&gt;$columns&lt;/code&gt; , они разбиваются. &lt;code&gt;wrap()&lt;/code&gt; добавляет &lt;code&gt;&quot;\n&quot;&lt;/code&gt; в столбец &lt;code&gt;$columns&lt;/code&gt; . Это поведение можно изменить, установив для &lt;code&gt;$huge&lt;/code&gt; значение 'die' или 'overflow'. Если установлено значение 'die', большие слова будут вызывать вызов &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . Если установлено значение &amp;laquo;переполнение&amp;raquo;, большие слова останутся нетронутыми.</target>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">При написании DBM-фильтра это</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">При написании расширения Perl для общего потребления следует ожидать,что это расширение будет использоваться с версиями Perl,отличными от версии,доступной на вашей машине.Поскольку вы читаете этот документ,версия Perl на вашей машине,вероятно,5.005 или более поздняя,но у пользователей вашего расширения могут быть более древние версии.</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">При записи символа UV в строку UTF-8 &lt;b&gt;всегда&lt;/b&gt; используйте &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , если только &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; в этом случае вы можете использовать &lt;code&gt;*s = uv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">При записи gzip-файла этот интерфейс будет</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">При записи в файл или дескриптор файла установите &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; перед записью в файл.</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">Когда ты</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">Когда вы довольны списком подозреваемых,вы можете теперь</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">Когда вы закончите,процесс установки XS-модуля добавит в вашу &quot;perllocal&quot; информацию о том,что бинарник perl был заменён,и какой модуль был установлен.Вы можете просмотреть эту информацию в любое время с помощью команды:</target>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">Если вы собираетесь использовать компилятор GNU C (gcc), но у вас еще нет gcc, вы можете либо собрать его самостоятельно из источников (доступных, например, по &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;адресу http://gcc.gnu.org/mirrors.html&lt;/a&gt; ) или загрузите предварительно созданный двоичный файл из центра портирования HP по адресу &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; или из DSPP (вы должны быть участником) по адресу &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http : //h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801? ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD &amp;amp; jumpid = reg_r100_r1002_usen&lt;/a&gt; , так как часто доступны несколько версий пакета, так как список пакетов от.</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">Когда вы вручную создаете UCM файл,вы должны скопировать ascii.ucm или существующую кодировку,которая близка к вашей,вместо того,чтобы писать свою собственную с нуля.</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">Когда вы будете удовлетворены результатами тестов,установите библиотеки сборки C для расширений:</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">Если вы уверены , что только несколько подкаталогов привести к сбоям, вы можете добавить &lt;code&gt;-j4&lt;/code&gt; вариант &lt;code&gt;make&lt;/code&gt; , чтобы ускорить пропуск подкаталогов с уже готовой сборкой.</target>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">Когда вы используете &amp;laquo;потоковый&amp;raquo; протокол, этот вызов предварительно открывает TCP-сокет. Это необходимо только в том случае, если вы хотите указать другой тайм-аут при создании соединения или удалить накладные расходы на установление соединения из первого эхо-запроса. Если вы не вызываете &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , соединение автоматически открывается при первом вызове &lt;code&gt;ping()&lt;/code&gt; . Этот вызов просто ничего не делает, если вы используете какой-либо протокол, кроме потока.</target>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">Когда вы собираете модули,скажите Perl,где установить модули.</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">Когда вы вызываете &lt;code&gt;bar&lt;/code&gt; с аргументами, вы видите, что &lt;code&gt;foo&lt;/code&gt; имеет то же &lt;code&gt;@_&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">Когда вы вызываете метод, то, что находится слева от стрелки, передается в качестве первого аргумента метода. Это означает, что когда мы вызываем &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , метод &lt;code&gt;new()&lt;/code&gt; получает строку &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; качестве своего первого аргумента. Когда мы вызываем &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , переменная &lt;code&gt;$fred&lt;/code&gt; передается как первый аргумент для &lt;code&gt;speak()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">Когда вы изменяете &lt;b&gt;значение&lt;/b&gt; в процессе его копирования. [От французского &amp;laquo;попутно&amp;raquo;, как в экзотическом маневре с захватом пешки в шахматах.]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">При chop()математическом объекте он переходит в строку и его математические свойства теряются.То же самое может произойти и с другими операциями.</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">При объединении устаревших данных и Юникода,устаревшие данные необходимо обновить до Юникода.Обычно считается,что устаревшие данные соответствуют стандарту ISO 8859-1 (или EBCDIC,если применимо).</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">Когда вы создаете карту, вы ДОЛЖНЫ сделать ваши сопоставления безопасными. То есть &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; обозначает все символы, помеченные как &lt;code&gt;|0&lt;/code&gt; . Вот как в этом убедиться:</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">Когда вы объявляете константу, такую ​​как &lt;code&gt;PI&lt;/code&gt; , используя метод, показанный выше, каждая машина, на которой запускается ваш скрипт, может иметь столько цифр точности, сколько она может использовать. Кроме того, вашу программу будет легче читать, с большей вероятностью будет поддерживаться (и правильно обслуживаться) и гораздо меньше шансов отправить космический зонд не на ту планету, потому что никто не заметил одно уравнение, в котором вы написали &lt;code&gt;3.14195&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">Когда вы декодируете(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">Когда вы декодируете, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; вставляется для искаженного символа, где</target>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для объекта &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы можете получить объект этого класса.</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы можете получить объект этого класса.</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы должны получить объект подкласса Pod :: Simple :: PullParserToken.</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">Когда вы делаете open()и указываете дополнительные слои PerlIO,которые должны быть развернуты,слои,которые вы указываете,&quot;толкаются&quot; поверх уже существующего стека по умолчанию.Один из способов увидеть это-&quot;операционная система слева&quot; и &quot;Perl справа&quot;.</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">Когда вы это сделаете, убедитесь, что вы оставили по крайней мере от &lt;b&gt;U0000&lt;/b&gt; до &lt;b&gt;U0020&lt;/b&gt; как есть, если ваша среда не EBCDIC.</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">Когда вы это делаете, вы заменяете обычные &lt;code&gt;OP_CUSTOM&lt;/code&gt; &lt;code&gt;op_ppaddr&lt;/code&gt; на собственные операции, создавая операции с типом OP_CUSTOM и op_ppaddr вашей собственной функции PP. Это должно быть определено в XS код, и должен выглядеть ПП опы &lt;code&gt;pp_*.c&lt;/code&gt; . Вы несете ответственность за то, чтобы ваш оператор взял соответствующее количество значений из стека, и вы несете ответственность за добавление меток стека, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">Когда вы кодируете,он просто кодирует UTF-8 строку с помощью</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">При выполнении этого скрипта Perl создает исходный поток для файла.Перед тем,как синтаксический анализатор обработает какую-либо строку из файла,исходный поток выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">Когда вам надоест писать нестандартную печать для ваших структур данных, вы можете взглянуть на стандартные &lt;a href=&quot;dumpvalue&quot;&gt;модули Dumpvalue&lt;/a&gt; или &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; . Первый - это то, что использует отладчик Perl, а второй генерирует анализируемый код Perl. Например:</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Когда у вас установлен Module::Build и модуль поставляется как с Makefile.PL,так и с Build.PL,что должно иметь приоритет?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Когда у вас установлен Term::ANSIColor,вы можете включить цветной вывод,чтобы иметь некоторые визуальные различия между обычным выводом CPAN.pm,предупреждениями,отладочным выводом и выводом устанавливаемых модулей.Установите ваши любимые цвета после некоторых экспериментов с модулем Term::ANSIColor.</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">Когда у вас есть &lt;code&gt;$normalized&lt;/code&gt; строка &lt;code&gt;$unnormalized&lt;/code&gt; следующая за ней ненормализованная строка, простое объединение неверно:</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">Когда у вас есть дубликат записи,отметьте его '|1' или '|3'.</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">Когда вы перечисляете аргументы для XSUB в файле .xs, это сообщает &lt;b&gt;xsubpp,&lt;/b&gt; какой аргумент соответствует какому из стека аргументов (т. &lt;b&gt;Е.&lt;/b&gt; Первый из перечисленных аргументов является первым аргументом и т. Д.). Вы приглашаете к катастрофе, если не перечисляете их в том же порядке, в каком их ожидает функция.</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">Когда вы создаете исполняемый файл сценария, чтобы его можно было использовать в качестве команды, система передаст переключатели на perl из сценария #! линия. Perl проверяет, что любые параметры командной строки, заданные для сценария setuid (или setgid), действительно соответствуют параметрам, установленным в #! линия. Некоторые Unix и Unix-подобные среды накладывают ограничение в один переключатель на #! строка, поэтому вам может потребоваться использовать что-то вроде &lt;code&gt;-wU&lt;/code&gt; вместо &lt;code&gt;-w -U&lt;/code&gt; в таких системах. (Эта проблема должна возникать только в Unix или Unix-подобных средах, которые поддерживают сценарии #! И setuid или setgid.)</target>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">Когда вы переопределяете встроенный, ваша замена должна согласовываться (если возможно) со встроенным собственным синтаксисом. Добиться этого можно с помощью подходящего прототипа. Чтобы получить прототип переопределяемого встроенного модуля, используйте функцию &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; с аргументом &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (см. &lt;a href=&quot;functions/prototype&quot;&gt;Прототип&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">Когда вы заменяете эту переменную,считается хорошей практикой хранить,возможно,ранее установленный крюк,и что вы помните его внутри своего собственного.</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Когда вы запускаете Makefile.PL,он делает Makefile.В этом весь смысл MakeMaker.Makefile.PL-это простая программа,которая загружает ExtUtils::MakeMaker и запускает функцию WriteMakefile()для генерации Makefile.</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Когда вы запускаете Perl скрипт,что-то другое запускает скрипт для вас,и что-то другое может выдать сообщения об ошибках.Сценарий может выдавать свои собственные предупреждения и сообщения об ошибках.В большинстве случаев вы не можете сказать,кто что сказал.</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">Когда вы запустите эту программу,вы должны получить что-то,что выглядит так:</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">Когда вы говорите &quot;сделать тест&quot;,Перл использует</target>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">Когда вы видите &lt;code&gt;charset=gb2312&lt;/code&gt; в сообщениях электронной почты и на веб-страницах, они действительно имеют в виду &lt;code&gt;euc-cn&lt;/code&gt; . Чтобы исправить это, &lt;code&gt;gb2312&lt;/code&gt; имеет псевдоним &lt;code&gt;euc-cn&lt;/code&gt; . Используйте &lt;code&gt;gb2312-raw&lt;/code&gt; , когда действительно имеете в виду.</target>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">Когда вы видите &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; в сообщениях электронной почты и на веб-страницах, они действительно имеют в виду кодировки &quot;cp949&quot;. Чтобы исправить это, устанавливаются следующие псевдонимы;</target>
        </trans-unit>
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">Когда вы говорите на одном языке, а компьютер думает, что вы говорите на другом. Вы увидите странные переводы, например, при отправке UTF ‑ 8, но компьютер думает, что вы отправили Latin-1, вместо этого показывая всевозможные странные символы. Этот термин пишется на японском 文字 化 け 」и означает&amp;laquo; гниль характера &amp;raquo;, подходящее описание. Произносится [ &lt;code&gt;modʑibake&lt;/code&gt; ] в стандартной фонетике &lt;b&gt;IPA&lt;/b&gt; , или приблизительно &amp;laquo;мо-джи-ба-кех&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">Когда вы указываете аргументы в подпрограмме в файле .xs,вы действительно передаете три части информации для каждого из перечисленных аргументов.Первая часть-это порядок следования этого аргумента по отношению к другим (первый,второй и т.д.).Второй-это тип аргумента и состоит из объявления типа аргумента (например,int,char*и т.д.).Третья часть-вызывающая конвенция для аргумента при вызове библиотечной функции.</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">При вводе отдельного отображаемого имени становится возможным проводить тест несколько раз;отображаемое имя фактически является псевдонимом,по которому тест известен внутри жгута.Если один и тот же тест будет выполняться несколько раз,то жгут не будет заботиться о том,чтобы он выполнялся несколько раз при каждом вызове под разным именем.</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">Когда вы используете &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; для блокировки файла, &lt;code&gt;Tie::File&lt;/code&gt; предполагает, что кэш чтения больше не заслуживает доверия, потому что другой процесс мог изменить файл с момента последнего чтения. Следовательно, успешный вызов &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; отбрасывает содержимое кэша чтения и таблицы смещения внутренней записи.</target>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">Когда Вы используете Perl из C,Ваша программа на C будет...обычно...выделять,&quot;запускать&quot;,а также распределять</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">Когда вы используете переключатели &lt;b&gt;-n&lt;/b&gt; и &lt;b&gt;-p&lt;/b&gt; для Perl, &lt;code&gt;BEGIN&lt;/code&gt; и &lt;code&gt;END&lt;/code&gt; работают так же, как и в &lt;b&gt;awk&lt;/b&gt; , но в вырожденном случае. И &lt;code&gt;BEGIN&lt;/code&gt; и &lt;code&gt;CHECK&lt;/code&gt; блоки выполняются при использовании &lt;b&gt;-c&lt;/b&gt; переключателя для компиляции только проверки синтаксиса, хотя ваш основной код не является.</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">При использовании &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; прагмы или Perl в &lt;b&gt;-w&lt;/b&gt; параметра командной строки, вы можете увидеть предупреждение о бесполезном использовании констант и функций в &amp;laquo;пустом контексте&amp;raquo;. Пустой контекст просто означает, что значение было отброшено, например, утверждение, содержащее только &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; . Он по-прежнему считается скалярным контекстом для функций, которые заботятся о том, вызываются ли они в контексте списка.</target>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">Однако,когда вы хотите кодировать Unicode для писем и веб-страниц,не используйте UTF-7,если вы не уверены,что ваши получатели и читатели могут справиться с этим.Очень немногие MUA и WWW-браузеры поддерживают в наши дни (кажется,только Mozilla поддерживает один).Для общих случаев,используйте UTF-8 для тела сообщения и MIME-Header для заголовка.</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">Когда вы хотите записать в файл,вам сначала нужно решить,что делать с любым существующим содержимым этого файла.Здесь у вас есть два основных варианта:сохранить или уничтожить.</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">Когда вы закончите со своими дескрипторами файлов, вы должны &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; их (хотя, честно говоря, Perl очистит после вас, если вы забудете):</target>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">Когда вы используете RETVAL для возврата &lt;code&gt;SV *&lt;/code&gt; , за кулисами творится некоторая магия, о которой следует упомянуть. Например, когда вы манипулируете стеком аргументов с помощью макроса ST (x), вам обычно нужно уделять особое внимание счетчику ссылок. (Для получения дополнительной информации о подсчете ссылок см. &lt;a href=&quot;perlguts&quot;&gt;Perlguts&lt;/a&gt; .) Чтобы облегчить вашу жизнь, файл typemap автоматически делает &lt;code&gt;RETVAL&lt;/code&gt; смертным, когда вы возвращаете &lt;code&gt;SV *&lt;/code&gt; . Таким образом, следующие два XSUB более или менее эквивалентны:</target>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">Когда вы обнаружили,что нет модуля,доступного для того,что вы пытаетесь сделать,и вам пришлось писать код самому,подумайте о том,чтобы упаковать решение в модуль и загрузить его в CPAN,чтобы другие могли извлечь из этого пользу.</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">Когда вы разобрались со своим именем и уверены,что ваш модуль в розыске и недоступен в данный момент,пришло время начать кодирование.</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">Когда ваш ребенок &lt;code&gt;finalize&lt;/code&gt; выполнение тестов, вы должны вызвать finalize, чтобы очистить и сообщить родителю свой статус пройден / не пройден.</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">Когда ваш модуль сталкивается с ошибкой,он должен сделать одну или несколько ошибок:</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">Когда &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; включен, этот параметр определяет, используются ли разрешения для файлов из архива без изменений или фильтруются ли они путем удаления любых битов setid и применения текущей маски umask.</target>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">Когда функция Berkeley DB возвращает данные через один из своих параметров, эквивалентный метод &lt;b&gt;DB_File&lt;/b&gt; делает то же самое.</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">Всякий раз,когда вызывается подпрограмма Perl с помощью одной из подпрограмм</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">Всякий раз,когда ссылка используется в качестве хэш-ключа полей,проверяется реестр объектов и при необходимости вносится новая запись.Хэш-значение поля добавляется в список полей,используемых этой ссылкой.</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">Всякий раз,когда управление возвращается с</target>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">Всегда,когда это возможно,новые возможности должны быть прототипированы в модуле CPAN,прежде чем они будут рассмотрены для ядра.</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">Всякий раз, когда это применяется к строке, которая не совсем соответствует ожиданиям шаблона, таким как &lt;code&gt;&quot;abc &quot;&lt;/code&gt; или &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; , механизм регулярных выражений будет выполнять возврат примерно один раз для каждого символа в строке. Но мы знаем, что никуда не денешься</target>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">Всякий раз, когда вы выполняете ввод-вывод для файла в Perl, вы делаете это с помощью того, что в Perl называется &lt;b&gt;дескриптором файла&lt;/b&gt; . Дескриптор файла - это внутреннее имя внешнего файла. Задача функции &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; - установить связь между внутренним именем и внешним именем, а задача функции &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; - разорвать эту связь.</target>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">Всякий раз,когда у вас более одного подпроцесса,вы должны быть осторожны,чтобы каждый из них закрывал любую из половин каналов,созданных для межпроцессного взаимодействия,которые он не использует.Это происходит потому,что любой дочерний процесс,читающий из трубы и ожидающий EOF,никогда не получит его и,следовательно,никогда не выйдет.Одного процесса,закрывающего трубу,недостаточно,чтобы закрыть ее;последний процесс с открытой трубой должен закрыть ее,чтобы она могла считывать EOF.</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">Всякий раз,когда вы сообщаете текст с чем-либо,что является внешним по отношению к вашему perl процессу,например,с базой данных,текстовым файлом,сокетом или другой программой.Даже если то,с чем вы общаетесь,также написано на Perl.</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">Всякий раз, когда ваша закодированная двоичная строка используется вместе с текстовой строкой, Perl будет считать, что ваша двоичная строка была закодирована с помощью ISO-8859-1, также известного как latin-1. Если это не latin-1, то ваши данные будут преобразованы неприятно. Например, если это был UTF-8, отдельные байты многобайтовых символов отображаются как отдельные символы, а затем снова преобразуются в UTF-8. Такое двойное кодирование можно сравнить с двойным кодированием HTML ( &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ) или двойным кодированием URI ( &lt;code&gt;%253E&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">Всякий раз,когда ваша программа получает доступ к данным или ресурсам,которые могут быть доступны другим потокам,вы должны принимать меры по координации доступа или рисковать несовместимостью данных и условиями гонки.Обратите внимание,что Perl защитит свои внутренние компоненты от ваших расовых условий,но он не защитит вас от вас.</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">Где 1-позиция первого графика в строке.Обратите внимание,что позиция может быть равна 0 или больше,чем фактическая длина детали,также длина может быть равна нулю.</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">Где &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; - двухбайтовые идентификаторы подполей.</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">Где &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; - двухбайтовые идентификаторы подполей. Второй байт идентификатора не может быть 0, если не отключена опция &lt;code&gt;Strict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">Где &lt;code&gt;$r1&lt;/code&gt; может быть ссылкой на любую структуру данных, которую вы хотите. Это будет глубоко скопировано. Поскольку &lt;code&gt;dclone&lt;/code&gt; принимает и возвращает ссылки, вам придется добавить дополнительную пунктуацию, если у вас есть хэш массивов, которые вы хотите скопировать.</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">Где &lt;b&gt;компилятор&lt;/b&gt; запоминает символы. Программа, подобная Perl, должна каким-то образом запоминать все имена всех используемых вами &lt;b&gt;переменных&lt;/b&gt; , &lt;b&gt;дескрипторов файлов&lt;/b&gt; и &lt;b&gt;подпрограмм&lt;/b&gt; . Он делает это, помещая имена в таблицу символов, которая реализована в Perl с использованием &lt;b&gt;хеш-таблицы&lt;/b&gt; . Для каждого &lt;b&gt;пакета&lt;/b&gt; существует отдельная таблица символов, чтобы дать каждому пакету свое собственное &lt;b&gt;пространство имен&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">Где устанавливаются модули?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">Где я могу купить коммерческую версию Perl?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">Где я могу достать макросы Perl для vi?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">Где я могу получить информацию о Перле?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">Где я могу получить perl-режим или cperl-режим для emacs?</target>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">Где я могу узнать о CGI или веб-программировании на Perl?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">Где я могу узнать о связи C с Perl?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">Где можно узнать об объектно-ориентированном программировании на Perl?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">Где я могу разместить вопросы?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">Где я могу получить включаемые файлы для выполнения ioctl()или syscall()?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">Куда посылать сообщения об ошибках?</target>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">Где реализация?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">Там,где люди попадают в неприятности:</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">Что касается предварительных требований, если используется META_MERGE, предварительные требования объединяются с их противоположным аргументом &lt;code&gt;WriteMakefile()&lt;/code&gt; (PREREQ_PM объединяется в {prereqs} {runtime} {requires}, BUILD_REQUIRES в &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES в &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; и TEST_REQUIRES в &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . Когда предварительные требования указываются с помощью META_ADD, единственные предварительные условия, добавляемые в файл, исходят из метаданных, а не аргументов &lt;code&gt;WriteMakefile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">Где $way-это значение от нуля ($theta0,$phi0)до единицы ($theta1,$phi1).Обратите внимание,что антиподные точки (где их расстояние -</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">Где символы 'DSLIP' имеют следующие значения:</target>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">При наличии только одного операнда (или только одного операнда с перегрузкой)проверки в отношении другого вышеуказанного операнда пропускаются.</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">То, где эти шаги происходят при фактическом выполнении программы на Perl, определяется тем, включает ли шаблон интерполяцию каких-либо строковых переменных. Если происходит интерполяция, то компиляция происходит во время выполнения. Если нет, то компиляция выполняется во время компиляции. ( Модификатор &lt;code&gt;/o&lt;/code&gt; меняет это, как и &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; в некоторой степени.) Движку на самом деле все равно.</target>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">Где найти сообщество</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">Где найти перлфак</target>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">Где искать указатель на информацию в другом месте. (См. &lt;b&gt;Косвенное&lt;/b&gt; обращение.) Ссылки бывают двух видов: &lt;b&gt;символические ссылки&lt;/b&gt; и &lt;b&gt;жесткие ссылки&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">Где подвох? Заполнение не требуется ни перед &lt;code&gt;count&lt;/code&gt; первого поля , ни между этим и следующим &lt;code&gt;glyph&lt;/code&gt; поля , так почему мы не можем просто упаковать его так:</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">В то время как QP декодер,который работает как на ASCII,так и на EBCDIC платформах,выглядел бы несколько следующим образом:</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">В то время как вот как Perl программист,более комфортный с идиомой,может сделать это:</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">В то время как если вы прокомментируете две строки,которые я сказал,что вы можете захотеть,то это покажет вам это таким образом:</target>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">Где бы ни был дан список операторов,Вы можете использовать один или несколько наборов опций.См.также раздел Манипулирование опциями ниже.</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">Везде,где это возможно,разделяемые изображения предпочитаются объектными библиотеками,а объектные библиотеки-обычными объектными файлами.В соответствии с соглашениями об именовании VMS функция ext()ищет файлы с именами</target>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">Находится ли PadnamePV в UTF8.В настоящее время это всегда так.</target>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">Допускается ли смешивание аргументов командной строки с параметрами. По умолчанию отключено, если не была установлена ​​переменная окружения POSIXLY_CORRECT, и в этом случае &lt;code&gt;require_order&lt;/code&gt; включен.</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">Допускается ли смешивание аргументов командной строки с параметрами. По умолчанию включено, если не была установлена ​​переменная среды POSIXLY_CORRECT, и в этом случае &lt;code&gt;permute&lt;/code&gt; отключена. Обратите внимание, что &lt;code&gt;permute&lt;/code&gt; - это противоположность &lt;code&gt;require_order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">Оптимизирована ли операция глазком оптимизатора или нет.</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">Должен ли тест выдавать номера или нет.То есть,это если правда:</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">Будет ли он многословен в том,что делает-по умолчанию будет $Module::Load::Conditional::VERBOSE</target>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">принадлежит ли эта запись к внешней прокладке.Записи,для которых это правда,часто называют &quot;фальшивыми&quot;.</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">Является ли это переменной &quot;состояние&quot;.</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">Является ли это &quot;нашей&quot; переменной.</target>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">Следует ли прервать печать,если флаг сигнала отладчика поднят.</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">Следует ли добавлять оглавление в верхней части каждой страницы (так называемый указатель по традиции).</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">Следует ли привязать каждую директиву definition &lt;code&gt;=item&lt;/code&gt; . Это необходимо включить, если вы хотите иметь возможность ссылаться на определенные директивы &lt;code&gt;=item&lt;/code&gt; , которые выводятся как элементы &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; . По умолчанию отключено.</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">Назвать ли эти расширенные графемные кластеры &quot;символами&quot; зависит от вашей точки зрения.Если вы программист,то вы,вероятно,склонны видеть каждый элемент в последовательности как единое целое,или как &quot;символ&quot;.Однако,с точки зрения пользователя,вся последовательность может рассматриваться как один &quot;символ&quot;,поскольку,вероятно,именно так она выглядит в контексте языка пользователя.В данном документе мы рассмотрим точку зрения программиста:один &quot;символ&quot;-это одна точка кода Юникода.</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">Будь то печатать графики с высоким битовым набором в двоичном виде или &quot;как есть&quot;.</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">Печатать ли содержимое глобусов.</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">Попробовать ли найти имя подпрограммы,указанное в ссылке.</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">Превращать ли каждую директиву =head1 в ссылку,указывающую на верхнюю часть страницы (а именно,открывающий тег тела).</target>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">Записывать ли незагруженные формы строковых объектов.</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">Perl не может контролировать потокобезопасные вызовы различных библиотек. Вызовы, часто страдающие от небезопасной &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; включают: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; , gmtime () , функции , извлекающие информацию о пользователях, группах и сети (например, &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; и т. Д.), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; . В общем, вызовы, которые зависят от некоторого глобального внешнего состояния.</target>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">Неважно,используете ли вы НИС.Удивительно,но та же самая ошибка затрагивает и Solaris.</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">Независимо от того, используете ли вы &lt;code&gt;perlbug&lt;/code&gt; или отправляете электронное письмо вручную, сделайте вашу тему &amp;laquo;Тема&amp;raquo; информативной. &quot;баг&quot; не информативен. Ни &amp;laquo;Perl сбой&amp;raquo;, ни &amp;laquo;ПОМОЩЬ !!!&amp;raquo;. Это не помогает. Краткое описание того, что не так, - это нормально.</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">Ух ты! Это все остальные персонажи и классы персонажей.</target>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">Какая операция &lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt; выполняется с уровня Perl на &lt;code&gt;%+&lt;/code&gt; или &lt;code&gt;%+&lt;/code&gt; , если есть:</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">Какие блоги Perl я должен читать?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">Какую реализацию ЯМЛ вы предпочитаете?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">Какой каталог зависит от архитектуры?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">Какой модификатор набора символов действует?</target>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">Который сначала проверяется, &lt;code&gt;nomethod&lt;/code&gt; или &lt;code&gt;fallback&lt;/code&gt; ? Если два операнда оператора относятся к разным типам и оба перегружают оператор, какая реализация используется? Ниже приведены правила приоритета:</target>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">Что,по сути,справедливо:</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">Как и следовало ожидать, совпадение находит единственную &lt;code&gt;cat&lt;/code&gt; в строке и фиксируется на ней. Однако рассмотрим это регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">Какие журналы имеют Perl содержание?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">Что делает $richard и $dick одной и той же переменной,но оставляет @richard и @dick в виде отдельных массивов.Коварно,да?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">Какую из различных структур &lt;code&gt;*OP&lt;/code&gt; использует эта операция. Это должна быть одна из констант &lt;code&gt;OA_*&lt;/code&gt; из</target>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">Какой из этих модификаторов действует в любой момент регулярного выражения, зависит от довольно сложного набора взаимодействий. Они были разработаны таким образом, чтобы в целом вам не приходилось об этом беспокоиться, но в этом разделе приведены кровавые подробности. Как объясняется ниже в &lt;a href=&quot;#Extended-Patterns&quot;&gt;разделе &amp;laquo;Расширенные шаблоны&amp;raquo;,&lt;/a&gt; можно явно указать модификаторы, которые применяются только к частям регулярного выражения. Самое внутреннее всегда имеет приоритет над любыми внешними, а выражение, применяемое ко всему выражению, имеет приоритет над любыми настройками по умолчанию, которые описаны в оставшейся части этого раздела.</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">Какое из этих выражений лучше отражает приведенную выше спецификацию комментариев,зависит от того,какое из них будет выбрано.</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">Который,возможно,неожиданно уступит:</target>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">Какие применяемые правила определяются, как описано в &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;разделе &amp;laquo;Какой модификатор набора символов действует? в перлре&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">Какую подстроку проверить первой.</target>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">Какой форматировщик текста использовать. По умолчанию используется &lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt; или для очень старых версий Perl &lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt; . Альтернативой может быть, например, &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">Какую версию Perl мне использовать?</target>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">Какую версию перла следует использовать?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">Какую веб-фреймворк следует использовать?</target>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">Который напечатает</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">Который будет пытаться установить точки останова на 4-й и 6-й строках сразу после инициализации отладчика.Обратите внимание,что @DB::typeahead не является поддерживаемым интерфейсом и может быть изменен в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">Который создаст формат,похожий на этот:</target>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">Что,в вырожденном случае использования только обычных массивов,дает вам многомерные массивы,такие же,как и C:</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">Какая бы версия ни использовалась, фактические методы вызываются в том же контексте (список, скаляр или void), что и исходный вызов через &lt;code&gt;EVERY&lt;/code&gt; , и возвращают:</target>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">Хотя $FORMAT_TOP_NAME содержит имя текущего формата заголовка,нет соответствующего механизма,который бы автоматически делал то же самое для нижнего колонтитула.Не зная,насколько большим будет формат,пока вы его не оцените,это является одной из основных проблем.Он есть в списке TODO.</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">Хотя &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; обеспечивает арифметику только для целых чисел, не существует аналогичного механизма для обеспечения автоматического округления или усечения до определенного числа десятичных знаков. Для округления до определенного количества цифр &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; обычно самый простой путь. Смотрите &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">Хотя &lt;code&gt;STORABLE_freeze&lt;/code&gt; и &lt;code&gt;STORABLE_thaw&lt;/code&gt; полезны для классов, где каждый экземпляр является независимым, этот механизм имеет трудности (или несовместим) с объектами, которые существуют как общие ресурсы уровня процесса или уровня системы, такие как одиночные объекты, пулы баз данных, кеши или мемоизированные объекты. .</target>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">В то время как B::Deparse идет на некоторые шаги,чтобы попытаться выяснить,что ваша оригинальная программа делала,некоторые части языка все еще могут его споткнуть;он все еще терпит неудачу даже на некоторых частях собственного тестового набора Perl.Если Вы столкнетесь с неудачей,отличной от наиболее распространённых,описанных в разделе BUGS ниже,Вы можете помочь внести свой вклад в B::Deparse,отправив отчёт об ошибке с небольшим примером.</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">В то время как BigInt имеет обширный опыт работы с Inf и NaN,некоторые причуды остаются.</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">В то время как С гарантирует порядок,указанный в определении структуры,между разными платформами определения могут различаться</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">В то время как Дан Когай сохраняет авторские права в качестве сопровождающего лица,все,кто в этом участвует,должны быть в этом заинтересованы.Список тех,кто предоставил исходные тексты для проекта,см.в AUTHORS.</target>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">Perl пытается сохранить текущее значение vaxc$errno,но если errno не EVMSERR,то это может быть не из текущей операции.</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">В то время как Perl передаёт аргументы в функции по ссылке,C передаёт аргументы по значению;для реализации функции C,которая модифицирует данные одного из &quot;аргументов&quot;,фактическим аргументом этой функции C будет указатель на данные.Таким образом,две функции Си с объявлениями</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">Хотя System V IPC не так широко используется в качестве сокетов, у него все же есть некоторые интересные применения. Однако вы не можете использовать SysV IPC или Berkeley mmap (), чтобы переменная использовалась совместно несколькими процессами. Это потому, что Perl перераспределяет вашу строку, когда вы этого не хотите. Для этого вы можете изучить модули &lt;code&gt;IPC::Shareable&lt;/code&gt; или thread &lt;code&gt;threads::shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">Хорошая пристройка,но она не портативная.Perl-код,по общему признанию,использует их,если они доступны,чтобы получить некоторую дополнительную скорость (по сути,как фанковая форма вставки),но вы не должны этого делать.</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">Во время поиска методы &lt;code&gt;reach&lt;/code&gt; и &lt;code&gt;done&lt;/code&gt; объекта progress вызываются следующим образом:</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">В то время как,по-видимому,целая чокнутая программа,</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">При сборке Perl могут потребоваться некоторые изменения в вашей настройке Cygwin, чтобы Perl собирался чисто. Эти изменения &lt;b&gt;не&lt;/b&gt; требуются для обычного использования Perl.</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">Во время проверки этот модуль собирает свойства документа, например, узлы для гиперссылок ( &lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) и записи индекса ( &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). Трансляторы POD могут использовать эту функцию для проверки синтаксиса и получения узлов в первом проходе перед фактическим началом преобразования. Это дорого с точки зрения времени выполнения, но обеспечивает очень надежные преобразования.</target>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">Хотя эксперты могут спорить об этих идиомах, новичок в понимании Perl может предпочесть способ, который как можно меньше зависит от Perl-guts, что означает автоматическое преобразование и автоматическую генерацию вызовов, как в &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;случае с XSUB&lt;/a&gt; . Дополнительным преимуществом этого подхода является защита модуля записи XSUB от будущих изменений Perl API.</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">Хотя в принципе оператор &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; может быть реализован с помощью (и с теми же довольно серьезными ограничениями) подпрограммы CRTL &lt;code&gt;vfork()&lt;/code&gt; , и хотя имеется некоторая внутренняя поддержка для выполнения именно этого, реализация так и не была завершена, поэтому в настоящее время &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; недоступен. Настоящая &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ядра () ожидается в будущей версии VMS, а псевдо-вилка, основанная на потоках интерпретатора, может быть доступна в будущей версии Perl на VMS (см. &lt;a href=&quot;perlfork&quot;&gt;Perlfork&lt;/a&gt; ). А пока используйте &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , обратные кавычки или указатели файлов по конвейеру для создания подпроцессов.</target>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">В этом режиме Perl принимает специальные меры предосторожности,называемые</target>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">Хотя разрешено &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; управляемый файл FileCache, не делайте этого, если вы вызываете &lt;code&gt;FileCache::cacheout&lt;/code&gt; из пакета, отличного от того, который он был импортирован, или с другим модулем, который переопределяет &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; . Если необходимо, используйте &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">Хотя это и не обязательно для внесения изменений в документацию,новых тестов или тривиальных патчей,часто стоит объяснять,как работает ваше изменение.Даже если это понятно вам сегодня,это может быть не понятно портье в следующем месяце или в следующем году.</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">Хотя можно напрямую ссылаться на эти хэш-ключи вне класса,считается лучшей практикой обернуть весь доступ к атрибуту методами доступа.</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">Хотя это правда, что регулярные выражения Perl напоминают DFA (детерминированные конечные автоматы) программы egrep (1), на самом деле они реализованы как NFA (недетерминированные конечные автоматы), позволяющие выполнять обратный поиск и обратную ссылку. И они тоже не в стиле POSIX, потому что они гарантируют наихудшее поведение во всех случаях. (Кажется, что некоторые люди предпочитают гарантии согласованности, даже если гарантирована медленность.) См. Книгу Джеффри Фридла &amp;laquo;Освоение регулярных выражений&amp;raquo; (от О'Рейли), где приведены все подробности, которые вы могли когда-либо надеяться узнать по этим вопросам ( полная цитата находится в &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">Хотя это правда,что эта документация в некоторой степени подчинена,если вы используете программу с именем</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">Хотя буквальные списки и именные массивы часто взаимозаменяемы,для хэшей это не так.То,что вы можете подписывать значение списка как обычный массив,не означает,что вы можете подписывать значение списка как хэш.Аналогично,хэши,включенные как части других списков (включая списки параметров и возвращаемые из функций списки)всегда разбиваются на пары ключ/значение.Поэтому иногда полезно использовать ссылки.</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">Хотя наиболее важные значения в этом файле</target>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">Хотя ни один из встроенных типов данных не имеет произвольных ограничений на размер (кроме размера памяти),все же существует несколько произвольных ограничений:имя заданной переменной не может быть длиннее 251 символа.Номера строк,отображаемые с помощью диагностики,внутренне хранятся в виде коротких целых чисел,поэтому они ограничены максимум 65535 (на более высокие числа обычно влияет обертка).</target>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">Хотя это и не ограничивается Unix-совместимыми операционными системами (например,WinSock на ПК обеспечивает поддержку сокетов,как и некоторые библиотеки VMS),у вас может не быть сокетов на вашей системе,и в этом случае этот раздел,вероятно,не принесет вам много пользы.С сокетами вы можете делать как виртуальные схемы,такие как TCP-потоки,так и датаграммы,такие как UDP-пакеты.Вы можете сделать еще больше в зависимости от вашей системы.</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">При запуске Configure и при сборке вы,скорее всего,получите довольно много таких предупреждений:</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">Хотя короткие идентификаторы, такие как &lt;code&gt;$gotit&lt;/code&gt; , вероятно, подходят, используйте подчеркивание для разделения слов в более длинных идентификаторах. Это , как правило , легче читать &lt;code&gt;$var_names_like_this&lt;/code&gt; чем &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , особенно для не-носителей английского языка. Это также простое правило, которое последовательно работает с &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">Хотя некоторые разработчики считают фатализацию некоторых предупреждений полезной техникой защитного программирования, использование &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; для фатализации всех возможных категорий предупреждений, включая пользовательские, особенно рискованно. Поэтому использование &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; не &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;рекомендуется&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">Находясь в этом каталоге,напечатайте:</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">Хотя проект GNU включает Perl в свои дистрибутивы,такого понятия,как &quot;GNU Perl&quot;,не существует.Perl не производится и не поддерживается Фондом свободного программного обеспечения.Условия лицензирования Perl также более открыты,чем обычно бывает в программах GNU.</target>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">Хотя стандарт Unicode определяет две дополнительные формы сворачивания регистра, одну для тюркских языков и одну, которая никогда не отображает один символ в несколько символов, они не предусмотрены ядром Perl; Однако модуль &lt;code&gt;Unicode::Casing&lt;/code&gt; CPAN может использоваться для реализации.</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">В то время как ключ должен быть строковым значением (поскольку это основное ограничение,которое Perl накладывает на хэш-ключи),значение в лексиконе на данный момент может быть нескольких типов:определенный скаляр,скаляр или кодовый.Использование этих типов описано выше,в разделе &quot;Метод &quot;maketext&quot;,а нотация в скобках для строк обсуждается в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">В то время как список аргументов может работать нормально для одного,двух или даже трех аргументов,любые другие аргументы становятся трудно запомнить пользователю модуля,а также трудно управляются автором модуля.Если вы хотите добавить новый параметр,вам придется добавить его в конец списка для обратной совместимости,и это,вероятно,сделает ваш список неинтуитивно понятным.Также,если многие элементы могут быть неопределенными,вы можете увидеть следующие непривлекательные вызовы методов:</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">В то время как отображение &quot;infin&quot; на символ &quot;\x{221E}&quot; (будем надеяться)уже было обработано парсером Pod,наличие символа в этом файле означает,что достаточно важно включить в таблицу форматировщиков,которые отображают от заметных символов Юникода до кодов,необходимых для их отображения.Так что,например,для отображения символов в формате Юникод-к-*рофф,это заслуживает записи:</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">Хотя эти два класса могут отличаться по-разному, когда дело доходит до &lt;code&gt;print_content()&lt;/code&gt; , они одинаковы. Это означает, что мы можем попытаться вызвать метод &lt;code&gt;print_content()&lt;/code&gt; для объекта любого класса, и &lt;b&gt;нам не нужно знать, к какому классу принадлежит объект!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">Хотя в настоящее время не существует расширений или модулей,специфичных для архитектуры и распространяемых с perl,для хранения таких файлов можно использовать следующие каталоги (замените строку VERSION на соответствующий номер версии):</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">Хотя эти операции не являются вопросами жизни и смерти, они необходимы для множества полезных скриптов. Это заставляет компиляцию в стиле &lt;code&gt;a.out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">Хотя это действительно можно сделать,это намного сложнее,чем ты думаешь.Например,этот однослойный</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">Хотя это и дает некоторые (существенные?)преимущества в производительности,это значительно усложняет жизнь разработчикам,так как вышеуказанная схема делает невозможным &quot;привязку&quot; DLL к символу в</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">В то время как данный класс в настоящее время реализован с использованием модуля Class::Struct для построения структуроподобного класса,не стоит полагаться на это.</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">Хотя он собирается и работает счастливо,он,вероятно,не будет делать то,что ожидается,а именно,он не печатает &quot;Hello World\n&quot; вообще;С другой стороны,он будет делать в точности то,что ему было сказано делать,компьютеры немного склонны к этому.То есть,он выведет символ новой строки,и вы получите то,что выглядит как пустая строка.Похоже,что есть 2 переменные,когда (из-за опечатки)их действительно 3:</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">Хотя это в настоящее время существует во всех трех реализациях perl сам по себе не использует его.</target>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">Хотя этот документ предназначен для всех авторов модулей,он особенно ориентирован на авторов,желающих опубликовать свои модули на CPAN.</target>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">Хотя это юридическая практика,она,безусловно,сомнительна и фатальна,по крайней мере,на одной платформе:например,VMS cc считает это фатальной ошибкой.Одна из причин,по которой люди часто совершают эту ошибку,заключается в том,что &quot;голый char&quot; и,следовательно,разыменование &quot;голого указателя char&quot; имеет неопределенную подпись:это зависит от компилятора и флагов компилятора и лежащей в его основе платформы,является ли результат знаковым или беззнаковым.По этой же причине плохо использовать 'char' в качестве индекса массива.</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">Хотя на первый взгляд это так,гораздо эффективнее обрабатывать файл по одной строке или запись за раз,потому что тогда вам не придется считывать все это в память сразу.Это также дает вам более тонкий контроль над всем процессом,позволяя вам убить дочерний процесс рано,если вы хотите.</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">Хотя это может быть слишком громоздко для реализации в парсерах Pod на основе событий,для парсеров,которые возвращают деревья для разбора,это просто.</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">Хотя это может случайно сработать на какой-то платформе (где IV является &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ), в целом это невозможно. IV может быть чем-то большим. Еще хуже ситуация с более конкретными типами (определенными на этапе настройки Perl в</target>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">В то время как для однонаправленной связи это работает достаточно хорошо,как насчет двунаправленной связи? Самый очевидный подход не работает:</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">В то время как потоки приносят новый набор полезных инструментов,они также приносят ряд подводных камней.Один из них-состояние гонки:</target>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">Пытаясь читать данные из своего ящика с идентификатором вызывающего абонента, пресловутый Джейми Завински &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; после долгого скрежета зубами и борьбы с &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;tcgetattr&lt;/code&gt; Business POSIX и различными другими функциями, которые не работают ночью, наконец придумал это:</target>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">При использовании стандарта</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">В то время как версия объекты перегрузки stringification, чтобы переносимый конвертировать &lt;code&gt;$^V&lt;/code&gt; в строковом представление, использование &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; &amp;laquo;s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; преобразование, который работает как для клиновых строк или версий объектов:</target>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">Хотя версии ранее 5.8.1 имели потоки,они содержат слишком много ошибок для поддержки.</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">Хотя мы обычно думаем, что шаблоны разделены символами &lt;code&gt;/&lt;/code&gt; , их можно разделить практически любым символом. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; описывает это. Например, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; выше использует фигурные скобки в качестве разделителей. Выбор другого разделителя позволяет избежать использования разделителя внутри шаблона:</target>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">Хотя мы настоятельно рекомендуем вам не создавать свои объекты с нуля, вам следует знать термин &amp;laquo; &lt;b&gt;благословение&amp;raquo;&lt;/b&gt; . &lt;b&gt;Благословлены&lt;/b&gt; структура данных ( так называемый &amp;laquo;референт&amp;raquo;) является объектом. Иногда мы говорим, что объект был &amp;laquo;благословлен в класс&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">Хотя мы обычно думаем о кавычках как о буквальных значениях, в Perl они функционируют как операторы, предоставляя различные виды интерполяции и возможности сопоставления с образцом. Perl предоставляет обычные символы кавычек для этого поведения, но также дает вам возможность выбрать символ кавычек для любого из них. В следующей таблице &lt;code&gt;{}&lt;/code&gt; представляет любую пару разделителей по вашему выбору.</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">Пока мы здесь, внимательно рассмотрим команду ' &lt;b&gt;x&lt;/b&gt; ', она действительно полезна и с удовольствием выгружает вложенные ссылки, полные объекты, частичные объекты - практически все, что вы на нее набросите:</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">Хотя вы можете смешивать двойные двоеточия с одиночными кавычками, кавычки должны стоять после двоеточия: &lt;code&gt;$::::'foo&lt;/code&gt; и &lt;code&gt;$foo::'bar&lt;/code&gt; допустимы, но &lt;code&gt;$::'::foo&lt;/code&gt; и &lt;code&gt;$foo'::bar&lt;/code&gt; не.</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">Хотя для лексических ключей можно использовать произвольные уникальные идентификаторы (например,&quot;_min_larger_max_error&quot;),часто бывает полезно,если ключ записи сам по себе является допустимым значением,как,например,в данном примере сообщения об ошибке:</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">Пока вы это делаете,убедитесь,что вы не пропустили модуль,похожий на тот,который вы собираетесь написать.</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">В то время как управление находится в библиотеке,возникает состояние ошибки.Вы предварительно настроили обратный вызов на Perl для обработки этой ситуации,так что он будет выполнен.После завершения обратного вызова элемент управления снова вернется на Perl.Вот как будет выглядеть поток управления в этой ситуации.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">Пробельные символы не разделяют файловые глобусы.</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">Пробельные символы в именах файлов допускаются на большинстве систем,но не на всех,и даже на системах,где они допускаются,некоторые утилиты могут быть запутаны такими пробелами.</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">Уайтспейс игнорируется.</target>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">Уайтспейс не имеет значения:</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">Кому нужны сложные структуры данных?</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">Кто поддерживает Перла? Кто его разрабатывает? Почему он свободен?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">Кто его написал (используйте АВТОРЫ для нескольких человек).Хорошей идеей будет включить ваш текущий электронный адрес (или какой-нибудь электронный адрес,на который следует отправлять сообщения об ошибках)или какую-нибудь другую контактную информацию,чтобы у пользователей была возможность связаться с вами.Помните,что документация программы имеет тенденцию блуждать в дикой природе гораздо дольше,чем вы ожидаете,и выбирайте способ связи,который,скорее всего,продлится дольше.</target>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">Ой! Вы просто вставляете вкладку и канал в это имя файла! Помните, что в строках с двойными кавычками (&amp;laquo;как \ это&amp;raquo;) обратная косая черта является escape-символом. Полный их список находится в &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators в perlop&lt;/a&gt; . Неудивительно, что в вашей устаревшей файловой системе DOS нет файла с именем &amp;laquo;c: (tab) emp (formfeed) oo&amp;raquo; или &amp;laquo;c: (tab) emp (formfeed) oo.exe&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">Упс.Вместо этого следует использовать это,которое не будет работать,если файл не будет существовать:</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">Почему я получаю длинные десятичные цифры (например,19.9499999999999)вместо цифр,которые я должен получать (например,19.95)?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">Почему мои случайные числа не случайны?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">Почему я не могу получить результат команды с помощью system()?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">Почему я не могу просто открыть (FH, &quot;&amp;gt; file.lock&quot;)?</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">Почему я не могу использовать &quot;C:\temp\foo&quot; в путях DOS? Почему не работает `C:\temp\foo.exe`?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">Почему нельзя найти метод,включенный в этот же файл?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">Почему мой скрипт не может прочитать из STDIN после того,как я дал ему EOF (^D на Unix,^Z на MS-DOS)?</target>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">Почему химеру строят?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">Почему MakeMaker заново изобрел колесо конфигурации сборки? Почему бы просто не использовать autoconf или automake,или ppm,или Ant,или ...</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">Почему мне задают одни и те же вопросы каждый раз,когда я начинаю оболочку?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">Почему я получаю странные пробелы,когда печатаю массив строк?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">Почему я иногда получаю &amp;laquo;слишком длинный список аргументов&amp;raquo;, когда использую &amp;lt;*&amp;gt;?</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">Почему иногда я получаю &quot;Слишком длинный список аргументов&quot;,когда использую его?</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">Почему операторы Perl имеют иной приоритет,чем операторы C?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">Почему регекс-классы символов иногда совпадают только в диапазоне ASCII?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">Почему скрипты setuid perl жалуются на проблемы с ядром?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">Почему некоторые символы неправильно написаны прописными или строчными буквами?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">Почему ты хочешь это сделать? :-)</target>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Почему Perl позволяет мне удалять файлы только для чтения? Почему -i файлы защищены от взлома? Разве это не ошибка на Perl?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">Почему Perl позволяет мне удалять файлы, доступные только для чтения? Почему &lt;code&gt;-i&lt;/code&gt; сбивает защищенные файлы? Разве это не ошибка Perl?</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">Почему функция defined()возвращает true на пустых массивах и хэшах?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">Почему передача подпрограммы неопределенного элемента в хэше создает ее?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">Почему использование $ &amp;amp;, $ `или $ 'замедляет мою программу?</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">Почему не &quot;my ($ foo) = &amp;lt;$ fh&amp;gt;;&quot; работать правильно?</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">Почему &quot;my($foo)=;&quot; не работает правильно?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">Почему &amp;amp; не работает так, как я хочу?</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">Почему Glob(&quot;*.*&quot;)не получает все файлы?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">Почему моя программа сокетов не работает в Системе V (Solaris)? Что означает сообщение об ошибке &quot;Протокол не поддерживается&quot;?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">Почему функция open()не возвращает ошибку при неудачном открытии трубы?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">Почему Perl-однолинеры не работают на моей системе DOS/Mac/VMS?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">Почему бы мне не &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">Почему мои &amp;lt;&amp;lt; ЗДЕСЬ документы не работают?</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">Почему бы моим завязанным хешам не провести различие между определённым и существующим?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">Почему мне не подходит поиск по границе слов с &lt;code&gt;\b&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">Почему бы не поискать слова на сайте \b?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">Почему динамическая связь?</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">Почему int()сломан?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">Почему в моей базе данных есть источник Perl?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">Почему мои восьмеричные данные не интерпретируются правильно?</target>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">Почему странные имена?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">Почему,черт возьми,API Encode отличается?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">Зачем использовать ppport.h?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">Зачем тебе гашиш списков? Давайте возьмем простой пример:У вас есть файл с названиями городов и стран,вот так:</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">Вы можете спросить, зачем вам нужен кусок памяти, содержащий некоторые значения в двоичном представлении? Одна из веских причин - ввод и вывод для доступа к какому-либо файлу, устройству или сетевому соединению, в результате чего это двоичное представление либо навязывается вам, либо дает вам некоторые преимущества при обработке. Другая причина - передача данных в некоторый системный вызов, который недоступен как функция Perl: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; требует, чтобы вы предоставили параметры, хранящиеся так, как это происходит в программе на C. Даже обработка текста (как показано в следующем разделе) может быть упрощена при разумном использовании этих двух функций.</target>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">Зачем? Потому что &lt;code&gt;can&lt;/code&gt; возвращает кодовую ссылку, означающую &amp;laquo;да, может (и метод такой ...)&amp;raquo;, а затем &lt;code&gt;ok&lt;/code&gt; видит кодовую ссылку и думает, что вы передаете функцию, которую хотите, чтобы она вызывала, и учитываете истинность результата. из! Т.е. просто так:</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">Зачем? Потому что &lt;code&gt;nasty_break()&lt;/code&gt; изменяет &lt;code&gt;$\&lt;/code&gt; без предварительной локализации. Значение, которое вы установили в &lt;code&gt;nasty_break()&lt;/code&gt; там, когда вы вернетесь. Исправление - добавить &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; чтобы значение не просачивалось из &lt;code&gt;nasty_break()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">Расширение Wildcard</target>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">Мои старые сценарии сломаются?</target>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">Добавит файл в архив в памяти с именем &lt;code&gt;$filename&lt;/code&gt; и содержимым &lt;code&gt;$data&lt;/code&gt; . Конкретные свойства можно установить с помощью &lt;code&gt;$opthashref&lt;/code&gt; . Поддерживается следующий список свойств: name, size, mtime (дата последнего изменения), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (В MacOS путь к файлу и время модификации конвертируются в эквиваленты Unix.)</target>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">Будет вызван, когда произойдет &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; . (См. &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;Раздел Развязка Gotcha&lt;/a&gt; ниже.)</target>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">Будет загружен по требованию и автоматически вызван BigInt.</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">Будет подготовлено к каждому установочному пути.</target>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">Будет использоваться для изменения набивки,применяемой к строке,как описано выше.</target>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">Оба оставят предложение как есть. Обычно при приеме ввода буквальной строки от пользователя необходимо использовать quotemeta () или &lt;code&gt;\Q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">Превратит &lt;code&gt;$sentence&lt;/code&gt; в &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">Будет croak(),если произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">Умрет,если вызовет r-magic.</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">Сбрасывает содержимое любых ссылок в формате,удобном для чтения человеком.Удобно для таких вещей,как...</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">Выгрузит содержимое любых ссылок в удобочитаемом формате. Обычно вы хотите передать это в &lt;code&gt;note&lt;/code&gt; или &lt;code&gt;diag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">Заставит генерировать тестовый код, использующий старый &lt;code&gt;Test&lt;/code&gt; модуль.</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">Будет неправильно распечатана</target>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">Убедитесь, что = head1 станет &amp;lt;h3&amp;gt;, а = head2 станет &amp;lt;h4&amp;gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">Не заставит &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; перечитать поток каталога. Записи, уже прочитанные до &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; будут просто снова возвращены из буфера кеша. (Win32)</target>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">Не будет работать на платформах,которые не поддерживают тест C на липкий бит.</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">Будет выведено 2, а не 1. Это особенно важно, если вы собираетесь скомпилировать определения с помощью оператора &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , а затем интерполировать их в другой шаблон.</target>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">Предотвращает автоматическое использование INSTALL.SKIP в качестве файла пропуска установки.</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">Напечатает &lt;code&gt;2&lt;/code&gt; , потому что &lt;code&gt;$string&lt;/code&gt; обновляется до UTF-8. Без &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , вместо этого он напечатает &lt;code&gt;4&lt;/code&gt; , поскольку &lt;code&gt;$string&lt;/code&gt; составляет три октета при интерпретации как Latin-1.</target>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">произведет что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">Будет использовать &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt; в качестве класса проводки и сохранить TAP в &lt;code&gt;file.tgz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Функциональные шлейфы Win32 CORE</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">внедрение Win32</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Поддержка Win32 для Sys::Syslog</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Пользователи Win32 должны использовать реальную косую черту.Если вы действительно хотите использовать обратный слеш,подумайте об использовании Sarathy's File::DosGlob,который поставляется со стандартным дистрибутивом Perl.</target>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95 и Win98 и WinME-это вместе Win9x и Win32.</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">Win98 подавится такими вещами,как Encode,если мы установим максимальную длину nmake в 2K.Таким образом,мы выбираем более консервативное значение 1K.</target>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x не может &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; открытый файл (хотя WinNT может).</target>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9x неправильно сообщает о &lt;code&gt;EOF&lt;/code&gt; с неблокирующим чтением по закрытому каналу. Вы увидите следующие сообщения:</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">В 5.6 добавлена поддержка Win9x (Benjamin Stuhl).</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET Server поддерживает модель данных LLP64 на архитектуре Intel Itanium.</target>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Журнал событий Windows, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">Windows-это Win32.</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows-это Windows telnet,Cygwin SSH-это реализация OpenSSH под Cygwin на Windows NT,а Mac Terminal-это терминальное приложение в Mac OS X.Там,где запись отличается от &quot;да&quot; или &quot;нет&quot;,этот эмулятор отображает данный атрибут как нечто другое.Обратите внимание,что в aixterm,clear не сбрасывает цвета;вы должны явно установить цвета обратно на то,что вы хотите.Приветствуются дополнительные записи в этой таблице.</target>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">Пользователи Windows, использующие &lt;code&gt;nmake&lt;/code&gt; , должны помнить, что из-за ошибки в &lt;code&gt;nmake&lt;/code&gt; при указании &lt;code&gt;TEST_FILES&lt;/code&gt; вы должны использовать обратную косую черту вместо прямой.</target>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Испытания для конкретных окон.</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">С $k выбрали тщательно,и,вероятно,будет небольшое число,как 1 или 2.Теоретически,чем больше ковшовый массив,тем меньше вероятность столкновения.</target>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">С помощью 5005threads вы также можете &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; подпрограмму так, чтобы любые вызовы этой подпрограммы из другого потока блокировались до тех пор, пока блокировка не будет снята.</target>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">С помощью &lt;code&gt;/a&lt;/code&gt; можно записать &lt;code&gt;\d&lt;/code&gt; с уверенностью, что он будет соответствовать только символам ASCII, и если возникнет необходимость в сопоставлении за пределами ASCII, вы можете вместо этого использовать &lt;code&gt;\p{Digit}&lt;/code&gt; (или &lt;code&gt;\p{Word}&lt;/code&gt; для &lt;code&gt;\w&lt;/code&gt; ). Существуют похожие конструкции &lt;code&gt;\p{...}&lt;/code&gt; которые могут соответствовать за пределами ASCII как пробелам (см. &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Пробелы в perlrecharclass&lt;/a&gt; ), так и классам Posix (см. &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;Классы символов POSIX в perlrecharclass&lt;/a&gt; ). Таким образом, этот модификатор не означает, что вы не можете использовать Unicode, это означает, что для получения соответствия Unicode вы должны явно использовать конструкцию ( &lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ), которая сигнализирует о Unicode.</target>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">С помощью &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; это можно обойти, используя блок и выражение, в которое вы поместите дескриптор файла:</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">При использовании &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; и STDOUT, и STDERR будут располагаться в том же месте, что и STDOUT и STDERR скрипта, если их не перенаправит команда &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . Обратные кавычки и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; читают &lt;b&gt;только&lt;/b&gt; STDOUT вашей команды.</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">С &lt;code&gt;Class::Tiny&lt;/code&gt; все методы доступа доступны для чтения и записи. Он генерирует для вас конструктор, а также определяемые вами средства доступа.</target>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">С &lt;code&gt;ignore_case&lt;/code&gt; спецификации опций для опций, которые отличаются только регистром, например, &lt;code&gt;&quot;foo&quot;&lt;/code&gt; и &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , будут помечены как повторяющиеся.</target>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">С &lt;code&gt;pass_through&lt;/code&gt; все, что неизвестно, неоднозначно или снабжено недопустимой опцией, не будет помечено как ошибка. Вместо этого неизвестные параметры будут переданы в catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , если они есть, в противном случае - в &lt;code&gt;@ARGV&lt;/code&gt; . Это позволяет писать сценарии оболочки, которые обрабатывают только часть предоставленных пользователем аргументов командной строки и передают оставшиеся параметры какой-либо другой программе.</target>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">С помощью EXPR он возвращает некоторую дополнительную информацию,которую отладчик использует для печати трассировки стека.Значение EXPR показывает,сколько кадров вызова нужно вернуть до текущего.</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">В Mac OS X 10.4 &quot;Tiger&quot; и более новых версиях практически нет штрафов за неограниченное использование библиотек.Более ранние выпуски будут страдать от большей нагрузки,чем статические библиотеки или динамические библиотеки Apple.</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">С NTFS (и без CYGWIN=nontsec)не должно быть проблем,даже если perl был построен на FAT.</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">В стиле OO,вы можете разбить сообщение произвольно.Это означает,что мы больше не ограничены местом в памяти для всего сообщения,т.е.можем обрабатывать сообщения любого размера.</target>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">С Perl 5.004 вы также можете использовать интерфейс TIEHANDLE для доступа к сжатым файлам,как к обычным файлам:</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">С помощью Perl 5.10 и более поздних версий &quot;умный&quot; оператор может дать Вам ответ с наименьшим объемом работы:</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">С &lt;a href=&quot;#code-point-argument&quot;&gt;кодом точкой аргументом&lt;/a&gt; , &lt;code&gt;charscript()&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">С &lt;a href=&quot;#code-point-argument&quot;&gt;аргументом кодовой точки &lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">С небольшой дополнительной работой вы можете получить все группы в угловых скобках,даже если они находятся в других угловых скобках.Каждый раз,когда вы получаете сбалансированное совпадение,удаляйте его внешний разделитель (это тот,который вы только что подобрали,так что не сравнивайте его снова)и добавляйте его в очередь строк для обработки.Продолжайте делать это до тех пор,пока не получите ни одного совпадения:</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">При использовании perl без &lt;code&gt;DEBUGGING&lt;/code&gt; , начинающиеся со &lt;code&gt;128&lt;/code&gt; , имеют 4-байтовые накладные расходы, и, таким образом, сегмент длиной 8192 байта может занимать до 8188 байтов.</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">При использовании параметра slurpy в сигнатуре нет верхнего предела на то,сколько аргументов может быть передано.Параметр массива slurpy может быть безымянным так же,как и позиционный параметр,и в этом случае его единственный эффект-это отключение лимита аргументов,который в противном случае применялся бы:</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">С помощью метода,называемого &quot;копирование на запись&quot;,стоимость копирования с перегрузкой может быть сведена к минимуму или даже полностью исключена.Тестовая реализация COW действительно показала прирост производительности при перегрузке математики,но ввела потерю производительности из-за постоянных накладных расходов на все остальные операции.Таким образом,математика::BigInt в настоящее время не COW.</target>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">С блоком задач ожидается, что тесты внутри не пройдут. Test :: More будет запускать тесты в обычном режиме, но распечатывать специальные флаги, указывающие, что это &amp;laquo;todo&amp;raquo;. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; интерпретирует отказы как нормальные. Если что-то удастся, он сообщит об этом как о неожиданном успехе. Затем вы знаете, что то, что вам нужно было сделать, выполнено и можете удалить флаг TODO.</target>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">При всех вышеперечисленных регексах,если регекс совпадал где-нибудь в строке,то считалось,что он совпадает.Чтобы указать</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">При всех вышеперечисленных регеxps,если регеxp совпадал где-либо в строке,он считался совпадающим.Иногда,однако,нам хотелось бы указать.</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">Используя &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , вы должны быть особенно внимательны, чтобы помнить, на что смотрят, когда:</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">Используя &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , вы должны быть особенно внимательны, чтобы помнить, на что смотрят, когда:</target>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">С помощью любого из них вы можете изменить дескрипторы файлов перед вызовом:</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">С любой версией Perl 5 вы можете использовать основной интерфейс OO:</target>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">При объединении можно установить сразу несколько односимвольных параметров. Например, если &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; - допустимые параметры,</target>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">С более ранними версиями Perl,вы должны сделать немного больше работы.Если вы собираетесь сделать этот запрос много раз по произвольным строковым значениям,то,скорее всего,самым быстрым способом будет инвертирование исходного массива и поддержание хэша,ключи которого являются первыми значениями массива:</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">С выдержками из Perl,а также материалами и предложениями от Рональда Дж.Кимбалла,Дэйва Митчелла,Доминика Данлопа,Марка Джейсона Домина,Стивена Маккаманта и Дэвида Лэндгрена.</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">С крючками приходит возможность вернуться обратно к двигателю Storable.Действительно,крючки-это обычный Perl-код,а Storable удобно использовать,когда дело доходит до сериализации и десериализации вещей,так почему бы не использовать его для работы со строкой сериализации?</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">С большим количеством помощи и предложений от декана Рёриха,Малькольма Битти,Андреаса Кёнига,Пола Хадсона,Ильи Захаревича,Пола Маркеса,Нила Бауэрса,Мэтью Грина,Тима Банса,Человека-паука,Ульриха Пфайфера,Стивена Маккаманта и Гурусами Сарати.</target>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">В методах 2 и 3 Perl начинает синтаксический анализ входного файла с самого начала, если вы не указали переключатель &lt;b&gt;-x&lt;/b&gt; , и в этом случае он просматривает первую строку, начинающуюся с &lt;code&gt;#!&lt;/code&gt; и содержащий слово &quot;perl&quot;, и вместо этого начинается. Это полезно для запуска программы, встроенной в большое сообщение. (В этом случае вы должны указать конец программы с &lt;code&gt;__END__&lt;/code&gt; токена __END__ .)</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">С mod_perl и модулем Apache :: Registry (распространяется с mod_perl) httpd будет работать со встроенным интерпретатором Perl, который предварительно компилирует ваш скрипт, а затем выполняет его в том же адресном пространстве без разветвления. Расширение Apache также предоставляет Perl доступ к внутреннему API сервера, поэтому модули, написанные на Perl, могут делать практически все, что может модуль, написанный на C. Подробнее о mod_perl см. &lt;a href=&quot;http://perl.apache.org/&quot;&gt;Http://perl.apache.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">С большой помощью в отношении общих библиотек от Марка Сабателлы.</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">При отрицательном смещении запоминает свою позицию с конца строки,когда изменяется целевая строка:</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">При отсутствии аргумента MASK он возвращает текущую маску оператора помещения.</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">Без аргументов метод доступа возвращает ссылку на весь массив элемента (независимо от того, был ли элемент указан как &lt;code&gt;'@'&lt;/code&gt; или &lt;code&gt;'*@'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">Без аргументов метод доступа возвращает ссылку на весь хэш элемента (независимо от того, был ли элемент указан как &lt;code&gt;'%'&lt;/code&gt; или &lt;code&gt;'*%'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">Без аргументов (или с использованием &lt;code&gt;threads::all&lt;/code&gt; ) и в контексте списка возвращает список всех несоединенных, несвязанных</target>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">В более старых версиях Perl модуль &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt; предоставляет аналогичные функции.</target>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">С одним или двумя аргументами первый аргумент - это ключ, определяющий один элемент хеша; второй аргумент, если он присутствует, присваивается хеш-элементу. Если тип элемента - &lt;code&gt;'%'&lt;/code&gt; , метод доступа возвращает значение хеш-элемента. Если тип элемента - &lt;code&gt;'*%'&lt;/code&gt; , возвращается ссылка на хэш-элемент.</target>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">С одним или двумя аргументами первый аргумент - это индекс, определяющий один элемент массива; второй аргумент, если он присутствует, присваивается элементу массива. Если тип элемента - &lt;code&gt;'@'&lt;/code&gt; , метод доступа возвращает значение элемента массива. Если тип элемента - &lt;code&gt;'*@'&lt;/code&gt; , возвращается ссылка на элемент массива.</target>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">С опцией -exec,ходит дерево в порядке выполнения,в противном случае в основном порядке.</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">При перегруженной математике только первые два варианта приводят к BigFloat:</target>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">Что касается совмещения символов,есть еще несколько пунктов,о которых вам нужно знать.Прежде всего,не все символы могут быть использованы в матче &quot;как есть&quot;.Некоторые символы,называемые</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">Что касается файлов, то тот, у которого установлен правильный бит разрешения, позволяющий вам получить доступ к файлу. Что касается компьютерных программ, они написаны достаточно хорошо, чтобы кто-то мог понять, что они пытаются делать.</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">Что касается загрузки &lt;code&gt;Exporter&lt;/code&gt; и наследования, есть альтернативы с использованием таких модулей, как &lt;code&gt;base&lt;/code&gt; и &lt;code&gt;parent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">С некоторыми брандмауэрами активный режим не работает, поскольку сервер не может подключиться к вашей машине (потому что вы находитесь за брандмауэром), и брандмауэр не перезаписывает команду. В этом случае вы должны установить &lt;code&gt;ftp_ext_passive&lt;/code&gt; на</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">С помощью фильтров исходного кода вы можете хранить текст вашего скрипта в сжатом виде и использовать фильтр исходного кода,чтобы распаковать его для парсера Perl:</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">Благодаря поддержке &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; это можно обойти - если одна из DLL не запущена из</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">С помощью этого трюка MakeMaker прочитает только первую строку и,таким образом,прочитает подчеркивание,в то время как интерпретатор perl вычислит $VERSION и преобразует строку в число.Более поздние операции,которые рассматривают $VERSION как число,затем смогут сделать это без предупреждения о том,что $VERSION не является числом.</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">С помощью протокола &quot;tcp&quot; метод ping()пытается установить соединение с эхо-портом удаленного хоста.Если соединение успешно установлено,удаленный хост считается доступным.На самом деле эхо-сигнал не передается.Этот протокол не требует никаких специальных привилегий,но имеет более высокие накладные расходы,чем протоколы &quot;udp&quot; и &quot;icmp&quot;.</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">С помощью &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma вы можете использовать слой &lt;code&gt;:locale&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">С помощью оператора &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; сопоставленные переменные &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и т. Д. Сразу становятся доступными для использования в выражении замены. С помощью глобального модификатора &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; будет искать и заменять все вхождения регулярного выражения в строке:</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">С помощью прагмы &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; вы можете управлять поведением встроенной функции &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">С помощью субпрагмы &lt;code&gt;IN&lt;/code&gt; вы можете объявить уровни входных потоков по умолчанию, а с помощью субпрагмы &lt;code&gt;OUT&lt;/code&gt; вы можете объявить уровни по умолчанию для выходных потоков. С помощью субпрагмы &lt;code&gt;IO&lt;/code&gt; вывода вы можете управлять как входными, так и выходными потоками одновременно.</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">С логическим именем &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; , определенным как &quot;ENABLE&quot;, установка &lt;code&gt;$?&lt;/code&gt; приведет к тому, что новое значение будет закодировано в &lt;code&gt;$^E&lt;/code&gt; так что исходные родительские или дочерние значения статуса выхода от 0 до 255 могут быть автоматически восстановлены программами на C, ожидающими поведения _POSIX_EXIT. Если и родительское, и дочернее значение выхода не равны нулю, тогда предполагается, что это фактически значение собственного статуса VMS, которое нужно передать. Специальное значение 0xFFFF - это почти NOOP, поскольку оно приведет к тому, что текущий собственный статус VMS в библиотеке C станет текущим собственным статусом Perl VMS, и обрабатывается таким образом, поскольку известно, что оно не является допустимым значением статуса собственного VMS. Рекомендуется использовать только значения в диапазоне обычных номеров родительского или дочернего статуса Unix от 0 до 255.</target>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">С операторами в стиле С,которые были бы написаны так:</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">С модулем FCGI (из CPAN) и модулем mod_fastcgi (доступным на &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) каждая из ваших программ Perl становится постоянным процессом демона CGI.</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">При наличии аргумента MASK он устанавливает маску оператора для отсека (эквивалент вызова метода deny_only).</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">В наборе макросов _POSIX_EXIT выходное значение Unix равняется нулю,а значения Unix от 2 до 255 кодируются уравнением:</target>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">С помощью параметра check_sigs можно включать и выключать проверку сигнатур.По умолчанию на данный момент отключена,т.к.вся цепочка инструментов для функциональности некоторыми еще не считается зрелой.Автор CPAN.pm порекомендовал бы большую часть времени устанавливать ее в true и выключать только в том случае,если это окажется раздражающим.</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">После завершения примера 4 у нас теперь есть простой способ моделирования некоторых реальных библиотек, интерфейсы которых могут быть не самыми чистыми в мире. Теперь мы продолжим обсуждение аргументов, переданных компилятору &lt;b&gt;xsubpp&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">С созданием модулей &lt;code&gt;IO::Compress&lt;/code&gt; и &lt;code&gt;IO::Uncompress&lt;/code&gt; никаких новых функций для &lt;code&gt;Compress::Zlib&lt;/code&gt; не планируется - новые модули делают все, что делает &lt;code&gt;Compress::Zlib&lt;/code&gt; , а затем и некоторые. Разработка &lt;code&gt;Compress::Zlib&lt;/code&gt; будет ограничена только исправлением ошибок.</target>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">При настройке по умолчанию размер ограничен 128MB.Значение -1 снимает это ограничение.Если &quot;make test&quot; не удается,пожалуйста,измените /etc/security/limits,как указано выше.</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">В приведенном выше примере вы знали, что нужно искать &lt;code&gt;Perl_pp_add&lt;/code&gt; , но что, если было несколько обращений к нему повсюду или вы не знали, какую операцию вы ищете?</target>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">С помощью следующих опций вы получаете Perl версию,которая проходит все тесты make в 32-битном режиме.</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">С помощью следующих опций вы получаете Perl-версию,которая проходит все make тесты в 64-битном режиме.</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">С помощью следующих опций вы получаете потоковую Perl-версию,которая проходит все тесты make в 64-битном режиме.</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">Со следующими опциями вы получаете потоковую Perl версию,которая проходит все тесты в потоковом 32-битном режиме,что является конфигурацией по умолчанию для Perl сборок,которые AIX поставляется с.</target>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">С введением лексических предупреждений,обязательные предупреждения теперь стали</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">С введением</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">При отпущенном замке процесс &quot;B&quot; теперь может продолжаться.Он также обновляет БД и,к сожалению,тоже модифицирует данные,которые были в его первоначальном буфере.Как только эти данные будут прошиты на диск,он перезапишет некоторые/все изменения процесса &quot;A&quot;,внесенные в БД.</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">С выходом 5.003_01 динамически загружаемые библиотеки должны быть перестроены при компиляции другой версии Perl.В частности,DLL (включая</target>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">При наличии этого ключевого слова &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;создается переменная RETVAL&lt;/a&gt; , и в сгенерированном вызове подпрограммы эта переменная назначается, но значение этой переменной не будет использоваться в автоматически сгенерированном коде.</target>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">При использовании этой опции,рендерингу каждого оператора (начиная с оператора nextstate OP)будет предшествовать 1-я строка исходного кода,которая его генерирует.Например:</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">В этом синтаксисе пробельные символы после &amp;laquo;C &amp;lt;&amp;lt;&amp;lt;&amp;raquo; и перед &amp;laquo;&amp;gt;&amp;gt;&amp;gt;&amp;raquo; (или любой другой буквой) являются</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">При этом потребуется &quot;какой-нибудь пакет&quot;,после чего тайник проверяется,и каждая функция выводится на экран.</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">При этом &lt;code&gt;charinrange()&lt;/code&gt; вернет &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если его входная кодовая точка соответствует &lt;code&gt;$default&lt;/code&gt; . Вы можете избежать этого, пропустив &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператор и добавив строку после цикла для обработки последнего элемента карты инверсии.</target>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">С нитями нужно быть осторожным,чтобы убедиться,что все они имеют шанс бежать до конца,предполагая,что это то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">В случае тестов todo лучше всего запускать тесты. Так вы узнаете, когда они начнут проходить. Иногда это невозможно. Часто неудачный тест приводит к тому, что вся программа умирает или зависает, даже внутри &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; с и с использованием &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; . В этих крайних случаях у вас нет другого выбора, кроме как полностью пропустить сломанные тесты.</target>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">Внутри &lt;code&gt;(?[ ])&lt;/code&gt; Буквальные символы не допускаются, если они не находятся во внутренней паре квадратных скобок, например</target>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">Внутри Perl,вы можете использовать это напрямую:</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">Внутри USS ваш /etc/профиль или $HOME/.profile может ограничивать ваши настройки ulimit.Убедитесь,что следующая команда возвращает разумные значения:</target>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">Внутри блока Pod есть &lt;b&gt;параграфы Pod&lt;/b&gt; . Абзац модуля состоит из непустых строк текста, разделенных одной или несколькими пустыми строками.</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">В пределах класса персонажей:</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">Внутри шаблона можно обозначить подмаски для последующего использования,заключив их в круглые скобки,а также можно сослаться на</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Внутри подпрограммы массив &lt;code&gt;@_&lt;/code&gt; содержит параметры, переданные этой подпрограмме. Внутри подпрограммы &lt;code&gt;@_&lt;/code&gt; - это массив по умолчанию для операторов массива &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">В шаблонах поиска (которые также заменяются двойными кавычками) есть досадная двусмысленность: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; следует интерпретировать как &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (где &lt;code&gt;[bar]&lt;/code&gt; - это класс символов для регулярное выражение) или как &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (где &lt;code&gt;[bar]&lt;/code&gt; - это индекс массива @foo)? Если @foo иначе не существует, то это, очевидно, класс символов. Если @foo существует, Perl хорошо догадывается о &lt;code&gt;[bar]&lt;/code&gt; и почти всегда прав. Если он ошибается, или если вы просто параноик, вы можете заставить правильную интерпретацию использовать фигурные скобки, как указано выше.</target>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">В строках, которые должны отображаться в текстовом поле фиксированной длины, каждый управляющий символ заменяется пробелом. (Но помните об особом значении &lt;code&gt;\r&lt;/code&gt; при использовании режима заполнения.) Это сделано, чтобы избежать перекоса, когда управляющие символы &amp;laquo;исчезают&amp;raquo; на некоторых носителях вывода.</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">Внутри этой базовой формы добавьте части,которые необходимо вставить,изменить или удалить строки.</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">В этом модуле создайте подпрограмму &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">Внутри подпрограммы &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; вызовите &lt;code&gt;filter_add&lt;/code&gt; , передав ему ссылку на подпрограмму.</target>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">Внутри альтернативной группы нумерации номера групп начинаются с одной и той же позиции для каждой альтернативы.После группы нумерация продолжается на единицу выше максимального значения,достигнутого во всех альтернативных вариантах.</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">Внутри анонимной подпрограммы или блока, переданного в &lt;code&gt;FILTER&lt;/code&gt; , обработайте содержимое $ _, чтобы изменить исходный код желаемым образом.</target>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">В рамках &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;использования функция unicode_strings&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">В рамках &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;использования языковой стандарт not_characters&lt;/a&gt; или &lt;a href=&quot;perllocale&quot;&gt;используйте языковой стандарт,&lt;/a&gt; и текущий языковой стандарт является локалью UTF-8.</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">В рамках &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; или выше</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">В рамках области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; все кодовые точки, отличные от ASCII Latin1, заключаются в кавычки, независимо от того, закодирована ли строка как UTF-8 или нет. Как упоминалось выше, языковой стандарт не влияет на цитирование символов диапазона ASCII. Это защищает от тех языков, в которых используются такие символы, как &lt;code&gt;&quot;|&quot;&lt;/code&gt; считаются символами слова.</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">В рамках &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">В рамках области &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; все кодовые точки, отличные от ASCII Latin1, заключаются в кавычки, независимо от того, закодирована ли строка как UTF-8 или нет. Как упоминалось выше, языковой стандарт не влияет на цитирование символов диапазона ASCII. Это защищает от тех языков, в которых используются такие символы, как &lt;code&gt;&quot;|&quot;&lt;/code&gt; считаются символами слова.</target>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">В справочнике подпрограммы вызовите &lt;code&gt;filter_read&lt;/code&gt; или &lt;code&gt;filter_read_exact&lt;/code&gt; , чтобы &quot; заполнить &quot; $ _ данными исходного кода из исходного файла, который будет &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ваш модуль. Проверьте возвращаемое значение статуса, чтобы узнать, действительно ли был прочитан какой-либо исходный код.</target>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">В цикле while мы вызываем accept () и проверяем, возвращает ли он ложное значение. Обычно это означает, что необходимо сообщить о системной ошибке. Однако введение безопасных сигналов (см. &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Отложенные сигналы (Safe Signals)&lt;/a&gt; выше) в Perl 5.8.0 означает, что accept () также может быть прерван, когда процесс получает сигнал. Обычно это происходит, когда один из разветвленных подпроцессов завершает работу и уведомляет родительский процесс сигналом CHLD.</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">Без поддержки Readline вы можете видеть символы &quot;^[[A]&quot;,&quot;^[[C]&quot;,&quot;^[[B],&quot;^[[D]&quot;,&quot;^H&quot;,...при использовании клавиш со стрелками и/или клавиш с обратной связью.</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">Без дополнительной конфигурации GetOptions()проигнорирует регистр имен опций и позволит сократить их до уникальности.</target>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает регулярное выражение для упрощения отдельных строк элементов после определения типа списка. Использование: например, при преобразовании в HTML можно удалить начальное число в упорядоченном списке, поскольку &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; уже сам печатает числа. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-rx&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;rx ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает информацию о теге списка, который может быть любым скаляром. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-tag&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;tag ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает информацию о родителе, содержащем этот список, который представлен в виде произвольного скаляра. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-parent&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;parent ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">Без аргументов получает массив элементов этого списка.Элементы могут быть представлены любым скаляром.Если задан аргумент,то он вытесняется в список элементов.</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргумента извлекает имя файла, в котором находится список. Это должно быть установлено ранее либо путем указания &lt;b&gt;-file&lt;/b&gt; в методе &lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;file ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргумента извлекает уровень отступа списка, указанный в &lt;code&gt;=over n&lt;/code&gt; . Это должно было быть установлено ранее, указав &lt;b&gt;-indent&lt;/b&gt; в &lt;b&gt;методе &lt;/b&gt;&lt;b&gt;new ()&lt;/b&gt; или вызвав метод &lt;b&gt;indent ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргумента извлекает номер строки, с которой начался список. Это должно было быть установлено ранее либо путем указания &lt;b&gt;-start&lt;/b&gt; в методе &lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;start ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">Без аргументов извлекает тип списка, который может быть произвольным значением, например &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... при мышлении в формате HTML. Это должно было быть установлено ранее либо указанием &lt;b&gt;-type&lt;/b&gt; в методе &lt;b&gt;new (),&lt;/b&gt; либо путем вызова метода &lt;b&gt;type ()&lt;/b&gt; со скалярным аргументом.</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">Без аргументов libnetcfg отображает текущую конфигурацию.</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">Без autodie (и при условии, что BAREWORD - это открытый дескриптор файла / dirhandle) это правильный вызов chdir. Но в autodie &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; будет вести себя так, как будто у него был прототип &quot;; $&quot;, и поэтому BAREWORD будет синтаксической ошибкой (в разделе &quot;use strict&quot;. Без strict он будет интерпретироваться как имя файла).</target>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">Без режима binmode это случается,но без режима binmode,print()выходит из строя вместо write().</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">Без компиляции специального Perl невозможно получить точно такое же поведение любых версий до Perl 5.18.0.Ближайший путь-установить значение PERL_PERTURB_KEYS равным 0 и значение PERL_HASH_SEED равным известному значению.Мы не рекомендуем эти настройки для использования в производстве в связи с вышеизложенными соображениями безопасности.</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">Не отправив почту на адрес и не увидев,есть ли на другом конце человек,который может вам ответить,вы не сможете полностью ответить на вопрос.</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">Без тестов,предоставленных первоначальным автором,как кто-либо может быть уверен в том,что в будущем,изменив perl,он не случайно сломал поведение патч-инструментария? А без тестов,как автор патча может быть уверен,что его тяжелый труд,вложенный в патч,не будет случайно выброшен кем-то в будущем?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">Без этой пустой строки перед &quot;=head1&quot; многие переводчики не узнали бы &quot;=head1&quot; как стартующий блок Под.</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">Без &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; объявления $ AUTOLOAD этот код не будет компилироваться согласно директиве &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">Без \\ перед#мы бы начали комментарий Makefile,и макрос был бы неверно определен.</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">Без объявления &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; критически важного &lt;a href=&quot;functions/use&quot;&gt;использования использование&lt;/a&gt; UTF ‑ 8 в литералах и идентификаторах не будет работать правильно. Если вы использовали только что приведенную выше стандартную преамбулу, это уже произошло. Если да, то вы можете сделать следующее:</target>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">Без фигурных скобок Perl искал бы переменные $ whospeak, &lt;code&gt;$who::0&lt;/code&gt; и &lt;code&gt;$who's&lt;/code&gt; . Последние две будут переменными $ 0 и $ s в (предположительно) несуществующем пакете &lt;code&gt;who&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">Без файловой рукоятки нет простого способа отобразить карту от обратного вызова C к подпрограмме Perl.</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">Без кавычек Perl преобразовывал бы большое число в константу с плавающей точкой во время компиляции,а затем передавал бы результат в BigInt,что приводило бы к усеченному результату или NaN.</target>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">Без этой прагмы,если строки,работающие по байтовой семантике,и строки с символьными данными Юникода будут скомкатированы,новая строка будет создана путем декодирования байтовых строк как</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">Символы слов</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">Рабочая бригада</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">Несколько раз обходите 255-символьный лимит DCL и в некоторых случаях используйте кавычки из командной строки в стиле VMS.</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">Работа для накачки,работа для программистов Perl,работа для авторов модулей,...Perl должен быть простым.</target>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">Рабочий код всегда предпочитается идеям &quot;пирога в небе&quot;.Заплатка для добавления функции имеет гораздо больше шансов попасть в язык,чем случайный запрос функции,независимо от того,насколько горячо он был аргументирован.Это связано с вопросом &quot;Будет ли это полезно?&quot;,поскольку тот факт,что кто-то потратил время на создание патча,свидетельствует о сильном желании использовать эту возможность.</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">Работа с аудио-видео оборудованием</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">Работа с ВГС</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">Работа с сетью::FTP</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">Работа с SV</target>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">В настоящее время работает только для целых чисел.</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">Работает точно так же , как , &lt;code&gt;like()&lt;/code&gt; , только он проверяет $ GOT &lt;b&gt;не&lt;/b&gt; соответствует заданному шаблону.</target>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">Работает так же, как &lt;a href=&quot;#localtime&quot;&gt;местное время,&lt;/a&gt; но возвращаемые значения локализованы для стандартного часового пояса Гринвича.</target>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">Работает так же, как &lt;a href=&quot;localtime&quot;&gt;местное время,&lt;/a&gt; но возвращаемые значения локализованы для стандартного часового пояса Гринвича.</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">Работает так же , как &lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt; &amp;laquo;s &lt;code&gt;cmp_ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">Работает так же,как и index(),за исключением того,что она возвращает позицию</target>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">Работает как &lt;code&gt;sv_catpvf&lt;/code&gt; , но копирует текст в SV вместо того, чтобы добавлять его. Не справляется с магией &amp;laquo;установки&amp;raquo;. См. &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">Работает как &lt;code&gt;sv_vcatpvf&lt;/code&gt; , но копирует текст в SV вместо того, чтобы добавлять его. Не справляется с магией &amp;laquo;установки&amp;raquo;. См. &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">Работает как &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , но копирует текст в SV вместо того, чтобы добавлять его.</target>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">Всемирная паутина,HTML,HTTP,CGI,MIME</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">Хуже того,если у вас есть такой язык,как китайский или японский,который имеет сотни или тысячи иероглифов,то вы действительно не можете поместить их всего в 256,поэтому им пришлось совсем забыть про ASCII,и построить свои системы,используя пары чисел,чтобы ссылаться на один иероглиф.</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">Напечатал бы '1', потому что &lt;code&gt;$foo&lt;/code&gt; содержит ссылку на</target>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">Будет работать bin/foobar.PL вот так:</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">Обернитесь вокруг CPAN.pm без использования какого-либо модуля XS</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">Обертка вокруг Config.pm</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">Класс обертки для вызова подгрупп в конце области видимости</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">Обертывание всех вызовов die в подпрограмме обработчика может быть полезно, чтобы увидеть, как и откуда они вызываются, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; имеет дополнительную информацию:</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">Заключение в круглые скобки позволяет ссылаться на части с подстановочными знаками во &lt;code&gt;globmap&lt;/code&gt; файле Glob вторым параметром в globmap , &lt;code&gt;#1.tgz&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">Оборачивает любые ссылки CODE, найденные в аргументах, заменяя каждую на результат вызова &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; для ссылки CODE. Любые ссылки на ARRAY или HASH в аргументах проверяются рекурсивно.</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">Завершает дерево операций некоторыми дополнительными операциями, чтобы во время выполнения была создана динамическая область видимости. Исходные операции выполняются в новой динамической области, а затем, при условии, что они завершаются нормально, область будет развернута. Дополнительные опсы , используемые для создания и размотать динамический объем, как правило , быть &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; пара, но &lt;code&gt;scope&lt;/code&gt; оп может быть использована вместо этого , если опов достаточно просто , чтобы не нуждаться в полные структурах динамической области видимости.</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">Записать &lt;code&gt;SIZE&lt;/code&gt; байт данных из &lt;code&gt;BUFFER&lt;/code&gt; на сервер, а также выполнить любую необходимую трансляцию &amp;lt;CRLF&amp;gt;. &lt;code&gt;TIMEOUT&lt;/code&gt; является необязательным, если он не указан, будет использоваться значение тайм-аута из командного соединения.</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">Запишите &lt;code&gt;SIZE&lt;/code&gt; байт в сегмент разделяемой памяти в &lt;code&gt;POS&lt;/code&gt; . Возвращает истину в случае успеха или ложь в случае ошибки. См. &lt;a href=&quot;../functions/shmwrite&quot;&gt;Shmwrite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">Напишите информацию о MYMETA в MYMETA.json и MYMETA.yml.</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">Записывайте файлы/буферы RFC 1950 года</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">Напишите файлы/буферы RFC 1951 года</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">Записывать файлы/буферы RFC 1952 года</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">Записывать данные YAMLish</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">Напишите форматер как Pod::Простой подкласс.</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">Доступ к записи через git</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">Запишите запись,имя которой эквивалентно имени файла,предоставленного на диск.Опционально принимает второй параметр,который является полным родным путем (включая имя файла),в который будет записываться запись.</target>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">Запись bzip2 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">Пишите документацию в POD</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">Записывать на диск файлы, имена которых эквивалентны любому из имен в &lt;code&gt;@filenames&lt;/code&gt; , при необходимости создавая подкаталоги. Это может не очень хорошо работать под VMS. В MacPerl время модификации файла будет преобразовано в нулевое время MacOS, и соответствующие преобразования будут выполнены в путь. Однако длина каждого элемента пути не проверяется, чтобы узнать, длиннее ли она, чем позволяет MacOS в настоящее время (32 символа).</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">Запись линкерных опций файлов для динамического расширения</target>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">Напишите код на C для perlmain.c</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">Запишите архив in-memory на диск.Первым аргументом может быть либо имя файла,либо ссылка на уже открытую файловую оболочку (GLOB-ссылка).</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">Запишите состояние в файл.</target>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">Напишите в файл. При этом используются файловые дескрипторы, например, полученные при вызове &lt;code&gt;POSIX::open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">Пишите по адресу modules@perl.org,объясняя,что вы сделали,чтобы связаться с текущим мэйнтейнером.Администраторы PAUSE также попытаются связаться с сопровождающим.</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">Записывайте zip-файлы/буферы</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">Доступ только для записи к данным в файле.</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile()теперь делает некоторые базовые проверки на вменяемость своих параметров для защиты от опечаток и некорректных значений.Это означает,что некоторые вещи,которые раньше работали,теперь будут бросать предупреждения и,возможно,приводить к внутренним ошибкам.</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">Записывает байты РАЗМЕР от STRING в сегмент памяти на ADDR,начиная с позиции POS.Если STRING слишком длинный,используются только байты РАЗМЕРА;если STRING слишком короткий,записываются нули для заполнения байтов РАЗМЕРА.Возвращает true в случае успеха или false в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">Записывает файл кода C и файл кода XS, которые вы должны &lt;code&gt;#include&lt;/code&gt; и &lt;code&gt;INCLUDE&lt;/code&gt; в разделах C и XS соответственно кода XS вашего модуля. Вероятно, вы захотите сделать это в своем &lt;code&gt;Makefile.PL&lt;/code&gt; , чтобы вы могли легко редактировать список констант, не касаясь остальной части вашего модуля. Поддерживаемые атрибуты:</target>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">Записывает отформатированную запись (возможно, многострочную) в указанный FILEHANDLE, используя формат, связанный с этим файлом. По умолчанию формат файла имеет то же имя, что и дескриптор файла, но формат для текущего выходного канала (см. Функцию &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ) можно задать явно, присвоив имя формата переменной &lt;code&gt;$~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">Записывает отформатированную запись (возможно, многострочную) в указанный FILEHANDLE, используя формат, связанный с этим файлом. По умолчанию формат файла имеет то же имя, что и дескриптор файла, но формат для текущего выходного канала (см. Функцию &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ) можно задать явно, присвоив имя формата переменной &lt;code&gt;$~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">Записывает все файлы в и под текущей директорией в вашу</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">Пишет пустой FORCE:цель.</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">Запись разрешена,т.е.открыта как &quot;w&quot; или &quot;r+&quot; или &quot;a&quot; и т.д.</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">Записывает содержимое &lt;code&gt;$buffer&lt;/code&gt; в сжатый файл. Возвращает количество фактически записанных байтов или 0 в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">Записывает файл META.yml (мета-данные в кодировке YAML)и META.json (мета-данные в кодировке JSON)о модуле в дистрибутиве.Формат следует за Module::Build's настолько близко,насколько это возможно.</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">Записывает файл SIGNATURE с надписью &quot;cpansign -s&quot;.</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">Пишет на выходе из</target>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">Аксессуары для письма</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">Писатели-конструкторы</target>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">Написание Perl на платформе EBCDIC в действительности ничем не отличается от написания на платформе &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; , но с другими базовыми числами, как мы вскоре увидим. Вам нужно будет кое-что знать об этих платформах &lt;a href=&quot;#ASCII&quot;&gt;ASCII,&lt;/a&gt; потому что документация предвзята и часто будет использовать номера примеров, которые не относятся к EBCDIC. Также очень мало модулей CPAN, написанных для EBCDIC и не работающих с ASCII; вместо этого подавляющее большинство модулей CPAN написано для ASCII, и некоторые из них могут работать на EBCDIC, в то время как некоторые были разработаны для переносимой работы на обоих.</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">Плагины для письма</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">Написание собственного отладчика.</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">Написание фильтра</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">Написание модуля с MakeMaker</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">Написание исходного фильтра как отдельного исполняемого файла работает нормально, но влечет за собой небольшое снижение производительности. Например, если вы выполните небольшой пример выше, будет создан отдельный подпроцесс для запуска команды Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; . Для каждого использования фильтра требуется собственный подпроцесс. Если создание подпроцессов в вашей системе обходится дорого, вы можете рассмотреть один из других вариантов создания фильтров источника.</target>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">Написание обратных ссылок в вашей программе посылает четкий сигнал читателям вашего кода о том,что вы хотели получить результат команды.Зачем посылать четкое сообщение,которое не является правдой?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">Написание хороших тестовых сценариев</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">Подпрограммы написания</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">Написать подпрограммы легко:</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">Написание заплаты</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">Рекомендуется сначала написать короткий вариант,потому что он легче читается.Длинный вариант в любом случае достаточно длинный,чтобы привлечь к нему внимание,а короткий вариант в противном случае может потеряться в зрительном шуме.</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">Написание печатной карты Записи</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">Неправильно: движок Storable создает для вас пустой. Если вы знаете Eiffel, вы можете рассматривать &lt;code&gt;STORABLE_thaw&lt;/code&gt; как альтернативную процедуру создания.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">Эксплуатационная пригодность XPG часто подразумевает наличие</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH аргументирует И устанавливает RETVAL И присваивает возвращаемое значение массиву</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XS ВЕРСИЯ</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Код XS добавлен Грегом Бэконом &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">Код XS обычно можно заставить работать с любой платформой,но зависимые библиотеки,заголовочные файлы и т.д.могут быть не всегда доступны или переносимы,либо сам код XS может быть специфичен для любой платформы,точно так же,как и Perl-код.Если библиотеки и заголовки переносятся,то обычно разумно удостовериться,что код XS тоже переносится.</target>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Код XS для использования собственных функций C, заимствованных из &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; , написанный Маркусом Харнишем &amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">Код XS имеет полный доступ к системным вызовам,включая функции библиотеки C.Таким образом,он имеет возможность вмешиваться в то,что установлено ядром Perl или другими модулями,такими как обработчики сигналов или файловые дескрипторы.Он может вмешиваться в память или в любое количество вредных вещей.Не надо.</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">Код XS,вероятно,лучше использовать &quot;typemap&quot;,если он ожидает аргументы FILE *.Стандартная карта типов будет скорректирована для понимания любых изменений в этой области.</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">Код XS очень чувствителен к номеру версии модуля и будет жаловаться,если номер версии в вашем модуле Perl не совпадает.Если вы измените версию модуля#без повторного запуска Makefile.PL,старый номер версии останется в Makefile,в результате чего XS-код будет собран с неправильным номером.</target>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XS-это формат файла описания интерфейса,используемый для создания интерфейса расширения между Perl и C-кодом (или C-библиотекой),который желательно использовать с Perl.Интерфейс XS комбинируется с библиотекой для создания новой библиотеки,которая затем может быть либо динамически загружена,либо статически скомпонована с perl.Описание интерфейса XS написано на языке XS и является основным компонентом интерфейса расширения Perl.</target>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">Модули XS для всех категорий, кроме &lt;code&gt;LC_NUMERIC&lt;/code&gt; , получают базовый языковой стандарт, и, следовательно, любые функции библиотеки C, которые они вызывают, будут использовать этот базовый языковой стандарт. Для получения дополнительной информации см. &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;ПРЕДОСТЕРЕЖЕНИЯ в perlxs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">Модули типа XS требуют перекомпоновки двоичного файла perl,потому что часть модуля XS написана на &quot;C&quot;,и должна быть скомпонована с исполняемым двоичным файлом perl.Это необходимо,так как perl в DJGPP собирается с опцией &quot;статическое соединение&quot;,из-за отсутствия &quot;динамического соединения&quot; в среде DJGPP.</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-Динамически загружать библиотеки C в Perl-код</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUB и стопка аргументов</target>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUB также могут избегать автоматического преобразования аргументов функции Perl в аргументы функции C. См. Подробности в &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; . Некоторые люди предпочитают ручное преобразование путем проверки &lt;code&gt;ST(i)&lt;/code&gt; даже в тех случаях, когда подойдет автоматическое преобразование, утверждая, что это упрощает логику вызова XSUB. Сравните с &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&amp;laquo;Полностью избавиться от XSUB&amp;raquo;&lt;/a&gt; для аналогичного компромисса с полным разделением &amp;laquo;клея Perl&amp;raquo; и &amp;laquo;рабочей лошадки&amp;raquo; XSUB.</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">XSUB также могут возвращать списки, а не только скаляры. Это необходимо сделать, немного изменив значения стека ST (0), ST (1) и т. Д. См. Подробности в &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">XSUB могут иметь списки параметров переменной длины, если в списке параметров указать многоточие &lt;code&gt;(...)&lt;/code&gt; . Это использование многоточия аналогично тому, что используется в ANSI C. Программист может определить количество аргументов, переданных в XSUB, исследуя переменную &lt;code&gt;items&lt;/code&gt; , которую компилятор &lt;b&gt;xsubpp&lt;/b&gt; предоставляет для всех XSUB. Используя этот механизм, можно создать XSUB, который принимает список параметров неизвестной длины.</target>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB не имеют CvPADLIST. dXSTARG извлекает значения из PL_curpad, но на самом деле это панель вызывающих абонентов (слот которой выделяется каждым входом). Не получать и не устанавливать CvPADLIST, если CV является XSUB (как определено &lt;code&gt;CvISXSUB()&lt;/code&gt; ), слот CvPADLIST повторно используется для другой внутренней цели в XSUB.</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUB ссылаются на свои аргументы стека с помощью макроса &lt;b&gt;ST (x)&lt;/b&gt; , где</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION:-D строка для установки версии xs при компиляции.</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION:версия в вашем файле .xs.По умолчанию $(VERSION).</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO:какой макрос представляет версию XS.</target>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPM было бы более разумно сделать аргумент PADOFFSET пустым SAVEPADSV(PADOFFSET po)</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">ХХХ:Нужно больше докторов.</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">жетон результата ЯМЛ.</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="9a8fc610a3168e82e07390203ce40d7382c7da6f" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DDThh:mm:ss</source>
          <target state="translated">YYYY-MM-DDThh:mm:ss</target>
        </trans-unit>
        <trans-unit id="76ac22fb38468218ad6552d9043d5bb2c7920d48" translate="yes" xml:space="preserve">
          <source>Year Value Interpretation</source>
          <target state="translated">Год толкования стоимости</target>
        </trans-unit>
        <trans-unit id="44f6289f7e3326b30824a187cdb204e4dc7264b2" translate="yes" xml:space="preserve">
          <source>Years greater than 999 are interpreted as being the actual year, rather than the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won the Nobel prize, not the year 3864.</source>
          <target state="translated">Годы,превышающие 999,интерпретируются как фактический год,а не как смещение с 1900.Таким образом,1964 указал бы год,в котором Мартин Лютер Кинг выиграл Нобелевскую премию,а не год 3864.</target>
        </trans-unit>
        <trans-unit id="c9ec20e90ee8369d4a4738a1355fc718ca45a57e" translate="yes" xml:space="preserve">
          <source>Years in the range 0..99 are interpreted as shorthand for years in the rolling &quot;current century,&quot; defined as 50 years on either side of the current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy, but matches the way people currently think about two digit dates. Whenever possible, use an absolute four digit year instead.</source>
          <target state="translated">Годы в диапазоне 0...99 интерпретируются как сокращение на годы в переходящем &quot;текущем веке&quot;,определяемом как 50 лет по обе стороны от текущего года.Таким образом,сегодня,в 1999 году,0 будет означать 2000 год,а 45-2045 год,а 55-1955 год.Через двадцать лет 55 лет будет означать вместо этого 2055 год.Это грязно,но соответствует тому,как люди в настоящее время думают о двухзначных датах.Когда это возможно,используйте абсолютные четыре цифры года вместо них.</target>
        </trans-unit>
        <trans-unit id="862a9bbc8aa08db48d5ef905c8dc85be457e6ea8" translate="yes" xml:space="preserve">
          <source>Years in the range 100..999 are interpreted as offset from 1900, so that 112 indicates 2012. This rule also applies to years less than zero (but see note below regarding date range).</source>
          <target state="translated">Годы в диапазоне 100...999 интерпретируются как смещенные с 1900 года,так что 112 указывает на 2012 год.Это правило также применяется к годам меньше нуля (но в отношении диапазона дат см.примечание ниже).</target>
        </trans-unit>
        <trans-unit id="dfc439a506f8ca9ae872d5d02c2ad4c82b034c13" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">Да, см. Предыдущий ответ. Поскольку &lt;code&gt;Compress::Zlib&lt;/code&gt; и, следовательно, &lt;code&gt;IO::Zlib&lt;/code&gt; не поддерживают &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; по своим дескрипторам файлов, у них нет другого выбора, кроме как считывать архив в память. Это нормально, если вы хотите манипулировать архивом в памяти.</target>
        </trans-unit>
        <trans-unit id="acb5099459bfa43931dd4b78a628e1d113168a69" translate="yes" xml:space="preserve">
          <source>Yes it is. It's pure perl, so it's a lot slower then your &lt;code&gt;/bin/tar&lt;/code&gt; However, it's very portable. If speed is an issue, consider using &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">Да, это так. Это чистый Perl, поэтому он намного медленнее, чем ваш &lt;code&gt;/bin/tar&lt;/code&gt; . Однако он очень портативен. Если скорость является проблемой, рассмотрите возможность использования &lt;code&gt;/bin/tar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4107dbe8a030ec286ba38d4f763957128d667542" translate="yes" xml:space="preserve">
          <source>Yes, it does</source>
          <target state="translated">Да,это так.</target>
        </trans-unit>
        <trans-unit id="3678471c058284ba4000bf6331c346c6bbd02a28" translate="yes" xml:space="preserve">
          <source>Yes, that's a lot of expansion.</source>
          <target state="translated">Да,это большое расширение.</target>
        </trans-unit>
        <trans-unit id="eb5a8cd62389870da5aba481f01f1a18a4a6e511" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt; , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">Да, этого много :-) Но точнее, в системах UNIX есть утилита под названием &lt;code&gt;file&lt;/code&gt; , которая распознает файлы данных на основе их содержимого (обычно их первых нескольких байтов). Для этого нужен файл с именем</target>
        </trans-unit>
        <trans-unit id="dc1e472e45c46619f7f9549ce98213f0173da937" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt; . Thank-you notes are good. It makes people smile.</source>
          <target state="translated">Да, вы можете сделать это либо с помощью опции &lt;code&gt;-T&lt;/code&gt; , либо вызвав программу в качестве &lt;code&gt;perlthanks&lt;/code&gt; . Благодарственные письма хороши. Это заставляет людей улыбаться.</target>
        </trans-unit>
        <trans-unit id="2c8d0f90fcceba5d3649946cef16ef6f0de57be0" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma.</source>
          <target state="translated">Да, ты можешь! Если ваши источники имеют кодировку UTF-8, вы можете указать это с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd3c0b60626749e4fb04200f5ac37da9c3ba6f91" translate="yes" xml:space="preserve">
          <source>Yes, you could probably do the same thing with code like $token-&amp;gt;isa('Pod::Simple::PullParserEndToken'), but that's not so pretty as using just $token-&amp;gt;type, or even the following shortcuts:</source>
          <target state="translated">Да, вы, вероятно, могли бы сделать то же самое с кодом вроде $ token-&amp;gt; isa ('Pod :: Simple :: PullParserEndToken'), но это не так красиво, как использование только типа $ token-&amp;gt; или даже следующих сочетаний клавиш:</target>
        </trans-unit>
        <trans-unit id="9ba10bd10462c10515a891999d5f144a0ef8db84" translate="yes" xml:space="preserve">
          <source>Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will want to use a framework to make handling requests and responses easier.</source>
          <target state="translated">Да,если вы строите веб-сайт с любым уровнем интерактивности (формы/пользователи/базы данных),вы захотите использовать фреймворк,чтобы сделать обработку запросов и ответов проще.</target>
        </trans-unit>
        <trans-unit id="4131deed69500e1ce76a1aa4746c5be5d04540cb" translate="yes" xml:space="preserve">
          <source>Yes. Perl's garbage collection system takes care of this so everything works out right.</source>
          <target state="translated">Да.Система сбора мусора Перла позаботится об этом,чтобы все получилось.</target>
        </trans-unit>
        <trans-unit id="3a7fae4176564291917eb6c0f952942b7ae63ec5" translate="yes" xml:space="preserve">
          <source>Yes. Read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more information. Some examples follow. (These assume standard Unix shell quoting rules.)</source>
          <target state="translated">Да. Прочтите &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; для получения дополнительной информации. Ниже приведены некоторые примеры. (Они предполагают стандартные правила цитирования оболочки Unix.)</target>
        </trans-unit>
        <trans-unit id="85739d75a309637ea84dea150d48798fe5f385f6" translate="yes" xml:space="preserve">
          <source>Yet Another Compiler Compiler. A parser generator without which Perl probably would not have existed. See the file</source>
          <target state="translated">Еще один компилятор.Генератор парсеров,без которого Perl,вероятно,не существовал бы.Смотрите файл</target>
        </trans-unit>
        <trans-unit id="7fafe5e36aa3122413d32c6d4c8b4284bb245038" translate="yes" xml:space="preserve">
          <source>Yet another capturing group numbering technique (also as from Perl 5.10) deals with the problem of referring to groups within a set of alternatives. Consider a pattern for matching a time of the day, civil or military style:</source>
          <target state="translated">Еще один метод нумерации групп (также как и на Perl 5.10)связан с проблемой отнесения групп к набору альтернатив.Рассмотрим схему соответствия времени суток,гражданскому или военному стилю:</target>
        </trans-unit>
        <trans-unit id="a23e788a3e5975e13dc401fc7dc400a7d94469f5" translate="yes" xml:space="preserve">
          <source>Yet another framework for writing test scripts</source>
          <target state="translated">Еще одна основа для написания тестовых сценариев</target>
        </trans-unit>
        <trans-unit id="50d7418e5885441f0de4ccbd54d601d8993cfb34" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that NEXT.pm provides is &lt;code&gt;EVERY&lt;/code&gt; . Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">Еще один псевдокласс, который предоставляет NEXT.pm, - &lt;code&gt;EVERY&lt;/code&gt; . Его поведение значительно проще, чем у семейства &lt;code&gt;NEXT&lt;/code&gt; . Звонок:</target>
        </trans-unit>
        <trans-unit id="807fa18eacfa8333a4615b7233d28577520ce46b" translate="yes" xml:space="preserve">
          <source>Yet another way is to assign to a &lt;code&gt;foreach&lt;/code&gt; loop</source>
          <target state="translated">Еще один способ - назначить цикл &lt;code&gt;foreach&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb6a80ccd3cd48516fa10f2b5e43ec6135ec9451" translate="yes" xml:space="preserve">
          <source>Yet another way would be to use the Devel::Peek module:</source>
          <target state="translated">Еще одним способом будет использование модуля Devel::Peek:</target>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="f551936e2c614f3a2dff9203d64b57c373086792" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">Вы &lt;b&gt;не&lt;/b&gt; вызываете &lt;code&gt;setlogsock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adc6962b12f722ff929475c965699bd91420b623" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt; , and you skip that character, you can never match a &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">Вы &lt;b&gt;должны&lt;/b&gt; преобразовать символы в UV, используя вышеуказанные функции, если вы когда-нибудь окажетесь в ситуации, когда вам нужно сопоставить символы UTF-8 и не-UTF-8. В этом случае нельзя пропускать символы UTF-8. Если вы сделаете это, вы потеряете возможность сопоставлять hi-bit символы, отличные от UTF-8; например, если ваша строка UTF-8 содержит &lt;code&gt;v196.172&lt;/code&gt; , и вы пропустите этот символ, вы никогда не сможете сопоставить &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; в строке, отличной от UTF-8. Так что не делай этого!</target>
        </trans-unit>
        <trans-unit id="84f6ab55499a431ab963225e1b323e598c043cac" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; have the BFD (-lbfd) library installed, otherwise &lt;code&gt;perl&lt;/code&gt; will fail to link. The BFD is usually distributed as part of the GNU binutils.</source>
          <target state="translated">У вас &lt;b&gt;должна&lt;/b&gt; быть установлена ​​библиотека BFD (-lbfd), иначе &lt;code&gt;perl&lt;/code&gt; не сможет подключиться. BFD обычно распространяется как часть GNU binutils.</target>
        </trans-unit>
        <trans-unit id="b5fb57ccedc3fdf63890d16c6dbd3e60731ff70f" translate="yes" xml:space="preserve">
          <source>You CAN say</source>
          <target state="translated">Ты можешь сказать.</target>
        </trans-unit>
        <trans-unit id="f4ab9d853c38812e284656a7bf6f62a6214856cd" translate="yes" xml:space="preserve">
          <source>You already learned that a &lt;b&gt;method&lt;/b&gt; is a subroutine that operates on an object. You can think of a method as the things that an object can</source>
          <target state="translated">Вы уже узнали, что &lt;b&gt;метод&lt;/b&gt; - это подпрограмма, которая работает с объектом. Вы можете думать о методе как о вещах, которые объект может</target>
        </trans-unit>
        <trans-unit id="9a0c2a8aac855d59d1e419df17c0d8362fab4ef6" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вы также не можете выйти из блока или подпрограммы сортировки, используя любой из операторов управления циклом, описанных в &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn,&lt;/a&gt; или с помощью &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cce8f481cd5c5e068e4367b0b286efd66e3e8b5e" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вы также не можете выйти из блока или подпрограммы сортировки, используя любой из операторов управления циклом, описанных в &lt;a href=&quot;perlsyn&quot;&gt;perlsyn,&lt;/a&gt; или с помощью &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6462e3c6fa18441789982aade2cc057d4a5754fa" translate="yes" xml:space="preserve">
          <source>You also don't have to use push(). You could just make a direct assignment if you knew where you wanted to put it:</source>
          <target state="translated">Вам также не нужно использовать функцию push().Вы можете просто сделать прямое задание,если знаете,куда его поставить:</target>
        </trans-unit>
        <trans-unit id="762d8de62e5184e1ddd3f7df62b51251838a45ad" translate="yes" xml:space="preserve">
          <source>You also have to be careful about context. You can assign an array to a scalar to get the number of elements in the array. This only works for arrays, though:</source>
          <target state="translated">Вы также должны быть осторожны с контекстом.Вы можете назначить массив скаляру,чтобы получить количество элементов в массиве.Однако это работает только для массивов:</target>
        </trans-unit>
        <trans-unit id="e9900e6006f63d330e774e6c340305cdfb9e9fa2" translate="yes" xml:space="preserve">
          <source>You also need dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">Также вам понадобится dmake. См. Раздел &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; выше, чтобы узнать, как его получить.</target>
        </trans-unit>
        <trans-unit id="ad4cae9e1d17ccae297619ff7a90fc58163adef4" translate="yes" xml:space="preserve">
          <source>You are allowed to use underscores (underbars) in numeric literals between digits for legibility (but not multiple underscores in a row: &lt;code&gt;23__500&lt;/code&gt; is not legal; &lt;code&gt;23_500&lt;/code&gt; is). You could, for example, group binary digits by threes (as for a Unix-style mode argument such as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</source>
          <target state="translated">Вам разрешено использовать подчеркивания (подчеркивания) в числовых литералах между цифрами для удобочитаемости (но не несколько подчеркиваний подряд: &lt;code&gt;23__500&lt;/code&gt; недопустимо; &lt;code&gt;23_500&lt;/code&gt; разрешено ). Вы можете, например, сгруппировать двоичные цифры по тройкам (как для аргумента режима Unix, такого как 0b110_100_100) или по четверкам (для представления полубайтов, как в 0b1010_0110) или в других группах.</target>
        </trans-unit>
        <trans-unit id="e9086be8aa3acbf107ed69aa30ed1efd2e29806d" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect the root directory (</source>
          <target state="translated">При вызове функции вы выполняете chdir () d to &lt;code&gt;$File::Find::dir&lt;/code&gt; , если не указано &lt;code&gt;no_chdir&lt;/code&gt; . Обратите внимание, что при переходе в каталоги действует корневой каталог (</target>
        </trans-unit>
        <trans-unit id="765a24f0e7b225890131f993a03189d4db8249a5" translate="yes" xml:space="preserve">
          <source>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</source>
          <target state="translated">Вы либо используете копию zlib,которая старше версии 1.2.0,либо хотите,чтобы код вашего приложения мог работать с как можно большим количеством различных версий zlib.</target>
        </trans-unit>
        <trans-unit id="a13d801950c0dc8ed9906d27d14a9952af5a263a" translate="yes" xml:space="preserve">
          <source>You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">Вам предлагается принять участие в обсуждении и выступить в защиту вашего патча.Иногда ваш патч может затеряться в тасовании.Если в течение месяца не было предпринято никаких действий,уместно отправить письмо-напоминание на p5p.Пожалуйста,помните,что все разработчики Perl 5-добровольцы,и будьте вежливы.</target>
        </trans-unit>
        <trans-unit id="719d41b23df4f3bd674c48a03b68b419d4539869" translate="yes" xml:space="preserve">
          <source>You are encouraged to use &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; over &lt;code&gt;ok()&lt;/code&gt; where possible, however do not be tempted to use them to find out if something is true or false!</source>
          <target state="translated">Вам рекомендуется использование &lt;code&gt;is()&lt;/code&gt; и &lt;code&gt;isnt()&lt;/code&gt; над &lt;code&gt;ok()&lt;/code&gt; , где это возможно, однако не поддавайтесь искушению использовать их , чтобы выяснить , если что - то является истинным или ложным!</target>
        </trans-unit>
        <trans-unit id="7231b46f1cb348d100d3ac2d2fb73b6bf57d8066" translate="yes" xml:space="preserve">
          <source>You are guaranteed that &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; will denote the same location as the original $path.</source>
          <target state="translated">Вам гарантировано, что &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; будет обозначать то же местоположение, что и исходный путь $.</target>
        </trans-unit>
        <trans-unit id="845992c360c01c1fffb9e8ef6310e8cc47a34923" translate="yes" xml:space="preserve">
          <source>You are not supposed to modify arrays while they are being iterated over. For speed and efficiency reasons, Perl internally does not do full reference-counting of iterated items, hence deleting such an item in the middle of an iteration causes Perl to see a freed value.</source>
          <target state="translated">Вы не должны изменять массивы,пока они итератируются.Из соображений скорости и эффективности Perl внутренне не производит полный подсчет итерационных элементов по ссылкам,поэтому удаление такого элемента в середине итерации приводит к тому,что Perl видит освобожденное значение.</target>
        </trans-unit>
        <trans-unit id="c4250931e7c7965b87b322df0e377d3c209e4074" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; explicitly if you wish to slurp the file. In future versions of Perl assigning a reference to will throw a fatal error.</source>
          <target state="translated">Рекомендуется изменить код, чтобы явно установить &lt;code&gt;$/&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если вы хотите проглотить файл. В будущих версиях Perl присвоение ссылки вызовет фатальную ошибку.</target>
        </trans-unit>
        <trans-unit id="d65f3a3a78dc9835626ba2ec61976c50a4907da1" translate="yes" xml:space="preserve">
          <source>You are responsible for &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</source>
          <target state="translated">Вы несете ответственность за &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; для возвращаемого значения, если вы планируете хранить его где-нибудь на полустационарном уровне (в противном случае оно может быть удалено из-под вас в следующий раз, когда кеш станет недействительным).</target>
        </trans-unit>
        <trans-unit id="37e416f1d8fe7e351baa8b0e70e6dc37f69f6f41" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to implement methods below, at least either encode() or decode().</source>
          <target state="translated">Настоятельно рекомендуется реализовать методы,приведенные ниже,по крайней мере,либо encode(),либо decode().</target>
        </trans-unit>
        <trans-unit id="ff134e38e289cfa6f5f3d471d7e0e0fabcbe8c66" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the &lt;code&gt;threads&lt;/code&gt; and &lt;code&gt;threads::shared&lt;/code&gt; modules) as soon as possible.</source>
          <target state="translated">Вам настоятельно рекомендуется как можно скорее перенести любой существующий многопоточный код в новую модель (т. Е. Использовать &lt;code&gt;threads&lt;/code&gt; и &lt;code&gt;threads::shared&lt;/code&gt; модули).</target>
        </trans-unit>
        <trans-unit id="2a08b19fff728f8eb38fe62f343715380f316ef9" translate="yes" xml:space="preserve">
          <source>You aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:</source>
          <target state="translated">Конечно,вам не разрешается изменять константы таким образом.Если бы аргумент был на самом деле буквальным,и вы попытались его изменить,вы бы сделали исключение (предположительно фатальное).Например,это не сработает:</target>
        </trans-unit>
        <trans-unit id="1622820db3665cc19fb76f05a9e122011064bf68" translate="yes" xml:space="preserve">
          <source>You can &quot;make install&quot; already but you should test first.</source>
          <target state="translated">Вы уже можете &quot;сделать установку&quot;,но сначала нужно протестировать.</target>
        </trans-unit>
        <trans-unit id="441d296a1602f9e39d91a622912b032dea66e8b8" translate="yes" xml:space="preserve">
          <source>You can (and should) read more about references in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can</source>
          <target state="translated">Вы можете (и должны) прочитать больше о ссылках в &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; . Вкратце, ссылки больше похожи на указатели, которые знают, на что они указывают. (Объекты также являются своего рода справочником, но они нам не понадобятся сразу - если вообще когда-либо.) Это означает, что когда у вас есть что-то, что вам кажется похожим на доступ к двумерному массиву и / или хеш, на самом деле происходит то, что базовый тип - это просто одномерный объект, который содержит ссылки на следующий уровень. Просто ты можешь</target>
        </trans-unit>
        <trans-unit id="4c8d7d3437af9191b3b2ecdbf2e0cc22d58ff901" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">Вы можете &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; Изе только один элемент совокупности. Обычно это делается на динамике:</target>
        </trans-unit>
        <trans-unit id="3c3c57d183363a886eda26951cab8a3d873beb8e" translate="yes" xml:space="preserve">
          <source>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</source>
          <target state="translated">Вы можете получить доступ к первым символам строки с помощью функции substr().Например,чтобы получить первый символ,начните с позиции 0 и захватите строку длиной 1.</target>
        </trans-unit>
        <trans-unit id="4b6168183223c539ff65f81f73941c2c4a8e59c2" translate="yes" xml:space="preserve">
          <source>You can actually chomp anything that's an lvalue, including an assignment:</source>
          <target state="translated">Ты можешь на самом деле нажимать все,что имеет ценность,включая задание:</target>
        </trans-unit>
        <trans-unit id="ab3659f896bba38cbe056eb37538d331f15d2fcc" translate="yes" xml:space="preserve">
          <source>You can actually chop anything that's an lvalue, including an assignment.</source>
          <target state="translated">Ты можешь нарезать все,что имеет ценность,включая задание.</target>
        </trans-unit>
        <trans-unit id="06e51b7968687b9d39d3fba6b7611216b01c17eb" translate="yes" xml:space="preserve">
          <source>You can actually put an array or hash anywhere in the list, but the first one in the list will soak up all the values, and anything after it will become undefined. This may be useful in a my() or local().</source>
          <target state="translated">На самом деле вы можете поместить массив или хэш куда угодно в список,но первый в списке впитает все значения,и все что угодно после этого станет неопределенным.Это может быть полезно в my()или local().</target>
        </trans-unit>
        <trans-unit id="9fcefecb0feb2b6d0223364636eebffcb896a89d" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt; ) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt; , etc.</source>
          <target state="translated">Вы можете добавить настраиваемые псевдонимы к стандартным ( &lt;code&gt;:full&lt;/code&gt; ) соглашениям об именах Unicode. Псевдонимы отменяют любые стандартные определения, поэтому, если вы достаточно запутались, вы можете заменить &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; на &lt;code&gt;&quot;B&quot;&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="422d4c1954392600b653163b725624c46d77f3f0" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt; , but this will not actually move the seek pointer.</source>
          <target state="translated">Вы можете настроить счетчик, присвоив &lt;code&gt;$.&lt;/code&gt; , но на самом деле это не приведет к перемещению указателя поиска.</target>
        </trans-unit>
        <trans-unit id="add234c624f206426ee8290a3ddfc9b8ceedcb89" translate="yes" xml:space="preserve">
          <source>You can also alter the way the output and logic of &lt;code&gt;Carp&lt;/code&gt; works, by changing some global variables in the &lt;code&gt;Carp&lt;/code&gt; namespace. See the section on &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; below.</source>
          <target state="translated">Вы также можете изменить способ работы и логику работы &lt;code&gt;Carp&lt;/code&gt; , изменив некоторые глобальные переменные в пространстве имен &lt;code&gt;Carp&lt;/code&gt; . См. Раздел &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="0d61dd797cd63f1042bbffa35621af46e71f5b31" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">Вы также можете вызвать &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; с аргументом ссылки, и если он находится в ловушке внутри &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; содержит эту ссылку. Это позволяет более тщательно обрабатывать исключения с использованием объектов, которые поддерживают произвольное состояние исключения. Такая схема иногда предпочтительнее сопоставления определенных строковых значений &lt;code&gt;$@&lt;/code&gt; с регулярными выражениями. Поскольку &lt;code&gt;$@&lt;/code&gt; - глобальная переменная, а &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; может использоваться в реализациях объекта, будьте осторожны, чтобы анализ объекта ошибки не заменял ссылку в глобальной переменной. Проще всего перед любыми манипуляциями сделать локальную копию референса. Вот пример:</target>
        </trans-unit>
        <trans-unit id="151ae294544e5b15c198686df29c5202445b492a" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">Вы также можете вызвать &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; с аргументом ссылки, и если он находится в ловушке внутри &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;$@&lt;/code&gt; содержит эту ссылку. Это позволяет более тщательно обрабатывать исключения с использованием объектов, которые поддерживают произвольное состояние исключения. Такая схема иногда предпочтительнее сопоставления определенных строковых значений &lt;code&gt;$@&lt;/code&gt; с регулярными выражениями. Поскольку &lt;code&gt;$@&lt;/code&gt; - глобальная переменная, а &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; может использоваться в реализациях объекта, будьте осторожны, чтобы анализ объекта ошибки не заменял ссылку в глобальной переменной. Проще всего перед любыми манипуляциями сделать локальную копию референса. Вот пример:</target>
        </trans-unit>
        <trans-unit id="9cdb85fa1e67a62d3e70dba3d5bf1c75c04f7e09" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method.</source>
          <target state="translated">Вы также можете вызвать parse_lines () для анализа массива строк или parse_string_document () для анализа документа, уже находящегося в памяти. Как и в случае с parse_file (), parse_lines () и parse_string_document () по умолчанию отправляют свой вывод в &lt;code&gt;STDOUT&lt;/code&gt; , если не были изменены с помощью метода output_fh ().</target>
        </trans-unit>
        <trans-unit id="e57fcafa1ea35942e9edb2cd8f5d66578716838d" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this will make first a copy and then multiply it by 2:</source>
          <target state="translated">Вы можете так же цепочку звонков,это сделает сначала копию,а затем умножит на 2:</target>
        </trans-unit>
        <trans-unit id="029fcbbc45bf12d25b834057d9395bba7ab192ae" translate="yes" xml:space="preserve">
          <source>You can also change the internal suspects list via &lt;code&gt;set_suspects&lt;/code&gt; method.</source>
          <target state="translated">Вы также можете изменить внутренний список подозреваемых с помощью метода &lt;code&gt;set_suspects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2a2e4e937f2dcf302981b9beceb35f4afd812bf" translate="yes" xml:space="preserve">
          <source>You can also choose to use rsync to get a copy of the current source tree for the bleadperl branch and all maintenance branches:</source>
          <target state="translated">Вы также можете использовать rsync,чтобы получить копию текущего дерева исходных текстов для ветки bleadperl и всех ветвей обслуживания:</target>
        </trans-unit>
        <trans-unit id="69913c0f24daf22d2c432ea27b2a49c000488188" translate="yes" xml:space="preserve">
          <source>You can also control the 'hushed' flag at run-time, using the built-in routine vmsish::hushed(). Without argument, it returns the hushed status. Since vmsish::hushed is built-in, you do not need to &quot;use vmsish&quot; to call it.</source>
          <target state="translated">Вы также можете управлять флагом 'hushed' во время выполнения,используя встроенную рутинную vmsish::hushed().Без аргументов,он возвращает статус &quot;hushed&quot;.Поскольку vmsish::hushed встроен,вам не нужно &quot;использовать vmsish&quot; для его вызова.</target>
        </trans-unit>
        <trans-unit id="563cd6bbc176ecbc734b5b0b439a546964280899" translate="yes" xml:space="preserve">
          <source>You can also control the character encoding and entities. For example, if you're sure that the POD is properly encoded (using the &lt;code&gt;=encoding&lt;/code&gt; command), you can prevent high-bit characters from being encoded as HTML entities and declare the output character set as UTF-8 before parsing, like so:</source>
          <target state="translated">Вы также можете управлять кодировкой символов и сущностями. Например, если вы уверены, что POD правильно закодирован (с помощью команды &lt;code&gt;=encoding&lt;/code&gt; ), вы можете предотвратить кодирование символов с высоким битом как объекты HTML и объявить выходной набор символов как UTF-8 перед синтаксическим анализом, например :</target>
        </trans-unit>
        <trans-unit id="ce7cb29295e37cbd29b717e64482225d4d4ba414" translate="yes" xml:space="preserve">
          <source>You can also control the shell that perl uses to run system() and backtick commands via PERL5SHELL. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">Вы также можете управлять оболочкой, которую Perl использует для запуска команд system () и обратных ссылок, через PERL5SHELL. См. &lt;a href=&quot;perlrun&quot;&gt;Perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6274126a67429902f21b4ff102d4a5f157ec82" translate="yes" xml:space="preserve">
          <source>You can also create a circular reference with a single variable:</source>
          <target state="translated">Можно также создать круговую ссылку с одной переменной:</target>
        </trans-unit>
        <trans-unit id="fe319fa0895a7f47e55075d55fc2289e3b3f2bea" translate="yes" xml:space="preserve">
          <source>You can also do</source>
          <target state="translated">Вы также можете сделать</target>
        </trans-unit>
        <trans-unit id="69a5ee6a0a8ad7101d445832b3faf4f8db8fd92c" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">Вы также можете сделать то же самое с модулем &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="efdd9cfab2b6e73dabdc31999bde389ad6e9c40e" translate="yes" xml:space="preserve">
          <source>You can also do the wrapping explicitly by rad2rad(), deg2deg(), and grad2grad().</source>
          <target state="translated">Вы также можете делать обёртку явно с помощью функций rad2rad(),deg2deg()и grad2grad().</target>
        </trans-unit>
        <trans-unit id="e971cca5e90229321a699ea5b197dee6a304b5cb" translate="yes" xml:space="preserve">
          <source>You can also do this directly in the match operator using the &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; sequences. The &lt;code&gt;\Q&lt;/code&gt; tells Perl where to start escaping special characters, and the &lt;code&gt;\E&lt;/code&gt; tells it where to stop (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details).</source>
          <target state="translated">Вы также можете сделать это прямо в операторе сопоставления с использованием &lt;code&gt;\Q&lt;/code&gt; и &lt;code&gt;\E&lt;/code&gt; последовательности. &lt;code&gt;\Q&lt;/code&gt; говорит Perl , где начать специальные символы, а &lt;code&gt;\E&lt;/code&gt; сообщает ему , где остановиться (см &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; для более подробной информации).</target>
        </trans-unit>
        <trans-unit id="fe2d0afbbbfb95dc9ef1705dc46b6eb4a3e77627" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">Вы также можете сделать это для большинства систем, используя модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; из CPAN, который проще в использовании и теоретически более портативен.</target>
        </trans-unit>
        <trans-unit id="f3337ad9bcb6d402cd92e0314d2032a9a8dc4c0a" translate="yes" xml:space="preserve">
          <source>You can also easily say to use all categories but one, by either, for example,</source>
          <target state="translated">Можно также легко сказать,что можно использовать все категории,кроме одной,например,по одной,</target>
        </trans-unit>
        <trans-unit id="317bed7b561a99db6e7463d3bee761b35a18aa16" translate="yes" xml:space="preserve">
          <source>You can also embed newlines directly in your strings, i.e., they can end on a different line than they begin. This is nice, but if you forget your trailing quote, the error will not be reported until Perl finds another line containing the quote character, which may be much further on in the script. Variable substitution inside strings is limited to scalar variables, arrays, and array or hash slices. (In other words, names beginning with $ or @, followed by an optional bracketed expression as a subscript.) The following code segment prints out &quot;The price is $100.&quot;</source>
          <target state="translated">Вы также можете встраивать новые строки непосредственно в строки,т.е.они могут заканчиваться на другой строке,а не начинаться.Это хорошо,но если вы забудете о своей трейлинговой котировке,об ошибке не будет сообщено до тех пор,пока Perl не найдет другую строку,содержащую символ котировки,который может быть намного дальше по тексту скрипта.Подстановка переменных внутри строк ограничена скалярными переменными,массивами и массивами или хэш-фрагментами.(Другими словами,имена,начинающиеся с $ или @,с последующим необязательным выражением в скобках в качестве подскрипта).Следующий сегмент кода распечатывает &quot;Цена $100&quot;.</target>
        </trans-unit>
        <trans-unit id="6dc98b973b8e3861953362cf4137bf9098b40a23" translate="yes" xml:space="preserve">
          <source>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</source>
          <target state="translated">Вы также можете явно указать,что один обработчик предназначен для всех типов референтов:</target>
        </trans-unit>
        <trans-unit id="cc7d393dae203f89e29915d158bc84c0d091344a" translate="yes" xml:space="preserve">
          <source>You can also explicitly specify the argument number to use for the join string using something like &lt;code&gt;*2$v&lt;/code&gt;; for example:</source>
          <target state="translated">Вы также можете явно указать номер аргумента, который будет использоваться для строки соединения, используя что-то вроде &lt;code&gt;*2$v&lt;/code&gt; ; например:</target>
        </trans-unit>
        <trans-unit id="3c69b8b0664f8688a90139832b96e7b725fab5ec" translate="yes" xml:space="preserve">
          <source>You can also gain some minuscule measure of efficiency by pre-extending an array that is going to get big. You can also extend an array by assigning to an element that is off the end of the array. You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</source>
          <target state="translated">Вы также можете получить некоторую минусовую меру эффективности,предварительно расширив массив,который будет становиться большим.Вы также можете расширить массив,назначив элемент,который находится вне конца массива.Можно усечь массив до нуля,присвоив ему нулевой список ().Следующее эквивалентно:</target>
        </trans-unit>
        <trans-unit id="87f6d7508324248bf5fa6b6a6e4e9d73a898fe92" translate="yes" xml:space="preserve">
          <source>You can also get a pointer to the end of the string stored in the SV with the macro:</source>
          <target state="translated">Также с помощью макроса можно получить указатель на конец строки,хранящейся в SV:</target>
        </trans-unit>
        <trans-unit id="843f7af3e5947338619464418b011d78b7714032" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">Вы также можете получить различия с помощью вычитания, которое возвращает объект &lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0da6f0ff3f9840990993a84402f300e13eb838e3" translate="yes" xml:space="preserve">
          <source>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical &lt;code&gt;++&lt;/code&gt; autoincrement operator or the syscall() function.</source>
          <target state="translated">Вы также можете столкнуться с тонкими проблемами в тех немногих операциях в Perl, которые действительно заботятся о разнице между строкой и числом, таких как магический оператор автоинкремента &lt;code&gt;++&lt;/code&gt; или функция syscall ().</target>
        </trans-unit>
        <trans-unit id="dd7d480332101e4bfe5db6a1d74af4d69d28cfca" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">Вы также можете получить точность из следующего аргумента, используя &lt;code&gt;.*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="31317a51fe6916c8950fb1738da08a3f662e794a" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so the loop continues to the &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">Вы также можете просмотреть каждый элемент и пропустить те, которые видели раньше. Используйте хеш для отслеживания. В первый раз, когда цикл видит элемент, этот элемент не имеет ключа в &lt;code&gt;%Seen&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператор создает ключ и сразу использует его значение, которое &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , поэтому цикл продолжается до &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; и увеличивает значение для этого ключа. В следующий раз, когда цикл увидит тот же элемент, его ключ существует в хэше</target>
        </trans-unit>
        <trans-unit id="7930ef83d4a331d3e89d11f276bc35572519ad08" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;code&gt;Fcntl&lt;/code&gt; module:</source>
          <target state="translated">Вы также можете импортировать символьные константы &lt;code&gt;S_I*&lt;/code&gt; из модуля &lt;code&gt;Fcntl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="254f31569eb5ae2200e952d6645d10bd474402c9" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt; . Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Вы также можете вставить ловушки в систему включения файлов, поместив код Perl непосредственно в &lt;code&gt;@INC&lt;/code&gt; . Эти ловушки могут быть ссылками на подпрограммы, ссылками на массивы или благословенными объектами. См. &lt;a href=&quot;functions/require&quot;&gt;Требовать&lt;/a&gt; подробностей.</target>
        </trans-unit>
        <trans-unit id="ae3dcb264a37bf433b3f44d57e7b80c09701bead" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the @INC array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="translated">Вы также можете вставить крючки в средство импорта,поместив Perl-код непосредственно в массив @INC.Существует три формы хуков:ссылки в подпрограммном обеспечении,ссылки в массивах и благословенные объекты.</target>
        </trans-unit>
        <trans-unit id="05e59c02014a1d5de9eba1297e8dbc08a175322a" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; on an undefined value this way:</source>
          <target state="translated">Вы также можете просто быстро &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; от неопределенного значения следующим образом:</target>
        </trans-unit>
        <trans-unit id="5af0b3086e446e033f6737e913de95b977971d84" translate="yes" xml:space="preserve">
          <source>You can also look for information at:</source>
          <target state="translated">Вы также можете поискать информацию:</target>
        </trans-unit>
        <trans-unit id="52f3afa40db22b85e32dd734c2f80ac43010fee7" translate="yes" xml:space="preserve">
          <source>You can also override &lt;code&gt;DOES&lt;/code&gt; directly in your own classes. If you override this method, it should never throw an exception.</source>
          <target state="translated">Вы также можете переопределить &lt;code&gt;DOES&lt;/code&gt; прямо в своих классах. Если вы переопределите этот метод, он никогда не должен вызывать исключение.</target>
        </trans-unit>
        <trans-unit id="95cd0a4f9ce9a6a1469a2469c1efc68cdb5fae5b" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">Вы также можете передать &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; явную кодировку, чтобы изменять ее на лету. Это не совсем &amp;laquo;двоичный&amp;raquo; режим, но мы все еще используем &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; для этого:</target>
        </trans-unit>
        <trans-unit id="f90ccf1fd48c6dc4de43f56b2888c9c3134e2996" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="translated">Вы также можете передать ссылку на подпрограмму, чтобы определить и вернуть правильную программу для запуска на основе заданного тестового сценария. Ссылка на подпрограмму должна ожидать сам объект TAP :: Harness в качестве первого аргумента и имя файла в качестве второго аргумента. Он должен возвращать ссылку на массив, содержащую команду, которую нужно запустить, и включая имя тестового файла. Он также может просто вернуть &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , и в этом случае TAP :: Harness вернется к выполнению тестового скрипта на Perl:</target>
        </trans-unit>
        <trans-unit id="f73ef4e3f69ff87027791a2bee2e957755bc2ee3" translate="yes" xml:space="preserve">
          <source>You can also read and execute Perl statements from a file while in the midst of your C program, by placing the filename in</source>
          <target state="translated">Вы также можете читать и выполнять Perl-выражения из файла,находясь в середине программы на C,поместив имя файла в поле</target>
        </trans-unit>
        <trans-unit id="e9bed781c4a6044ffb67b23fe5c127e03e4dd1a1" translate="yes" xml:space="preserve">
          <source>You can also refer to capture groups relatively, by using a negative number, so that &lt;code&gt;\g-1&lt;/code&gt; and &lt;code&gt;\g{-1}&lt;/code&gt; both refer to the immediately preceding capture group, and &lt;code&gt;\g-2&lt;/code&gt; and &lt;code&gt;\g{-2}&lt;/code&gt; both refer to the group before it. For example:</source>
          <target state="translated">Вы также можете относиться к группам захвата, используя отрицательное число, так что &lt;code&gt;\g-1&lt;/code&gt; и &lt;code&gt;\g{-1}&lt;/code&gt; оба относятся к непосредственно предшествующей группе захвата, а &lt;code&gt;\g-2&lt;/code&gt; и &lt;code&gt;\g{-2}&lt;/code&gt; оба обратитесь к группе перед ним. Например:</target>
        </trans-unit>
        <trans-unit id="108a751b15dd5a65748cd5542a9f662a512fab15" translate="yes" xml:space="preserve">
          <source>You can also restrict names to a certain alphabet by specifying the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; pragma:</source>
          <target state="translated">Вы также можете ограничить имена определенным алфавитом, указав прагму &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0b5023bd40fe3a7df91e6504812de04a002532fe" translate="yes" xml:space="preserve">
          <source>You can also see in that example that we use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get the value of the character; the inverse function &lt;code&gt;uvchr_to_utf8&lt;/code&gt; is available for putting a UV into UTF-8:</source>
          <target state="translated">Вы также можете видеть в этом примере, что мы используем &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; для получения значения символа; обратная функция &lt;code&gt;uvchr_to_utf8&lt;/code&gt; доступна для помещения UV в UTF-8:</target>
        </trans-unit>
        <trans-unit id="7a3be218b57aec1fe1552cf95cde772b459e8c4a" translate="yes" xml:space="preserve">
          <source>You can also send pull requests to the Github repository:</source>
          <target state="translated">Вы также можете отправлять запросы на вытаскивание в репозиторий Github:</target>
        </trans-unit>
        <trans-unit id="2a4162cf16b37e0bb4e40d233ea23d3b932f7f0d" translate="yes" xml:space="preserve">
          <source>You can also specify the separator character using hexadecimal notation: &lt;b&gt;-0x&lt;i&gt;HHH...&lt;/i&gt;&lt;/b&gt;, where the &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; are valid hexadecimal digits. Unlike the octal form, this one may be used to specify any Unicode character, even those beyond 0xFF. So if you</source>
          <target state="translated">Вы также можете указать символ-разделитель в шестнадцатеричной системе счисления: &lt;b&gt;-0x &lt;i&gt;HHH ...&lt;/i&gt;&lt;/b&gt; , где &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; являются допустимыми шестнадцатеричными цифрами. В отличие от восьмеричной формы, эту можно использовать для указания любого символа Юникода, даже если он превышает 0xFF. Итак, если вы</target>
        </trans-unit>
        <trans-unit id="5708c7cba5f95ced05791bc1f781cc7e3ab698d2" translate="yes" xml:space="preserve">
          <source>You can also specify to NOT use something:</source>
          <target state="translated">Вы также можете указать НЕ использовать что-либо:</target>
        </trans-unit>
        <trans-unit id="d0e21d8042eb943e53a763ac42b81475843fd69a" translate="yes" xml:space="preserve">
          <source>You can also store data in network order to allow easy sharing across multiple platforms, or when storing on a socket known to be remotely connected. The routines to call have an initial &lt;code&gt;n&lt;/code&gt; prefix for</source>
          <target state="translated">Вы также можете хранить данные в сетевом порядке, чтобы обеспечить простой обмен на нескольких платформах, или при хранении в сокете, который, как известно, подключен удаленно. У вызываемых подпрограмм есть начальный префикс &lt;code&gt;n&lt;/code&gt; для</target>
        </trans-unit>
        <trans-unit id="32a000612a53a9f73b8165e9ffd35ee663d455aa" translate="yes" xml:space="preserve">
          <source>You can also subscript a list to get a single element from it:</source>
          <target state="translated">Вы также можете подписаться на список,чтобы получить из него один элемент:</target>
        </trans-unit>
        <trans-unit id="e308900a9f85413017177815b933ee92128f909d" translate="yes" xml:space="preserve">
          <source>You can also test a class, to make sure that it has the right ancestor:</source>
          <target state="translated">Вы также можете протестировать класс,чтобы убедиться,что у него есть правильный предок:</target>
        </trans-unit>
        <trans-unit id="e940484c0812f3991ca3b5162180666fbbc774e9" translate="yes" xml:space="preserve">
          <source>You can also try &lt;code&gt;guess_encoding&lt;/code&gt; function which is exported by default. It takes $data to check and it also takes the list of suspects by option. The optional suspect list is</source>
          <target state="translated">Вы также можете попробовать функцию &lt;code&gt;guess_encoding&lt;/code&gt; , которая по умолчанию экспортируется. Для проверки требуется $ data, а также список подозреваемых по опциям. Необязательный список подозреваемых:</target>
        </trans-unit>
        <trans-unit id="c6c2bb7263fcb86f56120bac5220dbcae10e778f" translate="yes" xml:space="preserve">
          <source>You can also try to include the module in a one-liner to see if perl finds it:</source>
          <target state="translated">Вы также можете попробовать включить модуль в один лайнер,чтобы посмотреть,найдет ли его perl:</target>
        </trans-unit>
        <trans-unit id="b15c66e70792efbd27fd6c112e317c6eb54c5b69" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="translated">Вы также можете попробовать использовать &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; , как описано в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (хотя это то же самое, что многие модули сделают за вас).</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">Вы также можете использовать</target>
        </trans-unit>
        <trans-unit id="b0304b03ea61e4912a40d9a36c7c0d47306360a9" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt; -like syntax.</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class :: Tiny :: Antlers&lt;/a&gt; для синтаксиса, подобного &lt;code&gt;Moose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37de0be164e83020017ecbe8445d1b73a8f2a1b8" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel :: REPL&lt;/a&gt; , интерактивную оболочку для Perl, широко известную как REPL - Read, Evaluate, Print, Loop. Он предоставляет различные удобные функции.</target>
        </trans-unit>
        <trans-unit id="9013c35ad3298535ad5c8c74739a6a896be46939" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie :: Cycle&lt;/a&gt; для использования скаляра, который всегда имеет следующий элемент кругового массива:</target>
        </trans-unit>
        <trans-unit id="ed9079885add1db23c7b692dc26264a6c8112995" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib,&lt;/a&gt; чтобы сделать то же самое. Установите модули, используя настройки &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt; , затем используйте модуль в своей программе:</target>
        </trans-unit>
        <trans-unit id="38efc50c4c6a8567a3f07d734113580b8054b830" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object:</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; , который поставляется с Perl и предоставляет &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; , возвращающее объект:</target>
        </trans-unit>
        <trans-unit id="fe8ff91507ad3e201158ab00126828440dda9b62" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; to access the line counter for a given filehandle without having to worry about which handle you last accessed.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; для доступа к счетчику строк для данного дескриптора файла, не беспокоясь о том, к какому дескриптору вы последний раз обращались.</target>
        </trans-unit>
        <trans-unit id="cfc194c704de65f5fa2e2dc7cdfca08cd861cafc" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt; 's &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="translated">Вы можете также использовать &lt;code&gt;cpan&lt;/code&gt; &amp;laquo;s &lt;code&gt;-a&lt;/code&gt; переключатель , чтобы создать autobundle файл , который &lt;code&gt;CPAN.pm&lt;/code&gt; понимает и может использовать повторно установить каждый модуль:</target>
        </trans-unit>
        <trans-unit id="3ed04ee9d470ae5bb5ded41953f6884557aab9f4" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;while&lt;/code&gt; in a post-condition:</source>
          <target state="translated">Вы также можете использовать в &lt;code&gt;while&lt;/code&gt; в пост-состоянии:</target>
        </trans-unit>
        <trans-unit id="d2490129a2ade6b9a949f50bed0b1d18208e8c0a" translate="yes" xml:space="preserve">
          <source>You can also use Perl one-liners to modify a file in-place. The following changes all 'Fred' to 'Barney' in</source>
          <target state="translated">Вы также можете использовать Perl-однолинеры для изменения файла на месте.Следующее изменяет все 'Фред' на 'Барни'.</target>
        </trans-unit>
        <trans-unit id="ae806fe9a09487e09415c88d84054f11b5bab926" translate="yes" xml:space="preserve">
          <source>You can also use a commercial debugger such as Affrus (Mac OS X), Komodo from Activestate (Windows and Mac OS X), or EPIC (most platforms).</source>
          <target state="translated">Вы также можете использовать коммерческий отладчик,такой как Affrus (Mac OS X),Komodo от Activestate (Windows и Mac OS X)или EPIC (большинство платформ).</target>
        </trans-unit>
        <trans-unit id="79babd18e608e40e4da78366242734a20c79cee2" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="translated">Также можно использовать двойную вилку. Вы немедленно &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; для своего первого ребенка, а демон init будет &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; для вашего внука после его выхода.</target>
        </trans-unit>
        <trans-unit id="9ef85cce54fb95ce8f948edcebadc50c579e68d3" translate="yes" xml:space="preserve">
          <source>You can also use a list slice to select only the elements that you need:</source>
          <target state="translated">Вы также можете использовать фрагмент списка,чтобы выбрать только те элементы,которые вам нужны:</target>
        </trans-unit>
        <trans-unit id="d760c6f0200ce645ec4271e39ed0780a635d6be2" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Вы также можете использовать локализованный &lt;code&gt;@ARGV&lt;/code&gt; для устранения &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4613c51eb74aabc580ab960ede735ed7c5a84c03" translate="yes" xml:space="preserve">
          <source>You can also use a subroutine reference as a method:</source>
          <target state="translated">Вы также можете использовать в качестве метода ссылку на подпрограмму:</target>
        </trans-unit>
        <trans-unit id="f4a8095c707393fa806f56c74d791b44c5bdbd35" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like Config conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="translated">Вы также можете использовать определенные библиотеки,такие как Config условно,но не забудьте изящно пропустить тест,если его там нет.</target>
        </trans-unit>
        <trans-unit id="aee62fec81f8fc5af73b94cc4b6a4396ba0e2b3e" translate="yes" xml:space="preserve">
          <source>You can also use dmake to build using Visual C++; provided, however, you set OSRELEASE to &quot;microsft&quot; (or whatever the directory name under which the Visual C dmake configuration lives) in your environment and edit win32/config.vc to change &quot;make=nmake&quot; into &quot;make=dmake&quot;. The latter step is only essential if you want to use dmake as your default make for building extensions using MakeMaker.</source>
          <target state="translated">Вы также можете использовать dmake для сборки с Visual C++;однако,при условии,что вы установите OSRELEASE в &quot;microsft&quot; (или любое другое имя каталога,под которым находится конфигурация dmake Visual C)в вашем окружении и отредактируете win32/config.vc,чтобы изменить &quot;make=nmake&quot; на &quot;make=dmake&quot;.Последний шаг необходим только в том случае,если вы хотите использовать dmake в качестве вашей стандартной make для сборки расширений с помощью MakeMaker.</target>
        </trans-unit>
        <trans-unit id="4fabe958607319aed5413ce7d91aa1937c4486e1" translate="yes" xml:space="preserve">
          <source>You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:</source>
          <target state="translated">Вы также можете использовать перенаправление файловых скрипторов,чтобы сделать STDERR дубликатом STDOUT:</target>
        </trans-unit>
        <trans-unit id="bb1f48473296bb1c89d7c3f43ff784b475814cae" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt; .</source>
          <target state="translated">Вы также можете использовать отрицание как в &lt;code&gt;\p{}&lt;/code&gt; и в &lt;code&gt;\P{}&lt;/code&gt; , вставив курсор ( &lt;code&gt;^&lt;/code&gt; ) между первой фигурной скобкой и именем свойства: &lt;code&gt;\p{^Tamil}&lt;/code&gt; равно &lt;code&gt;\P{Tamil}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6a71e5490894554dcf75a2f44b77577d1780db" translate="yes" xml:space="preserve">
          <source>You can also use substr() as an lvalue.</source>
          <target state="translated">Вы также можете использовать substr()в качестве значения lvalue.</target>
        </trans-unit>
        <trans-unit id="c8a027b09bbb1035f68edd31b3dac9da865767c1" translate="yes" xml:space="preserve">
          <source>You can also use the -Duse64bitint flag to Configure. Although there are some minor differences between compiling Perl with this flag versus the -Duse64bitall flag, they should not be noticeable from a Perl user's perspective. When configuring -Duse64bitint using a 64bit gcc on a pa-risc architecture, -Duse64bitint is silently promoted to -Duse64bitall.</source>
          <target state="translated">Также для настройки можно использовать флаг -Duse64bitint.Хотя есть небольшие различия между компиляцией Perl с этим флагом и флагом -Duse64bitall,они не должны быть заметны с точки зрения пользователя Perl.При настройке -Duse64bitint с использованием 64-битного gcc на архитектуре pa-risc,-Duse64bitint молча повышается до -Duse64bitall.</target>
        </trans-unit>
        <trans-unit id="01f985bfd65126ce04f3352a8f1c24d2647a415c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="translated">Вы также можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc,&lt;/a&gt; используя его функцию &lt;code&gt;Today_and_Now&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5948ec91fdfb792b5884ccadb56a91fc59d16359" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вы также можете использовать модуль &lt;a href=&quot;tie/file&quot;&gt;Tie :: File,&lt;/a&gt; который позволяет вам обращаться к строкам через связанный массив. Вы можете использовать обычные операции с массивами для изменения вашего файла, включая установку последнего индекса и использование &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cea4cf5784aecf948d1c03056df0b1645df434de" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;**&lt;/code&gt; operator, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Вы также можете использовать оператор &lt;code&gt;**&lt;/code&gt; , см. &lt;a href=&quot;perlop&quot;&gt;Perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aca7a853e98fdbbaafd79c6bf0b9e3d107072aaf" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; flag.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;\G&lt;/code&gt; в скалярном контексте. Вам все еще нужен флаг &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36d5ff0652d0a9cfb0d9a8028ed64cb97f87e026" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;open3()&lt;/code&gt; из &lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; . Бенджамин Голдберг предоставляет пример кода:</target>
        </trans-unit>
        <trans-unit id="54c10825a7a9a0e79c4bc9a8acb25f8c895c8d2f" translate="yes" xml:space="preserve">
          <source>You can also use the Unix command mknod(1), or on some systems, mkfifo(1). These may not be in your normal path, though.</source>
          <target state="translated">Вы также можете использовать Unix-команду mknod(1),или на некоторых системах mkfifo(1).Однако,это может быть не в вашем обычном пути.</target>
        </trans-unit>
        <trans-unit id="d558c8753e7739908d901edc4316bd26afe6b26c" translate="yes" xml:space="preserve">
          <source>You can also use the complement of \b, \B, to specify that there should not be a word boundary.</source>
          <target state="translated">Вы также можете использовать дополнение \b,\B,чтобы указать,что не должно быть границы слов.</target>
        </trans-unit>
        <trans-unit id="94817cf57f637575defe9d34927c35a3c77682d8" translate="yes" xml:space="preserve">
          <source>You can also use the following functions to extract the file header information from Storable images:</source>
          <target state="translated">Вы также можете использовать следующие функции для извлечения информации о заголовке файла из изображений Storable:</target>
        </trans-unit>
        <trans-unit id="621c9d7b846400426f6a8d8885a28fc12414361e" translate="yes" xml:space="preserve">
          <source>You can also write that as a single substitution, although it turns out the combined statement is slower than the separate ones. That might not matter to you, though:</source>
          <target state="translated">Можно также написать,что в качестве единственной замены,хотя получается,что комбинированный оператор медленнее,чем отдельные.Для вас это может не иметь значения:</target>
        </trans-unit>
        <trans-unit id="6e736747d1920ca322bb92742d39b47addfde6fe" translate="yes" xml:space="preserve">
          <source>You can also:</source>
          <target state="translated">Ты тоже можешь:</target>
        </trans-unit>
        <trans-unit id="9a39342cae5acfdbd6b63da64d2d504d73f599e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt; 'd key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section below.</source>
          <target state="translated">Вы можете изменить глобальную переменную $ Params :: Check :: NO_DUPLICATES, чтобы контролировать, будет ли по -прежнему присутствовать ключ &lt;code&gt;store&lt;/code&gt; d в вашем наборе результатов. См. Раздел &amp;laquo; &lt;a href=&quot;#Global-Variables&quot;&gt;Глобальные переменные&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="330192003f1fea8edf49c86f71523fd9c154de87" translate="yes" xml:space="preserve">
          <source>You can always check the value you're using by printing it in octal notation to ensure it matches what you think it should be. Print it in octal and decimal format:</source>
          <target state="translated">Вы всегда можете проверить значение,которое вы используете,распечатав его в восьмеричной нотации,чтобы убедиться,что оно соответствует тому,что вы думаете,что это должно быть.Распечатайте его в восьмеричном и десятичном формате:</target>
        </trans-unit>
        <trans-unit id="ef6c5c0a821b62556c215147b73e29172a7eabfd" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">Вы всегда можете использовать ссылку на массив в фигурных скобках вместо имени массива. Например, &lt;code&gt;@{$aref}&lt;/code&gt; вместо &lt;code&gt;@array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4754996a46b2974a193b45735bde04e1ddad5927" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">Вы можете организовать обратный вызов, который будет запускаться непосредственно перед тем, как &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; выполнит свое действие, установив хук &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; . Связанный обработчик вызывается с текстом ошибки и может изменить сообщение об ошибке, если сочтет нужным, повторно вызвав &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;% SIG в perlvar&lt;/a&gt; для получения подробной информации о настройке записей &lt;code&gt;%SIG&lt;/code&gt; и &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; для некоторых примеров. Хотя эта функция должна была запускаться только непосредственно перед выходом вашей программы, в настоящее время это не так: хук &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; в настоящее время вызывается даже внутри блоков / строк eval () ed! Если кто-то хочет, чтобы крючок в таких ситуациях ничего не делал, положите</target>
        </trans-unit>
        <trans-unit id="6d6ebe42604b8b630167882d7abe0a8f91ccbdb6" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">Вы можете организовать обратный вызов, который будет запускаться непосредственно перед тем, как &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; выполнит свое действие, установив хук &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; . Связанный обработчик вызывается с текстом ошибки и может изменить сообщение об ошибке, если сочтет нужным, повторно вызвав &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;perlvar#%25SIG&quot;&gt;% SIG в perlvar&lt;/a&gt; для получения подробной информации о настройке записей &lt;code&gt;%SIG&lt;/code&gt; и &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; для некоторых примеров. Хотя эта функция должна была запускаться только непосредственно перед выходом вашей программы, в настоящее время это не так: хук &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; в настоящее время вызывается даже внутри блоков / строк eval () ed! Если кто-то хочет, чтобы крючок в таких ситуациях ничего не делал, положите</target>
        </trans-unit>
        <trans-unit id="b111cf2dc7e21ab63d8886219ae9103dbe8e5745" translate="yes" xml:space="preserve">
          <source>You can ask &lt;code&gt;prove&lt;/code&gt; to remember the state of previous test runs and select and/or order the tests to be run based on that saved state.</source>
          <target state="translated">Вы можете попросить &lt;code&gt;prove&lt;/code&gt; запомнить состояние предыдущих тестовых запусков и выбрать и / или заказать тесты для запуска на основе этого сохраненного состояния.</target>
        </trans-unit>
        <trans-unit id="5be6ec0673c2462bb7fe8ce793fcded60eef0f18" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="translated">Вы можете разорвать циклические ссылки, создав &amp;laquo;слабую ссылку&amp;raquo;. Слабая ссылка не увеличивает счетчик ссылок для переменной, что означает, что объект может выйти за пределы области видимости и быть уничтожен. Вы можете ослабить ссылку с помощью функции &lt;code&gt;weaken&lt;/code&gt; экспортируемой модулем &lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b50c9286c4042666f0e26f5a3f4bc1fff06eaf5" translate="yes" xml:space="preserve">
          <source>You can call the perl visible subroutine something other than &lt;code&gt;constant&lt;/code&gt; if you give the parameter</source>
          <target state="translated">Вы можете вызвать подпрограмму perl visible не как &lt;code&gt;constant&lt;/code&gt; если укажете параметр</target>
        </trans-unit>
        <trans-unit id="03c6b44929e8d300ef044fa7166e3c54539d868d" translate="yes" xml:space="preserve">
          <source>You can capture its numeric and string content using:</source>
          <target state="translated">Вы можете захватить его цифровое и строковое содержимое,используя его:</target>
        </trans-unit>
        <trans-unit id="596d44f0dc27aeca16b120bcaf752ef2dfa99248" translate="yes" xml:space="preserve">
          <source>You can categorize these CES by 3 criteria: size of each character, endianness, and Byte Order Mark.</source>
          <target state="translated">Вы можете классифицировать эти CES по 3 критериям:размер каждого персонажа,эндианность и знак байтового порядка.</target>
        </trans-unit>
        <trans-unit id="6b889973d01196115807ed3e24800abe92e6ed58" translate="yes" xml:space="preserve">
          <source>You can change an array element, but you can't change a list element:</source>
          <target state="translated">Вы можете изменить элемент массива,но не можете изменить элемент списка:</target>
        </trans-unit>
        <trans-unit id="d178a91245c223a6b3d558a26825e4086182ea75" translate="yes" xml:space="preserve">
          <source>You can change both the effective gid and the real gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; (use only a single numeric argument). Changes to &lt;code&gt;$)&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">Вы можете изменить как эффективный gid, так и реальный gid одновременно, используя &lt;code&gt;POSIX::setgid()&lt;/code&gt; (используйте только один числовой аргумент). При изменении &lt;code&gt;$)&lt;/code&gt; требуется чек на &lt;code&gt;$!&lt;/code&gt; для обнаружения возможных ошибок после попытки изменения.</target>
        </trans-unit>
        <trans-unit id="59d9719ad7d1133b142fc0ce7a1557db385a25a2" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">Вы можете изменить как эффективный, так и реальный uid одновременно, используя &lt;code&gt;POSIX::setuid()&lt;/code&gt; . При изменении &lt;code&gt;$&amp;gt;&lt;/code&gt; требуется проверка на &lt;code&gt;$!&lt;/code&gt; для обнаружения возможных ошибок после попытки изменения.</target>
        </trans-unit>
        <trans-unit id="57121de58d74f1a64c5b126aeda69842259d90c4" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; . Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">Вы можете изменить как реальный gid, так и эффективный gid одновременно, используя &lt;code&gt;POSIX::setgid()&lt;/code&gt; . Изменения в &lt;code&gt;$(&lt;/code&gt; требуется проверка &lt;code&gt;$!&lt;/code&gt; Для обнаружения любых возможных ошибок после попытки изменения.</target>
        </trans-unit>
        <trans-unit id="b09c5405e2b602271ef0ef2f3017aa480c6d1079" translate="yes" xml:space="preserve">
          <source>You can change options from</source>
          <target state="translated">Вы можете изменить опции из</target>
        </trans-unit>
        <trans-unit id="d6315b4e978f53eeff4964ee1909c618fbc90cfa" translate="yes" xml:space="preserve">
          <source>You can change the underlying module that does the low-level math operations by using:</source>
          <target state="translated">Вы можете изменить базовый модуль,который выполняет низкоуровневые математические операции с помощью:</target>
        </trans-unit>
        <trans-unit id="ac0967b2c568b641678650e45e2b539ad81b2c7d" translate="yes" xml:space="preserve">
          <source>You can change this backend library by using:</source>
          <target state="translated">Вы можете изменить эту библиотеку бэкэндов с помощью:</target>
        </trans-unit>
        <trans-unit id="e271d7bee0eb9af50859c996a87b147d97ca08b1" translate="yes" xml:space="preserve">
          <source>You can change this by using:</source>
          <target state="translated">Вы можете изменить это с помощью:</target>
        </trans-unit>
        <trans-unit id="a8c0aadd56b5a3424b47f02ac266fd1fef206d7e" translate="yes" xml:space="preserve">
          <source>You can check the values of these variables on your system with</source>
          <target state="translated">Вы можете проверить значения этих переменных в вашей системе с помощью</target>
        </trans-unit>
        <trans-unit id="19186d4d2aa107ae87a9009974a30d3e15b94cd1" translate="yes" xml:space="preserve">
          <source>You can choose if you want to always install (yes), never install (no) or be always asked. In the latter case you can set the default answer for the question to yes (ask/yes) or no (ask/no).</source>
          <target state="translated">Вы можете выбрать,хотите ли вы всегда устанавливать (да),никогда не устанавливать (нет)или вас всегда спрашивают.В последнем случае вы можете установить по умолчанию ответ на вопрос:да (спросить/да)или нет (спросить/нет).</target>
        </trans-unit>
        <trans-unit id="432283768bc5fcc2cbc19482faa7326a0cb0200d" translate="yes" xml:space="preserve">
          <source>You can compare $s1 and $s2 above with</source>
          <target state="translated">Вы можете сравнить $s1 и $s2 выше с</target>
        </trans-unit>
        <trans-unit id="5cd28c9babbe3b0c5cce52c7e8b6bd3de247f8a7" translate="yes" xml:space="preserve">
          <source>You can compile a special debugging version of Perl, which allows you to use the &lt;code&gt;-D&lt;/code&gt; option of Perl to tell more about what Perl is doing. But sometimes there is no alternative than to dive in with a debugger, either to see the stack trace of a core dump (very useful in a bug report), or trying to figure out what went wrong before the core dump happened, or how did we end up having wrong or unexpected results.</source>
          <target state="translated">Вы можете скомпилировать специальную отладочную версию Perl, которая позволяет вам использовать параметр Perl &lt;code&gt;-D&lt;/code&gt; , чтобы узнать больше о том, что делает Perl. Но иногда нет альтернативы, кроме как погрузиться в отладчик, либо посмотреть трассировку стека дампа ядра (очень полезно в отчете об ошибке), либо попытаться выяснить, что пошло не так до того, как произошел дамп ядра, или как это произошло. мы получаем неправильные или неожиданные результаты.</target>
        </trans-unit>
        <trans-unit id="87041007fca4b20217db14f0fb86e591cf75c1a4" translate="yes" xml:space="preserve">
          <source>You can compile perl as a universal binary (built for both ppc and intel). In Mac OS X 10.4 &quot;Tiger&quot;, you must export the 'u' variant of the SDK:</source>
          <target state="translated">Вы можете скомпилировать perl как универсальный бинарный файл (собранный как для ppc,так и для intel).В Mac OS X 10.4 &quot;Tiger&quot; необходимо экспортировать вариант SDK 'u':</target>
        </trans-unit>
        <trans-unit id="fa58ab427e59cc304b800becf278713e2a473dc4" translate="yes" xml:space="preserve">
          <source>You can compute spherical distances, called &lt;b&gt;great circle distances&lt;/b&gt;, by importing the great_circle_distance() function:</source>
          <target state="translated">Вы можете вычислить сферические расстояния, называемые &lt;b&gt;расстояниями&lt;/b&gt; по &lt;b&gt;большой окружности&lt;/b&gt; , импортируя функцию great_circle_distance ():</target>
        </trans-unit>
        <trans-unit id="e0e56eaab18c95d9fc59dbbcb6020dceb739e042" translate="yes" xml:space="preserve">
          <source>You can configure &lt;code&gt;CPAN.pm&lt;/code&gt; to automatically use this option too:</source>
          <target state="translated">Вы также можете настроить &lt;code&gt;CPAN.pm&lt;/code&gt; для автоматического использования этой опции:</target>
        </trans-unit>
        <trans-unit id="2d461022ba384996bf77747145dbd16f78eb1d3d" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call dbmopen():</source>
          <target state="translated">Вы можете контролировать,какую DBM-библиотеку вы используете,загрузив эту библиотеку перед вызовом dbmopen():</target>
        </trans-unit>
        <trans-unit id="b63a08beb712c643691cdd9c1e77329f30769a82" translate="yes" xml:space="preserve">
          <source>You can create endless loops if the things you serialize via freeze() (for instance) point back to the object we're trying to serialize in the hook.</source>
          <target state="translated">Вы можете создавать бесконечные циклы,если вещи,которые вы сериализуете с помощью функции freeze()(например),указывают на объект,который мы пытаемся сериализовать на крючке.</target>
        </trans-unit>
        <trans-unit id="8cc300aa058401f33bcdc1d74e140c0960d7fa90" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">Вы можете определить для всех типов связей метод UNTIE, который будет вызываться при untie (). См. &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;Раздел &amp;laquo;Развязка Gotcha&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="cd22b39009d785c43f4f9453185f24b021494e27" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt; . (The experimental feature &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;(?[ ]) in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="translated">Вы можете определить свои собственные свойства двоичного символа, определив подпрограммы, имена которых начинаются с &lt;code&gt;&quot;In&quot;&lt;/code&gt; или &lt;code&gt;&quot;Is&quot;&lt;/code&gt; . (Экспериментальная функция &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;(? []) В perlre&lt;/a&gt; предоставляет альтернативу, которая допускает более сложные определения.) Подпрограммы могут быть определены в любом пакете. Определяемые пользователем свойства могут использоваться в конструкциях регулярных выражений &lt;code&gt;\p{}&lt;/code&gt; и &lt;code&gt;\P{}&lt;/code&gt; ; если вы используете определяемое пользователем свойство из пакета, отличного от того, в котором вы находитесь, вы должны указать его пакет в конструкции &lt;code&gt;\p{}&lt;/code&gt; или &lt;code&gt;\P{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="107745b2e3d0c30dbe6a28beb79e3db6db75115c" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties&lt;/a&gt; for more details.</source>
          <target state="translated">Вы можете определить свои собственные свойства символа и использовать их в регулярном выражении с помощью конструкции &lt;code&gt;\p{}&lt;/code&gt; или &lt;code&gt;\P{}&lt;/code&gt; . См. Дополнительные сведения в разделе &amp;laquo; &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;Свойства символов, определяемые пользователем&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9472dcd36f94375050dea75545931297e23f500b" translate="yes" xml:space="preserve">
          <source>You can detect the OS mode using &quot;isainfo -v&quot;, e.g.</source>
          <target state="translated">Режим операционной системы можно определить с помощью &quot;isainfo -v&quot;,например.</target>
        </trans-unit>
        <trans-unit id="ac56709f3e046a38d3f4f58f4d03fe93d1a1a7f4" translate="yes" xml:space="preserve">
          <source>You can determine your system endianness with this incantation:</source>
          <target state="translated">С помощью этого заклинания вы можете определить эндианность вашего организма:</target>
        </trans-unit>
        <trans-unit id="5e10ee4faf1824e9c84d1fdce76b93c2ae5f9fd0" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; flag, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">Вы можете отключить сброс &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; в случае сбоя с помощью флага &lt;code&gt;c&lt;/code&gt; , задокументированного в &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; и &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt; . Последующие совпадения начинаются там, где закончилось последнее успешное совпадение (значение &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; ), даже если совпадение в той же строке за это время не удалось. В этом случае совпадение после цикла &lt;code&gt;while()&lt;/code&gt; начинается с &lt;code&gt;a&lt;/code&gt; (где остановлено последнее совпадение), и, поскольку он не использует привязку, он может пропустить &lt;code&gt;a&lt;/code&gt; , чтобы найти &lt;code&gt;44&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="458912b1d0d0c5a77d13c3e7ffc4ddad22f59daf" translate="yes" xml:space="preserve">
          <source>You can dispense with numbers altogether and create named capture groups. The notation is &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; to declare and &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; to reference. (To be compatible with .Net regular expressions, &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; may also be written as &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt;.)</source>
          <target state="translated">Вы можете полностью отказаться от номеров и создать именованные группы захвата. Обозначения: &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; для объявления и &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; для ссылки. (Для совместимости с регулярными выражениями .Net &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; можно также записать как &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="b18d3c8d444331784ad87d0c9066604ce83188e2" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt; , which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="translated">Вы можете сделать то же самое со значением &lt;code&gt;$0&lt;/code&gt; , которое содержит имя сценария. Это может содержать относительный путь, но &lt;code&gt;rel2abs&lt;/code&gt; может превратить его в абсолютный путь. Как только у вас будет</target>
        </trans-unit>
        <trans-unit id="2cb0b5304ad3a2505b033f6205316fe91cd8667f" translate="yes" xml:space="preserve">
          <source>You can do it yourself:</source>
          <target state="translated">Ты можешь сделать это сам:</target>
        </trans-unit>
        <trans-unit id="3df3594ac830b3b367e2449531bc9481e6c2c743" translate="yes" xml:space="preserve">
          <source>You can do some customization by setting up a</source>
          <target state="translated">Вы можете сделать некоторую настройку,настроив параметр</target>
        </trans-unit>
        <trans-unit id="e36b0a11441d7f370d1c8f3b9a2c5df0ed14fec0" translate="yes" xml:space="preserve">
          <source>You can do the same thing with foreach and a match using the c flag and the \G anchor, if you do not mind your entire file being in memory at the end.</source>
          <target state="translated">Вы можете сделать то же самое с фореком и матчем,используя c-флаг и якорь \G,если вы не возражаете против того,чтобы весь ваш файл остался в памяти в конце.</target>
        </trans-unit>
        <trans-unit id="94475bd1aa00e25358f732725451e1c48c0023a3" translate="yes" xml:space="preserve">
          <source>You can do this by filtering a list of &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects based on your criteria. For example, to extract only files that have the string &lt;code&gt;foo&lt;/code&gt; in their title, you would use:</source>
          <target state="translated">Вы можете сделать это, отфильтровав список объектов &lt;code&gt;Archive::Tar::File&lt;/code&gt; на основе ваших критериев. Например, чтобы извлечь только файлы, в заголовке которых есть строка &lt;code&gt;foo&lt;/code&gt; , вы должны использовать:</target>
        </trans-unit>
        <trans-unit id="e3b58ea141bf0b2ab8308eba04e2fe1187709b38" translate="yes" xml:space="preserve">
          <source>You can do this in</source>
          <target state="translated">Вы можете сделать это в</target>
        </trans-unit>
        <trans-unit id="0e82d2d4c5fee3c3455ee13c93472ac8305c2886" translate="yes" xml:space="preserve">
          <source>You can do various useful things to lists:</source>
          <target state="translated">Вы можете делать различные полезные вещи для списков:</target>
        </trans-unit>
        <trans-unit id="2293c83d7e9f41c388c0c9ef674c18441a39f91a" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;.</source>
          <target state="translated">Вы можете загрузить NDK с &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2add1e5f384d4e366c7f0bda81dca221784f796a" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="translated">Вы можете легко сделать это и сами, проверив каждый уровень хэша, прежде чем переходить на следующий уровень. По сути, &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt; делает для вас:</target>
        </trans-unit>
        <trans-unit id="aca937c9b8249ef74f6bdd2a2c24ef2b2c942c33" translate="yes" xml:space="preserve">
          <source>You can effect a sleep of 250 milliseconds this way:</source>
          <target state="translated">Таким образом,вы можете спать 250 миллисекунд:</target>
        </trans-unit>
        <trans-unit id="2cf03e7d8c028c108e1f07b9fdfd93ec5a0911cb" translate="yes" xml:space="preserve">
          <source>You can either get the latest perl-for-amiga source from Ninemoons and extract it with:</source>
          <target state="translated">Вы можете либо получить последний источник perl-for-амига из Ninemoons и извлечь его с помощью:</target>
        </trans-unit>
        <trans-unit id="dc1b686bd86f9825c512e3b19e24ca27d9b0e88c" translate="yes" xml:space="preserve">
          <source>You can embed Pod documentation in your Perl modules and scripts. Start your documentation with an empty line, a &quot;=head1&quot; command at the beginning, and end it with a &quot;=cut&quot; command and an empty line. The &lt;b&gt;perl&lt;/b&gt; executable will ignore the Pod text. You can place a Pod statement where &lt;b&gt;perl&lt;/b&gt; expects the beginning of a new statement, but not within a statement, as that would result in an error. See any of the supplied library modules for examples.</source>
          <target state="translated">Вы можете встраивать документацию Pod в свои модули и скрипты Perl. Начните свою документацию с пустой строки, вначале введите команду &amp;laquo;= head1&amp;raquo;, а завершите ее командой &amp;laquo;= cut&amp;raquo; и пустой строкой. &lt;b&gt;Perl&lt;/b&gt; исполняемый файл будет игнорировать текст Pod. Вы можете разместить оператор Pod там, где &lt;b&gt;perl&lt;/b&gt; ожидает начало нового оператора, но не внутри оператора, так как это приведет к ошибке. См. Примеры любого из поставляемых библиотечных модулей.</target>
        </trans-unit>
        <trans-unit id="4e8901a24d5203f278555dd6630e84e6495d5c32" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="translated">Вы можете включить автоматическую UTF-8-кацию ваших стандартных дескрипторов файлов, по умолчанию &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; слоя и &lt;code&gt;@ARGV&lt;/code&gt; либо с помощью &lt;code&gt;-C&lt;/code&gt; переключателя командной строки или &lt;code&gt;PERL_UNICODE&lt;/code&gt; переменного окружения, см &lt;a href=&quot;perlrun&quot;&gt;PerlRun&lt;/a&gt; для документации &lt;code&gt;-C&lt;/code&gt; коммутатора.</target>
        </trans-unit>
        <trans-unit id="9b7d65e57af61c849fd344c325e8ff8558b6ea76" translate="yes" xml:space="preserve">
          <source>You can enable this program wide by setting the package variable &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; to a true value. For details, see the section on &lt;code&gt;Global Variables&lt;/code&gt; below.</source>
          <target state="translated">Вы можете включить эту программу в целом, установив для переменной пакета &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; истинное значение. Подробнее см. Ниже в разделе &amp;laquo; &lt;code&gt;Global Variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9f5fdd175da39fdf1b2aee95117b6f24089729" translate="yes" xml:space="preserve">
          <source>You can even add a line to the beginning of a file, since the current line prints at the end of the loop:</source>
          <target state="translated">Вы даже можете добавить строку в начало файла,так как текущая строка распечатывается в конце цикла:</target>
        </trans-unit>
        <trans-unit id="469cbe63338eb0799dde10314ea7997fd8799ab7" translate="yes" xml:space="preserve">
          <source>You can even chain the operations together as usual:</source>
          <target state="translated">Вы даже можете связать операции воедино,как обычно:</target>
        </trans-unit>
        <trans-unit id="2aadc431d196d9bef8923dcadb3a5f0c2d7f67b9" translate="yes" xml:space="preserve">
          <source>You can even set them to pipe commands. For example, this automatically filters compressed arguments through &lt;b&gt;gzip&lt;/b&gt;:</source>
          <target state="translated">Вы даже можете настроить их как конвейерные команды. Например, это автоматически фильтрует сжатые аргументы через &lt;b&gt;gzip&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="5959df3dd95aca5e6820f2cd7c4389121f214d69" translate="yes" xml:space="preserve">
          <source>You can examine the @INC variable from within a perl program to see the order in which Perl searches these directories.</source>
          <target state="translated">Вы можете изучить переменную @INC внутри perl программы,чтобы увидеть порядок,в котором Perl ищет в этих каталогах.</target>
        </trans-unit>
        <trans-unit id="b698e2e22416ac9eb31f0b1d16a0dd9b5e075ed0" translate="yes" xml:space="preserve">
          <source>You can expand the macros in a</source>
          <target state="translated">Вы можете расширить макросы в</target>
        </trans-unit>
        <trans-unit id="c6984ea0cc547a7d94d70f8b198039214ca8c15f" translate="yes" xml:space="preserve">
          <source>You can explore the endianness of your platform by unpacking a data structure packed in native format such as:</source>
          <target state="translated">Вы можете изучить эндианность вашей платформы,распаковав структуру данных,упакованную в родном формате,например:</target>
        </trans-unit>
        <trans-unit id="25084ad020c81115ae6c13e15f94c38c747b7c70" translate="yes" xml:space="preserve">
          <source>You can explore various information from the Unicode data files using the &lt;code&gt;Unicode::UCD&lt;/code&gt; module.</source>
          <target state="translated">Вы можете изучить различную информацию из файлов данных Unicode, используя модуль &lt;code&gt;Unicode::UCD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="214226a1ed44146fabbcdf1d7ff955aea72e1c83" translate="yes" xml:space="preserve">
          <source>You can extend the data conversion shortcuts menu, so for example you can display an SV's IV value with one click, without doing any typing. To do that simply edit ~/.ddd/init file and add after:</source>
          <target state="translated">Вы можете расширить меню быстрого доступа к данным,например,вы можете одним щелчком мыши отобразить IV-значение SV,не набирая при этом никакого текста.Для этого просто отредактируйте ~/.ddd/init файл и добавьте после:</target>
        </trans-unit>
        <trans-unit id="9f3b19dace5e1ee6e80db897c83810c886662b0c" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt; , and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt; . Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt; .</source>
          <target state="translated">Вы можете подделать статическую переменную, используя лексическую переменную, которая выходит за пределы области видимости. В этом примере вы определяете &lt;code&gt;counter&lt;/code&gt; подпрограмм , и он использует лексическую переменную &lt;code&gt;$count&lt;/code&gt; . Поскольку вы заключаете это в блок BEGIN, &lt;code&gt;$count&lt;/code&gt; определяется во время компиляции, но также выходит за пределы области видимости в конце блока BEGIN. Блок BEGIN также гарантирует, что подпрограмма и значение, которое она использует, определены во время компиляции, поэтому подпрограмма готова к использованию, как и любая другая подпрограмма, и вы можете поместить этот код в то же место, что и другие подпрограммы в тексте программы ( т.е. обычно в конце кода). &lt;code&gt;counter&lt;/code&gt; подпрограммпо-прежнему есть ссылка на данные, и это единственный способ получить доступ к значению (и каждый раз, когда вы это делаете, вы увеличиваете значение). Данные в блоке памяти, определяемом параметром &lt;code&gt;$count&lt;/code&gt; являются частными для &lt;code&gt;counter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98bfa69a23c16121bcf7918a14cd66f9c3c6d27f" translate="yes" xml:space="preserve">
          <source>You can find documentation for this module with the perldoc command.</source>
          <target state="translated">Документацию по этому модулю можно найти с помощью команды perldoc.</target>
        </trans-unit>
        <trans-unit id="2ec893daacd3a612f16b5ff8e3b0ca737de8a9f5" translate="yes" xml:space="preserve">
          <source>You can find more info about Configure's command line switches in the</source>
          <target state="translated">Дополнительную информацию о переключателях командной строки Configure можно найти в разделе</target>
        </trans-unit>
        <trans-unit id="60d30b2a5683150ee021b2d2efe823e684b28b49" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Вы можете узнать, считает ли Perl &quot;long double&quot; размером с плавающей запятой по умолчанию для использования на вашей платформе через &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0a14665644553d1c1ca40b3a369c0cfc1687919b" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Вы можете узнать, считает ли Perl &quot;long double&quot; размером с плавающей запятой по умолчанию для использования на вашей платформе через &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a8c0376796b23fff5ec186fab67f5500801dd3ed" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Вы можете узнать, поддерживает ли ваш Perl квадроциклы через &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="977c50ef8718482d8b17abe375d1697e8f9a2d66" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">Вы можете узнать, поддерживает ли ваш Perl квадроциклы через &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="58566ff87e227e47e0a6175cb880b0492ff07d0d" translate="yes" xml:space="preserve">
          <source>You can find the bytes that make up a UTF-8 sequence with</source>
          <target state="translated">Вы можете найти байты,которые составляют последовательность UTF-8 с помощью</target>
        </trans-unit>
        <trans-unit id="d66bda1e5630ce31a16d647268de04ca99f2d093" translate="yes" xml:space="preserve">
          <source>You can find the full DJGPP distribution on any of the mirrors listed here:</source>
          <target state="translated">Полный дистрибутив DJGPP можно найти на любом из зеркал,перечисленных здесь:</target>
        </trans-unit>
        <trans-unit id="53a7bd12f9a84d4d155f8bc43066fe15624ba305" translate="yes" xml:space="preserve">
          <source>You can find them for example by</source>
          <target state="translated">Вы можете найти их,например,по</target>
        </trans-unit>
        <trans-unit id="abd3b038a5876faa8d912c01ba340b1b8ceaabfa" translate="yes" xml:space="preserve">
          <source>You can follow the formats with numbers to say how many characters should be affected by that format: &lt;code&gt;A12&lt;/code&gt; means &quot;take 12 characters&quot;; &lt;code&gt;x6&lt;/code&gt; means &quot;skip 6 bytes&quot; or &quot;character 0, 6 times&quot;.</source>
          <target state="translated">Вы можете следовать форматам с числами, чтобы указать, на сколько символов должен воздействовать этот формат: &lt;code&gt;A12&lt;/code&gt; означает &amp;laquo;взять 12 символов&amp;raquo;; &lt;code&gt;x6&lt;/code&gt; означает &amp;laquo;пропустить 6 байтов&amp;raquo; или &amp;laquo;символ 0, 6 раз&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3e5ffde15ed2080164a5592bd7bb881aeab7fa67" translate="yes" xml:space="preserve">
          <source>You can force Perl to interpret the bareword as a class name by appending &quot;::&quot; to it, like we saw earlier:</source>
          <target state="translated">Вы можете заставить Perl интерпретировать пустое слово как имя класса,добавив к нему &quot;::&quot;,как мы видели ранее:</target>
        </trans-unit>
        <trans-unit id="6a0f7fd6c71d8ef00acad73e562310bfdc7188b5" translate="yes" xml:space="preserve">
          <source>You can force Perl to use the first interpretation (i.e. as a method call on the class named &quot;Class&quot;) in two ways. First, you can append a &lt;code&gt;::&lt;/code&gt; to the class name:</source>
          <target state="translated">Вы можете заставить Perl использовать первую интерпретацию (то есть как вызов метода класса с именем &quot;Class&quot;) двумя способами. Во-первых, вы можете добавить &lt;code&gt;::&lt;/code&gt; к имени класса:</target>
        </trans-unit>
        <trans-unit id="3683b364293548110b32df191aa4769c6b0d7861" translate="yes" xml:space="preserve">
          <source>You can force a backreference interpretation always by using the &lt;code&gt;\g{...}&lt;/code&gt; form. You can the force an octal interpretation always by using the &lt;code&gt;\o{...}&lt;/code&gt; form, or for numbers up through \077 (= 63 decimal), by using three digits, beginning with a &quot;0&quot;.</source>
          <target state="translated">Вы всегда можете принудительно интерпретировать обратную ссылку, используя форму &lt;code&gt;\g{...}&lt;/code&gt; . Вы можете принудительно использовать восьмеричную интерпретацию всегда, используя форму &lt;code&gt;\o{...}&lt;/code&gt; , или для чисел до \ 077 (= 63 десятичных), используя три цифры, начинающиеся с &quot;0&quot;.</target>
        </trans-unit>
        <trans-unit id="b877192684c9091db1ed512a1471d2f292aa330b" translate="yes" xml:space="preserve">
          <source>You can force an SV to make its own copy of its string buffer by calling &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; or SvPV_force_nolen(sv).</source>
          <target state="translated">Вы можете заставить SV сделать свою собственную копию строкового буфера, вызвав &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; или SvPV_force_nolen (sv).</target>
        </trans-unit>
        <trans-unit id="59bd5097130055276750c2a4628acf949f4c2e6b" translate="yes" xml:space="preserve">
          <source>You can get a precompiled version of gcc from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; or &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;. Make sure you pick up the package for your Solaris release.</source>
          <target state="translated">Вы можете получить предварительно скомпилированную версию gcc с &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; или &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt; . Убедитесь, что вы выбрали пакет для своей версии Solaris.</target>
        </trans-unit>
        <trans-unit id="6c43b7d416e3df44e0ee3889ce9e7a7e5b755245" translate="yes" xml:space="preserve">
          <source>You can get an overview of all the files with this command:</source>
          <target state="translated">С помощью этой команды можно получить обзор всех файлов:</target>
        </trans-unit>
        <trans-unit id="a325b2e4941194b844aaba1d34803d7f10c46f65" translate="yes" xml:space="preserve">
          <source>You can get and set the current length of the string stored in an SV with the following macros:</source>
          <target state="translated">Вы можете получить и установить текущую длину строки,хранящейся в SV,с помощью следующих макросов:</target>
        </trans-unit>
        <trans-unit id="498e28fc3884e7bafa55f40835a491ab14376104" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; before you use the string.</source>
          <target state="translated">Вы можете обойти это несколькими способами в зависимости от нашей ситуации. Во-первых, если вы не хотите, чтобы какие-либо символы в строке были особенными, вы можете экранировать их с помощью &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; прежде чем использовать строку.</target>
        </trans-unit>
        <trans-unit id="2880274dc7c0ec586da21bf05619e960d62718ce" translate="yes" xml:space="preserve">
          <source>You can get at any of these quantities from C very easily; just add &lt;code&gt;Sv&lt;/code&gt; to the name of the field shown in the snippet, and you've got a macro which will return the value: &lt;code&gt;SvCUR(sv)&lt;/code&gt; returns the current length of the string, &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; returns the reference count, &lt;code&gt;SvPV(sv, len)&lt;/code&gt; returns the string itself with its length, and so on. More macros to manipulate these properties can be found in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">Вы можете легко получить любую из этих величин из C; просто добавьте &lt;code&gt;Sv&lt;/code&gt; к имени поля, показанного во фрагменте, и у вас есть макрос, который вернет значение: &lt;code&gt;SvCUR(sv)&lt;/code&gt; возвращает текущую длину строки, &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; возвращает счетчик ссылок, &lt;code&gt;SvPV(sv, len)&lt;/code&gt; возвращает саму строку с ее длиной и так далее. Дополнительные макросы для управления этими свойствами можно найти в &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98610d953793b8d3a809dccac32eb0df790fe7b6" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Вы можете получить список ключей и значений с помощью &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
