<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a87ba5fd11240d3846b6402630cc4fc5a1bb692a" translate="yes" xml:space="preserve">
          <source>The name of the remote file. For the local file name, the result of $ff-&amp;gt;output_file will be used.</source>
          <target state="translated">Имя удаленного файла. Для имени локального файла будет использоваться результат $ ff-&amp;gt; output_file.</target>
        </trans-unit>
        <trans-unit id="54a547e6d045957f910163d7d9750610edbb9f85" translate="yes" xml:space="preserve">
          <source>The name of the test that will be displayed after the &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;not
ok&lt;/code&gt; .</source>
          <target state="translated">Название теста, которое будет отображаться после &lt;code&gt;ok&lt;/code&gt; или &lt;code&gt;not ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fed54953d3ed163e618a466d003f5bcd630ecc77" translate="yes" xml:space="preserve">
          <source>The name of the test. Usually a filename.</source>
          <target state="translated">Название теста.Обычно это фамилия.</target>
        </trans-unit>
        <trans-unit id="bddd22d202ef6bbfb07440852aa85decd3f86741" translate="yes" xml:space="preserve">
          <source>The name of the variable the OP's targ refers to, if any, otherwise the letter t followed by the OP's targ in decimal.</source>
          <target state="translated">Имя переменной,на которую указан знак ОП,если таковой имеется,в противном случае буква t,за которой следует знак ОП в десятичной дроби.</target>
        </trans-unit>
        <trans-unit id="57d8fd0b0612e473ba409ed332506df9547952e4" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the tarball generated by tardist. This target does the actual work of turning the distdir into a tarball.</source>
          <target state="translated">Имя этой цели-название тарбола,генерируемого тардистом.Эта мишень выполняет фактическую работу по превращению дистрибутива в тарбол.</target>
        </trans-unit>
        <trans-unit id="7f384abee623b7aefa3eee77d6cf325a89576f28" translate="yes" xml:space="preserve">
          <source>The name of this target is the name of the zip file generated by zipdist. This target does the actual work of turning the distdir into a zip file.</source>
          <target state="translated">Имя этой цели-это имя zip-файла,сгенерированного zipdist'ом.Эта цель выполняет фактическую работу по превращению дистрибутива в zip-файл.</target>
        </trans-unit>
        <trans-unit id="40fffdd6d8d082596e0b6d7269c4fc2ab2372dd8" translate="yes" xml:space="preserve">
          <source>The name or URL, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&amp;lt;/CAVEATS&amp;gt;&quot;, the name is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Имя или URL-адрес, или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если нет. (Например, в &amp;laquo;L &amp;lt;Perl Functions | perlfunc&amp;gt;&amp;raquo; имя (также иногда называемое страницей) - &amp;laquo;perlfunc&amp;raquo;. В &amp;laquo;L &amp;lt;/CAVEATS&amp;gt;&amp;raquo; имя - &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="032b79c8986bca0bbbc3c31a86f48e2e4e0d3085" translate="yes" xml:space="preserve">
          <source>The name returned is the &quot;best&quot; (defined below) official name or alias for the code point, if available; otherwise your custom alias for it, if defined; otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. This means that your alias will only be returned for code points that don't have an official Unicode name (nor alias) such as private use code points.</source>
          <target state="translated">Возвращаемое имя является &amp;laquo;наилучшим&amp;raquo; (определенным ниже) официальным именем или псевдонимом для кодовой точки, если доступно; в противном случае ваш собственный псевдоним для него, если он определен; в противном случае &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Это означает, что ваш псевдоним будет возвращен только для кодовых точек, у которых нет официального имени Unicode (или псевдонима), таких как кодовые точки частного использования.</target>
        </trans-unit>
        <trans-unit id="45c859e03c561ae7900b19a5195289cf330fd686" translate="yes" xml:space="preserve">
          <source>The name specification contains the name of the option, optionally followed by a list of alternative names separated by vertical bar characters.</source>
          <target state="translated">Спецификация имени содержит имя опции,за которым,по желанию,следует список альтернативных имен,разделенных символами вертикальной полосы.</target>
        </trans-unit>
        <trans-unit id="74ea5f2153ac354bb676ac855da5204a1c4f0887" translate="yes" xml:space="preserve">
          <source>The name stored in the pad name struct. This returns NULL for a target slot.</source>
          <target state="translated">Имя,сохраненное в структуре имени блокнота.Возвращает NULL для целевого слота.</target>
        </trans-unit>
        <trans-unit id="7c9c5d421e8490b0fb44df42960273145ec017c2" translate="yes" xml:space="preserve">
          <source>The name that &lt;code&gt;gv_stash*v&lt;/code&gt; wants is the name of the package whose symbol table you want. The default package is called &lt;code&gt;main&lt;/code&gt; . If you have multiply nested packages, pass their names to &lt;code&gt;gv_stash*v&lt;/code&gt; , separated by &lt;code&gt;::&lt;/code&gt; as in the Perl language itself.</source>
          <target state="translated">Имя, &lt;code&gt;gv_stash*v&lt;/code&gt; хочет gv_stash * v, - это имя пакета, таблица символов которого вам нужна. Пакет по умолчанию называется &lt;code&gt;main&lt;/code&gt; . Если у вас несколько вложенных пакетов, передайте их имена в &lt;code&gt;gv_stash*v&lt;/code&gt; , разделив их символом &lt;code&gt;::&lt;/code&gt; , как в самом языке Perl.</target>
        </trans-unit>
        <trans-unit id="0ea1c9f71e1742c14f7e274aadd24083453f785c" translate="yes" xml:space="preserve">
          <source>The name used to execute the current copy of Perl, from C's &lt;code&gt;argv[0]&lt;/code&gt; or (where supported)</source>
          <target state="translated">Имя, используемое для выполнения текущей копии Perl, из &lt;code&gt;argv[0]&lt;/code&gt; C argv [0] или (где поддерживается)</target>
        </trans-unit>
        <trans-unit id="7d5e4108cb484849f5cc23fa9d5c378793d57fcf" translate="yes" xml:space="preserve">
          <source>The names</source>
          <target state="translated">Имена</target>
        </trans-unit>
        <trans-unit id="618e9ec6e6fd129b3719b6fed50188e89fd59442" translate="yes" xml:space="preserve">
          <source>The names are in the old-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">Имена указаны в старом стиле (см. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Сравнение имен блоков в старом и новом стиле&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="07ca386df79309f7e041c206d3183ef66c0ddbc4" translate="yes" xml:space="preserve">
          <source>The names associated with pad entries.</source>
          <target state="translated">Имена,связанные с записями в блокнот.</target>
        </trans-unit>
        <trans-unit id="284af84a82eacc68e4acdb3ccfa2e6b8438eb902" translate="yes" xml:space="preserve">
          <source>The names have been chosen by analogy with &lt;a href=&quot;tie/scalar&quot;&gt;Tie::Scalar&lt;/a&gt; methods names with an additional &lt;b&gt;LENGTH&lt;/b&gt; callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</source>
          <target state="translated">Имена выбраны по аналогии с именами методов &lt;a href=&quot;tie/scalar&quot;&gt;Tie :: Scalar&lt;/a&gt; с дополнительным обратным вызовом &lt;b&gt;LENGTH&lt;/b&gt; для эффективности. Однако именованные переменные захвата в настоящее время не связаны внутренне, а реализованы с помощью магии.</target>
        </trans-unit>
        <trans-unit id="6f2021e99e612abfa74ac94b1f6cbd3e729a273e" translate="yes" xml:space="preserve">
          <source>The names of any symbols that cannot be exported should be listed in the &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; array.</source>
          <target state="translated">Имена любых символов, которые нельзя экспортировать, должны быть перечислены в массиве &lt;code&gt;@EXPORT_FAIL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce28b5edeebefe670a07dac363032a7c7d1c8c78" translate="yes" xml:space="preserve">
          <source>The names of one or more patch files or other text attachments to be included with the report. Multiple files must be separated with commas.</source>
          <target state="translated">Имена одного или нескольких патч-файлов или других текстовых вложений,которые должны быть включены в отчет.Несколько файлов должны быть разделены запятыми.</target>
        </trans-unit>
        <trans-unit id="8f857c3b3defbce0780a8f039ec3e39d992aed2b" translate="yes" xml:space="preserve">
          <source>The names of the constants are grouped by length. Generate child subroutines for each group with this number or more names in.</source>
          <target state="translated">Названия констант сгруппированы по длине.Сгенерируйте дочерние подпрограммы для каждой группы с таким номером или несколькими именами.</target>
        </trans-unit>
        <trans-unit id="014e7ffcf388c955244e207841832a805e1b764b" translate="yes" xml:space="preserve">
          <source>The names of the fields can be obtained by calling &lt;code&gt;overview_fmt&lt;/code&gt; .</source>
          <target state="translated">Имена полей можно получить, вызвав &lt;code&gt;overview_fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4fc313d5aefbc7e8f27ebb1be72375df1f65ec2" translate="yes" xml:space="preserve">
          <source>The names of the signals are the ones listed out by &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; on your system, or you can retrieve them using the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC::Signal&lt;/a&gt;.</source>
          <target state="translated">Имена сигналов перечислены с помощью &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; в вашей системе, или вы можете получить их с помощью модуля CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Signal&quot;&gt;IPC :: Signal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5a87a1d013fec4fa7021ebe1fad71eb5dada0f" translate="yes" xml:space="preserve">
          <source>The naming of encodings, both by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and by the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma allows for flexible names: &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;KOI8R&lt;/code&gt; will both be understood.</source>
          <target state="translated">Именование кодировок с помощью &lt;code&gt;KOI8R&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; позволяет использовать гибкие имена: &lt;code&gt;koi8-r&lt;/code&gt; и KOI8R будут понятны.</target>
        </trans-unit>
        <trans-unit id="eb26ebee327534f7eadec1f76baa31ad090fef00" translate="yes" xml:space="preserve">
          <source>The native status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. On POSIX-like systems this value can be decoded with the WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG and WIFCONTINUED functions provided by the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">Собственный статус, возвращаемый последним закрытием канала, командой обратной кавычки ( &lt;code&gt;``&lt;/code&gt; ), успешным вызовом &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; или оператором &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . В системах, подобных POSIX, это значение можно декодировать с помощью функций WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG и WIFCONTINUED, предоставляемых модулем &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f679d50295d2d00d85ba280df81111988684878" translate="yes" xml:space="preserve">
          <source>The natural question: &quot;Why can't Perl compensate for the gaps?&quot; warrants an answer. One good reason is that C compilers might provide (non-ANSI) extensions permitting all sorts of fancy control over the way structures are aligned, even at the level of an individual structure field. And, if this were not enough, there is an insidious thing called &lt;code&gt;union&lt;/code&gt; where the amount of fill bytes cannot be derived from the alignment of the next item alone.</source>
          <target state="translated">Естественный вопрос: &amp;laquo;Почему Perl не может компенсировать пробелы?&amp;raquo; требует ответа. Одна из веских причин заключается в том, что компиляторы C могут предоставлять (не-ANSI) расширения, позволяющие всевозможные причудливые средства управления выравниванием структур, даже на уровне отдельного поля структуры. И, если этого было недостаточно, есть коварная вещь, называемая &lt;code&gt;union&lt;/code&gt; где количество байтов заполнения не может быть получено только путем выравнивания следующего элемента.</target>
        </trans-unit>
        <trans-unit id="73304f2bc3720cbdf5bbe3a347ce1a6a6606cb3e" translate="yes" xml:space="preserve">
          <source>The natural way to do this is to have a hash whose keys are country names. Associated with each country name key is a list of the cities in that country. Each time you read a line of input, split it into a country and a city, look up the list of cities already known to be in that country, and append the new city to the list. When you're done reading the input, iterate over the hash as usual, sorting each list of cities before you print it out.</source>
          <target state="translated">Естественный способ сделать это-иметь хэш,ключами которого являются названия стран.С каждым ключом названия страны связан список городов в этой стране.Каждый раз,когда вы читаете строку ввода,разбиваете ее на страну и город,просматриваете список городов,уже известных в этой стране,и добавляете новый город в список.Когда вы закончите чтение ввода,выполните итерацию по хэшу,как обычно,сортируя каждый список городов перед тем,как распечатать его.</target>
        </trans-unit>
        <trans-unit id="9ba13cfae515a220e252c3e1157af722de7da0aa" translate="yes" xml:space="preserve">
          <source>The negation is useful for defining (surprise!) negated classes.</source>
          <target state="translated">Отрицание полезно для определения (сюрприз!)отрицательных классов.</target>
        </trans-unit>
        <trans-unit id="db0ad6bd4816ce652496b94f2f1d7976b92ada0c" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">Отрицание этого макроса &lt;code&gt;OP_TYPE_ISNT&lt;/code&gt; также доступно, а также &lt;code&gt;OP_TYPE_IS_NN&lt;/code&gt; и &lt;code&gt;OP_TYPE_ISNT_NN&lt;/code&gt; , которые исключают проверку указателя NULL.</target>
        </trans-unit>
        <trans-unit id="691f70fa29f72e49de97eccc12c05c1f840f1b46" translate="yes" xml:space="preserve">
          <source>The negation of this macro, &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; is also available as well as &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; and &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; which elide the NULL pointer check.</source>
          <target state="translated">Отрицание этого макроса &lt;code&gt;OP_TYPE_ISNT_AND_WASNT&lt;/code&gt; также доступно, а также &lt;code&gt;OP_TYPE_IS_OR_WAS_NN&lt;/code&gt; и &lt;code&gt;OP_TYPE_ISNT_AND_WASNT_NN&lt;/code&gt; , которые отменяют проверку нулевого указателя.</target>
        </trans-unit>
        <trans-unit id="a68f1f4d38ce035e2e238de529bbc7313afe802e" translate="yes" xml:space="preserve">
          <source>The new class is given a constructor method, &lt;code&gt;new&lt;/code&gt; , for creating struct objects.</source>
          <target state="translated">Новому классу предоставляется метод конструктора &lt;code&gt;new&lt;/code&gt; для создания объектов структуры.</target>
        </trans-unit>
        <trans-unit id="133a286ef1fa797920ffbacb6d543c092bbb9c81" translate="yes" xml:space="preserve">
          <source>The new compare function must be specified when you create the database.</source>
          <target state="translated">Новая функция сравнения должна быть указана при создании базы данных.</target>
        </trans-unit>
        <trans-unit id="6ca5133e85084fb8ccd654bdee5f648c6a7925f9" translate="yes" xml:space="preserve">
          <source>The new interface to the USE_PERLIO implementation. The layers &quot;:crlf&quot; and &quot;:raw&quot; are only ones allowed for other implementations and those are silently ignored. (As of perl5.8 &quot;:raw&quot; is deprecated.) Use PerlIO_binmode() below for the portable case.</source>
          <target state="translated">Новый интерфейс к реализации USE_PERLIO.Слои &quot;:crlf&quot; и &quot;:raw&quot; разрешены только для других реализаций и игнорируются.(Начиная с версии perl5.8 &quot;:raw&quot; является устаревшим.)Используйте PerlIO_binmode(),приведенную ниже,для переносимого кейса.</target>
        </trans-unit>
        <trans-unit id="ef605716ebbaada258955508adf61e07c343c95f" translate="yes" xml:space="preserve">
          <source>The new key is specified by</source>
          <target state="translated">Новый ключ определяется</target>
        </trans-unit>
        <trans-unit id="853b1cad8315c050b3031642990285f3b3f61796" translate="yes" xml:space="preserve">
          <source>The new perlIO layer is used. NI-S' favorite.</source>
          <target state="translated">Используется новый слой перлио.Любимый NI-S.</target>
        </trans-unit>
        <trans-unit id="3f44fc740bd8115fd48ea2f3dccbe8d30383620f" translate="yes" xml:space="preserve">
          <source>The new routine will be called whenever a built-in function is called without a qualifying package:</source>
          <target state="translated">Новая рутина будет вызываться всякий раз,когда будет вызвана встроенная функция без квалифицирующего пакета:</target>
        </trans-unit>
        <trans-unit id="69fd8169a1c03a87b9cb7323668ea2985b78ca39" translate="yes" xml:space="preserve">
          <source>The new semantics are now only available with &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; . The old semantics are only available through &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; . Users are strongly encouraged to upgrade to at least 2.08 in order to avoid surprises.</source>
          <target state="translated">Новая семантика теперь доступна только с &lt;code&gt;make_path&lt;/code&gt; и &lt;code&gt;remove_tree&lt;/code&gt; . Старая семантика доступна только через &lt;code&gt;mkpath&lt;/code&gt; и &lt;code&gt;rmtree&lt;/code&gt; . Пользователям настоятельно рекомендуется обновиться до версии не ниже 2.08, чтобы избежать сюрпризов.</target>
        </trans-unit>
        <trans-unit id="dcb00043758d6e48f38e06be5dcd0156fe97d078" translate="yes" xml:space="preserve">
          <source>The new shiny result of either genuine new functionality or your arduous refactoring is now ready and correctly exported. So what could possibly go wrong?</source>
          <target state="translated">Новый блестящий результат либо реальной новой функциональности,либо Вашего трудного рефакторинга теперь готов и правильно экспортирован.Так что же может пойти не так?</target>
        </trans-unit>
        <trans-unit id="c231cf25130a94dd10bb860a955a6b6ad30c18f8" translate="yes" xml:space="preserve">
          <source>The new simpler way to call &lt;code&gt;XSLoader::load()&lt;/code&gt; with no arguments at all does not work on Perl 5.8.4 and 5.8.5.</source>
          <target state="translated">Новый более простой способ вызова &lt;code&gt;XSLoader::load()&lt;/code&gt; вообще без аргументов не работает в Perl 5.8.4 и 5.8.5.</target>
        </trans-unit>
        <trans-unit id="80d8983154af8008f3d7e48dfd488df835186d04" translate="yes" xml:space="preserve">
          <source>The new thread creation is line 20. We pass on to it a reference to the queue we've created, and the prime number we've found. In lines 21 through 24, we check to make sure that our new thread got created, and if not, we stop checking any remaining numbers in the queue.</source>
          <target state="translated">Создание новой нити-линия 20.Мы передаем ей ссылку на созданную нами очередь и найденное нами простое число.В строках с 21 по 24 мы проверяем,создан ли наш новый поток,и если нет,то перестаем проверять любые оставшиеся номера в очереди.</target>
        </trans-unit>
        <trans-unit id="9044c695c3da968e5a2ea15d51b8b1e2dbc7cbb0" translate="yes" xml:space="preserve">
          <source>The new() function searches for all the installed .packlists on the system, and stores their contents. The .packlists can be queried with the functions described below. Where it searches by default is determined by the settings found in &lt;code&gt;%Config::Config&lt;/code&gt; , and what the value is of the PERL5LIB environment variable.</source>
          <target state="translated">Функция new () ищет все установленные в системе списки .packlists и сохраняет их содержимое. Списки .packlists можно запросить с помощью функций, описанных ниже. Область поиска по умолчанию определяется настройками, найденными в &lt;code&gt;%Config::Config&lt;/code&gt; , и значением переменной среды PERL5LIB.</target>
        </trans-unit>
        <trans-unit id="5e76ad120503fe22fb2abd0288095a443b471d16" translate="yes" xml:space="preserve">
          <source>The newer style replaces these with underscores, like this:</source>
          <target state="translated">Более новый стиль заменяет их подчеркиваниями,вот так:</target>
        </trans-unit>
        <trans-unit id="0249c11220739d961eab9d8efdfb827caa468595" translate="yes" xml:space="preserve">
          <source>The newly created subroutine takes ownership of a reference to the passed in SV.</source>
          <target state="translated">Вновь созданная подпрограмма берет на себя право собственности на ссылку на переданную в SV.</target>
        </trans-unit>
        <trans-unit id="c36ff1fb86ca87ccc2385388c9e1be809de8496c" translate="yes" xml:space="preserve">
          <source>The next 8 bits contain the termination status of the program.</source>
          <target state="translated">Следующие 8 бит содержат статус завершения программы.</target>
        </trans-unit>
        <trans-unit id="429ca09b18f928ad50edc605bbb88976cae30220" translate="yes" xml:space="preserve">
          <source>The next example demonstrates how one would place an explicit undef in the return value, should the need arise.</source>
          <target state="translated">Следующий пример демонстрирует,как можно поместить явный undef в возвращаемое значение,если возникает такая необходимость.</target>
        </trans-unit>
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">В следующем примере показано, как использовать параметр &lt;code&gt;LimitOutput&lt;/code&gt; . Обратите внимание на использование двух вложенных циклов в этом случае. Внешний цикл считывает данные из источника ввода - STDIN, а внутренний цикл многократно вызывает &lt;code&gt;inflate&lt;/code&gt; до тех пор, пока &lt;code&gt;$input&lt;/code&gt; будет исчерпан, мы не получим ошибку или не будет достигнут конец потока. Следует помнить один момент: используя параметр &lt;code&gt;LimitOutput&lt;/code&gt; , вы также получаете набор &lt;code&gt;ConsumeInput&lt;/code&gt; - это значительно упрощает приведенный ниже код.</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">В следующем примере показан каждый входной параметр,обработанный с опозданием.</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">В следующих примерах будет использоваться следующий класс C++.</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">Следующий вариант связан с кодовым набором (так же известным как набор символов),который поддерживает ваш терминал.В общем,CPAN является англоязычной территорией,поэтому кодовая таблица не имеет большого значения,но некоторые CPAN имеют имена,которые находятся за пределами диапазона ASCII.Если ваш терминал поддерживает UTF-8,вы должны сказать &quot;нет&quot; следующему вопросу.Если он ожидает ISO-8859-1 (также известный как LATIN1),то вы должны сказать &quot;да&quot;.Если он не поддерживает ни то,ни другое,ваш ответ не имеет значения,потому что вы все равно не сможете прочитать имена некоторых авторов.Если вы ответите &quot;нет&quot;,имена будут выведены в UTF-8.</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">Следующий указатель для &lt;code&gt;BRANCH&lt;/code&gt; es интересен тем, что он указывает, куда должно идти выполнение, если ветвление завершится неудачей. При выполнении, если движок пытается перейти от ветки к &lt;code&gt;regnext&lt;/code&gt; , который не является ветвью, то движок будет знать, что весь набор ветвей потерпел неудачу.</target>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">Следующий шаг-интерполяция в полученном тексте,который теперь является разделительно-независимым.Случаев несколько.</target>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">Следующий шаг-отправить патч в основную билетную систему Perl по электронной почте.</target>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">Следующая задача-разбить проблему на более мелкие проблемы,которые легко преобразуются в регеxp.</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">В следующий раз,когда вы захотите сделать заплатку,вы должны начать с последнего perl в первозданном виде.Проверьте,нет ли у вас локальных изменений или добавленных файлов на perl,которые вы хотите сохранить,затем запустите эти команды:</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">Хорошая часть о тестах todo,в отличие от простого комментирования блока тестов,это как иметь программный список todo.Вы знаете,сколько работы осталось сделать,вы знаете,какие есть ошибки,и сразу же узнаете,когда они будут исправлены.</target>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Для сборки достаточно nmake, поставляемого с Visual C ++. Visual C требует, чтобы определенные вещи были настроены в консоли, прежде чем Visual C успешно запустится. Чтобы консоль могла запускать компилятор C, вам необходимо заранее запустить файл &lt;code&gt;vcvars32.bat&lt;/code&gt; для компиляции для x86-32 и для x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; или &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . При типичной установке продукта компилятора Microsoft C эти командные файлы уже будут в вашем &lt;code&gt;PATH&lt;/code&gt; переменная среды, поэтому вы можете просто ввести их без абсолютного пути в консоль. Если вам нужно найти абсолютный путь к пакетному файлу, он обычно находится где-то вроде C: \ Program Files \ Microsoft Visual Studio \ VC98 \ Bin. В некоторых новых продуктах Micrsoft C (выпущенных после ~ 2004 г.) программа установки поместит ярлык в меню &amp;laquo;Пуск&amp;raquo; для запуска нового окна консоли с консолью, уже настроенной для вашей целевой архитектуры (x86-32 или x86-64 или IA64). . С более новыми компиляторами вы также можете использовать старые командные файлы, если захотите.</target>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">Nmake,которая поставляется с Платформой SDK,будет достаточно для создания Perl.Убедитесь,что вы собираете в одной из оболочек &quot;Build Environment&quot;,доступных после установки Комплекта SDK для платформы из меню &quot;Пуск&quot;.</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Тип узла: &lt;code&gt;section&lt;/code&gt; или &lt;code&gt;item&lt;/code&gt; . В качестве неофициального типа существует также &lt;code&gt;hyperlink&lt;/code&gt; , производная, например, от &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">Неразрушающий модификатор &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; приводит к возврату результата подстановки вместо изменения &lt;code&gt;$_&lt;/code&gt; (или любой другой переменной, к которой подстановка была привязана с помощью &lt;code&gt;=~&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">Ненулевое число</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">Обычный Makefile.PL,который генерирует h2xs,не знает о каталоге mylib.Мы должны сказать ему,что есть подкаталог,и что мы будем генерировать в нем библиотеку.Добавим аргумент MYEXTLIB к вызову WriteMakefile,чтобы он выглядел так:</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">Обычное дело-позвонить:</target>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">Обычное использование этого класса так и есть:</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">Обычный способ запустить программу Perl - сделать ее непосредственно исполняемой или передать имя исходного файла в качестве аргумента в командной строке. (Также возможна интерактивная среда Perl - см. &lt;a href=&quot;perldebug&quot;&gt;Perldebug,&lt;/a&gt; чтобы узнать, как это сделать.) При запуске Perl ищет вашу программу в одном из следующих мест:</target>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">Нотация все еще выглядит немного громоздкой,так что есть еще одна аббревиатура:</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">Представление о том, что пустой &lt;b&gt;производный класс&lt;/b&gt; должен вести себя точно так же, как его &lt;b&gt;базовый класс&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">Представление о том, что вы можете указать &lt;b&gt;объекту&lt;/b&gt; выполнить что-то общее, и объект будет интерпретировать команду по-разному в зависимости от ее типа. [&amp;lt;Греч. &amp;Pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, много форм.]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">Идея о том, что с полным набором простых инструментов, которые хорошо работают вместе, вы можете построить практически все, что захотите. Это нормально, если вы собираете трехколесный велосипед, но если вы собираете регургалатор comboflux с дефранизацией, вам действительно нужен собственный цех, в котором можно будет создавать специальные инструменты. Perl - это что-то вроде механического цеха.</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">Нулевой дескриптор файла &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; является особенным: его можно использовать для эмуляции поведения &lt;b&gt;sed&lt;/b&gt; и &lt;b&gt;awk&lt;/b&gt; , а также любой другой программы фильтрации Unix, которая принимает список имен файлов, делая то же самое для каждой строки ввода от всех из них. Входные данные из &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; поступают либо из стандартного ввода, либо из каждого файла, указанного в командной строке. Вот как это работает: при первом вычислении &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;code&gt;@ARGV&lt;/code&gt; массив @ARGV , и если он пуст, &lt;code&gt;$ARGV[0]&lt;/code&gt; устанавливается в &lt;code&gt;&quot;-&quot;&lt;/code&gt; , что при открытии дает стандартный ввод. Затем массив &lt;code&gt;@ARGV&lt;/code&gt; обрабатывается как список имен файлов. Петля</target>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">Нулевой список представлен фигурой ().Интерполяция его в списке не имеет никакого эффекта.Таким образом,функция ((),(),())эквивалентна функции ().Аналогично,интерполяция массива без элементов такая же,как если бы в этот момент не было интерполировано ни одного массива.</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">Время цикла нуля может быть кэшировано,ключом является количество циклов.Кэшированием можно управлять с помощью подобных вызовов:</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">Число 0, строки &lt;code&gt;'0'&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; , пустой список &lt;code&gt;()&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в логическом контексте ложны. Все остальные значения верны. Отрицание истинной ценности &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; возвращает специальное ложное значение. При оценке в виде строки он обрабатывается как &lt;code&gt;&quot;&quot;&lt;/code&gt; , но как число он обрабатывается как 0. Большинство операторов Perl, возвращающих истину или ложь, ведут себя подобным образом.</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Номер после Perl (т.е.5 после Perl 5)является основным выпуском perl-переводчика,а также версией языка.Каждая основная версия имеет существенные различия,которые не могут быть поддержаны более ранними версиями.</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">Номер для &quot;генерации&quot; тестового прогона.Первое поколение-1 (одно),а последующие-2,3 и т.д.</target>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">Количество параллельных заданий,с которыми будет работать эта форматура.</target>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">Количество элементов в массиве будет &lt;code&gt;fill + 1&lt;/code&gt; после возврата av_fill (). Если ранее массив был короче, то добавляемые дополнительные элементы устанавливаются в NULL. Если массив был длиннее, то лишние элементы освобождаются. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; совпадает с &lt;code&gt;av_clear(av)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">Количество элементов в хэше можно получить,сделав это:</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">Количество строк,оставшихся на странице текущего выбранного выходного канала.</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">Количество строк, прочитанных до этой, плюс 1. Perl сохраняет отдельный номер строки для каждого исходного или входного файла, который он открывает. Номер строки текущего исходного файла представлен как &lt;code&gt;__LINE__&lt;/code&gt; . Текущий номер строки ввода (для файла, который был прочитан последним через &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) представлен символом &lt;code&gt;$.&lt;/code&gt; ( &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) переменная. Во многих сообщениях об ошибках указываются оба значения, если они доступны.</target>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">Количество секунд,в течение которых программа выполнялась перед завершением,или 0,если таймаут не наступил.</target>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">Количество пробелов для отступа обычного текста и отступ по умолчанию для &lt;code&gt;=over&lt;/code&gt; блоками. По умолчанию 4.</target>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">Количество тестов в вашем сценарии.Это означает все вызовы ok()и skip().</target>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">Количество тестов с директивами TODO.</target>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">Количество ссылок на структуру. Когда оно падает до 0, регулярное выражение автоматически освобождается вызовом pregfree. Это должно быть установлено на 1 в программе &lt;a href=&quot;#comp&quot;&gt;компенсации&lt;/a&gt; каждого двигателя .</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">Количество неудачных тестов.</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">Количество пройденных тестов.</target>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">Нумерация внутри каждой ветви будет как обычно,и любые группы,следующие за этой конструкцией,будут пронумерованы так,как если бы конструкция содержала только одну ветвь,которая является той,в которой находится больше всего захватывающих групп.</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Числа хранятся как объекты,и их внутренняя часть может измениться в любое время,особенно между математическими операциями.Объекты также могут принадлежать различным классам,таким как Math::BigInt или Math::BigFloat.Смешивание их вместе,даже при нормальных скалярах,не является экстраординарным,а нормальным и ожидаемым.</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Числа хранятся как объекты,и их внутренняя часть может измениться в любое время,особенно между математическими операциями.Объекты также могут принадлежать различным классам,таким как Math::BigInt или Math::BigInt::Lite.Смешивание их вместе,даже при нормальных скалярах,не является экстраординарным,а нормальным и ожидаемым.</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">Режим числовых разрешений, применяемый к каждому созданному каталогу (по умолчанию 0777), который должен быть изменен текущей &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; . Если каталог уже существует (и, следовательно, его не нужно создавать), разрешения не будут изменены.</target>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">Числовое значение флагов подсказки COP,или пустая строка,если это не COP.</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">Числовое значение флагов ОП.</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">Числовое значение частных флагов ОП.</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">Числовое значение ТАРГА ОП.</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">Числовое значение типа ОП,в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">Объект повторно благословляется в подкласс &lt;code&gt;IO::Handle&lt;/code&gt; и становится дескриптором на считывающем конце канала. Если заданы &lt;code&gt;ARGS&lt;/code&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;ARGS&lt;/code&gt; передаются в exec.</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">Объект повторно благословляется в подкласс &lt;code&gt;IO::Handle&lt;/code&gt; и становится дескриптором на записывающем конце канала. Если заданы &lt;code&gt;ARGS&lt;/code&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;ARGS&lt;/code&gt; передаются в exec.</target>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">Объект или класс, для которого вызывается метод, передается как один из аргументов метода, а не как отдельное значение &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">В этом разделе описывается объектно-ориентированный интерфейс к &lt;code&gt;Digest::MD5&lt;/code&gt; . После создания объекта &lt;code&gt;Digest::MD5&lt;/code&gt; вы добавите к нему данные и, наконец, запросите дайджест в подходящем формате. Один объект можно использовать для вычисления нескольких дайджестов.</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">Реестр объектов также используется для ремонта хэша полей после клонирования потока.Здесь обрабатывается весь объектный реестр.Для каждой найденной там ссылки,хэши полей,которые он использовал,посещаются и запись обновляется.</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">Реестр объектов отслеживает ссылки, которые использовались в качестве ключей хеширования полей. Ключи генерируются из ссылочного адреса, как в хэше поля (хотя реестр не является хешем поля). Каждое значение является слабой копией исходной ссылки, хранящейся в &lt;code&gt;SV&lt;/code&gt; , который сам по себе является магическим ( снова &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ). Магическая структура содержит список (на самом деле еще один хеш) хешей полей, с которыми использовалась ссылка. Когда weakref становится устаревшим, магия активируется и использует список для удаления ссылки из всех хэшей полей, с которыми она использовалась. После этого запись удаляется из самого реестра объектов. Неявно это освобождает магическую структуру и хранилище, которое она использовала.</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">Объект, возвращаемый &lt;code&gt;builder()&lt;/code&gt; может измениться во время выполнения, поэтому вы должны вызывать &lt;code&gt;builder()&lt;/code&gt; внутри каждой функции, а не сохранять его в глобальном.</target>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">Функция oct () обычно используется, когда, например, строку типа &lt;code&gt;644&lt;/code&gt; необходимо преобразовать в файловый режим. Хотя Perl автоматически преобразует строки в числа по мере необходимости, это автоматическое преобразование предполагает основание 10.</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">Официальные (многопоточные) сборки HP, поставляемые на DVD / CD с приложениями, доступны на &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; для обоих PA-RISC. и IPF (Семейство процессоров Itanium). Они построены с помощью компилятора HP ANSI-C. До 5.8.8 этим занимался ActiveState.</target>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">Официальным форумом для разработки perl является список рассылки perl5-портеров,упомянутый выше,и его багтрекер на rt.perl.org.Ожидается,что все участники дискуссии там будут придерживаться стандарта поведения.</target>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">Официальное название VMS на момент написания статьи-OpenVMS.</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">Официальный сайт Berkeley DB является</target>
        </trans-unit>
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">Старое поведение немедленного кваканья можно восстановить, установив для &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; некоторое значение &lt;code&gt;FALSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">Старый стиль формата отображения, который может иметь значения &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; или &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , можно изменить с помощью параметра &lt;code&gt;&quot;style&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">Старая форма gv_init_pvn (). Он не работает со строками UTF8, так как не имеет параметра flags. Если установлен параметр &lt;code&gt;multi&lt;/code&gt; , флаг GV_ADDMULTI будет передан в gv_init_pvn ().</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">Старый дом для модульных тестов,не стоит ставить сюда ничего нового.Здесь все еще есть несколько кусочков,которые нужно перевезти.Может,вы могли бы их переместить? Спасибо!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">Старым разделителем пакетов была одинарная кавычка, но теперь предпочтительным разделителем является двойное двоеточие, отчасти потому, что он более читается для людей, а отчасти потому, что он более читается для макросов &lt;b&gt;emacs&lt;/b&gt; . Это также заставляет программистов на C ++ чувствовать, что они знают, что происходит, - в отличие от использования одинарной кавычки в качестве разделителя, который был нужен для того, чтобы программисты Ada чувствовали, что они знают, что происходит. Поскольку старомодный синтаксис все еще поддерживается для обратной совместимости, если вы попытаетесь использовать строку типа &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , вы получите доступ к &lt;code&gt;$owner::s&lt;/code&gt; ; то есть переменная $ s в &lt;code&gt;owner&lt;/code&gt; пакета , что, вероятно, не то, что вы имели в виду. Используйте фигурные скобки для устранения неоднозначности, например, &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">Старые (и, возможно, устаревшие) библиотеки &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">Старые библиотеки &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">Форма с одним аргументом add_bits () принимает в качестве аргумента строку $ bitstring из &quot;1&quot; и &quot;0&quot; символов. Это сокращение от &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">Единственное соглашение по вызову параметров также работает.</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">Единственный пользователь (кроме суперпользователя), который имеет полный контроль над &lt;b&gt;файлом&lt;/b&gt; . Файл также может иметь &lt;b&gt;группу&lt;/b&gt; пользователей, которые могут осуществлять совместное владение, если это разрешено реальным владельцем. См. &lt;b&gt;Биты разрешений&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">Единственный абсолютно обязательный метод. Вызывается, когда слой помещается в стек. &lt;code&gt;mode&lt;/code&gt; аргумент может быть NULL , если это происходит после открытой. &lt;code&gt;arg&lt;/code&gt; будет не- &lt;code&gt;NULL&lt;/code&gt; , если строка аргумента была принята. В большинстве случаев это должно вызывать &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; для преобразования &lt;code&gt;mode&lt;/code&gt; в соответствующие флаги &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; в дополнение к любым действиям, предпринимаемым самим слоем. Если уровень не ожидает аргумента, ему не нужно ни сохранять переданный ему аргумент, ни предоставлять &lt;code&gt;Getarg()&lt;/code&gt; (возможно, &lt;code&gt;Perl_warn&lt;/code&gt; может указать, что аргумент был неожиданным ).</target>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">Единственные различия связаны с тем, что &lt;code&gt;string_vianame&lt;/code&gt; - это время выполнения, а &lt;code&gt;\N{}&lt;/code&gt; - время компиляции. Вы не можете интерполировать внутри &lt;code&gt;\N{}&lt;/code&gt; (поэтому &lt;code&gt;\N{$variable}&lt;/code&gt; не работает); а если имя входа неизвестно, &lt;code&gt;string_vianame&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вместо синтаксической ошибки.</target>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">Единственным указанным флагом на этот раз был G_SCALAR. Это означает, что будет создан массив &lt;code&gt;@_&lt;/code&gt; и что значение, возвращаемое</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">Единственная интерполяция - это удаление &lt;code&gt;\&lt;/code&gt; из пар &lt;code&gt;\\&lt;/code&gt; . Поэтому &lt;code&gt;&quot;-&quot;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; трактуется буквально как дефис, и диапазон символов недоступен. &lt;code&gt;\1&lt;/code&gt; в замене &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; не работает как &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">Осталась только одна проблема-как загрузиться.</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">Единственный вид простых операторов - это выражение, оцениваемое на предмет его побочных эффектов. Каждый простой оператор должен заканчиваться точкой с запятой, если только это не последний оператор в блоке, и в этом случае точка с запятой не является обязательной. Но все равно ставьте точку с запятой, если блок занимает более одной строки, потому что в конечном итоге вы можете добавить еще одну строку. Обратите внимание, что есть такие операторы, как &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , которые</target>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">Единственное законное использование этой прагмы - это почти наверняка только по одному на файл, в верхней части, с областью действия файла, поскольку файл, вероятно, будет записан только в одной кодировке. Дальнейшие ограничения применяются в &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Perl&lt;/a&gt; до v5.22 (см. До Perl v5.22 ).</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Единственная локаль для многобайтовых (или широких символов), которую Perl может поддерживать, - это UTF-8. Это связано со сложностью реализации, тем фактом, что высококачественные локали UTF-8 теперь публикуются для всех регионов мира ( &lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt; ), и что в противном случае вы можно использовать &lt;a href=&quot;encode&quot;&gt;кодирование&lt;/a&gt;модуль для перевода на / из вашей локали. Итак, вам придется сделать одну из этих вещей, если вы используете одну из этих локалей, например Big5 или Shift JIS. Для локалей UTF-8 в Perls (до версии 5.20), которые не имеют полной поддержки локали UTF-8, они могут работать достаточно хорошо (в зависимости от реализации вашей библиотеки C) просто потому, что и они, и Perl хранят символы, которые занимают несколько байтов одинаково. Однако некоторые, если не большинство, реализаций библиотеки C могут не обрабатывать символы в верхней половине диапазона Latin-1 (128&amp;ndash;255) должным образом в &lt;code&gt;LC_CTYPE&lt;/code&gt; . Чтобы узнать, относится ли символ к определенному типу в локали, Perl использует такие функции, как &lt;code&gt;isalnum()&lt;/code&gt; . Ваша библиотека C может не работать для локалей UTF-8 с этими функциями,вместо этого работает только с новыми широкими библиотечными функциями, такими как &lt;code&gt;iswalnum()&lt;/code&gt; , который Perl не использует. Эти многобайтовые языковые стандарты рассматриваются как однобайтовые языковые стандарты и будут иметь ограничения, описанные ниже. Начиная с Perl v5.22, появляется предупреждение, когда Perl обнаруживает многобайтовый языковой стандарт, который он не поддерживает полностью.</target>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Единственное несимвольное свойство, которое в настоящее время поддерживает Perl, - это именованные последовательности, в которых последовательности кодовых точек присваивается имя и обычно обрабатывается как единое целое. (Perl поддерживает их с помощью конструкции с двойными кавычками &lt;code&gt;\N{...}&lt;/code&gt; , &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame (name) в именах символов&lt;/a&gt; и &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq () в Unicode :: UCD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">Единственной несингл-байтовой поддержкой Perl является (начиная с версии 5.20)UTF-8.Это означает,что точки кода выше 255 рассматриваются как Юникод вне зависимости от того,какая локаль действует (так как UTF-8 подразумевает Юникод).</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">Единственное объективное преимущество использования &lt;code&gt;DirHandle&lt;/code&gt; состоит в том, что он позволяет избежать загрязнения пространства имен за счет создания глобусов для хранения дескрипторов каталогов.</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">Единственным ограничением является то,что вы должны предварительно объявить,сколько тестов вы планируете запустить.Это в случае,если что-то пойдет ужасно не так во время теста,и ваша тестовая программа прервется,или пропустит тест или что-то в этом роде.Вы делаете это так:</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">Единственное место, где предупреждение не появляется, хотя оно могло бы быть, - это если в результате оптимизации не выполняется попытка сопоставления всего шаблона. Например, Perl может выяснить, что для того, чтобы строка соответствовала определенному шаблону регулярного выражения, строка должна содержать подстроку &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Перед попыткой сопоставления Perl может поискать эту подстроку, и, если она не найдена, немедленно провалить сопоставление, фактически не пытаясь его выполнить; поэтому предупреждение не создается, даже если строка содержит указанную выше кодовую точку Unicode.</target>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">Единственная цель этого шага-создать нужные каталоги и дать вам знать имена этих каталогов.Из вывода видно,что каталог для расширения имеет вид</target>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">Единственная требуемая часть-это первое поле,название модуля (например,Foo::Bar,т.е.</target>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">Единственными значимыми значениями для &lt;code&gt;flags&lt;/code&gt; являются GV_SUPER и SVf_UTF8.</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">Единственное,что следует отметить,так это то,что и в статическом,и в виртуальном методах имя метода не передается через стек-оно используется в качестве первого параметра,чтобы</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">Единственное, что вы должны помнить, это то, что подпрограмма &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Единственное, что вам нужно объявить в Perl, - это форматы отчетов и подпрограммы (а иногда даже не подпрограммы). Скалярная переменная хранит неопределенное значение ( &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) до тех пор, пока ей не будет присвоено определенное значение, отличное от &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . При использовании в качестве числа &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; обрабатывается как &lt;code&gt;0&lt;/code&gt; ; когда используется как строка, она рассматривается как пустая строка, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; и при использовании в качестве ссылки, которая не назначается, это рассматривается как ошибка. Если вы включите предупреждения, вы будете получать уведомление о неинициализированном значении всякий раз, когда вы рассматриваете &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; как строку или число. Ну, обычно. Логические контексты, например:</target>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">Единственный раз,когда ты абсолютно</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">Единственный способ изменить это - создать собственную подпрограмму для &lt;code&gt;'|'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">Единственный способ переопределить настройку лексических предупреждений - использовать флаги командной строки &lt;b&gt;-W&lt;/b&gt; или &lt;b&gt;-X&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">Дерево опций связано двумя способами:можно представить,что через него проходят два &quot;маршрута&quot;,два порядка,в которых можно пройти по дереву.Во-первых,порядок разбора отражает то,как парсер понял код,а во-вторых,порядок выполнения говорит perl,в каком порядке выполнять операции.</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">Возвращается дерево операций, представляющее блок кода. Это всегда настоящая операция, а не нулевой указатель. Обычно это список &lt;code&gt;lineseq&lt;/code&gt; , включая &lt;code&gt;nextstate&lt;/code&gt; или аналогичные операции. Никакие операции по созданию какой-либо области времени выполнения не включаются в силу того, что она является блоком.</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">Возвращается дерево операций,представляющее выражение.Если необязательное выражение отсутствует,возвращается нулевой указатель,в противном случае указатель будет ненулевым.</target>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">Возвращается дерево операций, представляющее оператор. Это может быть нулевой указатель, если оператор имеет значение NULL, например, если на самом деле это определение подпрограммы (которое имеет побочные эффекты во время компиляции). Если не null, оператор будет напрямую реализовывать инструкцию, подходящую для передачи в &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; . Обычно он не будет включать &lt;code&gt;nextstate&lt;/code&gt; или эквивалентную операцию (кроме тех, которые встроены в область видимости, полностью содержащуюся внутри оператора).</target>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">Возвращается дерево операций, представляющее оператор. Это может быть нулевой указатель, если оператор имеет значение NULL, например, если на самом деле это определение подпрограммы (которое имеет побочные эффекты во время компиляции). Если не null, это будет результатом вызова &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; , обычно включающего &lt;code&gt;nextstate&lt;/code&gt; или эквивалентную операцию.</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">Возвращается дерево операций, представляющее последовательность операторов. Это может быть нулевой указатель, если все операторы были нулевыми, например, если не было операторов или были только определения подпрограмм (которые имеют побочные эффекты во время компиляции). Если не null, это будет список &lt;code&gt;lineseq&lt;/code&gt; , обычно включающий &lt;code&gt;nextstate&lt;/code&gt; или эквивалентные операции.</target>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">Операционные флаги (например, &lt;b&gt;'sK / 2'&lt;/b&gt; ) описаны в ( &lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;Сокращения OP-флагов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">Лицензия с открытым исходным кодом, которую Ларри Уолл создал для Perl, максимизирует полезность, доступность и модифицируемость Perl. Текущая версия - 2. ( &lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">Функция open2()запускает заданный $cmd и соединяет $chld_out для чтения и $chld_in для записи.Это то,что,по вашему мнению,должно работать,когда вы пытаетесь</target>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">Операндом некоторых типов regop является буквальная строка; для других это переход к подпрограмме. В частности, операнд узла &lt;code&gt;BRANCH&lt;/code&gt; является первым регистром ветви.</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">Операционная система, драйверы устройств, библиотеки C и исполняющая система Perl - все сговорились, чтобы позволить программисту рассматривать один символ ( &lt;code&gt;\n&lt;/code&gt; ) как признак конца строки, независимо от внешнего представления. Во многих операционных системах собственное представление текстового файла совпадает с внутренним представлением, но на некоторых платформах внешнее представление &lt;code&gt;\n&lt;/code&gt; состоит из более чем одного символа.</target>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">Работа массива &lt;code&gt;%ENV&lt;/code&gt; зависит от перевода логического имени</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">Эксплуатация варианта bval заслуживает некоторого обсуждения.Вот определение bval на странице руководства по эксплуатации Berkeley DB 1.85 recno:</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">На работу этого метода также влияют записи &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; и &lt;code&gt;cc&lt;/code&gt; в &lt;code&gt;Config.pm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">На работу этого метода также влияют записи &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; и &lt;code&gt;ld&lt;/code&gt; в &lt;code&gt;Config.pm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">Операции,на которые оказывает влияние местность:</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">Оператор &lt;code&gt;not&lt;/code&gt; не является допустимым ключом для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . Однако если оператор &lt;code&gt;!&lt;/code&gt; перегружен, то для &lt;code&gt;not&lt;/code&gt; будет использоваться одна и та же реализация (поскольку два оператора отличаются только приоритетом).</target>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">Оператор может быть назначен,если и 2-й,и 3-й аргументы являются юридическими значениями (это означает,что их можно назначить):</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">За именем операции, как в &lt;b&gt;'add [t1]'&lt;/b&gt; , может следовать информация, относящаяся к операции, в круглых или квадратных скобках (например, &lt;b&gt;'[t1]'&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">Противоположность &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">Противоположность &lt;a href=&quot;#catdir()&quot;&gt;catdir ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">Противоположность &lt;a href=&quot;../spec#catdir&quot;&gt;catdir ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">Противоположность &lt;code&gt;catdir()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">Функции opset и opset_to_ops могут быть использованы для преобразования из списка операторов в опсет и</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">Используемое имя оптага не должно быть уже определено (define_optag перекроется,если оно уже определено).Имена оптагов являются глобальными для процесса perl,и определения оптагов не могут быть изменены или удалены после их определения.</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">Информация, относящаяся к оптимизатору, используется, чтобы избежать ввода (медленного) механизма регулярных выражений для строк, которые точно не будут соответствовать. Если &lt;code&gt;isall&lt;/code&gt; флаг isall , вызова механизма регулярных выражений можно избежать, даже если оптимизатор нашел подходящее место для совпадения.</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">Опция не принимает аргумент и может быть отменена, поставив перед ней префикс &amp;laquo;no&amp;raquo; или &amp;laquo;no-&amp;raquo;. Например, &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; разрешит &lt;code&gt;--foo&lt;/code&gt; (будет присвоено значение 1), а также &lt;code&gt;--nofoo&lt;/code&gt; и &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (будет присвоено значение 0). Если у опции есть псевдонимы, это относится и к псевдонимам.</target>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">Параметр не принимает аргументов и будет увеличиваться на 1 каждый раз, когда появляется в командной строке. Например, &lt;code&gt;&quot;more+&quot;&lt;/code&gt; при использовании с &lt;code&gt;--more --more --more&lt;/code&gt; увеличит значение в три раза, в результате чего получится значение 3 (при условии, что сначала оно было 0 или не определено).</target>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">Имя опции,как указано в функции GetOptions(),вызывает опцию</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">Имена опций,определенные ниже,не чувствительны к регистру и могут быть опционально префиксованы с помощью '-'.Таким образом,все нижеследующее является действительным</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">Опция требует аргумента данного типа.Поддерживаемые типы:</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">Дополнительный</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">Необязательный атрибут &lt;code&gt;rules&lt;/code&gt; указывает направление, в котором тесты должны выполняться параллельно, а какие - последовательно. Если структура данных правила не указана, используется структура данных по умолчанию, которая позволяет запускать каждый тест параллельно:</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">Необязательные аргументы считаются буквальными строками, если они не начинаются с &lt;code&gt;~&lt;/code&gt; или &lt;code&gt;!&lt;/code&gt; , и в этом случае они интерпретируются как регулярные выражения (возможно, с отрицанием).</target>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">Перечисленные выше параметры настраивают части заголовка по умолчанию, но установка &lt;code&gt;html_header&lt;/code&gt; или &lt;code&gt;html_footer&lt;/code&gt; полностью переопределяет встроенный верхний или нижний колонтитул. Это может быть полезно, если вы хотите использовать теги шаблонов вместо буквальных верхних и нижних колонтитулов HTML или интегрируете преобразованные страницы POD в более крупный веб-сайт.</target>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">Опции этого аргумента представляют собой список каталогов, в которых выполняется рекурсивный поиск, или файлов. (Обычно вы не указываете файлы, а просто каталоги.) Или вы можете просто указать пустой список, как в $ name2path; с &lt;code&gt;inc&lt;/code&gt; опцией inc , как и по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Optree разделяется между потоками. Это означает, что существует вероятность того, что optree переживет конкретный поток (и, следовательно, экземпляр интерпретатора), который его создал, поэтому истинные скаляры Perl не могут быть сохранены в optree. Вместо этого используется компактная форма, в которой могут храниться только целые числа (со знаком и без знака), строки или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - ссылки и значения с плавающей запятой преобразуются в строки . Если вам нужно сохранить несколько значений или сложных структур, вы должны сериализовать их, например, с помощью &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; . Удаление хеш-ключа из &lt;code&gt;%^H&lt;/code&gt; записывается, и, как всегда, его можно отличить от существования ключа со значением &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">Порядок,в котором объекты уничтожаются во время глобального уничтожения перед выходом программы,непредсказуем.Это означает,что любые объекты,содержащиеся в вашем объекте,возможно,уже были уничтожены.Прежде чем вызывать метод на нем,необходимо проверить,определен ли содержащийся в нем объект:</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">Порядок,в котором этот тест проводился для данного результата тестового набора.</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">Порядок сортировки &lt;b&gt;символов&lt;/b&gt; . Это используется подпрограммами сравнения &lt;b&gt;строк&lt;/b&gt; , чтобы решить, например, где в этом глоссарии поместить &amp;laquo;последовательность сортировки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">Порядок аргументов отличается от порядка,используемого функцией open2().</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">Порядок аргументов отличается от порядка,используемого функцией open3().</target>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">Порядок следования тот же,что и для регулярного выражения,которое является результатом EXPR,или шаблона,содержащегося в группе захвата</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">Оригинальный интерфейс &lt;code&gt;MD5&lt;/code&gt; был написан Нилом Винтоном ( &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">Оригинальная бумага Дилана</target>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">Исходный Pod :: Text содержал код для форматирования с помощью последовательностей termcap, хотя он не был включен по умолчанию, и заставить его вообще работать было проблематично. Эта перезапись даже не пытается это сделать, но ее подкласс делает. Найдите &lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">Исходная спецификация UTF-8 позволяла использовать до 6 байтов, чтобы разрешить кодирование чисел до &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl по-прежнему позволяет это делать и расширил это количество до 13 байтов для кодирования кодовых точек до того, что может поместиться в 64-битное слово. Однако Perl выдаст предупреждение, если вы выведете какой-либо из них как непереносимый; и в соответствии со строгими протоколами ввода UTF-8 они запрещены.</target>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">Оригинальная культура доопулистского Интернета и глубоко укоренившиеся убеждения автора Perl Ларри Уолла породили политику свободного и открытого распространения Perl.Perl поддерживается его пользователями.Ядро,стандартная библиотека Perl,дополнительные модули и документация,которую вы сейчас читаете,были написаны волонтерами.</target>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">Исходная форма &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt; , которая передает ему флаг &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">Исходным форматом мета-файлов CPAN был &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML,&lt;/a&gt; а соответствующий файл назывался</target>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">Первоначальной целью исходных фильтров было дать вам возможность зашифровать исходный текст программы для предотвращения случайного пиратства.Это не все,что они могут сделать,как вы скоро узнаете.Но сначала,основы.</target>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">Исходная метка стека для XSUB. См. &lt;code&gt;dORIGMARK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">В исходном стиле в именах блоков (кроме &lt;code&gt;No_Block&lt;/code&gt; ) используются пробелы и дефисы , например:</target>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">Первоначальное название было</target>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">Первоначальная версия B :: Terse была написана Малкольмом Битти, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. Эту оболочку написал Стивен МакКамант, &amp;lt;smcc@MIT.EDU&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">Оригинальная версия PA-RISC,HP больше не продает системы с этим чипом.</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">Оригинальная версия этой статьи первоначально появилась в журнале Perl Journal #10,и на нее распространяется авторское право 1998 The Perl Journal.Она появилась благодаря Джону Оруанту и &quot;Журналу Perl&quot;.Этот документ может распространяться на тех же условиях,что и сам Perl.</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">Оригинал был написан Энди Доэрти...</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">Другие константы &lt;code&gt;OA_*&lt;/code&gt; использовать не следует.</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">Другой &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; предназначены методы , которые будут вызываться только один раз за &lt;code&gt;$parser&lt;/code&gt; объекта; но &lt;code&gt;parse_lines&lt;/code&gt; можно вызывать столько раз для объекта &lt;code&gt;$parser&lt;/code&gt; сколько вы хотите, до тех пор, пока последний вызов (и только последний вызов) заканчивается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">Другие аргументы должны показаться вам знакомыми, если вы знаете &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">Другая большая проблема с &lt;code&gt;$^W&lt;/code&gt; - это то, как вы можете случайно изменить настройку предупреждения в неожиданных местах вашего кода. Например, при запуске приведенного ниже кода (без флага &lt;b&gt;-w&lt;/b&gt; ) второй вызов &lt;code&gt;doit&lt;/code&gt; вызовет предупреждение &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; , а первый - нет.</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">В других случаях требуются более сложные процедуры. Ниже я предполагаю, что текущая версия Perl - &lt;code&gt;5.8.2&lt;/code&gt; , поэтому исполняемые файлы названы соответственно.</target>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">Другой аналог в столбце &amp;laquo;Full-range Unicode&amp;raquo; соответствует любым подходящим символам в полном наборе символов Unicode. Например, &lt;code&gt;\p{Alpha}&lt;/code&gt; соответствует не только алфавитным символам ASCII, но и любому символу во всем наборе символов Unicode, который считается алфавитным. Запись в столбце &amp;laquo;последовательность обратного слэша&amp;raquo; является (коротким) эквивалентом.</target>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">Другим хаком является восстановление FP-флагов после вызова dlopen().Это помогает против подобных повреждений,наносимых DLLs _DLLInitTerm()во время выполнения.В настоящее время нет возможности отключить эти взломы.</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">Другое-установка модуля во временное место.</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">Другое изменение заключается в том,что</target>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">Другая причина, по которой использование переменной для хранения имени другой переменной является плохой идеей, заключается в том, что вопрос часто возникает из-за недостаточного понимания структур данных Perl, особенно хешей. Используя символические ссылки, вы просто используете хэш таблицы символов пакета (например, &lt;code&gt;%main::&lt;/code&gt; вместо пользовательского хеша. Решение состоит в том, чтобы вместо этого использовать свой собственный хеш или реальную ссылку.</target>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">На другую структуру указывает &lt;code&gt;pprivate&lt;/code&gt; структуры &lt;code&gt;regexp&lt;/code&gt; и она является дополнением к &lt;code&gt;intflags&lt;/code&gt; в той же структуре, которая считается свойством механизма регулярных выражений, который скомпилировал регулярное выражение;</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">Другие примитивы синхронизации,описанные ниже,могут страдать аналогичными проблемами.</target>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Разделитель поля вывода для оператора печати. Если определено, это значение печатается между каждым из аргументов print. По умолчанию &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">Выходной файл для печати. Если используются специальные имена &amp;laquo;-&amp;raquo; или &amp;laquo;&amp;gt; &amp;amp; 1&amp;raquo; или &amp;laquo;&amp;gt; &amp;amp; STDOUT&amp;raquo;, то используется стандартный вывод. Если используется &quot;&amp;gt; &amp;amp; 2&quot; или &quot;&amp;gt; &amp;amp; STDERR&quot;, используется стандартная ошибка.</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">Выходные файлы помещаются в иерархию, основанную на директории библиотеки Perl, зависящей от архитектуры. Вы можете указать другую иерархию с помощью ключа &lt;b&gt;-d&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">Формат вывода регулируется несколькими параметрами, описанными в разделе &amp;laquo; &lt;a href=&quot;#Configurable-Options&quot;&gt;Настраиваемые параметры&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">Формат вывода &lt;a href=&quot;functions/write&quot;&gt;записи&lt;/a&gt; определяется более ранним объявлением формата ( &lt;a href=&quot;functions/format&quot;&gt;форматом&lt;/a&gt; ), поэтому то, зависит ли вывод от языкового стандарта, определяется тем, находится ли &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; в пределах области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , а не от того, находится ли &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; является.</target>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">Вывод из XSUB,который использует что-то вроде карты T_PTREF,которая не благословляет объект,может выглядеть что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">Выход из этого будет</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">Выход не используется.Если ты не знаешь,что такое пятно,не волнуйся об этом.</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">Строку вывода можно использовать как шаблон в вызове &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">Вывод &lt;code&gt;uname -a&lt;/code&gt; , если доступен, иначе имя хоста. Затем все это делается в нижнем регистре, а косая черта и одинарные кавычки удаляются.</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Разделитель выходной записи для оператора печати. Если определено, это значение печатается после последнего аргумента print. По умолчанию &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">На выходе показаны все группы.Самые крайние совпадения показываются первыми,а вложенные-позже:</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">Вывод показывает,что Перл нашел две основные группы:</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">Выходные данные показывают, что в блоке &lt;code&gt;OUTER&lt;/code&gt; значения &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;$2&lt;/code&gt; взяты из совпадения с &lt;code&gt;$outer&lt;/code&gt; . Внутри блока &lt;code&gt;INNER&lt;/code&gt; значения &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;$2&lt;/code&gt; взяты из совпадения с &lt;code&gt;$inner&lt;/code&gt; , но только до конца блока (то есть динамической области). После завершения блока &lt;code&gt;INNER&lt;/code&gt; значения &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;$2&lt;/code&gt; возвращаются к значениям для сопоставления с &lt;code&gt;$outer&lt;/code&gt; даже если мы не сделали другого сопоставления:</target>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">Выходные данные показывают, что подпрограмма constant (), которую мы тестируем, заменяется значением константы &lt;code&gt;DEBUG&lt;/code&gt; : ноль. Тестируемая линия была полностью оптимизирована, и вы не можете добиться гораздо большей эффективности, чем это.</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">Выходная строка будет возвращена.</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">Выходные строки для &lt;b&gt;Tputs&lt;/b&gt; кэшируются на &lt;b&gt;счетчик&lt;/b&gt; 1 для производительности. &lt;b&gt;Tgoto&lt;/b&gt; и &lt;b&gt;Tpad&lt;/b&gt; не &lt;b&gt;кешируют&lt;/b&gt; . &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; - это необработанные данные termcap, а &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; - это кэшированная версия.</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">Выходное значение со знаком должно быть либо положительным значением в диапазоне 1,2,...,OBJ2-1,либо таким же значением,вычитаемым OBJ2.Например,если входными аргументами являются объекты,представляющие числа 7 и 5,то метод должен либо возвращать объект,представляющий число 3 и знак &quot;+&quot;,так как (3*7)% 5=1 % 5,либо объект,представляющий число 2 и знак &quot;-&quot;,так как (-2*7)% 5=1 % 5.</target>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">Вывод,который вы получите при выполнении скрипта:</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">В целом, или стандартная дата, время между тем, когда &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; называли, и когда она заканчивается. Истекшее время включает время пользователя и системы, а также время, потраченное на ожидание других пользователей и процессов в системе. Неизбежно, что это наиболее приблизительный из приведенных измерений.</target>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">Символ pTHX_в определении-это макрос,используемый Perl в потоке для предоставления дополнительного аргумента рутине,удерживающей указатель обратно на интерпретатор,выполняющий регенерацию.Таким образом,при многопоточности все рутины получают дополнительный аргумент.</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">Код пакета &lt;code&gt;A*&lt;/code&gt; поглощает все оставшиеся байты, а &lt;code&gt;$prio&lt;/code&gt; остается неопределенным! Прежде чем мы позволим разочарованию подорвать боевой дух: у Perl есть козырь, чтобы сделать этот трюк, чуть дальше в рукаве. Смотри:</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">Код пакета &lt;code&gt;w&lt;/code&gt; был добавлен для поддержки переносимой схемы кодирования двоичных данных, которая выходит далеко за рамки простых целых чисел. (Подробности можно найти на &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt; , проекте Scarab.) Сжатое целое число без знака BER ( двоичное кодированное представление) хранит базовые 128 цифр, начиная с самой старшей цифры, с как можно меньшим количеством цифр. Бит восемь (старший бит) устанавливается на каждый байт, кроме последнего. Для кодирования BER нет ограничений по размеру, но Perl не будет впадать в крайности.</target>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">Код пакета для обратного порядка байтов (старший байт по младшему адресу) равен &lt;code&gt;n&lt;/code&gt; для 16-битных и &lt;code&gt;N&lt;/code&gt; для 32-битных целых чисел. Вы используете эти коды, если знаете, что ваши данные поступают из совместимой архитектуры, но, как ни удивительно, вы также должны использовать эти коды пакетов, если вы обмениваетесь двоичными данными по сети с какой-либо системой, о которой вы почти ничего не знаете. Простая причина в том, что этот порядок был выбран в качестве</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">Код пакета перед &lt;code&gt;/&lt;/code&gt; может быть любым, подходящим для представления числа: все числовые двоичные коды пакетов и даже текстовые коды, такие как &lt;code&gt;A4&lt;/code&gt; или &lt;code&gt;Z*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">Формат пакета &lt;code&gt;A&lt;/code&gt; означает &amp;laquo;любой символ&amp;raquo;; если вы собираете &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и у вас кончились вещи, которые нужно упаковать, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; заполнит остальное пространство.</target>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">Пакет содержит менеджер сеансов и менеджер кэша.Менеджер сеансов отслеживает,что было извлечено,собрано и установлено в текущем сеансе.Менеджер кэша отслеживает дисковое пространство,занятое процессами make,и удаляет лишнее пространство,используя простой механизм FIFO.</target>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">Аргументом имени пакета обычно является имя класса,в котором была объявлена подпрограмма,но это может быть и имя производного класса (так как обработчики наследуются).</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">В названии пакета используется префикс &lt;code&gt;DBM_Filter::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">Пакет, представляющий дистрибутив. Например, &lt;code&gt;Test::More&lt;/code&gt; или &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . Он будет использоваться для получения информации о дистрибутиве, такой как &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt; , места установки в библиотеке Perl и где файлы XS будут искать по умолчанию (см. &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">Пакет, в который помещается магический объект qr // (как видно из &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ). Рекомендуется, чтобы движки изменили это имя на свое имя пакета для идентификации независимо от того, реализуют ли они методы для объекта.</target>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">Пакет, возвращаемый этим методом, также должен иметь внутренний пакет &lt;code&gt;Regexp&lt;/code&gt; в своем &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; всегда должно быть истинным, независимо от того, какой движок используется.</target>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">Переменная пакета &lt;code&gt;@EXPORT&lt;/code&gt; будет определять, какие символы будут экспортированы, когда вызывающий просто скажет &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - вы вряд ли когда-нибудь захотите что-нибудь туда помещать. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , с другой стороны, указывает, какие символы вы хотите экспортировать. Если вы действительно хотите экспортировать набор символов, используйте &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; и определите стандартный набор для экспорта - более подробную информацию см. В &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">Пакеты,относящиеся к различным реализациям,связанным с РБМ (</target>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">Имена колодок в PADNAMELIST имеют свой PV,удерживающий имя переменной.Поля COP_SEQ_RANGE_LOW и _HIGH образуют диапазон (low+1...high inclusive)номеров cop_seq,для которых имя является действительным.При компиляции эти поля могут содержать специальное значение PERL_PADSEQ_INTRO для обозначения различных этапов:</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">Мягкая шнурка возвращена.</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">Документ &quot;Как сломать MD5 и другие хэш-функции&quot; Xiaoyun Wang и Hongbo Yu.</target>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">Абзацы, которые вы передаете &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap,&lt;/a&gt; не должны содержать встроенных символов новой строки. &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; не выравнивает строки (выравнивание вправо).</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">Параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; используется для управления местом назначения сжатых данных. Этот параметр может принимать одну из следующих форм.</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">Параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; используется для управления местом назначения несжатых данных. Этот параметр может принимать одну из следующих форм.</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">Параметр &lt;code&gt;$text&lt;/code&gt; - это строка или блок текста, который нужно проанализировать на предмет внутренних последовательностей; а параметр &lt;code&gt;$line_num&lt;/code&gt; - это номер строки, соответствующий началу &lt;code&gt;$text&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">Параметр &lt;code&gt;extra_libs&lt;/code&gt; можно использовать для указания &lt;b&gt;дополнительных&lt;/b&gt; путей для поиска установленных модулей. Например</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">Параметр &lt;code&gt;type&lt;/code&gt; представляет собой перечисление , который определяет , какой из 3 -х методов интерфейса (DB_HASH, DB_BTREE или DB_RECNO) должен быть использован. В зависимости от того, какой из них фактически выбран, последний параметр,</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">Список параметров my()при желании может быть присвоен,что позволяет инициализировать переменные.(Если для конкретной переменной не задан инициализатор,она создается с неопределенным значением).Обычно это используется для именования входных параметров в подпрограмме.Примеры:</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">Значение параметра по умолчанию все равно будет вычислено,если соответствующий аргумент не указан,даже если значение нигде не будет храниться.Это в том случае,если оценка имеет важные побочные эффекты.Однако,оно будет вычисляться в контексте void,поэтому,если оно не имеет побочных эффектов и не является тривиальным,оно будет выдавать предупреждение,если включена категория предупреждения &quot;void&quot;.Если значение по умолчанию безымянного опционального параметра не важно,то оно может быть опущено точно так же,как и имя параметра:</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">Параметр &lt;code&gt;$input_filename_or_reference&lt;/code&gt; используется для определения источника сжатых данных.</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">Параметр &lt;code&gt;$input_filename_or_reference&lt;/code&gt; используется для определения источника несжатых данных.</target>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">Параметры,которые он принимает,таковы:</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">Параметры для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; добавляются в начало пути поиска perl. Говоря</target>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">Скобки о &lt;code&gt;XSLoader::load()&lt;/code&gt; аргументы необходимы , так как мы заменили &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; по &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , чтобы компилятор не знает , что функция &lt;code&gt;XSLoader::load()&lt;/code&gt; присутствует.</target>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">Анализ выполняется почти так же, как и на этапе построения, за исключением того, что большинство подпрограмм замыкаются, чтобы изменить поле размера &lt;code&gt;RExC_size&lt;/code&gt; и больше ничего не делать.</target>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">Синтаксическому анализатору благородно помогает лексер, который разбивает ваш ввод на токены и решает, какого типа является каждый токен: имя переменной, оператор, простое слово, подпрограмма, базовая функция и т. Д. Основной точкой входа в лексер является &lt;code&gt;yylex&lt;/code&gt; , и его и связанные с ним процедуры можно найти в</target>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">Затем синтаксический анализатор видит следующий код:</target>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">Часть адреса TCP или UDP-разъема,которая направляет пакеты в правильный процесс после нахождения нужной машины,что-то вроде расширения телефона,которое вы даете,когда вы достигаете оператора компании.Также результат преобразования кода для запуска на другой платформе,чем изначально предполагалось,или глагол,обозначающий это преобразование.</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">Конкретная копия Perl, которую вы пытаетесь использовать, не поддерживает указанный сигнал, используемый в вызове &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">Конкретная копия Perl, которую вы пытаетесь использовать, не была создана с использованием &lt;code&gt;useithreads&lt;/code&gt; конфигурации useithreads .</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">Конкретный макрос, который вы должны использовать, зависит от того, какую &lt;code&gt;sv_set*v&lt;/code&gt; вы вызвали первой. Это связано с тем, что каждая процедура &lt;code&gt;sv_set*v&lt;/code&gt; включает только бит для определенного типа устанавливаемых данных и отключает все остальные.</target>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#prop_aliases()&quot;&gt;Передаваемое&lt;/a&gt; свойство может быть указано как любой из синонимов, возвращаемых функцией prop_aliases () .</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">Уровень патча в данном пакете.Значение патч-уровня происходит от</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Путь, по &lt;code&gt;@INC&lt;/code&gt; Perl проходит через @INC . По умолчанию это поиск с двойной глубиной поиска, один раз ищет определенные методы, а &lt;code&gt;AUTOLOAD&lt;/code&gt; . Однако Perl позволяет вам настроить это с помощью &lt;code&gt;mro&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">Путь из УРИ,будет как минимум одним '/'.</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">Путь к файлу, из которого история (при условии, что используется бэкэнд Term :: ReadLine) будет считана при запуске отладчика и в который она будет сохранена при завершении работы (для сохранения между сеансами). По концепции &lt;code&gt;.bash_history&lt;/code&gt; файл .bash_history в Bash .</target>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">Путь к файлу автоматически преобразуется в Unix-подобный эквивалент для использования в архиве, и, если в MacOS, время модификации файла конвертируется из эпохи MacOS в эпоху Unix. Таким образом, tar-архивы, созданные в MacOS с помощью &lt;b&gt;Archive :: Tar,&lt;/b&gt; можно читать как с помощью</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">Имя POD-файла для проверки синтаксиса (по умолчанию-стандартный вход).</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">Имя файла,содержащего документацию по подставке,для вывода в формате сообщения об использовании (по умолчанию-стандартный ввод).</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">Имя файла,из которого следует выбирать разделы документации по pod (по умолчанию-стандартный вход).</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">Шаблон начинается с класса, соответствующего подмножеству букв. Когда это совпадает, выражение типа &lt;code&gt;$count{'a'}++;&lt;/code&gt; выполняется, увеличивая счетчик букв. Затем &lt;code&gt;(*FAIL)&lt;/code&gt; выполняет то, что он говорит, и механизм регулярного выражения действует в соответствии с книгой: до тех пор, пока конец строки не достигнут, позиция продвигается вперед перед поиском другой гласной. Таким образом, совпадение или отсутствие совпадения не имеет значения, и механизм регулярных выражений продолжает работу до тех пор, пока не будет проверена вся строка. (Примечательно, что альтернативное решение, использующее что-то вроде</target>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">Сопоставление с образцом выполнено успешно, и определен &lt;code&gt;$1&lt;/code&gt; , хотя он не соответствует &quot;ничего&quot;. Это действительно ни с чем не подводило. Скорее, он соответствовал чему-то, длина которого оказалась нулевой. Все это очень откровенно и честно. Когда функция возвращает неопределенное значение, это признание того, что она не может дать вам честный ответ. Поэтому вы должны использовать &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; только тогда, когда сомневаетесь в целостности того, что вы пытаетесь сделать. В других случаях вам нужно простое сравнение с &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">Сопоставление с образцом выполнено успешно, и определен &lt;code&gt;$1&lt;/code&gt; , хотя он не соответствует &quot;ничего&quot;. Это действительно ни с чем не подводило. Скорее, он соответствовал чему-то, длина которого оказалась нулевой. Все это очень откровенно и честно. Когда функция возвращает неопределенное значение, это признание того, что она не может дать вам честный ответ. Поэтому вы должны использовать &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; только тогда, когда сомневаетесь в целостности того, что вы пытаетесь сделать. В других случаях вам нужно простое сравнение с &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">В шаблоне,совпадающем с мета-символами &quot;(&quot;,&quot;)&quot; и &quot;|&quot;,нет обратных слэшей впереди.</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">Операции сопоставления с образцом &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (также известные как &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ) при использовании без оператора &lt;code&gt;=~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">Модификаторы шаблонов:</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">Шаблон макро-вызовов такой:</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">Правда,шаблон,</target>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Шаблоны, используемые при сопоставлении шаблонов Perl, эволюционировали от шаблонов, поставляемых в подпрограммах регулярных выражений Версии 8. (Подпрограммы являются производными (удаленно) от свободно распространяемой повторной реализации подпрограмм V8 Генри Спенсера.) См. Подробности в &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Регулярных выражениях Версии 8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">Оптимизатор глазка никогда не следует заменять полностью. Скорее добавьте к нему код, обернув существующий оптимизатор. Основной способ сделать это можно увидеть &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;на этапе компиляции 3: оптимизация глазка в perlguts&lt;/a&gt; . Если новый код желает работать с операциями по всей структуре подпрограммы, а не только на верхнем уровне, вероятно, будет удобнее обернуть &lt;a href=&quot;#PL_rpeepp&quot;&gt;ловушку PL_rpeepp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">Оптимизатор глазка никогда не следует заменять полностью. Скорее добавьте к нему код, обернув существующий оптимизатор. Основной способ сделать это можно увидеть &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;на этапе компиляции 3: оптимизация глазка в perlguts&lt;/a&gt; . Если новый код желает работать только с операциями на верхнем уровне подпрограммы, а не по всей структуре, вероятно, будет удобнее обернуть &lt;a href=&quot;#PL_peepp&quot;&gt;ловушку PL_peepp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">Данные по каждому экземпляру хранятся в памяти за пределами базовой PerlIOl-структуры,делая таким образом PerlIOl первым членом структуры слоя:</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">Данные по каждому экземпляру для конкретной рукоятки.</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">Накладные расходы на каждую запись ограничат максимальное количество записей,к которым вы можете получить доступ в каждом файле.Обратите внимание,что</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">Период &quot;...&quot; совпадает с любым символом,кроме &quot;\n&quot;.</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">Период '.' соответствует любому символу, кроме &quot;\ n&quot; (если не действует модификатор &lt;code&gt;//s&lt;/code&gt; , как описано ниже).</target>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">Perl код в PerlIO.pm затем пытается найти слой,делая следующее</target>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">Ядро perl обертывает &lt;code&gt;setjmp()&lt;/code&gt; т. Д. В макросах &lt;code&gt;JMPENV_PUSH&lt;/code&gt; и &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . Основное правило исключений perl заключается в том , что &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (в отсутствие &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ) выполняют &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , а &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; внутри &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; выполняет &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">Исполняемый файл perl получается путем связывания</target>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">Сообщение Perl выходит с &amp;laquo;Perl&amp;raquo; впереди. Блок &lt;code&gt;BEGIN&lt;/code&gt; работает во время компиляции, поэтому все ошибки и предупреждения компиляции также получают префикс Perl :.</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">Перл-источник находится в git-репозитории.Вы можете клонировать репозиторий следующей командой:</target>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">Функция perl tie связывает переменную с объектом, который реализует различные методы GET, SET и т. Д. Чтобы выполнить эквивалент функции perl tie из XSUB, вы должны имитировать это поведение. Приведенный ниже код выполняет необходимые шаги - сначала он создает новый хеш, а затем создает второй хеш, который он добавляет в класс, который будет реализовывать методы привязки. Наконец, он связывает два хеша вместе и возвращает ссылку на новый связанный хеш. Обратите внимание, что приведенный ниже код НЕ вызывает метод TIEHASH в классе MyTie - см. &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Вызов&lt;/a&gt; подпрограмм Perl из программ на языке C, чтобы узнать, как это сделать.</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">Видимое на Perl имя созданной подпрограммы XS, которая будет возвращать константы. По умолчанию - &lt;code&gt;constant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">Список perl-mvs@perl.org предназначен для обсуждения вопросов переноса,а также вопросов общего использования для всех Perls EBCDIC.Отправьте тело сообщения &quot;subscribe perl-mvs&quot; на majordomo@perl.org.</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">Список рассылки perl5-changes получает копию каждого патча, который отправляется в ветви обслуживания и разработки репозитория perl. См. &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;Http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; для получения информации о подписке и архиве.</target>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">Список рассылки perl5-портеров (p5p)-это то место,где поддерживается и развивается стандартная рассылка Perl.Людей,которые поддерживают Perl,также называют &quot;Perl 5 Porters&quot;,&quot;p5p&quot; или просто &quot;porters&quot;.</target>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">Программа perlbug задаст вам несколько вопросов о вашем электронном адресе и заплатке,которую вы отправляете.После того,как вы ответите на них,программа отправит патч по электронной почте.</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">В perldoc for utime также есть пример,который имеет тот же эффект,что и touch(1)на файлы,которые</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">Perlfaq включает в себя несколько документов,которые отвечают на наиболее часто задаваемые вопросы о программировании на Perl и Perl.Он разделен по темам на девять основных разделов,описанных в этом документе.</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">Perlfaq - это постоянно развивающийся документ. Последнюю версию читайте на &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; . Он также включен в стандартный дистрибутив Perl.</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">Спецификация perlpod для Verbatim абзаца гласит:&quot;Она должна быть воспроизведена точно...&quot;,что означает,что пробельные символы,которые вы использовали для отступов от ваших дословных блоков,будут сохранены в выводе.Это может быть раздражающе для таких выходов,как HTML,где этот пробел будет оставаться перед каждой строкой.Это прискорбный случай,когда синтаксис превращается в семантику.</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">В руководстве по Perl,которое поставляется вместе с Perl,есть много полезных советов.</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">Человек, которому &lt;b&gt;операционная система&lt;/b&gt; позволяет делать практически все. Обычно это ваш системный администратор или кто-то, выдающий себя за вашего системного администратора. В системах Unix пользователь &lt;b&gt;root&lt;/b&gt; . В системах Windows обычно используется администратор.</target>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">Модель трубопровода делит задачу на ряд шагов,и результаты одного шага передаются на обработку потока за другим.Каждый поток выполняет одну вещь с каждой единицей данных и передает результаты в следующий поток по очереди.</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">Утилита pl2pm запустит вас.</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">План (например,'1..5')должен начинаться или заканчиваться только в начале или в конце TAP-выхода.</target>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">Смысл функции состоит в том, чтобы &amp;laquo;засеять&amp;raquo; функцию &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; , чтобы функция &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; могла генерировать другую последовательность каждый раз, когда вы запускаете свою программу. При вызове с параметром &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; использует его для начального числа; в противном случае он (полу) случайным образом выбирает семя. В любом случае, начиная с Perl 5.14, он возвращает начальное значение. Чтобы сигнализировать, что ваш код будет работать</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">Смысл функции состоит в том, чтобы &amp;laquo;засеять&amp;raquo; функцию &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; , чтобы функция &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; могла генерировать другую последовательность каждый раз, когда вы запускаете свою программу. При вызове с параметром &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; использует его для начального числа; в противном случае он (полу) случайным образом выбирает семя. В любом случае, начиная с Perl 5.14, он возвращает начальное значение. Чтобы сигнализировать, что ваш код будет работать</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">Указатель благословляется в класс,который является производным от имени типа указателя,но при этом все '*' в имени заменяется на 'Ptr'.</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;dsv&lt;/code&gt; указатель на PV dsv .</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">Следует отметить следующее</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">Полярная нотация (также известная как тригонометрическое представление)намного удобнее для выполнения умножений и делений комплексных чисел,в то время как картезианная нотация лучше подходит для сложений и вычитаний.Реальные числа находятся на</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">Полярный стиль пытается подчеркнуть такие аргументы,как</target>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">В качестве справочного порта использовался порт для Win32.</target>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">Порт Perl на Mac OS был официально удален с версии Perl 5.12,хотя последний официальный производственный релиз MacPerl соответствовал версии Perl 5.6.В то время как Perl 5.10 включал в себя порт на Mac OS,ExtUtils::MakeMaker,основная часть инфраструктуры Perl по установке модулей,официально отказалась от поддержки Mac OS в апреле 2004 года.</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">Портье ценят время,которое вы потратили на то,чтобы сделать Перла лучше.Спасибо!</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">Часть расширения, предоставляемая кодом XS, может быть связана с остальной частью Perl любым из двух способов. В &lt;b&gt;статической&lt;/b&gt; конфигурации объектный код расширения напрямую связан с</target>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">Позиция в файле FILEHANDLE остается неизменной. Вы можете вызвать &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;функцию seek&lt;/a&gt; перед записью в файл.</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">Притягательные формы (новые в Perl 5.10)предотвращают обратное движение:то,что совпадает с паттерном с притягательным квантификатором,не будет возвращено в обратное движение,даже если это приводит к неудаче всего совпадения.</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">Возможные категории: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , а категория псевдо &lt;code&gt;:characters&lt;/code&gt; (описанные ниже).</target>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">Возможные значения и биты флагов параметра MODE зависят от системы; они доступны через стандартный модуль &lt;code&gt;Fcntl&lt;/code&gt; . См. Документацию по вашей операционной системе</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">Возможно предполагаемый текст ссылки; то есть, если не было реального текста ссылки, то это текст, который мы выведем вместо него. (Например, для &amp;laquo;L &amp;lt;Getopt :: Std&amp;gt;&amp;raquo; предполагаемый текст ссылки будет &amp;laquo;Getopt :: Std&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">Практика говорить: &amp;laquo;Если бы мне пришлось делать это все заново, я бы сделал это по-другому&amp;raquo;, а затем фактически возвращался и делал все по-другому. С математической точки зрения, это возвращение после неудачной рекурсии на дереве возможностей. Perl откатывает назад, когда пытается сопоставить шаблоны с &lt;b&gt;регулярным выражением&lt;/b&gt; , и его предыдущие попытки не увенчались успехом. См. Раздел &amp;laquo;Маленький паровозик, который / не может (не)&amp;raquo; в главе 5 Camel &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">Практика сдвига алфавита одним или несколькими символами для шифрования насчитывает тысячи лет и была подробно описана Гаем Юлием Цезарем в его тексте &lt;b&gt;Галльских войн&lt;/b&gt; . Один сдвиг в алфавитном порядке иногда называют вращением, и величина сдвига указывается в виде числа $ n после строки &quot;rot&quot; или &quot;rot $ n&quot;. Rot0 и rot26 обозначают идентификационные карты на английской версии латинского алфавита из 26 букв. Rot13 обладает тем интересным свойством, что чередующиеся последующие вызовы являются тождественными отображениями (таким образом, rot13 является собственным нетривиальным обратным в группе из 26 поворотов алфавита). Следовательно, следующий кодировщик и декодер rot13 будет работать на платформах ASCII и EBCDIC:</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">Прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; составляет &lt;code&gt;$?&lt;/code&gt; отражать фактический статус выхода VMS вместо эмуляции по умолчанию статуса POSIX, описанной выше. Эта прагма также отключает преобразование ненулевых значений в SS $ _ABORT при установке &lt;code&gt;$?&lt;/code&gt; в блоке END (но ноль все равно будет преобразован в SS $ _NORMAL).</target>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">Прагма была для каждого скрипта, а не для каждого блока лексической. Имеет значение только последняя &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; , и это влияет &lt;b&gt;на весь сценарий&lt;/b&gt; . Тем &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; менее, прагма no encoding поддерживалась, и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; могло появляться столько раз, сколько вы хотите в данном сценарии (хотя только последний был эффективным).</target>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">Псевдокомментарии &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;BIGINT&lt;/a&gt; и &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; также могут быть интересны тем , что они решают autoupgrading / Откат вопрос, по крайней мере , частично.</target>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">Преамбула,добавляемая к каждому выходному файлу,довольно многословна,и большая ее часть необходима только при наличии не-ASCII символов.В идеале было бы неплохо,если бы все эти определения выводились только при необходимости,возможно,на лету,так как используются символы.</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">Код преамбулы класса выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">Предпочтение обработчика &lt;b&gt;регулярных выражений&lt;/b&gt; совпадать с крайним левым вхождением &lt;b&gt;шаблона с&lt;/b&gt; учетом позиции, в которой будет происходить совпадение, предпочтение самого длинного совпадения (при условии использования &lt;b&gt;жадного&lt;/b&gt; квантификатора). См. Главу 5 &amp;laquo;Верблюд&amp;raquo; &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">Предпочтительный способ сделать это - объявить план при &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">Префикс, указанный в &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; будет использоваться с числовым суффиксом, если имя для значения не определено.</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">Наличие слова &quot;FATAL&quot; в списке категорий приведет к тому,что предупреждения в этих категориях превратятся в фатальные ошибки в этом лексическом диапазоне.</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">Предыдущие задания в точности эквивалентны</target>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">Предыдущий пример не был особенно полезен.Чтобы сделать его более общим,мы будем использовать контекстные данные и позволим произвольные</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">Предыдущий абзац дословно применим к привязанному хеш-доступу с использованием &lt;code&gt;hv_store&lt;/code&gt; и &lt;code&gt;hv_store_ent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">Предыдущий раздел (введенный командой a &lt;code&gt;=head&lt;/code&gt; ) не содержит текста. Обычно это указывает на то, что чего-то не хватает. Примечание: A &lt;code&gt;=head1&lt;/code&gt; , за которым сразу следует &lt;code&gt;=head2&lt;/code&gt; , не вызывает это предупреждение.</target>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">Предыдущий созданный шаг</target>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">Основная причина сообщения &amp;laquo;dlopen: stub interception failed&amp;raquo; заключается в том, что переменная среды LD_LIBRARY_PATH включает каталог, который является символической ссылкой на / usr / lib (например, / lib). См. &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; выше.</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">Основная цель этого модуля - предоставить доступ для потоковой записи к zip-файлам и буферам. Это не универсальный файловый архиватор. Если это то, что вам нужно, посмотрите &lt;code&gt;Archive::Zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">Основной сайт для gzip является</target>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">Основной сайт для</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">Основным сайтом для программы bzip2 является</target>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">Основное значение касательной дуги y/x</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">Принцип заключается в том, что количество найденных объектов влияет на то, как объект отображается. Если поиск находит один элемент, результат отображается с помощью довольно подробного метода &lt;code&gt;as_string&lt;/code&gt; , но если найдено более одного объекта, каждый объект отображается с помощью &lt;code&gt;as_glimpse&lt;/code&gt; метода as_glimpse .</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">Оператор print () не добавляет разделители полей и записей, если вы не установили &lt;code&gt;$,&lt;/code&gt; и &lt;code&gt;$\&lt;/code&gt; . Вы можете установить $ OFS и $ ORS, если используете английский модуль.</target>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">Кэш частных данных будет владеть ссылкой на private_sv, почти так же, как &lt;code&gt;hv_store()&lt;/code&gt; получает право владения ссылкой на значение, которое вы ему передаете.</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">Хеш-ключи закрытого объекта, такие как &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; не могут быть изменены, но могут быть добавлены дополнительные ключи, такие как &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">Частная переменная используется для сохранения текущего состояния локали, так что требуемый соответствующий вызов &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; может восстановить его.</target>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">Проблема может быть дополнительно рассмотрена в примерно эквивалентной программе на языке С:</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">Проблема возникает, когда вы берете свои числа из чего-то, что Perl считает строкой, например, аргумента командной строки в &lt;code&gt;@ARGV&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">Проблема возникает,когда,например,у вас есть строка,которая не помечена как UTF-8,и содержит последовательность байтов,которая может быть UTF-8-особенно при объединении строк без UTF-8 и UTF-8.</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">Проблема существует потому, что анонимная подпрограмма, назначенная &lt;code&gt;__ANON__&lt;/code&gt; &lt;code&gt;*Foo::foo&lt;/code&gt; будет отображаться в стеке вызовов как вызываемая __ANON__, а не &lt;code&gt;foo&lt;/code&gt; , как вы могли ожидать. Поскольку &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; использует &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; для поиска имени метода, в котором он был вызван, в этом случае он завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">Проблема здесь в том, что Uid_t может быть не только не &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; -wide, но и беззнаковым, и в этом случае большие uid будут печататься как отрицательные значения.</target>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">Проблема здесь в том, что и группа с именем &lt;code&gt;a&lt;/code&gt; , и группа с именем &lt;code&gt;b&lt;/code&gt; являются псевдонимами для группы, принадлежащей к &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">Проблема в том,что Perl имеет предупреждения как о времени компиляции,так и о времени выполнения.Чтобы отключить предупреждения во время компиляции,необходимо переписать код таким образом:</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">Проблема в том, что и &lt;code&gt;rp&lt;/code&gt; , и &lt;code&gt;dp&lt;/code&gt; являются указателями на одно и то же место в памяти! В C вам нужно не забыть выполнить malloc () себе новую память. В Perl вместо этого вы захотите использовать конструктор массива &lt;code&gt;[]&lt;/code&gt; или конструктор хеша &lt;code&gt;{}&lt;/code&gt; . Вот правильный способ сделать предыдущие фрагменты сломанного кода:</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">Проблема в том,что grep строит список возврата независимо от контекста.Это означает,что вы заставляете Perl пойти на проблему построения списка,который вы просто выбрасываете.Если список большой,вы тратите и время,и место.Если вы хотите провести итерацию по списку,то используйте для этого цикл.</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">Проблема в том,что ни один из этих примеров не является надежным:они зависят от командного интерпретатора.В Unix первые два часто работают.В DOS вполне возможно,что ни один из них не работает.Если бы 4DOS была командной оболочкой,вам,вероятно,повезло бы так:</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">Проблема в том,что все это не является надежным:это зависит от команды,и вполне возможно,что ни то,ни другое не работает.Если</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">Проблема в том, что этот код всегда будет анализироваться и выполняться, даже если уровень отладки, установленный в файле конфигурации ведения журнала, равен нулю. Как только подпрограмма debug () была введена и внутренняя переменная &lt;code&gt;$debug&lt;/code&gt; , например, была подтверждена равной нулю, отправленное сообщение будет отброшено, и программа продолжит работу. Однако в приведенном примере хэш &lt;code&gt;\%INC&lt;/code&gt; уже был сброшен, а строка сообщения построена, и всю эту работу можно обойти с помощью переменной отладки на уровне оператора, например:</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">Проблема в том,что этот код</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">Проблема в том,что эти двойные кавычки форсируют строковуюфикацию-когерсирование чисел и ссылок в строки-даже если вы не хотите,чтобы они были строками.Подумайте об этом так:расширение в двойных кавычках используется для создания новых строк.Если у вас уже есть строка,зачем вам нужно больше?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">Проблема в том,что различные структуры,видимые через procfs,используют off_t,и если вы компилируете с поддержкой больших файлов,то это изменение от 32 бит до 64 бит.Таким образом,то,что вы получаете от procfs,не совпадает со структурами на perl,что приводит к мусору.Обратитесь к proc(4)для дальнейшего обсуждения.</target>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">Проблема заключается во вложенных неопределенных квантификаторах. Есть много разных способов разбить строку длины n между &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; : одно повторение с &lt;code&gt;b+&lt;/code&gt; длины n, два повторения с первым &lt;code&gt;b+&lt;/code&gt; длиной k и второе с длиной nk, m повторений, биты которых в сумме составляют длину n и т.д. На самом деле существует экспоненциальное количество способов разбить строку в зависимости от ее длины. Регулярному выражению может повезти, и оно может совпадать на ранней стадии процесса, но если совпадений нет, Perl попытается</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">Проблема обычно заключается в том,что командные интерпретаторы на этих системах имеют довольно разные представления о цитировании,нежели Unix-оболочки,под которыми создавались однослойные оболочки.На некоторых системах может потребоваться изменить одинарные кавычки на двойные,которые должны</target>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">Проблема в том, что буферизация действительно испортит вам день. Несмотря на то, что ваш дескриптор файла &lt;code&gt;Writer&lt;/code&gt; автоматически очищается, поэтому процесс на другом конце своевременно получает ваши данные, вы обычно не можете ничего сделать, чтобы заставить этот процесс передать вам свои данные таким же быстрым способом. В этом частном случае мы могли бы это сделать, потому что мы дали</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">Обе проблемы, связанные со сборкой мусора и безопасностью потоков, решаются функцией &lt;code&gt;register()&lt;/code&gt; . Он регистрирует объект вместе с любым количеством хешей. Реестр означает, что, когда объект умирает, запись в любом из хешей под ссылочным адресом этого объекта будет удалена. Это гарантирует сборку мусора в этих хэшах. Это также означает, что при клонировании потока записи объекта в зарегистрированных хэшах будут заменены обновленными записями, ключ которых является ссылочным адресом клонированного объекта. Таким образом, ассоциация объект-данные становится поточно-ориентированной.</target>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">Номер процесса Perl,выполняемого этим скриптом.Хотя вы</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">Процесс преобразования строки в одну из четырех &lt;b&gt;casemaps&lt;/b&gt; Unicode ; в Perl это реализовано с помощью функций &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">Процесс определения того, какой метод следует использовать, называется &lt;b&gt;разрешением метода&lt;/b&gt; . Что делает Perl, так это сначала смотрит на класс объекта ( в данном случае &lt;code&gt;File::MP3&lt;/code&gt; ). Если этот класс определяет метод, то вызывается версия метода этого класса. В противном случае Perl просматривает каждый родительский класс по очереди. Для &lt;code&gt;File::MP3&lt;/code&gt; его единственным родительским элементом является &lt;code&gt;File&lt;/code&gt; . Если &lt;code&gt;File::MP3&lt;/code&gt; не определяет метод, а &lt;code&gt;File&lt;/code&gt; определяет , тогда Perl вызывает метод в &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">Процесс приклеивания носа одной кошки к хвосту другой кошки. Тоже аналогичная операция на двух &lt;b&gt;строках&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">Процесс создания &lt;b&gt;строкового&lt;/b&gt; представления абстрактного объекта.</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">Процесс опробования одной альтернативы,проверки ее соответствия и перехода к следующей альтернативе,при этом возвращаясь в строку,откуда была опробована предыдущая альтернатива,если она не была опробована,называется</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">Процесс преобразования исходного кода в форму, пригодную для машинного использования. См. &lt;b&gt;Этап компиляции&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">Программу можно заставить запустить,&quot;отмывая&quot; запятнанное значение через регулярное выражение:второй пример-который по-прежнему игнорирует информацию о локали-запускается,создавая файл с именем в командной строке,если это возможно.</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">Программа вылетает, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , вызывает &lt;code&gt;closelog&lt;/code&gt; , журнал окончен.</target>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">Программа h2xs является отправной точкой для создания расширений.В последующих примерах мы увидим,как можно использовать h2xs для чтения заголовочных файлов и генерации шаблонов для подключения к C-программам.</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">Программа состоит из двух частей: строки 2-7 читают ввод и создают структуру данных, а строки 8-13 анализируют данные и распечатывают отчет. У нас будет хеш- &lt;code&gt;%table&lt;/code&gt; , ключи которой являются названиями стран, а значения - ссылками на массивы названий городов. Структура данных будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">Программа представлена ​​массивом структур &lt;code&gt;regnode&lt;/code&gt; , одна или несколько из которых представляют один regop программы. Struct &lt;code&gt;regnode&lt;/code&gt; является самой маленькой структурой необходимо, и имеет структуру поля , которая совместно со всеми другими более крупными структурами.</target>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">Программа должна позаботиться о том,чтобы это произошло.</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">Программе потребовалось чуть более 17 секунд для запуска. Обратите внимание на разные значения &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; вывода, важно всегда использовать одно и то же и не путать, что означает каждое из них.</target>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">Программа остановится</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">Интерфейс программирования прост в использовании: он тот же, что и в модуле &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; CPAN . Итак, если ваши приложения в настоящее время используют &lt;a href=&quot;md5&quot;&gt;Digest :: MD5&lt;/a&gt; и вы предпочитаете более высокий уровень безопасности SHA, их просто преобразовать.</target>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">Программы и документация в этом дистрибутиве распространяются в надежде,что они будут полезны,но без каких-либо гарантий;даже без подразумеваемой гарантии товарного состояния или пригодности для конкретной цели.</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">Запрос оболочки cpan может содержать текущий номер команды для более легкого отслеживания сеанса или быть простой строкой.</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">Свойство нижнего регистра перед прописными буквами в EBCDIC переносится даже на страницы Latin 1 EBCDIC, такие как 0037 и 1047. Например, &quot;&amp;Euml;&quot; ( &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) стоит перед &quot;&amp;euml;&quot; ( &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235 ) на платформе ASCII, но последняя (83) предшествует первой (115) на платформе EBCDIC. (Проницательные читатели заметят, что заглавная версия &amp;laquo;&amp;szlig;&amp;raquo; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; - это просто &amp;laquo;SS&amp;raquo; и что заглавные версии &amp;laquo;&amp;raquo; (маленький &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) и &amp;laquo;&amp;micro;&amp;raquo; ( &lt;code&gt;MICRO SIGN&lt;/code&gt; ) не входят в 0..255, но в Unicode, в Perl с поддержкой Unicode).</target>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">Протокол (например, &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">Протокол также определяет несколько стандартных &lt;b&gt;переводов&lt;/b&gt;которому файл может подвергнуться во время передачи. Это ASCII, EBCDIC, двоичные и байтовые. ASCII является типом по умолчанию и указывает, что отправитель файлов переводит концы строк в стандартное представление, которое получатель затем переводит обратно в их локальное представление. EBCDIC указывает, что передаваемый файл находится в формате EBCDIC. Двоичный формат (также известный как изображение) отправляет данные в виде непрерывного битового потока. Байтовый формат передает данные как байты, значения которых остаются неизменными независимо от различий в размере байтов между двумя машинами (теоретически - на практике вы должны использовать это, только если вы действительно знаете, что делаете). Этот класс не поддерживает форматы EBCDIC или байтов и по умолчанию будет использовать двоичный формат, если они будут выполнены.</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">Прототип CV для &quot;моей&quot; подлодки.</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">Атрибут прототипа и любые другие атрибуты идут после подписи.</target>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">Прототип из атрибута назначается подпрограмме сразу после прототипа из подпрограммы, что означает, что если оба объявлены одновременно, традиционно определенный прототип игнорируется. Другими словами, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; неотличим от &lt;code&gt;sub foo(@){}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">Предоставленный аргумент ДОЛЖЕН быть равен строке для передачи валидации.</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">Предоставленный аргумент ДОЛЖЕН совпадать с одним из элементов массива ref для прохождения проверки.Справка по массиву может содержать все вышеперечисленные значения.</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">Предоставленный аргумент ДОЛЖЕН совпадать с регулярным выражением для передачи валидации.</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">Предоставленная подпрограмма ДОЛЖНА возвращать true для того,чтобы проверка прошла,а аргумент был принят.</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">Функция псевдохеширования была экспериментальной функцией, представленной в более ранних версиях Perl и удаленной в 5.10.0. Псевдохеш - это ссылка на массив, доступ к которой можно получить с помощью именованных ключей, таких как хеш. Вы можете столкнуться с каким-то кодом в дикой природе, который его использует. Дополнительную информацию см. В прагме &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">Публичный API должен оставаться последовательным,т.е.если подкласс является перегрузочным дополнением,то подкласс должен использовать одно и то же имя,в данном случае badd().Причина этого заключается в том,что Math::BigInt оптимизирован для прямого вызова методов объекта.</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">Назначение макроса &lt;code&gt;SPAGAIN&lt;/code&gt; - обновить локальную копию указателя стека. Это необходимо, потому что возможно, что память, выделенная стеку Perl, была перераспределена во время</target>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">Цель тестирования двоякая:во-первых,помочь разработчикам исправить любые проблемы в их коде,возникающие из-за отсутствия тестирования на других платформах;во-вторых,предоставить пользователям информацию о том,работает ли данный модуль на данной платформе.</target>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">Цель этого документа-показать вам,как вызывать подпрограммы Perl непосредственно из C,т.е.как писать</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">Цель этого модуля - предоставить широкий спектр утилит для тестирования. Различные способы сказать &amp;laquo;хорошо&amp;raquo; с лучшей диагностикой, возможностями пропустить тесты, протестировать будущие функции и сравнить сложные структуры данных. Хотя с помощью простой функции &lt;code&gt;ok()&lt;/code&gt; можно делать почти все , она не обеспечивает хороших результатов диагностики.</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">Назначение,область применения и целевые приложения вашего модуля</target>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">Качество, которое заставляет прилагать большие усилия для снижения общих затрат энергии. Это заставляет вас писать трудосберегающие программы, которые другие сочтут полезными, а затем документировать то, что вы написали, чтобы вам не приходилось отвечать на так много вопросов по этому поводу. Отсюда первое великое достоинство программиста. Отсюда и эта книга. Смотрите также &lt;b&gt;нетерпеливость&lt;/b&gt; и &lt;b&gt;высокомерие&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">Вопрос об эквивалентности строк в Юникоде несколько усложняется:что вы имеете в виду под &quot;равным&quot;?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">Вопрос остается открытым,когда SV,которые являются</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">Вопрос,конечно,в том,зачем тебе делать что-то подобное? Зачем создавать семафор со стартовым счётом,который не является единичным,или зачем уменьшать или увеличивать его более чем на единицу? Ответ-доступность ресурсов.Многие ресурсы,для которых вы хотите управлять доступом,могут безопасно использоваться несколькими потоками одновременно.</target>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">Быстрый и грязный метод хорошо работает только в том случае,если вы не планируете оставлять закомментированный код в исходных текстах.Если появится парсер Pod,ваш многострочный комментарий появится в переводе Pod.Лучше скрыть его и от парсеров Pod.</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">Самый быстрый и грязный способ закомментировать более одной строки Perl - окружить эти строки директивами Pod. Вы должны поместить эти директивы в начало строки и где-нибудь там, где Perl ожидает новый оператор (а не в середине таких операторов, как комментарии &lt;code&gt;#&lt;/code&gt; ). Вы заканчиваете комментарий с помощью &lt;code&gt;=cut&lt;/code&gt; , заканчивая раздел Pod:</target>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">Коэффициент всегда является наибольшим целым числом,меньшим или равным реальному значению коэффициента двух операндов,а остаток (когда он ненулевой)всегда имеет тот же знак,что и второй операнд;так,например,</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">Случайные символы предоставляются программой File::Temp и гарантируют уникальность индивидуальной директории сборки каждого модуля.Это делает одновременный запуск CPAN.pm в параллельных процессах безопасным.</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">Оператор диапазона (в контексте списка)использует магический алгоритм автоинкремента,если операнды являются строками.Можно сказать</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">Оператор диапазона &lt;code&gt;..&lt;/code&gt; не может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">Оператор диапазона также работает со струнами,используя магическое автоинкрементирование,см.ниже.</target>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">Оператором диапазона является &quot;...&quot;,а не запятая.Оператор запятая работает как в C.</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">Оператор диапазона - это &lt;code&gt;...&lt;/code&gt; , а не запятая.</target>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">Причина для требования этого состоит в том, чтобы не сломать старые программы, которые полагаются на то, как все работало до появления Unicode. Эти старые программы знали только о наборе символов ASCII и поэтому могли некорректно работать с дополнительными символами. Когда строка кодируется в UTF-8, Perl предполагает, что программа подготовлена ​​к работе с Unicode, но когда строка не работает, Perl предполагает, что нужен только ASCII, и поэтому те символы, которые не являются символами ASCII, не узнал, какими они будут в Юникоде. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 'unicode_strings' указывает Perl обрабатывать все символы как Unicode, независимо от того, закодирована ли строка в UTF-8 или нет, таким образом избегая проблемы.</target>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">Необработанное исходное содержимое L &amp;lt;...&amp;gt; до разделения текста на &amp;laquo;|&amp;raquo;, &amp;laquo;/&amp;raquo; и т. Д. И до раскрытия кодов E &amp;lt;...&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">Доступная только для чтения волшебная переменная &lt;code&gt;${^UNICODE}&lt;/code&gt; отражает числовое значение этого параметра. Эта переменная устанавливается при запуске Perl и после этого доступна только для чтения. Если вам нужны эффекты времени выполнения, используйте open () с тремя аргументами (см. &lt;a href=&quot;functions/open&quot;&gt;Open&lt;/a&gt; ), binmode () с двумя аргументами (см. &lt;a href=&quot;functions/binmode&quot;&gt;Binmode&lt;/a&gt; ) и прагму &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (см. &lt;a href=&quot;open&quot;&gt;Open&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">Настоящая гид этого процесса. Если вы работаете на машине, которая поддерживает членство в нескольких группах одновременно, выдает список групп, в которых вы &lt;code&gt;getgid()&lt;/code&gt; через пробел . Первое число - это число, возвращаемое функцией getgid () , а последующие - &lt;code&gt;getgroups()&lt;/code&gt; , одна из которых может быть таким же, как первое число.</target>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">Реальный порядковый номер OP, как обычный номер, не скорректированный так, чтобы он соответствовал началу реальной программы. (Обычно это довольно большое число, потому что весь &lt;b&gt;B :: Concise&lt;/b&gt; компилируется раньше, чем ваша программа).</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">Время в реальном времени выполняется с использованием времени(2),поэтому гранулярность составляет всего одну секунду.</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">Реальный идентификатор этого процесса. Вы можете изменить как реальный uid, так и эффективный uid одновременно, используя &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Поскольку для изменения &lt;code&gt;$&amp;lt;&lt;/code&gt; требуется системный вызов, проверьте &lt;code&gt;$!&lt;/code&gt; после изменения попытаться обнаружить возможные ошибки.</target>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">Реальная работа выполняется в стандартной типографской карте.</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">Причина существования &lt;code&gt;encode_language_tag&lt;/code&gt; заключается в том, что разные языковые теги могут представлять один и тот же язык; обычно это можно лечить с помощью &lt;code&gt;same_language_tag&lt;/code&gt; , но рассмотрим эту ситуацию:</target>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">Причина,по которой я сказал &quot;в данном случае&quot;,в том.</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">Причина,по которой не проверяется возвращаемое значение из функции print(),заключается в буферизации трубы;физическая запись задерживается.Она не взорвется до закрытия,а взорвется с помощью SIGPIPE.Чтобы поймать его,можно использовать вот это:</target>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">Причина этого в том, что CPAN не знает зависимости всех модулей при запуске. Чтобы решить, какие дополнительные элементы нужно установить, он просто использует данные из файла META.yml или созданного файла Makefile. Необнаруженный недостающий элемент нарушает процесс. Но вполне может быть, что ваш Bundle устанавливает некоторые предварительные условия позже, чем какой-либо зависимый элемент, и, таким образом, ваша вторая попытка сможет решить все. Обратите внимание, что CPAN.pm заранее не знает дерево зависимостей и не может отсортировать очередь вещей для установки в топологически правильном порядке. Он отлично разрешается, &lt;b&gt;если&lt;/b&gt; все модули правильно объявляют предварительные условия с атрибутом PREREQ_PM для MakeMaker или &lt;code&gt;requires&lt;/code&gt; строфа Module :: Build. Для пакетов, которые не работают и вам нужно часто устанавливать, рекомендуется вручную отсортировать файл определения пакета.</target>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">Причина такой непригодности заключается в том, что фундаментальное предположение Perl состоит в том, что символы, которые он заботится для синтаксического анализа и лексического анализа, одинаковы, независимо от того, находится ли текст в UTF-8. Например, Perl ожидает, что символ &lt;code&gt;&quot;[&quot;&lt;/code&gt; будет иметь одно и то же представление, независимо от того, закодирована ли строка, содержащая его (или текст программы), в кодировке UTF-8 или нет. Чтобы гарантировать это, Perl адаптирует UTF-EBCDIC к конкретной кодовой странице, так что все символы, которые он ожидает инвариантными для UTF-8, фактически инвариантны для UTF-8. Это означает, что текст, сгенерированный на компьютере с одной версией Perl UTF-EBCDIC, должен быть переведен, чтобы он был понятен компьютеру, на котором запущена другая.</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">Причина в том,что Encode::Guess угадывает кодировку методом проб и ошибок.Сначала он разбивает $data на строки и пытается декодировать строку для каждого подозреваемого.Он продолжает работать до тех пор,пока все кодировки,кроме одной,не будут удалены из списка подозреваемых.Серия ISO-8859 просто слишком успешна для большинства случаев (потому что она заполняет почти все кодовые пункты на \x00-\xff).</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">Причина в том,что переменная интерполяция и выражения кода вместе представляют собой риск безопасности.Эта комбинация опасна,так как многие программисты,пишущие поисковые системы,часто берут пользовательский ввод и подключают его непосредственно к регеxp:</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">Причина в том,что кодировка производителя обычно является сверхнормативным национальным стандартом,поэтому в большинстве случаев она становится слишком двусмысленной.</target>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">Причина,по которой не делается то,что вы хотите,заключается в том,что назначение такого именованного массива скаляру происходит в контексте скаляра,а это значит,что просто подсчитывается количество элементов в @tmp.</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">Причина,по которой хост $failed_ack_host не получил действительный ACK.Полезно,чтобы выяснить почему,когда функция ack($fail_ack_host)возвращает ложное значение.</target>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">Причина,по которой эта функция имеет &quot;_strictly&quot; в названии,заключается в том,что когда вы обрабатываете список Accept-Language согласно RFC,если вы интерпретируете RFC достаточно строго,то вы будете использовать implicate_supers_strictly,но для нормального использования (т.е.для здравого смысла,насколько я понимаю)вы будете использовать импликат_supers.</target>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">Причина,по которой это необходимо,заключается в том,что область стека Perl,в которой они находились,скорее всего,была перезаписана чем-то другим к моменту возвращения контроля времени из</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">Причина,по которой это не является поведением по умолчанию,заключается в том,что содержимое RFC 1951 может быть обнаружено только при попытке его распаковки.Этот процесс подвержен ошибкам и может привести к ложным срабатываниям.</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">Причина,по которой это не является поведением по умолчанию,заключается в том,что содержимое lzma_alone может быть обнаружено только при попытке его распаковки.Этот процесс подвержен ошибкам и может привести к ложным срабатываниям.</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">Причина, по которой это неверно, заключается в том, что к тому времени, когда вы начнете использовать указатель &lt;code&gt;rememberSub&lt;/code&gt; в &lt;code&gt;CallSavedSub1&lt;/code&gt; , он может все еще относиться или не ссылаться на подпрограмму Perl, которая была записана в &lt;code&gt;SaveSub1&lt;/code&gt; . Это особенно актуально для следующих случаев:</target>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">Причины наиболее важных пропущенных тестов:</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">Распознанные яркие атрибуты цвета фона (цвета от 8 до 15):</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">Распознаются обычные атрибуты цвета фона (цвета от 0 до 7):</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">Распознаются обычные атрибуты цвета переднего плана (цвета от 0 до 7):</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">Признанные опции функции new()следующие.Все опции принимают один аргумент.</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">В Tru64 рекомендуется использовать родной компилятор Си.Родной компилятор производит гораздо более быстрый код (разница в скорости заметна:несколько десятков процентов),а также более корректный:если вы рассматриваете возможность использования компилятора GNU C,то следует использовать как минимум выпуск 2.95.3,так как известно,что при компиляции Perl все старые релизы gcc производят код с ошибками.Одним из проявлений этой нарушенности является дампинг ядра теста lib/sdbm;другим является дампинг ядра многих op/regexp и op/pat,или ext/Storable тестов (точный шаблон отказов в зависимости от релиза GCC и флагов оптимизации).</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">Рекомендуемый порядок разделов в документации на модуль Perl:</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">Рекомендуемый способ сборки Perl для OS/400 PASE-это сборка исходного кода Perl 5 (редакция 5.8.1 или более поздняя)под AIX.</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">Функции red()и green()будут похожи.Для их создания мы назначим закрывающий шрифт имени функции,которую мы пытаемся собрать.</target>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">Счетчик ссылок &lt;code&gt;sv&lt;/code&gt; будет уменьшаться в конце</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">Счетчик ссылок для каждого указанного параметра &lt;code&gt;SV*&lt;/code&gt; уменьшается.</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">Счетчик ссылок в списке имен блокнотов.</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">Счетчик ссылок на название площадки.</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">Счетчик ссылок в ведомости.В настоящее время это всегда 1.</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ссылка с &lt;code&gt;$foo&lt;/code&gt; на &lt;code&gt;$bar&lt;/code&gt; была ослаблена. Когда переменная &lt;code&gt;$bar&lt;/code&gt; выходит за пределы области видимости, она будет собрана в мусор. В следующий раз, когда вы посмотрите на значение клавиши &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; , оно будет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">Ссылка действительно сброшена,и мы наконец-то видим,с чем имеем дело.Наша цитата была совершенно верной,но неправильной для наших целей,когда &quot;и канитель&quot; трактовалась как 2 отдельных слова,а не как фраза,таким образом,выкидывая равномерно парную хэш-структуру из равновесия.</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">Ссылки,которые вы получаете из правила 2,это те же самые ссылки,которые вы получаете из правила 1:</target>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">Регулярное выражение имеет единственную группировку, которая рассматривает комбинации из 4 букв, затем комбинации из 3 букв и т. Д. И использует &lt;code&gt;\g1&lt;/code&gt; для поиска повтора. Хотя &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;\g1&lt;/code&gt; представляют одно и то же, следует соблюдать осторожность, чтобы использовать только совпадающие переменные &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">Регулярное выражение соответствует открытой круглой скобке, одной или нескольким копиям чередования и закрытой круглой скобке. Чередование двухстороннее: первая альтернатива &lt;code&gt;[^()]+&lt;/code&gt; соответствует подстроке без скобок, а вторая альтернатива &lt;code&gt;\([^()]*\)&lt;/code&gt; соответствует подстроке, разделенной скобками. Проблема с этим регулярным выражением заключается в том, что оно является патологическим: оно содержит вложенные неопределенные кванторы вида &lt;code&gt;(a+|b)+&lt;/code&gt; . В части 1 мы обсуждали, как вложенные квантификаторы, подобные этому, могут занять экспоненциально много времени для выполнения, если совпадение невозможно. Чтобы предотвратить экспоненциальный взрыв, нам нужно предотвратить бесполезный возврат в какой-то момент. Это можно сделать, включив внутренний квантификатор как независимое подвыражение:</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">Структура regexp содержит все данные,которые perl должен знать,чтобы корректно работать с регулярным выражением.Она включает данные об оптимизациях,которые perl может использовать для определения того,действительно ли следует использовать регекс-движок,а также различную другую контрольную информацию,необходимую для правильного выполнения шаблонов в различных контекстах,например,закреплен ли каким-либо образом шаблон,или какие флаги использовались во время компиляции,или содержит ли программа специальные конструкции,о которых perl должен знать.</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">Регулярное выражение без модификатора &lt;code&gt;//x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">Регопы определены в</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">Регрессивные тесты для каждого оператора живут в</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">Двигатель регулярного выражения может быть весомым орудием в руках.На длинных строках и сложных шаблонах ему может потребоваться много работы,чтобы найти совпадение,а еще больше-решить,что совпадение невозможно.Рассмотрим такую ситуацию,как следующая.</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">Регулярное выражение для выполнения.</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">Регулярное выражение, соответствующее сбалансированному тексту, использует две новые (для Perl 5.10) функции регулярного выражения. Они описаны в &lt;a href=&quot;perlre&quot;&gt;perlre,&lt;/a&gt; и этот пример представляет собой модифицированную версию той же документации.</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">Связанная &lt;code&gt;base&lt;/code&gt; прагма объединит поля из базовых классов и любые поля, объявленные с помощью прагмы &lt;code&gt;fields&lt;/code&gt; . Это позволяет наследованию полей работать правильно. Унаследованные поля можно переопределить, но при включении предупреждений будет выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">Соответствующий фрагмент из &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">Остаток входной строки (т.е.символы после извлеченной строки).При отказе возвращается вся строка.</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">Остальные аргументы перечисляют файлы,которые должны быть включены в tar-файл.Все эти файлы должны существовать.Любые файлы,которые не существуют или не могут быть прочитаны,беззвучно игнорируются.</target>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">Остальные функции сокращения списка являются специализацией этой общей идеи.</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">Остальные категории локалей в настоящее время не используются самим Perl. Но снова обратите внимание, что вещи, с которыми взаимодействует Perl, могут использовать их, включая расширения вне стандартного дистрибутива Perl, а также операционную систему и ее утилиты. Обратите особое внимание на то, что строковое значение &lt;code&gt;$!&lt;/code&gt; и сообщения об ошибках, выдаваемые внешними утилитами, могут быть изменены &lt;code&gt;LC_MESSAGES&lt;/code&gt; . Если вы хотите иметь переносимые коды ошибок, используйте &lt;code&gt;%!&lt;/code&gt; . См. &lt;a href=&quot;errno&quot;&gt;Эррно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">Остальные три аргумента &lt;code&gt;autosplit&lt;/code&gt; управляют другими параметрами autosplitter.</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">Остальные преобразования (например, hex -&amp;gt; oct, bin -&amp;gt; hex и т. Д.) Оставлены в качестве упражнения для склонного читателя.</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">Счетчик повторов для &lt;code&gt;u&lt;/code&gt; интерпретируется как максимальное количество байтов для кодирования на строку вывода, при этом 0, 1 и 2 заменены на 45. Счетчик повторов не должен превышать 65.</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Репертуар символов, которые может представлять Perl, является расширенным набором символов, определенных Консорциумом Unicode. На большинстве платформ порядковые значения символа, возвращаемые &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">Генерируемый отчет имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">Затем отчет группируется по &lt;b&gt;Пакету&lt;/b&gt; каждой переменной, подпрограммы или формата с особым случаем &amp;laquo;(лексические)&amp;raquo;, означающим лексические переменные. Каждое имя &lt;b&gt;объекта&lt;/b&gt; (неявно определяемое содержащим его &lt;b&gt;пакетом&lt;/b&gt; ) включает в себя символ (ы) типа в начале, где это возможно. Лексические переменные легче отслеживать, и они даже включали информацию для разыменования, где это возможно.</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">Доклад с</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">Запрос был сочтен небольшим, поэтому возможность его перехвата зависит от способа компиляции perl. По умолчанию это невозможно. Однако, если он скомпилирован для этого, Perl может использовать содержимое &lt;code&gt;$^M&lt;/code&gt; как аварийный пул после die () с этим сообщением. В этом случае ошибка возможна.</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">Запросы не всегда доходят до операционной системы:именно здесь в игру вступает буферизация PerlIO.</target>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">Функция &quot;Требование&quot; будет на самом деле искать &quot;</target>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">Требуемая функция будет искать &quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">Обязательными аргументами во время &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; являются хэш, пакет и ссылка на функцию &lt;code&gt;FETCH&lt;/code&gt; ing. Необязательными аргументами являются произвольные скалярные данные $, ссылка на функцию &lt;code&gt;EXISTS&lt;/code&gt; и начальные значения хэша и кеша существования.</target>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">Требования и требования к декларациям зависимостей</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">Остальное-дубликат кода из MM_Unix.Следует перенести код компоновщика на свой собственный метод.</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">Остальное предназначено для внутреннего использования данного пакета.В частности,если TIEHASH переписан,он должен позвонить SUPER::TIEHASH.</target>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">Остальной файл .pm содержит пример кода для предоставления документации по расширению.</target>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">Остальная часть описания функции может быть снабжена отступом или скорректирована влево.В следующем примере показана функция с левосторонней регулировкой тела.В большинстве примеров в этом документе тело функции будет иметь отступы для лучшей читабельности.</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">Остальная часть этого раздела может нуждаться в обновлении, но мы не знаем, что в нем должно быть сказано. &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;Отправляйте&lt;/a&gt; комментарии по адресу perlbug@perl.org .</target>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">Ранее перезапуск был реализован с использованием &lt;code&gt;longjmp&lt;/code&gt; в &lt;code&gt;regatom()&lt;/code&gt; обратно к &lt;code&gt;setjmp&lt;/code&gt; в &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , но это оказалось проблематичным, поскольку последняя представляет собой большую функцию, содержащую множество автоматических переменных, которые плохо взаимодействуют с возникающим потоком управления &lt;code&gt;setjmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">Ограничение для операции сравнения состоит в том, что даже если, например, &lt;code&gt;cmp&lt;/code&gt; должна возвращать благословенную ссылку, автоматически сгенерированная функция &lt;code&gt;lt&lt;/code&gt; будет выдавать только стандартное логическое значение, основанное на числовом значении результата &lt;code&gt;cmp&lt;/code&gt; . В частности, в этом случае требуется рабочее числовое преобразование (возможно, выраженное в терминах других преобразований).</target>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">Результат &lt;code&gt;$^R&lt;/code&gt; автоматически локализуется, поэтому он будет вести себя правильно при наличии возврата.</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;Regexp&lt;/code&gt; указывает, что аргумент является регулярным выражением, полученным из &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;Regexp&lt;/code&gt; указывает, что аргумент является регулярным выражением, полученным из &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">Результат возвращается в виде двух аргументов.Если модульный мультипликативный обратный аргумент не существует,то оба аргумента неопределенны.В противном случае аргументами являются число (объект)и его знак (&quot;+&quot; или &quot;-&quot;).</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">В результате содержимое 17-й строки файла будет заменено на &quot;Вишневый пирог&quot;;символ новой строки отделит 17-ю строку от 18-й.Это означает,что данный код ничего не сделает:</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">В результате получается символ Юникода или последовательность символов,заданная параметрами</target>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом будет символ, указанный в шестнадцатеричном числе в фигурных скобках. См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом является символ, заданный шестнадцатеричным числом в диапазоне от 0x00 до 0xFF. См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом будет символ, указанный восьмеричным числом в фигурных скобках. См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом является символ, заданный трехзначным восьмеричным числом в диапазоне от 000 до 777 (но лучше не использовать выше 077, см. Следующий абзац). См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">Результат такой же, как у &lt;code&gt;xhdr&lt;/code&gt; , за исключением того, что он будет ограничен заголовками, текст заголовка которых соответствует &lt;code&gt;PATTERN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">Результат может быть использован в качестве подмаскировки в матче:</target>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">Результат оценки последнего успешного &lt;code&gt;(?{ code })&lt;/code&gt; утверждения регулярного выражения (см. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; ). Может быть написано на.</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">Результат great_circle_direction находится в радиусах,ноль указывает на прямой север,pi или -pi прямой юг,pi/2 прямой запад,и -pi/2 прямой восток.</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">Результат md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)будет точно таким же,как и результат md5(&quot;abc&quot;).</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">Результат переполнения диапазона целых чисел не определен, потому что он не определен также в C. Другими словами, при использовании 32-битных целых чисел &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; не определено. Сдвиг на отрицательное количество бит также не определен.</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">Результатом этого сценария является в лучшем случае база данных,которая не содержит того,что вы ожидаете.В худшем случае база данных будет повреждена.</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">Возвращаемый результат будет одним из следующих:</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">Строка результата, содержащая интерполированный материал, испорчена, если действует форма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; , включающая &lt;code&gt;LC_CTYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">В результате получится массив из 3 элементов,каждый из которых будет содержать ссылку на массив,в котором будут храниться хэндлы,готовые к чтению,записи и имеющие исключения соответственно.При ошибке возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">Результат будет в три раза больше, чем количество слоев: первый элемент будет именем, второй элемент - аргументами (неопределенные аргументы будут &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), третий элемент - флагами, четвертый элемент - снова именем, и так вперед.</target>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">В результирующем $subdir_cmd нет ни ведущей вкладки,ни следящей новой линии.Это облегчает встраивание в строку make.Например.</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">Полученная последовательность байтов наиболее удобна для проверки контрольной суммы. Не замедляйте работу своей программы с помощью цикла for, добавляющего значения &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; байтов этой строки - код &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; - это то, что нужно использовать для вычисления 8-битной суммы всех байтов, которая должна быть равна нулю:</target>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">По умолчанию результирующий путь относителен,т.е.результирующий путь будет иметь ведущий двоеточие.</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">Получившаяся программа выглядит так:</target>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Результаты можно передать в &lt;a href=&quot;#catpath&quot;&gt;catpath,&lt;/a&gt; чтобы вернуть путь, эквивалентный (обычно идентичный) исходному пути.</target>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Результаты можно передать в &lt;a href=&quot;#catpath()&quot;&gt;catpath (),&lt;/a&gt; чтобы вернуть путь, эквивалентный (обычно идентичный) исходному пути.</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Результаты можно передать в &lt;code&gt;catpath()&lt;/code&gt; чтобы вернуть путь, эквивалентный (обычно идентичный) исходному пути.</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">Результаты соответствуют правилам ASCII. Только символы &lt;code&gt;A-Z&lt;/code&gt; меняются на &lt;code&gt;a-z&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">Результаты создания новых записей таблицы символов непосредственно или изменения любых записей,которые еще не являются печатными шрифтами,не определены и могут изменяться между выпусками perl.</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">Результатом &lt;code&gt;VERSION&lt;/code&gt; будет фактически строковый объект версии, использующий скаляр пакета &lt;code&gt;$VERSION&lt;/code&gt; , который гарантированно эквивалентен, но может не быть в точности содержимым скаляра &lt;code&gt;$VERSION&lt;/code&gt; . Если вам нужно фактическое содержимое &lt;code&gt;$VERSION&lt;/code&gt; , используйте вместо этого &lt;code&gt;$CLASS::VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">Список возврата сгенерированной функции Perl состоит из значения, возвращаемого функцией C (если XSUB не имеет типа возврата &lt;code&gt;void&lt;/code&gt; или не использовалось &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; ), за которым следуют все параметры &lt;code&gt;OUTLIST&lt;/code&gt; и &lt;code&gt;IN_OUTLIST&lt;/code&gt; (в порядке появления). При возврате из XSUB параметр &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl будет изменен, чтобы значения были записаны функцией C.</target>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">Возвращает истину, если аргумент удовлетворяет условию. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; не являются целыми числами и не являются ни нечетными, ни четными.</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">Возвращаемое значение (если определено) - объект Perl класса &lt;code&gt;PerlIO::Layer&lt;/code&gt; который создается кодом C в</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;LVALUE&lt;/code&gt; указывает ссылку на lvalue, которое не является переменной. Вы получаете это, взяв ссылку на вызовы функций, такие как &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;VSTRING&lt;/code&gt; возвращается, если ссылка указывает на &lt;a href=&quot;perldata#Version-Strings&quot;&gt;строку версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;LVALUE&lt;/code&gt; указывает ссылку на lvalue, которое не является переменной. Вы получаете это, взяв ссылку на вызовы функций, такие как &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;VSTRING&lt;/code&gt; возвращается, если ссылка указывает на &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;строку версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">Возвращаемое значение может быть &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; чтобы получить идентичную копию исходной ссылочной структуры. (Пожалуйста, примите во внимание последствия проверки кода из ненадежных источников для безопасности!)</target>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">Возвращаемое значение для &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; определяется реализацией; обратитесь к вашей странице руководства atan2 (3) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">Возвращаемое значение для &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; определяется реализацией; обратитесь к вашей странице руководства atan2 (3) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;true&lt;/code&gt; если это действительный прототип, и &lt;code&gt;false&lt;/code&gt; если это не так, независимо от того, было ли &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">Возвращаемое значение похоже на POSIX (сдвинуто вверх на 8 бит), что дает место только для выдуманного значения, полученного из битов серьезности собственного 32-битного кода условия (если не переопределено с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). Если собственный код условия имеет кодированное значение POSIX, значение POSIX будет декодировано для извлечения ожидаемого значения выхода. Подробнее см. &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? в perlvms&lt;/a&gt; . (VMS)</target>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">Возвращаемое значение всегда является скаляром, строкой или числом. Для свойств, где есть синонимы для значений, синоним, возвращаемый этой функцией, является самой длинной и описательной формой, возвращаемой &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; при вызове в скалярном контексте. Конечно, вы можете вызвать &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; для результата, чтобы получить другие синонимы.</target>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">Возвращаемым значением является сам объект $ctx.</target>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">Возвращаемое значение - это статус выхода программы, возвращенный вызовом &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Чтобы получить фактическое значение выхода, сдвиньте вправо на восемь (см. Ниже). См. Также &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; . Это</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">Возвращаемое значение - это статус выхода программы, возвращенный вызовом &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Чтобы получить фактическое значение выхода, сдвиньте вправо на восемь (см. Ниже). См. Также &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; . Это</target>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">Возвращаемым значением является сам обновленный объект.</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение может быть списком, содержащим ноль или более ссылок на массив, целого числа или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">Возвращаемое значение может быть ссылкой на массив с 1-й по 4-ю весами, как показано выше. Возвращаемое значение может быть целым числом в качестве основного веса, как показано ниже. Если возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , будет использоваться производный элемент сопоставления по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (и &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (и &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;INLINED&lt;/code&gt; в этом примере всегда будет 54321, независимо от последующих изменений в $ x. Вы также можете поместить любой произвольный код внутрь подпрограммы, он будет выполнен немедленно, а его возвращаемое значение будет захвачено таким же образом.</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;survey&lt;/code&gt; - два хеша:</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">Возвращаемое значение Pod::Perldoc::GetOptsOO::getopts истинно,если нет ошибок,в противном случае это ложь.</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">Возвращаемое значение функции tell()для стандартных потоков,таких как STDIN,зависит от операционной системы:она может возвращать -1 или что-то еще.tell()на трубах,fifos и сокетах обычно возвращает -1.</target>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">Возвращаемое значение будет NULL, если операция завершилась неудачно или значение не нужно было фактически хранить в хэше (как в случае связанных хешей). В противном случае его можно будет разыменовать, чтобы получить исходный &lt;code&gt;SV*&lt;/code&gt; . Обратите внимание, что вызывающая сторона отвечает за соответствующее увеличение счетчика ссылок &lt;code&gt;val&lt;/code&gt; перед вызовом и уменьшение его, если функция вернула NULL. Фактически успешный hv_store становится владельцем одной ссылки на &lt;code&gt;val&lt;/code&gt; . Обычно это то, что вы хотите; вновь созданный SV имеет счетчик ссылок, равный единице, поэтому, если весь ваш код создает SV, а затем сохраняет их в хэше, hv_store будет владеть единственной ссылкой на новый SV, и вашему коду не нужно делать что-либо еще для прибраться. hv_store не реализован как вызов hv_store_ent и не создает временный SV для ключа, поэтому, если ваши данные ключа еще не находятся в форме SV, используйте hv_store вместо hv_store_ent.</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">Возвращаемое значение будет представлять собой список;первым значением будет состояние ошибки,за которым последуют имя хоста и имя службы.</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">Возвращаемое значение будет представлять собой список;первое значение-индикация ошибок,за которым следует список структур адресов (если ошибка не произошла).</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">Возвращаемое значение будет представлять собой ссылку на хэш,где ключами являются номера сообщений,и каждое значение содержит ссылку на массив,который содержит поля обзора этого сообщения.</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">Возвращаемое значение будет представлять собой ссылку на хэш,где ключами являются номера сообщений,и каждое значение содержит текст запрошенного заголовка этого сообщения.</target>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">Возвращаемые значения более &quot;приготовлены&quot;, чем значения &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; . Например, значение свойства &lt;code&gt;&quot;uc&quot;&lt;/code&gt; - это фактическая строка, содержащая полное отображение в верхнем регистре входной кодовой точки. Вы должны пойти на дополнительные проблемы с &lt;code&gt;charinfo&lt;/code&gt; , чтобы получить это значение из его &lt;code&gt;upper&lt;/code&gt; хеш-элемента, когда полное отображение отличается от простого.</target>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">Возвращаемый объект будет действителен только до тех пор,пока продолжают существовать базовые операционные системы и SV.Не пытайтесь использовать объект после освобождения базовых структур.</target>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">Возвращаемые значения являются копиями исходных ключей в хэше, поэтому их изменение не повлияет на исходный хеш. Сравните &lt;a href=&quot;#values&quot;&gt;значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">Возвращаемые значения являются копиями исходных ключей в хэше, поэтому их изменение не повлияет на исходный хеш. Сравните &lt;a href=&quot;values&quot;&gt;значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">Возвращаемые значения свойств расширения Perl, таких как &lt;code&gt;Any&lt;/code&gt; и &lt;code&gt;Greek&lt;/code&gt; , несколько вводят в заблуждение. Значения могут быть &lt;code&gt;&quot;Y&quot;&lt;/code&gt; или &lt;code&gt;&quot;N&lt;/code&gt; &amp;raquo;. Все свойства Unicode являются двудольными, поэтому вы можете использовать &lt;code&gt;&quot;Y&quot;&lt;/code&gt; или &lt;code&gt;&quot;N&lt;/code&gt; &amp;raquo; в регулярном повторном выражении Perl для них, например &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; . Но расширения Perl не указаны таким образом, только как &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Редакция, версия и подрывная версия интерпретатора Perl, представленные как объект &lt;a href=&quot;version&quot;&gt;версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Редакция,версия и подрыв Perl интерпретатора,представленная в виде десятичной дроби формы 5.XXXYYY,где XXX-версия/1e3 и YYY-подрывная версия/1e6.Например,Perl v5.10.1 будет &quot;5.010001&quot;.</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">Переписанная версия этого модуля (по сравнению с v0.01) медленнее при выполнении некоторых операций, таких как &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; и &lt;code&gt;numify()&lt;/code&gt; . Причина в том, что теперь он выполняет больше работы и обрабатывает гораздо больше дел. Время, затрачиваемое на эти операции, обычно достигается за счет других математических операций, поэтому код в среднем должен работать (намного) быстрее. Если нет, свяжитесь с автором.</target>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">Правая колонка также предупредит вас,если объект недвижимости означает нечто отличное от того,что обычно можно ожидать.</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">Правая сторона, начиная со строки 5, аналогична тому, что мы только что видели: у нас есть &lt;code&gt;add&lt;/code&gt; op ( &lt;code&gt;pp_add&lt;/code&gt; также в</target>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">Правый операнд не оценивается, пока оператор находится в состоянии &amp;laquo;ложь&amp;raquo;, а левый операнд не оценивается, пока оператор находится в состоянии &amp;laquo;истина&amp;raquo;. Приоритет немного ниже, чем || и &amp;amp;&amp;amp;. Возвращаемое значение представляет собой либо пустую строку для false, либо порядковый номер (начинающийся с 1) для true. Порядковый номер сбрасывается для каждого обнаруженного диапазона. К последнему порядковому номеру в диапазоне добавлена строка &lt;code&gt;&quot;E0&quot;&lt;/code&gt; , которая не влияет на его числовое значение, но дает вам что-то для поиска, если вы хотите исключить конечную точку. Вы можете исключить начальную точку, дождавшись, пока порядковый номер не станет больше 1.</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">Крайний правый разделитель, начинающий текст аргумента с внутренней последовательностью (должен быть &quot;&amp;gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">Функция rmtree()предоставляет наследственному интерфейсу remove_tree()другую интерпретацию передаваемых аргументов.Поведение и возвращаемое значение функции в противном случае идентичны функции remove_tree().</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">Пример rot13 был тривиальным.Вот еще одна демонстрация,показывающая еще несколько возможностей.</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$myarray[$idx]&lt;/code&gt; эквивалент Perl - $ myarray [$ idx] .</target>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">Подпрограмма &lt;code&gt;regtail()&lt;/code&gt; вызывается как &lt;code&gt;reg()&lt;/code&gt; и &lt;code&gt;regbranch()&lt;/code&gt; чтобы правильно &amp;laquo;установить указатель хвоста&amp;raquo;. При выполнении и достижении конца ветки нам нужно перейти к узлу, следующему за скобками группировки. Однако при синтаксическом анализе мы не знаем, где будет конец, пока не дойдем до него, поэтому, когда мы это сделаем, мы должны вернуться и обновить смещения по мере необходимости. &lt;code&gt;regtail&lt;/code&gt; используется, чтобы сделать это проще.</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">Подпрограмма, обозначенная &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; вызывается, когда вот-вот возникнет фатальное исключение. Сообщение об ошибке передается как первый аргумент. При &lt;code&gt;__DIE__&lt;/code&gt; подпрограммы ловушки __DIE__ обработка исключения продолжается, как и в случае ее отсутствия, если сама процедура ловушки не завершается через &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , выход из цикла или &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;__DIE__&lt;/code&gt; обработчик явно отключается во время разговора, так что вы можете умереть от &lt;code&gt;__DIE__&lt;/code&gt; обработчика. Аналогично для &lt;code&gt;__WARN__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">Чаще всего используется процедура &lt;code&gt;call_sv&lt;/code&gt; . &lt;code&gt;SV*&lt;/code&gt; аргумент содержит либо имя подпрограммы Perl будет называться, или ссылка на подпрограмму. Второй аргумент состоит из флагов, которые управляют контекстом, в котором вызывается подпрограмма, независимо от того, передаются ли подпрограмме аргументы, как следует перехватывать ошибки и как обрабатывать возвращаемые значения.</target>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">В противном случае процедура возвращает &lt;b&gt;false&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">Подпрограмма возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; для проблем ввода-вывода или другой внутренней ошибки, в противном случае - истинное значение. Серьезные ошибки распространяются в качестве &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; исключений.</target>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">Подпрограммы &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;reftype&lt;/code&gt; можно экспортировать.</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">Процедуры &lt;code&gt;make_path&lt;/code&gt; и &lt;code&gt;remove_tree&lt;/code&gt; которые &lt;b&gt;не&lt;/b&gt; экспортируются по умолчанию. Вы должны указать, какие из них хотите использовать.</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">Эти подпрограммы вызываются в порядке сравнения строк KEY.</target>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">Правило,по которому Digest::SHA обрабатывает строку в Юникоде,легко сформулировать,но потенциально сбивает с толку:строка интерпретируется как последовательность значений байтов,где каждое значение байта равно порядковому значению (а именно кодовой точке)соответствующего ей символа Юникода.Таким образом,строка в Юникоде 'abc' имеет точно такое же дайджестовое значение,что и обычная строка 'abc'.</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">В правиле должен быть только один ключ верхнего уровня:либо 'par' для &quot;parallel&quot;,либо 'seq' для &quot;sequence&quot;.</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">Эмпирическое правило для портативного кода таково:Делайте все это на переносном Perl или используйте модуль (который может реализовать его внутри платформы с помощью кода,специфичного для конкретной платформы,но раскрывающего общий интерфейс).</target>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">Более подробно структура данных правил описана в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">Правила,определяющие,что это такое,довольно просты:если символ,следующий за обратным слешем,является ASCII-знаком препинания (не словом)(то есть всем,что не является буквой,цифрой или подчеркиванием),то обратный слеш просто убирает любое особое значение следующего за ним символа.</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">Правила поведения,которые в отсутствие других указаний определяют,что должно произойти в первую очередь.Например,при отсутствии скобок,вы всегда делаете умножение перед сложением.</target>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">Компонент времени выполнения должен иметь имя</target>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">Тот же подход,что и в командной строке:</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">То же, что и для &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , но если отсутствующий оператор не может быть автоматически сгенерирован, то вместо выдачи сообщения об ошибке Perl может вернуться к тому, что он сделал бы для этого оператора, если бы не было директивы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">Эта же контрольная сумма может быть рассчитана и в стиле OO:</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">Тот же эффект,что и в примере выше,по-другому.В качестве аргумента coderef принимает псевдоним и возвращает каноническое имя при успехе или undef,если нет.Обратите внимание,что второй аргумент игнорируется,если он предоставлен.Используйте это с еще большей осторожностью,чем в регекс-версии.</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">То же самое относится к оцененным строкам, которые содержат подпрограммы или которые в настоящее время выполняются. Имя $ filename для строк &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ed выглядит так &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">Та же самая информация отображается в конце вывода команды</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">То же самое не относится к реализациям &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; : ожидается, что они изменят свои операнды. Соответствующая реализация &lt;code&gt;--&lt;/code&gt; может выглядеть как</target>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">То же самое может произойти и с AIX 5.1 или другими уровнями ОС.В качестве примечания,Perl не может быть собран без установленных bos.adt.syscalls и bos.adt.libm</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">Одно и то же имя пакета может быть использовано несколько раз,что позволяет использовать несетевой код.Это полезно,если у вас более строгий принцип заказа,чем имена пакетов.</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">Те же проблемы возникают, если вы включите автоматическую UTF-8-ификацию ваших стандартных файловых дескрипторов, уровня &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; умолчанию и &lt;code&gt;@ARGV&lt;/code&gt; для локалей, отличных от ISO8859-1 и не-UTF-8 (с помощью командной строки &lt;b&gt;-C&lt;/b&gt; переключатель или &lt;code&gt;PERL_UNICODE&lt;/code&gt; среды PERL_UNICODE ; см. &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; ). Вещи читаются как UTF-8, что обычно подразумевает интерпретацию Unicode, но наличие языкового стандарта заставляет их интерпретировать их вместо этого. Например, кодовая точка 0xD7 во вводе Unicode, которая должна означать знак умножения, не будет интерпретироваться Perl таким образом в греческой локали. Это не является проблемой</target>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">Те же проблемы возникают, если им передать объекты Math :: BigInt-&amp;gt; binf (). Поскольку перегрузка этих подпрограмм невозможна, это не может быть исправлено с помощью BigInt.</target>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">Этот же шаблон обычно может быть использован и в распаковке().</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">Оба раза выполняются одни и те же тесты, но дополнительная информация предоставляется при запуске с &lt;code&gt;./perl harness&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">Пример программы:</target>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">Скалярное &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; сохраняется в экземпляре SV с именем &lt;code&gt;PL_sv_undef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">Скаляр/контекст списка для подпрограмм и для правой стороны назначения определяется так,как если бы вызов подпрограмм был заменен скаляром.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">Вышеприведенная схема позволяет интерпретировать широкий диапазон дат,особенно при использовании 4-х значных лет.</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">Схема из uri (например,'file','http' и т.д.)</target>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">Область, в которой используется &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; превратила категорию &lt;code&gt;void&lt;/code&gt; предупреждений в фатальную ошибку, поэтому программа немедленно завершает работу при обнаружении предупреждения.</target>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">Сценарий сначала проверяет функцию класса &lt;code&gt;Name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">Скрипт доступен по &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;адресу https://gist.github.com/eqhmcow/5389877.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">Поисковая система сначала сопоставит &lt;code&gt;\D*&lt;/code&gt; с &quot;ABC&quot;. Затем он попытается сопоставить &lt;code&gt;(?!123)&lt;/code&gt; с &amp;laquo;123&amp;raquo;, но это не поможет . Но поскольку в регулярном выражении использовался квантификатор ( &lt;code&gt;\D*&lt;/code&gt; ), поисковая машина может выполнить обратный поиск и повторить поиск по-другому в надежде найти полное регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">Второе преимущество заключается в том, что встроенные модификаторы (за исключением &lt;code&gt;//p&lt;/code&gt; , который изменяет все регулярное выражение) влияют только на регулярное выражение внутри группы, в которой содержится встроенный модификатор. Таким образом, для локализации эффектов модификатора можно использовать группировку:</target>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; и &lt;code&gt;type&lt;/code&gt; второго и третьего аргументов указывают, сколько структур данных указанного типа должно быть выделено. Аргумент &lt;code&gt;type&lt;/code&gt; передается &lt;code&gt;sizeof&lt;/code&gt; . Последний аргумент &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , следует использовать, если аргумент &lt;code&gt;pointer&lt;/code&gt; отличается от аргумента &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">Второй аргумент ($eol)-это конечная строчная последовательность.Он необязателен и по умолчанию равен &quot;\n&quot;.Каждое вхождение &quot;\n&quot; заменяется этой строкой,а также используется для дополнительных &quot;мягких разрывов строк&quot;,чтобы гарантировать,что ни одна строка не заканчивается длиннее 76 символов.Для получения данных,пригодных для внешнего потребления,передайте их как &quot;\015\012&quot;.Строка &quot;\r\n&quot; дает на многих платформах,но не на всех.</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Второй аргумент может быть хеш-ссылкой с параметрами, которые идентичны аргументам, переданным в &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">Второй аргумент - регулярное выражение. Это может быть ссылка на регулярное выражение (например, &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ) или (для лучшей совместимости со старыми perls) как строка, которая выглядит как регулярное выражение (альтернативные разделители в настоящее время не поддерживаются):</target>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">Второй аргумент считается регексом,если это либо объект регекса,либо строка,которая выглядит как регекс.Регекс-объекты строятся с помощью оператора qr//в последних версиях perl.Строка считается регексом,если ее первый и последний символ-это &quot;/&quot;,или если первый символ-это &quot;m&quot;,а второй и последний символ-это один и тот же не алфавитно-цифровой символ без пробела.Эти регексы</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">Второй аргумент - это другой операнд, или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в случае унарного оператора.</target>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">Второй аргумент используется для обозначения сжатия. Вы можете сжать с помощью &lt;code&gt;gzip&lt;/code&gt; или &lt;code&gt;bzip2&lt;/code&gt; . Если вы передаете цифру, предполагается, что это уровень сжатия &lt;code&gt;gzip&lt;/code&gt; (от 1 до 9), но использование констант предпочтительнее:</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">Второй аргумент можно считать необязательным,но он остается для обратной совместимости.Archive::Tar теперь смотрит на магию файла,чтобы определить,какой класс должен быть использован для открытия файла,и прозрачно делает правильную вещь.</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">Второй аргумент указывает на массив, содержащий &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; . Как только AV был создан, SV при желании можно уничтожить.</target>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">Второй вызов функции hex()предупредит о неподвижной константе.</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">Второй обратный вызов является необязательным, если обратный вызов зарегистрирован до вызова $ term-&amp;gt; readline.</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">Второй зарегистрированный обратный звонок-это обратный звонок для регистрации.Входная файловая ручка (часто STDIN,но не обязательно)будет передана.</target>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">Вторая колонка-тип возврата,третья-имя.Следующие столбцы-аргументы.Первый столбец-это набор флагов:</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">Второй пример в синопсисе делает нечто эквивалентное этому:</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">Во втором примере печатаются записи с именами &lt;code&gt;foo&lt;/code&gt; , а также записи с именами, которые заканчиваются на &lt;code&gt;bar&lt;/code&gt; или короче 5 символов.</target>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">Вторая точка выхода проверяет, остались ли какие-либо данные во входном буфере, &lt;code&gt;$input&lt;/code&gt; - помните, что опция &lt;code&gt;ConsumeInput&lt;/code&gt; автоматически включается при использовании &lt;code&gt;LimitOutput&lt;/code&gt; . Когда входной буфер исчерпан, внешний цикл может запуститься снова и перезаписать теперь пустой &lt;code&gt;$input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">Вторая форма позволяет фильтру удерживать информацию о состоянии,используя,таким образом,закрытие:</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">Вторая форма настоятельно не рекомендуется,так как она нарушает способность подкласса повторно использовать конструктор родителя,но вы все равно можете столкнуться с ней в существующем коде.</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">Вторая форма ограничивает или расширяет выходную мощность с помощью глобуса оболочки,как в следующих примерах:</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">Вторая форма принимает в качестве аргумента строку ASCII,состоящую из символов &quot;0&quot; и &quot;1&quot;.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">Вторая форма для удобства просто вызывает &lt;code&gt;new&lt;/code&gt; метод для своих аргументов перед немедленным сбросом объекта.</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">Второй дает данные о том,сколько клавиш находится на каждой глубине цепочки,и дает представление о том,сколько работы займет fetch *hit*.Производительность для обновления или удаления элемента в хэше эквивалентна этому случаю.</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">Второй -</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">Второй вопросительный знак &lt;code&gt;?&lt;/code&gt; для соответствия любому одиночному символу. Третий определяет конкретный набор символов.</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">Вторая,короче говоря,более читабельная.В частности,очевидно,что количество параметров,которые вы передаете этой фразе (два),это количество параметров,которые она</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">Второй метод как создает AV,так и изначально заполняет его SV:</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">Второй метод разделяет сгенерированный код на</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">Второй новый параметр отображения - &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , который может иметь значение true или false, значение по умолчанию - true. См. Предыдущий раздел, чтобы узнать, что это означает.</target>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">Второй вариант - явно указать Configure на обнаружение новой установки Berkeley DB, &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; правильные каталоги с -Dlocincpth = / some / include и &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;и&lt;/b&gt; перед запуском команды make test, установив для LD_LIBRARY_PATH значение</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">Второй параметр, &lt;code&gt;$mode&lt;/code&gt; , используется, чтобы указать, открыт ли файл для чтения или записи, а также, при необходимости, указать уровень сжатия и стратегию сжатия при записи. Формат параметра &lt;code&gt;$mode&lt;/code&gt; аналогичен параметру mode функции &lt;code&gt;fopen&lt;/code&gt; 'C' , поэтому &quot;rb&quot; используется для открытия для чтения, &quot;wb&quot; для записи и &quot;ab&quot; для добавления (запись в конце файл).</target>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">Второе регулярное выражение не соответствует, потому что &lt;code&gt;^&lt;/code&gt; ограничивает &lt;code&gt;keeper&lt;/code&gt; совпадением только в начале строки, но &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; имеет keeper, начиная с середины. Третье регулярное выражение совпадает, поскольку &lt;code&gt;$&lt;/code&gt; ограничивает &lt;code&gt;keeper&lt;/code&gt; совпадением только в конце строки.</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">Второй возвращенный товар и &lt;code&gt;$!&lt;/code&gt; может использоваться для проверки правильности ввода:</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">Второе предложение неверно. Фактически, bval по умолчанию будет иметь значение &lt;code&gt;&quot;\n&quot;&lt;/code&gt; тогда, когда параметр openinfo в dbopen равен NULL. Если вообще используется параметр openinfo, отличный от NULL, будет использоваться значение, которое находится в bval. Это означает, что вы всегда должны указывать bval при использовании любой из опций в параметре openinfo. Эта ошибка документации будет исправлена ​​в следующем выпуске Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">Вторая ситуация вызвана тем,что оценщик обращается к лексической подпрограмме,которая,например,вышла из-под контроля,</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">Вторая ситуация вызвана,например,оценочным доступом к переменной,которая вышла из-под контроля,</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">Второй стиль комплектации снимает это ограничение.Оно может быть включено:</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">Второе значение,которое должно быть подставлено в выходную строку (обычно это строка в возможностях адресации курсора)</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">Второй,более эффективный способ-использовать следующий шаблон для ваших Foo.xs:</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">Раздел (он же &amp;laquo;элемент&amp;raquo; в старых модулях perlpods) или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если его нет. Например, в &amp;laquo;L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&amp;raquo; &amp;laquo;ОПИСАНИЕ&amp;raquo; - это раздел. (Обратите внимание, что это не то же самое, что раздел справочной страницы, такой как &amp;laquo;5&amp;raquo; в &amp;laquo;man 5 crontab&amp;raquo;. &amp;laquo;Раздел Foo&amp;raquo; в смысле Pod означает часть текста, которая вводится заголовком или элементом с текстом &amp;laquo;Foo&amp;raquo;. &quot;.)</target>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">Особое внимание уделяется аспекту безопасности создания временного файла, так что дескриптор файла и имя файла возвращаются вместе. Это помогает гарантировать, что состояние гонки не может возникнуть, если временный файл создается другим процессом между проверкой существования файла и его открытием. Дополнительные уровни безопасности предусмотрены для проверки, например, того, что бит закрепления установлен в каталогах, доступных для записи во всем мире. См. &lt;a href=&quot;#safe_level&quot;&gt;Safe_level&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">На первый взгляд эквивалентная конструкция в Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; сначала выполняет deref для $ aref, заставляя его использовать $ aref как ссылку на массив, а затем разыменовывает это и, наконец, сообщает вам</target>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">Семантика интервальных таймеров для многопоточных программ зависит от системы, и некоторые системы могут поддерживать дополнительные интервальные таймеры. Например, не указано, какой поток получает сигналы. См. &lt;code&gt;setitimer()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">Смысл совпадения можно изменить, используя оператор &lt;code&gt;!~&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">Последовательность &lt;code&gt;\b&lt;/code&gt; является особенной внутри класса символов в квадратных скобках. Находясь за пределами класса символов, &lt;code&gt;\b&lt;/code&gt; является утверждением, указывающим на точку, которая не имеет ни двух символов слова, ни двух символов не слов с обеих сторон, внутри класса символов в квадратных скобках &lt;code&gt;\b&lt;/code&gt; соответствует символу возврата.</target>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">Номер последовательности следующей операционной.</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">Номер последовательности ОП,или дефис,если его нет.</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">Номер последовательности ОП.Обратите внимание,что это порядковый номер,генерируемый B::Кратко.</target>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">Последовательности &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; и &lt;code&gt;\x&lt;/code&gt; также являются специальными и имеют те же значения, что и делать вне класса символов в квадратных скобках.</target>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">Сериализующий крюк,вызванный на объект во время сериализации.Как и любой другой метод,он может быть наследуемым или определяться в самом классе.</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">Имя сервиса,поставляемое для getaddrinfo(),недоступно для типа сокета,указанного в $hints.</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">Сервисы, которые часть кода обещает предоставлять вечно, в отличие от его &lt;b&gt;реализации&lt;/b&gt; , которую он может свободно изменять, когда захочет.</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">Набор задается как список символов или как диапазон символов, где начало и конец диапазона разделены знаком минуса (или тире), или как любая комбинация списков и диапазонов. Прочерк также может быть включен в набор как символ, если он является началом или концом набора. Этот набор заключен в квадратные скобки. Закрывающая квадратная скобка &lt;code&gt;]&lt;/code&gt; может использоваться в наборе, если это первый символ в наборе.</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">Набор символов,которые считаются пробелами,-это те символы,которые Юникод называет &quot;Пробелом образца&quot;,а именно:</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">Функция setlocale</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">Установка атрибутов подпрограммы происходит во время компиляции. Атрибуты переменных в &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; объявлениях также применяются во время компиляции. Однако атрибуты &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; переменных применяются во время выполнения. Это означает, что вы должны</target>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">Семь маршрутов:</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">Лист</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">Панцирь предлагает войти</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">В &lt;code&gt;test&lt;/code&gt; оболочки используются символы &amp;laquo;=&amp;raquo;, &amp;laquo;! =&amp;raquo;, &amp;laquo;&amp;lt;&amp;raquo; И т. Д. Для сравнения строк и &amp;laquo;-eq&amp;raquo;, &amp;laquo;-ne&amp;raquo;, &amp;laquo;-lt&amp;raquo; и т. Д. Для числовых сравнений. Это обратная Perl, который использует &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; для сравнения строк, а &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; И т.д. для цифровых сравнений.</target>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">Короткий ответ состоит в том, что по умолчанию Perl сравнивает эквивалентность ( &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) только на основе кодовых точек символов. В приведенном выше случае ответ отрицательный (потому что 0x00C1! = 0x0041). Но иногда любые ЗАГЛАВНЫЕ БУКВЫ A следует считать равными, или даже A в любом случае.</target>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">Короткий ответ заключается в том, что по умолчанию Perl сравнивает строки ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) только на основе кодовых точек символов. В приведенном выше случае ответ - &amp;laquo;после&amp;raquo;, поскольку &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">Короткое название общей категории</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">Короткая история</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">Коротко говоря, вам, вероятно, следует использовать только определенные для скаляров или функций, а не для агрегатов (массивов и хэшей). См. &lt;a href=&quot;functions/defined&quot;&gt;Определение&lt;/a&gt; Perl в версии 5.004 или более поздней для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">Знак &lt;code&gt;/^[+-]$/&lt;/code&gt; хранится отдельно. Строка &amp;laquo;NaN&amp;raquo; используется для представления результата, когда входные аргументы не являются числами, а также результата деления на ноль.</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">Знак '+','-','NaN','+inf' или '-inf' и хранится отдельно.Доступ к нему можно получить с помощью метода sign().</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">Знак '+','-','NaN','+inf' или '-inf'.</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">Знак '+','-','NaN','+inf' или '-inf'.Вы можете получить доступ к нему с помощью метода sign().</target>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">Подпись является частью тела подпрограммы.Обычно тело подпрограммы-это просто сплетенный блок кода.При использовании подписи подпись представляет собой заключенный в круглые скобки список,который идет сразу после имени подпрограммы.Подпись объявляет лексические переменные,которые находятся в области действия блока.При вызове подпрограмм сначала подпись получает управление.Она заполняет переменные сигнатуры из списка переданных аргументов.Если список аргументов не удовлетворяет требованиям сигнатуры,то она бросает исключение.Когда обработка сигнатуры завершена,управление передается блоку.</target>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">Значение каждого из них будет объяснено в остальной части урока,но пока важно только знать,что метахарактер может быть сопоставлен,поставив перед ним обратную косую черту:</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">Свойство с аналогичным названием &lt;code&gt;\p{Punct}&lt;/code&gt; соответствует несколько другому набору в диапазоне ASCII, а именно &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . То есть в нем отсутствуют девять символов &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . Это связано с тем, что Unicode разделяет то, что POSIX считает пунктуацией, на две категории: пунктуация и символы.</target>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">Простое правило: наследование не будет работать при автозагрузке не-методов. Простое исправление для старого кода: в любом модуле, который раньше зависел от наследования &lt;code&gt;AUTOLOAD&lt;/code&gt; для не-методов от базового класса с именем &lt;code&gt;BaseClass&lt;/code&gt; , выполните &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; во время запуска.</target>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">Простая студийная реализация создает файлы</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">Самые простые XSUB состоят из 3 частей:описание возвращаемого значения,имя рутины XSUB и имена ее аргументов,а также описание типов или форматов аргументов.</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">Самый простой случай - целые числа. Они состоят из последовательности цифр с необязательным знаком спереди. Цифры, которые мы можем представить с помощью &lt;code&gt;\d+&lt;/code&gt; а знак можно сопоставить с помощью &lt;code&gt;[+-]&lt;/code&gt; . Таким образом, целочисленное регулярное выражение равно</target>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">Самый простой метод использует функцию &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; . Он может дополнять слева или справа пробелами и слева нулями, и это не приведет к усечению результата. Функция &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; может &lt;code&gt;$pad_len&lt;/code&gt; пробелами только строки справа, и она усекает результат до максимальной длины $ pad_len .</target>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">Самый простой регекс-это просто слово или,более широко,строка символов.Регекс,состоящий из слова,соответствует любой строке,содержащей это слово:</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">Самый простой регэкспресс-это просто слово или,более широко,строка символов.Регеxp,состоящий из слова,соответствует любой строке,содержащей это слово:</target>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">Простейший стиль комплектации может быть включен:</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">Простейшая двухуровневая структура данных для встраивания в Perl представляет собой массив массивов,иногда случайно называемый списком.Его довольно легко понять,и почти все,что здесь применимо,также будет применено позже к более прихотливым структурам данных.</target>
        </trans-unit>
        <trans-unit id="6e9b91e3cec9f10bb3ce35088b75f0be6c8e9b0d" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt; : this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt; s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt; s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt; , which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt; . The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">Самый простой тип структуры op - это &lt;code&gt;OP&lt;/code&gt; : у нее нет дочерних элементов . Унарные операторы &lt;code&gt;UNOP&lt;/code&gt; имеют одного дочернего &lt;code&gt;op_first&lt;/code&gt; на который указывает поле op_first . Бинарные операторы ( &lt;code&gt;BINOP&lt;/code&gt; s) имеют не только поле &lt;code&gt;op_first&lt;/code&gt; , но также поле &lt;code&gt;op_last&lt;/code&gt; . Самый сложный тип операции - это &lt;code&gt;LISTOP&lt;/code&gt; , у которого есть любое количество потомков. В этом случае на первый дочерний &lt;code&gt;op_first&lt;/code&gt; указывает op_first, а на последний дочерний &lt;code&gt;op_last&lt;/code&gt; - op_last . &lt;code&gt;OpSIBLING&lt;/code&gt; можно найти, итеративно следуя указателю OpSIBLING от первого дочернего элемента к последнему (но см. Ниже).</target>
        </trans-unit>
        <trans-unit id="2054b09e7b3505e051c925e118baa9402ac5d4ec" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is:</source>
          <target state="translated">Самый простой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="388dab005124e81f16d269b4ee944aa3b8003908" translate="yes" xml:space="preserve">
          <source>The simplest way to use this library is to import the md5_hex() function (or one of its cousins):</source>
          <target state="translated">Самый простой способ использования этой библиотеки-это импорт функции md5_hex()(или одного из ее кузеновов):</target>
        </trans-unit>
        <trans-unit id="5ecd63cfa076538859f9d50a754ce0ea42b734ec" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt; :</source>
          <target state="translated">Самый простой и понятный способ создать поток - использовать &lt;code&gt;create()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="142891f6dfc36054413e16ddc5cd0b102274ac48" translate="yes" xml:space="preserve">
          <source>The single parameter &lt;code&gt;cb1&lt;/code&gt; is a pointer to a function, so you must have defined &lt;code&gt;cb1&lt;/code&gt; in your code, say something like this</source>
          <target state="translated">Единственный параметр &lt;code&gt;cb1&lt;/code&gt; - это указатель на функцию, поэтому вы должны определить &lt;code&gt;cb1&lt;/code&gt; в своем коде, скажем что-то вроде этого</target>
        </trans-unit>
        <trans-unit id="c390613e0b451f9ebc65ddd44ea3f2cbf88c23f5" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a list of values rather than a single value. Functions that want a</source>
          <target state="translated">Ситуация, в которой окружение (вызывающий его код) ожидает, что &lt;b&gt;выражение&lt;/b&gt; вернет список значений, а не одно значение. Функции, которые хотят</target>
        </trans-unit>
        <trans-unit id="d86701b02acab027c0d49bd429316b14b358d71d" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a single &lt;b&gt;value&lt;/b&gt; rather than a &lt;b&gt;list&lt;/b&gt; of values. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;list context&lt;/b&gt;. A scalar context sometimes imposes additional constraints on the return value&amp;mdash;see &lt;b&gt;string context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;. Sometimes we talk about a &lt;b&gt;Boolean context&lt;/b&gt; inside conditionals, but this imposes no additional constraints, since any scalar value, whether numeric or &lt;b&gt;string&lt;/b&gt;, is already true or false.</source>
          <target state="translated">Ситуация, в которой окружение (вызывающий его код) ожидает, что &lt;b&gt;выражение&lt;/b&gt; вернет одно &lt;b&gt;значение,&lt;/b&gt; а не &lt;b&gt;список&lt;/b&gt; значений. См. Также &lt;b&gt;контекст&lt;/b&gt; и &lt;b&gt;контекст списка&lt;/b&gt; . Скалярный контекст иногда накладывает дополнительные ограничения на возвращаемое значение - см. &lt;b&gt;Контекст строки&lt;/b&gt; и &lt;b&gt;числовой контекст&lt;/b&gt; . Иногда мы говорим о &lt;b&gt;логическом контексте&lt;/b&gt; внутри условных выражений, но это не налагает дополнительных ограничений, поскольку любое скалярное значение, будь то числовое или &lt;b&gt;строковое&lt;/b&gt; , уже истинно или ложно.</target>
        </trans-unit>
        <trans-unit id="5bf519df1d56695e3fe7b5f2cac71014a6a10291" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a &lt;b&gt;string&lt;/b&gt;. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;.</source>
          <target state="translated">Ситуация, в которой окружение (вызывающий его код) ожидает, что выражение вернет &lt;b&gt;строку&lt;/b&gt; . См. Также &lt;b&gt;контекст&lt;/b&gt; и &lt;b&gt;числовой контекст&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d5278b812a3307d0ee6951ce2678ae1eab81add9" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a number. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;string context&lt;/b&gt;.</source>
          <target state="translated">Ситуация, в которой окружение (вызывающий его код) ожидает, что выражение вернет число. См. Также &lt;b&gt;контекст&lt;/b&gt; и &lt;b&gt;контекст строки&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1778a01cc57bbb1bfba8f72e778c79445c3a36bf" translate="yes" xml:space="preserve">
          <source>The situation is even less clear for tools such as MakeMaker that can be used to install additional modules into non-standard places. For example, if a user intends to install a module into a private directory (perhaps by setting &lt;code&gt;PREFIX&lt;/code&gt; on the</source>
          <target state="translated">Еще менее ясна ситуация с такими инструментами, как MakeMaker, которые можно использовать для установки дополнительных модулей в нестандартные места. Например, если пользователь намеревается установить модуль в частный каталог (возможно, установив &lt;code&gt;PREFIX&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="9a9c38132104cf7801e22419b38670f4a24614fb" translate="yes" xml:space="preserve">
          <source>The situation where this is necessary, is presumably quite rare.</source>
          <target state="translated">Ситуация,когда это необходимо,предположительно,достаточно редкая.</target>
        </trans-unit>
        <trans-unit id="5a9a5af0a6298739507c5ced21852b79711a0a57" translate="yes" xml:space="preserve">
          <source>The situation with matching Unicode properties in regular expressions, the &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</source>
          <target state="translated">Ситуация с сопоставлением свойств Unicode в регулярных выражениях, конструкциях &lt;code&gt;\p{}&lt;/code&gt; и &lt;code&gt;\P{}&lt;/code&gt; с этими кодовыми точками не так однозначна, и то, как они обрабатываются, изменилось по мере накопления опыта.</target>
        </trans-unit>
        <trans-unit id="88e6088a9ab77ba2f6a1ec54ad364f7fffa87f43" translate="yes" xml:space="preserve">
          <source>The size of the file will be determined, and sent to the server automatically for normal files so that this method need only be called if you are transferring data from a socket, named pipe, or other stream not associated with a normal file.</source>
          <target state="translated">Размер файла будет определен и автоматически отправлен на сервер для обычных файлов,так что этот метод нужно вызывать только в том случае,если вы передаете данные из сокета,именованного канала или другого потока,не связанного с обычным файлом.</target>
        </trans-unit>
        <trans-unit id="87d9309a72cdac9a52fd9593050f47fe997d18b5" translate="yes" xml:space="preserve">
          <source>The size of the per-instance data structure, e.g.:</source>
          <target state="translated">Размер структуры данных по каждому экземпляру,например:</target>
        </trans-unit>
        <trans-unit id="5877446a070972ed92cd79aed206f27b2111d714" translate="yes" xml:space="preserve">
          <source>The size of the pieces you&amp;rsquo;re dealing with, mentally speaking.</source>
          <target state="translated">Размер частей, с которыми вы имеете дело, мысленно говоря.</target>
        </trans-unit>
        <trans-unit id="1656b4f2fdda6835a902c9679ea0caaf9c6c13e1" translate="yes" xml:space="preserve">
          <source>The size specifier &lt;code&gt;V&lt;/code&gt; has no effect for Perl code, but is supported for compatibility with XS code. It means &quot;use the standard size for a Perl integer or floating-point number&quot;, which is the default.</source>
          <target state="translated">Спецификатор размера &lt;code&gt;V&lt;/code&gt; не влияет на код Perl, но поддерживается для совместимости с кодом XS. Это означает &amp;laquo;использовать стандартный размер для целого числа Perl или числа с плавающей запятой&amp;raquo;, который является значением по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0b86c8f6fcdbd6b3e5e7fca2359cdc4a25ce8c43" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Пропущенный префикс (т.е. символы перед извлеченной строкой). В случае неудачи возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cca8448b9d4d7f08ec6d38447f60e1a5ccb09b43" translate="yes" xml:space="preserve">
          <source>The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The mis(sing)configuration of the whole system's locales usually requires the help of your friendly system administrator.</source>
          <target state="translated">Более медленное,но превосходное исправление-это когда вы можете сами исправить неправильную настройку собственных переменных окружения.Неправильная настройка локалей всей системы обычно требует помощи дружелюбного системного администратора.</target>
        </trans-unit>
        <trans-unit id="0fbe962e06d42462e7c0e18bd04f3db25354c94a" translate="yes" xml:space="preserve">
          <source>The smaller and more localized the change, the better. Similarly, a series of small patches is greatly preferred over a single large patch.</source>
          <target state="translated">Чем меньше и локальнее изменения,тем лучше.Аналогичным образом,серия маленьких патчей является более предпочтительной,чем один большой патч.</target>
        </trans-unit>
        <trans-unit id="f4b9fc3a5444ff6c99460c86f0eae40188849994" translate="yes" xml:space="preserve">
          <source>The smallest individual element of a string. Computers store characters as integers, but Perl lets you operate on them as text. The integer used to represent a particular character is called that character&amp;rsquo;s &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">Наименьший отдельный элемент строки. Компьютеры хранят символы как целые числа, но Perl позволяет работать с ними как с текстом. Целое число, используемое для представления определенного символа, называется &lt;b&gt;кодовой точкой&lt;/b&gt; этого символа .</target>
        </trans-unit>
        <trans-unit id="743692cb1b17807cb7e732ecae2c349fdebd6008" translate="yes" xml:space="preserve">
          <source>The smart match stops when it finds a match, so it doesn't have to try every expression.</source>
          <target state="translated">Умное совпадение останавливается,когда находит совпадение,так что не нужно пробовать каждое выражение.</target>
        </trans-unit>
        <trans-unit id="936144db8d649469afd4d348dac4550c6a90cbd0" translate="yes" xml:space="preserve">
          <source>The smartmatch implicitly dereferences any non-blessed hash or array reference, so the &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; entries apply in those cases. For blessed references, the &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; entries apply. Smartmatches involving hashes only consider hash keys, never hash values.</source>
          <target state="translated">Smartmatch неявно разыменовывает любой неблаженный хэш или ссылку на массив, поэтому в этих случаях применяются записи &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; и &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; . Блаженны ссылки на &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; позиции применяются. В интеллектуальных матчах с участием хешей учитываются только хеш-ключи, а не хеш-значения.</target>
        </trans-unit>
        <trans-unit id="d02f6728ba4dcd43d024dc500f10ccfe28692eeb" translate="yes" xml:space="preserve">
          <source>The smartmatch operator is most often used as the implicit operator of a &lt;code&gt;when&lt;/code&gt; clause. See the section on &quot;Switch Statements&quot; in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">Оператор smartmatch чаще всего используется как неявный оператор предложения &lt;code&gt;when&lt;/code&gt; . См. Раздел &amp;laquo;Операторы переключения&amp;raquo; в &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="538eac64870e76a04cefadec7560ac9099d4a644" translate="yes" xml:space="preserve">
          <source>The socket tests may fail if the network is not configured. You have to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving it the right arguments. Try &quot;/hurd/pfinet --help&quot; for more information.</source>
          <target state="translated">Тесты сокетов могут быть неудачными,если сеть не сконфигурирована.Вы должны сделать &quot;/hurd/pfinet&quot; переводчиком для &quot;/servers/socket/2&quot;,дав ему правильные аргументы.Попробуйте &quot;/hurd/pfinet --help&quot; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="127dbba60bbfba8c121a95d45a5b1267637cec67" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</source>
          <target state="translated">Тип сокета (например, &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d10c516fba6283faccc420f0f1f0ddca597fd882" translate="yes" xml:space="preserve">
          <source>The sole purpose of this module is to enable colour highlighting from the command line.</source>
          <target state="translated">Единственное предназначение этого модуля-включение цветовой подсветки из командной строки.</target>
        </trans-unit>
        <trans-unit id="165006648b6cdcfa730ff63bd97b9430605a3ca6" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">Решение состоит в том, чтобы удалить &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; из дочернего каталога в место за пределами дерева каталогов.</target>
        </trans-unit>
        <trans-unit id="8bd1e61d4eb0bbe0f75b3581782eef3e8dfaf4b4" translate="yes" xml:space="preserve">
          <source>The sort of characters we put into words. In Unicode, this is all letters including all ideographs and certain diacritics, letter numbers like Roman numerals, and various combining marks.</source>
          <target state="translated">Своего рода символы,которые мы вкладываем в слова.В Юникоде это все буквы,включая все идеографы и определенные диакритические знаки,буквенные числа,такие как римские цифры,и различные комбинированные знаки.</target>
        </trans-unit>
        <trans-unit id="a1d44ffc9ae032aff54b02af9e8455f31b34d012" translate="yes" xml:space="preserve">
          <source>The sort order will cause differences between results obtained on ASCII platforms versus EBCDIC platforms. What follows are some suggestions on how to deal with these differences.</source>
          <target state="translated">Порядок сортировки приведет к различиям между результатами,полученными на ASCII-платформах и EBCDIC-платформах.Ниже приведены некоторые предложения по устранению этих различий.</target>
        </trans-unit>
        <trans-unit id="89da5c4101906ac148b9121db995bfdaa11ef39f" translate="yes" xml:space="preserve">
          <source>The source buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">Буфер источника может быть как скалярным,так и скалярным.</target>
        </trans-unit>
        <trans-unit id="67687b08f8914b53b7f3846fac38e3b4363d7a5e" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt; , can either be a scalar or a scalar reference.</source>
          <target state="translated">Исходный буфер &lt;code&gt;$source&lt;/code&gt; может быть скалярной или скалярной ссылкой.</target>
        </trans-unit>
        <trans-unit id="1b7e9fa2ae5c5f428ffd5cfef77286b08b69792f" translate="yes" xml:space="preserve">
          <source>The source code for an extension usually resides in its own directory. At least three files are generally provided:</source>
          <target state="translated">Исходный код расширения обычно находится в собственном каталоге.Обычно предоставляется как минимум три файла:</target>
        </trans-unit>
        <trans-unit id="1e4ee98da0c8794c248be818bce3b87507488dbe" translate="yes" xml:space="preserve">
          <source>The source code includes multiple hash algorithms to choose from. While we believe that the default perl hash is robust to attack, we have included the hash function Siphash as a fall-back option. At the time of release of Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is not the default as it is much slower than the default hash.</source>
          <target state="translated">Исходный код включает в себя несколько хэш-алгоритмов на выбор.Хотя мы считаем,что perl хэш по умолчанию робастен для атаки,мы включили хэш-функцию Siphash в качестве опции отката.На момент выхода Perl 5.18.0 Siphash считался криптографически устойчивым.Это не по умолчанию,так как это намного медленнее,чем хэш по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d0caf29be420bbd199849ea512093a83580509aa" translate="yes" xml:space="preserve">
          <source>The source code locations are supported &lt;b&gt;only&lt;/b&gt; if you have the Developer Tools installed. (BFD is &lt;b&gt;not&lt;/b&gt; needed.)</source>
          <target state="translated">Расположение исходного кода поддерживается, &lt;b&gt;только&lt;/b&gt; если у вас установлены Инструменты разработчика. (BFD &lt;b&gt;не&lt;/b&gt; нужен.)</target>
        </trans-unit>
        <trans-unit id="edb2a3de91b362ca2b61febe5041a5a32501556d" translate="yes" xml:space="preserve">
          <source>The source code repository for Test::More can be found at</source>
          <target state="translated">Хранилище исходных кодов для Test::More можно найти по адресу</target>
        </trans-unit>
        <trans-unit id="449ffcdb319b9addd8fd6dc6fc9226340b95b72f" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt; . Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">В дистрибутив исходного фильтра входят два модуля, которые упрощают эту задачу: &lt;code&gt;Filter::exec&lt;/code&gt; и &lt;code&gt;Filter::sh&lt;/code&gt; . Оба позволяют запускать любой внешний исполняемый файл. Оба используют сопроцесс для управления потоком данных во внешний исполняемый файл и из него. (Подробнее о сопроцессах см. Stephens, WR, &amp;laquo;Advanced Programming in the UNIX Environment.&amp;raquo; Addison-Wesley, ISBN 0-210-56317-7, страницы 441-445.) Разница между ними в том, что &lt;code&gt;Filter::exec&lt;/code&gt; порождает внешнюю команду напрямую, а &lt;code&gt;Filter::sh&lt;/code&gt; порождает оболочку для выполнения внешней команды. (Unix использует оболочку Bourne; NT использует оболочку cmd.) Создание оболочки позволяет вам использовать метасимволы оболочки и средства перенаправления.</target>
        </trans-unit>
        <trans-unit id="ea0efb50a1d96794619b6be6780ccfe01a3a3f70" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt; :</source>
          <target state="translated">Перед тем, как что-либо анализировать, необходимо установить источник. Самый низкоуровневый способ - вызвать &lt;code&gt;set_source&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="30a7a830852a264986b70187999506a317874b7f" translate="yes" xml:space="preserve">
          <source>The source of ISO 3166-1 two-letter codes used by this module.</source>
          <target state="translated">Источник двубуквенных кодов по ISO 3166-1,используемых данным модулем.</target>
        </trans-unit>
        <trans-unit id="26888526042c45b79818c80cb5da539324a9402b" translate="yes" xml:space="preserve">
          <source>The source of the official ISO 3166-1 three-letter codes and three-digit codes.</source>
          <target state="translated">Источник официальных трехбуквенных и трехзначных кодов ИСО 3166-1.</target>
        </trans-unit>
        <trans-unit id="454a907e32531c807293e3735238b43baf267920" translate="yes" xml:space="preserve">
          <source>The special argument of &lt;code&gt;h h&lt;/code&gt; produces the entire help page, which is quite long.</source>
          <target state="translated">Специальный аргумент &lt;code&gt;h h&lt;/code&gt; создает всю страницу справки, которая довольно длинная.</target>
        </trans-unit>
        <trans-unit id="c6f65c11625ca6f6efd4fce69ae54247f9d5fb65" translate="yes" xml:space="preserve">
          <source>The special bookkeeping Perl does to track the flow of external data through your program and disallow their use in system commands.</source>
          <target state="translated">Специальный бухгалтерский Perl делает это для того,чтобы отслеживать поток внешних данных через вашу программу и запретить их использование в системных командах.</target>
        </trans-unit>
        <trans-unit id="fbeef28b2f2c3763e9cdd6d44783f63733b4347f" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; . Some examples are</source>
          <target state="translated">Специальный символ &lt;code&gt;'-'&lt;/code&gt; действует как оператор диапазона в классах символов, так что непрерывный набор символов может быть записан как диапазон. С диапазонами громоздкие &lt;code&gt;[0123456789]&lt;/code&gt; и &lt;code&gt;[abc...xyz]&lt;/code&gt; становятся стройными &lt;code&gt;[0-9]&lt;/code&gt; и &lt;code&gt;[a-z]&lt;/code&gt; . Некоторые примеры</target>
        </trans-unit>
        <trans-unit id="3a71b165b4e188832e186d5361505b47059b1afc" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; :</source>
          <target state="translated">Специальный символ &lt;code&gt;'-'&lt;/code&gt; действует как оператор диапазона в классах символов, так что громоздкие &lt;code&gt;[0123456789]&lt;/code&gt; и &lt;code&gt;[abc...xyz]&lt;/code&gt; становятся стройными &lt;code&gt;[0-9]&lt;/code&gt; и &lt;code&gt;[a-z]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1d9d9306fb9aa515c3bd892587a0587d3baf9f6" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">Специальный символ &lt;code&gt;^&lt;/code&gt; в первой позиции класса символов обозначает</target>
        </trans-unit>
        <trans-unit id="8afc59f37c7b54c4d8a636841474cf58beb13e84" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a &lt;b&gt;negated character class&lt;/b&gt;, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">Специальный символ &lt;code&gt;^&lt;/code&gt; в первой позиции класса символов обозначает &lt;b&gt;инвертированный класс символов&lt;/b&gt; , который соответствует любому символу, кроме символов в скобках. И &lt;code&gt;[...]&lt;/code&gt; , и &lt;code&gt;[^...]&lt;/code&gt; должны соответствовать символу, иначе совпадение не будет выполнено. затем</target>
        </trans-unit>
        <trans-unit id="94d7fdb99f703e5dc3a7ffcb7bb005616b504881" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt; . Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">Специальный дескриптор файла, который перебирает имена файлов командной строки в &lt;code&gt;@ARGV&lt;/code&gt; . Обычно записывается как нулевой дескриптор файла в операторе угла &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Обратите внимание, что в настоящее время &lt;code&gt;ARGV&lt;/code&gt; имеет магический эффект только внутри оператора &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ; в другом месте это просто простой дескриптор файла, соответствующий последнему файлу, открытому &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . В частности, передача &lt;code&gt;\*ARGV&lt;/code&gt; в качестве параметра функции, которая ожидает дескриптор файла, может не привести к тому, что ваша функция автоматически прочитает содержимое всех файлов в &lt;code&gt;@ARGV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f805e5a7fa6e6a7379f92a69ce80440a9d42a7c7" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt; . See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">Специальный дескриптор файла, который указывает на текущий открытый выходной файл при выполнении обработки на месте с &lt;b&gt;-i&lt;/b&gt; . Полезно, когда вам нужно много вставлять и вы не хотите продолжать изменять &lt;code&gt;$_&lt;/code&gt; . Смотрите &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; для ключа &lt;b&gt;-i&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="25d2e9e8733979d7b1492fbdd9a7cb623d57628f" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">Специальные литералы __FILE__, __LINE__ и __PACKAGE__ представляют текущее имя файла, номер строки и имя пакета в этой точке вашей программы. __SUB__ дает ссылку на текущую подпрограмму. Их можно использовать только как отдельные токены; они не будут вставлены в строки. Если нет текущего пакета (из-за пустого &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; директива), __PACKAGE__ является неопределенным значением. (Но пустой &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; больше не поддерживается, начиная с версии 5.10.) Вне подпрограммы __SUB__ является неопределенным значением. __SUB__ доступен только в 5.16 или выше, и только с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; декларацией.</target>
        </trans-unit>
        <trans-unit id="6af0b63b67806c6dfb7b9ddb2d398096248ddab4" translate="yes" xml:space="preserve">
          <source>The special mark that tells the operating system it can run this program. There are actually three execute bits under Unix, and which bit gets used depends on whether you own the file singularly, collectively, or not at all.</source>
          <target state="translated">Специальный знак,указывающий операционной системе,что она может запускать эту программу.На самом деле под Unix есть три исполняемых бита,и то,какой бит будет использоваться,зависит от того,являетесь ли вы владельцем файла единичным,коллективным или нет вообще.</target>
        </trans-unit>
        <trans-unit id="6429c59caa249ed4d6719a4eab753f28d6cfd25d" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Специальные методы &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt; и, &lt;code&gt;maybe::next::method&lt;/code&gt; недоступны, пока этот модуль &lt;code&gt;mro&lt;/code&gt; не будет загружен с помощью &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c41f3d15a857df9bc04fff7f6a7434b18442c584" translate="yes" xml:space="preserve">
          <source>The special quoting behavior ignores precedence, and hence may apply to</source>
          <target state="translated">Специальное поведение цитирования игнорирует приоритет и,следовательно,может применяться к</target>
        </trans-unit>
        <trans-unit id="79a2544429fe460799a8292535fcaefc5e4c6c60" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;b&gt;-w&lt;/b&gt; complaints about improper numeric conversions.</source>
          <target state="translated">Специальная строка &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; исключена из &lt;b&gt;-w&lt;/b&gt; жалоб на неправильное преобразование чисел.</target>
        </trans-unit>
        <trans-unit id="026f6dfd3d9c99c5a9bfd6afe8ee0f79daedf36d" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names.</source>
          <target state="translated">Специальный символ &lt;code&gt;__PACKAGE__&lt;/code&gt; содержит текущий пакет, но не может (легко) использоваться для создания имен переменных.</target>
        </trans-unit>
        <trans-unit id="8f36c55aa844c8a0dac4156e30712cffbcd8a9f0" translate="yes" xml:space="preserve">
          <source>The special two-argument form of Perl's open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</source>
          <target state="translated">Специальная двухпараметрическая форма функции Perl open()игнорирует трейлинговые пробелы в именах файлов и выводит режим из некоторых ведущих символов (или трейлингового &quot;|&quot;).В старых версиях Perl это была единственная версия функции open(),поэтому она распространена в старом коде и книгах.</target>
        </trans-unit>
        <trans-unit id="161a5a9075bb6b7595615ee16fc183085e48d829" translate="yes" xml:space="preserve">
          <source>The special value 00 will cause Perl to slurp files in paragraph mode. Any value 0400 or above will cause Perl to slurp files whole, but by convention the value 0777 is the one normally used for this purpose.</source>
          <target state="translated">Специальное значение 00 приводит к тому,что Perl в абзацевом режиме будет слирпировать файлы.Любое значение 0400 или выше приведёт к тому,что Perl перейдёт в режим slurp-файлов целиком,но по общему правилу для этой цели используется значение 0777.</target>
        </trans-unit>
        <trans-unit id="510ff7ba673af9c07da4bdf1546cce9f48d4aa9d" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$#array&lt;/code&gt; tells you the index of the last element of an array:</source>
          <target state="translated">Специальная переменная &lt;code&gt;$#array&lt;/code&gt; сообщает вам индекс последнего элемента массива:</target>
        </trans-unit>
        <trans-unit id="848d9f1e6794b744b742b40d6e30625dbd74dd9d" translate="yes" xml:space="preserve">
          <source>The special variables for formats are a subset of those for filehandles. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for more information about Perl's formats.</source>
          <target state="translated">Специальные переменные для форматов - это подмножество переменных для дескрипторов файлов. См. &lt;a href=&quot;perlform&quot;&gt;Perlform&lt;/a&gt; для получения дополнительной информации о форматах Perl.</target>
        </trans-unit>
        <trans-unit id="d50e7fd9df415ed27a91da10839b57126db4d317" translate="yes" xml:space="preserve">
          <source>The special verbosity level 99 requires to also specify the -sections parameter; then these sections are extracted and printed.</source>
          <target state="translated">Специальный уровень глаголов 99 требует также указать параметр -sections;затем эти сечения извлекаются и распечатываются.</target>
        </trans-unit>
        <trans-unit id="79d7da7f02ba1ece997a8e1f533d9c05c192eb59" translate="yes" xml:space="preserve">
          <source>The specific task here is to sort the 286,525 lines of this file by Response Code, Query, Browser, Referring Url, and lastly Date. One solution might be to use the following code, which iterates over the files given on the command-line.</source>
          <target state="translated">Специфической задачей здесь является сортировка 286,525 строк этого файла по Коду ответа,Запросу,Браузеру,Ссылке на Url и последней Дате.Одним из решений может быть использование следующего кода,который итерирует над файлами,указанными в командной строке.</target>
        </trans-unit>
        <trans-unit id="61bf1ad08824c740b76048cd4f454fa0d05ebcf4" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Спецификация, из которой происходит tar; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">Указанный</target>
        </trans-unit>
        <trans-unit id="0bbf6ce071adc9bbc621e13b2eb0c9adb5ed909d" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;
BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">Указанная подпрограмма фильтрации вызывается каждый раз, когда встречается &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; , и передает весь исходный код после этого вызова, вплоть до следующего &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (или любой другой терминатор, который вы установили) или конец исходного файла, в зависимости от того, что произойдет раньше. По умолчанию &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; вызов должен появляться сам по себе в отдельной строке, иначе он будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="c52324d25d30fa15232ecb990b5648a4dcfeb28a" translate="yes" xml:space="preserve">
          <source>The split function</source>
          <target state="translated">Сплит-функция</target>
        </trans-unit>
        <trans-unit id="ddfcdc05a5251df7fbf9a8a775f1e8025aac3f91" translate="yes" xml:space="preserve">
          <source>The split operator</source>
          <target state="translated">Сплит-оператор</target>
        </trans-unit>
        <trans-unit id="62b2eb8876cf935a6917a946dbc16da0fe289ddf" translate="yes" xml:space="preserve">
          <source>The square brackets explicitly turn a list value into a scalar value, while parentheses do not. So when a parenthesized list is evaluated in a scalar context, the comma is treated like C's comma operator, which throws away the left argument, which is not what you want. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more on this.</source>
          <target state="translated">Квадратные скобки явно превращают значение списка в скалярное значение, а круглые скобки - нет. Поэтому, когда список в скобках оценивается в скалярном контексте, запятая обрабатывается как оператор запятой C, который отбрасывает левый аргумент, а это не то, что вам нужно. См. &lt;a href=&quot;perlref&quot;&gt;Perlref&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="daa1d51a4ab5d5dc2b248180c01a452f38c9d08d" translate="yes" xml:space="preserve">
          <source>The square brackets make a reference to a new array with a</source>
          <target state="translated">Квадратные скобки содержат ссылку на новый массив с параметром a</target>
        </trans-unit>
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">Стабильность этих расширений варьируется в широких пределах.Некоторые из них являются частью основного языка на протяжении многих лет.Другие являются экспериментальными и могут изменяться без предупреждения или полностью удаляться.Проверьте документацию по отдельным функциям,чтобы проверить их текущее состояние.</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">Аргументы стека доступны через макрос &lt;code&gt;ST(n)&lt;/code&gt; , который возвращает &lt;code&gt;n&lt;/code&gt; -й аргумент стека. Аргумент 0 - это первый аргумент, переданный при вызове подпрограммы Perl. Это аргументы &lt;code&gt;SV*&lt;/code&gt; , и их можно использовать везде, где используется &lt;code&gt;SV*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">Размер стека существующих в настоящее время потоков не может быть изменен,поэтому приведенная ниже ошибка приводит к ошибке,описанной выше:</target>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">Стандартные &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; вместе с &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; и &lt;code&gt;bigrat&lt;/code&gt; предоставляют арифметические операции с переменной точностью и перегруженные операторы, хотя в настоящее время они довольно медленные. За счет некоторого места и значительной скорости они избегают обычных ошибок, связанных с представлениями с ограниченной точностью.</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">Стандартный модуль &lt;code&gt;IO::Select&lt;/code&gt; предоставляет более удобный интерфейс для &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; , в основном потому, что он выполняет всю работу с битовой маской за вас.</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">Стандартный модуль &lt;code&gt;IO::Select&lt;/code&gt; предоставляет более удобный интерфейс для &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; , в основном потому, что он выполняет всю работу с битовой маской за вас.</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">Стандартный Perl 5 MRO будет (D, B, A, C). В результате того , что появляется перед &lt;b&gt;C&lt;/b&gt; , даже если &lt;b&gt;C&lt;/b&gt; является подклассом &lt;b&gt;A&lt;/b&gt; . Однако алгоритм C3 MRO производит следующий порядок: (D, B, C, A), который не имеет этой проблемы.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">Стандартный метод Pod :: Parser parse_from_filehandle () принимает до двух аргументов, первый из которых представляет собой дескриптор файла для чтения POD, а второй - дескриптор файла для записи форматированного вывода. Первый по умолчанию - STDIN, если не указан, а второй - по умолчанию STDOUT. Метод parse_from_file () почти идентичен, за исключением того, что его два аргумента - это входные и выходные файлы на диске. См. &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">Стандартный метод Pod :: Simple parse_file () принимает один аргумент, называющий файл POD, из которого нужно читать. По умолчанию вывод отправляется в &lt;code&gt;STDOUT&lt;/code&gt; , но это можно изменить с помощью метода output_fh ().</target>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">Стандартный метод Pod::Simple parse_from_file()принимает до двух аргументов,первый из которых является входным файлом для чтения POD,а второй-файлом для записи отформатированного вывода.</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">Стандартный модуль Tie::RefHash обеспечивает удобный обходной путь.</target>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">Стандартные свойства Unicode, перечисленные ниже, задокументированы в &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; ; Perl_Decimal_Digit задокументирован в &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap () в Unicode :: UCD&lt;/a&gt; . Другие расширения Perl находятся &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;в разделе &amp;laquo;Другие свойства&amp;raquo; в perlunicode&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Стандартный выпуск Perl (поддерживаемый командой разработчиков Perl) распространяется только в виде исходного кода. Вы можете найти последние выпуски на &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">Стандартные разделы страницы руководства:</target>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">Стандартная типовая карта не содержит PerlIO*до perl 5.7,но имеет три потоковых варианта.Использование PerlIO*напрямую не является обратно совместимым,если только вы не предоставляете свою собственную типовую карту.</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">Стандартная карта типов предлагает три варианта PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) и &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). Голый &lt;code&gt;PerlIO *&lt;/code&gt; считаются T_INOUT. Если это имеет значение в вашем коде (см. Ниже, почему это может быть) #define или typedef одно из конкретных имен и используйте его в качестве аргумента или типа результата в вашем XS-файле.</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">Стандартный/определенный по умолчанию список каталогов,в которых dl_findfile()будет искать библиотеки и т.д.Поиск каталогов осуществляется по порядку:$dl_library_path[0],[1],...и т.д.</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">Тайник, связанный с типизированной лексикой. Это возвращает% Foo :: hash для &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">Тайник,в котором была объявлена эта &quot;наша&quot; переменная.</target>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">Биты режима stat(),вероятно,подходят для большинства файлов и каталогов,найденных в вашей системе,потому что мало кто хочет использовать дополнительные возможности,предлагаемые функцией access().Но вы можете столкнуться с неожиданностями,если ваша программа работает в системе,использующей ACL,так как информация stat()не будет отражать реальные права доступа.</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">Оператор &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; не изменяет текущую позицию, но очищает условие конца файла для дескриптора, так что следующий &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; заставляет Perl снова попытаться прочитать что-то.</target>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">Статус 2 указывает на то,что хотя бы один из указанных файлов не содержит</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">Код состояния, возвращаемый из &lt;code&gt;inflate&lt;/code&gt; , вызовет завершение основного цикла обработки, только если это не &lt;code&gt;Z_OK&lt;/code&gt; . Когда &lt;code&gt;LimitOutput&lt;/code&gt; не использовался, статус &lt;code&gt;Z_OK&lt;/code&gt; означает, что достигнут конец потока сжатых данных или произошла ошибка при распаковке.</target>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">Статус затихшего флага также влияет на вывод сообщений об ошибках VMS от ошибок компиляции.Опять же,вы все равно получаете сообщение об ошибке Perl (и код в $STATUS).</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">Статус, возвращаемый последним закрытием канала, командой обратной кавычки ( &lt;code&gt;``&lt;/code&gt; ), успешным вызовом &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; или оператором &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . Это всего лишь 16-битное слово состояния, возвращаемое традиционным системным вызовом Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; (или иначе созданное так, чтобы оно выглядело). Таким образом, значение выхода подпроцесса действительно ( &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ), а &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; дает сигнал, из-за которого процесс умер, а &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; сообщает, был ли дамп ядра.</target>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">Значение статуса, возвращаемое пользовательским методом &lt;code&gt;filter&lt;/code&gt; или анонимной подпрограммой, и функции &lt;code&gt;filter_read&lt;/code&gt; и &lt;code&gt;read_exact&lt;/code&gt; принимают один и тот же набор значений, а именно:</target>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">В справочной странице stdio (3C) отмечается, что для приложений LP32 с помощью fopen () можно открыть только 255 файлов, а в потоке можно использовать только файловые дескрипторы с 0 по 255. Поскольку perl вызывает open (), а затем fdopen (3C) с результирующим файловым дескриптором, perl ограничен до 255 одновременных открытых файлов, даже если используется sysopen (). Если это окажется непреодолимой проблемой, вы можете скомпилировать Perl как приложение LP64, подробности см. В разделе &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Создание LP64 perl&lt;/a&gt; . Также обратите внимание, что ограничение ресурсов по умолчанию для дескрипторов открытых файлов в Solaris составляет 255, поэтому вам придется соответствующим образом изменить свой ulimit или rctl (Solaris 9 и далее).</target>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">Функции хранилища будут &lt;code&gt;croak&lt;/code&gt; если они сталкиваются с такими ссылками, если вы не установите &lt;code&gt;$Storable::forgive_me&lt;/code&gt; в какое-то значение &lt;code&gt;TRUE&lt;/code&gt; . В этом случае фатальное сообщение преобразуется в предупреждение, и вместо него сохраняется некоторая бессмысленная строка.</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">Указатели стренд и патендов должны указывать на байт,следующий за последним символом каждой строки.</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">Строка &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Это говорит Perl использовать пакет &lt;code&gt;NDBM_File&lt;/code&gt; для выполнения функций хэша.)</target>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">Строка &lt;code&gt;$vec&lt;/code&gt; занимает ровно столько битов, сколько ей нужно. Например, если у вас было 16 записей в &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; нужно всего два байта для их хранения (не считая накладных расходов на скалярную переменную).</target>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">Строка &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; имеет шесть графем, но до восьми кодовых точек. Это считается графемой, а не кодом:</target>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">Строка, следующая за тем, что совпадало с последним успешным совпадением с шаблоном (не считая совпадений, скрытых внутри BLOCK или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; заключенных в текущий BLOCK). Пример:</target>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">Струна на вторник,12 декабря 1995 года.</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">Строковый индекс &lt;b&gt;хэша&lt;/b&gt; , используемый для поиска &lt;b&gt;значения,&lt;/b&gt; связанного с этим ключом.</target>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">Строка разбита на части, описанные ШАБЛОНОМ. Каждый фрагмент отдельно преобразуется в значение. Обычно либо строка является результатом &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , либо символы строки представляют собой какую-либо структуру C.</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">Строка разбита на части, описанные ШАБЛОНОМ. Каждый фрагмент отдельно преобразуется в значение. Обычно либо строка является результатом &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , либо символы строки представляют собой какую-либо структуру C.</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">Строка, совпадающая с последним успешным совпадением с шаблоном (не считая совпадений, скрытых в BLOCK или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; заключенных в текущий BLOCK).</target>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">Вывод строки (чисел с плавающей точкой)будет дополнен нулями:</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">В строковом выводе всегда будут удалены начальные и конечные нули и будет пропущен знак плюса. &lt;code&gt;bstr()&lt;/code&gt; всегда будет давать вам форму с десятичной точкой, а &lt;code&gt;bsstr()&lt;/code&gt; (s для научных) дает вам научную нотацию.</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">Строка, предшествующая тому, что совпадало с последним успешным совпадением с шаблоном, не считая совпадений, скрытых в BLOCK или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , заключенных в текущий BLOCK.</target>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">Строковый результат любой операции, использующей информацию о языковом стандарте, испорчен, поскольку языковой стандарт может быть ненадежным. Смотрите &lt;a href=&quot;#SECURITY&quot;&gt;БЕЗОПАСНОСТЬ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">Возвращаемая строка не всегда находится в NFD/NFKD.Может потребоваться переупорядочивание.</target>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">Строка, с которой начинается options. Если постоянной строки недостаточно, см. &lt;code&gt;prefix_pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">Вставляемая строка представлена следующим образом</target>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">Вставляемая строка представлена октетами,начинающимися от</target>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">Вставляемая строка является строковым значением параметра</target>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">Строковое значение &lt;code&gt;$!&lt;/code&gt; это то, что возвращается функцией strerror () CRTL, поэтому она будет включать сообщение VMS для ошибок, специфичных для VMS. Числовое значение &lt;code&gt;$!&lt;/code&gt; - значение &lt;code&gt;errno&lt;/code&gt; , кроме случая, когда errno - EVMSERR, и в этом случае &lt;code&gt;$!&lt;/code&gt; содержит значение vaxc $ errno. Установка &lt;code&gt;$!&lt;/code&gt; всегда устанавливает errno равным указанному значению. Если это значение EVMSERR, оно также устанавливает vaxc $ errno равным 4 (NONAME-F-NOMSG), так что строковое значение &lt;code&gt;$!&lt;/code&gt; не будет отображать сообщение об ошибке VMS до &lt;code&gt;$!&lt;/code&gt; был установлен.</target>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">Строковое значение $data,предоставленное в качестве аргумента,добавляется к сообщению,для которого мы вычисляем дайджест.Возвращаемым значением является сам объект $ctx.</target>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">Функция struct()</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">Структура данных tied()представляет собой ссылку на массив с элементами</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">Пакет stub,входящий в состав дистрибутива perl,позволяет использовать некоторые дополнительные методы:</target>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">Предполагается, что адрес отправителя в опции &lt;code&gt;AUTH&lt;/code&gt; будет в формате, требуемом RFC 2554, в форме, заключенной в кавычки RFC2821 и в кодировке xtext, или &amp;lt;&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">Подпрограмма для &lt;code&gt;'='&lt;/code&gt; не перегружает оператор присваивания Perl: она используется только для того, чтобы мутаторы работали, как описано здесь. (См. &lt;a href=&quot;#Assignments&quot;&gt;Задания&lt;/a&gt; выше.)</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">Подпрограмма для &lt;code&gt;'qr'&lt;/code&gt; используется везде, где объект интерполируется или используется как регулярное выражение, в том числе когда он появляется в правой части оператора &lt;code&gt;=~&lt;/code&gt; или &lt;code&gt;!~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">Подпрограмма для варианта назначения оператора требуется только для возврата результата операции.Допускается изменять значение своего операнда (это безопасно,так как Perl сначала вызывает конструктор копирования),но это необязательно,так как Perl все равно присваивает возвращаемое значение левому операнду.</target>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">Интерфейс подпрограммы имеет преимущество перед интерфейсом констант в том,что в пространство имен экспортируются только две подпрограммы,по сравнению с тридцатью восемью в интерфейсе констант.На обратной стороне,интерфейс констант имеет преимущество лучшей проверки ошибок компиляции,так как неправильно написанные имена цветов или атрибутов в вызовах color()и color()не будут пойманы до выполнения,в то время как неправильно написанные имена констант будут пойманы во время компиляции.Таким образом,загрязните ваше пространство имён почти двумя десятками подпрограмм,которые вы можете даже не использовать так часто,или рискуете получить глупую ошибку,неправильно написав атрибут.В конце концов,это ваш выбор,TMTOWTDI.</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">Подпрограмма принимает до пяти необязательных аргументов:</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">Подпрограмма принимает до четырех необязательных аргументов (тот же набор, что и &lt;code&gt;extract_tagged&lt;/code&gt; , за исключением обрабатываемой строки). Он возвращает ссылку на подпрограмму, которая, в свою очередь, принимает единственный аргумент (текст, из которого нужно извлечь).</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">Подпрограмма принимает до четырех необязательных аргументов:</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">Подпрограмма принимает до двух необязательных аргументов:</target>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">Подпрограммы для &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; и &lt;code&gt;'bool'&lt;/code&gt; могут возвращать любое произвольное значение Perl. Если соответствующая операция для этого значения также перегружена, операция будет вызвана снова с этим значением.</target>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">Подпрограммы должны возвращать специально отформатированную строку,с одной или несколькими строками,разделенными на новые.Каждая строка должна быть одной из следующих:</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">Разделитель подскриптов для эмуляции многомерных массивов.Если вы ссылаетесь на хэш-элемент как</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор подстановки. Смотрите &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор подстановки. Смотрите &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">Подстрока, которая должна быть извлечена, должна появиться в текущей &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; строковой переменной (или в нулевом индексе, если позиция &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; не определена). Другими словами, &lt;code&gt;extract_...&lt;/code&gt; подпрограмм</target>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">Тонкое, но иногда жестокое искусство попытки превратить вашу возможно некорректную программу в действительное &lt;b&gt;синтаксическое дерево&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">Уровень диверсии данного пакета.Значение диверсии происходит от</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">Суперпользователь ( &lt;code&gt;UID&lt;/code&gt; == 0). Также каталог верхнего уровня файловой системы.</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">Поддержка Unicode появилась впервые, начиная с версии Perl v5.6, и более полно реализована в версиях v5.8 и новее. См. &lt;a href=&quot;perluniintro&quot;&gt;Perluniintro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">Поддерживаются платформы Linux и OS X (некоторые *BSD могут работать хотя бы частично,но они еще не протестированы).</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">Удивительно то, что &lt;code&gt;--a&lt;/code&gt; устанавливает параметр &lt;code&gt;a&lt;/code&gt; (из-за автоматического завершения), а не &lt;code&gt;all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">Окружение или окружение. Контекст, задаваемый окружающим кодом, определяет, какие данные должно возвращать конкретное &lt;b&gt;выражение&lt;/b&gt; . Три основных контекста - это контекст &lt;b&gt;списка&lt;/b&gt; , &lt;b&gt;скалярный&lt;/b&gt; и &lt;b&gt;пустой контекст&lt;/b&gt; . Скалярный контекст иногда подразделяется на &lt;b&gt;логический контекст&lt;/b&gt; , &lt;b&gt;числовой контекст&lt;/b&gt; , &lt;b&gt;строковый контекст&lt;/b&gt; и &lt;b&gt;пустой контекст&lt;/b&gt; . Также есть контекст &amp;laquo;безразлично&amp;raquo; (который рассматривается во второй главе Camel &amp;laquo;Биты и куски&amp;raquo;, если вам интересно).</target>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">Функция sv_magic использует &lt;code&gt;how&lt;/code&gt; определения, какая из предопределенных &amp;laquo;волшебных виртуальных таблиц&amp;raquo; должна быть назначена полю &lt;code&gt;mg_virtual&lt;/code&gt; , если таковые имеются . См. Раздел &amp;laquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Волшебные виртуальные столы&lt;/a&gt; &amp;raquo; ниже. &lt;code&gt;how&lt;/code&gt; аргумент также хранится в &lt;code&gt;mg_type&lt;/code&gt; поле. Значение &lt;code&gt;how&lt;/code&gt; следует выбирать из набора макросов &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; , найденных в</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">Оператор switch называется &lt;code&gt;given/when&lt;/code&gt; и доступен только в Perl 5.10 или новее. См. &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Операторы переключения в perlsyn&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">Символ в угловых скобках указывает, например, тип операции; &amp;lt;2&amp;gt; - это BINOP, &amp;lt;@&amp;gt; - LISTOP, а &amp;lt;#&amp;gt; - это PADOP, который используется в многопоточном Perl. (см. &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;аббревиатуры классов OP&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">Таблица символов для пакета хранится в хэше этого имени с двумя добавленными двоеточиями. Таким образом, имя основной таблицы символов - &lt;code&gt;%main::&lt;/code&gt; или &lt;code&gt;%::&lt;/code&gt; для краткости. Точно так же таблица символов для вложенного пакета, упомянутого ранее, называется &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">Таблица символов заполнена именами,похожими на шум линии.</target>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">Для выбора метода сжатия используются символы ZIP_CM_STORE,ZIP_CM_DEFLATE,ZIP_CM_BZIP2 и ZIP_CM_LZMA.</target>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">Синтаксическая позиция между вызовом метода и его аргументами при использовании синтаксиса косвенного вызова объекта. (Слот отличается отсутствием запятой между ним и следующим аргументом.) &lt;code&gt;STDERR&lt;/code&gt; находится здесь в слоте косвенного объекта:</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">Синтаксис</target>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">Синтаксис и поведение аналогичны &lt;code&gt;SKIP: BLOCK&lt;/code&gt; за исключением того, что тесты будут помечены как неуспешные, но необходимо. &lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; интерпретирует их как пройденные.</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">Синтаксис &lt;code&gt;skip&lt;/code&gt; - это единственный возможный вариант, но он все равно довольно запутанный. Просто начните с приведенных выше примеров, и все будет в порядке.</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">Синтаксис входного FileGlob идентичен &lt;code&gt;File::Glob&lt;/code&gt; , за исключением следующего</target>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">Синтаксис для кодирования текстовых строк в бинарные строки так же прост,как и декодирование:</target>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">Синтаксис:</target>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">Проектируемая система большая или,скорее всего,станет большой.</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">&lt;code&gt;File::Copy::syscopy&lt;/code&gt; подпрограмму копирования можно также вызвать непосредственно в VMS и OS / 2 как File :: Copy :: syscopy (или в VMS как &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , которая выполняет фактическую работу для syscopy).</target>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">Дизайн системы уже ориентирован на объект.</target>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">Система игнорирует первую строку и направляет программу на</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">Системное время-это количество времени,которое само ядро потратило на выполнение процедур или системных вызовов от имени данного пользователя процесса.</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">Системное время нулевого цикла может быть немного больше, чем системное время цикла с фактическим кодом, и поэтому разница может оказаться &amp;lt;0.</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">Системные понятия времени суток и календарной даты контролируются различными способами. Не предполагайте, что часовой пояс хранится в &lt;code&gt;$ENV{TZ}&lt;/code&gt; , и даже если это так, не предполагайте, что вы можете контролировать часовой пояс с помощью этой переменной. Не предполагайте ничего о трехбуквенных аббревиатурах часовых поясов (например, что MST будет горным стандартным временем, оно, как известно, означает московское стандартное время). Если вам нужно использовать часовые пояса, выразите их в каком-либо недвусмысленном формате, например в точном смещении количества минут от UTC или в формате часового пояса POSIX.</target>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">В таблице ниже два столбца. Левый столбец содержит конструкции &lt;code&gt;\p{}&lt;/code&gt; для поиска, возможно, им предшествуют упомянутые выше флаги; а в правом столбце содержится информация о них, например описание или синонимы. В таблице показаны как одиночные, так и составные формы для каждого свойства, которое их имеет. Если левый столбец - это короткое имя свойства, в правом столбце будет его более длинное и описательное имя; и если в левом столбце указано самое длинное имя, в правом столбце будет отображаться любое эквивалентное кратчайшее имя, как в простой, так и в составной форме, если это применимо.</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">Файл таблицы должен находиться в</target>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">Таблица методов для всех операций магически кэшируется для хеша таблицы символов для пакета. Кеш становится недействительным во время обработки &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , новых определений функций и изменений в @ISA.</target>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">Таблица интеллектуальных совпадений в &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator в perlop&lt;/a&gt; не идентична таблице , предложенной спецификацией Perl 6, в основном из-за различий между моделями данных Perl 6 и Perl 5, а также из-за того, что спецификация Perl 6 изменилась с тех пор, как Perl 5 начал быстро внедряться. .</target>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="translated">Касательная</target>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">Тарбол можно создать следующим образом:</target>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">Цель состоит в том,чтобы сделать OS/2 одной из лучших поддерживаемых платформ для использования/создания/разработки Perl и</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">Цель ОП,или ничего для нулевой ОП.</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">Шаблон может принимать другой набор правил для каждого используемого ключа.</target>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">Шаблоном может быть любое имя файла с некоторым количеством X,например F.В трейлинге X заменяются уникальными буквенно-цифровыми комбинациями.</target>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">Термин &quot;родной&quot; не так много значит,когда мы говорим о родных целых числах,как это бывает,когда речь идет о родных числах с плавающей точкой.Единственным подтекстом термина &quot;родные&quot; на целые числа является то,что границы максимальных и минимальных поддерживаемых истинных интегральных величин близки к степеням 2.Однако,&quot;родные&quot; числа с плавающей точкой имеют самое фундаментальное ограничение:они могут представлять только те числа,которые при преобразовании в двоичную дробь имеют относительно &quot;короткое&quot; представление.Например,0.9 не может быть представлено &quot;родным&quot; флотом,так как двоичная доля для 0.9 бесконечна:</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">Термин &quot;железнодорожная нормальная форма&quot; является немного эзотерическим,при этом &quot;синтаксисная диаграмма/схемы&quot; или &quot;железнодорожная диаграмма/схемы&quot; являются более распространенными терминами.Тем не менее,он дает полезный ментальный образ регекс-программы:каждый узел можно рассматривать как единицу пути,с одной вилкой и в большинстве случаев с одной точкой выхода (есть кусочки пути,которые вилки,но их статистически не много),и все это образует макет с одной точкой входа и одной точкой выхода.Процесс сопоставления можно представить как машину,которая движется по треку,при этом конкретный маршрут через систему определяется по символам,прочитанным в каждой возможной точке соединения.Автомобиль может упасть с трассы в любой точке,но он может продолжать движение только до тех пор,пока соответствует трассе.</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">Термин &quot;математический&quot; описывает перегруженную реализацию математических операторов.Математические операции поднимают проблему.Рассмотрим код:</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">Термин &amp;laquo;ошибка Unicode&amp;raquo; был применен к несоответствию с кодовыми точками в &lt;code&gt;Latin-1 Supplement&lt;/code&gt; блоке Latin-1 , то есть между 128 и 255. Без указания локали, в отличие от всех других символов или кодовых точек, эти символы могут иметь очень разная семантика в зависимости от действующих правил. (Символы с кодовыми точками выше 255 применяют правила Unicode; тогда как правила для символов ASCII одинаковы как для правил ASCII, так и для правил Unicode.)</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">Скорость терминального вывода битов (часто ошибочно называемая скоростью передачи)для этого терминала-если ее не установить,то будет выдано предупреждение,и по умолчанию она будет равна 9600.</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">Тип терминала, для которого будет использоваться запись termcap - если не &lt;b&gt;указано, по&lt;/b&gt; умолчанию будет $ ENV {TERM}: если это не установлено, &lt;b&gt;Tgetent&lt;/b&gt; будет &lt;b&gt;квакать&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">Завершающая строка может быть идентификатором (словом) или текстом в кавычках. Идентификатор без кавычек работает как двойные кавычки. Между &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и идентификатором не может быть пробела , если идентификатор не указан явно. (Если вы поместите пробел, он будет рассматриваться как нулевой идентификатор, который действителен и соответствует первой пустой строке.) Завершающая строка должна появляться сама по себе (без кавычек и без окружающих пробелов) в завершающей строке.</target>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">Терминатор времени выполнения &lt;code&gt;(?{...})&lt;/code&gt; находится путем временного переключения управления на парсер perl, который должен остановиться в точке, где обнаруживается завершение логической балансировки &lt;code&gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">Тест</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">Тестовый жгут оставляет желать лучшего.Патчи приветствуются.</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">Расширения имени теста. По умолчанию &lt;code&gt;.t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">Тестовый набор намного лучше,но всегда нуждается в улучшении.</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">Тест выйдет с 255.</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">Система тестирования предназначена для использования путем выполнения трехэтапного процесса для каждого теста, который вы хотите протестировать. Этот процесс начинается с использования &lt;code&gt;test_out&lt;/code&gt; и &lt;code&gt;test_err&lt;/code&gt; заранее, чтобы объявить, какой набор тестов, который вы тестируете, будет выводить с помощью &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; в stdout и stderr.</target>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">Испытания</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">Тесты &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; и &lt;code&gt;-z&lt;/code&gt; работают как заявлено. Возвращаемые значения для &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-x&lt;/code&gt; говорят вам, действительно ли вы можете получить доступ к файлу; это может не отражать защиту файлов на основе UIC. Поскольку реальный и действующий UIC не различаются в VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; эквивалентны &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; и &lt;code&gt;-x&lt;/code&gt; . Кроме, несколько других тестов, включая &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; и &lt;code&gt;-u&lt;/code&gt; , не являются особенно значимыми при VMS, и возвращаемые значения этих тестов отражают точто ваш CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; рутина делает эквивалентным битам в поле st_mode. Наконец, &lt;code&gt;-d&lt;/code&gt; возвращает истину, если передана спецификация устройства без явного каталога (например, &lt;code&gt;DUA1:&lt;/code&gt; , а также если передана директория.</target>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">Текст &quot;Атрибуты объекта&quot; состоит из заголовка.Текст в этих командах заголовка может использовать коды форматирования,как показано здесь:</target>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">Текст соответствует последней скобке последнего успешного шаблона поиска.Это полезно,если вы не знаете,какой из наборов альтернативных шаблонов подходит.Например:</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">Текст,совпадающий по используемой группе,наиболее часто закрываемой (т.е.группе с правой крайней закрывающей скобкой)с последним успешным шаблоном поиска.</target>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">Текст сообщения для печати непосредственно перед печатью сообщения об использовании программы.</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Текст Makefile прогоняется через этот метод перед записью на диск.Это позволяет системам сделать исправления переносимости в Makefile.</target>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">Текстовый/бинарный вопрос подробно рассматривается в документации Cygwin.</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">Тэты,физы,направление и расстояние в вышеперечисленных точках находятся в радиусах.</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">То, над чем вы работаете. Структуры вроде &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; и &lt;code&gt;given&lt;/code&gt; задают для вас тему, назначая &lt;code&gt;$_&lt;/code&gt; значение по умолчанию (</target>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">Третий аргумент ($ binmode) выберет двоичный режим, если он передан как ИСТИНА. В двоичном режиме &quot;\ n&quot; будет закодирован так же, как и любой другой непечатаемый символ. Это гарантирует, что декодер получит точно такую ​​же строку, какую бы последовательность окончания строки он ни использовал. Как правило, для двоичных данных предпочтительно использовать кодировку base64; см. &lt;a href=&quot;base64&quot;&gt;MIME :: Base64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">Третьим аргументом может быть ссылка на хэш с опциями.Обратите внимание,что все опции чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">Третий аргумент-необязательный префикс.Все файлы будут убраны в каталог,который вы указываете как префикс.Поэтому,если у вас в архиве есть файлы 'a' и 'b',а в качестве префикса вы указываете 'foo',они будут записаны в архив как 'foo/a' и 'foo/b'.</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">Третий аргумент имеет значение ИСТИНА, если (и только если) два операнда поменялись местами. Perl может сделать это, чтобы гарантировать, что первый аргумент ( &lt;code&gt;$self&lt;/code&gt; ) является объектом, реализующим перегруженную операцию, в соответствии с общими соглашениями о вызове объектов. Например, если &lt;code&gt;$x&lt;/code&gt; и &lt;code&gt;$y&lt;/code&gt; - &lt;code&gt;Number&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Третья форма класса символов, которую вы можете использовать в регулярных выражениях Perl, - это класс символов в квадратных скобках. В простейшей форме он перечисляет символы, которые могут быть сопоставлены, заключенный в квадратные скобки, например: &lt;code&gt;[aeiou]&lt;/code&gt; . Это соответствует одному из &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; или &lt;code&gt;u&lt;/code&gt; . Как и в случае с другими классами символов, сопоставляется ровно один символ. * Чтобы сопоставить более длинную строку, состоящую из символов, упомянутых в классе символов, введите после класса символов &lt;a href=&quot;perlre#Quantifiers&quot;&gt;квантификатор&lt;/a&gt; . Например, &lt;code&gt;[aeiou]+&lt;/code&gt; соответствует одной или нескольким строчным английским гласным.</target>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">Третья опция заключается в том,чтобы обойти проблему,полностью отключив DB_File при сборке Perl,указав -Ui_db to Configure,а затем используя модуль BerkeleyDB из CPAN вместо DB_File.BerkeleyDB работает с Berkeley DB версии 2.*или выше.</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">Третий параметр - это целочисленный флаг, который сообщает &lt;code&gt;rmscopy&lt;/code&gt; , как обрабатывать временные метки. Если он &amp;lt;0, ни одна из временных меток входного файла не передается в выходной файл. Если он&amp;gt; 0, то это интерпретируется как битовая маска: если бит 0 (LSB) установлен, то распространяются отметки времени, отличные от даты ревизии; если бит 1 установлен, дата редакции распространяется. Если третий параметр для &lt;code&gt;rmscopy&lt;/code&gt; равен 0, то он ведет себя так же, как команда DCL COPY: если имя или тип выходного файла были явно указаны, то временные метки не распространяются, но если они были взяты неявно из входного файла спецификации, тогда распространяются все временные метки, кроме даты ревизии. Если этот параметр не указан, по умолчанию он равен 0.</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">Третий параметр &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; определяет, выполняется ли поиск AUTOLOAD , если данный метод отсутствует: ненулевое значение означает да, ищите AUTOLOAD; ноль означает нет, не ищите AUTOLOAD. Вызов &lt;code&gt;gv_fetchmethod&lt;/code&gt; эквивалентен вызову &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; с ненулевым параметром &lt;code&gt;autoload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">Третий,еще более эффективный способ-обезьяна,как это делается в кишках Perl:</target>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">Потоковая Perl-сборка также работает на AIX 5.1,но Perl-сборка IBM (Perl v5.6.0)не работает на AIX 5.1.</target>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">Три пунктирных оператора побитового присваивания ( &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; ) Являются новыми в Perl 5.22 и экспериментальными. См. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Побитовые строковые операторы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">Три особенности ключевых хэшей,</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">Все три вызова подпрограммы работают синхронно.Однако семафор обеспечивает одновременный доступ только одного потока к глобальной переменной.</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">Три предопределенные переменные $DB_HASH,$DB_BTREE и $DB_RECNO обычно адекватны для большинства приложений.Если вам все же необходимо создать дополнительные экземпляры этих объектов,то для каждого типа файлов доступны конструкторы.</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">Три главных достоинства программиста-это лень,нетерпение и Hubris.Смотри &quot;Книгу верблюдов&quot;.</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">Три переменные-api_revision,api_version и api_subversion-определяют версию старейшего бинарного файла perl,совместимого с настоящим perl.В полной строке версии,такой как</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">Три функции &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; :: warn , warnings :: warnif и warnings &lt;code&gt;warnings::enabled&lt;/code&gt; могут дополнительно использовать ссылку на объект вместо имени категории. В этом случае функции будут использовать имя класса объекта в качестве категории предупреждений.</target>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl # 121481]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl # 116487]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl # 119313]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl # 119315]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl # 119317]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl # 119437]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl # 119451]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl # 119453]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl # 119455]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl # 120085]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl # 122947]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl # 123630]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl # 123707]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">Билет на эту функцию - &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl # 120162]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">Функция tie()связывает переменную с классом (пакетом),который обеспечит реализацию методов доступа к этой переменной.После того,как эта магия выполнена,доступ к связанной переменной автоматически вызывает метод в соответствующем классе.Сложность класса скрыта за вызовами магических методов.Имена методов находятся во ВСЕХ CAPS,что является условным обозначением,которое Perl использует для указания на то,что они вызываются неявно,а не явно-так же,как и функции BEGIN()и END().</target>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">Время начала выполнения программы в секундах с начала 1970-х гг. Значения, возвращаемые тестами &lt;b&gt;-M&lt;/b&gt; , &lt;b&gt;-A&lt;/b&gt; и &lt;b&gt;-C&lt;/b&gt; , основаны на этом значении.</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">Время сократилось вдвое, что по любым стандартам является значительным улучшением скорости. Естественно, важно убедиться, что вывод согласуется с первым запуском программы, здесь на &lt;code&gt;cksum&lt;/code&gt; приходит утилита cksum системы Unix .</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">Время,необходимое для этого,варьируется в зависимости от того,насколько быстр ваш станок и насколько велика ваша кодировка.Если вы не работаете над чем-то большим,например,над euc-tw,это не займет много времени.</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">Время нулевого цикла (цикла с таким же количеством циклов,но с пустым телом цикла)вычитается из времени реального цикла.</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">Возвращаемое время также включает в себя время завершенных дочерних процессов,для которых была выполнена функция wait().Это значение в некоторой степени похоже на второе значение,возвращаемое функцией times()ядра Perl,но не обязательно идентично.Обратите внимание,что из-за ограничений обратной совместимости возвращаемое значение может обернуться примерно 2147 секунд или около 36 минут.</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">Время, когда Perl фактически выполняет то, что говорит ваш код, в отличие от более раннего периода времени, когда он пытался выяснить, имеет ли то, что вы сказали, какой-либо смысл, то есть &lt;b&gt;время компиляции&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">Время, когда Perl пытается разобраться в вашем коде, а не тогда, когда он думает, что знает, что означает ваш код, и просто пытается делать то, что, по его мнению, ваш код говорит делать, а именно &lt;b&gt;время выполнения&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">Таймаут в [PKG]может быть указан как ноль,чтобы произвести &quot;опрос&quot;,но вы не должны делать этого,потому что новый IO::Select объект будет создан за кулисами только для того,чтобы провести одиночный опрос.Это ужасно неэффективно.Используйте скорее истинную функцию select()с нулевым таймаутом на дескрипторе,или неблокирующий IO.</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">Таймаут может быть несколько секунд относительно текущего времени (например,5 секунд с момента совершения вызова),или может быть абсолютным таймаутом в</target>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">Синхронизация выполняется с использованием времени(3)и времени(3).</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">Заголовок этого раздела указывает на вторую проблему, с которой вы можете рано или поздно столкнуться при упаковке структур C. Если функция, которую вы собираетесь вызвать, ожидает, скажем, значение &lt;code&gt;void *&lt;/code&gt; , вы</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Документация верхнего уровня о регулярных выражениях Perl находится в &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">Верхний узел в дереве - это &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">Общее время,затраченное на проведение теста,в секундах от эпохи...</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">Общее количество сравнений равно сумме квадратов количества записей в каждой корзине. Для случайного хеширования &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; ключей в &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; сегментов ожидаемое значение:</target>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">Общее время, необходимое для запуска теста, в секундах. Если &lt;code&gt;Time::HiRes&lt;/code&gt; доступен, он будет иметь более тонкую детализацию.</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">Компромисс заключается в том,что необходимо заранее рассчитать количество возвращаемых значений (хотя чрезмерное увеличение стека,как правило,не повредит ничему,кроме расхода памяти).</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">Традиционные РЕЖИМЫ &amp;laquo;0&amp;raquo;, &amp;laquo;1&amp;raquo; и &amp;laquo;2&amp;raquo; реализуются с разными числовыми значениями в некоторых системах. Флаги, экспортируемые &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR), должны работать везде. (Mac OS, OS / 390)</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">В традиционном варианте за ним следует имя, заключенное в фигурные скобки, что означает символ (или последовательность символов), заданный этим именем. Таким образом, &lt;code&gt;\N{ASTERISK}&lt;/code&gt; - это еще один способ записи &lt;code&gt;*&lt;/code&gt; , допустимый как для строк в двойных кавычках, так и для шаблонов регулярных выражений. В шаблонах он не имеет значения, которое имеет неэкранированный &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">Переходная среда компиляции получается с помощью следующих флагов компилятора и компоновщика:</target>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">Оператор транслитерации. То же, что и &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; . См. Раздел &amp;laquo; &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Операторы типа кавычек&amp;raquo; в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">Ловушка и методы-ловушка-это синонимы отрицания и разрешения с уважением.</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">Обработка более чем одной физической &lt;b&gt;линии&lt;/b&gt; как одной логической линии. Строки &lt;b&gt;Makefile&lt;/b&gt; продолжаются обратной косой чертой перед &lt;b&gt;новой строкой&lt;/b&gt; . Заголовки писем, как определено в RFC 822, продолжаются помещением пробела или табуляции.</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">Дерево создается компилятором во время</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">Уловка в этой задаче состоит в том, чтобы найти каталог. Прежде чем ваш сценарий сделает что-либо еще (например, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ), вы можете получить текущий рабочий каталог с &lt;code&gt;Cwd&lt;/code&gt; модуля Cwd , который поставляется с Perl:</target>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">Хитрость в том, что если вы читаете &lt;code&gt;BOM&lt;/code&gt; , вы будете знать порядок байтов, поскольку если она была написана на платформе с &lt;code&gt;0xFE 0xFF&lt;/code&gt; байтов, вы прочитаете байты 0xFE 0xFF , но если она была написана на платформе с прямым порядком байтов, вы будет читать байты &lt;code&gt;0xFF 0xFE&lt;/code&gt; . (И если &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; платформа писала на платформе ASCII UTF-8, вы прочитаете байты 0xEF 0xBB 0xBF .)</target>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">Хитрость заключается в том,чтобы дать специальный параметр скрипту оболочки Configure при его запуске на AIX:</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">Уловка решения этой проблемы заключается в том, чтобы избежать случайного автовивификации. Если вы хотите проверить три ключа в глубину, вы можете наивно попробовать следующее:</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">Коварная вещь,которую нужно запомнить,это то,что первый параметр является истинным,если вы хотите.</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">Также определены тригонометрическая константа &lt;b&gt;пи&lt;/b&gt; и некоторые из удобных кратных ей.</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">Доверие к п. 2 является переходным. Если A доверяет B, а B доверяет C, то A доверяет C. Поэтому, если вы не переопределяете &lt;code&gt;@ISA&lt;/code&gt; с помощью &lt;code&gt;@CARP_NOT&lt;/code&gt; , то это доверительное отношение идентично &amp;laquo;наследует от&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">Правда в том,что регулярные выражения perl в наши дни намного сложнее,чем подобные структуры,но визуализация их таким образом может помочь при попытке сориентироваться,и они довольно близко подходят к текущей реализации.</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">Драйвер tty переводится в необработанный режим и восстанавливается с помощью специальной команды операционной системы в UNIX-подобных средах &lt;code&gt;stty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">Учебное пособие,начатое в Llama,продолжается в Alpaca,где представлены промежуточные функции ссылок,структур данных,объектно-ориентированного программирования и модулей:</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Две дополнительные строки запрашивают perl для выявления различных распространенных проблем в вашем коде. Они проверяют разные вещи, поэтому вам нужно и то, и другое. Потенциальная проблема, обнаруженная при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; заставит ваш код немедленно останавливаться, когда он встречается, при этом &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; просто выдаст предупреждение (например, ключ командной строки &lt;b&gt;-w&lt;/b&gt; ) и позволит вашему коду работать. Чтобы узнать больше о них, просмотрите соответствующие страницы руководства на &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; и &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">Форма с двумя аргументами add_bits () добавит первые $ nbits битов из $ data. Для последнего потенциально неполного байта используются только &lt;code&gt;$nbits % 8&lt;/code&gt; биты $ nbits% 8 . Если $ nbits больше, чем &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , то этот метод будет делать то же, что и &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">Два массива &lt;code&gt;@ISA&lt;/code&gt; и &lt;code&gt;@EXPORT&lt;/code&gt; очень важны. &lt;code&gt;@ISA&lt;/code&gt; массив содержит список других пакетов , в которых можно искать методы (или подпрограммы) , которые не существуют в текущем пакете. Обычно это важно только для объектно-ориентированных расширений (о которых мы поговорим намного позже), и поэтому обычно не требует изменений.</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">Два управляющих символа ^D и ^Z,а также маркеры __END__и __DATA__могут использоваться для указания логического конца скрипта до фактического конца файла.Любой следующий текст игнорируется.</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">Две точки входа - это &lt;code&gt;re_intuit_start()&lt;/code&gt; и &lt;code&gt;pregexec()&lt;/code&gt; . Эти подпрограммы имеют несколько кровосмесительную связь с перекрытием их функций, и &lt;code&gt;pregexec()&lt;/code&gt; может даже вызывать &lt;code&gt;re_intuit_start()&lt;/code&gt; самостоятельно. Тем не менее, другие части исходного кода Perl могут вызывать одну или обе.</target>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">Два имени файла также могут быть указаны отдельно полностью как &lt;code&gt;$dirfile&lt;/code&gt; и &lt;code&gt;$pagfilename&lt;/code&gt; . Это подходит для двух файлов без расширений &quot;.dir&quot; и &quot;.pag&quot;, например, для двух файлов из &lt;a href=&quot;file/temp&quot;&gt;File :: Temp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">Первые две формы-это просто синтаксический сахар,который автоматически загружает нужный модуль при первом использовании.Вторая форма позволяет использовать имена алгоритмов,которые содержат буквы,не являющиеся легальными perl идентификаторами,например &quot;SHA-1&quot;.Если реализация для данного алгоритма не найдена,то возникает исключение.</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">Двумя основными целями для этого являются возврат к использованию подпакета внутри внутренней области видимости:</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">Две наиболее распространенные ошибки при построении нечто вроде массива массивов-это либо случайный подсчет количества элементов,либо многократное обращение к одному и тому же месту памяти.Вот случай,когда вместо вложенного массива происходит просто подсчет:</target>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt; для плагинов поддерживает два основных варианта использования :</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">Двумя самыми быстрыми исправлениями являются:либо вывод информации о несоответствиях на Perl,либо запуск Perl под установленной по умолчанию локалью &quot;C&quot;.</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">Два набора баркасов дают статистику и визуальную индикацию исполнения хэша.</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">Оба заявления:</target>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">Тип константы (</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">Тип третьего параметра является произвольным для типовой карты.Он просто должен соответствовать объявленной переменной.</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">Соответствующий тип выделен белым цветом (за исключением запятых, перед которыми нет пробелов, и нескольких &lt;code&gt;*&lt;/code&gt; ,между которыми нет пробелов).</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">Типовая карта проверяет,что ссылка на скаляр передается от perl к XS.</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">Типы:</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">Типичный первый проход компилятора C, который обрабатывает строки, начинающиеся с &lt;code&gt;#&lt;/code&gt; для условной компиляции и определения макроса, и выполняет различные манипуляции с текстом программы на основе текущих определений. Также известный как</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">Типичный подход использует отладчик Perl,описанный в разделе</target>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">Типичный поток ввода/вывода программы:</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">Типичные взаимодействия между фрагментами данных лучше всего представлены операторами.</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">Типичный случай использования-для приватных модулей или рабочих копий проектов из удаленных репозиториев на локальном диске.</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">Типичное использование - из Makefile, созданного &lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; . Таким образом, при нормальных обстоятельствах вам не придется иметь дело с этим модулем напрямую.</target>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">Типичный способ использования вызова &lt;code&gt;EVERY&lt;/code&gt; - заключить его в другой базовый метод, который наследуют все классы. Например, чтобы гарантировать, что каждый деструктор, который наследует объект, действительно вызывается (в отличие от только самого левого деструктора по глубине):</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">Функция uncolor()и поддержка ANSI_COLORS_DISABLED добавлены в Term::ANSIColor 1.04,входящий в Perl 5.8.0.</target>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">Базовое поведение &lt;code&gt;%+&lt;/code&gt; обеспечивается модулем &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">Объект,лежащий в основе парсера.Это полезно,если вам нужна полная информация для тестовой программы.</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">Программа undump была древней попыткой ускорить программу Perl,сохранив уже скомпилированную форму на диск.Это больше не является жизнеспособным вариантом,так как она работала только на нескольких архитектурах,и в любом случае не была хорошим решением.</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">Прискорбное сходство имени этой функции с именем оператора &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; в Perl является строго случайным. Эта функция работает слева; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; работает справа.</target>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">Развязка Поймал</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">Развязка()Попалась</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">Варианты верхнего регистра ( &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; и &lt;code&gt;\V&lt;/code&gt; ) - это классы символов, которые соответствуют, соответственно, любому символу, который не является символом слова, цифрой, пробелом, горизонтальным пробелом или вертикальным пробелом.</target>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">Ури,который ты передал строителю.</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">Параметр urllist имеет поддержку CD-ROM</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">Используется для консервированного фильтра:</target>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">Использование &lt;code&gt;//g&lt;/code&gt; показано в следующем примере. Предположим, у нас есть строка, состоящая из слов, разделенных пробелами. Если мы заранее знаем, сколько слов есть, мы могли бы выделить слова с помощью группировки:</target>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">Использование &lt;code&gt;:void&lt;/code&gt; не рекомендуется, так как это может привести к тому, что исключения не будут выбраны, если вы</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">Использование &lt;code&gt;:void&lt;/code&gt; с Fatal не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">Использование &lt;code&gt;=&amp;gt;&lt;/code&gt; выше обеспечивает необходимое цитирование &lt;code&gt;MODULE&lt;/code&gt; . Если вы не используете жирную запятую (например, у вас нет АРГУМЕНТОВ), вам нужно указать МОДУЛЬ.</target>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">Использование &lt;code&gt;\Q&lt;/code&gt; приводит к тому, что &amp;lt;.&amp;gt; В регулярном выражении обрабатывается как обычный символ, так что &lt;code&gt;P.&lt;/code&gt; соответствует &lt;code&gt;P&lt;/code&gt; , за которым следует точка.</target>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">Использование верблюда с темой Perl является торговой маркой компании O'Reilly and Associates,Inc.Используется с разрешения.</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">Использование всех прописных букв для имен констант-это всего лишь соглашение,хотя оно рекомендуется для того,чтобы выделить константы и помочь избежать столкновений с другими пустыми словами,ключевыми словами и именами подпрограмм.Имена констант должны начинаться с буквы или подчеркивания.Имена,начинающиеся с двойного знака подчеркивания,зарезервированы.Некоторые плохие имена будут выдавать предупреждения,если предупреждения включены во время компиляции.</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">Использование хеш-ключей, начинающихся с дефиса ( &lt;code&gt;-name&lt;/code&gt; ) или полностью заглавных ( &lt;code&gt;NAME&lt;/code&gt; ), является пережитком старых версий Perl, в которых обычные строчные строки не обрабатывались правильно оператором &lt;code&gt;=&amp;gt;&lt;/code&gt; . В то время как некоторые модули сохраняют ключи аргументов в верхнем регистре или через дефис по историческим причинам или в соответствии с личным стилем, большинство новых модулей должны использовать простые ключи нижнего регистра. Что бы вы ни выбрали, будьте последовательны!</target>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">Официально не &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;рекомендуется&lt;/a&gt; использовать потоки на основе интерпретатора в Perl .</target>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">Использование круглых скобок вокруг &lt;b&gt;подшаблона&lt;/b&gt; в &lt;b&gt;регулярном выражении&lt;/b&gt; для сохранения совпадающей &lt;b&gt;подстроки&lt;/b&gt; в качестве &lt;b&gt;обратной ссылки&lt;/b&gt; . (Захваченные строки также возвращаются в виде списка в &lt;b&gt;контексте списка&lt;/b&gt; .) См. Главу 5 Camel &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">Использование скобок может быть использовано для захвата частей имени входного файла.</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">Использование следующих функций не рекомендуется, поскольку они на самом деле не являются функциями тестирования и не производят диагностику, помогающую выяснить, что пошло не так. Они были написаны до того, как &lt;code&gt;is_deeply()&lt;/code&gt; потому что я не мог понять, как отобразить полезную разницу двух произвольных структур данных.</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">Возможность использования</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">Идентификатор пользователя,владеющего файлом</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
