<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5e82b72795636964d66437770c692b7d03ceb23b" translate="yes" xml:space="preserve">
          <source>To assign a specific &lt;b&gt;network address&lt;/b&gt; to a &lt;b&gt;socket&lt;/b&gt;.</source>
          <target state="translated">Чтобы назначить конкретный &lt;b&gt;сетевой адрес&lt;/b&gt; к &lt;b&gt;розетке&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c2805d5269d7141c86f56aaf1c2c2a76a26622" translate="yes" xml:space="preserve">
          <source>To assist you &lt;code&gt;test_test&lt;/code&gt; can colour the background of the debug information to disambiguate the different types of output. The debug output will have its background coloured green and red. The green part represents the text which is the same between the executed and actual output, the red shows which part differs.</source>
          <target state="translated">Чтобы помочь вам, &lt;code&gt;test_test&lt;/code&gt; может раскрасить фон отладочной информации, чтобы устранить неоднозначность различных типов вывода. Фон вывода отладки будет зеленым и красным. Зеленая часть представляет текст, который одинаков для выполненного и фактического вывода, красный показывает, какая часть отличается.</target>
        </trans-unit>
        <trans-unit id="e8e1cbea5e7824434cdf9fc699c75f29c54b93f0" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</source>
          <target state="translated">Чтобы автоматически определять и распаковывать поток данных RFC 1950 или RFC 1952 (например, gzip), установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b525fdc47ff53e260dc0931cfbc7865b5eae8d3" translate="yes" xml:space="preserve">
          <source>To avoid ambiguity, when signatures are enabled the special syntax for prototypes is disabled. There is no attempt to guess whether a parenthesised group was intended to be a prototype or a signature. To give a subroutine a prototype under these circumstances, use a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. For example,</source>
          <target state="translated">Во избежание двусмысленности, когда подписи включены, специальный синтаксис для прототипов отключен. Нет попытки угадать, была ли заключенная в скобки группа задумана как прототип или подпись. Чтобы дать подпрограмме прототип в этих обстоятельствах, используйте &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;атрибут prototype&lt;/a&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="409b9ee9e716af7051876e4ad525c073a4badea1" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious failures, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">Чтобы избежать путаницы потенциальных пользователей вашего кода,которые работают с более ранними версиями Perl,с загадочными сбоями,поместите такие вещи в верхнюю часть файла,чтобы показать,что ваш код будет работать.</target>
        </trans-unit>
        <trans-unit id="cdb270b498c0b4af5dad93d34e6e87c778aa6616" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious syntax errors, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">Чтобы избежать путаницы потенциальных пользователей вашего кода,которые работают с более ранними версиями Perl,с загадочными синтаксическими ошибками,поместите такие вещи в верхнюю часть файла,чтобы показать,что ваш код будет работать.</target>
        </trans-unit>
        <trans-unit id="010f767fa3f7758e437e81843e72a2beb1516ec0" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code with mysterious syntax errors, put something like this at the top of your script:</source>
          <target state="translated">Чтобы избежать путаницы потенциальных пользователей вашего кода с загадочными синтаксическими ошибками,поместите что-то подобное в верхнюю часть вашего скрипта:</target>
        </trans-unit>
        <trans-unit id="92c9a11d8c00dc701cc8cb47a28dac284fb7ca76" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt; . Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt; , is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt; .</source>
          <target state="translated">Чтобы избежать создания нового SV каждый раз, &lt;code&gt;SaveSub2&lt;/code&gt; вызывается SaveSub2 , функция сначала проверяет, вызывалась ли она раньше. Если нет, то выделяется место для нового SV, и ссылка на &lt;code&gt;name&lt;/code&gt; подпрограммы Perl копируется в переменную &lt;code&gt;keepSub&lt;/code&gt; за одну операцию с использованием &lt;code&gt;newSVsv&lt;/code&gt; . После этого при каждом &lt;code&gt;SaveSub2&lt;/code&gt; существующий SV, &lt;code&gt;keepSub&lt;/code&gt; , перезаписывается новым значением с использованием &lt;code&gt;SvSetSV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f1c469efc6b2f6bb3fb09ea0c807689f209337a" translate="yes" xml:space="preserve">
          <source>To avoid memory leaks, all trailing duplicate entries in @INC are removed.</source>
          <target state="translated">Чтобы избежать утечки памяти,все дубликаты в @INC удаляются.</target>
        </trans-unit>
        <trans-unit id="fe0f91423917e2fcf830eb3362231efceaad6437" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt; , it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object
breaks encapsulation&lt;/code&gt; &quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">Чтобы не полагаться на базовое представление объекта, если правый операнд smartmatch является объектом, который не перегружает &lt;code&gt;~~&lt;/code&gt; , он вызывает исключение &amp;laquo; &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &amp;raquo;. Это потому, что никому не нужно копаться, чтобы увидеть, есть ли что-то &amp;laquo;внутри&amp;raquo; объекта. Все это недопустимо для объектов без &lt;code&gt;~~&lt;/code&gt; перегрузки:</target>
        </trans-unit>
        <trans-unit id="4c10393ba7ca423ef6dd3c94a2b581675efc33a8" translate="yes" xml:space="preserve">
          <source>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE before locking or unlocking it.</source>
          <target state="translated">Чтобы избежать возможности неправильной координации,Perl теперь промывает FILEHANDLE перед блокировкой или разблокировкой.</target>
        </trans-unit>
        <trans-unit id="5d5d75934a6f7e951fd9357cb74cb7683ab1e280" translate="yes" xml:space="preserve">
          <source>To avoid this problem, either put in extra parentheses or use the super low precedence &lt;code&gt;or&lt;/code&gt; operator:</source>
          <target state="translated">Чтобы избежать этой проблемы, либо заключите дополнительные скобки, либо используйте сверхнизкий приоритет &lt;code&gt;or&lt;/code&gt; оператор:</target>
        </trans-unit>
        <trans-unit id="766d42f164385b7f29a7e92b44d6d78b6d17a595" translate="yes" xml:space="preserve">
          <source>To avoid this problem, when it encounters a here document whilst extracting from a modifiable string, &lt;code&gt;extract_quotelike&lt;/code&gt; silently rearranges the string to an equivalent piece of Perl:</source>
          <target state="translated">Чтобы избежать этой проблемы, когда он встречает здесь документ при извлечении из изменяемой строки, &lt;code&gt;extract_quotelike&lt;/code&gt; незаметно переупорядочивает строку на эквивалентную часть Perl:</target>
        </trans-unit>
        <trans-unit id="da9ceee7d2a6a8bd92bf59b8dd4824301848ef6c" translate="yes" xml:space="preserve">
          <source>To avoid this warning and to avoid having different output encodings in a single stream, always specify an encoding explicitly, for example with a PerlIO layer:</source>
          <target state="translated">Чтобы избежать этого предупреждения и не иметь различных выходных кодировок в одном потоке,всегда указывайте кодировку явно,например,со слоем PerlIO:</target>
        </trans-unit>
        <trans-unit id="35af978891563db2721278dcfd7e8de9b9ef61ce" translate="yes" xml:space="preserve">
          <source>To avoid this, whenever a CV and its associated pad is freed, any &lt;code&gt;&amp;amp;&lt;/code&gt; entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's &lt;code&gt;CvOUTSIDE&lt;/code&gt; is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as &lt;code&gt;$a&lt;/code&gt; above).</source>
          <target state="translated">Чтобы избежать этого, всякий раз, когда CV и связанный с ним контактный блок освобождаются, любые записи &lt;code&gt;&amp;amp;&lt;/code&gt; в блоке явно удаляются из контактной площадки, и если счетчик ссылок указанной подпрограммы anon по-прежнему положительный, то &lt;code&gt;CvOUTSIDE&lt;/code&gt; этого дочернего элемента устанавливается на точку его бабушке и дедушке. Это произойдет только в единственном конкретном случае, когда прототип без закрытия анон имеет одну или несколько активных ссылок (например, &lt;code&gt;$a&lt;/code&gt; выше).</target>
        </trans-unit>
        <trans-unit id="892f516de74c75c59b1eb990ddf92d3f52eefdaf" translate="yes" xml:space="preserve">
          <source>To avoid this, you can force the Makefile to be rebuilt whenever you change the module containing the version number by adding this to your WriteMakefile() arguments.</source>
          <target state="translated">Чтобы избежать этого,вы можете заставить Makefile перестраиваться всякий раз,когда вы изменяете модуль,содержащий номер версии,добавив это в аргументы WriteMakefile().</target>
        </trans-unit>
        <trans-unit id="79bc3cfb105613cbe5f2c89b6ab087189a45bded" translate="yes" xml:space="preserve">
          <source>To avoid wasted work when a restart is needed, the sizing pass is abandoned - &lt;code&gt;regatom()&lt;/code&gt; immediately returns NULL, setting the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (This action is encapsulated using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</source>
          <target state="translated">Чтобы избежать ненужной работы, когда необходим перезапуск, &lt;code&gt;regatom()&lt;/code&gt; определения размера прекращается - regatom () немедленно возвращает NULL, устанавливая флаг &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (Это действие инкапсулируется с помощью макроса &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) Этот запрос на перезапуск распространяется вверх по цепочке вызовов аналогичным образом, пока он не будет &amp;laquo;пойман&amp;raquo; в &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , который помечает шаблон как содержащий Unicode и перезапускает этап изменения размера. Также возможно, что конструкции внутри блоков кода времени выполнения нуждаются в представлении Unicode., О чем сигнализирует &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; возвращающий false в &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09e124c75c7cbe80f3e4228168f11f802fe412a9" translate="yes" xml:space="preserve">
          <source>To be able to access the two parameters that were pushed onto the stack after they return from</source>
          <target state="translated">Чтобы иметь доступ к двум параметрам,которые были затолканы в стек после их возвращения из</target>
        </trans-unit>
        <trans-unit id="6e3a208559e7fc6775f8912d077235f17cca0135" translate="yes" xml:space="preserve">
          <source>To be announced.</source>
          <target state="translated">Будет объявлено.</target>
        </trans-unit>
        <trans-unit id="161647c06ada22688c122c82ae94e4258d4b89c7" translate="yes" xml:space="preserve">
          <source>To be announced. Or deleted.</source>
          <target state="translated">Будет объявлено.Или удалить.</target>
        </trans-unit>
        <trans-unit id="1942f94bc444abb1b89482bc04403e0f7a2e9a63" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">Для совместимости с регулярными выражениями .Net &lt;code&gt;\g{name}&lt;/code&gt; также может быть записано как &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; или &lt;code&gt;\k'name'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc3bab69ee4c24015f181f505f714806f55a6a5d" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">Чтобы быть полностью совместимым с модулями Exporter и MakeMaker, вы должны сохранить номер версии вашего модуля в переменной пакета, отличной от моего, с именем $ VERSION. Это должно быть положительное число с плавающей запятой, по крайней мере, с двумя цифрами после десятичной дроби (т. Е. Сотые, например, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Не используйте версию в стиле &amp;laquo;1.3.2&amp;raquo;. Подробнее см. &lt;a href=&quot;exporter&quot;&gt;Экспортер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="781abe7cd10e483cb21c7189d334aa3e4eaca732" translate="yes" xml:space="preserve">
          <source>To be more precise, we will say that a regex program is an encoding of a graph. Each node in the graph corresponds to part of the original regex pattern, such as a literal string or a branch, and has a pointer to the nodes representing the next component to be matched. Since &quot;node&quot; and &quot;opcode&quot; already have other meanings in the perl source, we will call the nodes in a regex program &quot;regops&quot;.</source>
          <target state="translated">Точнее,мы скажем,что регекс-программа-это кодировка графа.Каждый узел графа соответствует части исходного регрессионного паттерна,например,буквенной строке или ветке,и имеет указатель на узлы,представляющие следующую компоненту,которая должна быть сопоставлена.Так как &quot;узел&quot; и &quot;опкод&quot; уже имеют другие значения в источнике perl,мы будем называть узлы в регрессионной программе &quot;regops&quot;.</target>
        </trans-unit>
        <trans-unit id="a03a7a550b2afe3393fb820749da17491cf98371" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">Чтобы быть педантичным, на самом деле это сравнение &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , но это проблема, только если вы используете выражение с плавающей запятой; при неявном использовании &lt;code&gt;$.&lt;/code&gt; как описано в предыдущем абзаце, сравнение выполняется по типу &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; что возникает только тогда, когда &lt;code&gt;$.&lt;/code&gt; установлено значение с плавающей запятой, и вы не читаете из файла. Более того, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; или &lt;code&gt;2.18 .. 3.14&lt;/code&gt; не будет делать то, что вы хотите в скалярном контексте, потому что каждый из операндов оценивается с использованием своего целочисленного представления.</target>
        </trans-unit>
        <trans-unit id="ed53a49e46f6db6479ffd9a906bbff37f48f8995" translate="yes" xml:space="preserve">
          <source>To be polite to other functions wrapping your own you usually want to increment &lt;code&gt;$Level&lt;/code&gt; rather than set it to a constant.</source>
          <target state="translated">Чтобы быть вежливым по отношению к другим функциям, обертывающим ваши собственные, вы обычно хотите увеличивать &lt;code&gt;$Level&lt;/code&gt; а не устанавливать его на константу.</target>
        </trans-unit>
        <trans-unit id="377966b7899d2c6cc0617addc0bc388cc67a68ae" translate="yes" xml:space="preserve">
          <source>To be portable each component of a module name should be limited to 11 characters. If it might be used on MS-DOS then try to ensure each is unique in the first 8 characters. Nested modules make this easier.</source>
          <target state="translated">Чтобы быть переносимым,каждый компонент названия модуля должен быть ограничен до 11 символов.Если он может быть использован в MS-DOS,то постарайтесь,чтобы каждый из них был уникальным в первых 8 символов.Вложенные модули облегчают эту задачу.</target>
        </trans-unit>
        <trans-unit id="b076f38e81902902b25d1f17b1608ab8be160484" translate="yes" xml:space="preserve">
          <source>To begin your reading, start with:</source>
          <target state="translated">Чтобы начать читать,начни с:</target>
        </trans-unit>
        <trans-unit id="a61e1eb5d11062cb9036bb12d10d76fe348be7c1" translate="yes" xml:space="preserve">
          <source>To browse existing Perl bugs and patches, you can use the web interface at &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;.</source>
          <target state="translated">Чтобы просмотреть существующие ошибки и исправления Perl, вы можете использовать веб-интерфейс по адресу &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b19b13b7eebea3b4a95edad33fffc49ec225b2e5" translate="yes" xml:space="preserve">
          <source>To build a non-XS module, you can use the standard module-building instructions distributed with perl modules.</source>
          <target state="translated">Для создания модуля,отличного от XS,можно использовать стандартные инструкции по созданию модулей,распространяемые с модулями perl.</target>
        </trans-unit>
        <trans-unit id="6c2705e01ac97996d808db8effeb88881961867f" translate="yes" xml:space="preserve">
          <source>To build an XS module, you must use the standard module-building instructions distributed with perl modules *PLUS* three extra instructions specific to the DJGPP &quot;static link&quot; build environment.</source>
          <target state="translated">Для сборки модуля XS необходимо использовать стандартные инструкции по сборке модулей,распространяемые с модулями perl *PLUS*,три дополнительные инструкции,специфичные для среды сборки &quot;статической связи&quot; DJGPP.</target>
        </trans-unit>
        <trans-unit id="d5c2765f0199128d509d1897ee86d4417f4dd8a3" translate="yes" xml:space="preserve">
          <source>To build extensions other than standard extensions, NetWare Perl has to be installed on Windows along with Windows Perl. The Perl for Windows can be either downloaded from the CPAN site and built using the sources, or the binaries can be directly downloaded from the ActiveState site. Installation can be done by invoking</source>
          <target state="translated">Для создания расширений,отличных от стандартных,NetWare Perl должен быть установлен на Windows вместе с Windows Perl.Perl для Windows может быть либо загружен с сайта CPAN и построен с использованием исходных текстов,либо исполняемые файлы могут быть непосредственно загружены с сайта ActiveState.Установка может быть выполнена путем вызова</target>
        </trans-unit>
        <trans-unit id="787c86241856156cd077a05b7bdc7004761044c1" translate="yes" xml:space="preserve">
          <source>To build perl from its source code on the Stratus V Series platform you must have OpenVOS Release 17.1.0 or later, GNU Tools Release 3.5 or later, and the C/POSIX Runtime Libraries.</source>
          <target state="translated">Для сборки perl из его исходных текстов на платформе серии Stratus V вы должны иметь OpenVOS версии 17.1.0 или более поздней,GNU Tools версии 3.5 или более поздней,а также библиотеки времени исполнения C/POSIX Runtime Libraries.</target>
        </trans-unit>
        <trans-unit id="29d9cfbafe7af9c12fb5ae5d7307a03b50f8bc3e" translate="yes" xml:space="preserve">
          <source>To build perl with AddressSanitizer, your Configure invocation should look like:</source>
          <target state="translated">Для построения perl с помощью AddressSanitizer,ваше обращение Configure должно выглядеть как:</target>
        </trans-unit>
        <trans-unit id="b12975798f70dc1cb8c9fb59b7af2b4445d07d6d" translate="yes" xml:space="preserve">
          <source>To calculate the digest of an n-bit message where</source>
          <target state="translated">Для вычисления дайджеста n-битного сообщения,где</target>
        </trans-unit>
        <trans-unit id="0df1e5f84b4694c53717b89d6fb8b89ff7d44718" translate="yes" xml:space="preserve">
          <source>To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N 139.8E) in kilometers:</source>
          <target state="translated">Рассчитать расстояние между Лондоном (51,3N 0,5W)и Токио (35,7N 139,8E)в километрах:</target>
        </trans-unit>
        <trans-unit id="4cea3ec7425389162d89934663cf2df355daf6af" translate="yes" xml:space="preserve">
          <source>To call a function on each element in an array, and collect the results, use:</source>
          <target state="translated">Для вызова функции по каждому элементу массива и сбора результатов,используйте:</target>
        </trans-unit>
        <trans-unit id="dbe4aebe356ab30727111304ed5066c2800f1b44" translate="yes" xml:space="preserve">
          <source>To call a function on each element of an array, but ignore the results:</source>
          <target state="translated">Вызвать функцию по каждому элементу массива,но игнорировать результаты:</target>
        </trans-unit>
        <trans-unit id="710b700709beaae3a0d7fb3e17148d99cdb1ee11" translate="yes" xml:space="preserve">
          <source>To call a function on each integer in a (small) range, you &lt;b&gt;can&lt;/b&gt; use:</source>
          <target state="translated">Чтобы вызвать функцию для каждого целого числа в (небольшом) диапазоне, вы &lt;b&gt;можете&lt;/b&gt; использовать:</target>
        </trans-unit>
        <trans-unit id="b0c03ca703f3d70571e4ed1a5f4b95eb2f4f7eac" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt; .</source>
          <target state="translated">Для вызова отдельных подпрограмм Perl вы можете использовать любую из функций &lt;b&gt;call_ *,&lt;/b&gt; задокументированных в &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; . В этом примере мы будем использовать &lt;code&gt;call_argv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f49f3d19c459317781abadc37d2ae6f14022eac3" translate="yes" xml:space="preserve">
          <source>To call subroutines:</source>
          <target state="translated">Чтобы вызвать подпрограммы:</target>
        </trans-unit>
        <trans-unit id="5abcacc2499f97bcbde0588fdd4401b44cc6c01a" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT (ordering is important here):</source>
          <target state="translated">Чтобы захватить STDERR команды,но отбросить ее STDOUT (здесь важен заказ):</target>
        </trans-unit>
        <trans-unit id="891b8754dd37bb2c3dc54aab3a1185e0fd372170" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT:</source>
          <target state="translated">Чтобы захватить STDERR команды,но отбросить ее STDOUT:</target>
        </trans-unit>
        <trans-unit id="7ddfc050c95c3b76b8561d8851899b023835e01c" translate="yes" xml:space="preserve">
          <source>To capture a command's STDOUT but discard its STDERR:</source>
          <target state="translated">Захватить СТДУАТ команды,но отбросить СТДЕРР:</target>
        </trans-unit>
        <trans-unit id="459bfbbfb62f196ec5bdfb8f616f754fb8b81d04" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, and let its STDOUT go to our own STDERR:</source>
          <target state="translated">Захватить СТДЕРР программы и отпустить ее СТДУТ в наш собственный СТДЕРР:</target>
        </trans-unit>
        <trans-unit id="5bd52eb04283645c047b422b0b8e0a7d88ad61c6" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, but discard its STDOUT:</source>
          <target state="translated">Захватить СТДЕРР программы,но отбросить ее СТДАУТ:</target>
        </trans-unit>
        <trans-unit id="8a448a300769cb48dfafecf642b7105f4ae83d7b" translate="yes" xml:space="preserve">
          <source>To capture a program's STDOUT, but discard its STDERR:</source>
          <target state="translated">Захватить СТДУАТ программы,но отбросить СТДУЭРР:</target>
        </trans-unit>
        <trans-unit id="48535a0ea84ddf99c0ff0191b2ebc7ac2d2965e6" translate="yes" xml:space="preserve">
          <source>To catch this kind of problem, we can force each variable to be declared before use by pulling in the strict module, by putting 'use strict;' after the first line of the script.</source>
          <target state="translated">Чтобы поймать такую проблему,мы можем заставить каждую переменную быть объявленной перед использованием,потянув в строгий модуль,поставив 'use strict;' после первой строки скрипта.</target>
        </trans-unit>
        <trans-unit id="ee4539dea7c8d87e83fb7b99fbcea7146f28bf41" translate="yes" xml:space="preserve">
          <source>To center a whole line of text, do something like this:</source>
          <target state="translated">Чтобы отцентрировать целую строку текста,сделай что-нибудь вроде этого:</target>
        </trans-unit>
        <trans-unit id="cb50b80c4012bf8864c9070a8feaf64a654c0893" translate="yes" xml:space="preserve">
          <source>To change existing lines, insert the code to modify the lines inside the &lt;code&gt;while&lt;/code&gt; loop. In this case, the code finds all lowercased versions of &quot;perl&quot; and uppercases them. The happens for every line, so be sure that you're supposed to do that on every line!</source>
          <target state="translated">Для изменения существующих строк, вставьте код для изменения строк внутри в &lt;code&gt;while&lt;/code&gt; цикла. В этом случае код находит все версии &amp;laquo;perl&amp;raquo; в нижнем регистре и в верхнем регистре. Это происходит для каждой строки, поэтому убедитесь, что вы должны делать это на каждой строке!</target>
        </trans-unit>
        <trans-unit id="3014ba02f0b23a5077d149c5a55186e1b0210812" translate="yes" xml:space="preserve">
          <source>To change one of these elements, just assign to it like this:</source>
          <target state="translated">Чтобы изменить один из этих элементов,просто назначьте его так:</target>
        </trans-unit>
        <trans-unit id="0bc26e290e338fd9cb7ec178f79c71f3fe32327a" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt; , is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">Чтобы изменить только конкретную строку, введите номер строки ввода, &lt;code&gt;$.&lt;/code&gt; , является полезным. Сначала прочтите и распечатайте строки до той, которую вы хотите изменить. Затем прочтите единственную строку, которую вы хотите изменить, измените ее и распечатайте. После этого прочтите остальные строки и распечатайте их:</target>
        </trans-unit>
        <trans-unit id="f7b3b581f75dc5b407edfb21187704d85ccc3337" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt; , the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">Чтобы изменить только пятую строку, вы можете добавить тестовую проверку &lt;code&gt;$.&lt;/code&gt; , номер строки ввода, затем выполнить операцию только после успешного прохождения теста:</target>
        </trans-unit>
        <trans-unit id="2ac56000e9557456388facc9434e99b2f25c68f2" translate="yes" xml:space="preserve">
          <source>To change part of a string, you can use the optional fourth argument which is the replacement string.</source>
          <target state="translated">Для изменения части строки можно использовать необязательный четвертый аргумент-строку замены.</target>
        </trans-unit>
        <trans-unit id="159bf1e2399227a81a68240fcbc4a8d0c4d4386e" translate="yes" xml:space="preserve">
          <source>To change the configuration you will need to use either the &lt;code&gt;-c&lt;/code&gt; or the &lt;code&gt;-d&lt;/code&gt; options.</source>
          <target state="translated">Чтобы изменить конфигурацию, вам нужно будет использовать параметры &lt;code&gt;-c&lt;/code&gt; или &lt;code&gt;-d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82b774af2b2d757667a119fdffcb3a39066bffc5" translate="yes" xml:space="preserve">
          <source>To change the value of an</source>
          <target state="translated">Чтобы изменить значение</target>
        </trans-unit>
        <trans-unit id="c3243d9e5f9c11b853cdbfbdad7815af406db7ec" translate="yes" xml:space="preserve">
          <source>To check if you've got an object derived from a specific class you have to write:</source>
          <target state="translated">Чтобы проверить,есть ли у вас объект,производный от определенного класса,вам нужно написать:</target>
        </trans-unit>
        <trans-unit id="b5f0280c18244571ee821966259aa01905eea140" translate="yes" xml:space="preserve">
          <source>To check that a PerlIO* is valid use PerlIOValid(PerlIO *f). (All this does is really just to check that the pointer is non-NULL and that the pointer behind that is non-NULL.)</source>
          <target state="translated">Чтобы проверить,что PerlIO*является действительным,используйте PerlIOValid(PerlIO *f).(На самом деле это делается только для того,чтобы проверить,что указатель не является NULL и что указатель,находящийся за ним,не является NULL).</target>
        </trans-unit>
        <trans-unit id="6efc33cfc9910a60ea4ef9bf5110b124df74dec6" translate="yes" xml:space="preserve">
          <source>To circumvent this, Perl uses two hacks. They help against</source>
          <target state="translated">Чтобы обойти это,Перл использует два взлома.Они помогают против</target>
        </trans-unit>
        <trans-unit id="9b687155f88b0a0c7f0b7a50cd6c0fc2a98e0825" translate="yes" xml:space="preserve">
          <source>To clear the screen, you just have to print the special sequence that tells the terminal to clear the screen. Once you have that sequence, output it when you want to clear the screen.</source>
          <target state="translated">Чтобы очистить экран,достаточно распечатать специальную последовательность,которая говорит терминалу очистить экран.Как только вы получите эту последовательность,выводите ее,когда захотите очистить экран.</target>
        </trans-unit>
        <trans-unit id="5339fbdb482ebe20149617c58a946c9025ec4bd2" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8() &lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">Чтобы сравнить две строки без &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;учета&lt;/a&gt; регистра, используйте foldEQ_utf8 () (строки не обязательно должны иметь одинаковую кодировку UTF-8).</target>
        </trans-unit>
        <trans-unit id="9ef4437f2da5ad50f0107615b5cd7fb7937669db" translate="yes" xml:space="preserve">
          <source>To compile Perl with threads, add -Dusethreads to the arguments of Configure. Verify that the -D_POSIX_C_SOURCE=199506L compiler flag is automatically added to the list of flags. Also make sure that -lpthread is listed before -lc in the list of libraries to link Perl with. The hints provided for HP-UX during Configure will try very hard to get this right for you.</source>
          <target state="translated">Чтобы скомпилировать Perl с потоками,добавьте -Dusethreads к аргументам Configure.Убедитесь,что флаг компилятора -D_POSIX_C_SOURCE=199506L автоматически добавлен в список флагов.Также убедитесь,что -lpthread указан перед -lc в списке библиотек для линковки Perl.Подсказки,предоставляемые для HP-UX во время конфигурирования,очень постараются сделать это правильно.</target>
        </trans-unit>
        <trans-unit id="dca1f2d388460992485bc83958326b4fabbe3a89" translate="yes" xml:space="preserve">
          <source>To compile a 64-bit application on an UltraSparc with a recent Sun Compiler, you need to use the flag &quot;-xarch=v9&quot;. getconf(1) will tell you this, e.g.</source>
          <target state="translated">Для компиляции 64-битного приложения на UltraSparc с недавним компилятором Sun необходимо использовать флаг &quot;-xarch=v9&quot;.getconf(1)скажет об этом,например.</target>
        </trans-unit>
        <trans-unit id="87a608f7610a06343062c0a4f15a78987866b679" translate="yes" xml:space="preserve">
          <source>To compress all files in the directory &quot;/my/home&quot; that match &quot;*.txt&quot; and store the compressed data in the same directory</source>
          <target state="translated">Сжимать все файлы в директории &quot;/my/home&quot;,соответствующие &quot;*.txt&quot; и хранить сжатые данные в той же директории.</target>
        </trans-unit>
        <trans-unit id="e79c6c77e53867aede1a00267dc0d36f666b7950" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">Чтобы сжать поток данных RFC 1950, установите &lt;code&gt;WindowBits&lt;/code&gt; на положительное число от 8 до 15.</target>
        </trans-unit>
        <trans-unit id="7421981a167883ab2bc4949efb716b7db4314b6b" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">Чтобы сжать поток данных RFC 1951, установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0992d170df6f988844c94c5a16d02581fe60f0" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">Чтобы сжать поток данных RFC 1952 (например, gzip), установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;WANT_GZIP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c0a5b03c1713572aa7618df4ce2ea31c5f8ea2a" translate="yes" xml:space="preserve">
          <source>To concatenate</source>
          <target state="translated">Конкатенат</target>
        </trans-unit>
        <trans-unit id="6e6c0c8d29557c5cf786e08230a13bcf9f5a031b" translate="yes" xml:space="preserve">
          <source>To configure the</source>
          <target state="translated">Чтобы настроить</target>
        </trans-unit>
        <trans-unit id="b8324e82632846a0ff4c29dfcce46aaf6bb8f9fb" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">Чтобы подключить один дескриптор файла к нескольким дескрипторам вывода, вы можете использовать модули &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d6cbc660d600cd1c4583162826d97d790f4bf63" translate="yes" xml:space="preserve">
          <source>To conserve memory you should have your compiler modules loaded into the Link Pack Area (LPA/ELPA) rather than in a link list or step lib.</source>
          <target state="translated">Для экономии памяти вам следует загружать модули компилятора в Link Pack Area (LPA/ELPA),а не в список ссылок или step lib.</target>
        </trans-unit>
        <trans-unit id="968a823fad5813dfb21cd46750147776a5611926" translate="yes" xml:space="preserve">
          <source>To considerably speed up the initial CPAN shell startup, it is possible to use Storable to create a cache of metadata. If Storable is not available, the normal index mechanism will be used.</source>
          <target state="translated">Чтобы значительно ускорить начальный запуск CPAN оболочки,можно использовать Storable для создания кэша метаданных.Если Storable недоступен,будет использован обычный механизм индексации.</target>
        </trans-unit>
        <trans-unit id="20a4b2b8d77aba12d02e264b26db5b4fc2052c4a" translate="yes" xml:space="preserve">
          <source>To contact the author, send email to: &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</source>
          <target state="translated">Чтобы связаться с автором, отправьте электронное письмо по &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt; : mjd-perl-tiefile+@plover.com</target>
        </trans-unit>
        <trans-unit id="d4e7d2faeb717445863f554610fdabbf94c812cb" translate="yes" xml:space="preserve">
          <source>To control what text is used for display, you use &quot;&lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt;&quot;, as in:</source>
          <target state="translated">Чтобы контролировать, какой текст используется для отображения, вы используете &amp;laquo; &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; &amp;raquo;, например:</target>
        </trans-unit>
        <trans-unit id="0f2616580d4b758d8bc7475f582ba3ef32958144" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$Config{perlpath}&lt;/code&gt; to a file pathname, say:</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;$Config{perlpath}&lt;/code&gt; в путь к файлу, скажите:</target>
        </trans-unit>
        <trans-unit id="445d48b4e3ded0561c8b941a914e856d01c116d2" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$^X&lt;/code&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;$^X&lt;/code&gt; в путь к файлу с учетом требований различных возможностей операционной системы, скажите:</target>
        </trans-unit>
        <trans-unit id="c00d24e73fce2df83990c0f155f2d36a18a08fc4" translate="yes" xml:space="preserve">
          <source>To convert an octal number, use from_oct();</source>
          <target state="translated">Для преобразования восьмеричного числа используйте функцию from_oct();</target>
        </trans-unit>
        <trans-unit id="7d95d35a7d9c8de57b1e556f0a9920a9c8320986" translate="yes" xml:space="preserve">
          <source>To convert from EBCDIC 037 to ASCII just reverse the order of the tr/// arguments like so:</source>
          <target state="translated">Для преобразования из EBCDIC 037 в ASCII просто переверните порядок аргументов tr///так:</target>
        </trans-unit>
        <trans-unit id="e95102da8c741e9ba252adcb490152dec1b8623d" translate="yes" xml:space="preserve">
          <source>To convert from new-style to old-style, follow this recipe:</source>
          <target state="translated">Чтобы перейти от нового стиля к старому,следуйте этому рецепту:</target>
        </trans-unit>
        <trans-unit id="9fa39707ee5532360879dd87b7e44a99cff8fee0" translate="yes" xml:space="preserve">
          <source>To copy all your .c file to a backup directory</source>
          <target state="translated">Чтобы скопировать все ваши .c-файлы в каталог резервного копирования.</target>
        </trans-unit>
        <trans-unit id="5ab2f997dcaa14c701c81b93174b6bfe66ee6931" translate="yes" xml:space="preserve">
          <source>To copy the array, use</source>
          <target state="translated">Чтобы скопировать массив,используйте</target>
        </trans-unit>
        <trans-unit id="86582412ddc1c4958ec10cc1409f68b2a052f72a" translate="yes" xml:space="preserve">
          <source>To cover such cases, you can redispatch methods via:</source>
          <target state="translated">Чтобы охватить такие случаи,можно использовать методы повторного исправления:</target>
        </trans-unit>
        <trans-unit id="816db1c262f755f697320a74d5b828dbd17231a2" translate="yes" xml:space="preserve">
          <source>To create Unicode characters in literals, use the &lt;code&gt;\N{...}&lt;/code&gt; notation in double-quoted strings:</source>
          <target state="translated">Чтобы создать символы Юникода в литералах, используйте нотацию &lt;code&gt;\N{...}&lt;/code&gt; в строках , заключенных в двойные кавычки:</target>
        </trans-unit>
        <trans-unit id="c36e175a2f7ac1c4707a3b48724437b649be4b2b" translate="yes" xml:space="preserve">
          <source>To create a POD filter for translating POD documentation into some other format, you create a subclass of &lt;b&gt;Pod::Parser&lt;/b&gt; which typically overrides just the base class implementation for the following methods:</source>
          <target state="translated">Чтобы создать фильтр POD для перевода документации POD в какой-либо другой формат, вы создаете подкласс &lt;b&gt;Pod :: Parser,&lt;/b&gt; который обычно переопределяет только реализацию базового класса для следующих методов:</target>
        </trans-unit>
        <trans-unit id="3376aadc06d935bc6556cf078e6fff6d6ceed1e6" translate="yes" xml:space="preserve">
          <source>To create a Perl module that implements a PerlIO layer in Perl (as opposed to in C using XS as the interface to Perl), you need to supply some of the following subroutines. It is recommended to create these Perl modules in the PerlIO::via:: namespace, so that they can easily be located on CPAN and use the default namespace feature of the PerlIO::via module itself.</source>
          <target state="translated">Для создания модуля Perl,реализующего слой PerlIO на Perl (в отличие от модуля на C,использующего XS в качестве интерфейса к Perl),необходимо ввести некоторые из следующих подпрограмм.Рекомендуется создавать эти Perl-модули в пространстве имён PerlIO::via:,чтобы их можно было легко разместить на CPAN и использовать функцию пространства имён по умолчанию PerlIO::via самого модуля.</target>
        </trans-unit>
        <trans-unit id="cea82dcc2341d67ceae28cb7f8dd640de30d8fab" translate="yes" xml:space="preserve">
          <source>To create a child &lt;b&gt;process&lt;/b&gt; identical to the parent process at its moment of conception, at least until it gets ideas of its own. A thread with protected memory.</source>
          <target state="translated">Создать дочерний &lt;b&gt;процесс,&lt;/b&gt; идентичный родительскому процессу в момент его зачатия, по крайней мере, до тех пор, пока у него не появятся собственные идеи. Поток с защищенной памятью.</target>
        </trans-unit>
        <trans-unit id="973c5f5d0d37e9d577d7def77212ab83a77d00d7" translate="yes" xml:space="preserve">
          <source>To create a complex number, use either:</source>
          <target state="translated">Чтобы создать комплексное число,используйте либо то,либо другое:</target>
        </trans-unit>
        <trans-unit id="2ba00f13d11568a68eea0b9363c1c701b94f3530" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt; . For example:</source>
          <target state="translated">Чтобы создать обработчик, определите его как подпрограмму с тем же именем, что и желаемый атрибут, и объявите саму подпрограмму с атрибутом &lt;code&gt;:ATTR&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="0f301595bc4c387e143da9231296df032806e83c" translate="yes" xml:space="preserve">
          <source>To create a mortal variable, use the functions:</source>
          <target state="translated">Для создания смертельной переменной используйте функции:</target>
        </trans-unit>
        <trans-unit id="168d2bd52151b2f88de55aa6a46a9bc34a213502" translate="yes" xml:space="preserve">
          <source>To create a named pipe, use the &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; function.</source>
          <target state="translated">Чтобы создать именованный канал, используйте функцию &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4519b518bb57bb6e760a3915cac3cb53c117b7" translate="yes" xml:space="preserve">
          <source>To create a new Perl variable with an undef value which can be accessed from your Perl script, use the following routines, depending on the variable type.</source>
          <target state="translated">Чтобы создать новую переменную Perl со значением undef,к которой можно получить доступ из вашего Perl скрипта,используйте следующие процедуры,в зависимости от типа переменной.</target>
        </trans-unit>
        <trans-unit id="c5e6c240b7113609dabfe56dd41076e1c64fdaed" translate="yes" xml:space="preserve">
          <source>To create a new compartment, use</source>
          <target state="translated">Для создания нового отсека используйте</target>
        </trans-unit>
        <trans-unit id="a2f8f5de503a593a35d422a3d1a1da701a2bb15e" translate="yes" xml:space="preserve">
          <source>To create a reference, use either of the following functions:</source>
          <target state="translated">Для создания ссылки используйте одну из следующих функций:</target>
        </trans-unit>
        <trans-unit id="3b14234e60346a5da75e272e4ecdc1bcef627a2f" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt; ).</source>
          <target state="translated">Для создания ссылки мы используем функцию &lt;code&gt;newRV&lt;/code&gt; . Обратите внимание, что в этом случае (и во многих других) вы можете преобразовать AV * или HV * в тип SV *. Это позволяет вам использовать ссылки на массивы, хэши и скаляры с одной и той же функцией. И наоборот, функция &lt;code&gt;SvRV&lt;/code&gt; всегда возвращает SV *, который может потребоваться привести к соответствующему типу, если это нечто иное, чем скаляр (проверьте с помощью &lt;code&gt;SvTYPE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f750d278ece92b690ce083757a8b99d17e4a1cc6" translate="yes" xml:space="preserve">
          <source>To create a shared library, the following steps must be performed:</source>
          <target state="translated">Для создания общей библиотеки необходимо выполнить следующие шаги:</target>
        </trans-unit>
        <trans-unit id="3c6eb343e88be36bc92d3d97f3219df475d3ded3" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt; , that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">Чтобы создать zip-файл &lt;code&gt;output.zip&lt;/code&gt; , содержащий сжатое содержимое файлов &lt;code&gt;alpha.txt&lt;/code&gt; и &lt;code&gt;beta.txt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8a9c4100fca7c9df2f642138fcef0fc96929592" translate="yes" xml:space="preserve">
          <source>To create an HV, you use the following routine:</source>
          <target state="translated">Чтобы создать HV,вы используете следующую процедуру:</target>
        </trans-unit>
        <trans-unit id="0094ef6c2580e3be5fb982924088c9990a9a669b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">Чтобы создать поток данных RFC 1950, установите &lt;code&gt;WindowBits&lt;/code&gt; на положительное число.</target>
        </trans-unit>
        <trans-unit id="c43fa53c9a4af41c4362a70dd0d3da19011de429" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">Чтобы создать поток данных RFC 1951, установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbb0b362cb67cdcf254362d24dcd3489205dd8b1" translate="yes" xml:space="preserve">
          <source>To create your own result types you have two options:</source>
          <target state="translated">Для создания собственных типов результатов у вас есть два варианта:</target>
        </trans-unit>
        <trans-unit id="948e86a50124d6c16a2bb795d3ad5dd4ba16fd66" translate="yes" xml:space="preserve">
          <source>To deallocate the memory of a &lt;b&gt;referent&lt;/b&gt; (first triggering its &lt;code&gt;DESTROY&lt;/code&gt; method, if it has one).</source>
          <target state="translated">Чтобы освободить память &lt;b&gt;референта&lt;/b&gt; (сначала запустив его метод &lt;code&gt;DESTROY&lt;/code&gt; , если он есть).</target>
        </trans-unit>
        <trans-unit id="684b7eba474ceeeee203e03efc4972ceab5f4011" translate="yes" xml:space="preserve">
          <source>To declare a file-private variable, you still use a lexical variable. A file is also a scope, so a lexical variable defined in the file cannot be seen from any other file.</source>
          <target state="translated">Чтобы объявить файл-частную переменную,вы все равно используете лексическую переменную.Файл также является областью видимости,поэтому лексическая переменная,определенная в файле,не может быть видна ни из какого другого файла.</target>
        </trans-unit>
        <trans-unit id="26f359ab42151643a554fcca60e916cbc3b8c6c1" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</source>
          <target state="translated">Чтобы объявить несколько родителей, вам просто нужно передать несколько имен классов для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="195f600c4f130988d6cb960024f570abb452421b" translate="yes" xml:space="preserve">
          <source>To declare subroutines:</source>
          <target state="translated">Объявить подпрограммы:</target>
        </trans-unit>
        <trans-unit id="d689355c5c4c25b69703a4f888325a4f315e40d5" translate="yes" xml:space="preserve">
          <source>To decode the string, use the &lt;code&gt;uri_unescape&lt;/code&gt; function:</source>
          <target state="translated">Чтобы декодировать строку, используйте функцию &lt;code&gt;uri_unescape&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c00b1b3082eeba042c1321adab39b3572b77ab5f" translate="yes" xml:space="preserve">
          <source>To define a new encoding, use:</source>
          <target state="translated">Чтобы определить новую кодировку,используйте:</target>
        </trans-unit>
        <trans-unit id="90539d229e0f3e1882d607e70d036357967dd42b" translate="yes" xml:space="preserve">
          <source>To define an anonymous subroutine at runtime:</source>
          <target state="translated">Определить анонимную подпрограмму во время выполнения:</target>
        </trans-unit>
        <trans-unit id="c9cdf944c5644c128ca4890eae1d815775404ea8" translate="yes" xml:space="preserve">
          <source>To define your own variables, simply add them to the hash, or change existing values if you need to. The level and format are passed in as references to scalars, but it is unlikely that they will need to be changed or even used.</source>
          <target state="translated">Чтобы определить свои собственные переменные,просто добавьте их в хэш или измените существующие значения,если это необходимо.Уровень и формат передаются в виде ссылок на скаляры,но вряд ли их придется менять или даже использовать.</target>
        </trans-unit>
        <trans-unit id="663c37fcccd4eb9d16f3753290874adfe0a38adc" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to it.</source>
          <target state="translated">Чтобы удалить фильтр, передайте ему &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7282a69c7ceaa80a01f9176cf957edc11cea4de" translate="yes" xml:space="preserve">
          <source>To delete lines, only print the ones that you want.</source>
          <target state="translated">Чтобы удалить строки,печатайте только те,которые вам нужны.</target>
        </trans-unit>
        <trans-unit id="c1469f4d29b40fb0b7ab86c2c4e92578f7c6eb9f" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</source>
          <target state="translated">Чтобы определить во время выполнения, была ли эта возможность скомпилирована в вашем Perl, вы можете проверить значение &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ce033ec9e41969bd8c16961760514dcb521d365" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">Чтобы определить, поставляется ли модуль с вашей версией Perl, вы можете установить и использовать &lt;a href=&quot;module/corelist&quot;&gt;модуль Module :: CoreList&lt;/a&gt; . В нем есть информация о модулях (с их версиями), включенных в каждый выпуск Perl.</target>
        </trans-unit>
        <trans-unit id="a3640814314afd9f7ac9d11a68cf889d6f47fec5" translate="yes" xml:space="preserve">
          <source>To determine if a string is in Unicode, use:</source>
          <target state="translated">Чтобы определить,есть ли строка в Юникоде,используйте:</target>
        </trans-unit>
        <trans-unit id="bca0ec2b6522f981d9c11831a03f1f68a8800f50" translate="yes" xml:space="preserve">
          <source>To determine if an SV is a reference, you can use the following macro:</source>
          <target state="translated">Чтобы определить,является ли SV эталоном,можно использовать следующий макрос:</target>
        </trans-unit>
        <trans-unit id="c9936c817f7d3f0a431d8c4cc266d4265437482c" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">Чтобы определить, работаете ли вы в ASCII или EBCDIC, вы можете использовать возвращаемое значение &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; для проверки одного или нескольких символьных значений. Например:</target>
        </trans-unit>
        <trans-unit id="86e75dff4a5cb692b3db4e186257a30b993c598a" translate="yes" xml:space="preserve">
          <source>To determine whether or not perl was built under an EBCDIC code page you can use the Config module like so:</source>
          <target state="translated">Чтобы определить,был ли perl собран под кодовой страницей EBCDIC или нет,можно воспользоваться модулем Config:</target>
        </trans-unit>
        <trans-unit id="c7ca989a561cc6bb21cb242f3f9a4867fcc2a0a2" translate="yes" xml:space="preserve">
          <source>To determine which category a specific warning has been assigned to see &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;.</source>
          <target state="translated">Чтобы определить, какой категории было назначено конкретное предупреждение, необходимо просмотреть &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2650be423c3da22a5978107c38e624c70d0e420" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">Чтобы умереть с простым строковым сообщением, функция &lt;a href=&quot;#croak&quot;&gt;кваканья&lt;/a&gt; может быть более удобной.</target>
        </trans-unit>
        <trans-unit id="347758299b3b52a08c513c37128e636634230c65" translate="yes" xml:space="preserve">
          <source>To disable prototypes:</source>
          <target state="translated">Чтобы отключить прототипы:</target>
        </trans-unit>
        <trans-unit id="5d0844b4d1a693267fe5fcf752c200ff27d0a20a" translate="yes" xml:space="preserve">
          <source>To disable scoping:</source>
          <target state="translated">Чтобы отключить сканирование:</target>
        </trans-unit>
        <trans-unit id="6a2e4cf0ee9b26b39ec068b4b4c9bcaa2ebda9e0" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">Чтобы отключить эту проверку, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b80cbb6c9445e33c66e64e8bbc664c2dc7cb143d" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; strings or from any kind of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">Чтобы отключить этот безопасный режим по умолчанию, установите для этих значений значение выше 0. На уровне 1 вы получаете обратные трассировки при получении любого вида предупреждения (это часто раздражает) или исключения (это часто полезно). К сожалению, отладчик не может отличить фатальные исключения от нефатальных. Если &lt;code&gt;dieLevel&lt;/code&gt; равно 1, тогда ваши нефатальные исключения также отслеживаются и бесцеремонно изменяются, если они &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; из eval'ed строк или из любого вида &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; в модулях, которые вы пытаетесь загрузить. Если &lt;code&gt;dieLevel&lt;/code&gt; равно 2, отладчику все равно, откуда они пришли: он узурпирует ваш обработчик исключений и распечатывает трассировку, а затем модифицирует все исключения, добавляя собственные украшения. Это может быть полезно для некоторых целей трассировки, но имеет тенденцию безнадежно уничтожить любую программу, серьезно относящуюся к обработке исключений.</target>
        </trans-unit>
        <trans-unit id="8d156c08336acd4fd9a2800ec24f479a8112dea4" translate="yes" xml:space="preserve">
          <source>To disable version checking:</source>
          <target state="translated">Чтобы отключить проверку версии:</target>
        </trans-unit>
        <trans-unit id="738a71c259ac0a8afb90292476b05521cb3a2b41" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt; , you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">Чтобы запретить использование, например, &lt;code&gt;LWP&lt;/code&gt; и &lt;code&gt;Net::FTP&lt;/code&gt; , вы можете установить для $ File :: Fetch :: BLACKLIST значение:</target>
        </trans-unit>
        <trans-unit id="80dd5fada40953f3424fd8a183a453e068557bb1" translate="yes" xml:space="preserve">
          <source>To discover what type of value the reference refers to, use the following macro and then check the return value.</source>
          <target state="translated">Чтобы узнать,к какому типу значений относится ссылка,используйте следующий макрос,а затем проверьте возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="8fc94d5f52eb1139b287df828008badfb6c3e089" translate="yes" xml:space="preserve">
          <source>To display and change the libnet configuration run the libnetcfg command.</source>
          <target state="translated">Для отображения и изменения конфигурации libnet выполните команду libnetcfg.</target>
        </trans-unit>
        <trans-unit id="60ed656a96349b78cdba5a83471f5324d8dd1e87" translate="yes" xml:space="preserve">
          <source>To display the results you use the</source>
          <target state="translated">Для отображения результатов вы используете</target>
        </trans-unit>
        <trans-unit id="ad781551179d37e74d6f0377992b51ea7bdaace0" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">Чтобы сделать это правильно, вы можете использовать один из модулей &lt;code&gt;Date&lt;/code&gt; , поскольку они работают с календарями, а не с временем. Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; упрощает задачу и дает вам то же время суток, только накануне, несмотря на переход на летнее время:</target>
        </trans-unit>
        <trans-unit id="f1d6265a7b40372fb699b2b2f27a1df7b8f80a66" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">Чтобы выполнить аналог &lt;code&gt;cp -R&lt;/code&gt; (т.е. рекурсивно скопировать все дерево каталогов) в переносимом Perl, вам нужно либо написать что-нибудь самостоятельно, либо найти хороший модуль CPAN, такой как &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="800198c8e77892b2ea37f8a62c33fb5be9843971" translate="yes" xml:space="preserve">
          <source>To do this we need to produce a program by parsing the text. We then need to execute the program to find the point in the string that matches. And we need to do the whole thing efficiently.</source>
          <target state="translated">Для этого нужно создать программу,разобрав текст.Затем нам нужно выполнить программу,чтобы найти точку в строке,которая совпадает.И нам нужно сделать все это эффективно.</target>
        </trans-unit>
        <trans-unit id="b3b368d6bf057c7196323316138f2bb623cf857e" translate="yes" xml:space="preserve">
          <source>To do this you need to store a copy of the object returned from the tie.</source>
          <target state="translated">Для этого необходимо сохранить копию объекта,возвращенного с галстука.</target>
        </trans-unit>
        <trans-unit id="16944f02408f01608a70adc6c00bddd6a6f21c5d" translate="yes" xml:space="preserve">
          <source>To do this, declare the XSUB as</source>
          <target state="translated">Для этого объявите XSUB как</target>
        </trans-unit>
        <trans-unit id="9ba25feb906f9144f135e56832aaff07eb5da168" translate="yes" xml:space="preserve">
          <source>To do this, simple invoke the redispatch as:</source>
          <target state="translated">Чтобы сделать это,просто вызовите redispatch как:</target>
        </trans-unit>
        <trans-unit id="2b963497fc0bd80a2ad6cd72e920bb19d3acf535" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">Для этого вы можете расширить существующий &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP :: Formatter&lt;/a&gt; или написать свой собственный. Написание средств форматирования немного сложнее, чем написание</target>
        </trans-unit>
        <trans-unit id="4d922248445626035fad600ec3b500e3d07eeccb" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">Для этого вы можете либо расширить существующий &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; , либо написать свой собственный. Это довольно простой API, и их можно загрузить и настроить с помощью параметра &lt;code&gt;sources&lt;/code&gt; в &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9af8e6fc2b2d44ed39a720480b5eca952598206" translate="yes" xml:space="preserve">
          <source>To do this, you have to parse out each word in the input stream. We'll pretend that by word you mean chunk of alphabetics, hyphens, or apostrophes, rather than the non-whitespace chunk idea of a word given in the previous question:</source>
          <target state="translated">Для этого необходимо разобрать каждое слово во входном потоке.Мы притворимся,что под словом вы подразумеваете кусок алфавита,дефисы или апострофы,а не небелую кусок идеи слова,приведенную в предыдущем вопросе:</target>
        </trans-unit>
        <trans-unit id="a594dc0644909bfef7173f1f8eb29922809128db" translate="yes" xml:space="preserve">
          <source>To do what you meant properly, you must write:</source>
          <target state="translated">Чтобы сделать то,что вы имели в виду,вы должны написать:</target>
        </trans-unit>
        <trans-unit id="d3e2fbf11b8c81738d92b26c858673a8798bed9d" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; , and so on.</source>
          <target state="translated">Чтобы подчеркнуть, что вы работаете только с символами ASCII, вы можете добавить &lt;code&gt;_A&lt;/code&gt; к каждому &lt;code&gt;isALPHA_A&lt;/code&gt; столбце ASCII: isALPHA_A , &lt;code&gt;isDIGIT_A&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="e2f50143516f5760cd1414be18dcb711d9b307dd" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">Чтобы включить раскраску из командной строки, вы можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="b01967f773567b844b2b023b2a86bde4df70fc34" translate="yes" xml:space="preserve">
          <source>To enable prototypes:</source>
          <target state="translated">Чтобы включить прототипы:</target>
        </trans-unit>
        <trans-unit id="5ccde66aca7ada9c8fed76ada1d4a0446a4f8743" translate="yes" xml:space="preserve">
          <source>To enable scoping:</source>
          <target state="translated">Чтобы включить обзор:</target>
        </trans-unit>
        <trans-unit id="1484f429016f98a746a3ab26c198f24bb67adaaa" translate="yes" xml:space="preserve">
          <source>To enable version checking:</source>
          <target state="translated">Чтобы включить проверку версии:</target>
        </trans-unit>
        <trans-unit id="270b403e8cadfb40d1d97c0de3bf7642f9c98fb6" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">Чтобы самостоятельно закодировать строку, используйте модуль &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt; . Функция &lt;code&gt;uri_escape&lt;/code&gt; возвращает экранированную строку:</target>
        </trans-unit>
        <trans-unit id="197383dea9cb9c2b7e4139f047ab7802bc1168de" translate="yes" xml:space="preserve">
          <source>To end a Pod block, use a blank line, then a line beginning with &quot;=cut&quot;, and a blank line after it. This lets Perl (and the Pod formatter) know that this is where Perl code is resuming. (The blank line before the &quot;=cut&quot; is not technically necessary, but many older Pod processors require it.)</source>
          <target state="translated">Чтобы закончить блок Pod,используйте пустую строку,затем строку,начинающуюся с &quot;=cut&quot;,и пустую строку после нее.Это позволяет Perl (и форматировщику Pod)знать,что именно здесь возобновляется Perl-код.(Пустая строка перед &quot;=cut&quot; технически не нужна,но многие старые процессоры Pod требуют этого).</target>
        </trans-unit>
        <trans-unit id="0ae4a1a4ec134ed8922ee208a028b2c3245ebe13" translate="yes" xml:space="preserve">
          <source>To enforce scalar context in this particular case, however, you need merely omit the parentheses:</source>
          <target state="translated">Однако,чтобы обеспечить соблюдение скалярного контекста в данном конкретном случае,вам нужно просто опустить круглые скобки:</target>
        </trans-unit>
        <trans-unit id="5528aa31607b22ee5ba7b25dc9ad20fd957a80a3" translate="yes" xml:space="preserve">
          <source>To ensure your Perl programs can see these newly installed modules, set your &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable to</source>
          <target state="translated">Чтобы ваши программы Perl могли видеть эти недавно установленные модули, установите для переменной среды &lt;code&gt;PERL5LIB&lt;/code&gt; значение</target>
        </trans-unit>
        <trans-unit id="7aa8a6d9b5359d93562881107c4eb01ac8b79421" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt; :</source>
          <target state="translated">Чтобы избежать особого значения &lt;code&gt;.&lt;/code&gt; , мы используем &lt;code&gt;\Q&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f8b13457bc503e2905034bca18967c492e5be31" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out our old STDERR:</source>
          <target state="translated">Обменяться командами STDOUT и STDERR,чтобы захватить STDERR,но оставить его STDOUT,чтобы выйти из нашего старого STDERR:</target>
        </trans-unit>
        <trans-unit id="f19cbea3f43d914ef5dccac2f20ddb20b0a670bb" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out the old STDERR:</source>
          <target state="translated">Обменяться командами STDOUT и STDERR,чтобы захватить STDERR,но оставить его STDOUT,чтобы выйти из старого STDERR:</target>
        </trans-unit>
        <trans-unit id="1e299ba0ecd4337d918ed97321e55b553fe7e0a0" translate="yes" xml:space="preserve">
          <source>To exercise the various implementations the script &lt;a href=&quot;#Example-2&quot;&gt;below&lt;/a&gt; can be used.</source>
          <target state="translated">Для проверки различных реализаций можно использовать &lt;a href=&quot;#Example-2&quot;&gt;приведенный ниже&lt;/a&gt; сценарий .</target>
        </trans-unit>
        <trans-unit id="746a283f2992b56a8070a48ac33ef2cb2b8ab7fb" translate="yes" xml:space="preserve">
          <source>To explain them each in detail:</source>
          <target state="translated">Чтобы объяснить им каждую деталь:</target>
        </trans-unit>
        <trans-unit id="337ab3fc6e23ee2083bb48006f6530a512cb7265" translate="yes" xml:space="preserve">
          <source>To explicitly turn off a &quot;FATAL&quot; warning you just disable the warning it is associated with. So, for example, to disable the &quot;void&quot; warning in the example above, either of these will do the trick:</source>
          <target state="translated">Чтобы явно отключить предупреждение &quot;FATAL&quot;,просто отключите предупреждение,с которым оно связано.Так,например,чтобы отключить предупреждение &quot;void&quot; в приведенном выше примере,любой из них выполнит свою задачу:</target>
        </trans-unit>
        <trans-unit id="d8cfaf574ce10955d44800ed1fb485165bb12d03" translate="yes" xml:space="preserve">
          <source>To extract a comma-delimited list of numbers, use</source>
          <target state="translated">Чтобы извлечь список номеров,разделенных запятыми,воспользуйтесь функцией</target>
        </trans-unit>
        <trans-unit id="d086f02213d0494d6662b67a4783c59065f8a170" translate="yes" xml:space="preserve">
          <source>To extract an ASCII tar archive on BS2000 POSIX you need an ASCII filesystem (we used the mountpoint /usr/local/ascii for this). Now you extract the archive in the ASCII filesystem without I/O-conversion:</source>
          <target state="translated">Для извлечения архива ASCII tar на POSIX BS2000 вам понадобится файловая система ASCII (для этого мы использовали точку монтирования /usr/local/ascii).Теперь вы распаковываете архив в файловой системе ASCII без преобразования ввода/вывода:</target>
        </trans-unit>
        <trans-unit id="c062b7c2a495ae2a5b72a1379e8b1a41239ea1d2" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как использовать этот модуль, см. &lt;a href=&quot;../encode&quot;&gt;Кодирование&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3930f92a272e8f2e02166feb6d52740dba8a2a7" translate="yes" xml:space="preserve">
          <source>To find out</source>
          <target state="translated">Чтобы узнать</target>
        </trans-unit>
        <trans-unit id="8b9ad1d9bf5e88e70343c9bc73bc8f95e823175e" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как использовать этот модуль подробно, см. &lt;a href=&quot;../encode&quot;&gt;Кодирование&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8814e60c44afe937889a748a7dc5d647bd329617" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать подробно, какие кодировки поддерживаются этим пакетом, см. &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7957585a16fb8e9f58abff4512426bfd62b9e660" translate="yes" xml:space="preserve">
          <source>To find out where a module's source code is located, use</source>
          <target state="translated">Для того чтобы узнать,где находится исходный код модуля,используйте</target>
        </trans-unit>
        <trans-unit id="714fa5ade47f6c038c4e5047b338fbf758e5ccc9" translate="yes" xml:space="preserve">
          <source>To find out whether a given string is a valid non-zero number, it's sometimes enough to test it against both numeric 0 and also lexical &quot;0&quot; (although this will cause noises if warnings are on). That's because strings that aren't numbers count as 0, just as they do in &lt;b&gt;awk&lt;/b&gt;:</source>
          <target state="translated">Чтобы определить, является ли данная строка допустимым ненулевым числом, иногда достаточно проверить ее как на числовой 0, так и на лексический &amp;laquo;0&amp;raquo; (хотя это вызовет шумы, если включены предупреждения). Это потому, что строки, не являющиеся числами, считаются за 0, как и в &lt;b&gt;awk&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="b365160bfd575c380666252714a7e2191298f003" translate="yes" xml:space="preserve">
          <source>To find out which character encodings your Perl supports, run:</source>
          <target state="translated">Чтобы узнать,какие кодировки символов поддерживает Perl,запустите:</target>
        </trans-unit>
        <trans-unit id="8d0d1d4b42258f044bb86db954a57628e8eecd09" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">Чтобы найти что-то между двумя одиночными символами, шаблон вроде &lt;code&gt;/x([^x]*)x/&lt;/code&gt; получит промежуточные биты в $ 1. Для нескольких &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; что- то вроде /alpha(.*?)omega/ . Для вложенных шаблонов и / или сбалансированных выражений см. Так называемую конструкцию &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)&lt;/a&gt; (доступную с perl 5.10). Модуль CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; может помочь в построении таких регулярных выражений (см., В частности, &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp :: Common :: &lt;/a&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;balance&lt;/a&gt; и Regexp :: Common :: delimited ).</target>
        </trans-unit>
        <trans-unit id="c8886406693c43465a74828d32fde569bd987324" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">Чтобы найти первый элемент массива, который удовлетворяет условию, вы можете использовать функцию &lt;code&gt;first()&lt;/code&gt; в модуле &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; , который поставляется с Perl 5.8. В этом примере выполняется поиск первого элемента, содержащего &amp;laquo;Perl&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f1ca27f7c9ffaf0873146b4d5569bf1f7dd85f24" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt; , as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">Чтобы найти пакет, в котором вы сейчас находитесь, используйте специальный литерал &lt;code&gt;__PACKAGE__&lt;/code&gt; , как &lt;a href=&quot;perldata&quot;&gt;описано&lt;/a&gt; в perldata . Вы можете использовать специальные литералы только как отдельные токены, поэтому вы не можете интерполировать их в строки, как вы можете с переменными:</target>
        </trans-unit>
        <trans-unit id="cffcf6d33c52e5caff06e5888e1b1afff8c79cd9" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt; , use &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt; instead.</source>
          <target state="translated">Чтобы найти синонимы для одиночных форм, таких как &lt;code&gt;\p{Any}&lt;/code&gt; , используйте вместо них &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b4474f5909a02cbe785465728ea131216f023c4" translate="yes" xml:space="preserve">
          <source>To find your local Perl Mongers (or PM as they're commonly abbreviated) group check the international Perl Mongers directory at &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt;.</source>
          <target state="translated">Чтобы найти свою местную группу Perl Mongers (или PM, как их обычно называют), загляните в международный каталог Perl Mongers по адресу &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51fa9c8218dc025937f10203b9150ec3a3d4872c" translate="yes" xml:space="preserve">
          <source>To fire up the debugger, type</source>
          <target state="translated">Чтобы запустить отладчик,напечатайте</target>
        </trans-unit>
        <trans-unit id="5061c6729e5e674eb297e87fb65b6e686195258a" translate="yes" xml:space="preserve">
          <source>To fix by applying one, as it were. In the realm of hackerdom, a listing of the differences between two versions of a program as might be applied by the &lt;b&gt;patch&lt;/b&gt;(1) program when you want to fix a bug or upgrade your old version.</source>
          <target state="translated">Исправить, применив как бы одну. В сфере хакерства - список различий между двумя версиями программы, который может быть применен программой &lt;b&gt;patch&lt;/b&gt; (1), когда вы хотите исправить ошибку или обновить старую версию.</target>
        </trans-unit>
        <trans-unit id="baa8da9e4b55dce6e5a8c524e072f785277c31e7" translate="yes" xml:space="preserve">
          <source>To fix this, some people formed Unicode, Inc. and produced a new character set containing all the characters you can possibly think of and more. There are several ways of representing these characters, and the one Perl uses is called UTF-8. UTF-8 uses a variable number of bytes to represent a character. You can learn more about Unicode and Perl's Unicode model in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">Чтобы исправить это, некоторые люди создали Unicode, Inc. и создали новый набор символов, содержащий все символы, которые вы только можете придумать, и многое другое. Есть несколько способов представления этих символов, и тот, который использует Perl, называется UTF-8. UTF-8 использует переменное количество байтов для представления символа. Вы можете узнать больше о Unicode и модели Unicode Perl в &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f76f5a03185d9e714674242e64dfcf1b7f20c4" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), specify the &quot;a&quot; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt; . (The first occurrence of &quot;a&quot; restricts the &lt;code&gt;\d&lt;/code&gt; , etc., and the second occurrence adds the &lt;code&gt;/i&lt;/code&gt; restrictions.) But, note that code points outside the ASCII range will use Unicode rules for &lt;code&gt;/i&lt;/code&gt; matching, so the modifier doesn't really restrict things to just ASCII; it just forbids the intermixing of ASCII and non-ASCII.</source>
          <target state="translated">Чтобы запретить совпадения ASCII / не-ASCII (например, &amp;laquo;k&amp;raquo; с &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), укажите &amp;laquo;a&amp;raquo; дважды, например &lt;code&gt;/aai&lt;/code&gt; или &lt;code&gt;/aia&lt;/code&gt; . (Первое вхождение &quot;a&quot; ограничивает &lt;code&gt;\d&lt;/code&gt; и т. Д., А второе вхождение добавляет ограничения &lt;code&gt;/i&lt;/code&gt; .) Но обратите внимание, что кодовые точки вне диапазона ASCII будут использовать правила Unicode для сопоставления &lt;code&gt;/i&lt;/code&gt; , поэтому модификатор не на самом деле не ограничиваются только ASCII; он просто запрещает смешивание ASCII и не-ASCII.</target>
        </trans-unit>
        <trans-unit id="bc2a4c58af25cd402ee36a19ab3abed7cc44071e" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma).</source>
          <target state="translated">Чтобы заставить интерпретацию как вызов подпрограммы, либо поставьте амперсанд перед именем подпрограммы, либо уточните имя с ее пакетом. В качестве альтернативы вы можете импортировать подпрограмму (или сделать вид, что она импортирована с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="457433c503b0c64ab575af65985486ef91bd670a" translate="yes" xml:space="preserve">
          <source>To force multiple data values into an SV, you must do two things: use the &lt;code&gt;sv_set*v&lt;/code&gt; routines to add the additional scalar type, then set a flag so that Perl will believe it contains more than one type of data. The four macros to set the flags are:</source>
          <target state="translated">Чтобы принудительно &lt;code&gt;sv_set*v&lt;/code&gt; несколько значений данных в SV, вы должны сделать две вещи: использовать процедуры sv_set * v для добавления дополнительного скалярного типа, а затем установить флаг, чтобы Perl считал, что он содержит более одного типа данных. Четыре макроса для установки флагов:</target>
        </trans-unit>
        <trans-unit id="e794c449edc7f65a40ec8153981b15f3f2a9b550" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; . Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;).</source>
          <target state="translated">Чтобы освободить созданный &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; , вызовите SvREFCNT_dec (SV *) . Обычно в этом вызове нет необходимости (см. &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Подсчет ссылок и смертность&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2d1737256e6e8a51ce74a94d85a078c8dd0ab640" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">Чтобы получить доступ к символам, которые экспортируются из другого модуля. См. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; Camel в главе 27, &amp;laquo;Функции&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="dcb6076af26c9d87b4c92a15d546b5cbbac01e84" translate="yes" xml:space="preserve">
          <source>To generate just the stubs:</source>
          <target state="translated">Генерировать только шлейфы:</target>
        </trans-unit>
        <trans-unit id="535754fb5bff8ed1b444cf7b15654e6f3c7d7a5c" translate="yes" xml:space="preserve">
          <source>To get a Math::BigFloat you either need to call the operation manually, make sure the operands are already of the proper type or casted to that type via Math::BigFloat-&amp;gt;new():</source>
          <target state="translated">Чтобы получить Math :: BigFloat, вам нужно либо вызвать операцию вручную, убедитесь, что операнды уже имеют правильный тип, либо преобразованы в этот тип с помощью Math :: BigFloat-&amp;gt; new ():</target>
        </trans-unit>
        <trans-unit id="482a14b92894717900240dda3533f7f04de8b428" translate="yes" xml:space="preserve">
          <source>To get a binary stream an alternate method is to use:</source>
          <target state="translated">Для получения бинарного потока необходимо использовать альтернативный метод:</target>
        </trans-unit>
        <trans-unit id="342926328b3f4e6b863f62ddbfc63ea7184c5807" translate="yes" xml:space="preserve">
          <source>To get a full list of the available sync points:</source>
          <target state="translated">Получить полный список доступных точек синхронизации:</target>
        </trans-unit>
        <trans-unit id="4a7e3e5cefb00444495078948120515244d3f977" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">Чтобы получить случайное число между двумя значениями, вы можете использовать встроенную функцию &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; чтобы получить случайное число от 0 до 1. Оттуда вы перемещаете это в нужный диапазон.</target>
        </trans-unit>
        <trans-unit id="503a91db6b0ee3a6aaf3799cd04cbf8c2160ee5a" translate="yes" xml:space="preserve">
          <source>To get a real at or caret into the field, do this:</source>
          <target state="translated">Для того,чтобы получить реальную или заботу в поле,сделай это:</target>
        </trans-unit>
        <trans-unit id="6546b16387b88ec0ca99336cb1d0e013e452d98c" translate="yes" xml:space="preserve">
          <source>To get all the output from your error log, and not miss any messages via helpful operating system buffering, insert a line like this, at the start of your script:</source>
          <target state="translated">Чтобы получить весь вывод из вашего журнала ошибок и не пропустить ни одного сообщения через полезную буферизацию операционной системы,вставьте в начале вашего скрипта строку вроде этой:</target>
        </trans-unit>
        <trans-unit id="2baf587b399a3c62f41dfcb4f6a76fcf67a09c4b" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt; , the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt; .</source>
          <target state="translated">Чтобы получить &lt;code&gt;HMQ&lt;/code&gt; , расширение должно вызвать &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; в C. После выполнения этого вызова &lt;code&gt;hmq&lt;/code&gt; может быть доступен как &lt;code&gt;Perl_hmq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4fbf979e25bdf63e3a72510bfcc0bebacbf8c90" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt; ) in the open call:</source>
          <target state="translated">Чтобы получить небуферизованный поток, укажите небуферизованный уровень (например, &lt;code&gt;:unix&lt;/code&gt; ) в вызове open:</target>
        </trans-unit>
        <trans-unit id="4f25553ad923c6b2f304e605c8fcb2af6b398a17" translate="yes" xml:space="preserve">
          <source>To get around the error, place the word &lt;code&gt;DB_File&lt;/code&gt; in either single or double quotes, like this:</source>
          <target state="translated">Чтобы обойти ошибку, поместите слово &lt;code&gt;DB_File&lt;/code&gt; в одинарные или двойные кавычки, например:</target>
        </trans-unit>
        <trans-unit id="e7cc39162825d124202c37827aea79596926f995" translate="yes" xml:space="preserve">
          <source>To get around the security problem, I could also pull the values from a hash instead of evaluating variable names. Using a single &lt;code&gt;/e&lt;/code&gt;, I can check the hash to ensure the value exists, and if it doesn't, I can replace the missing value with a marker, in this case &lt;code&gt;???&lt;/code&gt; to signal that I missed something:</source>
          <target state="translated">Чтобы обойти проблему безопасности, я мог бы также извлечь значения из хэша вместо оценки имен переменных. Используя одиночный &lt;code&gt;/e&lt;/code&gt; , я могу проверить хэш, чтобы убедиться, что значение существует, и если это не так, я могу заменить отсутствующее значение маркером, в этом случае &lt;code&gt;???&lt;/code&gt; чтобы сигнализировать о том, что я что-то упустил:</target>
        </trans-unit>
        <trans-unit id="7daccee0149b6b5c023c3105df2756ca16d7041c" translate="yes" xml:space="preserve">
          <source>To get around these problems it is necessary to take a full copy of the SV. The code below shows &lt;code&gt;SaveSub2&lt;/code&gt; modified to do that.</source>
          <target state="translated">Чтобы обойти эти проблемы, необходимо взять полную копию SV. В приведенном ниже коде показано изменение &lt;code&gt;SaveSub2&lt;/code&gt; для этого.</target>
        </trans-unit>
        <trans-unit id="e5e782973aff491dec9c851f1733c85508f6c14a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">Чтобы обойти это, либо обновитесь до Perl v5.6.0 или новее, сделайте глобус самостоятельно с помощью readdir () и шаблонов, либо используйте такой модуль, как &lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt; , который не использует оболочку для выполнения глобусов.</target>
        </trans-unit>
        <trans-unit id="f6d7c7ba0c3680f1bdd16d6aa20e16ef63f21df2" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt; . You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">Чтобы обойти это, вам нужно разблокировать дескриптор выходного файла, в данном случае &lt;code&gt;STDOUT&lt;/code&gt; . Вы можете установить специальную переменную &lt;code&gt;$|&lt;/code&gt; к истинному значению (мнемоника: делая ваши файловые дескрипторы &quot;горячими&quot;):</target>
        </trans-unit>
        <trans-unit id="a6f34a68c60751e410691b9ae6ddd9f980469ba3" translate="yes" xml:space="preserve">
          <source>To get at hash elements:</source>
          <target state="translated">Чтобы добраться до гашиша:</target>
        </trans-unit>
        <trans-unit id="7f878bb059ecb8cc0e6a947e6d0564b810589ae6" translate="yes" xml:space="preserve">
          <source>To get even more recent perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">Чтобы получить еще более свежие хранилища Perl для всего диапазона HP-UX, посетите сайт бренда H.Merijn по адресу &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt; . Внимательно прочтите примечания, чтобы узнать, подходят ли доступные версии вашим потребностям.</target>
        </trans-unit>
        <trans-unit id="76a1d18d8c0d8e0ec36c61f2ab6bce082fca6308" translate="yes" xml:space="preserve">
          <source>To get finer test reports, call</source>
          <target state="translated">Чтобы получить более точные отчеты о тестах,позвоните</target>
        </trans-unit>
        <trans-unit id="93d274f25d53139f7087deba04a14a18e5484351" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt; , turn on the F register, as in:</source>
          <target state="translated">Чтобы получить записи указателя на &lt;code&gt;STDERR&lt;/code&gt; , включите регистр F, как в:</target>
        </trans-unit>
        <trans-unit id="8b6b89efcdec932089c6c9c0f91cf90b0d1e52b9" translate="yes" xml:space="preserve">
          <source>To get multiple values from an array:</source>
          <target state="translated">Получить несколько значений из массива:</target>
        </trans-unit>
        <trans-unit id="c67d46d6312179612215d6ef23eb3f6db1321700" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">Чтобы получить независимые от платформы элементы управления, вы можете использовать &lt;code&gt;\N{...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a965832b8b2f81c82888b8327d5081a21e8081aa" translate="yes" xml:space="preserve">
          <source>To get some interesting statistics, it is recommended that &lt;code&gt;randomize_urllist&lt;/code&gt; be set; this introduces some amount of randomness into the URL selection.</source>
          <target state="translated">Чтобы получить интересную статистику, рекомендуется установить &lt;code&gt;randomize_urllist&lt;/code&gt; ; это вносит некоторую случайность в выбор URL.</target>
        </trans-unit>
        <trans-unit id="42f32ff5f8a54ed95afefa260a5241934e3c3cb8" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">Чтобы получить несколько похожие, но зависящие от локали строки даты, соответствующим образом настройте переменные среды вашей локали (см. &lt;a href=&quot;../perllocale&quot;&gt;Perllocale&lt;/a&gt; ) и попробуйте, например:</target>
        </trans-unit>
        <trans-unit id="ab2c259ec21b8fdc7591d4aa060782af6913d852" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">Чтобы получить несколько похожие, но зависящие от локали строки даты, соответствующим образом настройте переменные среды вашей локали (см. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; ) и попробуйте, например:</target>
        </trans-unit>
        <trans-unit id="c33d002d66788db30ed6cc7efa61fd7b3021f5f2" translate="yes" xml:space="preserve">
          <source>To get the 25 traditional lowercase Greek letters, including both sigmas, you could use this instead:</source>
          <target state="translated">Чтобы получить 25 традиционных строчных греческих букв,включая оба сигмы,вы могли бы использовать это вместо них:</target>
        </trans-unit>
        <trans-unit id="6e85259394ca22644c2c269f73c9d0468d9813a0" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt; . There is no need to release the HAB after it is used.</source>
          <target state="translated">Чтобы получить HAB, расширение должно вызвать &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; в C. После выполнения этого вызова &lt;code&gt;hab&lt;/code&gt; может быть доступен как &lt;code&gt;Perl_hab&lt;/code&gt; . Нет необходимости освобождать HAB после его использования.</target>
        </trans-unit>
        <trans-unit id="35604b07a393cc3fdbf315f40abc25e64114d031" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">Чтобы получить IP-адрес, вы можете использовать встроенную функцию &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; , чтобы преобразовать имя в число. Чтобы превратить это число в форму октета с точками (abcd), которую ожидает большинство людей, используйте функцию &lt;code&gt;inet_ntoa&lt;/code&gt; из модуля &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; , который также поставляется с perl.</target>
        </trans-unit>
        <trans-unit id="aa0526e650783189d8454499d3396cf899e8f521" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для того, чтобы получить день года на любую дату, используйте &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; &amp;laquo;s &lt;code&gt;mktime&lt;/code&gt; , чтобы получить время в эпоху секунд для аргумента &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffadb121be361a5885303dda8c46c6cf80b68bb1" translate="yes" xml:space="preserve">
          <source>To get the last two digits of the year (e.g., &quot;01&quot; in 2001) do:</source>
          <target state="translated">Чтобы получить последние две цифры года (например,&quot;01&quot; в 2001 году),сделайте:</target>
        </trans-unit>
        <trans-unit id="22228c8d3b8e275582e9f34035469fcccc1c47a6" translate="yes" xml:space="preserve">
          <source>To get the script to work properly and silence the warning make sure there are no valid references to the tied object</source>
          <target state="translated">Чтобы заставить скрипт работать корректно и заглушить предупреждение,убедитесь,что нет корректных ссылок на связанный объект</target>
        </trans-unit>
        <trans-unit id="3d2c84cce621656fbbd6db23ecc45f9cb65b75f8" translate="yes" xml:space="preserve">
          <source>To get the stash pointer for a particular package, use the function:</source>
          <target state="translated">Чтобы получить указатель на тайник для определенного пакета,используйте функцию:</target>
        </trans-unit>
        <trans-unit id="1496f65198c7ac994d7422ae9ced83ce54781e58" translate="yes" xml:space="preserve">
          <source>To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is compatible with ancient perls and that File::Temp is listed as a prerequisite but CPAN has reasonable workarounds if it is missing.</source>
          <target state="translated">Для начала,обратите внимание,что GBARR/Scalar-List-Utils-1.18.tar.gz совместим с древними perls и что File::Temp указан в качестве предварительного условия,но CPAN имеет разумные обходные пути,если он отсутствует.</target>
        </trans-unit>
        <trans-unit id="0258f9df35378eac84877d3f62eff75269ae164c" translate="yes" xml:space="preserve">
          <source>To get valgrind and for more information see</source>
          <target state="translated">Чтобы получить valgrind и для получения дополнительной информации см.</target>
        </trans-unit>
        <trans-unit id="969efaa9efa953c87797414000140cc60d6a47f5" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">Чтобы пройти по всем клавишам, используйте функцию &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; . Это извлекает все ключи хэша и возвращает их вам в виде списка. Затем вы можете получить значение через конкретный ключ, который вы обрабатываете:</target>
        </trans-unit>
        <trans-unit id="da7117148549139674b757cf18ceb49ea4e3b714" translate="yes" xml:space="preserve">
          <source>To hack on the Perl guts, you'll need to read the following things:</source>
          <target state="translated">Чтобы взломать кишки Перла,тебе нужно прочитать следующие вещи:</target>
        </trans-unit>
        <trans-unit id="adcd3970934fc11a2c18b9c7c3e26524958accfd" translate="yes" xml:space="preserve">
          <source>To handle this situation, the PPCODE directive is used and the stack is extended using the macro:</source>
          <target state="translated">Для обработки этой ситуации используется директива PPCODE,а стек расширяется с помощью макроса:</target>
        </trans-unit>
        <trans-unit id="f2c53c3c3d7de6d2315fba06d0366c539cf64b63" translate="yes" xml:space="preserve">
          <source>To have everything installed in your home directory, do the following.</source>
          <target state="translated">Чтобы все было установлено в вашем домашнем каталоге,сделайте следующее.</target>
        </trans-unit>
        <trans-unit id="ebc28ed79805f971814bf2f23886e1860e904a26" translate="yes" xml:space="preserve">
          <source>To help explain what &lt;code&gt;File::GlobMapper&lt;/code&gt; does, consider what code you would write if you wanted to rename all files in the current directory that ended in &lt;code&gt;.tar.gz&lt;/code&gt; to &lt;code&gt;.tgz&lt;/code&gt;. So say these files are in the current directory</source>
          <target state="translated">Чтобы помочь объяснить, что делает &lt;code&gt;File::GlobMapper&lt;/code&gt; , подумайте, какой код вы бы написали, если бы вы хотели переименовать все файлы в текущем каталоге, оканчивающиеся на &lt;code&gt;.tar.gz&lt;/code&gt; , в &lt;code&gt;.tgz&lt;/code&gt; . Скажем, эти файлы находятся в текущем каталоге</target>
        </trans-unit>
        <trans-unit id="2009b3db85976237ffec01f5a479f250593bd279" translate="yes" xml:space="preserve">
          <source>To help understand how to write a Perl source filter we need an example to study. Here is a complete source filter that performs rot13 decoding. (Rot13 is a very simple encryption scheme used in Usenet postings to hide the contents of offensive posts. It moves every letter forward thirteen places, so that A becomes N, B becomes O, and Z becomes M.)</source>
          <target state="translated">Чтобы помочь понять,как написать фильтр исходников на Perl,нам нужен пример для изучения.Вот полный фильтр исходных текстов,выполняющий декодирование по технологии rot13.(Rot13-очень простая схема шифрования,используемая в сообщениях Usenet для сокрытия содержимого оскорбительных сообщений.Он перемещает каждую букву вперед на тринадцать мест,так что A становится N,B становится O,а Z становится M).</target>
        </trans-unit>
        <trans-unit id="b67c3276fc328ee702718e80d3624e6e736f9072" translate="yes" xml:space="preserve">
          <source>To help understand why this can be a real problem first consider how a callback is set up in an all C environment. Typically a C API will provide a function to register a callback. This will expect a pointer to a function as one of its parameters. Below is a call to a hypothetical function &lt;code&gt;register_fatal&lt;/code&gt; which registers the C function to get called when a fatal error occurs.</source>
          <target state="translated">Чтобы понять, почему это может быть реальной проблемой, сначала рассмотрим, как выполняется обратный вызов во всей среде C. Обычно API C предоставляет функцию для регистрации обратного вызова. Это будет ожидать указатель на функцию в качестве одного из ее параметров. Ниже приведен вызов гипотетической функции &lt;code&gt;register_fatal&lt;/code&gt; , которая регистрирует функцию C для вызова при возникновении фатальной ошибки.</target>
        </trans-unit>
        <trans-unit id="6caa11e5f28551bc8c9f71be4abd8c87215d7f26" translate="yes" xml:space="preserve">
          <source>To help you convert legacy programs to more modern Perl, the &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; utility will help you convert old-style Perl 4 libraries to new-style Perl5 modules.</source>
          <target state="translated">Чтобы помочь вам преобразовать устаревшие программы в более современный Perl, утилита &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; поможет вам преобразовать библиотеки Perl 4 старого стиля в модули Perl5 нового стиля.</target>
        </trans-unit>
        <trans-unit id="c501d022d8a0fffa65c230084aad7354f866cab9" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">Чтобы помочь вам выяснить, что было неопределенным, perl попытается сообщить вам имя переменной (если есть), которая не была определена. В некоторых случаях он не может этого сделать, поэтому он также сообщает вам, в какой операции вы использовали неопределенное значение. Обратите внимание, однако, что perl оптимизирует вашу программу, и операция, отображаемая в предупреждении, не обязательно может буквально отображаться в вашей программе. Например, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; обычно оптимизируется в &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , и предупреждение будет относиться к оператору &lt;code&gt;concatenation (.)&lt;/code&gt; , даже если его нет &lt;code&gt;.&lt;/code&gt; в вашей программе.</target>
        </trans-unit>
        <trans-unit id="77d1efff4e4ad59e580cc05099536ea5f027ae77" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt; . Add methods</source>
          <target state="translated">Чтобы скрыть острые углы под капотом, предоставьте интерфейс tie () d для пакета &lt;code&gt;symbolic&lt;/code&gt; . Добавить методы</target>
        </trans-unit>
        <trans-unit id="bb09986ebdb919a3ce53d54257037e7652baac8f" translate="yes" xml:space="preserve">
          <source>To illustrate the differences between these variables, consider the following Perl expression, which uses a single-quoted string. After execution of this statement, perl may have set all four special error variables:</source>
          <target state="translated">Чтобы проиллюстрировать различия между этими переменными,рассмотрим следующее выражение Perl,в котором используется строка в одной кавычке.После выполнения этого выражения Perl может установить все четыре специальные переменные ошибки:</target>
        </trans-unit>
        <trans-unit id="f0157186b912ecd3453913b9ba18ef7c370be226" translate="yes" xml:space="preserve">
          <source>To illustrate this feature, we'll design a pattern that matches if a string contains a palindrome. (This is a word or a sentence that, while ignoring spaces, interpunctuation and case, reads the same backwards as forwards. We begin by observing that the empty string or a string containing just one word character is a palindrome. Otherwise it must have a word character up front and the same at its end, with another palindrome in between.</source>
          <target state="translated">Чтобы проиллюстрировать эту возможность,мы создадим шаблон,который будет совпадать,если строка содержит палиндром.(Это слово или предложение,которое,игнорируя пробелы,интерполяцию и регистр,читается как задом наперёд,так и вперёд.Начнем с того,что пустая строка или строка,содержащая только одно слово,является палиндромом.В противном случае он должен иметь перед собой символ слова,а в его конце-такой же,а между ними должен находиться другой палиндром.</target>
        </trans-unit>
        <trans-unit id="983dc7293d2e1cce05648cd63638e4f7e22fc331" translate="yes" xml:space="preserve">
          <source>To illustrate unpacking for bit strings, we'll decompose a simple status register (a &quot;-&quot; stands for a &quot;reserved&quot; bit):</source>
          <target state="translated">Для иллюстрации распаковки для битовых строк разобьем простой регистр состояний (буква &quot;-&quot; означает &quot;зарезервированный&quot; бит):</target>
        </trans-unit>
        <trans-unit id="0eeac6bf1837c3892fad2067238a40143aea5c3f" translate="yes" xml:space="preserve">
          <source>To illustrate,</source>
          <target state="translated">Чтобы проиллюстрировать,</target>
        </trans-unit>
        <trans-unit id="3f180de5f2359e1c5045cf60151ad16271ecfbd0" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">Чтобы реализовать конструктор копирования, добавьте &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; строки перегрузки и кода (в этом коде предполагается, что мутаторы изменяют вещи только на один уровень, поэтому рекурсивное копирование не требуется):</target>
        </trans-unit>
        <trans-unit id="8240260917b1a03cdad7c5747565fe071f2719a2" translate="yes" xml:space="preserve">
          <source>To implement most arithmetic operations is easy; one should just use the tables of operations, and change the code which fills %subr to</source>
          <target state="translated">Реализовать большинство арифметических операций очень просто,достаточно воспользоваться таблицами операций и изменить код,который заполняет %subr на</target>
        </trans-unit>
        <trans-unit id="81c4d513cec75ad639c29820e8f6fc040826df1f" translate="yes" xml:space="preserve">
          <source>To import subroutines:</source>
          <target state="translated">Импортировать подпрограммы:</target>
        </trans-unit>
        <trans-unit id="97177a061d7ff62a243885c9bd4e1efe9ede32f2" translate="yes" xml:space="preserve">
          <source>To increase the value of something by 1 (or by some other number, if so specified).</source>
          <target state="translated">Увеличить значение чего-либо на 1 (или на какое-либо другое число,если оно указано).</target>
        </trans-unit>
        <trans-unit id="72b80e806b1c83aea2a8c7cd737f1e4bbb0943c8" translate="yes" xml:space="preserve">
          <source>To indicate to rather use commandline tools than modules</source>
          <target state="translated">Указывать на использование инструментов командной строки,а не модулей.</target>
        </trans-unit>
        <trans-unit id="75120c587d6fba4a38cc9dc45cf5606751546e6f" translate="yes" xml:space="preserve">
          <source>To insert a line after one already in the file, use the &lt;code&gt;-n&lt;/code&gt; switch. It's just like &lt;code&gt;-p&lt;/code&gt; except that it doesn't print &lt;code&gt;$_&lt;/code&gt; at the end of the loop, so you have to do that yourself. In this case, print &lt;code&gt;$_&lt;/code&gt; first, then print the line that you want to add.</source>
          <target state="translated">Чтобы вставить строку после той, которая уже есть в файле, используйте переключатель &lt;code&gt;-n&lt;/code&gt; . Это похоже на &lt;code&gt;-p&lt;/code&gt; , за исключением того, что он не печатает &lt;code&gt;$_&lt;/code&gt; в конце цикла, поэтому вам придется делать это самостоятельно. В этом случае сначала напечатайте &lt;code&gt;$_&lt;/code&gt; , а затем напечатайте строку, которую вы хотите добавить.</target>
        </trans-unit>
        <trans-unit id="574f86f03c88819ff70bca34830f6be35a8bf5f1" translate="yes" xml:space="preserve">
          <source>To install NetWare Perl onto a NetWare server, first map the Sys volume of a NetWare server to</source>
          <target state="translated">Чтобы установить NetWare Perl на сервер NetWare,сначала сопоставьте Sys том сервера NetWare с</target>
        </trans-unit>
        <trans-unit id="a7a520bfb7587900e1cbb96bf573db69af079c5b" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array)
{}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">Чтобы перебрать индексы массива, используйте &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array) {}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; перебирает значения.</target>
        </trans-unit>
        <trans-unit id="8f0a51f73b6311fa2b970169a1f0134f7c61aef8" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">Чтобы присоединиться к списку рассылки объявлений о &lt;code&gt;Memoize&lt;/code&gt; , отправьте пустое сообщение по &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . Этот список рассылки предназначен только для объявлений и имеет чрезвычайно низкий трафик - менее двух сообщений в год.</target>
        </trans-unit>
        <trans-unit id="9c7770af2e023d19bb1b24c66498040c02b4d820" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</source>
          <target state="translated">Чтобы присоединиться к списку рассылки с очень низким трафиком для объявлений о &lt;code&gt;Memoize&lt;/code&gt; , отправьте пустую заметку по &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30da17ba518ee8896f295021c334b446312ba2d0" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ() &lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE() &lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">Чтобы просто сравнить две строки на равенство / неравенство, вы можете просто использовать &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ ()&lt;/a&gt; и &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE ()&lt;/a&gt; как обычно, за исключением того, что строки должны быть как в кодировке UTF-8, так и без кодировки UTF-8.</target>
        </trans-unit>
        <trans-unit id="bfd1d911fc5d8c1a13ece46d4a41278866b326f9" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">Чтобы наше пространство имен &lt;code&gt;@EXPORT&lt;/code&gt; красивым и незагрязненным, отредактируйте файл .pm и измените переменную @EXPORT на &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Наконец, в файле .xs отредактируйте строку #include, чтобы она гласила:</target>
        </trans-unit>
        <trans-unit id="03272788bb4c31073d76ce4d5e5b7d43fa610bff" translate="yes" xml:space="preserve">
          <source>To learn how to install modules you download from CPAN, read &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как установить модули, загруженные с CPAN, прочтите &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a06d2306514b40b8ba1c92a7641c86fc2fa15b9" translate="yes" xml:space="preserve">
          <source>To learn how to use a particular module, use &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;. Typically you will want to &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;, which will then give you access to exported functions or an OO interface to the module.</source>
          <target state="translated">Чтобы узнать, как использовать конкретный модуль, используйте &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; . Обычно вам нужно &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; , который затем предоставит вам доступ к экспортированным функциям или объектно-ориентированному интерфейсу для модуля.</target>
        </trans-unit>
        <trans-unit id="085a503b5041562d55123a7fc6e92076974024bc" translate="yes" xml:space="preserve">
          <source>To learn more, just type a bogus option, like &lt;b&gt;-\?&lt;/b&gt;, and a long usage message will be provided. There are a fair number of possibilities.</source>
          <target state="translated">Чтобы узнать больше, просто введите фиктивный вариант, например &lt;b&gt;- \? &lt;/b&gt;, и будет предоставлено длинное сообщение об использовании. Есть изрядное количество возможностей.</target>
        </trans-unit>
        <trans-unit id="b660f64338ea03a5a1e256309c3e2566abdfdf76" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Floating-point Arithmetic in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">Чтобы ограничить количество десятичных знаков в числах, вы можете использовать функцию &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; . Подробнее см. &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Арифметика с плавающей запятой в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a08be93803c5f2a1dab3670911ed75d37f74ad6a" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt; , typically from your &lt;code&gt;Build.PL&lt;/code&gt; . For example:</source>
          <target state="translated">Чтобы загрузить плагины &lt;code&gt;TAP::Harness&lt;/code&gt; , вам нужно использовать параметр &lt;code&gt;tap_harness_args&lt;/code&gt; для &lt;code&gt;new&lt;/code&gt; , обычно из вашего &lt;code&gt;Build.PL&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="1281377e392724ce754ea5fba63ddbdb0e3e3b86" translate="yes" xml:space="preserve">
          <source>To load on demand. (Also called &amp;ldquo;lazy&amp;rdquo; loading.) Specifically, to call an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine on behalf of an undefined subroutine.</source>
          <target state="translated">Загрузить по запросу. (Также называется &amp;laquo;ленивой&amp;raquo; загрузкой.) В частности, для вызова подпрограммы &lt;code&gt;AUTOLOAD&lt;/code&gt; от имени неопределенной подпрограммы.</target>
        </trans-unit>
        <trans-unit id="c23756075d8a23d3d03df135a356f7c210c8debd" translate="yes" xml:space="preserve">
          <source>To maintain backward compatibility with version 1.x of this module &lt;code&gt;gzreadline&lt;/code&gt; ignores the &lt;code&gt;$/&lt;/code&gt; variable - it</source>
          <target state="translated">Для обеспечения обратной совместимости с версией 1.x этого модуля &lt;code&gt;gzreadline&lt;/code&gt; игнорирует переменную &lt;code&gt;$/&lt;/code&gt; - она</target>
        </trans-unit>
        <trans-unit id="abc4743aa98a734da932da278854d69561d0cbfb" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt; . We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt; , thus add</source>
          <target state="translated">Чтобы заставить &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; работать, нам нужно реализовать настоящие мутаторы либо напрямую, либо через &lt;code&gt;nomethod&lt;/code&gt; либо метод . Мы продолжаем делать что-то внутри &lt;code&gt;nomethod&lt;/code&gt; , поэтому добавляем</target>
        </trans-unit>
        <trans-unit id="91a1c6beb7c38d494fe7c7d801b2befdd4173ffc" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; work, there were two changes to</source>
          <target state="translated">Чтобы &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; работал, в</target>
        </trans-unit>
        <trans-unit id="b87c350e6119d6693a7cb04a8612a5e26f6e647d" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt; , give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">Чтобы сделать резервную копию &lt;code&gt;inFile.txt&lt;/code&gt; , дайте &lt;code&gt;-i&lt;/code&gt; добавляемое расширение файла:</target>
        </trans-unit>
        <trans-unit id="8414b77ccfd34c712fab8c626931679fd71f5d22" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">Короче говоря, вы можете использовать специальные переменные &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; и &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; с AV и HV, но вы должны быть уверены, что знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="5c0463c040e841ec603e099982e8abee57b683e9" translate="yes" xml:space="preserve">
          <source>To make life easier when dealing with duplicate keys, &lt;b&gt;DB_File&lt;/b&gt; comes with a few utility methods.</source>
          <target state="translated">Чтобы облегчить жизнь при работе с повторяющимися ключами, &lt;b&gt;DB_File&lt;/b&gt; поставляется с несколькими служебными методами.</target>
        </trans-unit>
        <trans-unit id="5ae2d3fa0128e67ff0e0a2c8bcd480511ed4d982" translate="yes" xml:space="preserve">
          <source>To make proper use of the</source>
          <target state="translated">Для правильного использования</target>
        </trans-unit>
        <trans-unit id="c44a199ec9bf1193e7c67a06e66e66c5a73ebf54" translate="yes" xml:space="preserve">
          <source>To make sure we're talking about the same thing when we discuss the removal of features or functionality from the Perl core, we have specific definitions for a few words and phrases.</source>
          <target state="translated">Чтобы убедиться в том,что мы говорим об одном и том же,когда обсуждаем удаление функций или функциональности из ядра Perl,у нас есть специальные определения для нескольких слов и фраз.</target>
        </trans-unit>
        <trans-unit id="5942273fcaa449896c9e37c66cd4e802e9c0964a" translate="yes" xml:space="preserve">
          <source>To make symbols from a &lt;b&gt;module&lt;/b&gt; available for &lt;b&gt;import&lt;/b&gt; by other modules.</source>
          <target state="translated">Сделать символы из &lt;b&gt;модуля&lt;/b&gt; доступными для &lt;b&gt;импорта&lt;/b&gt; другими модулями.</target>
        </trans-unit>
        <trans-unit id="dcd61647f554ce66ac28cd2d49ac0cbdb07ed537" translate="yes" xml:space="preserve">
          <source>To make the field hashes kick in, it is easiest to redefine &lt;code&gt;refaddr&lt;/code&gt; as</source>
          <target state="translated">Чтобы использовать хэши полей, проще всего переопределить &lt;code&gt;refaddr&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="ffcdcbe9b2ae0d61ba055686a39957aa53dc38e5" translate="yes" xml:space="preserve">
          <source>To make the interface more useful for older versions of Perl, a number of methods are supplied with &lt;b&gt;DB_File&lt;/b&gt; to simulate the missing array operations. All these methods are accessed via the object returned from the tie call.</source>
          <target state="translated">Чтобы сделать интерфейс более полезным для старых версий Perl, с &lt;b&gt;DB_File&lt;/b&gt; поставляется ряд методов для имитации операций с отсутствующими массивами. Доступ ко всем этим методам осуществляется через объект, возвращаемый при вызове связи.</target>
        </trans-unit>
        <trans-unit id="1e1af3e6c47d65824073836d9be72328a9d2a810" translate="yes" xml:space="preserve">
          <source>To make these calls fail</source>
          <target state="translated">Чтобы сделать эти звонки неудачными.</target>
        </trans-unit>
        <trans-unit id="5100ca13c61421986a8b595f7f48745403cf86c2" translate="yes" xml:space="preserve">
          <source>To make things more complicated, the hash may contain references to the actual destinations, for example:</source>
          <target state="translated">Чтобы все усложнить,хэш может содержать,например,ссылки на фактические места назначения:</target>
        </trans-unit>
        <trans-unit id="23271da81593c086fb9f97e8eda36eed5fe8ab37" translate="yes" xml:space="preserve">
          <source>To make use of either of the two filter modules above, place the line below in a Perl source file.</source>
          <target state="translated">Чтобы использовать любой из двух модулей фильтров выше,поместите строку внизу в исходном файле Perl.</target>
        </trans-unit>
        <trans-unit id="546b84e64be1bb2630d4087e9c7e0aa2ec07fbeb" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">Однако для использования потоковой передачи обычно требуется, чтобы потоки обменивались хотя бы некоторыми данными между собой. Это делается с помощью модуля &lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt; и атрибута: &lt;code&gt;:shared&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="482a24cc09ed210b4be1c7fca66ab517d60e1e62" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">Чтобы пометить FILEHANDLE как UTF-8, используйте &lt;code&gt;:utf8&lt;/code&gt; или &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; просто помечает данные как UTF-8 без дополнительной проверки, а &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; проверяет, действительно ли данные являются действительными UTF-8. Более подробную информацию можно найти в &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5274ade94ad24fbd8e1e1d8904bba9bc30f6d6c0" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">Чтобы пометить FILEHANDLE как UTF-8, используйте &lt;code&gt;:utf8&lt;/code&gt; или &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; просто помечает данные как UTF-8 без дополнительной проверки, а &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; проверяет, действительно ли данные являются действительными UTF-8. Более подробную информацию можно найти в &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4e2df2dd87486f202e752cbd1bc2453ac926173" translate="yes" xml:space="preserve">
          <source>To minimize the number of sbrk(2)s, malloc() asks for more memory. This field gives the size of the yet unused part, which is sbrk(2)ed, but never touched.</source>
          <target state="translated">Чтобы минимизировать количество sbrk(2)s,функция malloc()запрашивает больше памяти.Это поле задает размер еще неиспользуемой части,которая является sbrk(2)ed,но никогда не затрагивалась.</target>
        </trans-unit>
        <trans-unit id="c7e29496ccd957aa4492216e45f2282e137e2591" translate="yes" xml:space="preserve">
          <source>To obtain this, a reference to a hash must be passed</source>
          <target state="translated">Чтобы получить это,необходимо передать ссылку на хэш.</target>
        </trans-unit>
        <trans-unit id="76c61aa559d88fae477b92a372d192b3b51d4c5b" translate="yes" xml:space="preserve">
          <source>To open a file without blocking, creating if necessary:</source>
          <target state="translated">Чтобы открыть файл без блокировки,создайте при необходимости:</target>
        </trans-unit>
        <trans-unit id="354facfe42bf4e55b171df83905f745324ebd0c9" translate="yes" xml:space="preserve">
          <source>To open file for appending, create if necessary:</source>
          <target state="translated">Чтобы открыть файл для добавления,создайте его при необходимости:</target>
        </trans-unit>
        <trans-unit id="1702818d3f57a9131b4035ed033f063e2b07cebf" translate="yes" xml:space="preserve">
          <source>To open file for appending, file must exist:</source>
          <target state="translated">Чтобы открыть файл для добавления,он должен существовать:</target>
        </trans-unit>
        <trans-unit id="4967760590c67e61373186454a8e4a1135dcb6d9" translate="yes" xml:space="preserve">
          <source>To open file for reading:</source>
          <target state="translated">Открыть файл для чтения:</target>
        </trans-unit>
        <trans-unit id="cee1bc0ab3a065feee926895157fb947a422ff0d" translate="yes" xml:space="preserve">
          <source>To open file for update, create file if necessary:</source>
          <target state="translated">Чтобы открыть файл для обновления,при необходимости создайте файл:</target>
        </trans-unit>
        <trans-unit id="7c8a25c4e2b2e915deaf352a915d4e6583e2f962" translate="yes" xml:space="preserve">
          <source>To open file for update, file must exist:</source>
          <target state="translated">Чтобы открыть файл для обновления,он должен существовать:</target>
        </trans-unit>
        <trans-unit id="b8d1b7a21cb716decbfe05cd44f437ced848a3ac" translate="yes" xml:space="preserve">
          <source>To open file for update, file must not exist:</source>
          <target state="translated">Чтобы открыть файл для обновления,файл не должен существовать:</target>
        </trans-unit>
        <trans-unit id="e09916f7ec3e12864e36849354a4ebf1fbb19361" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file if needed or else truncate old file:</source>
          <target state="translated">Чтобы открыть файл для записи,при необходимости создайте новый файл или укоротите старый:</target>
        </trans-unit>
        <trans-unit id="290398a666a114bce8d99caa62b27b49c84e4b59" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file, file must not exist:</source>
          <target state="translated">Чтобы открыть файл для записи,создать новый файл,файл не должен существовать:</target>
        </trans-unit>
        <trans-unit id="6007d31a54fba5ebc4520f06ed8627e89a0d4a2c" translate="yes" xml:space="preserve">
          <source>To output UTF-8, use the &lt;code&gt;:encoding&lt;/code&gt; or &lt;code&gt;:utf8&lt;/code&gt; output layer. Prepending</source>
          <target state="translated">Для вывода UTF-8 используйте выходной слой &lt;code&gt;:encoding&lt;/code&gt; или &lt;code&gt;:utf8&lt;/code&gt; . Подготовка</target>
        </trans-unit>
        <trans-unit id="3b36e6dcece917ee92e199616190bf7ab5b56187" translate="yes" xml:space="preserve">
          <source>To overcome this limitation, you need to turn on /s matching within the prefix pattern, using the &lt;code&gt;(?s)&lt;/code&gt; directive: '(?s).*?(?=&amp;lt;H1&amp;gt;)'</source>
          <target state="translated">Чтобы преодолеть это ограничение, вам необходимо включить / s сопоставление в шаблоне префикса с помощью директивы &lt;code&gt;(?s)&lt;/code&gt; : '(? S). *? (? = &amp;lt;H1&amp;gt;)'</target>
        </trans-unit>
        <trans-unit id="062f2ac749842e1dd1762ff59d78e1eb660fe9b7" translate="yes" xml:space="preserve">
          <source>To override a Perl built-in routine with your own version, you need to import it at compile-time. This can be conveniently achieved with the &lt;code&gt;subs&lt;/code&gt; pragma. This will affect only the package in which you've imported the said subroutine:</source>
          <target state="translated">Чтобы заменить встроенную процедуру Perl вашей собственной версией, вам необходимо импортировать ее во время компиляции. Этого удобно достичь с помощью &lt;code&gt;subs&lt;/code&gt; . Это повлияет только на пакет, в который вы импортировали указанную подпрограмму:</target>
        </trans-unit>
        <trans-unit id="1aa3f784c17082d78c7fbfe639d471e8c69f8458" translate="yes" xml:space="preserve">
          <source>To override a built-in globally (that is, in all namespaces), you need to import your function into the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; pseudo-namespace at compile time:</source>
          <target state="translated">Чтобы переопределить встроенное глобально (то есть во всех пространствах имен), вам необходимо импортировать свою функцию в псевдо-пространство имен &lt;code&gt;CORE::GLOBAL&lt;/code&gt; во время компиляции:</target>
        </trans-unit>
        <trans-unit id="605fcd402b7e1fdc810b4ff2c0f6a15f906ca915" translate="yes" xml:space="preserve">
          <source>To pack dates stored as triplets ( day, month, year ) in an array &lt;code&gt;@dates&lt;/code&gt; into a sequence of byte, byte, short integer we can write</source>
          <target state="translated">Чтобы упаковать даты, хранящиеся в виде троек (день, месяц, год) в массиве &lt;code&gt;@dates&lt;/code&gt; , в последовательность байтов, байтов, коротких целых чисел, мы можем написать</target>
        </trans-unit>
        <trans-unit id="1d0cde2eb7df8017d255040c9f5af9796899dd92" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a floating point number use</source>
          <target state="translated">Чтобы проанализировать строку &lt;code&gt;$str&lt;/code&gt; как число с плавающей запятой, используйте</target>
        </trans-unit>
        <trans-unit id="61571c195afbee84b0b85796b78595db86b7183b" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a number in some base &lt;code&gt;$base&lt;/code&gt; use</source>
          <target state="translated">Чтобы проанализировать строку &lt;code&gt;$str&lt;/code&gt; как число в некоторой базовой &lt;code&gt;$base&lt;/code&gt; используйте</target>
        </trans-unit>
        <trans-unit id="8c0b000078df0842ed41dd6cf17b93c225c65646" translate="yes" xml:space="preserve">
          <source>To parse this code, Perl uses a heuristic based on what package names it has seen, what subroutines exist in the current package, what barewords it has previously seen, and other input. Needless to say, heuristics can produce very surprising results!</source>
          <target state="translated">Для разбора этого кода Perl использует эвристический подход,основанный на том,какие имена пакетов он видел,какие подпрограммы существуют в текущем пакете,какие пустые слова он видел ранее,и другие вводимые данные.Нет необходимости говорить,что эвристика может дать очень удивительные результаты!</target>
        </trans-unit>
        <trans-unit id="fbca7774c8df9c1e7fff186e61962bc8047a5ac6" translate="yes" xml:space="preserve">
          <source>To pass an object method into a subroutine, you can do this:</source>
          <target state="translated">Для передачи метода объекта в подпрограмму можно это сделать:</target>
        </trans-unit>
        <trans-unit id="249caf0f11ba46a1737a888a2cd12f841c024b93" translate="yes" xml:space="preserve">
          <source>To pass supplemental arguments to a program opened with &lt;code&gt; '|-' &lt;/code&gt; or &lt;code&gt; '-|' &lt;/code&gt; append them to the command string as you would system EXPR.</source>
          <target state="translated">Для передачи дополнительных аргументов программе, открытой с помощью &lt;code&gt; '|-' &lt;/code&gt; или &lt;code&gt; '-|' &lt;/code&gt; добавьте их в командную строку, как если бы вы использовали системный EXPR.</target>
        </trans-unit>
        <trans-unit id="9bb3f23b2e2cd47ffa049a4b5b8e3297a48bd649" translate="yes" xml:space="preserve">
          <source>To prepare distribution you need to do following:</source>
          <target state="translated">Для подготовки дистрибуции вам необходимо сделать следующее:</target>
        </trans-unit>
        <trans-unit id="47e04bab26a33f27d49843c62d8c3b7400695e70" translate="yes" xml:space="preserve">
          <source>To prepend lines to the beginning, print those lines before you enter the loop that prints the existing lines.</source>
          <target state="translated">Чтобы подготовить строки к началу,распечатайте эти строки перед входом в петлю,которая печатает существующие строки.</target>
        </trans-unit>
        <trans-unit id="453d8a60ef1b8720b3eb21b0a6becefda886f512" translate="yes" xml:space="preserve">
          <source>To prevent &amp;lt;extract_quotelike&amp;gt; from mucking about with the input in this way (this is the only case where a list-context &lt;code&gt;extract_quotelike&lt;/code&gt; does so), you can pass the input variable as an interpolated literal:</source>
          <target state="translated">Чтобы &amp;lt;extract_quotelike&amp;gt; не возился с вводом таким образом (это единственный случай, когда это происходит с помощью list-context &lt;code&gt;extract_quotelike&lt;/code&gt; ), вы можете передать входную переменную как интерполированный литерал:</target>
        </trans-unit>
        <trans-unit id="743105860f25b02f06770315902de6783c423895" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">Для предотвращения &lt;code&gt;memoize&lt;/code&gt; от установки memoized версии в любом месте, используйте &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9de321857a95078722502ca43a0201a5f6a4b12" translate="yes" xml:space="preserve">
          <source>To prevent any ambiguity,</source>
          <target state="translated">Чтобы предотвратить любую двусмысленность,</target>
        </trans-unit>
        <trans-unit id="ac0fc603c0e20ee050f6b1167e08040f2086e70a" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">Чтобы предотвратить изменение содержимого очереди другим потоком во время его проверки и / или изменения, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;заблокируйте&lt;/a&gt; очередь внутри локального блока:</target>
        </trans-unit>
        <trans-unit id="521d225cb8b8267bdc9221af420cb3102374b4c5" translate="yes" xml:space="preserve">
          <source>To prevent this, supply a &lt;code&gt;NORMALIZER&lt;/code&gt; function that turns the program arguments into a string in a way that equivalent arguments turn into the same string. A &lt;code&gt;NORMALIZER&lt;/code&gt; function for &lt;code&gt;f&lt;/code&gt; above might look like this:</source>
          <target state="translated">Чтобы предотвратить это, предоставьте функцию &lt;code&gt;NORMALIZER&lt;/code&gt; , которая превращает аргументы программы в строку таким образом, чтобы эквивалентные аргументы превращались в ту же строку. Функция &lt;code&gt;NORMALIZER&lt;/code&gt; для приведенного выше &lt;code&gt;f&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="6fa84f786f1f2e361ba53d7582050f707e69605c" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt; , either say</source>
          <target state="translated">Чтобы создать двоичный файл perl с именем, отличным от имени &lt;code&gt;perl&lt;/code&gt; , либо скажите</target>
        </trans-unit>
        <trans-unit id="deeb5ed64d8b8726d03c2a35d8b9a4f9932501dd" translate="yes" xml:space="preserve">
          <source>To prove success on the host machine, run &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; from the win32/ folder and look for &quot;machine (ARM)&quot; in the FILE HEADER VALUES and &quot;subsystem (Windows CE GUI)&quot; in the OPTIONAL HEADER VALUES.</source>
          <target state="translated">Чтобы доказать успех на главной машине,запустите &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; из папки win32/и ищите &quot;machine (ARM)&quot; в &quot;FILE HEADER VALUES&quot; и &quot;subsystem (Windows CE GUI)&quot; в ОПТИЦИОНАЛЬНЫХ ЦЕНАХ ГЕНЕРАЛЬНОГО ЗАВОДА.</target>
        </trans-unit>
        <trans-unit id="e3f95db7629c92dc13df17dee2376ecae6bd28b4" translate="yes" xml:space="preserve">
          <source>To provide a Perl interface to this library we need to be able to map between the &lt;code&gt;fh&lt;/code&gt; parameter and the Perl subroutine we want called. A hash is a convenient mechanism for storing this mapping. The code below shows a possible implementation</source>
          <target state="translated">Чтобы предоставить Perl-интерфейс для этой библиотеки, нам нужно иметь возможность отображать между параметром &lt;code&gt;fh&lt;/code&gt; и подпрограммой Perl, которую мы хотим вызвать . Хеш - удобный механизм для хранения этого сопоставления. В приведенном ниже коде показана возможная реализация</target>
        </trans-unit>
        <trans-unit id="56afd5e1c9ab39b7d24b6a35fc7523124fb4a154" translate="yes" xml:space="preserve">
          <source>To provide an example, let's say the popular &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; function doesn't deal with Unicode data yet. The wrapper function would convert the argument to raw UTF-8 and convert the result back to Perl's internal representation like so:</source>
          <target state="translated">В качестве примера предположим, что популярная функция &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; еще не работает с данными Unicode. Функция-оболочка преобразует аргумент в необработанный UTF-8 и преобразует результат обратно во внутреннее представление Perl следующим образом:</target>
        </trans-unit>
        <trans-unit id="fe539191c8112058d164cdbdc07c4a313e2ceb71" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of Net::Ping, a pingecho() subroutine is available with the same functionality as before. pingecho() uses the tcp protocol. The return values and parameters are the same as described for the ping() method. This subroutine is obsolete and may be removed in a future version of Net::Ping.</source>
          <target state="translated">Для обеспечения обратной совместимости с предыдущей версией Net::Ping доступна подпрограмма pingecho()с той же функциональностью,что и раньше.pingecho()использует протокол tcp.Возвращаемые значения и параметры такие же,как и в методе ping().Эта подпрограмма устарела и может быть удалена в будущей версии Net::Ping.</target>
        </trans-unit>
        <trans-unit id="ece610257b3402f7eea4d17dbc76eda55d9cbb02" translate="yes" xml:space="preserve">
          <source>To provide the capability to set/get class-wide settings, it is best instead to provide accessors as subroutines or class methods instead.</source>
          <target state="translated">Для предоставления возможности устанавливать/запоминать настройки всего класса,лучше всего вместо этого предоставить аксессуары в виде подпрограмм или методов класса.</target>
        </trans-unit>
        <trans-unit id="b8ad3c75e2a9658073e3c75677575371b7b2154a" translate="yes" xml:space="preserve">
          <source>To put the output from any parse method into a string instead of a file handle, call the output_string() method instead of output_fh().</source>
          <target state="translated">Чтобы поместить вывод из любого метода разбора в строку вместо файлового дескриптора,вызовите метод output_string()вместо output_fh().</target>
        </trans-unit>
        <trans-unit id="8d3d8f79e5bb23da5237f2bc4f067b582af08744" translate="yes" xml:space="preserve">
          <source>To quickly check the type of a &lt;code&gt;Archive::Tar::File&lt;/code&gt; object, you can use the following methods:</source>
          <target state="translated">Чтобы быстро проверить тип объекта &lt;code&gt;Archive::Tar::File&lt;/code&gt; , вы можете использовать следующие методы:</target>
        </trans-unit>
        <trans-unit id="ffb74a402d25037ed756434b89268f8c6c0f487e" translate="yes" xml:space="preserve">
          <source>To quote the bzip2 documentation</source>
          <target state="translated">Для цитирования документации bzip2</target>
        </trans-unit>
        <trans-unit id="2e030dd198e6e120e9f1df9a82e7575806595a2d" translate="yes" xml:space="preserve">
          <source>To read an entire &lt;b&gt;file&lt;/b&gt; into a &lt;b&gt;string&lt;/b&gt; in one operation.</source>
          <target state="translated">Считать весь &lt;b&gt;файл&lt;/b&gt; в &lt;b&gt;строку&lt;/b&gt; за одну операцию.</target>
        </trans-unit>
        <trans-unit id="d6676802f298dda33ea89ee297e7a4c3b7e4e2ac" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately to files, and then read from those files when the program is done:</source>
          <target state="translated">Для чтения как STDOUT команды,так и ее STDERR отдельно,проще всего перенаправить их отдельно в файлы,а затем читать из этих файлов по окончании работы программы:</target>
        </trans-unit>
        <trans-unit id="441b0a3f043e9d675f24f50e1a3845049a78b701" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let the command run, then read the temp files:</source>
          <target state="translated">Чтобы прочитать как STDOUT,так и STDERR команды по отдельности,можно перенаправить их в temp-файлы,дать команде выполниться,а затем прочитать временные файлы:</target>
        </trans-unit>
        <trans-unit id="5540d6192acd70f39a8ef597e449669bc8ae5ddb" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">Для чтения из существующего дескриптора файла Perl, &lt;code&gt;$input&lt;/code&gt; , и записи сжатых данных в буфер, &lt;code&gt;$buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c349b729382da049ab850b286913e925d6fe3968" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">Для чтения из существующего дескриптора файла Perl, &lt;code&gt;$input&lt;/code&gt; , и записи несжатых данных в буфер, &lt;code&gt;$buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7482ebcf137b958140c12465f2671a82fcf986b9" translate="yes" xml:space="preserve">
          <source>To read the</source>
          <target state="translated">Чтобы прочитать</target>
        </trans-unit>
        <trans-unit id="87df4beb52a8613330401231fb10bf4839a044e4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.1950&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f3af95cfb979c68a078d4244b348eca50284cce" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.1951&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe87604cf51141fe67b4d7c05185428541881932" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.Compressed&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcd74724ed743479732074df76791b8e4375f0ba" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.bz2&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0224a4a1040095275155b56f5f7207fca1c2ad1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.gz&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b61bd1daa8a6cb2d7eb96d3ece7209a79b5aec" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.1950&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e429b7a25235b582c4b383620392f1a750a3bdd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.1951&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c406d8acaac2a742d676187babe70fbc63a189bd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa350228ff2721777414a685ddb5c4e3af10826c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.gz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1253348a31fd66554a6efd5d56c0e22a2ff1b137" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb0378e48901dddc588a6225fe4a4196884f056" translate="yes" xml:space="preserve">
          <source>To really poke around with Perl, you'll probably want to build Perl for debugging, like this:</source>
          <target state="translated">Чтобы по-настоящему пообщаться с Перлом,вам,наверное,захочется построить Perl для отладки,вот так:</target>
        </trans-unit>
        <trans-unit id="224b47d42836cf02b0538bc7324878629aa47a30" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</source>
          <target state="translated">Чтобы получать уведомление о выпуске новой версии этого модуля, отправьте пустое сообщение электронной почты на &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3e33fd8f77a0950334d95b2b753813796d2bf20" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы рекурсивно создать структуру каталогов, посмотрите на функцию &lt;code&gt;make_path&lt;/code&gt; модуля &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d93ce0279ba5e733f28599be83e53944021fc924" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы рекурсивно создать структуру каталогов, посмотрите на функцию &lt;code&gt;make_path&lt;/code&gt; модуля &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5946d1b5adc8bf79e8d8691892a42663cd834d2" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt; , which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">Чтобы максимально снизить накладные расходы, проверяется только одно возможное местоположение для поиска DLL расширения (это место, куда &lt;code&gt;make install&lt;/code&gt; поместит DLL). Если он не найден, поиск DLL прозрачно делегируется &lt;code&gt;DynaLoader&lt;/code&gt; , который ищет DLL в списке &lt;code&gt;@INC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98bed95392f2bd5c21b8012e731bec1f2530889e" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы удалить дерево каталогов рекурсивно ( &lt;code&gt;rm -rf&lt;/code&gt; в Unix), посмотрите на функцию &lt;code&gt;rmtree&lt;/code&gt; модуля &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5b819764f7105a80a7d510f2a867ba675bddec" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы удалить дерево каталогов рекурсивно ( &lt;code&gt;rm -rf&lt;/code&gt; в Unix), посмотрите на функцию &lt;code&gt;rmtree&lt;/code&gt; модуля &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e56141f1ebe96f14282b26d571378c274b2244ed" translate="yes" xml:space="preserve">
          <source>To remove a tied environment variable from the environment, assign it the undefined value</source>
          <target state="translated">Для удаления связанной переменной окружения из окружения присвойте ей неопределённое значение</target>
        </trans-unit>
        <trans-unit id="06b0ac63c637336d9c539fb315b8373179470836" translate="yes" xml:space="preserve">
          <source>To remove creation of the tied hash on each access, one may an extra level of indirection which allows a non-circular structure of references:</source>
          <target state="translated">Для удаления создания привязанного хэша на каждом доступе может быть установлен дополнительный уровень индеррекции,позволяющий создать нециркулярную структуру ссылок:</target>
        </trans-unit>
        <trans-unit id="385dafb73da7d1789642356fd78d8d3446310a3d" translate="yes" xml:space="preserve">
          <source>To remove the magic from an SV, call the function sv_unmagic:</source>
          <target state="translated">Чтобы удалить магию из SV,вызовите функцию sv_unmagic:</target>
        </trans-unit>
        <trans-unit id="ee81225f636096e269a365626b3e0c2212110758" translate="yes" xml:space="preserve">
          <source>To report a new bug, visit:</source>
          <target state="translated">Чтобы сообщить о новой ошибке,посетите:</target>
        </trans-unit>
        <trans-unit id="935323786b12419a7345fc07129055605bd12b91" translate="yes" xml:space="preserve">
          <source>To retrieve data stored to disk, use &lt;code&gt;retrieve&lt;/code&gt; with a file name. The objects stored into that file are recreated into memory for you, and a</source>
          <target state="translated">Для извлечения данных, хранящихся на диске, используйте &lt;code&gt;retrieve&lt;/code&gt; с именем файла. Объекты, хранящиеся в этом файле, воссоздаются в памяти для вас, и</target>
        </trans-unit>
        <trans-unit id="4f95fbea27e1a9b8ba09786147eb856c1d1f83f4" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP Functions in perlapi&lt;/a&gt;.</source>
          <target state="translated">Чтобы получить объект &lt;code&gt;REGEXP&lt;/code&gt; из скаляра в функции XS, используйте макрос &lt;code&gt;SvRX&lt;/code&gt; , см. &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;Функции REGEXP в perlapi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1231633ff6452d875f890a43a2ae8ede0790e949" translate="yes" xml:space="preserve">
          <source>To return an empty list one must use a PPCODE: block and then not push return values on the stack.</source>
          <target state="translated">Для возврата пустого списка необходимо использовать PPCODE:блок,а затем не нажимать на возвращаемые значения в стеке.</target>
        </trans-unit>
        <trans-unit id="c52a15c8b572dc0999ddd7a3d452b4f9cfbf130a" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">Для запуска Perl на платформах DPMI требуется среда выполнения RSX. Это необходимо в DOS-inside-OS / 2, Win0.3 *, Win0.95 и WinNT (см. &lt;a href=&quot;#Other-OSes&quot;&gt;Другие ОС&lt;/a&gt; ). RSX не будет работать только с VCPI, как EMX, он требует DMPI.</target>
        </trans-unit>
        <trans-unit id="f4988afc10b11011c01fd1dc8e2d9efa2ca35527" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">Для запуска &lt;b&gt;программы&lt;/b&gt; или &lt;b&gt;подпрограммы&lt;/b&gt; . (Не имеет ничего общего со встроенным &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; , если вы не пытаетесь запустить &lt;b&gt;обработчик сигнала&lt;/b&gt; .)</target>
        </trans-unit>
        <trans-unit id="8cf4ac8bbb41685c2ce7804ccdb1791a6e3ce985" translate="yes" xml:space="preserve">
          <source>To run a Perl program from the Unix command line:</source>
          <target state="translated">Для запуска программы на Perl из командной строки Unix:</target>
        </trans-unit>
        <trans-unit id="69d193d311b7fdb3c43e19bb64a6bebcfed27d39" translate="yes" xml:space="preserve">
          <source>To run this code, &lt;code&gt;perl_run&lt;/code&gt; is called, which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; then enters a runops loop. This loop executes the eval and tie ops on line 1, with the eval pushing a &lt;code&gt;CxEVAL&lt;/code&gt; onto the context stack.</source>
          <target state="translated">Для запуска этого кода &lt;code&gt;perl_run&lt;/code&gt; , который выполняет &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ,а затем входит в цикл runops. Этот цикл выполняет eval и связующие операции в строке 1, при этом eval &lt;code&gt;CxEVAL&lt;/code&gt; в стек контекста.</target>
        </trans-unit>
        <trans-unit id="46ec5458708076d609a6883cd1bd780e161cc64e" translate="yes" xml:space="preserve">
          <source>To say the least, surrogate pairs were the biggest mistake of the Unicode Consortium. But according to the late Douglas Adams in</source>
          <target state="translated">По крайней мере,суррогатные пары были самой большой ошибкой консорциума &quot;Юникод&quot;.Но по словам покойного Дугласа Адамса.</target>
        </trans-unit>
        <trans-unit id="48af12ca119bf709d476507ec2e3aea7bdcd0d97" translate="yes" xml:space="preserve">
          <source>To search the perlfaq question headings:</source>
          <target state="translated">Для поиска по заголовкам вопросов perlfaq:</target>
        </trans-unit>
        <trans-unit id="518862144f077b9ba7e98c4f411c046f6e96affb" translate="yes" xml:space="preserve">
          <source>To see all about your machine, type</source>
          <target state="translated">Чтобы увидеть все о вашей машине,введите</target>
        </trans-unit>
        <trans-unit id="5d0d28f6946dedb31c299d2d78aa9802594a8195" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">Чтобы увидеть, как работает (раз) упаковка, мы начнем с простого кода шаблона, в котором преобразование происходит на низком уровне: между содержимым последовательности байтов и строкой шестнадцатеричных цифр. Давайте использовать &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , так как это может напомнить вам о программе дампа или о каком-то отчаянном последнем сообщении, которое неудачные программы обычно бросают вам, прежде чем они исчезнут в дикой синеве. Предполагая, что переменная &lt;code&gt;$mem&lt;/code&gt; содержит последовательность байтов, которую мы хотели бы проверить, не предполагая ничего о ее значении, мы можем написать</target>
        </trans-unit>
        <trans-unit id="526ccfeab3729429cc060187cce1bbaba5ac3037" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">Чтобы увидеть, как это влияет на &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , мы сравним эти две структуры C:</target>
        </trans-unit>
        <trans-unit id="99fa402c0f19d397a266c609792e7a721baa908f" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">Чтобы узнать, содержит ли переменная ссылку, используйте функцию &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; . Он возвращает истину, если его аргумент является ссылкой. На самом деле это немного лучше: он возвращает &lt;code&gt;HASH&lt;/code&gt; для ссылок на хеш и &lt;code&gt;ARRAY&lt;/code&gt; для ссылок на массив.</target>
        </trans-unit>
        <trans-unit id="960bf2c563408fba71fe24086af2e53cbf0767bd" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">Чтобы узнать, влияет ли это несоответствие на вашу систему, проверьте, если &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; возвращает ложное значение. Потоки NTPL сохраняют семантику POSIX.</target>
        </trans-unit>
        <trans-unit id="d211374e5db97da1828e5f0a6f84c0b749ec44e8" translate="yes" xml:space="preserve">
          <source>To see it in action, add a method</source>
          <target state="translated">Чтобы увидеть это в действии,добавьте метод</target>
        </trans-unit>
        <trans-unit id="5e8654d4f5f9129c9cab32750ab5566521abf2dc" translate="yes" xml:space="preserve">
          <source>To see what a state description looks like, just run the following:</source>
          <target state="translated">Чтобы увидеть,как выглядит описание состояния,просто запустите следующее:</target>
        </trans-unit>
        <trans-unit id="1afd16a9742f3bb00f5d52a4bea0944a04f89bb4" translate="yes" xml:space="preserve">
          <source>To see what is installed on your system:</source>
          <target state="translated">Чтобы увидеть,что установлено в вашей системе:</target>
        </trans-unit>
        <trans-unit id="759c7cca5357567d905de52c1b1b6b667aaa23a6" translate="yes" xml:space="preserve">
          <source>To see what version is included on the DVD (assumed here to be mounted on /cdrom), issue this command:</source>
          <target state="translated">Чтобы посмотреть,какая версия включена в DVD (предполагается,что она будет смонтирована на /cdrom),выпустите эту команду:</target>
        </trans-unit>
        <trans-unit id="7ad61eadcf1dbdb7c99f44756b97def548456147" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt; :</source>
          <target state="translated">Чтобы узнать, есть ли у вас неконстантные данные, вы можете использовать совместимый с BSD (или GNU) &lt;code&gt;nm&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ceecb8953e41093c57b8581763c4bd993092c9bf" translate="yes" xml:space="preserve">
          <source>To see why this is a problem, consider what can happen when two processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same &lt;b&gt;DB_File&lt;/b&gt; database using the locking steps outlined above. Assume process &quot;A&quot; has already opened the database and has a write lock, but it hasn't actually updated the database yet (it has finished step 2, but not started step 3 yet). Now process &quot;B&quot; tries to open the same database - step 1 will succeed, but it will block on step 2 until process &quot;A&quot; releases the lock. The important thing to notice here is that at this point in time both processes will have cached identical initial blocks from the database.</source>
          <target state="translated">Чтобы понять, почему это проблема, подумайте, что может произойти, когда два процесса, скажем &amp;laquo;A&amp;raquo; и &amp;laquo;B&amp;raquo;, оба захотят обновить одну и &lt;b&gt;ту&lt;/b&gt; же &lt;b&gt;базу&lt;/b&gt; данных &lt;b&gt;DB_File,&lt;/b&gt; используя шаги блокировки, описанные выше. Предположим, что процесс &amp;laquo;A&amp;raquo; уже открыл базу данных и имеет блокировку записи, но на самом деле он еще не обновил базу данных (он завершил шаг 2, но еще не начал шаг 3). Теперь процесс &amp;laquo;B&amp;raquo; пытается открыть ту же базу данных - шаг 1 будет успешным, но он будет блокироваться на шаге 2, пока процесс &amp;laquo;A&amp;raquo; не снимет блокировку. Здесь важно отметить, что в этот момент оба процесса будут кэшировать идентичные начальные блоки из базы данных.</target>
        </trans-unit>
        <trans-unit id="887591ebb547202a2fbb02bece1d9984e9bcdec7" translate="yes" xml:space="preserve">
          <source>To see why, notice how you'll still have an issue on half-way-point alternation:</source>
          <target state="translated">Чтобы понять,почему,обратите внимание,что у вас все еще будет проблема с чередованием точек на полпути:</target>
        </trans-unit>
        <trans-unit id="0cddf3be7ebfd9389288691711afdcfed8edf9c1" translate="yes" xml:space="preserve">
          <source>To send a &lt;b&gt;datagram&lt;/b&gt; to multiple destinations simultaneously.</source>
          <target state="translated">Для одновременной отправки &lt;b&gt;дейтаграммы&lt;/b&gt; нескольким получателям.</target>
        </trans-unit>
        <trans-unit id="8617ca70598e41eabf7c915af7a92af825a55fcd" translate="yes" xml:space="preserve">
          <source>To send something to its correct destination. Often used metaphorically to indicate a transfer of programmatic control to a destination selected algorithmically, often by lookup in a table of function &lt;b&gt;references&lt;/b&gt; or, in the case of object &lt;b&gt;methods&lt;/b&gt;, by traversing the inheritance tree looking for the most specific definition for the method.</source>
          <target state="translated">Чтобы отправить что-то по назначению. Часто используется метафорически для обозначения передачи программного управления адресату, выбранному алгоритмически, часто путем поиска в таблице &lt;b&gt;ссылок&lt;/b&gt; на функции или, в случае объектных &lt;b&gt;методов&lt;/b&gt; , путем обхода дерева наследования в поисках наиболее конкретного определения метода.</target>
        </trans-unit>
        <trans-unit id="67e016f9948cc1473ec98e12bd274f9eaa7682bd" translate="yes" xml:space="preserve">
          <source>To set the state of a pragma:</source>
          <target state="translated">Чтобы установить состояние прагмы:</target>
        </trans-unit>
        <trans-unit id="4d0f638abe1cc26ab6bbeb03cebb08b40820c287" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</source>
          <target state="translated">Чтобы установить личное значение, вызовите &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39b42d6c90a6c04419bddc3aa56e776f03e6d4b1" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt; .</source>
          <target state="translated">Чтобы отключить его генерацию, &lt;code&gt;NO_META&lt;/code&gt; флаг &lt;code&gt;WriteMakefile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57cf8244407c213f6cbced635b585a8f402b31ff" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">Чтобы сигнализировать семафор, замените &lt;code&gt;-1&lt;/code&gt; на &lt;code&gt;1&lt;/code&gt; . См. Также документацию &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d782cb39a280e66911e6595a3826686b674e633e" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">Чтобы сигнализировать семафор, замените &lt;code&gt;-1&lt;/code&gt; на &lt;code&gt;1&lt;/code&gt; . См. Также документацию &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46e199b8e074ec6e1896ea95f9bad604e453a779" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">Чтобы сообщить Perl, что HMQ больше не нужен, вызовите &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Процесс Perl автоматически трансформируется / реформируется в / из процесса PM, если HMQ нужен / не нужен. Perl автоматически включает / отключает сообщение &lt;code&gt;WM_QUIT&lt;/code&gt; во время выключения, если очередь сообщений обслуживается / не обслуживается.</target>
        </trans-unit>
        <trans-unit id="3868e3b616a54cb1bab8634fd841ed657adc2c50" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt; ) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Subroutine Attributes in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">Чтобы молча интерпретировать его как оператор Perl, используйте префикс &lt;code&gt;CORE::&lt;/code&gt; в операторе (например, &lt;code&gt;CORE::log($x)&lt;/code&gt; ) или объявите подпрограмму как объектный метод (см. &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Атрибуты подпрограммы в perlsub&lt;/a&gt; или &lt;a href=&quot;attributes&quot;&gt;атрибуты&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea26257b4903cfdcc4f9b51c3c53cf94dc5f1003" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &quot;.&quot; character never matches a newline unless you use the &lt;code&gt;/s&lt;/code&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">Чтобы упростить многострочные замены, символ &quot;.&quot; символ никогда не соответствует новой строке, если вы не используете модификатор &lt;code&gt;/s&lt;/code&gt; , который, по сути, сообщает Perl, что строка представляет собой единственную строку, даже если это не так.</target>
        </trans-unit>
        <trans-unit id="3dcc0c984ac1c1f3aa01cd10ae020a1e23d2e144" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">Чтобы пропустить строки, используйте элементы управления зацикливанием. &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; в этом примере Пропускает строку комментариев, и &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; останавливает всю обработку , когда он встречает либо &lt;code&gt;__END__&lt;/code&gt; или &lt;code&gt;__DATA__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb7cc3fb6917e0db56d0ceef1f6b092afc65ddb" translate="yes" xml:space="preserve">
          <source>To solve this, you must manually use pipe(), fork(), and the form of open() which sets one file descriptor to another, as shown below:</source>
          <target state="translated">Для решения этой проблемы вы должны вручную использовать функции pipe(),fork()и форму open(),которая устанавливает дескриптор одного файла в другой,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="f205d5425879968b7952a3fb61c2ff97a391a194" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">Чтобы отсортировать хэш по значению, вам понадобится функция &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Вот числовой вид хеша по убыванию по его значениям:</target>
        </trans-unit>
        <trans-unit id="e22346e7b0a650eb196d705609c50726a647e816" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">Чтобы отсортировать хэш по значению, вам понадобится функция &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Вот числовой вид хеша по убыванию по его значениям:</target>
        </trans-unit>
        <trans-unit id="035b2f73f3e8b156397dc2189e758b10b01a049f" translate="yes" xml:space="preserve">
          <source>To sort a hash, start with the keys. In this example, we give the list of keys to the sort function which then compares them ASCIIbetically (which might be affected by your locale settings). The output list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a report which lists the keys in ASCIIbetical order.</source>
          <target state="translated">Чтобы отсортировать хэш,начни с клавиш.В этом примере мы предоставляем список ключей функции сортировки,которая затем сравнивает их ASCIIbetically (на которые могут повлиять настройки вашей локали).В списке вывода ключи находятся в ASCIIbetical порядке.После того,как у нас есть ключи,мы можем просмотреть их и создать отчёт,который перечислит ключи в ASCIIbetical порядке.</target>
        </trans-unit>
        <trans-unit id="bd567593644cab945269478fa56978a3d2bc8799" translate="yes" xml:space="preserve">
          <source>To specify a character by Unicode code point, use the form &lt;code&gt;\N{U+&lt;i&gt;code
point&lt;/i&gt;}&lt;/code&gt;, where</source>
          <target state="translated">Чтобы указать символ по кодовой точке Unicode, используйте форму &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="97bdead994a8b1301604dc655e33bb83cb6a1547" translate="yes" xml:space="preserve">
          <source>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</source>
          <target state="translated">Чтобы указать уровень сжатия при записи,добавьте цифру между 0 и 9 в строку режима --0 означает отсутствие сжатия,а 9-максимальное сжатие.Если уровень сжатия не указан,используется Z_DEFAULT_COMPRESSION.</target>
        </trans-unit>
        <trans-unit id="edce8429b2a3fa7edc3e49d4ca87a0b2294c60e2" translate="yes" xml:space="preserve">
          <source>To specify a particular stack size for any individual thread, call &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">Чтобы указать конкретный размер стека для любого отдельного потока, вызовите &lt;code&gt;-&amp;gt;create()&lt;/code&gt; с хеш-ссылкой в ​​качестве первого аргумента:</target>
        </trans-unit>
        <trans-unit id="5a3b28c1d56d62a0c685010a78c8616b6f249aaf" translate="yes" xml:space="preserve">
          <source>To specify a real-time timeout, supply the &lt;code&gt;LIFETIME&lt;/code&gt; option with a numeric value. Cached data will expire after this many seconds, and will be looked up afresh when it expires. When a data item is looked up afresh, its lifetime is reset.</source>
          <target state="translated">Чтобы указать тайм-аут в реальном времени, укажите для параметра &lt;code&gt;LIFETIME&lt;/code&gt; числовое значение. Срок действия кэшированных данных истечет по истечении этого количества секунд, и по истечении этого срока они будут просматриваться заново. Когда элемент данных просматривается заново, его время жизни сбрасывается.</target>
        </trans-unit>
        <trans-unit id="75872cec7b7dae2ec30afbe5f15f62f2ed47906e" translate="yes" xml:space="preserve">
          <source>To specify by name, the name of the character or character sequence goes between the curly braces.</source>
          <target state="translated">Для указания по имени имя символа или последовательность символов проходит между фигурными скобками.</target>
        </trans-unit>
        <trans-unit id="e22be0e52c335b1ce8908cd9371ba0e4b96e3022" translate="yes" xml:space="preserve">
          <source>To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</source>
          <target state="translated">Чтобы указать стратегию сжатия при записи,добавьте 'f' для отфильтрованных данных,'h' для сжатия только Huffman,или 'R' для кодирования длины выполнения.Если стратегия не указана,то используется Z_DEFAULT_STRATEGY.</target>
        </trans-unit>
        <trans-unit id="cb8a391550e8914db81270f773f4523451df8b90" translate="yes" xml:space="preserve">
          <source>To speed things up in complex installation scenarios, CPAN.pm keeps track of what it has already done and refuses to do some things a second time. A &lt;code&gt;get&lt;/code&gt; , a &lt;code&gt;make&lt;/code&gt; , and an &lt;code&gt;install&lt;/code&gt; are not repeated. A &lt;code&gt;test&lt;/code&gt; is repeated only if the previous test was unsuccessful. The diagnostic message when CPAN.pm refuses to do something a second time is one of</source>
          <target state="translated">Чтобы ускорить процесс в сложных сценариях установки, CPAN.pm отслеживает, что уже было сделано, и отказывается делать некоторые вещи во второй раз. &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , и &lt;code&gt;install&lt;/code&gt; не повторяются. &lt;code&gt;test&lt;/code&gt; повторяется , только если предыдущий тест был неудачным. Диагностическое сообщение, когда CPAN.pm отказывается делать что-либо во второй раз, является одним из</target>
        </trans-unit>
        <trans-unit id="ee745e8e1ccd43545cce5d6e1098128c6d2cb42b" translate="yes" xml:space="preserve">
          <source>To split a string automatically, as the</source>
          <target state="translated">Чтобы разделить строку автоматически,как</target>
        </trans-unit>
        <trans-unit id="76a587334bce3d780e4ef5607b4eb7989a44b338" translate="yes" xml:space="preserve">
          <source>To start external programs with complicated command lines (like with pipes in between, and/or quoting of arguments), Perl uses an external shell. With EMX port such shell should be named</source>
          <target state="translated">Для запуска внешних программ со сложными командными строками (например,с трубками между ними и/или цитированием аргументов)Perl использует внешнюю оболочку.При использовании EMX-порта такая оболочка должна иметь имя</target>
        </trans-unit>
        <trans-unit id="4496b7043de2731c625ff5d9cbb9bfec5778dc82" translate="yes" xml:space="preserve">
          <source>To start perl by clicking on a perl source file, you have to make the according entries in HKCR (see</source>
          <target state="translated">Чтобы запустить perl,щелкнув по файлу с исходным кодом perl,вы должны сделать соответствующие записи в HKCR (смотрите раздел</target>
        </trans-unit>
        <trans-unit id="ed415ca8982026bad9b823bf326a650e9d0848ae" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">Чтобы вычесть значение из переменной, например, &amp;laquo;уменьшить &lt;code&gt;$x&lt;/code&gt; &amp;raquo; (то есть удалить 1 из его значения) или &amp;laquo;уменьшить &lt;code&gt;$x&lt;/code&gt; на 3&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c34bd44153421ecb4ee7a84a5cf2f9e94314d16d" translate="yes" xml:space="preserve">
          <source>To summarise:</source>
          <target state="translated">Подводя итог:</target>
        </trans-unit>
        <trans-unit id="bdefe539f6f30e5536e03e0dcfcbf06113e55e75" translate="yes" xml:space="preserve">
          <source>To summarize, here are a number of possible methods for you to consider for storing the mapping between C and the Perl callback</source>
          <target state="translated">Подводя итог,вот несколько возможных методов,которые вы можете рассмотреть для хранения отображения между C и обратным вызовом на Perl</target>
        </trans-unit>
        <trans-unit id="87770a145a86a8f01c504f30ba378126d36ae639" translate="yes" xml:space="preserve">
          <source>To summarize, here's what to expect and how to handle locales in XS code:</source>
          <target state="translated">Подводя итог,скажу,чего ожидать и как работать с локалями в коде XS:</target>
        </trans-unit>
        <trans-unit id="9eda1d19cb3d66414653545444049318272d3717" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;\o{}&lt;/code&gt; form is always safe to use, and the other form is safe to use for code points through \077 when you use exactly three digits to specify them.</source>
          <target state="translated">Подводя итог, можно сказать, что форма &lt;code&gt;\o{}&lt;/code&gt; всегда безопасна в использовании, а другая форма безопасна для использования для кодовых точек до \ 077, когда вы используете ровно три цифры для их указания.</target>
        </trans-unit>
        <trans-unit id="f40c24735c228769cecae3c743dcd1c13b34fed1" translate="yes" xml:space="preserve">
          <source>To summarize, this modifier provides protection for applications that don't wish to be exposed to all of Unicode. Specifying it twice gives added protection.</source>
          <target state="translated">Подводя итог,можно сказать,что этот модификатор обеспечивает защиту приложений,которые не желают подвергаться воздействию всего Юникода.Дважды указав его,вы получите дополнительную защиту.</target>
        </trans-unit>
        <trans-unit id="8b52f75bf07c40cc3e2dd50eeec591de76cf40c0" translate="yes" xml:space="preserve">
          <source>To support potentially complex type mappings, if a typemap entry used by an XSUB contains a comment like &lt;code&gt;/*scope*/&lt;/code&gt; then scoping will be automatically enabled for that XSUB.</source>
          <target state="translated">Для поддержки потенциально сложных сопоставлений типов, если запись typemap, используемая XSUB, содержит комментарий, например &lt;code&gt;/*scope*/&lt;/code&gt; , тогда для этого XSUB будет автоматически включена область видимости.</target>
        </trans-unit>
        <trans-unit id="c8462b0ae01f912ec184e35a1a54c294d3db9c0b" translate="yes" xml:space="preserve">
          <source>To support these systems a dl_expandspec() function can be implemented either in the</source>
          <target state="translated">Для поддержки этих систем функция dl_expandspec()может быть реализована как в функции</target>
        </trans-unit>
        <trans-unit id="28ae7b79101a8be6ce604e7c61e718194e3e904d" translate="yes" xml:space="preserve">
          <source>To swap pairs of characters in a string (with even length) one could use several techniques. First, let's use &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; to skip forward and back:</source>
          <target state="translated">Чтобы поменять местами пары символов в строке (с одинаковой длиной), можно использовать несколько приемов. Во-первых, давайте использовать &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;X&lt;/code&gt; для перехода вперед и назад:</target>
        </trans-unit>
        <trans-unit id="52ed4dc484d91fd5d94539987c6af1829eb4d58f" translate="yes" xml:space="preserve">
          <source>To switch back to the default behaviour, use</source>
          <target state="translated">Чтобы вернуться к поведению по умолчанию,используйте</target>
        </trans-unit>
        <trans-unit id="9ad4d27e66821295806e39cdf16c87b63c90f1ed" translate="yes" xml:space="preserve">
          <source>To take a closer look at how the engine does optimizations, see the section &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Pragmas and debugging&lt;/a&gt; below.</source>
          <target state="translated">Чтобы подробнее узнать, как движок выполняет оптимизацию, см. Раздел &amp;laquo; &lt;a href=&quot;#Pragmas-and-debugging&quot;&gt;Прагмы и отладка&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="f3651fac40bf38f464aae40f7d0973a874e0f3ea" translate="yes" xml:space="preserve">
          <source>To test that your code is behaving correctly and not modifying COW buffers, on systems that support</source>
          <target state="translated">Проверить,что Ваш код ведет себя корректно и не модифицирует COW буферы,на системах,поддерживающих</target>
        </trans-unit>
        <trans-unit id="8ce0bdd874392ab18a8e9a217e048b7e9971ae31" translate="yes" xml:space="preserve">
          <source>To test whether a variable contains tainted data, and whose use would thus trigger an &quot;Insecure dependency&quot; message, you can use the &lt;code&gt;tainted()&lt;/code&gt; function of the Scalar::Util module, available in your nearby CPAN mirror, and included in Perl starting from the release 5.8.0. Or you may be able to use the following &lt;code&gt;is_tainted()&lt;/code&gt; function.</source>
          <target state="translated">Чтобы проверить, содержит ли переменная испорченные данные и чье использование, таким образом, вызовет сообщение &amp;laquo;Небезопасная зависимость&amp;raquo;, вы можете использовать функцию &lt;code&gt;tainted()&lt;/code&gt; модуля Scalar :: Util, доступную в вашем ближайшем зеркале CPAN и включенную в Perl, начиная с из выпуска 5.8.0. Или вы можете использовать следующую &lt;code&gt;is_tainted()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="521a49c8c35183a9a627a2f63a5d516c8a7cf5ba" translate="yes" xml:space="preserve">
          <source>To the Perl program that called fork(), all this is designed to be transparent. The parent returns from the fork() with a pseudo-process ID that can be subsequently used in any process-manipulation functions; the child returns from the fork() with a value of &lt;code&gt;0&lt;/code&gt; to signify that it is the child pseudo-process.</source>
          <target state="translated">Для программы Perl, которая вызвала fork (), все это должно быть прозрачным. Родитель возвращается из fork () с идентификатором псевдопроцесса, который впоследствии может быть использован в любых функциях управления процессом; потомок возвращается из fork () со значением &lt;code&gt;0&lt;/code&gt; , что означает, что это дочерний псевдопроцесс.</target>
        </trans-unit>
        <trans-unit id="c7e05b4fcf627d6e6c4197f19ffda73a879c664a" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will attempt to fix critical issues in the two most recent stable 5.x release series. Fixes for the current release series take precedence over fixes for the previous release series.</source>
          <target state="translated">В меру своих возможностей мы постараемся исправить критические проблемы в двух последних стабильных релизах серии 5.x.Исправления для текущей серии релиза имеют приоритет над исправлениями для предыдущей серии.</target>
        </trans-unit>
        <trans-unit id="51a0f8c69bc4919eb0f20691df0fe50a577785df" translate="yes" xml:space="preserve">
          <source>To the best of our ability, we will provide &quot;critical&quot; security patches / releases for any major version of Perl whose 5.x.0 release was within the past three years. We can only commit to providing these for the most recent .y release in any 5.x.y series.</source>
          <target state="translated">В меру наших возможностей,мы будем предоставлять &quot;критические&quot; исправления/релизы безопасности для любой основной версии Perl,чей релиз 5.x.0 был в течение последних трех лет.Мы можем предоставить их только для последнего релиза .y из любой серии 5.x.y.</target>
        </trans-unit>
        <trans-unit id="6fa12fa0dac95b52f8a74aca03b7455d8e9dea13" translate="yes" xml:space="preserve">
          <source>To throw away the current &lt;b&gt;process&lt;/b&gt;&amp;rsquo;s program and replace it with another, without exiting the process or relinquishing any resources held (apart from the old memory image).</source>
          <target state="translated">Чтобы выбросить программу текущего &lt;b&gt;процесса&lt;/b&gt; и заменить ее другой, не выходя из процесса или не отказываясь от любых удерживаемых ресурсов (кроме старого образа в памяти).</target>
        </trans-unit>
        <trans-unit id="448a61a17f3cda496b5d3ba49da88ff7c85062ed" translate="yes" xml:space="preserve">
          <source>To transform a bit vector into a string or list of 0's and 1's, use these:</source>
          <target state="translated">Чтобы преобразовать битовый вектор в строку или список 0 и 1,используйте эти:</target>
        </trans-unit>
        <trans-unit id="8d6d675a384b336013b57ff889fd3d31ada57c0a" translate="yes" xml:space="preserve">
          <source>To trim trailing newlines from text lines use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;. With default settings that function looks for a trailing &lt;code&gt;\n&lt;/code&gt; character and thus trims in a portable way.</source>
          <target state="translated">Чтобы обрезать завершающие символы новой строки из текстовых строк, используйте &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; . При настройках по умолчанию эта функция ищет завершающий символ &lt;code&gt;\n&lt;/code&gt; и, таким образом, выполняет обрезку переносимым способом.</target>
        </trans-unit>
        <trans-unit id="40f27a2565b48c1f61edc1951aa27946b5ec4637" translate="yes" xml:space="preserve">
          <source>To turn a hostname into a human-readable plain IP address use getaddrinfo() to turn the hostname into a list of socket structures, then getnameinfo() on each one to make it a readable IP address again.</source>
          <target state="translated">Чтобы превратить имя хоста в читаемый человеком простой IP-адрес,используйте getaddrinfo(),чтобы превратить имя хоста в список структур сокетов,затем getnameinfo()на каждом из них,чтобы сделать его снова читаемым IP-адресом.</target>
        </trans-unit>
        <trans-unit id="f7838aca863be2066e77c33f9ec760e481423363" translate="yes" xml:space="preserve">
          <source>To turn one string representation into another by mapping each character of the source string to its corresponding character in the result string. Not to be confused with translation: for example, Greek</source>
          <target state="translated">Превратить одно строковое представление в другое путем сопоставления каждого символа исходной строки с соответствующим ему символом в строке результата.Не путать с переводом:например,Greek</target>
        </trans-unit>
        <trans-unit id="2796f222a72ab401559f8c49bff573c8aee5f84f" translate="yes" xml:space="preserve">
          <source>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier &lt;code&gt;CORE::&lt;/code&gt; . For example, saying &lt;code&gt;CORE::open()&lt;/code&gt; always refers to the built-in &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, even if the current package has imported some other subroutine called &lt;code&gt;&amp;amp;open()&lt;/code&gt; from elsewhere. Even though it looks like a regular function call, it isn't: the CORE:: prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; , only works for some keywords. See &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt;.</source>
          <target state="translated">Чтобы однозначно ссылаться на встроенную форму, перед встроенным именем &lt;code&gt;CORE::&lt;/code&gt; специальный квалификатор пакета CORE :: . Например, выражение &lt;code&gt;CORE::open()&lt;/code&gt; всегда относится к встроенному &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , даже если текущий пакет импортировал какую-то другую подпрограмму под названием &lt;code&gt;&amp;amp;open()&lt;/code&gt; из другого места. Несмотря на то, что это выглядит как обычный вызов функции, это не так: префикс CORE :: в этом случае является частью синтаксиса Perl и работает для любого ключевого слова, независимо от того, что находится в пакете CORE. Ссылка на него, то есть &lt;code&gt;\&amp;amp;CORE::open&lt;/code&gt; , работает только для некоторых ключевых слов. См. &lt;a href=&quot;core&quot;&gt;CORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="248423c43b116b150a001ee976cc646676062436" translate="yes" xml:space="preserve">
          <source>To uncompress</source>
          <target state="translated">Чтобы не сжимать</target>
        </trans-unit>
        <trans-unit id="218af45982210497e46e853ffef0192283629105" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1950&quot; and store the compressed data in the same directory</source>
          <target state="translated">Распаковать все файлы в директории &quot;/my/home&quot;,соответствующие &quot;*.txt.1950&quot; и сохранить сжатые данные в той же директории.</target>
        </trans-unit>
        <trans-unit id="5ddcb357cfd2b7762051e66890c8b84e7d960611" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.1951&quot; and store the compressed data in the same directory</source>
          <target state="translated">Распаковать все файлы в директории &quot;/my/home&quot;,соответствующие &quot;*.txt.1951&quot; и сохранить сжатые данные в той же директории.</target>
        </trans-unit>
        <trans-unit id="0e932ba5dc24bfd784757a246bd08027f46d4625" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.Compressed&quot; and store the compressed data in the same directory</source>
          <target state="translated">Распаковать все файлы в директории &quot;/my/home&quot;,соответствующие &quot;*.txt.Compressed&quot; и сохранить сжатые данные в той же директории.</target>
        </trans-unit>
        <trans-unit id="29a087f9cfa51d4e0c2f6a475a11f449e63412aa" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.bz2&quot; and store the compressed data in the same directory</source>
          <target state="translated">Распаковать все файлы в каталоге &quot;/my/home&quot;,соответствующие &quot;*.txt.bz2&quot; и сохранить сжатые данные в том же каталоге.</target>
        </trans-unit>
        <trans-unit id="61aa1a4650d4e1d7c6939abfa456f5aeb3345d9a" translate="yes" xml:space="preserve">
          <source>To uncompress all files in the directory &quot;/my/home&quot; that match &quot;*.txt.gz&quot; and store the compressed data in the same directory</source>
          <target state="translated">Распаковать все файлы в каталоге &quot;/my/home&quot;,соответствующие &quot;*.txt.gz&quot; и сохранить сжатые данные в том же каталоге</target>
        </trans-unit>
        <trans-unit id="2754edb3f14d19ed8eebfcca373f83ac4a3282e7" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">Чтобы распаковать поток данных RFC 1950, установите &lt;code&gt;WindowBits&lt;/code&gt; на положительное число от 8 до 15.</target>
        </trans-unit>
        <trans-unit id="44083e3f2b591fd2c77505655cdb2c8f0aceb349" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">Чтобы распаковать поток данных RFC 1950, установите &lt;code&gt;WindowBits&lt;/code&gt; на положительное число.</target>
        </trans-unit>
        <trans-unit id="ceb9d1b68954b1740a461cdcd4976b0e567a28d9" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">Чтобы распаковать поток данных RFC 1951, установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42e613bd86be8bd3cb751a2f5e9d0b238c337e5e" translate="yes" xml:space="preserve">
          <source>To uncompress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">Чтобы распаковать поток данных RFC 1952 (например, gzip), установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;WANT_GZIP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be309868d7c608c972ac92d2374d84d68bbcff87" translate="yes" xml:space="preserve">
          <source>To understand what kinds of incompatibilities one may expect, and in the rare case that the version of Perl on your machine is older than this document, see the section on &quot;Troubleshooting these Examples&quot; for more information.</source>
          <target state="translated">Чтобы понять,какие виды несовместимости можно ожидать,и в редких случаях,когда версия Perl на вашей машине старше,чем этот документ,см.раздел &quot;Устранение неполадок в этих примерах&quot; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6b79315e2daa0488ef5b85ec7b3ded4c1bf9ff5d" translate="yes" xml:space="preserve">
          <source>To understand what the above</source>
          <target state="translated">Чтобы понять,что вышеизложенное</target>
        </trans-unit>
        <trans-unit id="84e6e80a4aa5a302f6ddaa79d242cdcf126f821b" translate="yes" xml:space="preserve">
          <source>To uppercase or lowercase several characters, one might want to use &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; , which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of &lt;code&gt;\E&lt;/code&gt; , whichever comes first. They provide functionality similar to what the functions &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; provide.</source>
          <target state="translated">Для прописных или строчных нескольких символов можно использовать &lt;code&gt;\L&lt;/code&gt; или &lt;code&gt;\U&lt;/code&gt; , которые будут строчными / прописными всеми символами, следующими за ними, до конца шаблона или до следующего появления &lt;code&gt;\E&lt;/code&gt; , в зависимости от того, что наступит раньше. Они предоставляют функциональные возможности, аналогичные функциям &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd3b3ccd26f316b1795adeb89ffff2bedd268ce6" translate="yes" xml:space="preserve">
          <source>To use 'load_remote' or 'autoload_remote', specify at 'use'.</source>
          <target state="translated">Чтобы использовать 'load_remote' или 'autoload_remote',укажите в поле 'use'.</target>
        </trans-unit>
        <trans-unit id="8a5610b8c5bc5858528e5c0711e8cd5aeeeaeb22" translate="yes" xml:space="preserve">
          <source>To use &lt;b&gt;AutoLoader&lt;/b&gt;, the author of a module has to place the definitions of subroutines to be autoloaded after an &lt;code&gt;__END__&lt;/code&gt; token. (See &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;.) The &lt;b&gt;AutoSplit&lt;/b&gt; module can then be run manually to extract the definitions into individual files</source>
          <target state="translated">Чтобы использовать &lt;b&gt;AutoLoader&lt;/b&gt; , автор модуля должен поместить определения подпрограмм для автозагрузки после токена &lt;code&gt;__END__&lt;/code&gt; . (См. &lt;a href=&quot;perldata&quot;&gt;Perldata&lt;/a&gt; .) Затем модуль &lt;b&gt;AutoSplit&lt;/b&gt; можно запустить вручную для извлечения определений в отдельные файлы.</target>
        </trans-unit>
        <trans-unit id="d246c1b4a8c6fc55969eb14bc150616f75299064" translate="yes" xml:space="preserve">
          <source>To use Getopt::Long from a Perl program, you must include the following line in your Perl program:</source>
          <target state="translated">Чтобы использовать Getopt::Long от программы на Perl,вы должны включить в свою программу на Perl следующую строку:</target>
        </trans-unit>
        <trans-unit id="6a708529644756357339b6bd4e7ce1cb0f6dc3ee" translate="yes" xml:space="preserve">
          <source>To use a here-document to assign an array, one line per element, you might use an approach like this:</source>
          <target state="translated">Чтобы использовать здесь-документ для назначения массива,по одной строке на элемент,можно использовать такой подход:</target>
        </trans-unit>
        <trans-unit id="d339f8f2813eea011c2650e8b1ed1fdac84e3d1c" translate="yes" xml:space="preserve">
          <source>To use a lexical subroutine from inside the subroutine itself, you must predeclare it. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; declaration.</source>
          <target state="translated">Чтобы использовать лексическую подпрограмму внутри самой подпрограммы, вы должны предварительно объявить ее. &lt;code&gt;sub foo {...}&lt;/code&gt; определение подпрограммы синтаксических отношения всего предыдущий &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; или &lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;;&lt;/code&gt; декларация.</target>
        </trans-unit>
        <trans-unit id="0a6c22616496274a8c0483ef0b81201680edefba" translate="yes" xml:space="preserve">
          <source>To use in your program as a pragma, merely invoke</source>
          <target state="translated">Чтобы использовать в вашей программе в качестве прагмы,просто вызовите</target>
        </trans-unit>
        <trans-unit id="c9702d448044d584ba0f08cf12e0416ad038a1b6" translate="yes" xml:space="preserve">
          <source>To use it more practically, you have to give the names of encodings to check (</source>
          <target state="translated">Чтобы использовать его более практично,вы должны дать имена кодировок для проверки (</target>
        </trans-unit>
        <trans-unit id="22588255917f935bc82a9b5e6907a6c5af5e0773" translate="yes" xml:space="preserve">
          <source>To use the OVERLOAD: keyword, create an XS function which takes three input parameters ( or use the c style '...' definition) like this:</source>
          <target state="translated">Чтобы использовать ключевое слово OVERLOAD:,создайте функцию XS,которая принимает три входных параметра(или используйте определение стиля c '...'),как это:</target>
        </trans-unit>
        <trans-unit id="3dc634fc1f1bc1b5d00fde6bff6b384f2eeb3f97" translate="yes" xml:space="preserve">
          <source>To use the Perl you just installed you will need to add a new entry to your PATH environment variable: &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , e.g.</source>
          <target state="translated">Чтобы использовать только что установленный Perl, вам нужно будет добавить новую запись в переменную среды PATH: &lt;code&gt;$INST_TOP\bin&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="7bc829cf0e8a5c97f97a31b7c617e9428478c19b" translate="yes" xml:space="preserve">
          <source>To use the forked debugger, you need to have the default display set to an X-11 Server and some environment variables set that Unix expects.</source>
          <target state="translated">Для использования вилочного отладчика необходимо,чтобы по умолчанию дисплей был установлен на X-11 Server и некоторые переменные окружения были установлены так,как ожидает Unix.</target>
        </trans-unit>
        <trans-unit id="fc207fecfdae515e813f72872e49086f5b78c28e" translate="yes" xml:space="preserve">
          <source>To use the module it is necessary to do the following:</source>
          <target state="translated">Для использования модуля необходимо сделать следующее:</target>
        </trans-unit>
        <trans-unit id="dd4bd0185af39ed243608e8976fc475a01dc61d4" translate="yes" xml:space="preserve">
          <source>To use this expiration policy, the user would say</source>
          <target state="translated">Чтобы использовать эту политику истечения срока действия,пользователь сказал бы.</target>
        </trans-unit>
        <trans-unit id="538ca1c3044001d3cfa088cc4be7d0f4954981d6" translate="yes" xml:space="preserve">
          <source>To use this method you must have the Digest::MD5 or the MD5 module installed, otherwise this method will return</source>
          <target state="translated">Чтобы использовать этот метод,у вас должен быть установлен Digest::MD5 или модуль MD5,иначе этот метод вернет</target>
        </trans-unit>
        <trans-unit id="b3ee11508a4f000324b572266622a1fcc5b08715" translate="yes" xml:space="preserve">
          <source>To use this performance boost, set the current directory via</source>
          <target state="translated">Чтобы использовать этот прирост производительности,установите текущий каталог с помощью параметра</target>
        </trans-unit>
        <trans-unit id="38c026c273aff885d8062765e295cb0676868f0f" translate="yes" xml:space="preserve">
          <source>To warn with a simple string message, the &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">Чтобы предупредить с помощью простого строкового сообщения, функция &lt;a href=&quot;#warn&quot;&gt;предупреждения&lt;/a&gt; может быть более удобной.</target>
        </trans-unit>
        <trans-unit id="be15e0c4892f05af6b92d2d4a6be1a0a5f9a6dcd" translate="yes" xml:space="preserve">
          <source>To watch the tail of a dynamically growing logfile, (from the command line):</source>
          <target state="translated">Наблюдать за хвостом динамически растущего лог-файла (из командной строки):</target>
        </trans-unit>
        <trans-unit id="a70297b48e7206cae4fcb0090dd44f6d0f3207a8" translate="yes" xml:space="preserve">
          <source>To work around this bug, surround the code with a second set of braces. This creates an inner block that defeats the &lt;code&gt;MULTICALL&lt;/code&gt; logic, and does get fresh SVs allocated each time:</source>
          <target state="translated">Чтобы обойти эту ошибку, заключите код вторым набором скобок. Это создает внутренний блок, который нарушает логику &lt;code&gt;MULTICALL&lt;/code&gt; и каждый раз получает новые SV:</target>
        </trans-unit>
        <trans-unit id="df77a0e9f9993c56d24066721ca0f8c51a0345d4" translate="yes" xml:space="preserve">
          <source>To work around this, set environment variables as part of the</source>
          <target state="translated">Чтобы обойти эту проблему,установите переменные окружения как часть</target>
        </trans-unit>
        <trans-unit id="67bc56a45c2b844733bf04f643db3f4d6359ddb1" translate="yes" xml:space="preserve">
          <source>To work with only alphanumeric sequences (including underscores), you might consider</source>
          <target state="translated">Для работы только с буквенно-цифровыми последовательностями (включая подчеркивания),вы можете рассмотреть следующие варианты</target>
        </trans-unit>
        <trans-unit id="737fcabd51bb1faacb7059e47b96e0c587be8c5f" translate="yes" xml:space="preserve">
          <source>To write a test for your new (and probably not even done) module, create a new file called</source>
          <target state="translated">Чтобы написать тест для вашего нового (и,возможно,даже не законченного)модуля,создайте новый файл с названием</target>
        </trans-unit>
        <trans-unit id="02bfda7919e7b9ec9d9ea9a01639287be236928c" translate="yes" xml:space="preserve">
          <source>To write platform-independent code, you must use &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; instead, like &lt;code&gt;\N{ESCAPE}&lt;/code&gt; or &lt;code&gt;\N{U+001B}&lt;/code&gt; , see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Чтобы написать независимый от платформы код, вы должны использовать вместо него &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; , например &lt;code&gt;\N{ESCAPE}&lt;/code&gt; или &lt;code&gt;\N{U+001B}&lt;/code&gt; , см. &lt;a href=&quot;charnames&quot;&gt;Имена символов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32379df686c78a3422056dcfb4c9b1da18747d64" translate="yes" xml:space="preserve">
          <source>To yield a usable Perl variable, characters that are not part of the syntax for variables are translated to underscores. For example, &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; will set the variable &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; . Note that this variable resides in the namespace of the calling program, not necessarily &lt;code&gt;main&lt;/code&gt; . For example:</source>
          <target state="translated">Чтобы получить пригодную для использования переменную Perl, символы, не являющиеся частью синтаксиса переменных, переводятся в символы подчеркивания. Например, &lt;code&gt;--fpp-struct-&lt;a href=&quot;../functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; установит переменную &lt;code&gt;$opt_fpp_struct_return&lt;/code&gt; . Обратите внимание, что эта переменная находится в пространстве имен вызывающей программы, не обязательно в &lt;code&gt;main&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="33224443be18843a7174975c46578d74787bc749" translate="yes" xml:space="preserve">
          <source>Tobias Brox, tobiasb@tobiasb.funcom.com</source>
          <target state="translated">Тобиас Брокс,tobiasb@tobiasb.funcom.com</target>
        </trans-unit>
        <trans-unit id="ec7a57e5883d57c428d8e15819e5060eeed56435" translate="yes" xml:space="preserve">
          <source>Together, these categories go a long way towards being able to customize a single program to run in many different locations. But there are deficiencies, so keep reading.</source>
          <target state="translated">Вместе эти категории имеют большое значение для того,чтобы иметь возможность настраивать одну программу для работы в разных местах.Но есть и недостатки,так что продолжайте читать.</target>
        </trans-unit>
        <trans-unit id="6f1eb05b47fbf56bdd9586b2ff6beeffab4ce59f" translate="yes" xml:space="preserve">
          <source>Together, these two features are intended to replace the historical &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, which has (at least) two bugs in it, that cannot easily be fixed without breaking existing programs:</source>
          <target state="translated">Вместе эти две функции предназначены для замены исторической функции &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , в которой есть (как минимум) две ошибки, которые нельзя легко исправить без нарушения существующих программ:</target>
        </trans-unit>
        <trans-unit id="5379fd6502d08f80951bb93415834c8443e36cd5" translate="yes" xml:space="preserve">
          <source>Toggle trace mode (see also the &lt;code&gt;AutoTrace&lt;/code&gt; option). Optional argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent.</source>
          <target state="translated">Переключить режим трассировки (см. Также параметр &lt;code&gt;AutoTrace&lt;/code&gt; ). Необязательный аргумент - максимальное количество уровней для трассировки ниже текущего; все, что глубже, будет безмолвным.</target>
        </trans-unit>
        <trans-unit id="f422da5828ccca294dcf6d07ee5efb74761f28a1" translate="yes" xml:space="preserve">
          <source>Tokens from Pod::Simple::PullParser</source>
          <target state="translated">Жетоны от Pod::Simple::PullParser</target>
        </trans-unit>
        <trans-unit id="685cbbd2434336a1c0d592cb5e469ec23061ee59" translate="yes" xml:space="preserve">
          <source>Tom Christiansen</source>
          <target state="translated">Том Христиансен</target>
        </trans-unit>
        <trans-unit id="8be2aa955349ba9da124a5ab00db7e6f88ee861a" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;</source>
          <target state="translated">Том Кристиансен &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5ca9f204e050f14afeeca056eec19f3529541293" translate="yes" xml:space="preserve">
          <source>Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; wrote this, with occasional kibbitzing from Larry Wall and Jeffrey Friedl in the background.</source>
          <target state="translated">Это написал Том Кристиансен &amp;lt;tchrist@perl.com&amp;gt;, на заднем плане время от времени высказывались Ларри Уолл и Джеффри Фридл.</target>
        </trans-unit>
        <trans-unit id="8e134c4a6e79e76b0db622556fcf6a08eb055742" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original perlfaq then expanded it with the help of Nat Torkington. brian d foy substantially edited and expanded the perlfaq. perlfaq-workers and others have also supplied feedback, patches and corrections over the years.</source>
          <target state="translated">Том Кристиансен написал оригинал perlfaq,а затем расширил его с помощью Нэт Торкингтон.Брайан д фой существенно отредактировал и расширил perlfaq.perlfaq-работники и другие также предоставили отзывы,патчи и исправления на протяжении многих лет.</target>
        </trans-unit>
        <trans-unit id="13f0322dc66b8435d53d03e97ab3bdb9a5e08c67" translate="yes" xml:space="preserve">
          <source>Tom Christiansen wrote the original version of this document. brian d foy &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; wrote this version. See the individual perlfaq documents for additional copyright information.</source>
          <target state="translated">Том Кристиансен написал оригинальную версию этого документа. Брайан Д &lt;code&gt;&amp;lt;bdfoy@cpan.org&amp;gt;&lt;/code&gt; написал эту версию. См. Отдельные документы perlfaq для получения дополнительной информации об авторских правах.</target>
        </trans-unit>
        <trans-unit id="594631f752605ca51961fa701a3edb58acb263cd" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, &amp;lt;tchrist@perl.com&amp;gt;.</source>
          <target state="translated">Том Кристиансен, &amp;lt;tchrist@perl.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="95a03ceecd01437e5e0609dbfa8dc64983a0ce69" translate="yes" xml:space="preserve">
          <source>Tom Christiansen, with occasional vestiges of Larry Wall's original version and suggestions from the Perl Porters.</source>
          <target state="translated">Том Кристиансен,с редкими остатками оригинальной версии Ларри Уолла и предложениями от Perl Porters.</target>
        </trans-unit>
        <trans-unit id="476ccb2f91007a71136d530d51755067de803643" translate="yes" xml:space="preserve">
          <source>Tom Phoenix, &amp;lt;</source>
          <target state="translated">Том Феникс, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ba42647932e0b5434947f286f404459ce1a76e83" translate="yes" xml:space="preserve">
          <source>Too few records will be retrieved.</source>
          <target state="translated">Слишком мало записей будет найдено.</target>
        </trans-unit>
        <trans-unit id="0f85c6fbc6b17f4b329c823a126de114fb51f097" translate="yes" xml:space="preserve">
          <source>Too many will be retrieved.</source>
          <target state="translated">Слишком много будет найдено.</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="2f4169d30e0802a9d8a3d39c5549f0963dd393e1" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; SDK</source>
          <target state="translated">Инструменты и SDK</target>
        </trans-unit>
        <trans-unit id="a00a8f35172e2849241ce00e52e7b7a9a0047d25" translate="yes" xml:space="preserve">
          <source>Top of Form Processing</source>
          <target state="translated">Вершина обработки форм</target>
        </trans-unit>
        <trans-unit id="ee80479b0fa9a2d2efdf0ff5851a9a2f37c4056d" translate="yes" xml:space="preserve">
          <source>Top of form processing is handled automatically: if there is insufficient room on the current page for the formatted record, the page is advanced by writing a form feed and a special top-of-page format is used to format the new page header before the record is written. By default, the top-of-page format is the name of the filehandle with &quot;_TOP&quot; appended, or &quot;top&quot; in the current package if the former does not exist. This would be a problem with autovivified filehandles, but it may be dynamically set to the format of your choice by assigning the name to the &lt;code&gt;$^&lt;/code&gt; variable while that filehandle is selected. The number of lines remaining on the current page is in variable &lt;code&gt;$-&lt;/code&gt; , which can be set to &lt;code&gt;0&lt;/code&gt; to force a new page.</source>
          <target state="translated">Обработка начала формы выполняется автоматически: если на текущей странице недостаточно места для форматированной записи, страница продвигается вперед путем написания канала формы, и для форматирования нового заголовка страницы перед форматом используется специальный формат верхней части страницы. запись написана. По умолчанию формат верхней части страницы - это имя дескриптора файла с добавленным &amp;laquo;_TOP&amp;raquo; или &amp;laquo;верх&amp;raquo; в текущем пакете, если первый не существует. Это было бы проблемой с автоактивизированными дескрипторами файлов, но для него можно динамически задать формат по вашему выбору, присвоив имя переменной &lt;code&gt;$^&lt;/code&gt; когда этот дескриптор файла выбран. Количество строк, оставшихся на текущей странице, находится в переменной &lt;code&gt;$-&lt;/code&gt; , которая может быть установлена ​​в &lt;code&gt;0&lt;/code&gt; , чтобы принудительно открыть новую страницу.</target>
        </trans-unit>
        <trans-unit id="9d8d0feb3edb0eff1e9ffe23486e4f54336c8d4e" translate="yes" xml:space="preserve">
          <source>Top-of-form processing is by default handled by a format with the same name as the current filehandle with &quot;_TOP&quot; concatenated to it. It's triggered at the top of each page. See &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;.</source>
          <target state="translated">Обработка верхней части формы по умолчанию обрабатывается форматом с тем же именем, что и текущий дескриптор файла, с присоединенным к нему &amp;laquo;_TOP&amp;raquo;. Он запускается вверху каждой страницы. Смотрите &lt;a href=&quot;functions/write&quot;&gt;напишите&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="855b740deb0e234d1668b8ec10c825eb8a3450f0" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of any children processes.</source>
          <target state="translated">Общий процессор (пользователь+система)любых дочерних процессов.</target>
        </trans-unit>
        <trans-unit id="3481164ed61c4f3a7713de67224c54bcab0e71f6" translate="yes" xml:space="preserve">
          <source>Total CPU (User + System) of the main (parent) process.</source>
          <target state="translated">Общий процессор (пользователь+система)основного (родительского)процесса.</target>
        </trans-unit>
        <trans-unit id="1e2c196e8d42960075bf83565f85bd785a488f4c" translate="yes" xml:space="preserve">
          <source>Total CPU of parent and any children processes.</source>
          <target state="translated">Общий процессор родительских и любых дочерних процессов.</target>
        </trans-unit>
        <trans-unit id="4b32a7b148f732eb014244c4bbbcbbea6216c149" translate="yes" xml:space="preserve">
          <source>Trace mode (similar to &lt;code&gt;t&lt;/code&gt; command, but can be put into &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ).</source>
          <target state="translated">Режим трассировки (аналогичен команде &lt;code&gt;t&lt;/code&gt; , но может быть помещен в &lt;code&gt;PERLDB_OPTS&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d8c4db1a294c0162454110ac7c8472297017033" translate="yes" xml:space="preserve">
          <source>Trace through execution of &lt;code&gt;expr&lt;/code&gt; . Optional first argument is the maximum number of levels to trace below the current one; anything deeper than that will be silent. See &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;Frame Listing Output Examples in perldebguts&lt;/a&gt; for examples.</source>
          <target state="translated">Проследить выполнение &lt;code&gt;expr&lt;/code&gt; . Необязательный первый аргумент - это максимальное количество уровней для трассировки ниже текущего; все, что глубже, будет безмолвным. &lt;a href=&quot;perldebguts#Frame-Listing-Output-Examples&quot;&gt;Примеры&lt;/a&gt; см. В разделе Примеры вывода списка кадров в perldebguts .</target>
        </trans-unit>
        <trans-unit id="24be5dbb481a63442832782f4da3ef4f0dc024ff" translate="yes" xml:space="preserve">
          <source>Trace variable used when Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch. This is the C variable which corresponds to Perl's $DB::trace variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Переменная трассировки, используемая при запуске Perl в режиме отладки с ключом &lt;b&gt;-d&lt;/b&gt; . Это переменная C, соответствующая переменной Perl $ DB :: trace. См. &lt;code&gt;PL_DBsingle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="411aea8f76aef96f5e36c8b291c19e9ceb9466d1" translate="yes" xml:space="preserve">
          <source>Traces changes to Perl's interpreter state. You can internalize this as tracing changes to Perl's &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable, especially since the values for &lt;code&gt;NEWPHASE&lt;/code&gt; and &lt;code&gt;OLDPHASE&lt;/code&gt; are the strings that &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; reports.</source>
          <target state="translated">Отслеживает изменения в состоянии интерпретатора Perl. Вы можете &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; это как отслеживание изменений в переменной Perl $ {^ GLOBAL_PHASE} , особенно потому, что значения &lt;code&gt;NEWPHASE&lt;/code&gt; и &lt;code&gt;OLDPHASE&lt;/code&gt; являются строками, о &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; сообщает $ {^ GLOBAL_PHASE} .</target>
        </trans-unit>
        <trans-unit id="0786ec1507cde8f738cd5528e03a2b67d40c8c91" translate="yes" xml:space="preserve">
          <source>Traces the entry of any subroutine. Note that all of the variables refer to the subroutine that is being invoked; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">Отслеживает вход любой подпрограммы.Обратите внимание,что все переменные ссылаются на вызываемую подпрограмму;в настоящее время нет возможности получить информацию о подпрограмме</target>
        </trans-unit>
        <trans-unit id="9f47af59eb569759ff1e8a42a52da14fba8b1705" translate="yes" xml:space="preserve">
          <source>Traces the execution of each opcode in the Perl runloop. This probe is fired before the opcode is executed. When the Perl debugger is enabled, the DTrace probe is fired</source>
          <target state="translated">Отслеживает выполнение каждого опкода в цикле Perl.Этот зонд выстреливает перед выполнением опкода.Когда отладчик Perl включен,запускается зонд DTrace.</target>
        </trans-unit>
        <trans-unit id="bbb01fbe6bfaaec090a44633982fb31ae18d0d39" translate="yes" xml:space="preserve">
          <source>Traces the exit of any subroutine. Note that all of the variables refer to the subroutine that is returning; there is currently no way to get ahold of any information about the subroutine's</source>
          <target state="translated">Отслеживает выход любой подпрограммы.Обратите внимание,что все переменные относятся к возвращающейся подпрограмме;в настоящее время нет возможности получить какую-либо информацию о подпрограмме</target>
        </trans-unit>
        <trans-unit id="469260e080c9b35d7ee5b388f5235f91978c75b9" translate="yes" xml:space="preserve">
          <source>Traditional form:</source>
          <target state="translated">Традиционная форма:</target>
        </trans-unit>
        <trans-unit id="0ad67b0aa9abbb10a0d4b2ca67f1c4ff5d61a0ed" translate="yes" xml:space="preserve">
          <source>Traditionally END blocks have been executed at the end of the perl_run. This causes problems for applications that never call perl_run. Since perl 5.7.2 you can specify &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; to get the new behaviour. This also enables the running of END blocks if the perl_parse fails and &lt;code&gt;perl_destruct&lt;/code&gt; will return the exit value.</source>
          <target state="translated">Традиционно блоки END выполняются в конце perl_run. Это вызывает проблемы для приложений, которые никогда не вызывают perl_run. Начиная с Perl 5.7.2, вы можете указать &lt;code&gt;PL_exit_flags |= PERL_EXIT_DESTRUCT_END&lt;/code&gt; чтобы получить новое поведение. Это также позволяет запускать блоки END в случае сбоя &lt;code&gt;perl_destruct&lt;/code&gt; и perl_destruct вернет значение выхода.</target>
        </trans-unit>
        <trans-unit id="0f62d4679a2de6656186513ec5b0145dfd0852c8" translate="yes" xml:space="preserve">
          <source>Traditionally in Perl, any use of any of the three variables &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; (or their &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; equivalents) anywhere in the code, caused all subsequent successful pattern matches to make a copy of the matched string, in case the code might subsequently access one of those variables. This imposed a considerable performance penalty across the whole program, so generally the use of these variables has been discouraged.</source>
          <target state="translated">Традиционно в Perl, любое использование любого из трех переменных &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; или &lt;code&gt;$'&lt;/code&gt; (или их &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; English&lt;/code&gt; эквивалентов) в коде, вызванной все последующие успешные модели матчи , чтобы сделать копию совпавшей строки, в случае , код может впоследствии получить доступ к одной из этих переменных. Это привело к значительному снижению производительности всей программы, поэтому, как правило, использование этих переменных не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="edc1e4ae8cd5bdd4ef52be4cd619be47a1e80306" translate="yes" xml:space="preserve">
          <source>Traditionally the result is a string of 13 bytes: two first bytes of the salt, followed by 11 bytes from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt;, and only the first eight bytes of PLAINTEXT mattered. But alternative hashing schemes (like MD5), higher level security schemes (like C2), and implementations on non-Unix platforms may produce different strings.</source>
          <target state="translated">Обычно результатом является строка из 13 байтов: два первых байта соли, за которыми следуют 11 байтов из набора &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; , и только первые восемь байтов PLAINTEXT имеют значение. Но альтернативные схемы хеширования (например, MD5), схемы безопасности более высокого уровня (например, C2) и реализации на платформах, отличных от Unix, могут создавать разные строки.</target>
        </trans-unit>
        <trans-unit id="366ba2d0971221ce62e3e700bb5e4027a597313b" translate="yes" xml:space="preserve">
          <source>Traditionally, Perl has captured the value of the variable at that point and turned the subroutine into a constant eligible for inlining. In those cases where the variable can be modified elsewhere, this breaks the behavior of closures, in which the subroutine captures the variable itself, rather than its value, so future changes to the variable are reflected in the subroutine's return value.</source>
          <target state="translated">Традиционно,Perl захватил значение переменной в этот момент и превратил подпрограмму в константу,имеющую право на встраивание.В тех случаях,когда переменная может быть изменена в другом месте,это нарушает поведение замыкания,при котором подпрограмма захватывает саму переменную,а не ее значение,поэтому будущие изменения переменной отражаются в возвращаемом подпрограммой значении.</target>
        </trans-unit>
        <trans-unit id="77c289ba4e5a8332a82b92e0a687ee8832b65763" translate="yes" xml:space="preserve">
          <source>Traditionally, the Perl function &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; rounds to 0 (see &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;), and so for floating-point-like types one should follow the same semantic.</source>
          <target state="translated">Традиционно функция Perl &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; округляется до 0 (см. &lt;a href=&quot;functions/int&quot;&gt;Int&lt;/a&gt; ), поэтому для типов с плавающей запятой следует придерживаться той же семантики.</target>
        </trans-unit>
        <trans-unit id="b2c93accaaddf881f0426884fd5fb319c6e78ef4" translate="yes" xml:space="preserve">
          <source>Traditionally, the definition of an inside-out class contains a bare block inside which a number of lexical hashes are declared and the basic accessor methods defined, usually through &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; . Further methods may be defined outside this block. There has to be a DESTROY method and, for thread support, a CLONE method.</source>
          <target state="translated">Традиционно определение вывернутого наизнанку класса содержит пустой блок, внутри которого объявляется ряд лексических хэшей и определяются основные методы доступа, обычно через &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; . Другие методы могут быть определены вне этого блока. Должен быть метод DESTROY, а для поддержки потоков - метод CLONE.</target>
        </trans-unit>
        <trans-unit id="56e30fa719825fef87897a9b73f8c643d6e27859" translate="yes" xml:space="preserve">
          <source>Traditionally, typemaps needed to be written to a separate file, conventionally called &lt;code&gt;typemap&lt;/code&gt; in a CPAN distribution. With ExtUtils::ParseXS (the XS compiler) version 3.12 or better which comes with perl 5.16, typemaps can also be embedded directly into XS code using a HERE-doc like syntax:</source>
          <target state="translated">Традиционно карты типов нужно было записывать в отдельный файл, &lt;code&gt;typemap&lt;/code&gt; в распространении CPAN обычно называется картой типов . С ExtUtils :: ParseXS (компилятор XS) версии 3.12 или выше, который поставляется с perl 5.16, карты типов также могут быть встроены непосредственно в код XS с использованием синтаксиса, подобного HERE-doc:</target>
        </trans-unit>
        <trans-unit id="b116d15c8d0f591aea30acc14d32c8151254d15b" translate="yes" xml:space="preserve">
          <source>Transfer file in ASCII. CRLF translation will be done if required</source>
          <target state="translated">Файл передачи в ASCII.При необходимости будет выполнен перевод CRLF</target>
        </trans-unit>
        <trans-unit id="19b93b66a9a164099cf4c3e60d4b5f7a2c5a7780" translate="yes" xml:space="preserve">
          <source>Transfer file in binary mode. No transformation will be done.</source>
          <target state="translated">Передача файла в двоичном режиме.Преобразование не будет выполнено.</target>
        </trans-unit>
        <trans-unit id="71b54b146f4723aa8db4c8d0ffb0816f4aee31ad" translate="yes" xml:space="preserve">
          <source>Transforms the current application into a PM application and back. The argument true means that a real message loop is going to be served. OS2::MorphPM() returns the PM message queue handle as an integer.</source>
          <target state="translated">Преобразует текущее приложение в PM-приложение и обратно.Аргумент true означает,что будет обслуживаться реальный цикл сообщений.OS2::MorphPM()возвращает хэндл очереди сообщений PM как целое число.</target>
        </trans-unit>
        <trans-unit id="3ab5267ee01682b79d53eef55a6ec4c6169897d2" translate="yes" xml:space="preserve">
          <source>Translate logical name DCL$PATH as a searchlist, rather than trying to &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; string value of &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; .</source>
          <target state="translated">Преобразуйте логическое имя DCL $ PATH как список поиска вместо того, чтобы пытаться &lt;code&gt;&lt;a href=&quot;../../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; строковое значение &lt;code&gt;$ENV{'PATH'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4df3684f8e1af9f3d36ff43ec1a39944ea62d252" translate="yes" xml:space="preserve">
          <source>Translates a Windows path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">Переводит путь Windows на соответствующий путь cygwin с учетом текущих точек монтирования.Со вторым ненулевым аргументом возвращает абсолютный путь.Двухбайтовые символы не будут переведены.</target>
        </trans-unit>
        <trans-unit id="43c8972cdf7cbd4964f60ea0553934fab0c0bfe0" translate="yes" xml:space="preserve">
          <source>Translates a Windows pid to the corresponding cygwin pid (if any).</source>
          <target state="translated">Переводит Windows pid на соответствующий cygwin pid (если есть).</target>
        </trans-unit>
        <trans-unit id="582d5dcb01cd3d8be49a7bc9c562cc61d6d3a8c7" translate="yes" xml:space="preserve">
          <source>Translates a cygwin path to the corresponding cygwin path respecting the current mount points. With a second non-null argument returns an absolute path. Double-byte characters will not be translated.</source>
          <target state="translated">Переводит путь cygwin на соответствующий путь cygwin относительно текущих точек крепления.Со вторым ненулевым аргументом возвращает абсолютный путь.Двухбайтовые символы не будут переведены.</target>
        </trans-unit>
        <trans-unit id="d0b7e8b1f9fa64e7df02a610ac8f751cbf79794f" translate="yes" xml:space="preserve">
          <source>Translates a cygwin pid to the corresponding Windows pid (which may or may not be the same).</source>
          <target state="translated">Переводит cygwin pid на соответствующий Windows pid (который может быть или не быть одинаковым).</target>
        </trans-unit>
        <trans-unit id="3cb9f5d38a91da3cb24f8ddc9ee0b78bc3316e7d" translate="yes" xml:space="preserve">
          <source>Translates the template as before except that a directory name is specified.</source>
          <target state="translated">Переводит шаблон,как и раньше,за исключением того,что указано имя каталога.</target>
        </trans-unit>
        <trans-unit id="0e0c59b2d3a94d773b16fba8c10f9e6b9a4c8d83" translate="yes" xml:space="preserve">
          <source>Translators are available for converting Pod to various formats like plain text, HTML, man pages, and more.</source>
          <target state="translated">Доступны переводчики для преобразования Pod в различные форматы,такие как обычный текст,HTML,man-страницы и многое другое.</target>
        </trans-unit>
        <trans-unit id="3d02c52d09a4e30f9d862205070306d13e0fd4bf" translate="yes" xml:space="preserve">
          <source>Translators may request clarification of the situation in which a particular phrase is found. For example, in English we are entirely happy saying &quot;</source>
          <target state="translated">Переводчики могут попросить разъяснить ситуацию,в которой встречается та или иная фраза.Например,на английском языке мы с удовольствием скажем:&quot;</target>
        </trans-unit>
        <trans-unit id="7cec7716cf837c5d26e64202c8e48b66fd1ee111" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#NNN; where NNN is the decimal Unicode code point.</source>
          <target state="translated">Транслитерировать символы, отсутствующие в кодировке, в &amp;amp; # NNN; где NNN - десятичная кодовая точка Unicode.</target>
        </trans-unit>
        <trans-unit id="4a944de5b3bc5a013582ea0515548fdc64b85e91" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to &amp;amp;#xHHHH; where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">Транслитерировать символы, отсутствующие в кодировке, в &amp;amp; # xHHHH; где HHHH - шестнадцатеричный код Unicode.</target>
        </trans-unit>
        <trans-unit id="7531ab4c38b927cd6bd26046089b6f931f4b9669" translate="yes" xml:space="preserve">
          <source>Transliterate characters missing in encoding to \x{HHHH} where HHHH is the hexadecimal Unicode code point.</source>
          <target state="translated">Перевести символы,отсутствующие в кодировке,на \x{HHHH},где HHHH-шестнадцатеричная точка кода в уникоде.</target>
        </trans-unit>
        <trans-unit id="778ddecb6dcc9c5eac19efad6822ed838d8cfd37" translate="yes" xml:space="preserve">
          <source>Transliterates all occurrences of the characters found in the search list with the corresponding character in the replacement list. It returns the number of characters replaced or deleted. If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; string is transliterated.</source>
          <target state="translated">Транслитерирует все вхождения символов, найденных в списке поиска, с соответствующим символом в списке замены. Возвращает количество замененных или удаленных символов. Если строка не указана с помощью оператора &lt;code&gt;=~&lt;/code&gt; или &lt;code&gt;!~&lt;/code&gt; , Строка &lt;code&gt;$_&lt;/code&gt; транслитерируется.</target>
        </trans-unit>
        <trans-unit id="420a5e0771ab4a0b9e610c4b35eccba70828962b" translate="yes" xml:space="preserve">
          <source>Transparent BigInteger support for Perl</source>
          <target state="translated">Прозрачная поддержка Perl BigInteger</target>
        </trans-unit>
        <trans-unit id="7267fd5dd0f2d5cad0d4fdfbc6f406231fbc74c7" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber support for Perl</source>
          <target state="translated">Прозрачная поддержка Perl BigNumber</target>
        </trans-unit>
        <trans-unit id="d53f15081d775673dd122d267a0fda505ffa50fe" translate="yes" xml:space="preserve">
          <source>Transparent BigNumber/BigRational support for Perl</source>
          <target state="translated">Прозрачный Большой Номер/Большая Рациональная поддержка для Perl</target>
        </trans-unit>
        <trans-unit id="1320fa0059bd04032c977af604f63823046e2bca" translate="yes" xml:space="preserve">
          <source>Trappable errors may be trapped using the eval operator. See &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In almost all cases, warnings may be selectively disabled or promoted to fatal errors using the &lt;code&gt;warnings&lt;/code&gt; pragma. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Обнаруживаемые ошибки могут быть отловлены с помощью оператора eval. См. &lt;a href=&quot;functions/eval&quot;&gt;Eval&lt;/a&gt; . Почти во всех случаях предупреждения могут быть выборочно отключены или преобразованы в фатальные ошибки с помощью &lt;code&gt;warnings&lt;/code&gt; warnings. См. &lt;a href=&quot;warnings&quot;&gt;Предупреждения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f10d4d7cb6294c3306a64ba2969b74200be2428" translate="yes" xml:space="preserve">
          <source>Traverse a directory tree.</source>
          <target state="translated">Пройдитесь по дереву каталогов.</target>
        </trans-unit>
        <trans-unit id="b2a99160c9547d1ab75aaa55623e70b1b8573818" translate="yes" xml:space="preserve">
          <source>Treat string as multiple lines. That is, change &quot;^&quot; and &quot;$&quot; from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string.</source>
          <target state="translated">Обращайтесь к строке как к нескольким строкам.То есть,измените &quot;^&quot; и &quot;$&quot; с соответствия начала первой строки и конца последней строки на соответствие начала и конца каждой строки внутри строки.</target>
        </trans-unit>
        <trans-unit id="93fa15e2fd4bd3f0707530f7f374f8fd00c44547" translate="yes" xml:space="preserve">
          <source>Treat string as single line. That is, change &quot;.&quot; to match any character whatsoever, even a newline, which normally it would not match.</source>
          <target state="translated">Обращайтесь со строкой как с одиночной строкой.То есть заменить &quot;...&quot; на любой символ,даже на новую строку,которая обычно не совпадает.</target>
        </trans-unit>
        <trans-unit id="369a3fe575602256c74f237530b2066156aadc25" translate="yes" xml:space="preserve">
          <source>Treats ARRAY as a stack by appending the values of LIST to the end of ARRAY. The length of ARRAY increases by the length of LIST. Has the same effect as</source>
          <target state="translated">Рассматривает ARRAY как стек,добавляя значения СПИСКА в конце ARRAY.Длина АРРЕЯ увеличивается на длину СПИСКА.Имеет тот же эффект,что и</target>
        </trans-unit>
        <trans-unit id="4c2b22d2044144acb2e177299ffb0546b35d1302" translate="yes" xml:space="preserve">
          <source>Treats the complete zip file/buffer as a single compressed data stream. When reading in multi-stream mode each member of the zip file/buffer will be uncompressed in turn until the end of the file/buffer is encountered.</source>
          <target state="translated">Рассматривает полный zip-файл/буфер как единый сжатый поток данных.При чтении в многопоточном режиме каждый член zip-файла/буфера будет поочередно распаковываться до тех пор,пока не встретится конец файла/буфера.</target>
        </trans-unit>
        <trans-unit id="9170df3df869288dce7be7560494463cb05b5488" translate="yes" xml:space="preserve">
          <source>Treats the return value of the code block as the condition.</source>
          <target state="translated">В качестве условия рассматривает возвращаемое значение кодового блока.</target>
        </trans-unit>
        <trans-unit id="076fbc2c1d84c79c360a6aaf693ed414200277af" translate="yes" xml:space="preserve">
          <source>Treats the string in EXPR as a bit vector made up of elements of width BITS and returns the value of the element specified by OFFSET as an unsigned integer. BITS therefore specifies the number of bits that are reserved for each element in the bit vector. This must be a power of two from 1 to 32 (or 64, if your platform supports that).</source>
          <target state="translated">Рассматривает строку в EXPR как битовый вектор,состоящий из элементов ширины BITS и возвращает значение элемента,заданного OFFSET как беззнаковое целое число.Следовательно,BITS определяет количество бит,которое зарезервировано для каждого элемента в битовом векторе.Это должно быть два значения от 1 до 32 (или 64,если ваша платформа это поддерживает).</target>
        </trans-unit>
        <trans-unit id="74c726e22e1ef4f0ff5d0f342fa4b671a8d7e3e6" translate="yes" xml:space="preserve">
          <source>Tree Contents</source>
          <target state="translated">Содержание дерева</target>
        </trans-unit>
        <trans-unit id="bc924ad99a31c83efb674a21a76798fdb63e8535" translate="yes" xml:space="preserve">
          <source>Tries to &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the given $module or $file. If it loads successfully, the test will pass. Otherwise it fails and displays the load error.</source>
          <target state="translated">Пытается &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; указанный $ module или $ file. Если он загружается успешно, тест будет пройден. В противном случае он не работает и отображает ошибку загрузки.</target>
        </trans-unit>
        <trans-unit id="82437a05f154f78a4ae190392aa21b46338d0c97" translate="yes" xml:space="preserve">
          <source>Tries to uses &lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; &amp;amp; &lt;a href=&quot;../../../io/select&quot;&gt;IO::Select&lt;/a&gt; to communicate with the spawned process if they are available. Falls back onto &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Пытается использовать &lt;a href=&quot;../../../ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt; и &lt;a href=&quot;../../../io/select&quot;&gt;IO :: Select&lt;/a&gt; для связи с порожденным процессом, если они доступны. Падение обратно на &lt;code&gt;&lt;a href=&quot;../../../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0328d99f96d6b6cb2e5370be4979de91fb2ea44" translate="yes" xml:space="preserve">
          <source>Triggered by a delete from %^H, records the key to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">Вызывается удалением из% ^ H, записывает ключ в &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce25e5857867e6310e792d455213353087781834" translate="yes" xml:space="preserve">
          <source>Triggered by a store to %^H, records the key/value pair to &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; . It is assumed that hints aren't storing anything that would need a deep copy. Maybe we should warn if we find a reference.</source>
          <target state="translated">Запускается хранилищем в% ^ H, записывает пару ключ / значение в &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; . Предполагается, что подсказки не хранят ничего, что требовало бы глубокой копии. Может стоит предупредить, если найдем ссылку.</target>
        </trans-unit>
        <trans-unit id="5e62fd5a7239de339d5bd00c0d3006bd6b133b17" translate="yes" xml:space="preserve">
          <source>Triggered by clearing %^H, resets &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</source>
          <target state="translated">Вызывается очисткой% ^ H, сбрасывает &lt;code&gt;PL_compiling.cop_hints_hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">тригонометрические функции</target>
        </trans-unit>
        <trans-unit id="ce550b5479caa5cd0ed1b0d59ad15c9773c7bcdb" translate="yes" xml:space="preserve">
          <source>Trilogy, &lt;code&gt;In the beginning the
Universe was created. This has made a lot of people very angry and
been widely regarded as a bad move&lt;/code&gt; . Their mistake was not of this magnitude so let's forgive them.</source>
          <target state="translated">Трилогия, &lt;code&gt;In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move&lt;/code&gt; . Их ошибка не была такой большой, так что давайте простим их.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="28e5d7df36d1a6dde25f3c09a31821344957a89c" translate="yes" xml:space="preserve">
          <source>Troubleshooting these Examples</source>
          <target state="translated">Устранение неполадок в этих примерах</target>
        </trans-unit>
        <trans-unit id="95a9fcae6cc7c433c5ecb181677d9e65f088ed3c" translate="yes" xml:space="preserve">
          <source>Tru64 5.1 documentation on syslog, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</source>
          <target state="translated">Документация Tru64 5.1 по системному журналу, &lt;a href=&quot;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&quot;&gt;http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V51_HTML/MAN/MAN3/0193____.HTM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9109071ad135094f2373ecd2b94d8dc48e87efa6" translate="yes" xml:space="preserve">
          <source>True if an external</source>
          <target state="translated">Верно,если внешний</target>
        </trans-unit>
        <trans-unit id="f3a74362a5094d39f2b42a3da4ab4b28a9691928" translate="yes" xml:space="preserve">
          <source>True if on an OS where qx operator (or backticks) can redirect &lt;code&gt;STDERR&lt;/code&gt; onto &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">Истинно, если в ОС, где оператор qx (или обратные кавычки) может перенаправить &lt;code&gt;STDERR&lt;/code&gt; на &lt;code&gt;STDOUT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52369ee8420cce3f1adcdcc979064876449bf33b" translate="yes" xml:space="preserve">
          <source>True if the socket is currently positioned at the urgent data mark, false otherwise.</source>
          <target state="translated">Верно,если сокет в данный момент расположен на отметке срочных данных,неверно.</target>
        </trans-unit>
        <trans-unit id="263df4a03022b2922b4599d5befe15e4f094944e" translate="yes" xml:space="preserve">
          <source>True if the source has meta data.</source>
          <target state="translated">Верно,если у источника есть мета-данные.</target>
        </trans-unit>
        <trans-unit id="001c945275af8c53e929fc8bb52b9331e9fa2beb" translate="yes" xml:space="preserve">
          <source>True if this op will be the return value of an lvalue subroutine</source>
          <target state="translated">Верно,если эта опция будет возвращающим значение подпрограмм lvalue</target>
        </trans-unit>
        <trans-unit id="a225ab817ea7fa5d168aaeda6fa091c3d9bf26a1" translate="yes" xml:space="preserve">
          <source>True is returned if the file name begins with &lt;code&gt;drive_letter:&lt;/code&gt; , and if not, File::Spec::Unix file_name_is_absolute() is called.</source>
          <target state="translated">Истина возвращается, если имя файла начинается с &lt;code&gt;drive_letter:&lt;/code&gt; , а если нет, вызывается File :: Spec :: Unix имя_файла_is_absolute ().</target>
        </trans-unit>
        <trans-unit id="714a51854b847f734d4ad3e61a135b245522aeae" translate="yes" xml:space="preserve">
          <source>True while the most recent result was a TODO. Becomes true before the TODO result is returned and stays true until just before the next non- TODO test is returned.</source>
          <target state="translated">Верно,в то время как самый последний результат был TODO.Становится верным до того,как будет возвращен результат TODO,и остается верным до тех пор,пока не будет возвращен следующий тест,не являющийся TODO.</target>
        </trans-unit>
        <trans-unit id="1aceee4ee4f49927d115b3fc82be6c512d7c286c" translate="yes" xml:space="preserve">
          <source>True/false results are never tainted.</source>
          <target state="translated">Правдивые/неправдивые результаты никогда не запятнаются.</target>
        </trans-unit>
        <trans-unit id="f8dc96e0b59ea3e8174d5b669fb89eb4295305d3" translate="yes" xml:space="preserve">
          <source>Truncate $x to an integer value.</source>
          <target state="translated">Усечь $x до целочисленного значения.</target>
        </trans-unit>
        <trans-unit id="11625b03167a879105d56ac5232340fe7c1e8727" translate="yes" xml:space="preserve">
          <source>Truncate file suggested by open mode.</source>
          <target state="translated">Усеченный файл,предложенный открытым режимом.</target>
        </trans-unit>
        <trans-unit id="69983876ff90a7fef773e08a772b817cd9bc808d" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">Обрезает файл, открытый в FILEHANDLE или названный с помощью EXPR, до указанной длины. Вызывает исключение, если усечение не реализовано в вашей системе. В случае успеха возвращает true, в случае ошибки - &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6b7268dfdb3e49fbc8b9714eadb8dee9d853cfb" translate="yes" xml:space="preserve">
          <source>Truncates the file opened on FILEHANDLE, or named by EXPR, to the specified length. Raises an exception if truncate isn't implemented on your system. Returns true if successful, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">Обрезает файл, открытый в FILEHANDLE или названный с помощью EXPR, до указанной длины. Вызывает исключение, если усечение не реализовано в вашей системе. В случае успеха возвращает true, в случае ошибки - &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2975c0f92fcae4101065548cc1a5e6bfa7744574" translate="yes" xml:space="preserve">
          <source>Truncation to same-or-shorter lengths only. (VOS)</source>
          <target state="translated">Укорачивание только на одну или более короткую длину.(VOS)</target>
        </trans-unit>
        <trans-unit id="07fcbd4e35869ee7c3769699235ad97c3caf7ea4" translate="yes" xml:space="preserve">
          <source>Truth and Falsehood</source>
          <target state="translated">Истина и Ложь</target>
        </trans-unit>
        <trans-unit id="0ea36a88c9652f7de32e4b8cdc539660f9c8bb67" translate="yes" xml:space="preserve">
          <source>Truth. (&lt;code&gt;PL_sv_yes&lt;/code&gt; ) The value is not needed (and ignored).</source>
          <target state="translated">Правда. ( &lt;code&gt;PL_sv_yes&lt;/code&gt; ) Значение не требуется (и игнорируется).</target>
        </trans-unit>
        <trans-unit id="820aa128934b824418f5ca61678f5828e0a9f3f1" translate="yes" xml:space="preserve">
          <source>Try 'which ld' and 'which ld' (or try 'ar --version' and 'ld --version', which work only for the GNU tools, and will announce themselves to be such), and adjust your PATH so that you are consistently using either the native tools or the GNU tools. After fixing your PATH, you should do 'make distclean' and start all the way from running the Configure since you may have quite a confused situation.</source>
          <target state="translated">Попробуйте &quot;какой ld&quot; и &quot;какой ld&quot; (или попробуйте &quot;ar --version&quot; и &quot;ld --version&quot;,которые работают только для инструментов GNU,и объявят о себе таковыми)и скорректируйте свою PATH так,чтобы вы последовательно пользовались либо родными инструментами,либо инструментами GNU.После исправления своей PATH вам следует сделать 'make distclean' и начать все с запуска команды Configure,поскольку у вас может возникнуть довольно запутанная ситуация.</target>
        </trans-unit>
        <trans-unit id="dfec8d0f349c3c42fb9d1815573a589ac82ef522" translate="yes" xml:space="preserve">
          <source>Try and match a closing delimiter bracket. If the bracket was the same species as the last opening bracket, return the substring to that point. If the bracket was mismatched, return an error.</source>
          <target state="translated">Попробуйте подобрать закрывающуюся разделительную скобку.Если скобка была того же вида,что и последняя открывающаяся скобка,верните подложку в эту точку.Если скобка была неправильно подобрана,верните ошибку.</target>
        </trans-unit>
        <trans-unit id="3534e8ec8243f82da173a0a961f29a6061ccc5a4" translate="yes" xml:space="preserve">
          <source>Try every conceivable way to get hostname</source>
          <target state="translated">Попробуйте все возможные способы получить имя хозяина.</target>
        </trans-unit>
        <trans-unit id="dfea66ec3b5d472c8a85f9f4143d2c2a2932e7a3" translate="yes" xml:space="preserve">
          <source>Try hard not to exceed 79-columns</source>
          <target state="translated">Старайтесь не превышать 79 столбцов</target>
        </trans-unit>
        <trans-unit id="71156f6966e318bbb69b3350da865612c3413590" translate="yes" xml:space="preserve">
          <source>Try keeping around the seekpointer and go there, like this:</source>
          <target state="translated">Попробуй держаться рядом с Искателем и иди туда,вот так:</target>
        </trans-unit>
        <trans-unit id="5ab49ef558819708ac26895c52750c3610705d02" translate="yes" xml:space="preserve">
          <source>Try not to launch headlong into developing your module without spending some time thinking first. A little forethought may save you a vast amount of effort later on.</source>
          <target state="translated">Постарайтесь не запускать без промедления разработку вашего модуля,не тратя время на размышления.Немного продуманности может сэкономить вам огромное количество усилий в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="1a2b567df2700cceb3e59d9f8a3eb3ca3092a77c" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;net/ftp&quot;&gt;Net::FTP&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP::Client&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; modules (available from CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; will also help for emulating the telnet protocol, but &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net::Telnet&lt;/a&gt; is quite probably easier to use.</source>
          <target state="translated">Попробуйте модули &lt;a href=&quot;net/ftp&quot;&gt;Net :: FTP&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/TCP::Client&quot;&gt;TCP :: Client&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet&lt;/a&gt; (доступны на CPAN). &lt;a href=&quot;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&quot;&gt;http://www.cpan.org/scripts/netstuff/telnet.emul.shar&lt;/a&gt; также поможет имитировать протокол telnet, но &lt;a href=&quot;http://search.cpan.org/perldoc/Net::Telnet&quot;&gt;Net :: Telnet,&lt;/a&gt; вероятно, проще в использовании.</target>
        </trans-unit>
        <trans-unit id="87f2df3af873276d11f18dcdfa6067907516ef82" translate="yes" xml:space="preserve">
          <source>Try the first alternative in the first group 'abd'.</source>
          <target state="translated">Попробуйте первую альтернативу в первой группе 'абд'.</target>
        </trans-unit>
        <trans-unit id="8fdc9fd893f9837a30290ddcdb863de474cd49f7" translate="yes" xml:space="preserve">
          <source>Try the native, UDP socket then UNIX domain socket mechanisms:</source>
          <target state="translated">Попробуйте &quot;родной&quot;,UDP сокет,а затем механизмы UNIX доменных сокетов:</target>
        </trans-unit>
        <trans-unit id="6a75e271162bdc3d061e3493d3ce114d627fc256" translate="yes" xml:space="preserve">
          <source>Try the resources in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;.</source>
          <target state="translated">Попробуйте ресурсы в &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aacef041b76d57895de9d7f5cee32482707bd3b3" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; to individual blocks of code that need less strictness.</source>
          <target state="translated">Попробуйте &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; (или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict qw(...);&lt;/code&gt; ). Помните , что вы не можете добавить &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; strict qw(...);&lt;/code&gt; к отдельным блокам кода, требующим меньшей строгости.</target>
        </trans-unit>
        <trans-unit id="dbe02bedd5bb36eab5b4bbe32b7d4940cf95d2ec" translate="yes" xml:space="preserve">
          <source>Try to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). Remember that you can add &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; to individual blocks of code that need less warnings.</source>
          <target state="translated">Попробуйте &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; (или &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings qw(...);&lt;/code&gt; ). Помните , что вы не можете добавить &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings qw(...);&lt;/code&gt; к отдельным блокам кода, которые требуют меньше предупреждений.</target>
        </trans-unit>
        <trans-unit id="1a50d23e31ca789a858a654feff08b918836c974" translate="yes" xml:space="preserve">
          <source>Try to color output. See &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;new in TAP::Formatter::Base&lt;/a&gt;.</source>
          <target state="translated">Попробуй цветной вывод. См. &lt;a href=&quot;../tap/formatter/base#new&quot;&gt;Новое в TAP :: Formatter :: Base&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e97a54a5e20ef4c3c124d4963b017c39c1dad7b" translate="yes" xml:space="preserve">
          <source>Try to design the new module to be easy to extend and reuse.</source>
          <target state="translated">Попробуйте сконструировать новый модуль,чтобы его было легко расширять и повторно использовать.</target>
        </trans-unit>
        <trans-unit id="220ea4d529b6fa37d1fa97bbb19f2fed77ce5e5b" translate="yes" xml:space="preserve">
          <source>Try to determine name of extension being built. We begin with the name of the current directory. Since VMS filenames are case-insensitive, however, we look for a</source>
          <target state="translated">Попробуйте определить название строящегося расширения.Начнем с имени текущей директории.Поскольку имена файлов VMS не чувствительны к регистру,тем не менее,мы ищем</target>
        </trans-unit>
        <trans-unit id="909a91fc6d3b48263691b246eef6c09eb4ec3bfc" translate="yes" xml:space="preserve">
          <source>Try to determine the width of the screen and the bold and underline sequences for the terminal from termcap, and use that information in formatting the output. Output will be wrapped at two columns less than the width of your terminal device. Using this option requires that your system have a termcap file somewhere where Term::Cap can find it and requires that your system support termios. With this option, the output of &lt;b&gt;pod2text&lt;/b&gt; will contain terminal control sequences for your current terminal type.</source>
          <target state="translated">Попытайтесь определить ширину экрана и последовательности жирного и подчеркнутого шрифтов для терминала с помощью termcap и используйте эту информацию при форматировании вывода. Вывод будет заключен в два столбца меньше ширины вашего оконечного устройства. Использование этой опции требует, чтобы ваша система имела файл termcap где-нибудь, где Term :: Cap может его найти, и требует, чтобы ваша система поддерживала termios. С этой опцией вывод &lt;b&gt;pod2text&lt;/b&gt; будет содержать последовательности управления терминалом для вашего текущего типа терминала.</target>
        </trans-unit>
        <trans-unit id="08f15a05901602892a511e670ab4aa0307df4226" translate="yes" xml:space="preserve">
          <source>Try to document your code and use Pod formatting in a consistent way. Here are commonly expected conventions:</source>
          <target state="translated">Попробуйте задокументировать свой код и последовательно использовать форматирование Pod.Вот обычно ожидаемые конвенции:</target>
        </trans-unit>
        <trans-unit id="c88c728349f5a2409f402906caa2d933f74c0865" translate="yes" xml:space="preserve">
          <source>Try to match a quote or quotelike operator. If found, call &lt;code&gt;extract_quotelike&lt;/code&gt; to eat it. If &lt;code&gt;extract_quotelike&lt;/code&gt; fails, return the error it returned. Otherwise go back to step 1.</source>
          <target state="translated">Попробуйте сопоставить цитату или оператор цитаты. Если он найден, вызовите &lt;code&gt;extract_quotelike&lt;/code&gt; , чтобы съесть его. Если &lt;code&gt;extract_quotelike&lt;/code&gt; не работает, вернуть возвращенную ошибку. В противном случае вернитесь к шагу 1.</target>
        </trans-unit>
        <trans-unit id="fed009e07cf40a3bfaccb23b101b1df3951ecefd" translate="yes" xml:space="preserve">
          <source>Try to match an opening delimiter bracket. If found, call &lt;code&gt;extract_codeblock&lt;/code&gt; recursively to eat the embedded block. If the recursive call fails, return an error. Otherwise, go back to step 1.</source>
          <target state="translated">Попробуйте сопоставить открывающую скобку-ограничитель. Если найдено, рекурсивно вызовите &lt;code&gt;extract_codeblock&lt;/code&gt; , чтобы съесть встроенный блок. Если рекурсивный вызов завершился неудачно, верните ошибку. В противном случае вернитесь к шагу 1.</target>
        </trans-unit>
        <trans-unit id="1bf160ae95bc79040defdb4258d5fad8caa20a29" translate="yes" xml:space="preserve">
          <source>Try to obtain the latest version of the Windows SDK. Sometimes these packages contain a particular Windows OS version in their name, but actually work on other OS versions too. For example, the &quot;Windows Server 2003 R2 Platform SDK&quot; also runs on Windows XP SP2 and Windows 2000.</source>
          <target state="translated">Попробуйте получить последнюю версию Windows SDK.Иногда эти пакеты содержат определенную версию ОС Windows в своем названии,но на самом деле работают и на других версиях ОС.Например,&quot;Windows Server 2003 R2 Platform SDK&quot; также работает на Windows XP SP2 и Windows 2000.</target>
        </trans-unit>
        <trans-unit id="962ca701cc2570a663505435d963dc55f234f4d9" translate="yes" xml:space="preserve">
          <source>Trying to create a new child with a previous child still active (i.e., &lt;code&gt;finalize&lt;/code&gt; not called) will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">Попытка создать нового дочернего элемента с активным предыдущим дочерним элементом (т.е. &lt;code&gt;finalize&lt;/code&gt; не вызывается) приведет к &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c592184c4820418323672dd4337df40c4098b0" translate="yes" xml:space="preserve">
          <source>Trying to do too much</source>
          <target state="translated">Пытаюсь сделать слишком много</target>
        </trans-unit>
        <trans-unit id="44d272c0c6193575553012dfbe62f22573eeb82f" translate="yes" xml:space="preserve">
          <source>Trying to run a test when you have an open child will also &lt;code&gt;croak&lt;/code&gt; and cause the test suite to fail.</source>
          <target state="translated">Попытка запустить тест, когда у вас есть открытый ребенок, также будет &lt;code&gt;croak&lt;/code&gt; и вызывать сбой набора тестов.</target>
        </trans-unit>
        <trans-unit id="e1251ee8a07b3dea6c343e31961e5913e11f0ce3" translate="yes" xml:space="preserve">
          <source>Tune the internal settings for the deflate object &lt;code&gt;$d&lt;/code&gt; . This option is only available if you are running zlib 1.2.2.3 or better.</source>
          <target state="translated">Настройте внутренние параметры для объекта deflate &lt;code&gt;$d&lt;/code&gt; . Этот параметр доступен, только если вы используете zlib 1.2.2.3 или выше.</target>
        </trans-unit>
        <trans-unit id="008eee580921a65a5e935994d388ebe43c6df0cd" translate="yes" xml:space="preserve">
          <source>Tuning the way RESOLVE_SYMLINK will works</source>
          <target state="translated">Настройка того,как будет работать RESOLVE_SYMLINK</target>
        </trans-unit>
        <trans-unit id="f7db0bf3a9c02aa40e34f07d8431257fcf327327" translate="yes" xml:space="preserve">
          <source>Turn =head1 directives into links pointing to the top of the HTML file.</source>
          <target state="translated">Поверните директивы =head1 в ссылки,указывающие на вершину HTML-файла.</target>
        </trans-unit>
        <trans-unit id="33f87dc87ea378d835e56e5bfd248ea1a352c832" translate="yes" xml:space="preserve">
          <source>Turn Pod into XML</source>
          <target state="translated">Превратите Pod в XML</target>
        </trans-unit>
        <trans-unit id="8e7cc74dfcc71c13798fc4a8a0bda3cb164ed4c1" translate="yes" xml:space="preserve">
          <source>Turn Pod::Simple events into method calls</source>
          <target state="translated">Превратить Pod::Простые события в вызовы методов</target>
        </trans-unit>
        <trans-unit id="87a4a4a475f00352f77a10d3ec1fd9eee936c4ee" translate="yes" xml:space="preserve">
          <source>Turn off Apple tar's tendency to copy resource forks as &quot;._foo&quot; files.</source>
          <target state="translated">Выключите склонность Apple tar копировать запросы ресурсов как &quot;._foo&quot; файлы.</target>
        </trans-unit>
        <trans-unit id="48d8224908b27731eb611ee5800a332f08bd6efe" translate="yes" xml:space="preserve">
          <source>Turn on colour in Test::Builder::Tester</source>
          <target state="translated">Включить цвет в Тест::Строитель::Тестер</target>
        </trans-unit>
        <trans-unit id="3aaaf6cc176020f3991943f2032de33eccbdb645" translate="yes" xml:space="preserve">
          <source>Turn on debugging messages.</source>
          <target state="translated">Включите отладочные сообщения.</target>
        </trans-unit>
        <trans-unit id="c5afa3624933dbb94708b864157bd75149a4bc45" translate="yes" xml:space="preserve">
          <source>Turn on the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">Включите UTF-8 статус SV (данные не меняются,только флаг).Не использовать фривольно.</target>
        </trans-unit>
        <trans-unit id="9903e627171cb3011421fef7af4a686d6ebc3e08" translate="yes" xml:space="preserve">
          <source>Turn on/off printing of warnings. Repeating &lt;b&gt;-warnings&lt;/b&gt; increases the warning level, i.e. more warnings are printed. Currently increasing to level two causes flagging of unescaped &quot;&amp;lt;,&amp;gt;&quot; characters.</source>
          <target state="translated">Включение / выключение печати предупреждений. Повторение &lt;b&gt;предупреждений&lt;/b&gt; увеличивает уровень предупреждений, т. &lt;b&gt;Е. Печатается&lt;/b&gt; больше предупреждений. В настоящее время повышение до второго уровня вызывает пометку неэкранированных символов &amp;laquo;&amp;lt;,&amp;gt;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d7dd646019946f4186b2c9415767806d113e6794" translate="yes" xml:space="preserve">
          <source>Turn warnings on/off.</source>
          <target state="translated">Включить/выключить предупреждения.</target>
        </trans-unit>
        <trans-unit id="4c628137dd54154b5661d62a2c76528177ce2c0e" translate="yes" xml:space="preserve">
          <source>Turning on one of the character set flags with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; takes precedence over the &lt;code&gt;locale&lt;/code&gt; pragma and the 'unicode_strings' &lt;code&gt;feature&lt;/code&gt; , for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:</source>
          <target state="translated">Включение одного из наборов символов флагов с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; имеет приоритет над &lt;code&gt;locale&lt;/code&gt; прагму и &amp;laquo;unicode_strings&amp;raquo; &lt;code&gt;feature&lt;/code&gt; , для регулярных выражений. Отключение одного из этих флагов, когда он активен, возвращает к поведению, заданному любыми другими прагматами в области видимости. Например:</target>
        </trans-unit>
        <trans-unit id="1dac2f62695f453fd439059f0a117cf373d1f773" translate="yes" xml:space="preserve">
          <source>Turns every &lt;code&gt;head1&lt;/code&gt; heading into a link back to the top of the page. By default, no backlinks are generated.</source>
          <target state="translated">Превращает каждый заголовок &lt;code&gt;head1&lt;/code&gt; в ссылку обратно в верхнюю часть страницы. По умолчанию обратные ссылки не создаются.</target>
        </trans-unit>
        <trans-unit id="488b4a24fda23c677bfd758dfeda4e2b3e28ea5b" translate="yes" xml:space="preserve">
          <source>Turns on all &quot;extra&quot; debugging options.</source>
          <target state="translated">Включает все &quot;дополнительные&quot; опции отладки.</target>
        </trans-unit>
        <trans-unit id="8a6abc6af101e3e68b329eb351f149732ea8c3d9" translate="yes" xml:space="preserve">
          <source>Turns on all compile related debug options.</source>
          <target state="translated">Включает все связанные с компиляцией опции отладки.</target>
        </trans-unit>
        <trans-unit id="377f42734b94211c01fa848b2645c0c159ecedcd" translate="yes" xml:space="preserve">
          <source>Turns on all execute related debug options.</source>
          <target state="translated">Включает все связанные с исполнением опции отладки.</target>
        </trans-unit>
        <trans-unit id="cf78d64b4c15f8d89c3f09aea595a015508f3471" translate="yes" xml:space="preserve">
          <source>Turns on autoflush, print ARGS and then restores the autoflush status of the &lt;code&gt;IO::Handle&lt;/code&gt; object. Returns the return value from print.</source>
          <target state="translated">Включает автозапуск, печатает ARGS, а затем восстанавливает статус автозапуска объекта &lt;code&gt;IO::Handle&lt;/code&gt; . Возвращает возвращаемое значение из печати.</target>
        </trans-unit>
        <trans-unit id="2d1676fcc040bdf1deeab307eee1f9a1faa4d87a" translate="yes" xml:space="preserve">
          <source>Turns on debug output related to the process of parsing the pattern.</source>
          <target state="translated">Включает отладочный вывод,связанный с процессом парсинга шаблона.</target>
        </trans-unit>
        <trans-unit id="80ae89d796a9f5474c9cf55351133039b045499c" translate="yes" xml:space="preserve">
          <source>Turns on debugging</source>
          <target state="translated">Включает отладку</target>
        </trans-unit>
        <trans-unit id="0b71618ab3c580ced56e12be5afa8ca78d10b841" translate="yes" xml:space="preserve">
          <source>Turns on debugging of the main matching loop.</source>
          <target state="translated">Включает отладку основного цикла совмещения.</target>
        </trans-unit>
        <trans-unit id="0d12b512bcc17c858f7f78847cab2c7f6461efd3" translate="yes" xml:space="preserve">
          <source>Turns on the magical status of an SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">Включает магический статус СВ. См. &lt;code&gt;sv_magic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5ed69f1e400ca234d376650a653b6521d5c1651" translate="yes" xml:space="preserve">
          <source>Turns the @metadata_pairs into YAML.</source>
          <target state="translated">Превращает пары @metadata_pairs в YAML.</target>
        </trans-unit>
        <trans-unit id="606c2af8d67a4d7dc7224ecdbb198b95627a3d18" translate="yes" xml:space="preserve">
          <source>Tutorial on making a new module.</source>
          <target state="translated">Учебное пособие по созданию нового модуля.</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="4106aa6fe38782986e71b6df351f9eed9adc1100" translate="yes" xml:space="preserve">
          <source>Tutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main documentation. If you really want to write these, include them as sub-documents such as &lt;code&gt;My::Module::Tutorial&lt;/code&gt; or &lt;code&gt;My::Module::FAQ&lt;/code&gt; and provide a link in the SEE ALSO section of the main documentation.</source>
          <target state="translated">Учебники, документация для конечных пользователей, исследовательские работы, ответы на часто задаваемые вопросы и т. Д. Не подходят для основной документации модуля. Если вы действительно хотите их написать, включите их в качестве дополнительных документов, таких как &lt;code&gt;My::Module::Tutorial&lt;/code&gt; или &lt;code&gt;My::Module::FAQ&lt;/code&gt; и дайте ссылку в разделе СМОТРИ ТАКЖЕ основной документации.</target>
        </trans-unit>
        <trans-unit id="d4f6fcebc83fe08414440f2690253120c9bf99c3" translate="yes" xml:space="preserve">
          <source>Tweak the style of B::Deparse's output. The letters should follow directly after the 's', with no space or punctuation. The following options are available:</source>
          <target state="translated">Тонизируйте стиль Б::Депарса.Буквы должны следовать непосредственно за 's',без пробелов и знаков препинания.Доступны следующие варианты:</target>
        </trans-unit>
        <trans-unit id="8b77b783948e5ce8fbd237831d47a3e2aa25c8cf" translate="yes" xml:space="preserve">
          <source>Two additional extensions by Andreas Kaiser, &lt;code&gt;OS2::UPM&lt;/code&gt; , and &lt;code&gt;OS2::FTP&lt;/code&gt; , are included into &lt;code&gt;ILYAZ&lt;/code&gt; directory, mirrored on CPAN. Other OS/2-related extensions are available too.</source>
          <target state="translated">Два дополнительных расширения от Андреаса Кайзера, &lt;code&gt;OS2::UPM&lt;/code&gt; и &lt;code&gt;OS2::FTP&lt;/code&gt; , включены в каталог &lt;code&gt;ILYAZ&lt;/code&gt; , отраженный на CPAN. Также доступны другие расширения, связанные с OS / 2.</target>
        </trans-unit>
        <trans-unit id="225de66ed8612f5eaedcbe3517b9b8a030dd1dfb" translate="yes" xml:space="preserve">
          <source>Two additional fields &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; contain array references which provide per-bucket count of free and used chunks. Two other fields &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; contain array references which provide the information about the allocated size and usable size of chunks in each bucket. Again, see &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Using $ENV{PERL_DEBUG_MSTATS} in perldebguts&lt;/a&gt; for details.</source>
          <target state="translated">Два дополнительных полей &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;used&lt;/code&gt; содержат ссылки на массивы , которые обеспечивают за счет ведре-свободных и используемых кусков. Два других поля &lt;code&gt;mem_size&lt;/code&gt; , &lt;code&gt;available_size&lt;/code&gt; содержат ссылки на массивы, которые предоставляют информацию о выделенном размере и используемом размере блоков в каждой корзине. Опять же, подробности см. В разделе &lt;a href=&quot;../perldebguts#Using-%24ENV%7bPERL_DEBUG_MSTATS%7d&quot;&gt;Использование $ ENV {PERL_DEBUG_MSTATS} в perldebguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="959e1dbe5c03b6bf54bd2c7c42f5c06de670abcf" translate="yes" xml:space="preserve">
          <source>Two arrays smartmatch if each element in the first array smartmatches (that is, is &quot;in&quot;) the corresponding element in the second array, recursively.</source>
          <target state="translated">Два массива smartmatch,если каждый элемент в первом массиве smartmatches (то есть &quot;in&quot;)соответствующий элемент во втором массиве,рекурсивно.</target>
        </trans-unit>
        <trans-unit id="ef9d289482c44cedd928e08a539e06da234c1ea2" translate="yes" xml:space="preserve">
          <source>Two directories</source>
          <target state="translated">Два справочника</target>
        </trans-unit>
        <trans-unit id="4932b4ce84c4a3c76d97d8ddc1677ad9583f731a" translate="yes" xml:space="preserve">
          <source>Two exceptions are fseek() and ftell(). 32-bit applications should use fseeko(3C) and ftello(3C). These will get automatically mapped to fseeko64() and ftello64().</source>
          <target state="translated">Двумя исключениями являются fseek()и ftell().32-битные приложения должны использовать fseeko(3C)и ftello(3C).Они будут автоматически отображены на fseeko64()и ftello64().</target>
        </trans-unit>
        <trans-unit id="59e6099a51676c8b357d47058d648615908e9535" translate="yes" xml:space="preserve">
          <source>Two functions are provided by</source>
          <target state="translated">Две функции обеспечиваются</target>
        </trans-unit>
        <trans-unit id="362495d14b1f3b1a8e9077a2b6d2d038307cf755" translate="yes" xml:space="preserve">
          <source>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt; .</source>
          <target state="translated">Предусмотрены две функции для выполнения сжатия / распаковки в памяти потоков данных RFC 1950. Их называют &lt;code&gt;compress&lt;/code&gt; и &lt;code&gt;uncompress&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1fae0daa00d9847553b4c2af0e0bfcf15f43ad2" translate="yes" xml:space="preserve">
          <source>Two hexadecimal numbers separated by horizontal whitespace (space or tabular characters) denoting a range of code points to include.</source>
          <target state="translated">Два шестнадцатеричных числа,разделенных горизонтальными пробелами (пробелами или табличными символами),обозначающими диапазон кодовых точек для включения.</target>
        </trans-unit>
        <trans-unit id="fc8d21d4a74e99aae1a5fc40b83d3fff90123b23" translate="yes" xml:space="preserve">
          <source>Two nested identical markup commands have been found. Generally this does not make sense.</source>
          <target state="translated">Найдены две вложенные идентичные команды разметки.Обычно это не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="5e76b53030582383f7d551a5e77c668c449dbb3b" translate="yes" xml:space="preserve">
          <source>Two of the codes specified by the standard (XTS which is reserved for testing purposes and XXX which is for transactions where no currency is involved) are omitted.</source>
          <target state="translated">Два из кодов,указанных в стандарте (XTS,который зарезервирован для тестовых целей,и XXX,который предназначен для операций,в которых отсутствует валюта),опущены.</target>
        </trans-unit>
        <trans-unit id="a1d006aec19b5d26f771c4cb3b1aa7d14cd4a562" translate="yes" xml:space="preserve">
          <source>Two or more suspects remain</source>
          <target state="translated">Двое или более подозреваемых остаются</target>
        </trans-unit>
        <trans-unit id="069f392f8b693bf3f912fa721edb551769786910" translate="yes" xml:space="preserve">
          <source>Two other &quot;encapsulation&quot; macros are the PERL_GLOBAL_STRUCT and PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the former turns on MULTIPLICITY.) The PERL_GLOBAL_STRUCT causes all the internal variables of Perl to be wrapped inside a single global struct, struct perl_vars, accessible as (globals) &amp;amp;PL_Vars or PL_VarsPtr or the function Perl_GetVars(). The PERL_GLOBAL_STRUCT_PRIVATE goes one step further, there is still a single struct (allocated in main() either from heap or from stack) but there are no global data symbols pointing to it. In either case the global struct should be initialized as the very first thing in main() using Perl_init_global_struct() and correspondingly tear it down after perl_free() using Perl_free_global_struct(), please see</source>
          <target state="translated">Два других макроса &amp;laquo;инкапсуляции&amp;raquo; - это PERL_GLOBAL_STRUCT и PERL_GLOBAL_STRUCT_PRIVATE (последний включает первый, а первый включает MULTIPLICITY.) PERL_GLOBAL_STRUCT заставляет все внутренние переменные Perl заключаться в одну глобальную структуру, доступную как struct perl_vars (глобальные переменные) &amp;amp; PL_Vars или PL_VarsPtr или функция Perl_GetVars (). PERL_GLOBAL_STRUCT_PRIVATE идет еще дальше, все еще есть одна структура (выделенная в main () либо из кучи, либо из стека), но нет глобальных символов данных, указывающих на нее. В любом случае глобальная структура должна быть инициализирована в первую очередь в main () с помощью Perl_init_global_struct () и, соответственно, разорвать ее после perl_free () с помощью Perl_free_global_struct (), см.</target>
        </trans-unit>
        <trans-unit id="9e4d897b2c15b7e4e4ca9fbaec8aab25f6b14e93" translate="yes" xml:space="preserve">
          <source>Two possible uses (besides ignoring the property) come to mind. A singleton class could be implemented this using the generic object. If necessary, an &lt;code&gt;init()&lt;/code&gt; method could die or ignore calls with actual objects (references), so only the generic object will ever exist.</source>
          <target state="translated">На ум приходят два возможных использования (помимо игнорирования свойства). Одноэлементный класс может быть реализован с помощью универсального объекта. При необходимости метод &lt;code&gt;init()&lt;/code&gt; может умереть или игнорировать вызовы с реальными объектами (ссылками), поэтому когда-либо будет существовать только общий объект.</target>
        </trans-unit>
        <trans-unit id="70abff015732d480e204353f739476e826fe7dc6" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">Две потенциально неочевидные, но традиционные семантики &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; заключаются в том, что он бесконечно ждет, пока блокировка не будет предоставлена, и что его блокировки являются &lt;b&gt;просто рекомендательными&lt;/b&gt; . Такие дискреционные блокировки более гибкие, но предлагают меньше гарантий. Это означает, что программы, которые также не используют &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; , могут изменять файлы, заблокированные с помощью &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;../perlport&quot;&gt;Perlport&lt;/a&gt;, документацию по вашему порту и локальные страницы руководства по вашей системе. Если вы пишете переносимые программы, лучше всего предполагать традиционное поведение. (Но если вы этого не сделаете, вы, как всегда, должны чувствовать себя совершенно свободно, чтобы писать для особенностей вашей собственной системы (иногда называемых &amp;laquo;функциями&amp;raquo;). Рабская приверженность проблемам переносимости не должна мешать вам выполнять свою работу.)</target>
        </trans-unit>
        <trans-unit id="3c9f59ec6423987c8c2fe5d0858f160205e3fc59" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; semantics are that it waits indefinitely until the lock is granted, and that its locks are &lt;b&gt;merely advisory&lt;/b&gt;. Such discretionary locks are more flexible, but offer fewer guarantees. This means that programs that do not also use &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; may modify files locked with &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, your port's specific documentation, and your system-specific local manpages for details. It's best to assume traditional behavior if you're writing portable programs. (But if you're not, you should as always feel perfectly free to write for your own system's idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn't get in the way of your getting your job done.)</source>
          <target state="translated">Две потенциально неочевидные, но традиционные семантики &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; заключаются в том, что он бесконечно ждет, пока блокировка не будет предоставлена, и что его блокировки являются &lt;b&gt;просто рекомендательными&lt;/b&gt; . Такие дискреционные блокировки более гибкие, но предлагают меньше гарантий. Это означает, что программы, которые также не используют &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; , могут изменять файлы, заблокированные с помощью &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt;, документацию по вашему порту и локальные страницы руководства по вашей системе. Если вы пишете переносимые программы, лучше всего предполагать традиционное поведение. (Но если вы этого не сделаете, вы, как всегда, должны чувствовать себя совершенно свободно, чтобы писать для особенностей вашей собственной системы (иногда называемых &amp;laquo;функциями&amp;raquo;). Рабская приверженность проблемам переносимости не должна мешать вам выполнять свою работу.)</target>
        </trans-unit>
        <trans-unit id="53df84b423920613232d12c96d5eb675ef01a9db" translate="yes" xml:space="preserve">
          <source>Two potentially non-obvious but traditional flock semantics are that it waits indefinitely until the lock is granted, and that its locks are</source>
          <target state="translated">Две потенциально неочевидные,но традиционные семантики стаи заключаются в том,что она ждет неопределенно долго,пока замок не будет выдан,и что ее замки являются</target>
        </trans-unit>
        <trans-unit id="778a62aee9043b393531476babc83e7e729243c9" translate="yes" xml:space="preserve">
          <source>Two special locales are worth particular mention: &quot;C&quot; and &quot;POSIX&quot;. Currently these are effectively the same locale: the difference is mainly that the first one is defined by the C standard, the second by the POSIX standard. They define the &lt;b&gt;default locale&lt;/b&gt; in which every program starts in the absence of locale information in its environment. (The</source>
          <target state="translated">Особо следует упомянуть две специальные локали: &amp;laquo;C&amp;raquo; и &amp;laquo;POSIX&amp;raquo;. В настоящее время это фактически один и тот же языковой стандарт: разница в основном в том, что первый определяется стандартом C, а второй - стандартом POSIX. Они определяют &lt;b&gt;языковой стандарт&lt;/b&gt; по &lt;b&gt;умолчанию,&lt;/b&gt; в котором каждая программа запускается при отсутствии информации о языковом стандарте в ее среде. (The</target>
        </trans-unit>
        <trans-unit id="001ed180b265179aa35dbaf576484db20b8f3115" translate="yes" xml:space="preserve">
          <source>Two special marker lines will bracket debugging code, like this:</source>
          <target state="translated">Две специальные строки маркеров будут заключены в скобки для отладочного кода,вот так:</target>
        </trans-unit>
        <trans-unit id="fc4c89a57e0f51cea54d0e2e158fcc3083bc5fa2" translate="yes" xml:space="preserve">
          <source>Two threads both access &lt;code&gt;$x&lt;/code&gt; . Each thread can potentially be interrupted at any point, or be executed in any order. At the end, &lt;code&gt;$x&lt;/code&gt; could be 3 or 4, and both &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$z&lt;/code&gt; could be 2 or 3.</source>
          <target state="translated">Два потока обращаются к &lt;code&gt;$x&lt;/code&gt; . Каждый поток потенциально может быть прерван в любой момент или выполнен в любом порядке. В конце, &lt;code&gt;$x&lt;/code&gt; может быть 3 или 4, а &lt;code&gt;$y&lt;/code&gt; и &lt;code&gt;$z&lt;/code&gt; могут быть 2 или 3.</target>
        </trans-unit>
        <trans-unit id="a040608578e9e9c915007f47fc1e5b14ac218a6c" translate="yes" xml:space="preserve">
          <source>Two ways. One is to build the module normally...</source>
          <target state="translated">Два способа.Первый-построить модуль нормально...</target>
        </trans-unit>
        <trans-unit id="aed361ca9a7b196027b5db9a2f0828216a331df8" translate="yes" xml:space="preserve">
          <source>Two's complement (bitwise not). This is equivalent to</source>
          <target state="translated">Двойное дополнение (не в точку).Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="639570380139caf69541c926ba46013c3318dc90" translate="yes" xml:space="preserve">
          <source>Two-face References</source>
          <target state="translated">Двуличные ссылки</target>
        </trans-unit>
        <trans-unit id="ae90b2c9e3f2f4b661468b3ddaef859dd9bff8a2" translate="yes" xml:space="preserve">
          <source>Two-face Scalars</source>
          <target state="translated">Двухликие скаляры</target>
        </trans-unit>
        <trans-unit id="47708aacd7aae4d98506843c2ea25848ad8c524c" translate="yes" xml:space="preserve">
          <source>Tying Arrays</source>
          <target state="translated">Массивы обвязки</target>
        </trans-unit>
        <trans-unit id="29fe0e127980eab253dd9684cf8924d1439a9c07" translate="yes" xml:space="preserve">
          <source>Tying Arrays by Casey West &amp;lt;</source>
          <target state="translated">Связывание массивов Кейси Уэст &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cb864932b4ba6b40040bda147b28500825da685" translate="yes" xml:space="preserve">
          <source>Tying FileHandles</source>
          <target state="translated">Свечи для перевязки</target>
        </trans-unit>
        <trans-unit id="c44951e9133e5d8875fa8e60d17eb7ca4e5ec846" translate="yes" xml:space="preserve">
          <source>Tying Hashes</source>
          <target state="translated">Связывание Хэшеса</target>
        </trans-unit>
        <trans-unit id="c124692dc36c13d6ea9eefe451091514b3053308" translate="yes" xml:space="preserve">
          <source>Tying Scalars</source>
          <target state="translated">Скаляры для обвязки</target>
        </trans-unit>
        <trans-unit id="dd441f6c670bdd175a4a06606b3ade32864a5013" translate="yes" xml:space="preserve">
          <source>Tying to an already-opened filehandle</source>
          <target state="translated">Привязка к уже открытой ручке файла</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="622fe690390119c9b2836b529615b923c08f64da" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake install&quot; (or &quot;nmake install&quot;). This will put the newly built perl and the libraries under whatever &lt;code&gt;INST_TOP&lt;/code&gt; points to in the Makefile. It will also install the pod documentation under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; and HTML versions of the same under &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; .</source>
          <target state="translated">Введите &amp;laquo;dmake install&amp;raquo; (или &amp;laquo;nmake install&amp;raquo;). Это поместит недавно созданный perl и библиотеки под все, на что указывает &lt;code&gt;INST_TOP&lt;/code&gt; в Makefile. Он также установит документацию модуля под &lt;code&gt;$INST_TOP\$INST_VER\lib\pod&lt;/code&gt; и его HTML-версии под &lt;code&gt;$INST_TOP\$INST_VER\lib\pod\html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48996994efbc36adb9197c655f8807f921339671" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake test&quot; (or &quot;nmake test&quot;). This will run most of the tests from the testsuite (many tests will be skipped).</source>
          <target state="translated">Введите &quot;dmake test&quot; (или &quot;nmake test&quot;).При этом будет запущено большинство тестов из набора (многие тесты будут пропущены).</target>
        </trans-unit>
        <trans-unit id="e707f55e50471f8dc7a11eb61a45491656e65c20" translate="yes" xml:space="preserve">
          <source>Type &quot;dmake&quot; (or &quot;nmake&quot; if you are using that make).</source>
          <target state="translated">Введите &quot;dmake&quot; (или &quot;nmake&quot;,если вы используете эту марку).</target>
        </trans-unit>
        <trans-unit id="817cc5b4f0c413465ec1e98078f923e58ba436f8" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;perl -v&lt;/code&gt; at the command line to find out.</source>
          <target state="translated">Введите &lt;code&gt;perl -v&lt;/code&gt; в командной строке, чтобы узнать.</target>
        </trans-unit>
        <trans-unit id="470a91ba8a41cc959ff1b12a936c2603408f2a81" translate="yes" xml:space="preserve">
          <source>Type flag for I/O objects. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Флаг типа для объектов ввода-вывода. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="115e0f5825d2a5e2437586f43a3052a4bc413be2" translate="yes" xml:space="preserve">
          <source>Type flag for arrays. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Флаг типа для массивов. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5424ebb415da653ce11cbaa80efe5caaa204e71c" translate="yes" xml:space="preserve">
          <source>Type flag for formats. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Флаг типа для форматов. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11f3d189f9118d5a6a717d6df4d8bfc5dd5c80fb" translate="yes" xml:space="preserve">
          <source>Type flag for hashes. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Флаг типа для хэшей. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7697ce082ff72de4bd1f6e232aec1e708c3e949b" translate="yes" xml:space="preserve">
          <source>Type flag for regular expressions. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Флаг типа для регулярных выражений. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8842ec0ce8ceed5f394b670f4b4d43838af8af85" translate="yes" xml:space="preserve">
          <source>Type flag for scalars. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Флаг типа для скаляров. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba6e0906867866e6b4c76c1aa73ce8fb1ddab2a4" translate="yes" xml:space="preserve">
          <source>Type flag for subroutines. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Типовой флаг для подпрограмм. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d98af6202cdf505f81d6de89907f306acd604bb" translate="yes" xml:space="preserve">
          <source>Type flag for typeglobs. See &lt;a href=&quot;#svtype&quot;&gt;svtype&lt;/a&gt;.</source>
          <target state="translated">Флаг типа для typeglobs. См. &lt;a href=&quot;#svtype&quot;&gt;Svtype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e47d64cc94d0acfc0cdbf0b2c9dd711351e0f339" translate="yes" xml:space="preserve">
          <source>Type of first matching node.</source>
          <target state="translated">Тип первого совпадающего узла.</target>
        </trans-unit>
        <trans-unit id="82be69629fdb03e428153252cb628a3089333b85" translate="yes" xml:space="preserve">
          <source>Type-casting operator.</source>
          <target state="translated">Оператор литья по типу.</target>
        </trans-unit>
        <trans-unit id="3c6b62766a1a668fd13ee2f54c72526e46bdd675" translate="yes" xml:space="preserve">
          <source>Type-specific attribute handlers</source>
          <target state="translated">Обработчики атрибутов конкретного типа</target>
        </trans-unit>
        <trans-unit id="ee3fb11d05c90c37311491cf33008925b13b487f" translate="yes" xml:space="preserve">
          <source>Type:</source>
          <target state="translated">Type:</target>
        </trans-unit>
        <trans-unit id="dacaa1ce7373acde846ee256ee267058f226c8cb" translate="yes" xml:space="preserve">
          <source>Typed lexicals</source>
          <target state="translated">Типичные лексики</target>
        </trans-unit>
        <trans-unit id="35c58169317903405f89e446350d7099fc17650c" translate="yes" xml:space="preserve">
          <source>Typeglobs and Filehandles</source>
          <target state="translated">Типеглобусы и файловые ручки</target>
        </trans-unit>
        <trans-unit id="c93af0f29f506026f9bce190608810109efe41de" translate="yes" xml:space="preserve">
          <source>Typeglobs are also a way to create a local filehandle using the local() operator. These last until their block is exited, but may be passed back. For example:</source>
          <target state="translated">Типеглобы-это также способ создать локальную файловую оболочку с помощью оператора local().Они действуют до тех пор,пока их блок не будет закрыт,но может быть передан обратно.Например:</target>
        </trans-unit>
        <trans-unit id="7c854e2c86ed5ebd580cf024fab8796f99c1a0f9" translate="yes" xml:space="preserve">
          <source>Types of Nodes</source>
          <target state="translated">Типы узлов</target>
        </trans-unit>
        <trans-unit id="54a79ea7d31cf3e80acf5e2ca6b3eef126289136" translate="yes" xml:space="preserve">
          <source>Typical frequently used settings:</source>
          <target state="translated">Типичные часто используемые настройки:</target>
        </trans-unit>
        <trans-unit id="eeee45f0582f2da790f6df23acb83c5b9ac37e5b" translate="yes" xml:space="preserve">
          <source>Typical usage is just:</source>
          <target state="translated">Типичное использование-это просто:</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">Типичное использование:</target>
        </trans-unit>
        <trans-unit id="f0a20c31caa817cfde9a5903c8d1331d2cc5ddae" translate="yes" xml:space="preserve">
          <source>Typical use is to do range checks on &lt;code&gt;uv&lt;/code&gt; before casting:</source>
          <target state="translated">Типичное использование - проверка диапазона &lt;code&gt;uv&lt;/code&gt; перед литьем:</target>
        </trans-unit>
        <trans-unit id="0f7c555ca8af58d8be6641bce4c54e1f92594d54" translate="yes" xml:space="preserve">
          <source>Typical use of AutoSplit in the perl MakeMaker utility is via the command-line with:</source>
          <target state="translated">Типичное использование AutoSplit в утилите perl MakeMaker осуществляется через командную строку с:</target>
        </trans-unit>
        <trans-unit id="2eb42fd8be2849b836904fd8c0478452015d5021" translate="yes" xml:space="preserve">
          <source>Typically displayed in italics. Example: &quot;&lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</source>
          <target state="translated">Обычно отображается курсивом. Пример: &quot; &lt;code&gt;F&amp;lt;.cshrc&amp;gt;&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="0b14febd4050c6e9e7fff1ec1a1e04a32b2411b9" translate="yes" xml:space="preserve">
          <source>Typically render into NFD on input and NFC on output. Using NFKC or NFKD functions improves recall on searches, assuming you've already done to the same text to be searched. Note that this is about much more than just pre- combined compatibility glyphs; it also reorders marks according to their canonical combining classes and weeds out singletons.</source>
          <target state="translated">Обычно рендеринг в NFD на входе и NFC на выходе.Использование функций NFKC или NFKD улучшает отзыв при поиске,предполагая,что вы уже сделали с тем же самым текстом для поиска.Обратите внимание,что речь идет не только о предварительно комбинированных глифах совместимости,но и о переупорядочивании меток в соответствии с их каноническими комбинационными классами и сортировке синглонов.</target>
        </trans-unit>
        <trans-unit id="b5c564109e8a3afa5be0b031d855d9ae4aa0bbb3" translate="yes" xml:space="preserve">
          <source>Typically this is used to emulate &lt;code&gt;#!&lt;/code&gt; startup on platforms that don't support &lt;code&gt;#!&lt;/code&gt; . It's also convenient when debugging a script that uses &lt;code&gt;#!&lt;/code&gt; , and is thus normally found by the shell's $PATH search mechanism.</source>
          <target state="translated">Обычно это используется для имитации &lt;code&gt;#!&lt;/code&gt; запуск на платформах, не поддерживающих &lt;code&gt;#!&lt;/code&gt; . Это также удобно при отладке сценария, в котором используется &lt;code&gt;#!&lt;/code&gt; , и поэтому обычно обнаруживается механизмом поиска $ PATH оболочки.</target>
        </trans-unit>
        <trans-unit id="687058d347f26c3b9dcf0508ed2f5930b5b6fa48" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be returned via &lt;code&gt;$out&lt;/code&gt; . &lt;code&gt;$status&lt;/code&gt; will have a value &lt;code&gt;Z_OK&lt;/code&gt; if successful.</source>
          <target state="translated">Обычно используется для завершения дефляции. Любой ожидающий результат будет возвращен через &lt;code&gt;$out&lt;/code&gt; . &lt;code&gt;$status&lt;/code&gt; случае успеха $ status будет иметь значение &lt;code&gt;Z_OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01a46f6fee05faa753caaabc6b43de594c708bd4" translate="yes" xml:space="preserve">
          <source>Typically used to finish the deflation. Any pending output will be written to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">Обычно используется для завершения дефляции. Любой ожидающий вывод будет записан в &lt;code&gt;$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6622b7497b5ad854ceef3d9e6b7f39de4b5a746f" translate="yes" xml:space="preserve">
          <source>Typically will call &lt;code&gt;Fill&lt;/code&gt; and manipulate pointers (possibly via the API). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; may be suitable for derived classes which provide &quot;fast gets&quot; methods.</source>
          <target state="translated">Обычно вызывает &lt;code&gt;Fill&lt;/code&gt; и манипулирует указателями (возможно, через API). &lt;code&gt;PerlIOBuf_read()&lt;/code&gt; может быть подходящим для производных классов, которые предоставляют методы &amp;laquo;быстрого получения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="eb1290094db39111daed12026731de41d874265c" translate="yes" xml:space="preserve">
          <source>Typically you only need to set this if you are using nonstandard prefixes and want some or all of them to have the same semantics as '--' does under normal circumstances.</source>
          <target state="translated">Обычно вам нужно установить это только в том случае,если вы используете нестандартные префиксы и хотите,чтобы некоторые или все из них имели ту же семантику,что и '--' при обычных обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="bbb5689bb894bcd45bb2427b7ffbb2ba5d9ac28a" translate="yes" xml:space="preserve">
          <source>Typically you use the &lt;code&gt;\G&lt;/code&gt; anchor with the &lt;code&gt;c&lt;/code&gt; flag when you want to try a different match if one fails, such as in a tokenizer. Jeffrey Friedl offers this example which works in 5.004 or later.</source>
          <target state="translated">Обычно вы используете привязку &lt;code&gt;\G&lt;/code&gt; с флагом &lt;code&gt;c&lt;/code&gt; , когда хотите попробовать другое совпадение в случае сбоя, например, в токенизаторе. Джеффри Фридл предлагает этот пример, который работает в версии 5.004 или более поздней.</target>
        </trans-unit>
        <trans-unit id="291f2d298dd4e6053c773023592956eee5655566" translate="yes" xml:space="preserve">
          <source>Typically, Perl tests are run through this. However, anything which spits out TAP is fine. You can use this argument to specify the name of the program (and optional switches) to run your tests with:</source>
          <target state="translated">Обычно тесты на Perl проходят через это.Однако все,что выплёвывает TAP,в порядке.Вы можете использовать этот аргумент,чтобы указать имя программы (и необязательных переключателей)для запуска тестов:</target>
        </trans-unit>
        <trans-unit id="bc1a3db1817e4391406ea8e4c10b938d812a2baf" translate="yes" xml:space="preserve">
          <source>Typically, a C compiler allocates 12 bytes to a &lt;code&gt;gappy_t&lt;/code&gt; variable, but requires only 8 bytes for a &lt;code&gt;dense_t&lt;/code&gt; . After investigating this further, we can draw memory maps, showing where the extra 4 bytes are hidden:</source>
          <target state="translated">Обычно компилятор C выделяет 12 байтов переменной &lt;code&gt;gappy_t&lt;/code&gt; , но требует только 8 байтов для &lt;code&gt;dense_t&lt;/code&gt; . После дальнейшего исследования мы можем нарисовать карты памяти, показывающие, где спрятаны лишние 4 байта:</target>
        </trans-unit>
        <trans-unit id="83c91d2712bb90187ca081aa74ad37d202d5e800" translate="yes" xml:space="preserve">
          <source>Typically, however, things are the other way around: the tieable class expects its arguments as a flattened list, so the attribute looks like:</source>
          <target state="translated">Обычно,однако,все происходит наоборот:связанный класс ожидает своих аргументов в виде сплющенного списка,так что атрибут выглядит как будто:</target>
        </trans-unit>
        <trans-unit id="a2dcf9e9fce909e6d70f7fd2b928940489e6fad5" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d off&quot; or &quot;buildtype d&quot; at the command prompt causes the buildtype to be set to Debug type with D1 flag set.</source>
          <target state="translated">При вводе &quot;buildtype d off&quot; или &quot;buildtype d&quot; в командной строке тип сборки устанавливается в тип Debug с установленным флагом D1.</target>
        </trans-unit>
        <trans-unit id="b2c7510e598f94047792f2e34322c55a1d654ee0" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype d on&quot; at the command prompt causes the buildtype to be set to Debug type with D2 flag set.</source>
          <target state="translated">Нажатие кнопки &quot;buildtype d on&quot; в командной строке приводит к тому,что тип сборки устанавливается в тип Debug с установленным флагом D2.</target>
        </trans-unit>
        <trans-unit id="6127511edf886df0417540a81474ffb3800e60b7" translate="yes" xml:space="preserve">
          <source>Typing &quot;buildtype r&quot; at the command prompt sets it to Release Build type.</source>
          <target state="translated">При вводе типа &quot;buildtype r&quot; в командной строке он становится типом Release Build.</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="70ae2f8ea36eac22765cdf44837146969d083d4c" translate="yes" xml:space="preserve">
          <source>U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">U/WIN специфический подкласс ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="3a333ea8bebfa50b73219f11f7bf0ebbb8c9a863" translate="yes" xml:space="preserve">
          <source>UCA recommends that out-of-range values should not be ignored for security reasons. Say, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; should not be equal to &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . However, &lt;code&gt;U+FFFD&lt;/code&gt; is wrongly mapped to a variable collation element in DUCET for Unicode 6.0.0 to 6.2.0, that means out-of-range values will be ignored when &lt;code&gt;variable&lt;/code&gt; isn't &lt;code&gt;Non-ignorable&lt;/code&gt; .</source>
          <target state="translated">УЦА рекомендует не игнорировать значения, выходящие за пределы допустимого диапазона, по соображениям безопасности. Скажем, &lt;code&gt;&quot;pe\x{110000}rl&quot;&lt;/code&gt; не должно быть равно &lt;code&gt;&quot;perl&quot;&lt;/code&gt; . Однако &lt;code&gt;U+FFFD&lt;/code&gt; неправильно сопоставлен с элементом сопоставления переменных в DUCET для Unicode 6.0.0&amp;ndash;6.2.0, это означает, что значения вне диапазона будут игнорироваться, если &lt;code&gt;variable&lt;/code&gt; не является &lt;code&gt;Non-ignorable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206177d23e4d5ec0abfb5c6b0df396d679742e7c" translate="yes" xml:space="preserve">
          <source>UCS-2 is a fixed-length encoding with each character taking 16 bits. It &lt;b&gt;does not&lt;/b&gt; support</source>
          <target state="translated">UCS-2 - это кодировка фиксированной длины, в которой каждый символ занимает 16 бит. Он &lt;b&gt;не&lt;/b&gt; поддерживает</target>
        </trans-unit>
        <trans-unit id="daeba9311089266fcf0acd6d54c9e56ca13a992e" translate="yes" xml:space="preserve">
          <source>UCS-2, UCS-4</source>
          <target state="translated">UCS-2,UCS-4</target>
        </trans-unit>
        <trans-unit id="a392dc8e430c846ca90f8e40c79fda571eef8daf" translate="yes" xml:space="preserve">
          <source>UDP datagrams are</source>
          <target state="translated">датаграммы UDP</target>
        </trans-unit>
        <trans-unit id="0b1ddbe7e9085079ee7967600cb1889fd0b548d1" translate="yes" xml:space="preserve">
          <source>UDP: Message Passing</source>
          <target state="translated">UDP:Передача сообщений</target>
        </trans-unit>
        <trans-unit id="74ff590c1dac1161eec0fbaa8b7d8b3a98fff4d5" translate="yes" xml:space="preserve">
          <source>UNICODE AND SIDE EFFECTS</source>
          <target state="translated">УНИКОД И ПОБОЧНЫЕ ЭФФЕКТЫ</target>
        </trans-unit>
        <trans-unit id="0f9d971f52bdd7a74ebeb786ec5143de4c2935d5" translate="yes" xml:space="preserve">
          <source>UNICODE IN OLDER PERLS</source>
          <target state="translated">ЮНИКОД В СТАРЫХ ПЕРЛАХ</target>
        </trans-unit>
        <trans-unit id="94c5e5979031dbec3b6f240558b2bfaa36f46791" translate="yes" xml:space="preserve">
          <source>UNIMPLEMENTED</source>
          <target state="translated">UNIMPLEMENTED</target>
        </trans-unit>
        <trans-unit id="9392ee60535a3aa7bb3335f263044b78e27554ed" translate="yes" xml:space="preserve">
          <source>UNISTD</source>
          <target state="translated">UNISTD</target>
        </trans-unit>
        <trans-unit id="c070755890afd262edf57a1cfae99ffc017d2459" translate="yes" xml:space="preserve">
          <source>UNITCHECK</source>
          <target state="translated">UNITCHECK</target>
        </trans-unit>
        <trans-unit id="bc192a928ab3fe78a1c74cfa4d1027b44d52c868" translate="yes" xml:space="preserve">
          <source>UNIVERSAL</source>
          <target state="translated">UNIVERSAL</target>
        </trans-unit>
        <trans-unit id="1feda7e9d1b1a232e025eeb903dd53659f7b069c" translate="yes" xml:space="preserve">
          <source>UNIVERSAL - base class for ALL classes (blessed references)</source>
          <target state="translated">УНИВЕРСАЛ-базовый класс для ВСЕХ классов (благословенные ссылки)</target>
        </trans-unit>
        <trans-unit id="b23387c60700d885c584c4f2b25855ad58b48b48" translate="yes" xml:space="preserve">
          <source>UNIX and POSIX systems provide an abstract access() operating system call, which should be used to query the read, write, and execute rights. This function hides various distinct approaches in additional operating system specific security features, like Access Control Lists (ACLs)</source>
          <target state="translated">UNIX и POSIX системы обеспечивают абстрактный вызов Access()операционной системы,который должен использоваться для запроса прав на чтение,запись и выполнение.Эта функция скрывает различные различные подходы в дополнительных специфических для операционной системы функциях безопасности,таких как списки контроля доступа (Access Control Lists,ACL)</target>
        </trans-unit>
        <trans-unit id="fa0c8b9587852cbf0dc08f98bcecbaed53f1e1c0" translate="yes" xml:space="preserve">
          <source>UNIX domain sockets added by Sean Robinson &amp;lt;</source>
          <target state="translated">Доменные сокеты UNIX, добавленные Шоном Робинсоном &amp;lt;</target>
        </trans-unit>
        <trans-unit id="85db2499d39f4696e02fb26511b230add2c1b670" translate="yes" xml:space="preserve">
          <source>UNIX file permissions are based on sets of mode bits for {read,write,execute} for each {user,group,other}. By default Cygwin only tracks the Win32 read-only attribute represented as the UNIX file user write bit (files are always readable, files are executable if they have a</source>
          <target state="translated">Разрешения на использование UNIX-файлов основаны на наборах битов режима для {read,write,execute}для каждого {пользователя,группы,другого}.По умолчанию Cygwin отслеживает только Win32 атрибут read-only,представленный как бит записи пользователя UNIX файла (файлы всегда доступны для чтения,файлы являются исполняемыми,если они имеют бит</target>
        </trans-unit>
        <trans-unit id="5b8f1af6e17a29d4f20f56ec6d442f59acfc755d" translate="yes" xml:space="preserve">
          <source>UNSUPPORTED</source>
          <target state="translated">UNSUPPORTED</target>
        </trans-unit>
        <trans-unit id="40cccdd49a4b2f7980664d02999aa7b9e3022b50" translate="yes" xml:space="preserve">
          <source>UNTIE by Nick Ing-Simmons &amp;lt;</source>
          <target state="translated">UNTIE, Ник Инг-Симмонс &amp;lt;</target>
        </trans-unit>
        <trans-unit id="41304503568dff57766f35c33ebaca45f5e827b2" translate="yes" xml:space="preserve">
          <source>UNTIE this</source>
          <target state="translated">ВНИМАНИЕ:</target>
        </trans-unit>
        <trans-unit id="e3bb3273c3d27a35e7a79c09d285ae651319171c" translate="yes" xml:space="preserve">
          <source>UPGRADING</source>
          <target state="translated">UPGRADING</target>
        </trans-unit>
        <trans-unit id="a6b6b187a5dabe1711e09378ba034929cf5397f3" translate="yes" xml:space="preserve">
          <source>UPSTREAM indicates where patches should go. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; implies that this hasn't been discussed for the module at hand. &lt;code&gt;blead&lt;/code&gt; indicates that the copy of the module in the blead sources is to be considered canonical, &lt;code&gt;cpan&lt;/code&gt; means that the module on CPAN is to be patched first. &lt;code&gt;first-come&lt;/code&gt; means that blead can be patched freely if it is in sync with the latest release on CPAN.</source>
          <target state="translated">UPSTREAM указывает, куда должны идти патчи. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; подразумевает, что это не обсуждалось для данного модуля. &lt;code&gt;blead&lt;/code&gt; указывает, что копия модуля в источниках blead должна считаться канонической, &lt;code&gt;cpan&lt;/code&gt; означает, что модуль на CPAN должен быть исправлен первым. &lt;code&gt;first-come&lt;/code&gt; означает, что blead может быть исправлен свободно, если он синхронизирован с последним выпуском на CPAN.</target>
        </trans-unit>
        <trans-unit id="ba5e5280eb88749f4ed2bd7802c151c1f77cb3d7" translate="yes" xml:space="preserve">
          <source>URL decoding and encoding</source>
          <target state="translated">декодирование и кодирование URL-адресов</target>
        </trans-unit>
        <trans-unit id="61aff325c59f0125c7432101521fe8aef2d620f8" translate="yes" xml:space="preserve">
          <source>URLS</source>
          <target state="translated">URLS</target>
        </trans-unit>
        <trans-unit id="cf3bfa9a159c5a5ddc20da1eccd6bbddbdc037e4" translate="yes" xml:space="preserve">
          <source>USAGE</source>
          <target state="translated">USAGE</target>
        </trans-unit>
        <trans-unit id="3ca88d77aca2d323542d2e8f12b83151e0846c19" translate="yes" xml:space="preserve">
          <source>USE EXAMPLES</source>
          <target state="translated">ИСПОЛЬЗОВАНИЕ ЭКЗАМПЛЕЙ</target>
        </trans-unit>
        <trans-unit id="045095377d72052bacadc70846f65ba919bc72ee" translate="yes" xml:space="preserve">
          <source>USER METHODS</source>
          <target state="translated">МЕТОДЫ ПОЛЬЗОВАТЕЛЯ</target>
        </trans-unit>
        <trans-unit id="eff0e1414e1813c02157d57d3f325f32947a8413" translate="yes" xml:space="preserve">
          <source>USE_MULTI &amp;amp; USE_IMP_SYS defined and USE_ITHREADS not defined</source>
          <target state="translated">USE_MULTI и USE_IMP_SYS определены, а USE_ITHREADS не определены</target>
        </trans-unit>
        <trans-unit id="5e29b7b3b7536de15b46013805cfeb875c7a61d3" translate="yes" xml:space="preserve">
          <source>USE_MULTI, USE_ITHREADS &amp;amp; USE_IMP_SYS defined</source>
          <target state="translated">Определены USE_MULTI, USE_ITHREADS и USE_IMP_SYS</target>
        </trans-unit>
        <trans-unit id="227996d58fdfdee97220bd395f44c03336330289" translate="yes" xml:space="preserve">
          <source>USE_PERL_FLOCK</source>
          <target state="translated">USE_PERL_FLOCK</target>
        </trans-unit>
        <trans-unit id="d403f19c30d9dafcf5b6a7bb8666159dacf7697f" translate="yes" xml:space="preserve">
          <source>USING B::Deparse AS A MODULE</source>
          <target state="translated">ИСПОЛЬЗОВАНИЕ Б::Отправление как МОДУЛЬ</target>
        </trans-unit>
        <trans-unit id="2efa10816450d527d9e56d3271b7e34ea8c81a61" translate="yes" xml:space="preserve">
          <source>USING CONTEXT: THE DEBUG FILTER</source>
          <target state="translated">ИСПОЛЬЗУЯ КОНТЕКСТ:ФИЛЬТР ОТЛАДКИ</target>
        </trans-unit>
        <trans-unit id="5dc41a076ce2820059919cbbf35a7c867770cef6" translate="yes" xml:space="preserve">
          <source>USING FILTERS</source>
          <target state="translated">ФИЛЬТРЫ ДЛЯ ИСПОЛЬЗОВАНИЯ</target>
        </trans-unit>
        <trans-unit id="3d73074a3cddd39278e855bf130287734b3a28e3" translate="yes" xml:space="preserve">
          <source>USING LOCALES</source>
          <target state="translated">ИСПОЛЬЗОВАНИЕ МЕСТАКОВ</target>
        </trans-unit>
        <trans-unit id="e914e6326e1588417f534e760a668a311b7406cd" translate="yes" xml:space="preserve">
          <source>USING PERL IN OPENVOS</source>
          <target state="translated">ИСПОЛЬЗОВАНИЕ ПЕРЛАМУТРА В ОТКРЫТОМ ПРОСТРАНСТВЕ</target>
        </trans-unit>
        <trans-unit id="ac35aec57e40ba482f8f9fa734ce439013d2f6b2" translate="yes" xml:space="preserve">
          <source>USING THE EXTERNAL GZIP</source>
          <target state="translated">ИСПОЛЬЗУЯ ВНЕШНЮЮ ЗАСТЁЖКУ</target>
        </trans-unit>
        <trans-unit id="6af50db97d3b4d2d4a30cc3bc98a5ffb4cb39ec7" translate="yes" xml:space="preserve">
          <source>USourceData.txt</source>
          <target state="translated">USourceData.txt</target>
        </trans-unit>
        <trans-unit id="6b28c2250a1cbb7c8f56dfcf0dd9e06201c35f2f" translate="yes" xml:space="preserve">
          <source>UTF stands for &quot;Unicode Transformation Format&quot;. UTF-8 is an encoding of Unicode into a sequence of 8-bit byte chunks, based on ASCII and Latin-1. The length of a sequence required to represent a Unicode code point depends on the ordinal number of that code point, with larger numbers requiring more bytes. UTF-EBCDIC is like UTF-8, but based on EBCDIC. They are enough alike that often, casual usage will conflate the two terms, and use &quot;UTF-8&quot; to mean both the UTF-8 found on ASCII platforms, and the UTF-EBCDIC found on EBCDIC ones.</source>
          <target state="translated">UTF означает &quot;Unicode Transformation Format&quot;.UTF-8-это кодировка Юникода в последовательность 8-битных кусков байт,основанная на ASCII и латинице-1.Длина последовательности,необходимой для представления точки кода Юникода,зависит от порядкового номера этой точки кода,а для больших чисел требуется больше байт.UTF-EBCDIC похожа на UTF-8,но основана на EBCDIC.Они достаточно похожи,что при случайном использовании будут сливаться два термина,и использовать &quot;UTF-8&quot; для обозначения как UTF-8,найденной на ASCII платформах,так и UTF-EBCDIC,найденной на EBCDIC.</target>
        </trans-unit>
        <trans-unit id="c965e907f9d25c517a8e5bd79aea9417a0714217" translate="yes" xml:space="preserve">
          <source>UTF-16 is almost the same as UCS-2 but it supports</source>
          <target state="translated">UTF-16 почти такая же,как и UCS-2,но она поддерживает</target>
        </trans-unit>
        <trans-unit id="5222e4ab75ba1ce305284f282ec30a73156a366c" translate="yes" xml:space="preserve">
          <source>UTF-16, UTF-16BE, UTF-16LE, Surrogates, and &lt;code&gt;BOM&lt;/code&gt; 's (Byte Order Marks)</source>
          <target state="translated">UTF-16, UTF-16BE, UTF-16LE, суррогаты и &lt;code&gt;BOM&lt;/code&gt; (метки порядка байтов)</target>
        </trans-unit>
        <trans-unit id="47a1ff59a1e826be6636526f502c21d7b7b97ead" translate="yes" xml:space="preserve">
          <source>UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits. Since it is 32-bit, there is no need for</source>
          <target state="translated">UTF-32 (UCS-4)-это кодировка фиксированной длины,каждый символ которой принимает 32 бита.Так как это 32-битная кодировка,то нет необходимости в</target>
        </trans-unit>
        <trans-unit id="dfd8dce020ef601007001e4289b99a7908444d8a" translate="yes" xml:space="preserve">
          <source>UTF-32, UTF-32BE, UTF-32LE</source>
          <target state="translated">УФ-32,УФ-32БЕ,УФ-32ЛЕ</target>
        </trans-unit>
        <trans-unit id="20e199acc434517cd4a6e5977a48bae6e5af47a4" translate="yes" xml:space="preserve">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>
        </trans-unit>
        <trans-unit id="4d56cb8e2ad2a50613de9fa7d9d9a0d239c1aca9" translate="yes" xml:space="preserve">
          <source>UTF-7 encoding</source>
          <target state="translated">кодирование UTF-7</target>
        </trans-unit>
        <trans-unit id="ba8308c0cebaf2cef9e02fb7f26e6c4f56ba6ce0" translate="yes" xml:space="preserve">
          <source>UTF-7 was not supported by Encode until version 1.95 because of that. But Unicode::String, a module by Gisle Aas which adds Unicode supports to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added so Encode can supersede Unicode::String 100%.</source>
          <target state="translated">Из-за этого UTF-7 не поддерживалась кодировкой до версии 1.95.Но Юникод::Строка,модуль от Gisle Aas,который добавляет поддержку Юникода к неutf8-savvy perl,действительно поддерживал UTF-7,поддержка UTF-7 была добавлена,так что кодировка может заменить Юникод::Строка на 100%.</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="e2635de14b396bd81c2a4f587434aea9cfbf99fc" translate="yes" xml:space="preserve">
          <source>UTF-8 and UTF-EBCDIC are two different encodings used to represent Unicode code points as sequences of bytes. Macros with the same names (but different definitions) in</source>
          <target state="translated">UTF-8 и UTF-EBCDIC-две разные кодировки,используемые для представления точек кода Юникода в виде последовательностей байтов.Макросы с одинаковыми именами (но с разными определениями)в</target>
        </trans-unit>
        <trans-unit id="8b4fe83acd749a66b827e068556fa7943eee22bb" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode FAQ for Unix/Linux</source>
          <target state="translated">UTF-8 и Unicode FAQ для Unix/Linux</target>
        </trans-unit>
        <trans-unit id="79cdcb7150e1254a38f057938e6f4012fc46b08a" translate="yes" xml:space="preserve">
          <source>UTF-8 is a variable-length (1 to 4 bytes), byte-order independent encoding. In most of Perl's documentation, including elsewhere in this document, the term &quot;UTF-8&quot; means also &quot;UTF-EBCDIC&quot;. But in this section, &quot;UTF-8&quot; refers only to the encoding used on ASCII platforms. It is a superset of 7-bit US-ASCII, so anything encoded in ASCII has the identical representation when encoded in UTF-8.</source>
          <target state="translated">UTF-8-это кодировка переменной длины (от 1 до 4 байт),независимая от порядка байт.В большинстве документов на Perl,в том числе и в других местах этого документа,термин &quot;UTF-8&quot; означает также &quot;UTF-EBCDIC&quot;.Но в этом разделе &quot;UTF-8&quot; относится только к кодировке,используемой на ASCII платформах.Это суперсет из 7-битных US-ASCII,так что все,что закодировано в ASCII,имеет идентичное представление при кодировке в UTF-8.</target>
        </trans-unit>
        <trans-unit id="64b07e44d3986db9cf7499225144a4d1d394db97" translate="yes" xml:space="preserve">
          <source>UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take only one byte per character. All other characters are encoded as two to four bytes using a complex scheme. Fortunately, Perl handles this for us, so we don't have to worry about this.</source>
          <target state="translated">UTF-8 обрабатывает первые 128 кодовых точек,0...127,так же,как и ASCII.Они берут только один байт на символ.Все остальные символы кодируются как два-четыре байта по сложной схеме.К счастью,Perl обрабатывает это для нас,так что нам не нужно беспокоиться об этом.</target>
        </trans-unit>
        <trans-unit id="7443ec4bd05d2044739a43a92206bcfe32f068b2" translate="yes" xml:space="preserve">
          <source>UTF-8 vs. utf8 vs. UTF8</source>
          <target state="translated">UTF-8 vs.utf8 vs.UTF8</target>
        </trans-unit>
        <trans-unit id="21357a91ac9a6238516304ecf3d0973befa29dc1" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC</source>
          <target state="translated">UTF-EBCDIC</target>
        </trans-unit>
        <trans-unit id="54206a5f5bcbb8b5ddd3ceb665085cec48ec6be8" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is defined by &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;Unicode Technical Report #16&lt;/a&gt;. It is defined based on CCSID 1047, not allowing for the differences for other code pages. This allows for easy interchange of text between computers running different code pages, but makes it unusable, without adaptation, for Perl on those other code pages.</source>
          <target state="translated">UTF-EBCDIC определен в &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr16&quot;&gt;техническом отчете Unicode №16&lt;/a&gt; . Он определяется на основе CCSID 1047, не учитывая различий для других кодовых страниц. Это позволяет легко обмениваться текстом между компьютерами, на которых работают разные кодовые страницы, но делает его непригодным для использования без адаптации для Perl на этих других кодовых страницах.</target>
        </trans-unit>
        <trans-unit id="fae1061497efd49ee6054c0a3d6e1ce19e05e6be" translate="yes" xml:space="preserve">
          <source>UTF-EBCDIC is used on EBCDIC platforms. The largest Unicode code points take 5 bytes to represent (instead of 4 in UTF-8), and Perl extends it to a maximum of 7 bytes to encode pode points up to what can fit in a 32-bit word (instead of 13 bytes and a 64-bit word in UTF-8).</source>
          <target state="translated">UTF-EBCDIC используется на платформах EBCDIC.Самые большие точки кода Unicode для представления занимают 5 байт (вместо 4 в UTF-8),а Perl расширяет его до максимум 7 байт для кодирования точек кода до того,что может поместиться в 32-битном слове (вместо 13 байт и 64-битного слова в UTF-8).</target>
        </trans-unit>
        <trans-unit id="32e4aba336279eb247fca6069de55e692fafce3d" translate="yes" xml:space="preserve">
          <source>UTF-X</source>
          <target state="translated">UTF-X</target>
        </trans-unit>
        <trans-unit id="17562b3d061f2f42586076a6b020ba8eb357a3ff" translate="yes" xml:space="preserve">
          <source>UTILITIES</source>
          <target state="translated">UTILITIES</target>
        </trans-unit>
        <trans-unit id="58bc809d31f639453a46636f9c8ab08c8b78bb44" translate="yes" xml:space="preserve">
          <source>UTILITY FUNCTIONS</source>
          <target state="translated">ФУНКЦИИ ПОЛЕЗНОСТИ</target>
        </trans-unit>
        <trans-unit id="994023f4756ccee554f76e83b238ef8441ca987c" translate="yes" xml:space="preserve">
          <source>Ultimate control over what should be done when (actually: each time) an option is encountered on the command line can be achieved by designating a reference to a subroutine (or an anonymous subroutine) as the option destination. When GetOptions() encounters the option, it will call the subroutine with two or three arguments. The first argument is the name of the option. (Actually, it is an object that stringifies to the name of the option.) For a scalar or array destination, the second argument is the value to be stored. For a hash destination, the second argument is the key to the hash, and the third argument the value to be stored. It is up to the subroutine to store the value, or do whatever it thinks is appropriate.</source>
          <target state="translated">Конечный контроль над тем,что должно быть сделано,когда (на самом деле:каждый раз)опция встречается в командной строке,может быть достигнут путем назначения ссылки на подпрограмму (или анонимную подпрограмму)в качестве пункта назначения опции.Когда GetOptions()встречает опцию,она будет вызывать подпрограмму с двумя или тремя аргументами.Первый аргумент-имя опции.(На самом деле,это объект,который строчит имя опции.)Для скаляра или назначения массива вторым аргументом является значение,которое должно быть сохранено.Для назначения хэша вторым аргументом является ключ к хэшу,а третьим-хранимое значение.Хранить значение или делать все,что он сочтет нужным,можно только в подпрограммном обеспечении.</target>
        </trans-unit>
        <trans-unit id="fd11761cf7cb6cb9a563ded422bdfc4417516b2a" translate="yes" xml:space="preserve">
          <source>Unacceptable behavior will result in a public and clearly identified warning. Repeated unacceptable behavior will result in removal from the mailing list and revocation of rights to update rt.perl.org. The first removal is for one month. Subsequent removals will double in length. After six months with no warning, a user's ban length is reset. Removals, like warnings, are public.</source>
          <target state="translated">Неприемлемое поведение приведет к публичному и четко обозначенному предупреждению.Повторное неприемлемое поведение приведет к удалению из списка рассылки и лишению прав на обновление rt.perl.org.Первое удаление-на один месяц.Последующие удаления будут длиться вдвое дольше.После шести месяцев без предупреждения длина запрета пользователя сбрасывается.Удаления,как и предупреждения,являются публичными.</target>
        </trans-unit>
        <trans-unit id="1f8a4652f1c5950bdfb9f442db5f7ff059a9e8ff" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;!&quot;&lt;/code&gt; performs logical negation, that is, &quot;not&quot;. See also &lt;code&gt;not&lt;/code&gt; for a lower precedence version of this.</source>
          <target state="translated">Унарный &lt;code&gt;&quot;!&quot;&lt;/code&gt; выполняет логическое отрицание, то есть &amp;laquo;не&amp;raquo;. См. Также &lt;code&gt;not&lt;/code&gt; версию с более низким приоритетом.</target>
        </trans-unit>
        <trans-unit id="975143052b1e27f57ec5fcc07f42eb1c0eae9dc3" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;+&quot;&lt;/code&gt; has no effect whatsoever, even on strings. It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments. (See examples above under &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;Terms and List Operators (Leftward)&lt;/a&gt;.)</source>
          <target state="translated">Унарный &lt;code&gt;&quot;+&quot;&lt;/code&gt; вообще не действует, даже на строки. Это полезно синтаксически для отделения имени функции от выражения в скобках, которое в противном случае интерпретировалось бы как полный список аргументов функции. (См. Примеры выше в разделе &amp;laquo; &lt;a href=&quot;#Terms-and-List-Operators-(Leftward)&quot;&gt;Условия и операторы списков&amp;raquo; (слева)&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="cbc2e014fe3be3f69d01617e0a9853fb77867e55" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;-&quot;&lt;/code&gt; performs arithmetic negation if the operand is numeric, including any string that looks like a number. If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned. Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned. One effect of these rules is that &lt;code&gt;-bareword&lt;/code&gt; is equivalent to the string &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; . If, however, the string begins with a non-alphabetic character (excluding &lt;code&gt;&quot;+&quot;&lt;/code&gt; or &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), Perl will attempt to convert the string to a numeric, and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning &lt;b&gt;Argument &quot;the string&quot; isn't numeric in negation (-) at ...&lt;/b&gt;.</source>
          <target state="translated">Унарный знак &lt;code&gt;&quot;-&quot;&lt;/code&gt; выполняет арифметическое отрицание, если операнд числовой, включая любую строку, которая выглядит как число. Если операнд является идентификатором, возвращается строка, состоящая из знака минус, соединенного с идентификатором. В противном случае, если строка начинается с плюса или минуса, возвращается строка, начинающаяся с противоположного знака. Одним из следствий этих правил является то, что &lt;code&gt;-bareword&lt;/code&gt; эквивалентно строке &lt;code&gt;&quot;-bareword&quot;&lt;/code&gt; . Если, однако, строка начинается с неалфавитного символа (за исключением &lt;code&gt;&quot;+&quot;&lt;/code&gt; или &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), Perl попытается преобразовать строку в числовой, и будет выполнено арифметическое отрицание. Если строка не может быть полностью преобразована в числовую, Perl выдаст предупреждение&lt;b&gt;Аргумент &amp;laquo;строка&amp;raquo; не является числовым значением в отрицании (-) в ...&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="75765e3d8911e6ac713c74a3a1fc1d709b9ed2ea" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;\&quot;&lt;/code&gt; creates a reference to whatever follows it. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</source>
          <target state="translated">Унарный &lt;code&gt;&quot;\&quot;&lt;/code&gt; создает ссылку на все, что следует за ним. См. &lt;a href=&quot;perlreftut&quot;&gt;Perlreftut&lt;/a&gt; и &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; . Не путайте это поведение с поведением обратной косой черты внутри строки, хотя обе формы действительно передают понятие защиты следующего объекта от интерполяции.</target>
        </trans-unit>
        <trans-unit id="a440a050a6ba4df9312abb517ec0cbc1f89e1767" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;not&quot;&lt;/code&gt; returns the logical negation of the expression to its right. It's the equivalent of &lt;code&gt;&quot;!&quot;&lt;/code&gt; except for the very low precedence.</source>
          <target state="translated">Унарное &lt;code&gt;&quot;not&quot;&lt;/code&gt; возвращает логическое отрицание выражения справа. Это эквивалент &lt;code&gt;&quot;!&quot;&lt;/code&gt; за исключением очень низкого приоритета.</target>
        </trans-unit>
        <trans-unit id="4dae9b42247425fb7e1e868bc6aec93255104f04" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; performs bitwise negation, that is, 1's complement. For example, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; is 0640. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt; and &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.) Note that the width of the result is platform-dependent: &lt;code&gt;~0&lt;/code&gt; is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; operator to mask off the excess bits.</source>
          <target state="translated">Унарный &lt;code&gt;&quot;~&quot;&lt;/code&gt; выполняет побитовое отрицание, то есть дополнение до единицы. Например, &lt;code&gt;0666 &amp;amp; ~027&lt;/code&gt; - это 0640. (См. Также &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленные арифметические&lt;/a&gt; и &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;побитовые строковые операторы&lt;/a&gt; .) Обратите внимание, что ширина результата зависит от платформы: &lt;code&gt;~0&lt;/code&gt; имеет ширину 32 бита на 32-битной платформе, но ширину 64 бита. на 64-битной платформе, поэтому, если вы ожидаете определенной разрядности, не забудьте использовать оператор &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; чтобы замаскировать лишние биты.</target>
        </trans-unit>
        <trans-unit id="121bb514c3415be69016271f5f8950c0aed3f161" translate="yes" xml:space="preserve">
          <source>Unbackslashed prototype characters have special meanings. Any unbackslashed &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; eats all remaining arguments, and forces list context. An argument represented by &lt;code&gt;$&lt;/code&gt; forces scalar context. An &lt;code&gt;&amp;amp;&lt;/code&gt; requires an anonymous subroutine, which, if passed as the first argument, does not require the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; keyword or a subsequent comma.</source>
          <target state="translated">Символы прототипа без обратной косой черты имеют особое значение. Любые символы &lt;code&gt;@&lt;/code&gt; или &lt;code&gt;%&lt;/code&gt; без обратной косой черты съедают все оставшиеся аргументы и заставляют контекст списка. Аргумент, представленный &lt;code&gt;$&lt;/code&gt; принудительно скалярный контекст. Для &lt;code&gt;&amp;amp;&lt;/code&gt; требуется анонимная подпрограмма, которая, если она передана в качестве первого аргумента, не требует &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; ключевого слова или последующей запятой.</target>
        </trans-unit>
        <trans-unit id="825c40d18a2a673a59517a26d2876574d355db3e" translate="yes" xml:space="preserve">
          <source>Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">Распаковать gzip,zip,bzip2 или lzop файл/буфер</target>
        </trans-unit>
        <trans-unit id="aed55ac0a8b1616e77c1e8b5f3fc823c056e7f68" translate="yes" xml:space="preserve">
          <source>Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">Распаковать zlib-файл/буфер (zip,gzip)на основе (zip,gzip)</target>
        </trans-unit>
        <trans-unit id="5566ebf8e86133343de98e57588751d94f017699" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">Распаковывает &lt;code&gt;$input&lt;/code&gt; и записывает несжатые данные в &lt;code&gt;$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3241d8b84b7531f4c85af8e73c024fd4504975c7" translate="yes" xml:space="preserve">
          <source>Uncompresses &lt;code&gt;$source&lt;/code&gt; . If successful it returns the uncompressed data. Otherwise it returns</source>
          <target state="translated">Распаковывает &lt;code&gt;$source&lt;/code&gt; . В случае успеха возвращает несжатые данные. В противном случае возвращается</target>
        </trans-unit>
        <trans-unit id="ac8d3226186ea01833996c8b65de3f2a8379790e" translate="yes" xml:space="preserve">
          <source>Uncompression</source>
          <target state="translated">Uncompression</target>
        </trans-unit>
        <trans-unit id="4189d548d277ce627b98749a55c3556ffc35219e" translate="yes" xml:space="preserve">
          <source>Unconditionally match a bareword or any other single character, and then go back to step 1.</source>
          <target state="translated">Безоговорочно сопоставьте пустое слово или любой другой одиночный символ,а затем вернитесь к шагу 1.</target>
        </trans-unit>
        <trans-unit id="577343970a5bf9b7cb8738f42c2797ca4589087a" translate="yes" xml:space="preserve">
          <source>Uncuddled elses and &quot;K&amp;amp;R&quot; style for indenting control constructs</source>
          <target state="translated">Uncuddled elses и стиль &quot;K&amp;amp;R&quot; для отступов управляющих конструкций</target>
        </trans-unit>
        <trans-unit id="11c11d31d108dd964ce797e5076b1d8839850791" translate="yes" xml:space="preserve">
          <source>Uncuddled elses.</source>
          <target state="translated">Необжитые Эльзы.</target>
        </trans-unit>
        <trans-unit id="5cd9e75daaa9152346601595647eb2d9696e6583" translate="yes" xml:space="preserve">
          <source>Undef if an external</source>
          <target state="translated">Необязательно,если внешний</target>
        </trans-unit>
        <trans-unit id="b410752a7d8baa31a708ac9e0618b37a2bdd788d" translate="yes" xml:space="preserve">
          <source>Undefined subroutine &amp;amp;main::GetOptions called</source>
          <target state="translated">Неопределенная подпрограмма &amp;amp; main :: GetOptions вызвана</target>
        </trans-unit>
        <trans-unit id="4be1ae516287ece8c814ce973af8c8cef754916c" translate="yes" xml:space="preserve">
          <source>Undefines the array. Frees the memory used by the av to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed.</source>
          <target state="translated">Неопределяет массив.Освобождает память,используемую av для хранения списка скаляров.Если в результате сработают деструкторы,то может быть освобождено само av.</target>
        </trans-unit>
        <trans-unit id="270b863b48b0c13c0b01735bf826d9b654084021" translate="yes" xml:space="preserve">
          <source>Undefines the collation element as if it were unassigned in the &lt;code&gt;table&lt;/code&gt; . This reduces the size of the table. If an unassigned character appears in the string to be collated, the sort key is made from its codepoint as a single-character collation element, as it is greater than any other assigned collation elements (in the codepoint order among the unassigned characters). But, it'd be better to ignore characters unfamiliar to you and maybe never used.</source>
          <target state="translated">Отменяет определение элемента сопоставления, как если бы он не был назначен в &lt;code&gt;table&lt;/code&gt; . Это уменьшает размер таблицы. Если в строке, подлежащей сопоставлению, появляется неназначенный символ, ключ сортировки создается из его кодовой точки как односимвольного элемента сопоставления, поскольку он больше, чем любые другие назначенные элементы сопоставления (в порядке кодовых точек среди неназначенных символов). Но лучше не обращать внимания на незнакомых вам персонажей, которые, возможно, никогда не использовались.</target>
        </trans-unit>
        <trans-unit id="7b61a323c52c38306eb024952539f4f8c5a7ffe3" translate="yes" xml:space="preserve">
          <source>Undefines the hash. The XS equivalent of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Отменяет определение хеша. Эквивалент &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef(%hash)&lt;/a&gt;&lt;/code&gt; XS (% hash) .</target>
        </trans-unit>
        <trans-unit id="21918cc87ca44856538ac74361e547848b42b7b4" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;#delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">Отменяет значение EXPR, которое должно быть lvalue. Используйте только скалярное значение, массив (используя &lt;code&gt;@&lt;/code&gt; ), хэш (используя &lt;code&gt;%&lt;/code&gt; ), подпрограмму (используя &lt;code&gt;&amp;amp;&lt;/code&gt; ) или typeglob (используя &lt;code&gt;*&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; , вероятно, не приведет к тому, что вы ожидаете от большинства предопределенных переменных или значений списков DBM, поэтому не делайте этого; см. &lt;a href=&quot;#delete&quot;&gt;удалить&lt;/a&gt; . Всегда возвращает неопределенное значение. Вы можете опустить EXPR, и в этом случае ничего не будет неопределенным, но вы все равно получите неопределенное значение, которое вы можете, например, вернуть из подпрограммы, присвоить переменной или передать в качестве параметра. Примеры:</target>
        </trans-unit>
        <trans-unit id="12772c94a5d6a3598c32da79f4c1c4affc5b608e" translate="yes" xml:space="preserve">
          <source>Undefines the value of EXPR, which must be an lvalue. Use only on a scalar value, an array (using &lt;code&gt;@&lt;/code&gt; ), a hash (using &lt;code&gt;%&lt;/code&gt; ), a subroutine (using &lt;code&gt;&amp;amp;&lt;/code&gt; ), or a typeglob (using &lt;code&gt;*&lt;/code&gt; ). Saying &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; will probably not do what you expect on most predefined variables or DBM list values, so don't do that; see &lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;. Always returns the undefined value. You can omit the EXPR, in which case nothing is undefined, but you still get an undefined value that you could, for instance, return from a subroutine, assign to a variable, or pass as a parameter. Examples:</source>
          <target state="translated">Отменяет значение EXPR, которое должно быть lvalue. Используйте только скалярное значение, массив (используя &lt;code&gt;@&lt;/code&gt; ), хэш (используя &lt;code&gt;%&lt;/code&gt; ), подпрограмму (используя &lt;code&gt;&amp;amp;&lt;/code&gt; ) или typeglob (используя &lt;code&gt;*&lt;/code&gt; ). Использование &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt; $hash{$key}&lt;/code&gt; , вероятно, не приведет к тому, что вы ожидаете от большинства предопределенных переменных или значений списков DBM, поэтому не делайте этого; см. &lt;a href=&quot;delete&quot;&gt;удалить&lt;/a&gt; . Всегда возвращает неопределенное значение. Вы можете опустить EXPR, и в этом случае ничего не будет неопределенным, но вы все равно получите неопределенное значение, которое вы можете, например, вернуть из подпрограммы, присвоить переменной или передать в качестве параметра. Примеры:</target>
        </trans-unit>
        <trans-unit id="8b42ea56822642513e4f112de38357bed9dd6a64" translate="yes" xml:space="preserve">
          <source>Undefining this symbol disables the PerlIO abstraction. PerlIO is now the default; it is not recommended to disable PerlIO.</source>
          <target state="translated">Неопределение этого символа отключает абстракцию PerlIO.Теперь по умолчанию используется PerlIO;не рекомендуется отключать PerlIO.</target>
        </trans-unit>
        <trans-unit id="14931b1ffe46d4f806d87924392ea8d8ba051a3f" translate="yes" xml:space="preserve">
          <source>Undefining this symbol forces Perl to be compiled statically.</source>
          <target state="translated">Неопределение этого символа заставляет Perl компилироваться статически.</target>
        </trans-unit>
        <trans-unit id="55d31ccf7c7a9061158740ae0e4ba2a4be4c51d6" translate="yes" xml:space="preserve">
          <source>Under &quot;Classic&quot; MacOS, a perl program will have the appropriate Creator and Type, so that double-clicking them will invoke the MacPerl application. Under Mac OS X, clickable apps can be made from any &lt;code&gt;#!&lt;/code&gt; script using Wil Sanchez' DropScript utility: &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</source>
          <target state="translated">В &amp;laquo;Классической&amp;raquo; MacOS программа Perl будет иметь соответствующий Создатель и Тип, так что двойной щелчок по ним будет вызывать приложение MacPerl. В Mac OS X интерактивные приложения можно создавать из любого &lt;code&gt;#!&lt;/code&gt; скрипт с использованием утилиты DropScript Уила Санчеса: &lt;a href=&quot;http://www.wsanchez.net/software/&quot;&gt;http://www.wsanchez.net/software/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7de147ca0cf42a020c2b34e4934080e8fbf00bba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt;, test number 2 would</source>
          <target state="translated">В разделе &lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; тест номер 2 будет</target>
        </trans-unit>
        <trans-unit id="50510298fcc80cb0b2cfe5fcb98eb1382cb9d484" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , detection step of discontiguous contractions will be skipped.</source>
          <target state="translated">В &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; шаг обнаружения несмежных сокращений будет пропущен.</target>
        </trans-unit>
        <trans-unit id="da1bc7be7a27894ec56a14e00f77fdf88c07658e" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="translated">При не &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature &quot;array_base&quot;&lt;/code&gt; , &lt;code&gt;$[&lt;/code&gt; больше не имеет никакого эффекта, и всегда содержит 0. Присвоение 0 ему разрешено, но любое другое значение приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="bacf555aace53131b41a0f7ef63c9e3e7d03589b" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;unicode_strings&lt;/code&gt; starting in Perl 5.12.0, Unicode rules are generally used. See &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; for details on how this works in combination with various other pragmas.</source>
          <target state="translated">В &lt;code&gt;unicode_strings&lt;/code&gt; , начиная с Perl 5.12.0, обычно используются правила Unicode. См. Подробности о том, как это работает в сочетании с другими прагмами, см. В &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94fe5caf324bcb104f1845ec70df5cb17cd45071" translate="yes" xml:space="preserve">
          <source>Under Cygwin, $^E is the same as $!. When using &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32 API Functions&lt;/a&gt;, use &lt;code&gt;Win32::GetLastError()&lt;/code&gt; to get the last Windows error.</source>
          <target state="translated">В Cygwin $ ^ E совпадает с $ !. При использовании &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;функций Win32 API&lt;/a&gt; используйте &lt;code&gt;Win32::GetLastError()&lt;/code&gt; чтобы получить последнюю ошибку Windows.</target>
        </trans-unit>
        <trans-unit id="08490cc0df2a509f16cddc3cf2a4ae40e649767f" translate="yes" xml:space="preserve">
          <source>Under EBCDIC platforms, &lt;code&gt;e2char($n)&lt;/code&gt; may not always be the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt;, because the strings are returned as native, and the numbers are returned as Unicode. However, for Perls starting with v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; is the same as &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt;, and ditto for &lt;code&gt;$Name2character{$name}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">На платформах EBCDIC &lt;code&gt;e2char($n)&lt;/code&gt; не всегда может быть таким же, как &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(e2charnum($n))&lt;/a&gt;&lt;/code&gt; , и то же &lt;code&gt;$Name2character{$name}&lt;/code&gt; для $ Name2character {$ name} и &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr($Name2character_number{$name})&lt;/a&gt;&lt;/code&gt; , потому что возвращаются строки как родной, а числа возвращаются как Unicode. Однако для Perls, начиная с v5.8, &lt;code&gt;e2char($n)&lt;/code&gt; совпадает с &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native(e2charnum($n)))&lt;/a&gt;&lt;/code&gt; , и то же &lt;code&gt;$Name2character{$name}&lt;/code&gt; для $ Name2character {$ name} и &lt;code&gt;&lt;a href=&quot;../functions/chr&quot;&gt;chr(utf8::unicode_to_native($Name2character_number{$name}))&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18254acc65d18b7ddbf875f7bfc47db0d75ce39a" translate="yes" xml:space="preserve">
          <source>Under NFS this will use the time of the NFS server, not the time of the local machine. If there is a time synchronization problem, the NFS server and local machine will have different times. The Unix touch(1) command will in fact normally use this form instead of the one shown in the first example.</source>
          <target state="translated">В NFS будет использоваться время сервера NFS,а не время локальной машины.Если возникает проблема синхронизации времени,то NFS-сервер и локальная машина будут иметь разное время.Команда Unix touch(1)на самом деле обычно использует эту форму вместо формы,показанной в первом примере.</target>
        </trans-unit>
        <trans-unit id="f3924a4fe96e1e85710f171a0842dfde3423eb52" translate="yes" xml:space="preserve">
          <source>Under OS/2, &lt;code&gt;$^E&lt;/code&gt; is set to the error code of the last call to OS/2 API either via CRT, or directly from perl.</source>
          <target state="translated">В OS / 2 &lt;code&gt;$^E&lt;/code&gt; устанавливается на код ошибки последнего вызова OS / 2 API через CRT или напрямую из perl.</target>
        </trans-unit>
        <trans-unit id="19dcdc34494760727e410f497dbed91a176d6c5e" translate="yes" xml:space="preserve">
          <source>Under Perl 5.10 only, using a string eval when &lt;code&gt;autodie&lt;/code&gt; is in effect can cause the autodie behaviour to leak into the surrounding scope. This can be worked around by using a &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; at the end of the scope to explicitly remove autodie's effects, or by avoiding the use of string eval.</source>
          <target state="translated">Только в Perl 5.10 использование строки eval во время работы &lt;code&gt;autodie&lt;/code&gt; может привести к тому, что поведение autodie проникнет в окружающую область. Это можно обойти, используя &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; в конце области видимости, чтобы явно удалить эффекты autodie, или избегая использования строки eval.</target>
        </trans-unit>
        <trans-unit id="1824d549ede70b3449b6bc94fa47857184a96f9f" translate="yes" xml:space="preserve">
          <source>Under Perl 5.18 and later, SvREADONLY only applies to read-only variables, and, under 5.20, copy-on-write scalars can also be read-only, so the above check is incorrect. You just want:</source>
          <target state="translated">В соответствии с Perl 5.18 и более поздними версиями,SvREADONLY применяется только к переменным,доступным только для чтения,а в соответствии с 5.20 скаляры копирования на запись также могут быть доступны только для чтения,поэтому вышеприведенная проверка неверна.Вы просто хотите:</target>
        </trans-unit>
        <trans-unit id="8d107d150b9abd6d04d1d29a993fa6ea829d9209" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8 only, &lt;code&gt;autodie&lt;/code&gt;</source>
          <target state="translated">Только под Perl 5.8 &lt;code&gt;autodie&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e28f5c058f0915564622ac46660d6f84c05ab318" translate="yes" xml:space="preserve">
          <source>Under Perl 5.8, the &lt;code&gt;given/when&lt;/code&gt; structure is not available, so the following structure may be used:</source>
          <target state="translated">В Perl 5.8 структура &lt;code&gt;given/when&lt;/code&gt; недоступна, поэтому можно использовать следующую структуру:</target>
        </trans-unit>
        <trans-unit id="ef993909ab6a97a91baf7e650bc7ce46f77c2516" translate="yes" xml:space="preserve">
          <source>Under QNX 6.2.0 there are still a few tests which fail. See below and hints/qnx.sh for more information.</source>
          <target state="translated">В QNX 6.2.0 есть еще несколько неудачных тестов.Смотрите ниже и подсказки/qnx.sh для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="66b5ec5cf7fb5924aee8dffa63eba13ccd60d52e" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary. Except for UTF-8 locales in Perls v5.20 and later, these are disallowed under &lt;code&gt;/l&lt;/code&gt; . For example, 0xFF (on ASCII platforms) does not caselessly match the character at 0x178, &lt;code&gt;LATIN
CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; , because 0xFF may not be &lt;code&gt;LATIN SMALL
LETTER Y WITH DIAERESIS&lt;/code&gt; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.</source>
          <target state="translated">Согласно правилам Unicode существует несколько совпадений без учета регистра, которые пересекают границу 255/256. За исключением локалей UTF-8 в Perls v5.20 и новее, они не разрешены в &lt;code&gt;/l&lt;/code&gt; . Например, 0xFF (на платформах ASCII) не соответствует без регистров символу в 0x178, &lt;code&gt;LATIN CAPITAL LETTER Y WITH DIAERESIS&lt;/code&gt; ЗАГЛАВНОЙ БУКВЕ Y С ДИАРЕЗОМ , потому что 0xFF может не быть &lt;code&gt;LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; в текущей локали, и Perl не имеет возможности узнать, если это символ даже существует в локали, не говоря уже о том, какой это код.</target>
        </trans-unit>
        <trans-unit id="666da3b151d79c3526ad94c74b4a7b5272bc4ad7" translate="yes" xml:space="preserve">
          <source>Under Unicode rules, these upper-Latin1 characters are interpreted as Unicode code points, which means they have the same semantics as Latin-1 (ISO-8859-1) and C1 controls.</source>
          <target state="translated">В соответствии с правилами Юникода,эти символы верхнего латинского алфавита 1 интерпретируются как точки кода Юникода,что означает,что они имеют ту же семантику,что и элементы управления латинского алфавита 1 (ISO-8859-1)и С1.</target>
        </trans-unit>
        <trans-unit id="15d191765263aacd2b7fcad31e78fb6cf886a85b" translate="yes" xml:space="preserve">
          <source>Under VMS this reflects the actual VMS exit status; i.e. it is the same as &lt;code&gt;$?&lt;/code&gt; when the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; is in effect.</source>
          <target state="translated">В VMS это отражает фактический статус выхода VMS; т.е. это то же самое, что и &lt;code&gt;$?&lt;/code&gt; когда действует прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="737324e93129014d33d4923a010ebe747aa167f7" translate="yes" xml:space="preserve">
          <source>Under VMS, &lt;code&gt;$^E&lt;/code&gt; provides the VMS status value from the last system error. This is more specific information about the last system error than that provided by &lt;code&gt;$!&lt;/code&gt; . This is particularly important when &lt;code&gt;$!&lt;/code&gt; is set to &lt;b&gt;EVMSERR&lt;/b&gt;.</source>
          <target state="translated">В VMS &lt;code&gt;$^E&lt;/code&gt; предоставляет значение статуса VMS из последней системной ошибки. Это более конкретная информация о последней системной ошибке, чем та, которую предоставляет &lt;code&gt;$!&lt;/code&gt; . Это особенно важно, когда &lt;code&gt;$!&lt;/code&gt; установлен на &lt;b&gt;EVMSERR&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="50b3f98ca540bd0c81d34840956f838255c71318" translate="yes" xml:space="preserve">
          <source>Under VMS, if there is no directory information in the $path, then the current default device and directory is used.</source>
          <target state="translated">Под VMS,если в $path нет информации о каталоге,то используется текущее устройство и каталог по умолчанию.</target>
        </trans-unit>
        <trans-unit id="3aaae4cddb5ecef27b2c450c8cc4b4b174c7016f" translate="yes" xml:space="preserve">
          <source>Under VMS, the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status, instead of the default emulation of POSIX status; see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt; for details.</source>
          <target state="translated">В VMS &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; делает &lt;code&gt;$?&lt;/code&gt; отражать фактический статус выхода VMS вместо стандартной эмуляции статуса POSIX; увидеть &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? в perlvms&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="711e7c0754f84b5e7bda634825aa4039a4a70c54" translate="yes" xml:space="preserve">
          <source>Under Win32's &quot;test&quot; target you may use the TEST_SWITCHES and TEST_FILES environment variables to control the behaviour of</source>
          <target state="translated">Под &quot;тестовой&quot; целью Win32 вы можете использовать переменные окружения TEST_SWITCHES и TEST_FILES для управления поведением</target>
        </trans-unit>
        <trans-unit id="53c6d0758bf54648c779157ed9111dd650df9efe" translate="yes" xml:space="preserve">
          <source>Under Win32, &lt;code&gt;$^E&lt;/code&gt; always returns the last error information reported by the Win32 call &lt;code&gt;GetLastError()&lt;/code&gt; which describes the last error from within the Win32 API. Most Win32-specific code will report errors via &lt;code&gt;$^E&lt;/code&gt; . ANSI C and Unix-like calls set &lt;code&gt;errno&lt;/code&gt; and so most portable Perl code will report errors via &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">В Win32 &lt;code&gt;$^E&lt;/code&gt; всегда возвращает информацию о последней ошибке, сообщенную вызовом Win32 &lt;code&gt;GetLastError()&lt;/code&gt; который описывает последнюю ошибку из Win32 API. Большинство Win32-специфический код будет сообщать об ошибках через &lt;code&gt;$^E&lt;/code&gt; . ANSI C и Unix-подобные вызовы устанавливают &lt;code&gt;errno&lt;/code&gt; , поэтому большинство переносимых Perl-кодов будут сообщать об ошибках через &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445377f279bee790252626a9efe4c710c5fb31ec" translate="yes" xml:space="preserve">
          <source>Under Windows and VMS the option file is named</source>
          <target state="translated">В Windows и VMS файл опций называется</target>
        </trans-unit>
        <trans-unit id="991af3b0df6455b17cae9de8484aa49771ee9333" translate="yes" xml:space="preserve">
          <source>Under a few operating systems, &lt;code&gt;$^E&lt;/code&gt; may contain a more verbose error indicator, such as in this case, &quot;CDROM tray not closed.&quot; Systems that do not support extended error messages leave &lt;code&gt;$^E&lt;/code&gt; the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">В некоторых операционных системах &lt;code&gt;$^E&lt;/code&gt; может содержать более подробный индикатор ошибки, например, в данном случае &amp;laquo;Лоток CDROM не закрыт&amp;raquo;. В системах, которые не поддерживают расширенные сообщения об ошибках, &lt;code&gt;$^E&lt;/code&gt; таким же, как &lt;code&gt;$!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8188d9bfb2c028e78df0c34f466ab12923ca95e" translate="yes" xml:space="preserve">
          <source>Under bignum (or bigint or bigrat), Perl will &quot;upgrade&quot; the numbers appropriately. This means that:</source>
          <target state="translated">Под бигнумом (или bigint или bigrat),Perl будет &quot;обновлять&quot; номера соответствующим образом.Это значит,что..:</target>
        </trans-unit>
        <trans-unit id="936167913e1d36052a60fe747af5e2acfb71f327" translate="yes" xml:space="preserve">
          <source>Under case-sensitive matching, these both match the same code points as &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; (&lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ). The difference is that under &lt;code&gt;/i&lt;/code&gt; caseless matching, these match the same as &lt;code&gt;\p{Cased}&lt;/code&gt; , whereas &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; matches &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</source>
          <target state="translated">При сопоставлении с учетом регистра они оба соответствуют тем же кодовым точкам, что и &lt;code&gt;\p{General Category=Titlecase_Letter}&lt;/code&gt; ( &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; ). Разница в том, что при сопоставлении без регистра &lt;code&gt;/i&lt;/code&gt; они совпадают с &lt;code&gt;\p{Cased}&lt;/code&gt; , тогда как &lt;code&gt;\p{gc=&lt;a href=&quot;functions/lt&quot;&gt;lt&lt;/a&gt;}&lt;/code&gt; соответствует &lt;code&gt;\p{Cased_Letter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="58098e551f5eebaa46d0d3a19d00f14ced3f4d46" translate="yes" xml:space="preserve">
          <source>Under ithreads the optree is read only. If you want to enforce this, to check for write accesses from buggy code, compile with &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; to enable code that allocates op memory via &lt;code&gt;mmap&lt;/code&gt; , and sets it read-only when it is attached to a subroutine. Any write access to an op results in a &lt;code&gt;SIGBUS&lt;/code&gt; and abort.</source>
          <target state="translated">В ithreads optree доступен только для чтения. Если вы хотите принудительно выполнить это, чтобы проверить доступ для записи из ошибочного кода, скомпилируйте с &lt;code&gt;-Accflags=-DPERL_DEBUG_READONLY_OPS&lt;/code&gt; , чтобы включить код, который выделяет операционную память через &lt;code&gt;mmap&lt;/code&gt; и устанавливает его только для чтения, когда он присоединен к подпрограмме. Любой доступ на запись к операции приводит к &lt;code&gt;SIGBUS&lt;/code&gt; и прерыванию.</target>
        </trans-unit>
        <trans-unit id="41c5c0dce73b6a45e16e6c80203f13488d40f1dd" translate="yes" xml:space="preserve">
          <source>Under the &quot;switch&quot; feature, Perl gains the experimental keywords &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;break&lt;/code&gt; . Starting from Perl 5.16, one can prefix the switch keywords with &lt;code&gt;CORE::&lt;/code&gt; to access the feature without a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; statement. The keywords &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; are analogous to &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt; in other languages, so the code in the previous section could be rewritten as</source>
          <target state="translated">Под функцией &amp;laquo;переключения&amp;raquo; Perl получает экспериментальные ключевые слова, &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;break&lt;/code&gt; . Начиная с Perl 5.16, можно добавить к ключевым словам переключателя префикс &lt;code&gt;CORE::&lt;/code&gt; для доступа к функции без &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; оператора функции . Ключевые слова &lt;code&gt;given&lt;/code&gt; и &lt;code&gt;when&lt;/code&gt; аналогичны &lt;code&gt;switch&lt;/code&gt; и &lt;code&gt;case&lt;/code&gt; на других языках, так что код в предыдущем разделе , можно переписать в виде</target>
        </trans-unit>
        <trans-unit id="3dcedc6c33e9a6ba46a7f82a03dd4b7c259f61b3" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;unicode_eval&lt;/code&gt; feature, Perl's &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; function, when passed a string, will evaluate it as a string of characters, ignoring any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; exists to declare the encoding of the script, which only makes sense for a stream of bytes, not a string of characters. Source filters are forbidden, as they also really only make sense on strings of bytes. Any attempt to activate a source filter will result in an error.</source>
          <target state="translated">В рамках функции &lt;code&gt;unicode_eval&lt;/code&gt; функция Perl &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; при передаче строки будет оценивать ее как строку символов, игнорируя любые объявления &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; существует для объявления кодировки скрипта, которая имеет смысл только для потока байтов, а не для строки символов. Исходные фильтры запрещены, так как они действительно имеют смысл только для строк байтов. Любая попытка активировать исходный фильтр приведет к ошибке.</target>
        </trans-unit>
        <trans-unit id="3ed7e8de69faa9a39e5b719579b31e326e5e1ba3" translate="yes" xml:space="preserve">
          <source>Under the Mac, it depends which environment you are using. The MacPerl shell, or MPW, is much like Unix shells in its support for several quoting variants, except that it makes free use of the Mac's non-ASCII characters as control characters.</source>
          <target state="translated">Под Mac это зависит от того,какую среду вы используете.Оболочка MacPerl,или MPW,очень похожа на Unix-оболочки в своей поддержке нескольких вариантов цитирования,за исключением того,что она свободно использует не-ASCII-символы Mac в качестве управляющих символов.</target>
        </trans-unit>
        <trans-unit id="57a69bed4d30aeb2c23df15a4942d2f1bc4e9a99" translate="yes" xml:space="preserve">
          <source>Under the current implementation, the &lt;code&gt;foreach&lt;/code&gt; loop can be anywhere within the &lt;code&gt;when&lt;/code&gt; modifier's dynamic scope, but must be within the &lt;code&gt;given&lt;/code&gt; block's lexical scope. This restricted may be relaxed in a future release. See &lt;a href=&quot;#Switch-Statements&quot;&gt;Switch Statements&lt;/a&gt; below.</source>
          <target state="translated">В текущей реализации цикл &lt;code&gt;foreach&lt;/code&gt; может находиться где угодно в пределах динамической области видимости модификатора &lt;code&gt;when&lt;/code&gt; , но должен находиться в пределах лексической области видимости &lt;code&gt;given&lt;/code&gt; блока. Это ограничение может быть ослаблено в будущем выпуске. См. Раздел &amp;laquo; &lt;a href=&quot;#Switch-Statements&quot;&gt;Операторы переключения&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="e08f959b6899ef90dffb2ee9e0e0a8572c0a7c28" translate="yes" xml:space="preserve">
          <source>Under the hood, Perl filehandles are instances of the &lt;code&gt;IO::Handle&lt;/code&gt; or &lt;code&gt;IO::File&lt;/code&gt; class. Once you have an open filehandle, you can call methods on it. Additionally, you can call methods on the &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; filehandles.</source>
          <target state="translated">Под капотом Perl-дескрипторы файлов являются экземплярами классов &lt;code&gt;IO::Handle&lt;/code&gt; или &lt;code&gt;IO::File&lt;/code&gt; . Если у вас есть открытый дескриптор файла, вы можете вызывать для него методы. Кроме того, вы можете вызывать методы дескрипторов файлов &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; и &lt;code&gt;STDERR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e7e970c4cb85f5a1a451cbbaa7bb6fdbefed11" translate="yes" xml:space="preserve">
          <source>Underlying implementation for the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl function. Note that the perl-level function is vaguely deprecated.</source>
          <target state="translated">Базовая реализация функции &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; Perl. Обратите внимание, что функция уровня perl не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="3d53a031b5fe95ac3434bee7e57607b8155a1a48" translate="yes" xml:space="preserve">
          <source>Understand References Today</source>
          <target state="translated">Понять ссылки Сегодня</target>
        </trans-unit>
        <trans-unit id="d2b515bbbe667df83c6f17f27b425a07b052435e" translate="yes" xml:space="preserve">
          <source>Understand that this removes the case-insensitivity feature of this module.</source>
          <target state="translated">Поймите,что это устраняет функцию чувствительности корпуса данного модуля.</target>
        </trans-unit>
        <trans-unit id="5dff374e163235318e5ce8f7742ec1049ed8b995" translate="yes" xml:space="preserve">
          <source>Understanding the Magic of Tied Hashes and Arrays</source>
          <target state="translated">Понимание магии завязанных гашишей и массивов</target>
        </trans-unit>
        <trans-unit id="4fad51d89f7e0dadc266115be3afc11b52bc9806" translate="yes" xml:space="preserve">
          <source>Undertake to build a new set of Perl images using VMS commands. Since VMS does dynamic loading, it's not necessary to statically link each extension into the Perl image, so this isn't the normal build path. Consequently, it hasn't really been tested, and may well be incomplete.</source>
          <target state="translated">Принять решение о создании нового набора образов Perl с помощью команд VMS.Так как VMS выполняет динамическую загрузку,нет необходимости статически связывать каждое расширение с изображением на Perl,поэтому это не обычный путь сборки.Следовательно,на самом деле он не тестировался и вполне может быть неполным.</target>
        </trans-unit>
        <trans-unit id="58380a9a71bcafd994016d7b4cb1383592a7215e" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV, where fakery means &quot;more than&quot; a string: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg; if we're a copy-on-write scalar, this is the on-write time when we do the copy, and is also used locally; if this is a vstring, drop the vstring magic. If &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; is set then a copy-on-write scalar drops its PV buffer (if any) and becomes SvPOK_off rather than making a copy. (Used where this scalar is about to be set to some other value.) In addition, the &lt;code&gt;flags&lt;/code&gt; parameter gets passed to &lt;code&gt;sv_unref_flags()&lt;/code&gt; when unreffing. &lt;code&gt;sv_force_normal&lt;/code&gt; calls this function with flags set to 0.</source>
          <target state="translated">Отмените различные типы подделки на SV, где fakery означает &amp;laquo;больше, чем&amp;raquo; строку: если PV является общей строкой, сделайте частную копию; если мы рефери, перестань реферировать; если мы глобус, перейдите на xpvmg; если мы скаляр копирования при записи, это время записи, когда мы делаем копирование, и оно также используется локально; если это vstring, отбросьте магию vstring. Если установлен &lt;code&gt;SV_COW_DROP_PV&lt;/code&gt; , то скаляр копирования при записи отбрасывает свой буфер PV (если есть) и становится SvPOK_off, а не копирует. (Используется, когда этот скаляр собирается установить на какое-то другое значение.) Кроме того, параметр &lt;code&gt;flags&lt;/code&gt; передается в &lt;code&gt;sv_unref_flags()&lt;/code&gt; при отмене ссылки. &lt;code&gt;sv_force_normal&lt;/code&gt; вызывает эту функцию с флагами, установленными в 0.</target>
        </trans-unit>
        <trans-unit id="2c0043167da52b5a8f43ef5ef3ae847c1d205a64" translate="yes" xml:space="preserve">
          <source>Undo various types of fakery on an SV: if the PV is a shared string, make a private copy; if we're a ref, stop refing; if we're a glob, downgrade to an xpvmg. See also &lt;code&gt;sv_force_normal_flags&lt;/code&gt; .</source>
          <target state="translated">Отмените различные типы подделки на SV: если PV является общей строкой, сделайте частную копию; если мы рефери, перестань реферировать; если мы глобус, переходите на xpvmg. См. Также &lt;code&gt;sv_force_normal_flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="translated">Недокументированные функции</target>
        </trans-unit>
        <trans-unit id="eed18284023acb946f22279a557b952faac276d4" translate="yes" xml:space="preserve">
          <source>Unfinished Tales</source>
          <target state="translated">Незаконченные сказки</target>
        </trans-unit>
        <trans-unit id="4df58040d6486eaa853729500be20c8509618322" translate="yes" xml:space="preserve">
          <source>Unfortunately it is not that difficult somehow manage to break one's Mac OS X Perl rather severely. If all else fails and you want to really, &lt;b&gt;REALLY&lt;/b&gt;, start from scratch and remove even your Apple Perl installation (which has become corrupted somehow), the following instructions should do it. &lt;b&gt;Please think twice before following these instructions: they are much like conducting brain surgery to yourself. Without anesthesia.&lt;/b&gt; We will &lt;b&gt;not&lt;/b&gt; come to fix your system if you do this.</source>
          <target state="translated">К сожалению, не так уж и сложно как-то серьезно взломать Mac OS X Perl. Если все остальное не удается, и вы действительно хотите, &lt;b&gt;ДЕЙСТВИТЕЛЬНО&lt;/b&gt; начать с нуля и удалить даже свою установку Apple Perl (которая каким-то образом была повреждена), следующие инструкции должны сделать это. &lt;b&gt;Пожалуйста, дважды подумайте, прежде чем следовать этим инструкциям: они очень похожи на операцию на головном мозге. Без анестезии. &lt;/b&gt;Мы &lt;b&gt;не&lt;/b&gt; будем исправлять вашу систему, если вы это сделаете.</target>
        </trans-unit>
        <trans-unit id="29de2b4590451aa9259989dd73cca2f011560c79" translate="yes" xml:space="preserve">
          <source>Unfortunately, I can't differentiate any further.</source>
          <target state="translated">К сожалению,я больше не могу различать.</target>
        </trans-unit>
        <trans-unit id="6e14820d498a0bc4a9f36bbc1285250e475a8eba" translate="yes" xml:space="preserve">
          <source>Unfortunately, a note cannot be used with the single argument style of &lt;code&gt;ok()&lt;/code&gt; . That is, if you try &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt;, then &lt;code&gt;Test&lt;/code&gt; will interpret this as &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt;, and probably end up testing &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; -- and that's not what you want!</source>
          <target state="translated">К сожалению, примечание нельзя использовать со стилем с одним аргументом &lt;code&gt;ok()&lt;/code&gt; . То есть, если вы попробуете &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;note&lt;/i&gt;)&lt;/code&gt; , тогда &lt;code&gt;Test&lt;/code&gt; будет интерпретировать это как &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; и, вероятно, закончит тестирование &lt;code&gt;&lt;i&gt;arg1&lt;/i&gt; eq &lt;i&gt;arg2&lt;/i&gt;&lt;/code&gt; - а это не то, что вам нужно!</target>
        </trans-unit>
        <trans-unit id="7f4f5938609da571758adb22fa6ce02f230693d9" translate="yes" xml:space="preserve">
          <source>Unfortunately, interpretation of colors 0 through 7 often depends on whether the emulator supports eight colors or sixteen colors. Emulators that only support eight colors (such as the Linux console) will display colors 0 through 7 with normal brightness and ignore colors 8 through 15, treating them the same as white. Emulators that support 16 colors, such as gnome-terminal, normally display colors 0 through 7 as dim or darker versions and colors 8 through 15 as normal brightness. On such emulators, the &quot;normal&quot; white (color 7) usually is shown as pale grey, requiring bright white (15) to be used to get a real white color. Bright black usually is a dark grey color, although some terminals display it as pure black. Some sixteen-color terminal emulators also treat normal yellow (color 3) as orange or brown, and bright yellow (color 11) as yellow.</source>
          <target state="translated">К сожалению,интерпретация цветов с 0 по 7 часто зависит от того,поддерживает ли эмулятор восемь или шестнадцать цветов.Эмуляторы,поддерживающие только восемь цветов (например,консоль Linux),будут отображать цвета с 0 по 7 с нормальной яркостью и игнорировать цвета с 8 по 15,рассматривая их как белые.Эмуляторы,поддерживающие 16 цветов,такие как гном-терминал,обычно отображают цвета с 0 по 7 как затемненные или более темные версии и цвета с 8 по 15 как нормальную яркость.На таких эмуляторах &quot;нормальный&quot; белый цвет (цвет 7)обычно отображается как бледно-серый,что требует использования яркого белого (15)для получения настоящего белого цвета.Яркий черный цвет обычно является темно-серым,хотя на некоторых терминалах он отображается как чистый черный.Около шестнадцати цветных терминальных эмуляторов также рассматривают нормальный желтый (цвет 3)как оранжевый или коричневый,а ярко-желтый (цвет 11)как желтый.</target>
        </trans-unit>
        <trans-unit id="d3f96232328f4faede427c8ce3041998253135ab" translate="yes" xml:space="preserve">
          <source>Unfortunately, it may be that encodings are not &lt;code&gt;PerlIO&lt;/code&gt; -savvy. You can check to see whether your encoding is supported by &lt;code&gt;PerlIO&lt;/code&gt; by invoking the &lt;code&gt;perlio_ok&lt;/code&gt; method on it:</source>
          <target state="translated">К сожалению, может случиться так, что кодировки не &lt;code&gt;PerlIO&lt;/code&gt; PerlIO. Вы можете проверить, поддерживается ли ваша кодировка &lt;code&gt;PerlIO&lt;/code&gt; , вызвав на &lt;code&gt;perlio_ok&lt;/code&gt; метод perlio_ok :</target>
        </trans-unit>
        <trans-unit id="fa870b38ba970158ffd4da6159a903c51d8f85af" translate="yes" xml:space="preserve">
          <source>Unfortunately, the original specification of UTF-8 leaves some room for interpretation of how many bytes of encoded output one should generate from one input Unicode character. Strictly speaking, the shortest possible sequence of UTF-8 bytes should be generated, because otherwise there is potential for an input buffer overflow at the receiving end of a UTF-8 connection. Perl always generates the shortest length UTF-8, and with warnings on, Perl will warn about non-shortest length UTF-8 along with other malformations, such as the surrogates, which are not Unicode code points valid for interchange.</source>
          <target state="translated">К сожалению,исходная спецификация UTF-8 оставляет некоторое пространство для интерпретации того,сколько байт кодированного вывода нужно сгенерировать из одного входного символа Unicode.Строго говоря,должна быть сгенерирована как можно более короткая последовательность байт UTF-8,так как в противном случае существует вероятность переполнения входного буфера на приемном конце соединения по UTF-8.Perl всегда генерирует самую короткую длину UTF-8,а при наличии предупреждений Perl будет предупреждать о не самой короткой длине UTF-8 наряду с другими пороками,такими как суррогаты,которые не являются действительными для обмена точками Юникод-кода.</target>
        </trans-unit>
        <trans-unit id="1170c59a72df3e22ea0a090adf0e9824ff8c0b09" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are quite a few deficiencies with the design (and often, the implementations) of locales. Unicode was invented (see &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for an introduction to that) in part to address these design deficiencies, and nowadays, there is a series of &quot;UTF-8 locales&quot;, based on Unicode. These are locales whose character set is Unicode, encoded in UTF-8. Starting in v5.20, Perl fully supports UTF-8 locales, except for sorting and string comparisons. (Use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; for these.) Perl continues to support the old non UTF-8 locales as well. There are currently no UTF-8 locales for EBCDIC platforms.</source>
          <target state="translated">К сожалению, в дизайне (а часто и в реализации) локалей есть немало недостатков. Юникод был изобретен (см. &lt;a href=&quot;perlunitut&quot;&gt;Введение в perlunitut&lt;/a&gt; ) отчасти для устранения этих недостатков дизайна, и в настоящее время существует серия &amp;laquo;локалей UTF-8&amp;raquo;, основанных на Unicode. Это языковые стандарты, набор символов которых - Unicode, закодированный в UTF-8. Начиная с версии 5.20, Perl полностью поддерживает локали UTF-8, за исключением сортировки и сравнения строк. (Для этого используйте &lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collate&lt;/a&gt; .) Perl продолжает поддерживать старые локали, отличные от UTF-8. В настоящее время нет локалей UTF-8 для платформ EBCDIC.</target>
        </trans-unit>
        <trans-unit id="c8d518114a049f78aefe7090de8efc32eccefc83" translate="yes" xml:space="preserve">
          <source>Unfortunately, this isn't true. In perl 5.18 and earlier, AVs use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a marker for indicating that an array element has not yet been initialized. Thus, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; would be true for the above Perl code, but false for the array generated by the XS code. In perl 5.20, storing &amp;amp;PL_sv_undef will create a read-only element, because the scalar &amp;amp;PL_sv_undef itself is stored, not a copy.</source>
          <target state="translated">К сожалению, это не так. В Perl 5.18 и ранее AV используют &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; в качестве маркера, указывающего, что элемент массива еще не инициализирован. Таким образом, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $av[0]&lt;/code&gt; будет истинным для указанного выше кода Perl, но ложным для массива, сгенерированного кодом XS. В Perl 5.20 сохранение &amp;amp; PL_sv_undef создаст элемент, доступный только для чтения, потому что сохраняется сам скаляр &amp;amp; PL_sv_undef, а не его копия.</target>
        </trans-unit>
        <trans-unit id="5a9b09da1b70d953819b14bad175ad6e8c81c049" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this &lt;code&gt;style&lt;/code&gt; variable is used to set defaults for all three directory hierarchies (core, vendor, and site), there is no guarantee that the same style is actually appropriate for all those directories. For example, $prefix might be</source>
          <target state="translated">К сожалению, хотя эта переменная &lt;code&gt;style&lt;/code&gt; используется для установки значений по умолчанию для всех трех иерархий каталогов (основная, поставщик и сайт), нет никакой гарантии, что один и тот же стиль действительно подходит для всех этих каталогов. Например, префикс $ может быть</target>
        </trans-unit>
        <trans-unit id="87c5d4faa14910842f5557a05819e468661f127e" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this is true, it's still broken. All the references in @AoA refer to the</source>
          <target state="translated">К сожалению,хотя это правда,она все еще сломана.Все ссылки в @AoA относятся к</target>
        </trans-unit>
        <trans-unit id="b3033d12e8c5e48f79875dd4cf162f90c243f353" translate="yes" xml:space="preserve">
          <source>Unfortunately, you may encounter Perl modules that are not</source>
          <target state="translated">К сожалению,вы можете столкнуться с модулями Perl,которые не являются</target>
        </trans-unit>
        <trans-unit id="76435dad798e21eb71def4f2d3a46ed9708e4adf" translate="yes" xml:space="preserve">
          <source>Unget a line of text from the server.</source>
          <target state="translated">Отключите строку текста с сервера.</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="eb802e96fd38e5e550d19f898a4fa941c45d6b21" translate="yes" xml:space="preserve">
          <source>Unicode 7.0 changed the wording so that they are &quot;&lt;b&gt;not recommended&lt;/b&gt; for use in open interchange of Unicode text data&quot;. The 7.0 Standard goes on to say:</source>
          <target state="translated">Unicode 7.0 изменил формулировки, так что они &amp;laquo; &lt;b&gt;не рекомендуются&lt;/b&gt; для использования при открытом обмене текстовыми данными Unicode&amp;raquo;. Стандарт 7.0 далее говорит:</target>
        </trans-unit>
        <trans-unit id="8306b01ff9c220d1ce9274f85cf12d457904d299" translate="yes" xml:space="preserve">
          <source>Unicode Character Properties</source>
          <target state="translated">Свойства символов Юникода</target>
        </trans-unit>
        <trans-unit id="2a76af7c10ae9a7945dc677634ff7f287d2f0d66" translate="yes" xml:space="preserve">
          <source>Unicode Collation Algorithm</source>
          <target state="translated">Алгоритм сопоставления Unicode</target>
        </trans-unit>
        <trans-unit id="8a8a7bf1ba1b9e4c2b07e9ad90fbd26463e5d980" translate="yes" xml:space="preserve">
          <source>Unicode Consortium</source>
          <target state="translated">Консорциум Юникод</target>
        </trans-unit>
        <trans-unit id="b56cce9c1325a6619b09abb29a03b2934dad13be" translate="yes" xml:space="preserve">
          <source>Unicode Encodings</source>
          <target state="translated">Юникод Кодировки</target>
        </trans-unit>
        <trans-unit id="20d826b4f354ace01634ff9215d461c1d2de2da2" translate="yes" xml:space="preserve">
          <source>Unicode FAQ</source>
          <target state="translated">Юникод FAQ</target>
        </trans-unit>
        <trans-unit id="be2c3b070e201b30c780f442801bee53720d3f02" translate="yes" xml:space="preserve">
          <source>Unicode Glossary</source>
          <target state="translated">Юникод Глоссарий</target>
        </trans-unit>
        <trans-unit id="c37be50216d5f3d38f1ea9b4becfe8758aaff3f3" translate="yes" xml:space="preserve">
          <source>Unicode I/O</source>
          <target state="translated">Юникодный ввод/вывод</target>
        </trans-unit>
        <trans-unit id="4f977034e8571e3a210188dcc1d8385457a8e9f6" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms</source>
          <target state="translated">Формы нормализации Юникода</target>
        </trans-unit>
        <trans-unit id="775e22294d31686679c1488c3a4e009b588fb93a" translate="yes" xml:space="preserve">
          <source>Unicode Normalization Forms - UAX #15</source>
          <target state="translated">Формы нормализации Юникода-UAX #15</target>
        </trans-unit>
        <trans-unit id="41086ae1277eac703b49ed9c64da7c4e1e028776" translate="yes" xml:space="preserve">
          <source>Unicode Properties</source>
          <target state="translated">Свойства Юникода</target>
        </trans-unit>
        <trans-unit id="ecfb52e522a545f9d54db78a273755a7cf69910d" translate="yes" xml:space="preserve">
          <source>Unicode Recommended Reading List</source>
          <target state="translated">Рекомендуемый список для чтения в Юникоде</target>
        </trans-unit>
        <trans-unit id="3dc43797a086d2e60b97e26ddbcd0e763ba2be44" translate="yes" xml:space="preserve">
          <source>Unicode Regular Expression Support Level</source>
          <target state="translated">Уровень поддержки регулярных выражений Юникода</target>
        </trans-unit>
        <trans-unit id="47be4025952fbf3894ef86d325a9d331d9d77d10" translate="yes" xml:space="preserve">
          <source>Unicode Support</source>
          <target state="translated">Поддержка Юникода</target>
        </trans-unit>
        <trans-unit id="3b3c1f4d1dbf76960cd965f0a9ee21a6e35c74bd" translate="yes" xml:space="preserve">
          <source>Unicode Useful Resources</source>
          <target state="translated">Полезные ресурсы Юникода</target>
        </trans-unit>
        <trans-unit id="0bd38e8f5dc5fab318029c6a0f6bf740c02237f9" translate="yes" xml:space="preserve">
          <source>Unicode aims to &lt;b&gt;UNI&lt;/b&gt;-fy the en-&lt;b&gt;CODE&lt;/b&gt;-ings of all the world's character sets into a single Standard. For quite a few of the various coding standards that existed when Unicode was first created, converting from each to Unicode essentially meant adding a constant to each code point in the original standard, and converting back meant just subtracting that same constant. For ASCII and ISO-8859-1, the constant is 0. For ISO-8859-5, (Cyrillic) the constant is 864; for Hebrew (ISO-8859-8), it's 1488; Thai (ISO-8859-11), 3424; and so forth. This made it easy to do the conversions, and facilitated the adoption of Unicode.</source>
          <target state="translated">Unicode цели в &lt;b&gt;UNI&lt;/b&gt; -fy на встре- &lt;b&gt;CODE&lt;/b&gt; -ings всех наборов символов мира в единый стандарт. Для довольно многих из различных стандартов кодирования, существовавших при первом создании Unicode, преобразование каждого из них в Unicode по существу означало добавление константы к каждой кодовой точке в исходном стандарте, а обратное преобразование означало просто вычитание той же константы. Для ASCII и ISO-8859-1 константа равна 0. Для ISO-8859-5 (кириллица) константа равна 864; для иврита (ISO-8859-8) это 1488 год; Тайский (ISO-8859-11), 3424; и так далее. Это упростило преобразование и способствовало принятию Unicode.</target>
        </trans-unit>
        <trans-unit id="292b5cfbcdb907b6b9b2852bab43a1e41959e1df" translate="yes" xml:space="preserve">
          <source>Unicode also defines various</source>
          <target state="translated">Юникод также определяет различные</target>
        </trans-unit>
        <trans-unit id="bfb017bed191925e52b6029168924ebfe8c5d26c" translate="yes" xml:space="preserve">
          <source>Unicode and EBCDIC</source>
          <target state="translated">Юникод и EBCDIC</target>
        </trans-unit>
        <trans-unit id="e27520c25eb75e7d79e8f990eeb1be4ae1df41df" translate="yes" xml:space="preserve">
          <source>Unicode and ISO/IEC 10646 are coordinated standards that unify almost all other modern character set standards, covering more than 80 writing systems and hundreds of languages, including all commercially-important modern languages. All characters in the largest Chinese, Japanese, and Korean dictionaries are also encoded. The standards will eventually cover almost all characters in more than 250 writing systems and thousands of languages. Unicode 1.0 was released in October 1991, and 6.0 in October 2010.</source>
          <target state="translated">Unicode и ISO/IEC 10646-это согласованные стандарты,которые объединяют почти все другие современные стандарты набора символов,охватывающие более 80 систем письма и сотни языков,включая все коммерчески значимые современные языки.Все иероглифы в крупнейших китайском,японском и корейском словарях также закодированы.Стандарты в конечном итоге охватят почти все иероглифы в более чем 250 системах письменности и тысячах языков.Юникод 1.0 был выпущен в октябре 1991 года,а 6.0-в октябре 2010 года.</target>
        </trans-unit>
        <trans-unit id="35759c0ae04781f6ce2a8261ef308a0d62267332" translate="yes" xml:space="preserve">
          <source>Unicode and Localisation Support</source>
          <target state="translated">Поддержка Юникода и локализации</target>
        </trans-unit>
        <trans-unit id="c79347889e0d28fc8f7e3b48dc5c985da6b9c2b3" translate="yes" xml:space="preserve">
          <source>Unicode and Multilingual Support in HTML, Fonts, Web Browsers and Other Applications</source>
          <target state="translated">Юникод и многоязычная поддержка в HTML,шрифтах,веб-браузерах и других приложениях</target>
        </trans-unit>
        <trans-unit id="aa0a00bb85a8ade7272b8fa2d081ab3abd746b2c" translate="yes" xml:space="preserve">
          <source>Unicode and UTF</source>
          <target state="translated">Юникод и UTF</target>
        </trans-unit>
        <trans-unit id="8e9632880dc5b73eee711bbb8acae51558160af7" translate="yes" xml:space="preserve">
          <source>Unicode and UTF-8</source>
          <target state="translated">Юникод и UTF-8</target>
        </trans-unit>
        <trans-unit id="814213da4f2b17caa9167081f902458536e3ac5c" translate="yes" xml:space="preserve">
          <source>Unicode casing is very different from ASCII casing.</source>
          <target state="translated">Корпус Unicode очень отличается от корпуса ASCII.</target>
        </trans-unit>
        <trans-unit id="3db087027c1f3fb2dafc91bf1aec8e28ed66555f" translate="yes" xml:space="preserve">
          <source>Unicode character database</source>
          <target state="translated">База данных символов Юникода</target>
        </trans-unit>
        <trans-unit id="90ce74ac0f978040e744ea5f9ee3a9fc0fdd5b56" translate="yes" xml:space="preserve">
          <source>Unicode character properties that are NOT accepted by Perl</source>
          <target state="translated">Свойства символов Юникода,которые НЕ принимаются Perl</target>
        </trans-unit>
        <trans-unit id="131ad96e9210c062a5a91bbff68adb3c52f574b9" translate="yes" xml:space="preserve">
          <source>Unicode characters are assigned to</source>
          <target state="translated">Символам Юникода присваиваются</target>
        </trans-unit>
        <trans-unit id="9cd8bdcde375ab8cc6d64998c61f22e2b1db366b" translate="yes" xml:space="preserve">
          <source>Unicode characters have a Unicode name and numeric code point (ordinal) value. Use the &lt;code&gt;\N{}&lt;/code&gt; construct to specify a character by either of these values. Certain sequences of characters also have names.</source>
          <target state="translated">У символов Юникода есть имя Юникода и числовое значение (порядковый номер). Используйте конструкцию &lt;code&gt;\N{}&lt;/code&gt; чтобы указать символ любым из этих значений. У некоторых последовательностей символов также есть имена.</target>
        </trans-unit>
        <trans-unit id="210080ef48f936087dda80492d9856fe5ec4b9bc" translate="yes" xml:space="preserve">
          <source>Unicode classes</source>
          <target state="translated">Классы Юникода</target>
        </trans-unit>
        <trans-unit id="0f01459324a40b9e6a3a0e387cbfebfba5b6c62c" translate="yes" xml:space="preserve">
          <source>Unicode code points versus EBCDIC code points</source>
          <target state="translated">точки кода Юникод против точек кода EBCDIC</target>
        </trans-unit>
        <trans-unit id="7625e9ef1dd87171eb4d5354c03dd9be33744a1d" translate="yes" xml:space="preserve">
          <source>Unicode codepoint</source>
          <target state="translated">кодовая точка Юникода</target>
        </trans-unit>
        <trans-unit id="106885fd8f00b6d1d3909f50579c6a1e81f50c34" translate="yes" xml:space="preserve">
          <source>Unicode concept which most often is equal to uppercase, but for certain characters like the German &quot;sharp s&quot; there is a difference.</source>
          <target state="translated">Понятие Юникод,которое чаще всего равно заглавным,но для некоторых символов,таких как немецкий &quot;sharp s&quot;,есть разница.</target>
        </trans-unit>
        <trans-unit id="d49075f8dbc705f2f67ea7272b64074e286787f2" translate="yes" xml:space="preserve">
          <source>Unicode defines a fourth boundary type, accessible through the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt; module.</source>
          <target state="translated">Unicode определяет четвертый тип границы, доступный через модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::LineBreak&quot;&gt;Unicode :: LineBreak&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07aa50c4f0010de0db76a15f32c4e153b24a7275" translate="yes" xml:space="preserve">
          <source>Unicode defines all its properties in the compound form, so all single-form properties are Perl extensions. Most of these are just synonyms for the Unicode ones, but some are genuine extensions, including several that are in the compound form. And quite a few of these are actually recommended by Unicode (in &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt;).</source>
          <target state="translated">Unicode определяет все свои свойства в составной форме, поэтому все свойства единой формы являются расширениями Perl. Большинство из них - просто синонимы для Unicode, но некоторые из них являются настоящими расширениями, в том числе некоторые, которые находятся в составной форме. И довольно много из них действительно рекомендовано Unicode ( &lt;a href=&quot;http://www.unicode.org/reports/tr18&quot;&gt;http://www.unicode.org/reports/tr18&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8557c4367cf0c9f30d95a470ee521928d669fb7c" translate="yes" xml:space="preserve">
          <source>Unicode defines characters like &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; or &lt;code&gt;GREEK
SMALL LETTER ALPHA&lt;/code&gt; and unique numbers for the characters, in this case 0x0041 and 0x03B1, respectively. These unique numbers are called</source>
          <target state="translated">Unicode определяет такие символы, как &lt;code&gt;LATIN CAPITAL LETTER A&lt;/code&gt; или ГРЕЧЕСКАЯ СТРОЧНАЯ &lt;code&gt;GREEK SMALL LETTER ALPHA&lt;/code&gt; и уникальные числа для символов, в данном случае 0x0041 и 0x03B1 соответственно. Эти уникальные номера называются</target>
        </trans-unit>
        <trans-unit id="66287c5bc6e75d359bae32c20cfc35103e105bf3" translate="yes" xml:space="preserve">
          <source>Unicode does define several other decimal--and numeric--characters besides the familiar 0 to 9, such as the Arabic and Indic digits. Perl does not support string-to-number conversion for digits other than ASCII &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; (and ASCII &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; for hexadecimal). To get safe conversions from any Unicode string, use &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Unicode определяет несколько других десятичных и числовых символов, помимо знакомых от 0 до 9, таких как арабские и индийские цифры. Perl не поддерживает преобразование строки в число для цифр, отличных от ASCII от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;9&lt;/code&gt; (и ASCII от &lt;code&gt;a&lt;/code&gt; до &lt;code&gt;f&lt;/code&gt; для шестнадцатеричных). Чтобы получить безопасные преобразования из любой строки Unicode, используйте &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num () в Unicode :: UCD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0b4309884526bd11fe1ab30cc9fc6ed43648809" translate="yes" xml:space="preserve">
          <source>Unicode form that is useful when comparing strings regardless of case, as certain characters have complex one-to-many case mappings. Primarily a variant of lowercase.</source>
          <target state="translated">Юникодовая форма,которая полезна при сравнении строк вне зависимости от регистра,так как некоторые символы имеют сложное отображение от одного до нескольких регистров.В основном это вариант строчного кода.</target>
        </trans-unit>
        <trans-unit id="71079ed61722f43474765527d68998144c7665d4" translate="yes" xml:space="preserve">
          <source>Unicode furnishes the &lt;code&gt;Age&lt;/code&gt; property from which this is derived. The problem with Age is that a strict interpretation of it (which Perl takes) has it matching the precise release a code point's meaning is introduced in. Thus &lt;code&gt;U+0041&lt;/code&gt; would match only 1.1; and &lt;code&gt;U+1EFF&lt;/code&gt; only 5.1. This is not usually what you want.</source>
          <target state="translated">Unicode предоставляет свойство &lt;code&gt;Age&lt;/code&gt; , из которого оно получено. Проблема с Age заключается в том, что при строгой его интерпретации (которую принимает Perl) он соответствует точному выпуску, в котором вводится значение кодовой точки. Таким образом, &lt;code&gt;U+0041&lt;/code&gt; будет соответствовать только 1.1; и только &lt;code&gt;U+1EFF&lt;/code&gt; 5.1. Обычно это не то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="fd3ab6b6f70f7431b1416e0f9107c1af48c38649" translate="yes" xml:space="preserve">
          <source>Unicode has some property-value pairs that currently don't match anything. This happens generally either because they are obsolete, or they exist for symmetry with other forms, but no language has yet been encoded that uses them. In this version of Unicode, the following match zero code points:</source>
          <target state="translated">У Юникода есть несколько пар свойств,которые на данный момент ни с чем не совпадают.Обычно это происходит либо потому,что они устарели,либо потому,что они существуют для симметрии с другими формами,но ни один язык ещё не закодирован,который их использует.В этой версии Юникода следующие совпадают с нулевыми точками кода:</target>
        </trans-unit>
        <trans-unit id="73c49c9d36b230f185c7169c7475e8856ddbd520" translate="yes" xml:space="preserve">
          <source>Unicode in Perl on EBCDIC</source>
          <target state="translated">Юникод в Perl на EBCDIC</target>
        </trans-unit>
        <trans-unit id="5a2ff10d38459692f18fa8f0d5e12e0027770ead" translate="yes" xml:space="preserve">
          <source>Unicode is a character set standard which plans to codify all of the writing systems of the world, plus many other symbols.</source>
          <target state="translated">Юникод-это стандарт набора символов,который планирует кодифицировать все системы письма мира,а также многие другие символы.</target>
        </trans-unit>
        <trans-unit id="3bb1c5615f2383d427b4613073ef1ec435b5138c" translate="yes" xml:space="preserve">
          <source>Unicode is a character set that can represent most characters in most of the world's languages, providing room for over one million different characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin characters are assigned to the numbers 0 - 127. The Latin-1 Supplement with characters that are used in several European languages is in the next range, up to 255. After some more Latin extensions we find the character sets from languages using non-Roman alphabets, interspersed with a variety of symbol sets such as currency symbols, Zapf Dingbats or Braille. (You might want to visit &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for a look at some of them - my personal favourites are Telugu and Kannada.)</source>
          <target state="translated">Юникод - это набор символов, который может представлять большинство символов на большинстве языков мира, обеспечивая место для более одного миллиона различных символов. Unicode 3.1 определяет 94 140 символов: базовые латинские символы присваиваются числам от 0 до 127. Дополнение Latin-1 с символами, которые используются в нескольких европейских языках, находится в следующем диапазоне, до 255. После некоторых дополнительных латинских расширений мы находим наборы символов из языков, использующих нелатинские алфавиты, с вкраплениями различных наборов символов, таких как символы валюты, дингбаты Zapf или шрифт Брайля. (Вы можете посетить &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/,&lt;/a&gt; чтобы ознакомиться с некоторыми из них - мои личные фавориты - телугу и каннада.)</target>
        </trans-unit>
        <trans-unit id="bb4b52a0e0d40f8cd4680e731fa8661db40b7bfb" translate="yes" xml:space="preserve">
          <source>Unicode is a comprehensive standard. It specifies many things outside the scope of Perl, such as how to display sequences of characters. For a full discussion of all aspects of Unicode, see &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">Юникод - это всеобъемлющий стандарт. Он определяет многие вещи, выходящие за рамки Perl, например, как отображать последовательности символов. Для полного обсуждения всех аспектов Unicode см. &lt;a href=&quot;http://www.unicode.org&quot;&gt;Http://www.unicode.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38d8bac67762b71e3e301bd389dd5bf647e3a7f7" translate="yes" xml:space="preserve">
          <source>Unicode is a new and complex technology and one may easily overlook certain security pitfalls. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; for an overview and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details, and &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;Security Implications of Unicode in perlunicode&lt;/a&gt; for security implications in particular.</source>
          <target state="translated">Unicode - это новая и сложная технология, и можно легко упустить из виду некоторые подводные камни. См. &lt;a href=&quot;perluniintro&quot;&gt;Perluniintro&lt;/a&gt; для обзора и &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; для подробностей, а также &lt;a href=&quot;perlunicode#Security-Implications-of-Unicode&quot;&gt;Последствия безопасности Unicode в perlunicode&lt;/a&gt; для безопасности, в частности.</target>
        </trans-unit>
        <trans-unit id="2819bd58737a8580070f8ba307d9387529fe1cef" translate="yes" xml:space="preserve">
          <source>Unicode is encoded using several competing encodings, of which UTF-8 is the most used. In a Unicode encoding, multiple subsequent bytes can be used to store a single code point, or simply: character.</source>
          <target state="translated">Юникод кодируется с использованием нескольких конкурирующих кодировок,из которых наиболее часто используется UTF-8.В кодировке Юникода несколько последующих байтов могут быть использованы для хранения одной точки кода,или просто:символа.</target>
        </trans-unit>
        <trans-unit id="5a66fde7942a6271294a3a5979cbe3017c3d5acd" translate="yes" xml:space="preserve">
          <source>Unicode is supported on EBCDIC platforms. See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;.</source>
          <target state="translated">Юникод поддерживается на платформах EBCDIC. См. &lt;a href=&quot;perlebcdic&quot;&gt;Perlebcdic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="989d0062ad097f9dec3fa95782856724eb6165aa" translate="yes" xml:space="preserve">
          <source>Unicode promises that the set of code points that have these two properties will never change, so something that is not quoted in v5.16 will never need to be quoted in any future Perl release. (Not all the code points that match Pattern_Syntax have actually had characters assigned to them; so there is room to grow, but they are quoted whether assigned or not. Perl, of course, would never use an unassigned code point as an actual metacharacter.)</source>
          <target state="translated">Юникод обещает,что набор точек кода,которые имеют эти два свойства,никогда не изменится,поэтому то,что не цитируется в версии v5.16,никогда не нужно будет цитировать в любом будущем релизе Perl.(Не все точки кода,которые соответствуют синтаксису Pattern_Syntax,на самом деле имеют назначенные им символы;так что есть место для роста,но они цитируются независимо от того,назначены они или нет.Perl,конечно,никогда бы не использовал неприсвоенную кодовую точку в качестве фактического метахарафа).</target>
        </trans-unit>
        <trans-unit id="fb2ca4e28ea7e22cfa06c89ba6c3b93dca994a19" translate="yes" xml:space="preserve">
          <source>Unicode properties are defined (surprise!) only on Unicode code points. Starting in v5.20, when matching against &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; , Perl treats non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF) as if they were typical unassigned Unicode code points.</source>
          <target state="translated">Свойства Unicode определены (сюрприз!) Только в кодовых точках Unicode. Начиная с v5.20, при сопоставлении с &lt;code&gt;\p&lt;/code&gt; и &lt;code&gt;\P&lt;/code&gt; Perl обрабатывает кодовые точки, отличные от Unicode (те, которые превышают допустимый максимум Unicode, равный 0x10FFFF), как если бы они были типичными неназначенными кодовыми точками Unicode.</target>
        </trans-unit>
        <trans-unit id="139a9bb1fddefbaa23b5411336f2d45c5af1add3" translate="yes" xml:space="preserve">
          <source>Unicode publishes the names of blocks in two different styles, though the two are equivalent under Unicode's loose matching rules.</source>
          <target state="translated">Юникод публикует названия блоков в двух различных стилях,хотя эти два стиля эквивалентны правилам свободного совпадения Юникода.</target>
        </trans-unit>
        <trans-unit id="38ecc57a7a45e8fa0530ba908225186656979efa" translate="yes" xml:space="preserve">
          <source>Unicode rules are used for the case change.</source>
          <target state="translated">Для изменения регистра используются правила Юникода.</target>
        </trans-unit>
        <trans-unit id="7088ba3066aa65d6bcc96771fbb92a42fd96dcd6" translate="yes" xml:space="preserve">
          <source>Unicode support is an extensive requirement. While Perl does not implement the Unicode standard or the accompanying technical reports from cover to cover, Perl does support many Unicode features.</source>
          <target state="translated">Поддержка Юникода является обширным требованием.Несмотря на то,что Perl не реализует стандарт Юникода и сопровождающие его технические отчеты от корки до корки,Perl поддерживает многие функции Юникода.</target>
        </trans-unit>
        <trans-unit id="b8b243e5f3e426dd36737b42e29d2ec9970a7c1a" translate="yes" xml:space="preserve">
          <source>Unicode, of course, assigns each of those code points a particular meaning (along with ones above 255). To preserve backward compatibility, Perl only uses the Unicode meanings when there is some indication that Unicode is what is intended; otherwise the non-ASCII code points remain treated as if they are unassigned.</source>
          <target state="translated">Юникод,конечно,присваивает каждому из этих кодовых точек определенное значение (наряду с теми,что выше 255).Чтобы сохранить обратную совместимость,Perl использует значения Юникода только в том случае,если есть какой-то признак того,что Юникод-это то,что предназначено;в противном случае,точки,не относящиеся к коду ASCII,остаются неприсвоенными.</target>
        </trans-unit>
        <trans-unit id="21276899f4cb4b0159879360c7526c4fe6c28316" translate="yes" xml:space="preserve">
          <source>Unicode/Collate</source>
          <target state="translated">Unicode/Collate</target>
        </trans-unit>
        <trans-unit id="37148638183749a1c0b03d85014634d4e43c64c4" translate="yes" xml:space="preserve">
          <source>Unicode/Collate/Foo.txt</source>
          <target state="translated">Unicode/Collate/Foo.txt</target>
        </trans-unit>
        <trans-unit id="f77e952a14d870cb3ae7b18f391e8c5f3d325575" translate="yes" xml:space="preserve">
          <source>Unicode::Collate</source>
          <target state="translated">Unicode::Collate</target>
        </trans-unit>
        <trans-unit id="3ff519c896603d01c9e76e4f19191f11d112327a" translate="yes" xml:space="preserve">
          <source>Unicode::Collate - Unicode Collation Algorithm</source>
          <target state="translated">Юникод::Сбор-Алгоритм суммирования Юникода</target>
        </trans-unit>
        <trans-unit id="72b47eca97eb095d02921b6571fab1a6dfdb0bc0" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize</source>
          <target state="translated">Unicode::Normalize</target>
        </trans-unit>
        <trans-unit id="2e61bd2963848230702b059b3f915c279424ceeb" translate="yes" xml:space="preserve">
          <source>Unicode::Normalize - Unicode Normalization Forms</source>
          <target state="translated">Юникод::Нормализовать-Формы нормализации Юникода</target>
        </trans-unit>
        <trans-unit id="58e1ebb138145877210bc1aaddb6a695f639333f" translate="yes" xml:space="preserve">
          <source>Unicode::UCD</source>
          <target state="translated">Unicode::UCD</target>
        </trans-unit>
        <trans-unit id="878eb3fe5907f3dbbef3993a9d210c838c3bd0a6" translate="yes" xml:space="preserve">
          <source>Unicode::UCD - Unicode character database</source>
          <target state="translated">Юникод::UCD-база данных символов Юникода</target>
        </trans-unit>
        <trans-unit id="b0e10771734c32d2d9e8385457afb6c4bd746163" translate="yes" xml:space="preserve">
          <source>Unicode::UCD::UnicodeVersion</source>
          <target state="translated">Unicode::UCD::UnicodeVersion</target>
        </trans-unit>
        <trans-unit id="c884d01b9429a9f7304a835d13687b8ca5872d3c" translate="yes" xml:space="preserve">
          <source>Unified method to both set and get options in the SOL_SOCKET level. If called with one argument then getsockopt is called, otherwise setsockopt is called.</source>
          <target state="translated">Унифицированный метод как для установки,так и для получения опций на уровне SOL_SOCKET.Если вызывается с одним аргументом,то вызывается getockopt,в противном случае вызывается setsockopt.</target>
        </trans-unit>
        <trans-unit id="238642af65f3add9fa062158d9a8954a0d8cc5fc" translate="yes" xml:space="preserve">
          <source>Unimplemented, but you can use &lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; and the &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module to achieve similar things.</source>
          <target state="translated">Не реализовано, но вы можете использовать &lt;a href=&quot;functions/die&quot;&gt;кубик&lt;/a&gt; и модуль &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; для достижения аналогичных целей.</target>
        </trans-unit>
        <trans-unit id="c6635fe323dcba6e8b8b2d5cdbb340361ce906ed" translate="yes" xml:space="preserve">
          <source>Universal Binary support</source>
          <target state="translated">Универсальная поддержка двоичных файлов</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="2fb49d2b5adcca8ced12a532099ac9adce5647b1" translate="yes" xml:space="preserve">
          <source>Unix Network Programming, 2nd Edition, Volume 1</source>
          <target state="translated">Сетевое программирование Unix,2-е издание,том 1.</target>
        </trans-unit>
        <trans-unit id="b4c5506923f63fcc0ec2a3603b475130b23382af" translate="yes" xml:space="preserve">
          <source>Unix Review</source>
          <target state="translated">Обзор Unix</target>
        </trans-unit>
        <trans-unit id="4b39a128140df62988dc25aafca006880dd71ad2" translate="yes" xml:space="preserve">
          <source>Unix has no need of special linker flags.</source>
          <target state="translated">Unix не нуждается в специальных флагах компоновщика.</target>
        </trans-unit>
        <trans-unit id="faa3f11d873bf24fcae352a27226c0c2e88d087f" translate="yes" xml:space="preserve">
          <source>Unix's &lt;code&gt;#!&lt;/code&gt; technique can be simulated on other systems:</source>
          <target state="translated">&lt;code&gt;#!&lt;/code&gt; Unix ! Техника может быть смоделирована на других системах:</target>
        </trans-unit>
        <trans-unit id="7f87c004392cd89a556aff5f86328de12b9ca773" translate="yes" xml:space="preserve">
          <source>Unix-Domain TCP Clients and Servers</source>
          <target state="translated">Unix-доменные TCP клиенты и серверы</target>
        </trans-unit>
        <trans-unit id="4acfa258fe45e38658aa00a5dfda8b8abeddb8cc" translate="yes" xml:space="preserve">
          <source>Unix-domain sockets on OS/2 live in a pseudo-file-system &lt;code&gt;/sockets/...&lt;/code&gt; . To avoid a failure to create a socket with a name of a different form, &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; is prepended to the socket name (unless it starts with this already).</source>
          <target state="translated">Unix-сокеты на OS / 2 живут в псевдо-файловой системы &lt;code&gt;/sockets/...&lt;/code&gt; . Чтобы избежать сбоя при создании сокета с именем другой формы, к имени сокета добавляется &lt;code&gt;&quot;/socket/&quot;&lt;/code&gt; (если оно уже не начинается с этого).</target>
        </trans-unit>
        <trans-unit id="4f3c45c8b86738464ace2f8005c8fbdecfe76366" translate="yes" xml:space="preserve">
          <source>Unix.U</source>
          <target state="translated">Unix.U</target>
        </trans-unit>
        <trans-unit id="516d733c8bf9db439f1f86408315d55784a8e43c" translate="yes" xml:space="preserve">
          <source>Unknown '=xxxx' commands, unknown 'X&amp;lt;...&amp;gt;' interior-sequences, and unterminated interior sequences.</source>
          <target state="translated">Неизвестные команды '= xxxx', неизвестные внутренние последовательности 'X &amp;lt;...&amp;gt;' и незавершенные внутренние последовательности.</target>
        </trans-unit>
        <trans-unit id="48c5c163aa1fa71615dee0d3c90ca77bf54723d6" translate="yes" xml:space="preserve">
          <source>Unknown result token.</source>
          <target state="translated">Неизвестный жетон результата.</target>
        </trans-unit>
        <trans-unit id="4013e411624fa8892f8200feafb69475d2458d0b" translate="yes" xml:space="preserve">
          <source>Unknowns are &lt;code&gt;&quot;-&quot;&lt;/code&gt; . Unknowns can happen unfortunately quite easily: if the platform doesn't support retrieving the information; if the binary is missing the debug information; if the optimizer has transformed the code by for example inlining.</source>
          <target state="translated">Неизвестные - &lt;code&gt;&quot;-&quot;&lt;/code&gt; . К сожалению, неизвестность может произойти довольно легко: если платформа не поддерживает получение информации; если в двоичном файле отсутствует отладочная информация; если оптимизатор преобразовал код, например, встраивая.</target>
        </trans-unit>
        <trans-unit id="ce906b20ea9a7a0bf0bcbae85c1c9421e3de60b2" translate="yes" xml:space="preserve">
          <source>Unless %hash has already been locked the key/value could be deleted regardless of this setting.</source>
          <target state="translated">Если %hash уже не был заблокирован,ключ/значение может быть удален вне зависимости от этой настройки.</target>
        </trans-unit>
        <trans-unit id="5c6af5673dc4ae00136df64bec88a6550bf388e5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are set to &quot;&lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt;&quot;. Therefore,</source>
          <target state="translated">Если &lt;code&gt;${^UNICODE}&lt;/code&gt; (доступно начиная с v5.8.2) не существует и не равно нулю, уровни PerlIO для &lt;code&gt;STDIN&lt;/code&gt; и &lt;code&gt;STDOUT&lt;/code&gt; устанавливаются в &quot; &lt;code&gt;:encoding(&lt;i&gt;ENCNAME&lt;/i&gt;)&lt;/code&gt; &quot;. Следовательно,</target>
        </trans-unit>
        <trans-unit id="c4a238cf9ea26a0e7ddfda497c5bf0d771bd8656" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; is also compiled, the logging functions read $ENV{PERL_MEM_LOG} to determine whether to log the event, and if so how:</source>
          <target state="translated">Если &lt;code&gt;-DPERL_MEM_LOG_NOIMPL&lt;/code&gt; также не скомпилирован, функции ведения журнала читают $ ENV {PERL_MEM_LOG}, чтобы определить, регистрировать ли событие, и если да, то как:</target>
        </trans-unit>
        <trans-unit id="7183c27cf3fecde6bcc64c00a3a891d43f73c77b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; is set to &lt;code&gt;T&lt;/code&gt; (and the kernel is after 2000/09/01), such DLLs are considered to be global. When loading a global DLL it is first looked in the table of already-loaded global DLLs. Because of this the fact that one executable loaded a DLL from &lt;code&gt;BEGINLIBPATH&lt;/code&gt; and &lt;code&gt;ENDLIBPATH&lt;/code&gt; , or</source>
          <target state="translated">Если для &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; не задано значение &lt;code&gt;T&lt;/code&gt; (а ядро ​​- после 2000/09/01), такие библиотеки DLL считаются глобальными. При загрузке глобальной DLL она сначала просматривается в таблице уже загруженных глобальных DLL. Из-за этого тот факт, что один исполняемый файл загрузил DLL из &lt;code&gt;BEGINLIBPATH&lt;/code&gt; и &lt;code&gt;ENDLIBPATH&lt;/code&gt; , или</target>
        </trans-unit>
        <trans-unit id="025ed2d87cd53899da043f16934d54b56cb767cf" translate="yes" xml:space="preserve">
          <source>Unless ASCII vs. EBCDIC issues are specifically being discussed, references to UTF-8 encoding in this document and elsewhere should be read as meaning UTF-EBCDIC on EBCDIC platforms. See &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;Unicode and UTF in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">Если вопросы ASCII и EBCDIC не обсуждаются специально, ссылки на кодировку UTF-8 в этом документе и в других местах следует понимать как означающие UTF-EBCDIC на платформах EBCDIC. См. &lt;a href=&quot;perlebcdic#Unicode-and-UTF&quot;&gt;Unicode и UTF в perlebcdic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="763e516abf0169c17797549989072db7b3b436d9" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, functions return 0 on success, or a negative value (usually &lt;code&gt;EOF&lt;/code&gt; which is usually -1) and set &lt;code&gt;errno&lt;/code&gt; on error.</source>
          <target state="translated">Если не указано иное, функции возвращают 0 в случае успеха или отрицательное значение (обычно &lt;code&gt;EOF&lt;/code&gt; , которое обычно равно -1) и устанавливают &lt;code&gt;errno&lt;/code&gt; в случае ошибки.</target>
        </trans-unit>
        <trans-unit id="843ebacc41e4317d9c7bf3f947fad475a9e1f11b" translate="yes" xml:space="preserve">
          <source>Unless otherwise notes, all examples below require this standard preamble to work correctly, with the &lt;code&gt;#!&lt;/code&gt; adjusted to work on your system:</source>
          <target state="translated">Если не указано иное, все приведенные ниже примеры требуют, чтобы эта стандартная преамбула работала правильно, с символом &lt;code&gt;#!&lt;/code&gt; настроен для работы в вашей системе:</target>
        </trans-unit>
        <trans-unit id="519ecd12b4838877006c606ab377c9933076da06" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated all methods return either a</source>
          <target state="translated">Если не указано иначе,все методы возвращают</target>
        </trans-unit>
        <trans-unit id="58c869a304e00ffd24d619f7d44db8d57f44a80c" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated it works just like ExtUtils::MM_Unix</source>
          <target state="translated">Если не указано иначе,он работает так же,как ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="caa9da45012bfbe0b5378d58f4fff0a9abfa58b5" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, it works just like ExtUtils::MM_Unix</source>
          <target state="translated">Если не указано иначе,он работает так же,как и ExtUtils::MM_Unix.</target>
        </trans-unit>
        <trans-unit id="42e400a7ab19dec964d9377da14546fab4feb3ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, дополнительные параметры для &lt;code&gt;anyinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же , как те , которые используются с интерфейсом ОО , определенным в &lt;a href=&quot;#Constructor-Options&quot;&gt;конструкторе Параметры&lt;/a&gt; раздел ниже.</target>
        </trans-unit>
        <trans-unit id="47a707f463b0bb3f1b25444c520600dbd6696505" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, дополнительные параметры для &lt;code&gt;anyuncompress&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же , как те , которые используются с интерфейсом ОО , определенным в &lt;a href=&quot;#Constructor-Options&quot;&gt;конструкторе Параметры&lt;/a&gt; раздел ниже.</target>
        </trans-unit>
        <trans-unit id="d669d839575081392547a5a9cafaedbd09bec28c" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bunzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;bunzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="5cd0d3bee7135d518d8ccc595535d8b3eccde37f" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;bzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;bzip2&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="2d2f8a94031befaa66720968f47bd4dde9da6fcf" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="f180e51799fa543d0272bd825b3d860097f806c2" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;gunzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="43b54de84f56f9f511018d58087cdd33377321ec" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="d8c0791fbf600370c86e6ae040e4b2abd896e9ba" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;inflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;inflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="e65e4b1379d48c357409defc2e3a088bfcc64051" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указаны ниже, дополнительные параметры для &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же , как те , которые используются с интерфейсом ОО , определенным в &lt;a href=&quot;#Constructor-Options&quot;&gt;конструкторе Параметры&lt;/a&gt; раздел ниже.</target>
        </trans-unit>
        <trans-unit id="f9aa434ca385a7cef6abc358c51e5f3189796565" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;rawinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указаны ниже, дополнительные параметры для &lt;code&gt;rawinflate&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же , как те , которые используются с интерфейсом ОО , определенным в &lt;a href=&quot;#Constructor-Options&quot;&gt;конструкторе Параметры&lt;/a&gt; раздел ниже.</target>
        </trans-unit>
        <trans-unit id="e2285dec1544503fb1e6e19eb0aec81e1f5a9726" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;unzip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="f45874d912d180929ebed6cffec516fc7cf2fb97" translate="yes" xml:space="preserve">
          <source>Unless specified below, the optional parameters for &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , are the same as those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;Constructor Options&lt;/a&gt; section below.</source>
          <target state="translated">Если не указано ниже, необязательные параметры для &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;OPTS&lt;/code&gt; , такие же, как те, которые используются с интерфейсом OO, определенным в разделе &amp;laquo; &lt;a href=&quot;#Constructor-Options&quot;&gt;Параметры конструктора&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="871cfac0f7d812719fa8ee355ce0991623ac4e0b" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise all method can be called as class methods, or as object methods. If called as class methods then the &quot;default&quot; object will be used, and if necessary created using the current processes %Config and @INC. See the 'default' option to new() for details.</source>
          <target state="translated">Если не указано иначе,все методы могут быть вызваны как методы класса или как объектные методы.При вызове в качестве методов класса будет использоваться объект &quot;по умолчанию&quot;,при необходимости созданный с помощью текущих процессов %Config и @INC.Подробности смотрите в опции new()'default'.</target>
        </trans-unit>
        <trans-unit id="360b129724fa7c1c8235f3513edf30406e818a7b" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified with &lt;code&gt;=~&lt;/code&gt; must be a scalar variable, an array element, a hash element, or an assignment to one of those; in other words, an lvalue.</source>
          <target state="translated">Если не используется параметр &lt;code&gt;/r&lt;/code&gt; , строка, указанная с помощью &lt;code&gt;=~&lt;/code&gt; , должна быть скалярной переменной, элементом массива, хеш-элементом или присвоением одному из них; другими словами, lvalue.</target>
        </trans-unit>
        <trans-unit id="9ef73743f2ca77d91834c677a3b2a131dd0854b0" translate="yes" xml:space="preserve">
          <source>Unless the above additional feature is enabled, nothing about the backtrace functionality is visible, except for the Perl/XS level.</source>
          <target state="translated">Если не включена вышеописанная дополнительная функция,ничего о функциональности обратной связи не видно,за исключением уровня Perl/XS.</target>
        </trans-unit>
        <trans-unit id="c2c4cb992d99b0b97748811097f97eea4d2ce81b" translate="yes" xml:space="preserve">
          <source>Unless the operator is an assignment (&lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , etc.), repeat step (1) in respect of the second operand.</source>
          <target state="translated">Если оператор не является присваиванием ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; и т. Д.), Повторите шаг (1) в отношении второго операнда.</target>
        </trans-unit>
        <trans-unit id="2c6634c0ddc3b2fcdacf253fa92fd7c8403abaf0" translate="yes" xml:space="preserve">
          <source>Unless the pattern or string are encoded in UTF-8, only ASCII characters can match positively.</source>
          <target state="translated">Если шаблон или строка не закодированы в кодировке UTF-8,то только ASCII-символы могут иметь положительное совпадение.</target>
        </trans-unit>
        <trans-unit id="93f6520e33056598a5ce68e86d15794aa942a8a6" translate="yes" xml:space="preserve">
          <source>Unless they are explicitly specified, the default values for the exit status, verbose level, and output stream to use are determined as follows:</source>
          <target state="translated">Если они явно не указаны,то значения по умолчанию для статуса выхода,многоуровневого уровня и выходного потока для использования определяются следующим образом:</target>
        </trans-unit>
        <trans-unit id="28631a8600ab2d0e4799cb9a021cc0306169b6f9" translate="yes" xml:space="preserve">
          <source>Unless you are accessing the CPAN on your filesystem via a file: URL, CPAN.pm needs to keep the source files it downloads somewhere. Please supply a directory where the downloaded files are to be kept.</source>
          <target state="translated">Если только вы не получаете доступ к CPAN в вашей файловой системе через файл:URL,CPAN.pm должен хранить где-нибудь загружаемые им исходные файлы.Пожалуйста,укажите каталог,в котором будут храниться загруженные файлы.</target>
        </trans-unit>
        <trans-unit id="6b861eac07037b268358d427fce8707b48f9500e" translate="yes" xml:space="preserve">
          <source>Unless you are using the &lt;code&gt;fields&lt;/code&gt; pragma, consider this module discouraged in favor of the lighter-weight &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">Если вы не используете прагму &lt;code&gt;fields&lt;/code&gt; , считайте, что этот модуль не рекомендуется в пользу более легкого &lt;code&gt;parent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84f0f4d743460958895c1346a2bcc4ae32486815" translate="yes" xml:space="preserve">
          <source>Unless you don't like the possibility of there being part of your Perl scripts embedded in a database file, this is nothing to worry about.</source>
          <target state="translated">Если вам не нравится возможность быть частью Perl скриптов,встроенных в файл базы данных,то вам не о чем беспокоиться.</target>
        </trans-unit>
        <trans-unit id="078c8b3d64fda031c2ca3a111adc19b05790c7fb" translate="yes" xml:space="preserve">
          <source>Unless you have a particular reason to use the two-argument form you should use the three-argument form of open() which does not treat any characters in the filename as special.</source>
          <target state="translated">Если у вас нет особой причины использовать двухпараметрическую форму,вы должны использовать трехпараметрическую форму open(),которая не рассматривает никакие символы в имени файла как специальные.</target>
        </trans-unit>
        <trans-unit id="bcd145902080112cd3bd3565e1aa0b2eb6698439" translate="yes" xml:space="preserve">
          <source>Unless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file &lt;code&gt;Changes&lt;/code&gt; , and to follow the simple format described in &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN::Changes::Spec&lt;/a&gt;.</source>
          <target state="translated">Если у вас нет веских причин для использования какого-либо другого формата (например, формата, используемого в вашей компании), соглашение заключается в том, чтобы назвать ваш файл журнала изменений &lt;code&gt;Changes&lt;/code&gt; и следовать простому формату, описанному в &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Changes::Spec&quot;&gt;CPAN :: Changes :: Spec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ba7a1f205e8e2686b0c4b6d39cce725cef83741e" translate="yes" xml:space="preserve">
          <source>Unless you know better, serializing hook should always say:</source>
          <target state="translated">Если ты не знаешь лучше,серийный крюк всегда должен говорить:</target>
        </trans-unit>
        <trans-unit id="4f5f76f31b82833340ef52081bb4d0e79eab2cc2" translate="yes" xml:space="preserve">
          <source>Unless you know with 100% certainty that quux() is only ever available for the &quot;Foonix&quot; operating system &lt;b&gt;and&lt;/b&gt; that is available &lt;b&gt;and&lt;/b&gt; correctly working for &lt;b&gt;all&lt;/b&gt; past, present, &lt;b&gt;and&lt;/b&gt; future versions of &quot;Foonix&quot;, the above is very wrong. This is more correct (though still not perfect, because the below is a compile-time check):</source>
          <target state="translated">Если вы не знаете со 100% уверенностью, что quux () когда-либо доступен только для операционной системы &amp;laquo;Foonix&amp;raquo; &lt;b&gt;и&lt;/b&gt; что он доступен &lt;b&gt;и&lt;/b&gt; правильно работает для &lt;b&gt;всех&lt;/b&gt; прошлых, настоящих &lt;b&gt;и&lt;/b&gt; будущих версий &amp;laquo;Foonix&amp;raquo;, приведенное выше неверно. Это более правильно (хотя и не идеально, потому что ниже представлена ​​проверка во время компиляции):</target>
        </trans-unit>
        <trans-unit id="93ff79231a3d36c0c3d8ce3114e701a1baebbf25" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a false value, Pod::Search will recurse into subdirectories of the search directories.</source>
          <target state="translated">Если вы не установите этот атрибут в значение false,Pod::Search будет повторяться в подкаталогах каталогов поиска.</target>
        </trans-unit>
        <trans-unit id="17c62f898b45d3be500e6c39bec8d493a60a2715" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Search will apply Perl-specific heuristics to find the correct module PODs quickly. This attribute's default value is false. You won't normally need to set this to true.</source>
          <target state="translated">Если вы не установите этот атрибут в истинное значение,Pod::Search применит Perl-специфическую эвристику,чтобы быстро найти нужный модуль POD.Значение атрибута по умолчанию равно false.Обычно вам не нужно будет устанавливать это значение в true.</target>
        </trans-unit>
        <trans-unit id="9f9a16887abf4c916f1550cac344cc208f6c0b6b" translate="yes" xml:space="preserve">
          <source>Unless you set this attribute to a true value, Pod::Simple::Search will consider only the first file of a given modulename as it looks thru the specified directories; that is, with this option off, if Pod::Simple::Search has seen a &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; already in this search, then it won't bother looking at a &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; later on in that search, because that file is merely a &quot;shadow&quot;. But if you turn on &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; , then these &quot;shadow&quot; files are inspected too, and are noted in the pathname2podname return hash.</source>
          <target state="translated">Если вы не установите для этого атрибута истинное значение, Pod :: Simple :: Search будет рассматривать только первый файл с заданным именем модуля при просмотре через указанные каталоги; то есть, если эта опция выключена, если Pod :: Simple :: Search уже обнаружил &lt;code&gt;somepathdir/Foo/Bar.pm&lt;/code&gt; в этом поиске, то он не будет беспокоиться о поиске &lt;code&gt;somelaterpathdir/Foo/Bar.pm&lt;/code&gt; позже в этот поиск, потому что этот файл - просто &amp;laquo;тень&amp;raquo;. Но если вы включите &lt;code&gt;$self-&amp;gt;shadows(1)&lt;/code&gt; , эти &amp;laquo;теневые&amp;raquo; файлы тоже будут проверены и будут отмечены в возвращаемом хэше pathname2podname.</target>
        </trans-unit>
        <trans-unit id="fa89971032de2d3d226811c31dc2014b63de305b" translate="yes" xml:space="preserve">
          <source>Unless you want to override the defaults, prefer META_MERGE so as to get the advantage of any future defaults.</source>
          <target state="translated">Если вы не хотите переопределить значения по умолчанию,предпочитайте META_MERGE,чтобы получить преимущество от любых будущих значений по умолчанию.</target>
        </trans-unit>
        <trans-unit id="eb83985aa16dab9a13560a8e8f1159fe638efa8b" translate="yes" xml:space="preserve">
          <source>Unless you want to use its advanced features, this is probably all you need to know to use Exporter.</source>
          <target state="translated">Если вы не хотите использовать его расширенные возможности,это,вероятно,все,что вам нужно знать,чтобы использовать Exporter.</target>
        </trans-unit>
        <trans-unit id="04c205c66e7bc90d55cfb8afb031ef118a5c83da" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve used &lt;code&gt;/a&lt;/code&gt; or &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; matches more than ASCII digits only, but Perl&amp;rsquo;s implicit string-to-number conversion does not current recognize these. Here&amp;rsquo;s how to convert such strings manually.</source>
          <target state="translated">Если вы не использовали &lt;code&gt;/a&lt;/code&gt; или &lt;code&gt;/aa&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; соответствует более чем цифрам ASCII, но неявное преобразование строки в число Perl в настоящее время их не распознает. Вот как преобразовать такие строки вручную.</target>
        </trans-unit>
        <trans-unit id="5d5045afa1f26fa3558f3707783d1ac5db1ca1f3" translate="yes" xml:space="preserve">
          <source>Unless you're writing a new &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, a plugin or subclassing &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;, you probably won't need to use this module directly.</source>
          <target state="translated">Если вы не пишете новый &lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; , плагин или подкласс &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; , вам, вероятно, не потребуется напрямую использовать этот модуль.</target>
        </trans-unit>
        <trans-unit id="26769d51e7e8546d072ce687409eedaf6bbd7d27" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;, this does not include the decomposition type. Use the &lt;code&gt;Decomposition_Type&lt;/code&gt; property to get that.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; , он не включает тип декомпозиции. Используйте свойство &lt;code&gt;Decomposition_Type&lt;/code&gt; , чтобы получить это.</target>
        </trans-unit>
        <trans-unit id="0f7823a1b5c73e2c047f503abcdbc0ee1982c031" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;integer&quot;&gt;integer&lt;/a&gt;, this pragma creates integer constants that are only limited in their size by the available memory and CPU time.</source>
          <target state="translated">В отличие от &lt;a href=&quot;integer&quot;&gt;целых чисел&lt;/a&gt; , эта прагма создает целочисленные константы, размер которых ограничен только доступной памятью и временем процессора.</target>
        </trans-unit>
        <trans-unit id="ed386882eb03009cdfed1d7cc619e0742b192d68" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; , функция &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; не будет &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; и не &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; для вас модуля; вам нужно сделать это самостоятельно. См. &lt;a href=&quot;../db_file&quot;&gt;DB_File&lt;/a&gt; или</target>
        </trans-unit>
        <trans-unit id="e6074edfe48b345d15827a75a36946caff143c7a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you; you need to do that explicitly yourself. See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; or the</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;functions/dbmopen&quot;&gt;dbmopen&lt;/a&gt;&lt;/code&gt; , функция &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; не будет &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; и не &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; для вас модуля; вам нужно сделать это самостоятельно. См. &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; или</target>
        </trans-unit>
        <trans-unit id="7f221507f852d26a177998f0fca0127e91483ffd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt;, Perl's &lt;code&gt;for&lt;/code&gt; (also spelled &lt;code&gt;foreach&lt;/code&gt; ) does not allow the left-hand side to be an arbitrary expression. It must be a variable:</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for...in&lt;/a&gt;&lt;/code&gt; , Perl &lt;code&gt;for&lt;/code&gt; (также пишется как &lt;code&gt;foreach&lt;/code&gt; ) не позволяет левой части быть произвольным выражением. Это должна быть переменная:</target>
        </trans-unit>
        <trans-unit id="2d1c847135806754dca42b817cb04eaf19cedf87" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; не делает того, что вы, вероятно, имеете в виду, когда вы передаете ему массив в качестве первого аргумента. Массиву задается скалярный контекст, и вместо использования 0-го элемента массива в качестве формата Perl будет использовать количество элементов в массиве в качестве формата, что почти никогда не бывает полезно.</target>
        </trans-unit>
        <trans-unit id="89ae4f74127125a7e7d48317841dc79dfceae6a6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; does not do what you probably mean when you pass it an array as your first argument. The array is given scalar context, and instead of using the 0th element of the array as the format, Perl will use the count of elements in the array as the format, which is almost never useful.</source>
          <target state="translated">В отличие от &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; не делает того, что вы, вероятно, имеете в виду, когда вы передаете ему массив в качестве первого аргумента. Массиву задается скалярный контекст, и вместо использования 0-го элемента массива в качестве формата Perl будет использовать количество элементов в массиве в качестве формата, что почти никогда не бывает полезно.</target>
        </trans-unit>
        <trans-unit id="9885543c31cf8cf0906d34d4b26f89726d373169" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;which&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; , this function is platform independent and will also work on, for example, Win32.</source>
          <target state="translated">В отличие от &lt;code&gt;which&lt;/code&gt; и &lt;code&gt;type&lt;/code&gt; , эта функция не зависит от платформы и также будет работать, например, в Win32.</target>
        </trans-unit>
        <trans-unit id="a93ac07922c6fc8a77d40224ee6574380d8e4055" translate="yes" xml:space="preserve">
          <source>Unlike Win32 build, miniperl will not have</source>
          <target state="translated">В отличие от сборки Win32,miniperl не будет иметь</target>
        </trans-unit>
        <trans-unit id="a7c35c87e2cd92f458c69ed20a29518c1fc60ceb" translate="yes" xml:space="preserve">
          <source>Unlike constants in some languages, these cannot be overridden on the command line or via environment variables.</source>
          <target state="translated">В отличие от констант в некоторых языках,они не могут быть переопределены в командной строке или через переменные окружения.</target>
        </trans-unit>
        <trans-unit id="2e9d61b3ed80ed71e7bbbb9d575bf23b5d77fb98" translate="yes" xml:space="preserve">
          <source>Unlike dbmopen(), the tie() function will not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module for you--you need to do that explicitly yourself.</source>
          <target state="translated">В отличие от dbmopen (), функция tie () не будет &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; модуль для вас - вам нужно сделать это явно самостоятельно.</target>
        </trans-unit>
        <trans-unit id="ae7d99bfc8b3205da369ad185c97fc4f2004cc75" translate="yes" xml:space="preserve">
          <source>Unlike dynamic variables created by the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator, lexical variables declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.</source>
          <target state="translated">В отличие от динамических переменных, созданных &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; оператором, лексические переменные, объявленные с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , полностью скрыты от внешнего мира, включая любые вызываемые подпрограммы. Это верно, если одна и та же подпрограмма вызывается из себя или из другого места - каждый вызов получает свою собственную копию.</target>
        </trans-unit>
        <trans-unit id="f1d613b9dfee0f458298b76229e47572b9ad09a4" translate="yes" xml:space="preserve">
          <source>Unlike in C and Pascal, in Perl these are all defined in terms of BLOCKs, not statements. This means that the curly brackets are</source>
          <target state="translated">В отличие от C и Pascal,в Perl все они определены в терминах BLOCK,а не в утверждениях.Это означает,что фигурные скобки</target>
        </trans-unit>
        <trans-unit id="f21336a91710bef15208089eafb11092016626b2" translate="yes" xml:space="preserve">
          <source>Unlike in C, the scalar assignment operator produces a valid lvalue. Modifying an assignment is equivalent to doing the assignment and then modifying the variable that was assigned to. This is useful for modifying a copy of something, like this:</source>
          <target state="translated">В отличие от C,оператор назначения скаляров производит действительное значение lvalue.Изменение присваивания эквивалентно выполнению присваивания,а затем изменению присвоенной переменной.Это полезно для изменения копии чего-то подобного:</target>
        </trans-unit>
        <trans-unit id="5f827eec6110de095ec9210c18c9cbffc634099b" translate="yes" xml:space="preserve">
          <source>Unlike in earlier versions of Perl, &lt;code&gt;:raw&lt;/code&gt; is</source>
          <target state="translated">В отличие от более ранних версий Perl &lt;code&gt;:raw&lt;/code&gt; - это</target>
        </trans-unit>
        <trans-unit id="33bdaa80be75964fba31840d455d3822e7d396b4" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) can be returned. Since &lt;code&gt;catdir()&lt;/code&gt; on Mac OS always appends a trailing colon to distinguish a directory path from a file path, a single trailing colon will be ignored, i.e. there's no empty directory name after it.</source>
          <target state="translated">В отличие от простого разделения каталогов по разделителю, могут быть возвращены пустые имена каталогов ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Поскольку &lt;code&gt;catdir()&lt;/code&gt; в Mac OS всегда добавляет конечное двоеточие, чтобы отличить путь к каталогу от пути к файлу, одиночное конечное двоеточие будет проигнорировано, т. Е. После него нет пустого имени каталога.</target>
        </trans-unit>
        <trans-unit id="54463777f2a5a26bb28578fbecd0a237664559d0" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSes.</source>
          <target state="translated">В отличие от простого разделения каталогов по разделителю, могут быть возвращены пустые имена каталогов ( &lt;code&gt;''&lt;/code&gt; ), поскольку они важны в некоторых ОС.</target>
        </trans-unit>
        <trans-unit id="86f74613bf49290364595249fc093a5b0e46c0b1" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, empty directory names (&lt;code&gt;''&lt;/code&gt; ) can be returned, because these are significant on some OSs.</source>
          <target state="translated">В отличие от простого разделения каталогов по разделителю, могут быть возвращены пустые имена каталогов ( &lt;code&gt;''&lt;/code&gt; ), поскольку они важны для некоторых ОС.</target>
        </trans-unit>
        <trans-unit id="f0601a2027041706b4a215c5ba97b0f2d038f55f" translate="yes" xml:space="preserve">
          <source>Unlike just splitting the directories on the separator, leading empty and trailing directory entries can be returned, because these are significant on some OSs. So,</source>
          <target state="translated">В отличие от простого разделения каталогов на разделитель,ведущие пустые и трейлинговые записи каталога могут быть возвращены,потому что они важны для некоторых ОС.Итак,</target>
        </trans-unit>
        <trans-unit id="7934f43f05e561c630f325debe8a290638569198" translate="yes" xml:space="preserve">
          <source>Unlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won't be freed--which is as it should be. You wouldn't want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.</source>
          <target state="translated">В отличие от локальных переменных в C или C++,лексические переменные Perl не обязательно перерабатываются только потому,что их область видимости вышла из строя.Если что-то более постоянное все еще знает о лексике,оно останется.До тех пор,пока что-то другое ссылается на лексику,эта лексика не будет освобождена-как и должно быть.Вы не захотите,чтобы память была освобождена до тех пор,пока вы не закончите использовать её,или не будете хранить её,как только вы закончите.Автоматический сбор мусора позаботится об этом за вас.</target>
        </trans-unit>
        <trans-unit id="61c2bf5d9fb9c4e4b449918bf685b7cd4c575760" translate="yes" xml:space="preserve">
          <source>Unlike many other languages which support object orientation, Perl does not provide any special syntax for constructing an object. Objects are merely Perl data structures (hashes, arrays, scalars, filehandles, etc.) that have been explicitly associated with a particular class.</source>
          <target state="translated">В отличие от многих других языков,поддерживающих объектную ориентацию,Perl не предоставляет никакого специального синтаксиса для построения объекта.Объектами являются только Perl-структуры данных (хэши,массивы,скаляры,файловые хэндлы и т.д.),которые были явно ассоциированы с определенным классом.</target>
        </trans-unit>
        <trans-unit id="96a17407e83fd96732a811a270065f8bf99b9560" translate="yes" xml:space="preserve">
          <source>Unlike most encodings which accept various ways to handle errors, Unicode encodings simply croaks.</source>
          <target state="translated">В отличие от большинства кодировок,которые допускают различные способы обработки ошибок,кодировки Unicode просто перекрывают друг друга.</target>
        </trans-unit>
        <trans-unit id="49b673e0d13d9cc508ff95ef6bf45edac94a0386" translate="yes" xml:space="preserve">
          <source>Unlike most locales, which are specific to a language and country pair, Unicode classifies all the characters that are letters</source>
          <target state="translated">В отличие от большинства локалей,которые специфичны для пары языка и страны,Юникод классифицирует все символы,которые являются буквами.</target>
        </trans-unit>
        <trans-unit id="de28345f4c14a0c66a5513ec93329ba001d9ced5" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. На него также не распространяется действие правила внешнего вида, поэтому &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; заставит &quot;bar&quot; быть частью аргумента для &lt;code&gt;&lt;a href=&quot;dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d9558dea8e06eb18c291c6122258af13477176" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. На него также не распространяется действие правила внешнего вида, поэтому &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; заставит &quot;bar&quot; быть частью аргумента для &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b35f8dffb5619dd71375e3734d385be7cc68976" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. На него также не распространяется действие правила &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; функции, поэтому &lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;). &quot;Bar&quot; заставит &quot;bar&quot; быть частью аргумента &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="642dec0f5e46307ce9e97ef7e93a9392f0b1f7ab" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. Он также не подчиняется правилу &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; функции, поэтому &lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;). &quot;Bar&quot; заставит &quot;bar&quot; быть частью аргумента для &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8af66683db3fc2cddaa8cdf32b4f53ebab4445" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. На него также не распространяется действие правила &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; функции, поэтому redo (&quot;foo&quot;). &quot;Bar&quot; заставит &quot;bar&quot; быть частью аргумента для &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bec2254ea41ddda3ef06eefb12b88f8ff1170ba" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. На него также не распространяется действие правила &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; функции, поэтому &lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; (&quot;foo&quot;). &quot;Bar&quot; заставит &quot;bar&quot; быть частью аргумента &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46f28e7c4c55184f01ee0fc59018a927acd8437c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. Он также не подчиняется правилу &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; функции, поэтому &lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; (&quot;foo&quot;). &quot;Bar&quot; заставит &quot;bar&quot; быть частью аргумента для &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe0bcbfb6300fcbe2507c49b4631d20697de525c" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this has the same precedence as assignment. It is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, этот имеет тот же приоритет, что и присваивание. На него также не распространяется действие правила &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; функции, поэтому redo (&quot;foo&quot;). &quot;Bar&quot; заставит &quot;bar&quot; быть частью аргумента для &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee3973cea98d2564d41622c65ad1eadc9b20495" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, это также не распространяется на правило, похожее на функцию, поэтому &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; заставит &quot;bar&quot; быть частью &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; аргумента .</target>
        </trans-unit>
        <trans-unit id="fd9949db65a27c0400a1254746b3e91b925c452b" translate="yes" xml:space="preserve">
          <source>Unlike most named operators, this is also exempt from the looks-like-a-function rule, so &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; will cause &quot;bar&quot; to be part of the argument to &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В отличие от большинства именованных операторов, это также не распространяется на правило, похожее на функцию, поэтому &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; (&quot;foo&quot;).&quot;bar&quot;&lt;/code&gt; заставит &quot;bar&quot; быть частью &lt;code&gt;&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; аргумента .</target>
        </trans-unit>
        <trans-unit id="d21a9fd801c4b5ff299a1a5bef8631136555ebd2" translate="yes" xml:space="preserve">
          <source>Unlike most operators, the smartmatch operator knows to treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; specially:</source>
          <target state="translated">В отличие от большинства операторов, оператор smartmatch умеет обращаться с &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; особым образом:</target>
        </trans-unit>
        <trans-unit id="c52ae364f54ddc8596b506c3503500a0182fc785" translate="yes" xml:space="preserve">
          <source>Unlike most other encodings, the following always croaks on error for any $chk that evaluates to true.</source>
          <target state="translated">В отличие от большинства других кодировок,следующие кодировки всегда перекрывают ошибку для любого $chk,который вычисляется как истинный.</target>
        </trans-unit>
        <trans-unit id="a0be45e558750e70d5ad5d40843ef88fbc85d85e" translate="yes" xml:space="preserve">
          <source>Unlike non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if these properties are matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">В отличии от не-определяемого пользователя &lt;code&gt;\p{}&lt;/code&gt; собственности матчей, предупреждение не генерируется , если когда - либо эти свойства сопоставляются с точкой коды не-Unicode (см &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;кодовых точек Юникода Вне&lt;/a&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="54d85676113e32968ab38ead192e565266d17ce6" translate="yes" xml:space="preserve">
          <source>Unlike other DJGPP packages, which are normal &quot;zip&quot; files, most CPAN module packages are &quot;gzipped tarballs&quot;. Recent versions of WinZip will safely unpack and expand them, *UNLESS* they have zero-length files. It is a known WinZip bug (as of v7.0) that it will not extract zero-length files.</source>
          <target state="translated">В отличие от других пакетов DJGPP,которые являются обычными &quot;zip&quot; файлами,большинство пакетов CPAN модулей являются &quot;gzipped tarballs&quot;.Последние версии WinZip безопасно распаковывают и расширяют их,*UNLESS*они имеют файлы нулевой длины.Это известная ошибка WinZip (по состоянию на v7.0),что он не будет извлекать файлы с нулевой длиной.</target>
        </trans-unit>
        <trans-unit id="83864ffb2b433053a7d93f1893b27cbe33018e20" translate="yes" xml:space="preserve">
          <source>Unlike other encodings where mappings are not one-to-one against Unicode, UTFs are supposed to map 100% against one another. So Encode is more strict on UTFs.</source>
          <target state="translated">В отличие от других кодировок,где сопоставление не происходит один на один с Юникодом,UTF должны сопоставлять 100% друг с другом.Поэтому коды более строги к UTF.</target>
        </trans-unit>
        <trans-unit id="9944da74f109a50432581cc20ef1a61578ffdb1c" translate="yes" xml:space="preserve">
          <source>Unlike other types of quote-like literals, a here document is rarely a contiguous substring. For example, a typical piece of code using here document might look like this:</source>
          <target state="translated">В отличие от других типов цитируемых литералов,здесь документ редко является сопрягаемой подстрокой.Например,типичный фрагмент кода,использующий данный документ,может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="82bfb2284168959f095690d2be25e5ae6b5a6d2d" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire file in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">В отличие от прагм, которые влияют на переменную подсказок &lt;code&gt;$^H&lt;/code&gt; , объявления &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; не имеют области видимости BLOCK. Таким образом, они действуют для всего файла, в котором они появляются. Вы не можете отменить эти заявления &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="946dc8e2b9e4dbb1e056eab35da113b4edec1e74" translate="yes" xml:space="preserve">
          <source>Unlike pragmas that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; declarations are not BLOCK-scoped. They are thus effective for the entire package in which they appear. You may not rescind such declarations with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</source>
          <target state="translated">В отличие от прагм, которые влияют на переменную подсказок &lt;code&gt;$^H&lt;/code&gt; , объявления &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; не имеют области видимости BLOCK. Таким образом, они эффективны для всего пакета, в котором они появляются. Вы не можете отменить эти заявления &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; vars&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; subs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a62fc8b32926f79e07e4cd739d192b4db682422d" translate="yes" xml:space="preserve">
          <source>Unlike previous examples, we've now run h2xs on a real include file. This has caused some extra goodies to appear in both the .pm and .xs files.</source>
          <target state="translated">В отличие от предыдущих примеров,теперь мы запустили h2xs на реально включаемом файле.Это привело к появлению некоторых дополнительных лакомств как в .pm,так и в .xs файлах.</target>
        </trans-unit>
        <trans-unit id="82613342b350d8ac2d5e700389b419d73a2e8511" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;Newx&lt;/code&gt; and &lt;code&gt;Newxc&lt;/code&gt; macros, the &lt;code&gt;Newxz&lt;/code&gt; macro calls &lt;code&gt;memzero&lt;/code&gt; to zero out all the newly allocated memory.</source>
          <target state="translated">В отличие от &lt;code&gt;Newx&lt;/code&gt; и &lt;code&gt;Newxc&lt;/code&gt; , макрос &lt;code&gt;Newxz&lt;/code&gt; вызывает &lt;code&gt;memzero&lt;/code&gt; для обнуления всей вновь выделенной памяти.</target>
        </trans-unit>
        <trans-unit id="3459d8de61947e832dd8d6cc93a45a157f32fe5d" translate="yes" xml:space="preserve">
          <source>Unlike the GNU programs,</source>
          <target state="translated">В отличие от программ GNU,</target>
        </trans-unit>
        <trans-unit id="675122bbd6fe9d02ab821cef4f122f1e2fdb7554" translate="yes" xml:space="preserve">
          <source>Unlike the L</source>
          <target state="translated">В отличие от L</target>
        </trans-unit>
        <trans-unit id="00946f20f0f39de3fde945a1c4762c9a2eb54a4d" translate="yes" xml:space="preserve">
          <source>Unlike the old Unix fmt(1) utility, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">В отличие от старой утилиты Unix fmt(1),этот модуль корректно учитывает любые комбинации символов Юникода (например,диакритические),которые могут встречаться в каждой строке как при расширении,так и при неизучении.Это переопределенные символы,которые не увеличивают логическое положение.Убедитесь,что включены соответствующие настройки Юникода.</target>
        </trans-unit>
        <trans-unit id="0625a7948b2143bf8fa5b94abdec3d975bedca11" translate="yes" xml:space="preserve">
          <source>Unlike the old unix utilities, this module correctly accounts for any Unicode combining characters (such as diacriticals) that may occur in each line for both expansion and unexpansion. These are overstrike characters that do not increment the logical position. Make sure you have the appropriate Unicode settings enabled.</source>
          <target state="translated">В отличие от старых утилит unix,этот модуль корректно учитывает любые комбинации символов Юникода (например,диакритические знаки),которые могут встречаться в каждой строке как при расширении,так и при нерасширении.Это переопределенные символы,которые не увеличивают логическое положение.Убедитесь,что включены соответствующие настройки Юникода.</target>
        </trans-unit>
        <trans-unit id="bbee11f3129dceedbb755c4927925d533e72e81f" translate="yes" xml:space="preserve">
          <source>Unlike the original coding of this example, the returned values are not accessed in reverse order. So &lt;code&gt;ST(0)&lt;/code&gt; refers to the first value returned by the Perl subroutine and &lt;code&gt;ST(count-1)&lt;/code&gt; refers to the last.</source>
          <target state="translated">В отличие от исходного кода этого примера, к возвращаемым значениям не обращаются в обратном порядке. Итак, &lt;code&gt;ST(0)&lt;/code&gt; относится к первому значению, возвращаемому подпрограммой Perl, а &lt;code&gt;ST(count-1)&lt;/code&gt; относится к последнему.</target>
        </trans-unit>
        <trans-unit id="54921bfadbbc4d5488355e38753c36b606db5127" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#croak&quot;&gt;Croak&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; не может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="8a7070baa0bba9b5c3411b37157873dd12da55ea" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt;, &lt;code&gt;pat&lt;/code&gt; is not permitted to be null.</source>
          <target state="translated">В отличие от &lt;a href=&quot;#vcroak&quot;&gt;vcroak&lt;/a&gt; , &lt;code&gt;pat&lt;/code&gt; не может быть нулевым.</target>
        </trans-unit>
        <trans-unit id="e5cefcdd918640639ca1153770063f61e285104d" translate="yes" xml:space="preserve">
          <source>Unlink any temporary files you create.</source>
          <target state="translated">Развяжите все временные файлы,которые вы создаете.</target>
        </trans-unit>
        <trans-unit id="7f2c338fa9bfcccaac25268ab0ef12e64490b19e" translate="yes" xml:space="preserve">
          <source>Unlock and close the database.</source>
          <target state="translated">Разблокируйте и закройте базу данных.</target>
        </trans-unit>
        <trans-unit id="3a1b8bde43d6985240bfa75345e6d99d943394fd" translate="yes" xml:space="preserve">
          <source>Unpack the result with</source>
          <target state="translated">Распакуйте результат с помощью</target>
        </trans-unit>
        <trans-unit id="add77c91d022a17024fa5eba373c6e719da883a1" translate="yes" xml:space="preserve">
          <source>Unpack the result with &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt;</source>
          <target state="translated">Распакуйте результат с помощью &lt;code&gt;tar -xof yourmodule.tar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae62392d2b4bc10cbedb53bdaea138dd0c54922e" translate="yes" xml:space="preserve">
          <source>Unpack the source package</source>
          <target state="translated">Распакуйте исходный пакет</target>
        </trans-unit>
        <trans-unit id="3ba56861ba0d7e4bf096f38cb19b9bd9d11ad9ab" translate="yes" xml:space="preserve">
          <source>Unpacking CPAN Modules on DOS</source>
          <target state="translated">Распаковка модулей CPAN на DOS</target>
        </trans-unit>
        <trans-unit id="a3e58138dfa89b35eb5a0a67e0ceb78fe71fb3cd" translate="yes" xml:space="preserve">
          <source>Unpacking Perl Distribution on BS2000</source>
          <target state="translated">Распаковка Perl Distribution на BS2000</target>
        </trans-unit>
        <trans-unit id="1906a11a734d044847362b51bdd5c4ffec722822" translate="yes" xml:space="preserve">
          <source>Unpacking Perl distribution on OS/390</source>
          <target state="translated">Распаковка Perl распределения на OS/390</target>
        </trans-unit>
        <trans-unit id="1bfe6e7e13df7f1f795bc2c142ba9f8933ba83d0" translate="yes" xml:space="preserve">
          <source>Unpacking a Stack Frame</source>
          <target state="translated">Распаковка рамки стека</target>
        </trans-unit>
        <trans-unit id="13585670fad4d52485b4ecff204569086b8b8bc7" translate="yes" xml:space="preserve">
          <source>Unpacking this message can be done with the same template:</source>
          <target state="translated">Распаковка этого сообщения может быть выполнена с помощью того же шаблона:</target>
        </trans-unit>
        <trans-unit id="65ab97485c132c2a06d23b7d99106c078eeca52f" translate="yes" xml:space="preserve">
          <source>Unpacking using the &lt;code&gt;U&lt;/code&gt; template code also works on UTF-8 encoded byte strings.</source>
          <target state="translated">Распаковка с использованием кода шаблона &lt;code&gt;U&lt;/code&gt; также работает с байтовыми строками в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="f5c52c7fb5fb7350d05f5400b468c41971c6a2ea" translate="yes" xml:space="preserve">
          <source>Unsets the IV status of an SV.</source>
          <target state="translated">Сбрасывает статус IV SV.</target>
        </trans-unit>
        <trans-unit id="4b35d98112909417a16d4e204369414a7012a63c" translate="yes" xml:space="preserve">
          <source>Unsets the NV status of an SV.</source>
          <target state="translated">Устанавливает статус NV для SV.</target>
        </trans-unit>
        <trans-unit id="8c346401fde7bad98f35f3a033aefb050144d4e1" translate="yes" xml:space="preserve">
          <source>Unsets the NV/IV status of an SV.</source>
          <target state="translated">Сброс статуса NV/IV у SV.</target>
        </trans-unit>
        <trans-unit id="b2fe5f61df3d20003f435b822e60a53db4a67fca" translate="yes" xml:space="preserve">
          <source>Unsets the PV status of an SV.</source>
          <target state="translated">Устанавливает PV-статус SV.</target>
        </trans-unit>
        <trans-unit id="2b428943db3814d458253435d21b77a7039ff870" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of an SV.</source>
          <target state="translated">Сбрасывает RV-статус SV.</target>
        </trans-unit>
        <trans-unit id="167340ebdf7672f2c96a0ab5594ee87b55416719" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . The &lt;code&gt;cflags&lt;/code&gt; argument can contain &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; to force the reference count to be decremented (otherwise the decrementing is conditional on the reference count being different from one or the reference being a readonly SV). See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">Сбрасывает статус RV SV и уменьшает счетчик ссылок для всего, на что ссылается RV. Это почти можно рассматривать как отмену &lt;code&gt;newSVrv&lt;/code&gt; . &lt;code&gt;cflags&lt;/code&gt; Аргумент может содержать &lt;code&gt;SV_IMMEDIATE_UNREF&lt;/code&gt; , чтобы заставить счетчик ссылок будет уменьшаться ( в противном случае декрементирование условно на счетчик ссылок отличен от одного или опорного быть только для чтения С.В.). См. &lt;code&gt;SvROK_off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2213e6f5fdeb83ff58d3c894e858b5a7ff9788f0" translate="yes" xml:space="preserve">
          <source>Unsets the RV status of the SV, and decrements the reference count of whatever was being referenced by the RV. This can almost be thought of as a reversal of &lt;code&gt;newSVrv&lt;/code&gt; . This is &lt;code&gt;sv_unref_flags&lt;/code&gt; with the &lt;code&gt;flag&lt;/code&gt; being zero. See &lt;code&gt;SvROK_off&lt;/code&gt; .</source>
          <target state="translated">Сбрасывает статус RV SV и уменьшает счетчик ссылок для всего, на что ссылается RV. Это почти можно рассматривать как отмену &lt;code&gt;newSVrv&lt;/code&gt; . Это &lt;code&gt;sv_unref_flags&lt;/code&gt; с нулевым &lt;code&gt;flag&lt;/code&gt; . См. &lt;code&gt;SvROK_off&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfacd26d54ec31883bc064dd4f33047f4f7aa58" translate="yes" xml:space="preserve">
          <source>Unsets the UTF-8 status of an SV (the data is not changed, just the flag). Do not use frivolously.</source>
          <target state="translated">Устанавливает UTF-8 статус SV (данные не изменяются,только флаг).Не используйте фривольно.</target>
        </trans-unit>
        <trans-unit id="d458cc7af0595ce52fa475113c58f925209c55f3" translate="yes" xml:space="preserve">
          <source>Unsets the script encoding. The layers of &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; are reset to &quot;&lt;code&gt;:raw&lt;/code&gt; &quot; (the default unprocessed raw stream of bytes).</source>
          <target state="translated">Отменяет кодировку скрипта. Слои &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; сбрасываются до &amp;laquo; &lt;code&gt;:raw&lt;/code&gt; &amp;raquo; (по умолчанию непереработанного сырого потока байт).</target>
        </trans-unit>
        <trans-unit id="f3f886677b52de9f164b2193f280f9e0b4fa4087" translate="yes" xml:space="preserve">
          <source>Unshift the given number of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values onto the beginning of the array. The array will grow automatically to accommodate the addition. You must then use &lt;code&gt;av_store&lt;/code&gt; to assign values to these new elements.</source>
          <target state="translated">Отмените сдвиг заданного количества значений &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в начало массива. Массив будет автоматически увеличиваться в соответствии с добавлением. Затем вы должны использовать &lt;code&gt;av_store&lt;/code&gt; для присвоения значений этим новым элементам.</target>
        </trans-unit>
        <trans-unit id="56c8806e91e8b07e1c8c5b623b330c5fc17f1e53" translate="yes" xml:space="preserve">
          <source>Unshifts an SV onto the beginning of the array, creating the array if necessary. A small internal helper function to remove a commonly duplicated idiom.</source>
          <target state="translated">Сдвигает SV на начало массива,создавая массив при необходимости.Небольшая внутренняя вспомогательная функция для удаления часто дублируемой идиомы.</target>
        </trans-unit>
        <trans-unit id="ee9dd9a34e19860a5fcf0a7ebd745fb02d06f995" translate="yes" xml:space="preserve">
          <source>Unsigned long integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned long&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned long&lt;/code&gt; is T_UV.</source>
          <target state="translated">Беззнаковые длинные целые числа. Это эквивалентно T_UV, но явно приводит возврат к типу &lt;code&gt;unsigned long&lt;/code&gt; . Карта типов по умолчанию для &lt;code&gt;unsigned long&lt;/code&gt; - T_UV.</target>
        </trans-unit>
        <trans-unit id="ef145f774c9c40a970f92057ceb7090d079d49a8" translate="yes" xml:space="preserve">
          <source>Unsigned short integers. This is equivalent to T_UV but explicitly casts the return to type &lt;code&gt;unsigned short&lt;/code&gt; . The default typemap for &lt;code&gt;unsigned short&lt;/code&gt; is T_UV.</source>
          <target state="translated">Беззнаковые короткие целые числа. Это эквивалентно T_UV, но явно приводит возврат к типу &lt;code&gt;unsigned short&lt;/code&gt; . Карта типов по умолчанию для &lt;code&gt;unsigned short&lt;/code&gt; строк - T_UV.</target>
        </trans-unit>
        <trans-unit id="e913109aa138d1120ee92917139364ad0e62c982" translate="yes" xml:space="preserve">
          <source>Unstable CPAN modules</source>
          <target state="translated">Нестабильные модули CPAN</target>
        </trans-unit>
        <trans-unit id="36af1ae54977c39ffd1ead9641e29d3a83f91f42" translate="yes" xml:space="preserve">
          <source>Untaint an SV. Use &lt;code&gt;SvTAINTED_off&lt;/code&gt; instead.</source>
          <target state="translated">Освободите SV. &lt;code&gt;SvTAINTED_off&lt;/code&gt; этого используйте SvTAINTED_off .</target>
        </trans-unit>
        <trans-unit id="bf2cbcc095493f902db2ae40c30ea409c9c066e5" translate="yes" xml:space="preserve">
          <source>Untaints an SV. Be</source>
          <target state="translated">Не обнаруживает спецназ.Быть</target>
        </trans-unit>
        <trans-unit id="dd1c8a6c3311799ae1ea8e9badc636ca33ce5f06" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself by the Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;.</source>
          <target state="translated">До мая 1997 г. этот документ поддерживал Джефф Окамото &amp;lt;okamoto@corp.hp.com&amp;gt;. Теперь он поддерживается как часть Perl Perl 5 Porters &amp;lt;perl5-porters@perl.org&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="1831403e65413acb20ccb5893a29f9432e4a4a0c" translate="yes" xml:space="preserve">
          <source>Until May 1997, this document was maintained by Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;. It is now maintained as part of Perl itself.</source>
          <target state="translated">До мая 1997 г. этот документ поддерживал Джефф Окамото &amp;lt;okamoto@corp.hp.com&amp;gt;. Сейчас он поддерживается как часть самого Perl.</target>
        </trans-unit>
        <trans-unit id="9377bbae85c5f3f0ba947e70ca82611c37d8697f" translate="yes" xml:space="preserve">
          <source>Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099 did not have names nor aliases. To preserve backwards compatibility, any alias you define for these code points will be returned by this function, in preference to the official name.</source>
          <target state="translated">До Юникода 6.1 4 управляющие символы U+0080,U+0081,U+0084 и U+0099 не имели ни имен,ни псевдонимов.Для сохранения обратной совместимости,любой псевдоним,который вы определите для этих точек кода,будет возвращен этой функцией,в предпочтение официальному названию.</target>
        </trans-unit>
        <trans-unit id="1eb5a9bdac4b575070ceef54e56442cbab9b46a4" translate="yes" xml:space="preserve">
          <source>Until Unicode 7.0, the noncharacters were &quot;&lt;b&gt;forbidden&lt;/b&gt; for use in open interchange of Unicode text data&quot;, so that code that processed those streams could use these code points as sentinels that could be mixed in with character data, and would always be distinguishable from that data. (Emphasis above and in the next paragraph are added in this document.)</source>
          <target state="translated">До Unicode 7.0 несимволы были &amp;laquo; &lt;b&gt;запрещены&lt;/b&gt; для использования в открытом обмене текстовыми данными Unicode&amp;raquo;, так что код, обрабатывающий эти потоки, мог использовать эти кодовые точки в качестве контрольных точек, которые можно было смешивать с символьными данными, и которые всегда были бы отличимы от них. данные. (В этом документе добавлены акценты выше и в следующем абзаце.)</target>
        </trans-unit>
        <trans-unit id="39e4b4459c9bb0a70e21b5f9e46e887914c2d11b" translate="yes" xml:space="preserve">
          <source>Until version 1.72 of this module, the recommended technique for locking &lt;b&gt;DB_File&lt;/b&gt; databases was to flock the filehandle returned from the &quot;fd&quot; function. Unfortunately this technique has been shown to be fundamentally flawed (Kudos to David Harris for tracking this down). Use it at your own peril!</source>
          <target state="translated">До версии 1.72 этого модуля рекомендованный метод блокировки &lt;b&gt;баз&lt;/b&gt; данных &lt;b&gt;DB_File&lt;/b&gt; заключался в том, чтобы &lt;b&gt;скопировать&lt;/b&gt; дескриптор файла, возвращаемый функцией &quot;fd&quot;. К сожалению, эта методика оказалась в корне ошибочной (Престижность Дэвиду Харрису за отслеживание). Используйте это на свой страх и риск!</target>
        </trans-unit>
        <trans-unit id="086839a55d5b993fe1e0e2c06b1920a0c4bb718d" translate="yes" xml:space="preserve">
          <source>Until version 1.88 CPAN.pm never trusted the contents of the build_dir directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based mechanism that makes it possible to share the contents of the build_dir/ directory between different sessions with the same version of perl. People who prefer to test things several days before installing will like this feature because it saves a lot of time.</source>
          <target state="translated">До версии 1.88 CPAN.pm никогда не доверял содержимому директории build_dir между сессиями.Начиная с версии 1.88_58 CPAN.pm имеет механизм,основанный на YAML,который позволяет совместно использовать содержимое директории build_dir/между различными сессиями с одной и той же версией perl.Людям,которые предпочитают тестировать вещи за несколько дней до установки,понравится эта возможность,так как она экономит много времени.</target>
        </trans-unit>
        <trans-unit id="3e8ce03700f57426d42c01b15a7e4b29915f11c3" translate="yes" xml:space="preserve">
          <source>Unused. Left in for compatibility with Perl 5.10.0.</source>
          <target state="translated">Неиспользованный.Оставлено для совместимости с Perl 5.10.0.</target>
        </trans-unit>
        <trans-unit id="06342bce5c18e1ce2d5790dec4f3e08db46e5f75" translate="yes" xml:space="preserve">
          <source>Unusually, the overloaded implementation of the smart match operator does not get full control of the smart match behaviour. In particular, in the following code:</source>
          <target state="translated">Необычно,что перегруженная реализация оператора &quot;умных совпадений&quot; не получает полного контроля над поведением &quot;умных совпадений&quot;.В частности,в следующем коде:</target>
        </trans-unit>
        <trans-unit id="2e6b69fad267beac964f8da92bb1c2cb8cf51e03" translate="yes" xml:space="preserve">
          <source>Unzipping a complete zip file to disk</source>
          <target state="translated">Распаковка полного zip-файла на диск</target>
        </trans-unit>
        <trans-unit id="3706919ae59d2c2aad143453aa2569b724a8dcba" translate="yes" xml:space="preserve">
          <source>Up to 3.14_05, the switch &lt;b&gt;-v&lt;/b&gt; was used to produce verbose messages of &lt;b&gt;perldoc&lt;/b&gt; operation, which is now enabled by &lt;b&gt;-D&lt;/b&gt;.</source>
          <target state="translated">До версии 3.14_05 параметр &lt;b&gt;-v&lt;/b&gt; использовался для создания подробных сообщений об операции &lt;b&gt;perldoc&lt;/b&gt; , которая теперь включена с помощью &lt;b&gt;-D&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b37c83dafbe144687e4e64f7705c9303ba945d98" translate="yes" xml:space="preserve">
          <source>Up until Perl 5.18, the actual rules of what a valid identifier was were a bit fuzzy. However, in general, anything defined here should work on previous versions of Perl, while the opposite -- edge cases that work in previous versions, but aren't defined here -- probably won't work on newer versions. As an important side note, please note that the following only applies to bareword identifiers as found in Perl source code, not identifiers introduced through symbolic references, which have much fewer restrictions. If working under the effect of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; pragma, the following rules apply:</source>
          <target state="translated">Вплоть до Perl 5.18 действительные правила того, что такое действительный идентификатор, были немного нечеткими. Однако в целом все, что определено здесь, должно работать в предыдущих версиях Perl, в то время как противоположные - крайние случаи, которые работают в предыдущих версиях, но не определены здесь - вероятно, не будут работать в более новых версиях. В качестве важного примечания обратите внимание, что нижеследующее относится только к идентификаторам, содержащимся в исходном коде Perl, а не к идентификаторам, представленным через символические ссылки, которые имеют гораздо меньше ограничений. Если работаете под влиянием &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; pragma, применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="700db59a01b3167d63908b9389905b718c997451" translate="yes" xml:space="preserve">
          <source>Update the pad compilation state variables on entry to a new block.</source>
          <target state="translated">Обновление переменных состояния компиляции блока при входе в новый блок.</target>
        </trans-unit>
        <trans-unit id="8d41ca4ae9515e795255242cbd01a15b9d2f782f" translate="yes" xml:space="preserve">
          <source>Update the running test count during testing.</source>
          <target state="translated">Обновите количество запущенных тестов во время тестирования.</target>
        </trans-unit>
        <trans-unit id="ee4df1b22166fed22f195ec39ac5348e1ad4b8f4" translate="yes" xml:space="preserve">
          <source>Updated 12 March 2001 to mention //'SYS1.TCPPARMS(TCPDATA)'.</source>
          <target state="translated">Обновлено 12 марта 2001 г.с упоминанием //'SYS1.TCPPARMS(TCPDATA)'.</target>
        </trans-unit>
        <trans-unit id="6a623978ea73cf3eae49fa257cd2b3aa518dc7a5" translate="yes" xml:space="preserve">
          <source>Updated 12 November 2000 for the 5.7.1 release of Perl.</source>
          <target state="translated">Обновлено 12 ноября 2000 г.для версии 5.7.1 на Perl.</target>
        </trans-unit>
        <trans-unit id="dd3c1a655a151c3e2de2f2bcc426466b5deb0bf5" translate="yes" xml:space="preserve">
          <source>Updated 15 January 2001 for the 5.7.1 release of Perl.</source>
          <target state="translated">Обновлено 15 января 2001 г.для версии 5.7.1 на Perl.</target>
        </trans-unit>
        <trans-unit id="5b24aab6b7b4ffb7848dd5c01694221d0200543c" translate="yes" xml:space="preserve">
          <source>Updated 24 January 2001 to mention dynamic loading.</source>
          <target state="translated">Обновлено 24 января 2001 г.с учетом динамической нагрузки.</target>
        </trans-unit>
        <trans-unit id="555d5c68c249342b429101141b4e668ed9316de1" translate="yes" xml:space="preserve">
          <source>Updated 28 November 2001 for broken URLs.</source>
          <target state="translated">Обновлено 28 ноября 2001 года для сломанных URL.</target>
        </trans-unit>
        <trans-unit id="e62d7626efdd54a1045fbdd7ab753ad6e883c01e" translate="yes" xml:space="preserve">
          <source>Updated by Kirrily &quot;Skud&quot; Robert, &lt;code&gt;skud@cpan.org&lt;/code&gt;</source>
          <target state="translated">Обновлено Киррили &quot;Skud&quot; Роберт, &lt;code&gt;skud@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d4259d34b695e49901c9de958534f87265a7f80" translate="yes" xml:space="preserve">
          <source>Updated to be autogenerated from comments in the source by Benjamin Stuhl.</source>
          <target state="translated">Обновлено для автогенерации из комментариев в источнике Бенджамина Штула.</target>
        </trans-unit>
        <trans-unit id="76fadb0208f83533ce563882faa439aa56b4df27" translate="yes" xml:space="preserve">
          <source>Updates for 5.8.0 by Nicholas Clark &amp;lt;nick@ccl4.org&amp;gt;</source>
          <target state="translated">Обновления для 5.8.0 от Николаса Кларка &amp;lt;nick@ccl4.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1339cf8af116acbabf9923f4b5f205bd8b4522d5" translate="yes" xml:space="preserve">
          <source>Updates the current digest state by appending bits to it. The return value is the updated object itself.</source>
          <target state="translated">Обновляет текущее состояние дайджеста,добавляя к нему биты.Возвращаемым значением является сам обновленный объект.</target>
        </trans-unit>
        <trans-unit id="0f2ec1c28ed80b9544a67d730b3a5ce7a7abddfc" translate="yes" xml:space="preserve">
          <source>Updates to dual-life modules should consist of minimal patches to fix crashing bugs or security issues (as above). Any changes made to dual-life modules for which CPAN is canonical should be coordinated with the upstream author.</source>
          <target state="translated">Обновления для модулей с двойной жизнью должны состоять из минимальных патчей для исправления ошибок при падении или проблем с безопасностью (как описано выше).Любые изменения,внесенные в модули с двойной жизнью,для которых CPAN является каноническим,должны согласовываться с автором upstream.</target>
        </trans-unit>
        <trans-unit id="6308607dfbe53993e815ce31d09f4ea8e48145b7" translate="yes" xml:space="preserve">
          <source>Updating Apple's Perl</source>
          <target state="translated">Обновление Apple Perl</target>
        </trans-unit>
        <trans-unit id="e1215f678a578a0f9348858eb8435faef2c2b2a9" translate="yes" xml:space="preserve">
          <source>Updating perldelta</source>
          <target state="translated">Обновление perldelta</target>
        </trans-unit>
        <trans-unit id="2c9b320c5f351db0fa6eccf0f443242caa105988" translate="yes" xml:space="preserve">
          <source>Upgrade an SV to a more complex form. Generally adds a new body type to the SV, then copies across as much information as possible from the old body. It croaks if the SV is already in a more complex form than requested. You generally want to use the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro wrapper, which checks the type before calling &lt;code&gt;sv_upgrade&lt;/code&gt; , and hence does not croak. See also &lt;code&gt;svtype&lt;/code&gt; .</source>
          <target state="translated">Обновите SV до более сложной формы. Обычно добавляет новый тип тела к SV, а затем копирует как можно больше информации из старого тела. Он хрипит, если SV уже находится в более сложной форме, чем запрошено. Обычно вы хотите использовать &lt;code&gt;SvUPGRADE&lt;/code&gt; макросов SvUPGRADE , которая проверяет тип перед вызовом &lt;code&gt;sv_upgrade&lt;/code&gt; и, следовательно, не хрипит. См. Также &lt;code&gt;svtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf9f028e2ed4c8dda78241c1ef169c062efd613f" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. Any arguments necessary for SSL must be given in &lt;code&gt;new&lt;/code&gt; already.</source>
          <target state="translated">Обновите существующее обычное соединение до SSL. Любые аргументы, необходимые для SSL, уже должны быть приведены в &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e297ad00204348f72b48d82b1764d98805e45e0" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. The SSL arguments have to be given in &lt;code&gt;new&lt;/code&gt; already because they are needed for data connections too.</source>
          <target state="translated">Обновите существующее обычное соединение до SSL. Аргументы SSL уже должны быть приведены в &lt;code&gt;new&lt;/code&gt; потому что они также необходимы для соединений данных.</target>
        </trans-unit>
        <trans-unit id="1fee598dc67371af303baa6134f7476c80299023" translate="yes" xml:space="preserve">
          <source>Upgrade existing plain connection to SSL. You can use SSL arguments as documented in &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;, but it will usually use the right arguments already.</source>
          <target state="translated">Обновите существующее обычное соединение до SSL. Вы можете использовать аргументы SSL, как описано в &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL&lt;/a&gt; , но обычно уже используются правильные аргументы.</target>
        </trans-unit>
        <trans-unit id="bd48bfd47491f661502b2059f5ddd29245e2ae65" translate="yes" xml:space="preserve">
          <source>Upgrade the input stream to handle UTF8.</source>
          <target state="translated">Обновите входной поток для обработки UTF8.</target>
        </trans-unit>
        <trans-unit id="abc1ecb08d6b6e94555b0616aae01977c29165a2" translate="yes" xml:space="preserve">
          <source>Upon a successful match, if &lt;code&gt;pe1&lt;/code&gt; is non-NULL, it will be set to point to the beginning of the</source>
          <target state="translated">После успешного совпадения, если &lt;code&gt;pe1&lt;/code&gt; не равно NULL, он будет установлен так, чтобы указывать на начало</target>
        </trans-unit>
        <trans-unit id="7931625de6bea30c3520a42f1b48c8c7ccb1cf73" translate="yes" xml:space="preserve">
          <source>Upon the call, the &lt;code&gt;mg_obj&lt;/code&gt; field will hold the hash key to be accessed. Upon return, the &lt;code&gt;SV*&lt;/code&gt; value in &lt;code&gt;mg_obj&lt;/code&gt; will be used in place of the original key in the hash access. The integer index value in the first parameter will be the &lt;code&gt;action&lt;/code&gt; value from &lt;code&gt;hv_fetch_common&lt;/code&gt; , or -1 if the call is from &lt;code&gt;hv_delete_common&lt;/code&gt; .</source>
          <target state="translated">После вызова поле &lt;code&gt;mg_obj&lt;/code&gt; будет содержать хэш-ключ, к которому будет осуществляться доступ. По возвращении значение &lt;code&gt;SV*&lt;/code&gt; в &lt;code&gt;mg_obj&lt;/code&gt; будет использоваться вместо исходного ключа в хеш-доступе. Целочисленное значение индекса в первом параметре будет значением &lt;code&gt;action&lt;/code&gt; из &lt;code&gt;hv_fetch_common&lt;/code&gt; или -1, если вызов из &lt;code&gt;hv_delete_common&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa70849156e04d235d49fdb3686f0245d179ad8d" translate="yes" xml:space="preserve">
          <source>Upon tying a new hash to this package, the developer must specify the size of the keys that will be used, the size of the value fields that the keys will index, and the size of the overall table (in terms of key-value pairs, not size in hard memory).</source>
          <target state="translated">При привязке нового хэша к данному пакету разработчик должен указать размер ключей,которые будут использоваться,размер полей значений,которые будут индексироваться ключами,и размер общей таблицы (с точки зрения пар ключ-значение,а не размер в жесткой памяти).</target>
        </trans-unit>
        <trans-unit id="187b6d106a78abc992df989626da341b4759f5bf" translate="yes" xml:space="preserve">
          <source>Upper/lower case differences in property names and values are irrelevant; thus &lt;code&gt;\p{Upper}&lt;/code&gt; means the same thing as &lt;code&gt;\p{upper}&lt;/code&gt; or even &lt;code&gt;\p{UpPeR}&lt;/code&gt; . Similarly, you can add or subtract underscores anywhere in the middle of a word, so that these are also equivalent to &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; . And white space is irrelevant adjacent to non-word characters, such as the braces and the equals or colon separators, so &lt;code&gt;\p{ Upper }&lt;/code&gt; and &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; are equivalent to these as well. In fact, white space and even hyphens can usually be added or deleted anywhere. So even &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; is equivalent. All this is called &quot;loose-matching&quot; by Unicode. The few places where stricter matching is used is in the middle of numbers, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="translated">Различия в верхнем и нижнем регистрах в именах и значениях свойств не имеют значения; таким образом, &lt;code&gt;\p{Upper}&lt;/code&gt; означает то же, что и &lt;code&gt;\p{upper}&lt;/code&gt; или даже &lt;code&gt;\p{UpPeR}&lt;/code&gt; . Точно так же вы можете добавлять или &lt;code&gt;\p{U_p_p_e_r}&lt;/code&gt; подчеркивания в любом месте в середине слова, так что они также эквивалентны \ p {U_p_p_e_r} . Пробелы не имеют значения рядом с символами, не являющимися словами, такими как фигурные скобки и разделители равенства или двоеточия, поэтому &lt;code&gt;\p{ Upper }&lt;/code&gt; и &lt;code&gt;\p{ Upper_case : Y }&lt;/code&gt; также эквивалентны им. Фактически, пробелы и даже дефисы обычно можно добавлять или удалять где угодно. Так что даже &lt;code&gt;\p{ Up-per case = Yes}&lt;/code&gt; эквивалентно. Все это в Юникоде называется &amp;laquo;свободным соответствием&amp;raquo;. Несколько мест, где используется более строгое соответствие, - это середина чисел и свойства расширения Perl, которые начинаются или заканчиваются знаком подчеркивания. При более строгом сопоставлении учитываются пробелы (кроме символов, не являющихся словами), дефисы и не внутренние подчеркивания.</target>
        </trans-unit>
        <trans-unit id="46cec56f3412b99de640a0bca5cebcfbc4f533b0" translate="yes" xml:space="preserve">
          <source>Urgh. No wonder. There's a big difference between &quot;a null byte&quot;, character zero, and &quot;a space&quot;, character 32. Perl's put something between the date and the description - but unfortunately, we can't see it!</source>
          <target state="translated">Ох.Неудивительно.Есть большая разница между &quot;нулевым байтом&quot;,символом ноль,и &quot;пробелом&quot;,символом 32.Перл поставил что-то между датой и описанием-но,к сожалению,мы этого не видим!</target>
        </trans-unit>
        <trans-unit id="da969c82ff05cdc8d49e5dc3d47bc17f0b801a39" translate="yes" xml:space="preserve">
          <source>Urgh. Well, it's a bit better, but - well, would you want to maintain that?</source>
          <target state="translated">Ох.Ну,это немного лучше,но-ну,ты хочешь сохранить это?</target>
        </trans-unit>
        <trans-unit id="82706ecdf8b404a3d7af76c38e97c34669646ccc" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on OS/390</source>
          <target state="translated">Подсказки по использованию Perl на OS/390</target>
        </trans-unit>
        <trans-unit id="96115201cdc9d452c0fc7c1a0ccadddf5148529a" translate="yes" xml:space="preserve">
          <source>Usage Hints for Perl on Windows</source>
          <target state="translated">Подсказки по использованию Perl на Windows</target>
        </trans-unit>
        <trans-unit id="73e902d9c6da4a824d1ebe10f64b85e576698ee7" translate="yes" xml:space="preserve">
          <source>Usage is</source>
          <target state="translated">Использование</target>
        </trans-unit>
        <trans-unit id="b4adcf0ec968acb4f04ec349a0b19258b19ca830" translate="yes" xml:space="preserve">
          <source>Usage messages issued as a result of bad command-line syntax should go to &lt;code&gt;STDERR&lt;/code&gt; . However, usage messages issued due to an explicit request to print usage (like specifying &lt;b&gt;-help&lt;/b&gt; on the command line) should go to &lt;code&gt;STDOUT&lt;/code&gt; , just in case the user wants to pipe the output to a pager (such as &lt;b&gt;more(1)&lt;/b&gt;).</source>
          <target state="translated">Сообщения об использовании, выданные в результате неправильного синтаксиса командной строки, должны поступать в &lt;code&gt;STDERR&lt;/code&gt; . Однако сообщения об использовании, выданные из-за явного запроса на использование печати (например, указание &lt;b&gt;-help&lt;/b&gt; в командной строке), должны поступать в &lt;code&gt;STDOUT&lt;/code&gt; , на всякий случай, если пользователь захочет передать вывод на пейджер (например, &lt;b&gt;more (1)&lt;/b&gt; ).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
