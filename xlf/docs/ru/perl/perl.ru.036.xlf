<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="25bc3d27f1f1d3400779cec866f02e11e267bcde" translate="yes" xml:space="preserve">
          <source>How do I handle linked lists?</source>
          <target state="translated">Как работать со связанными списками?</target>
        </trans-unit>
        <trans-unit id="22ab3c17d49644f7643e768f33f866efb0521ae5" translate="yes" xml:space="preserve">
          <source>How do I install a &quot;DEVELOPER RELEASE&quot; of a module?</source>
          <target state="translated">Как установить &quot;УСТАНОВКУ РАЗРЕШЕНИЯ&quot; модуля?</target>
        </trans-unit>
        <trans-unit id="51ca5bd4b613176b7121cb512580f3d074cc9e12" translate="yes" xml:space="preserve">
          <source>How do I install a module and all its dependencies from the commandline, without being prompted for anything, despite my CPAN configuration (or lack thereof)?</source>
          <target state="translated">Как установить модуль и все его зависимости из командной строки,не требуя ничего,несмотря на мою CPAN конфигурацию (или ее отсутствие)?</target>
        </trans-unit>
        <trans-unit id="332f266fa06f1a0ab802b1da5c10c6890675f4de" translate="yes" xml:space="preserve">
          <source>How do I install a module from CPAN?</source>
          <target state="translated">Как установить модуль из CPAN?</target>
        </trans-unit>
        <trans-unit id="125fb980d7aaa7ca2242befa5648bc32166dc7e6" translate="yes" xml:space="preserve">
          <source>How do I install a module into my home directory?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d861f5b4b26ce38782c487c2b8f360184457002f" translate="yes" xml:space="preserve">
          <source>How do I keep from installing man pages?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d92a5148bd9660c144884977d59745697a0930" translate="yes" xml:space="preserve">
          <source>How do I keep my $VERSION up to date without resetting it manually?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779b60119e9ac89f1b4bb8ccca7aa17790f78529" translate="yes" xml:space="preserve">
          <source>How do I keep my own module/library directory?</source>
          <target state="translated">Как мне сохранить собственный каталог модулей/библиотек?</target>
        </trans-unit>
        <trans-unit id="712ff90db628f146b683448ab9a743ea57d1a8f1" translate="yes" xml:space="preserve">
          <source>How do I keep persistent data across program calls?</source>
          <target state="translated">Как хранить постоянные данные во время вызовов программы?</target>
        </trans-unit>
        <trans-unit id="a20b09e11bad429f8e02c602624e45b441c22369" translate="yes" xml:space="preserve">
          <source>How do I look up a hash element by value?</source>
          <target state="translated">Как искать гашишный элемент по значению?</target>
        </trans-unit>
        <trans-unit id="fc81f211ace7f04a35490b5be3fe4452ee1626e9" translate="yes" xml:space="preserve">
          <source>How do I make a system() exit on control-C?</source>
          <target state="translated">Как сделать так,чтобы система()выходила из контроллера C?</target>
        </trans-unit>
        <trans-unit id="58c641789837b76dd9abee18041837a328da4bf8" translate="yes" xml:space="preserve">
          <source>How do I make a temporary file name?</source>
          <target state="translated">Как сделать имя временного файла?</target>
        </trans-unit>
        <trans-unit id="f0fab6b039e898671e7205067775272f3896476e" translate="yes" xml:space="preserve">
          <source>How do I make sure users can't enter values into a form that causes my CGI script to do bad things?</source>
          <target state="translated">Как сделать так,чтобы пользователи не могли вводить значения в форму,которая заставляет мой CGI-скрипт делать плохие вещи?</target>
        </trans-unit>
        <trans-unit id="717678bc544dca5a8699132ee02462800aee62d3" translate="yes" xml:space="preserve">
          <source>How do I make two or more XS files coexist in the same directory?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e83c97b2d0052618a071494ce58ad0aa5de46bd" translate="yes" xml:space="preserve">
          <source>How do I manipulate arrays of bits?</source>
          <target state="translated">Как мне манипулировать массивами кусочков?</target>
        </trans-unit>
        <trans-unit id="f91d0deef997d3bfa3ece796fb840e0045a0792b" translate="yes" xml:space="preserve">
          <source>How do I match XML, HTML, or other nasty, ugly things with a regex?</source>
          <target state="translated">Как сопоставить XML,HTML или другие неприятные,некрасивые вещи с регексом?</target>
        </trans-unit>
        <trans-unit id="9e10d6b9fcc0dce9241e02f9e3f41bcdabf8cf6b" translate="yes" xml:space="preserve">
          <source>How do I match a regular expression that's in a variable?</source>
          <target state="translated">Как мне сопоставить регулярное выражение,которое находится в переменной?</target>
        </trans-unit>
        <trans-unit id="5d4e304caa9da74ae39c7e0f1bc8a660a934e36b" translate="yes" xml:space="preserve">
          <source>How do I merge two hashes?</source>
          <target state="translated">Как мне объединить два хэша?</target>
        </trans-unit>
        <trans-unit id="e98a867a19e12d012764c76bf6e04f0613af63d6" translate="yes" xml:space="preserve">
          <source>How do I modify the shadow password file on a Unix system?</source>
          <target state="translated">Как изменить файл теневых паролей на Unix-системе?</target>
        </trans-unit>
        <trans-unit id="c7095e8729e8a7f2287429c858bc0e6162426248" translate="yes" xml:space="preserve">
          <source>How do I multiply matrices?</source>
          <target state="translated">Как мне умножить матрицы?</target>
        </trans-unit>
        <trans-unit id="9460689c66cd7c2602f152fc7b62b5a75f54acdd" translate="yes" xml:space="preserve">
          <source>How do I open a file without blocking?</source>
          <target state="translated">Как открыть файл без блокировки?</target>
        </trans-unit>
        <trans-unit id="9724c57d7e62b1229f27e461cfe00d869c775e7e" translate="yes" xml:space="preserve">
          <source>How do I pack arrays of doubles or floats for XS code?</source>
          <target state="translated">Как упаковать массивы двойников или плавающих для XS-кода?</target>
        </trans-unit>
        <trans-unit id="4400dc02ad15b6fc00f373b7446035015d4ee6bf" translate="yes" xml:space="preserve">
          <source>How do I pad a string with blanks or pad a number with zeroes?</source>
          <target state="translated">Как пропустить строку с пробелами или пропустить число с нулями?</target>
        </trans-unit>
        <trans-unit id="d0e3e8a036359d14fc456cf2c14236b5f608bd62" translate="yes" xml:space="preserve">
          <source>How do I parse a mail header?</source>
          <target state="translated">Как разобрать почтовый заголовок?</target>
        </trans-unit>
        <trans-unit id="9e0cafd923d528d129dae6e8757b0045ebfe45d2" translate="yes" xml:space="preserve">
          <source>How do I perform an operation on a series of integers?</source>
          <target state="translated">Как выполнить операцию над рядом целых чисел?</target>
        </trans-unit>
        <trans-unit id="0ea5e302520f6bb39c41ab5c626ec6b77bff9c77" translate="yes" xml:space="preserve">
          <source>How do I permute N elements of a list?</source>
          <target state="translated">Как пермутировать N элементов списка?</target>
        </trans-unit>
        <trans-unit id="2bb4f19e6e2b56ae1fd37e0d6e014e129c77c2b4" translate="yes" xml:space="preserve">
          <source>How do I prevent &quot;object version X.XX does not match bootstrap parameter Y.YY&quot; errors?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b942fa715d105d63d048d010625e34a4e15cc06" translate="yes" xml:space="preserve">
          <source>How do I print out or copy a recursive data structure?</source>
          <target state="translated">Как распечатать или скопировать рекурсивные структуры данных?</target>
        </trans-unit>
        <trans-unit id="0cee12c0d629b76061795de4e8ea8e8aad20c9a2" translate="yes" xml:space="preserve">
          <source>How do I print something out in color?</source>
          <target state="translated">Как распечатать что-нибудь в цвете?</target>
        </trans-unit>
        <trans-unit id="8c5e011ff87e317620443254f20726209e4d5142" translate="yes" xml:space="preserve">
          <source>How do I print to more than one file at once?</source>
          <target state="translated">Как распечатать более чем на один файл одновременно?</target>
        </trans-unit>
        <trans-unit id="8e6e30c99d7d46a63b6dd2a8de7f090b5c3b78f8" translate="yes" xml:space="preserve">
          <source>How do I process an entire hash?</source>
          <target state="translated">Как мне обработать целый гашиш?</target>
        </trans-unit>
        <trans-unit id="271b9d3d652ec230aba0c388cad00cfb6ec4cadb" translate="yes" xml:space="preserve">
          <source>How do I process each word on each line?</source>
          <target state="translated">Как обработать каждое слово в каждой строке?</target>
        </trans-unit>
        <trans-unit id="067d5b88bfca3ed1b6b7d97cd252f5dd16cbb5b2" translate="yes" xml:space="preserve">
          <source>How do I process/modify each element of an array?</source>
          <target state="translated">Как обработать/модифицировать каждый элемент массива?</target>
        </trans-unit>
        <trans-unit id="4b013be3c59b874a12db528d39cfb66ea2b4d285" translate="yes" xml:space="preserve">
          <source>How do I profile my Perl programs?</source>
          <target state="translated">Как профилировать мои программы на Perl?</target>
        </trans-unit>
        <trans-unit id="907ce6af6f55d655a78f0e8c0ae363954d37ba4f" translate="yes" xml:space="preserve">
          <source>How do I put a &quot;-?&quot; option into a Getopt::Long?</source>
          <target state="translated">Как вставить опцию &quot;-?&quot; в Getopt::Long?</target>
        </trans-unit>
        <trans-unit id="c7fe97c54150572fb4431657021f14d59fd4861f" translate="yes" xml:space="preserve">
          <source>How do I put a password on my web pages?</source>
          <target state="translated">Как поместить пароль на мои веб-страницы?</target>
        </trans-unit>
        <trans-unit id="aabceca15e4a4d5d9ca824c2b010057c5ffb938d" translate="yes" xml:space="preserve">
          <source>How do I randomly update a binary file?</source>
          <target state="translated">Как случайным образом обновить двоичный файл?</target>
        </trans-unit>
        <trans-unit id="be52f21f6d10d6ab8f3f91d7f9754bf001810264" translate="yes" xml:space="preserve">
          <source>How do I read and write the serial port?</source>
          <target state="translated">Как прочитать и записать серийный порт?</target>
        </trans-unit>
        <trans-unit id="88cf95522fd81b968df3c101e350990093c3aa09" translate="yes" xml:space="preserve">
          <source>How do I read email?</source>
          <target state="translated">Как читать электронную почту?</target>
        </trans-unit>
        <trans-unit id="f7f8ec70d59120dd78e53b84aba791742e9edd1e" translate="yes" xml:space="preserve">
          <source>How do I read just one key without waiting for a return key?</source>
          <target state="translated">Как прочитать только один ключ,не дожидаясь возвратного ключа?</target>
        </trans-unit>
        <trans-unit id="b3ea24ef99830bfeddb0edd113b634795cbe4cbc" translate="yes" xml:space="preserve">
          <source>How do I recompress using a different compression?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d36808740d961fdd3bc4db24c2ee814f31ee7c" translate="yes" xml:space="preserve">
          <source>How do I redefine a builtin function, operator, or method?</source>
          <target state="translated">Как переопределить встроенную функцию,оператора или метод?</target>
        </trans-unit>
        <trans-unit id="64b8d2bb065ca77fe0dc5f5fef705f4b317c4fca" translate="yes" xml:space="preserve">
          <source>How do I redirect to another page?</source>
          <target state="translated">Как перейти на другую страницу?</target>
        </trans-unit>
        <trans-unit id="0261e937b4173727b02c00645ba76e6a415fae20" translate="yes" xml:space="preserve">
          <source>How do I reformat a paragraph?</source>
          <target state="translated">Как переформатировать абзац?</target>
        </trans-unit>
        <trans-unit id="0eeeab64d2dc7e3dd771f347a9a11591454f54b3" translate="yes" xml:space="preserve">
          <source>How do I remove HTML from a string?</source>
          <target state="translated">Как удалить HTML из строки?</target>
        </trans-unit>
        <trans-unit id="7190f2c95452c7e338420c52915e20b7f528657f" translate="yes" xml:space="preserve">
          <source>How do I remove consecutive pairs of characters?</source>
          <target state="translated">Как удалить последовательные пары символов?</target>
        </trans-unit>
        <trans-unit id="d5da8d0925bfcf1ec95ecac71470e320a20303f5" translate="yes" xml:space="preserve">
          <source>How do I reset an each() operation part-way through?</source>
          <target state="translated">Как перезагрузить каждую()операцию по частям?</target>
        </trans-unit>
        <trans-unit id="344b42394088d6a1b32ccef3d8e8decb8e4c01b4" translate="yes" xml:space="preserve">
          <source>How do I reverse a string?</source>
          <target state="translated">Как перевернуть струну?</target>
        </trans-unit>
        <trans-unit id="c109790cdec5d8d7c505dc674edb8df7914a81e2" translate="yes" xml:space="preserve">
          <source>How do I select a random element from an array?</source>
          <target state="translated">Как выбрать случайный элемент из массива?</target>
        </trans-unit>
        <trans-unit id="199c93de57e75c85ebb9d101614dabcde24b6614" translate="yes" xml:space="preserve">
          <source>How do I select a random line from a file?</source>
          <target state="translated">Как выбрать случайную строку из файла?</target>
        </trans-unit>
        <trans-unit id="39ccafc4ea9b3fd7b952612609873f9c549c7c42" translate="yes" xml:space="preserve">
          <source>How do I send email?</source>
          <target state="translated">Как отправить электронную почту?</target>
        </trans-unit>
        <trans-unit id="56fc4c1960e173cac75e9d994591b6be91c2c2f5" translate="yes" xml:space="preserve">
          <source>How do I set CPU limits?</source>
          <target state="translated">Как установить лимиты процессора?</target>
        </trans-unit>
        <trans-unit id="73ae95585e094adfdbb75ef9f256a18859cff476" translate="yes" xml:space="preserve">
          <source>How do I set a file's timestamp in perl?</source>
          <target state="translated">Как установить временную метку файла на perl?</target>
        </trans-unit>
        <trans-unit id="7015da22cf6dfd7afb1594ce5e8862f937d3b755" translate="yes" xml:space="preserve">
          <source>How do I set the time and date?</source>
          <target state="translated">Как установить время и дату?</target>
        </trans-unit>
        <trans-unit id="36b77dc941cd48cd98a47f8dbd2c57de165d3aa2" translate="yes" xml:space="preserve">
          <source>How do I shuffle an array randomly?</source>
          <target state="translated">Как перетасовать массив случайным образом?</target>
        </trans-unit>
        <trans-unit id="c56fb4f98404c5161610269f73993e7de95a3de7" translate="yes" xml:space="preserve">
          <source>How do I skip some return values?</source>
          <target state="translated">Как пропустить некоторые возвратные значения?</target>
        </trans-unit>
        <trans-unit id="f999ee460d48e77fd71574c2f54756bd21091885" translate="yes" xml:space="preserve">
          <source>How do I sort a hash (optionally by value instead of key)?</source>
          <target state="translated">Как отсортировать хэш (опционально по значению вместо ключа)?</target>
        </trans-unit>
        <trans-unit id="3557025618ab23a2cf788475e1bcca26065db241" translate="yes" xml:space="preserve">
          <source>How do I sort an array by (anything)?</source>
          <target state="translated">Как отсортировать массив по (чему-нибудь)?</target>
        </trans-unit>
        <trans-unit id="11e9e959693213fc786f53e3eeef7ea5001cbb5a" translate="yes" xml:space="preserve">
          <source>How do I start a process in the background?</source>
          <target state="translated">Как начать процесс на заднем плане?</target>
        </trans-unit>
        <trans-unit id="e8df49adcf72001a3aba0a320e673d15d1fbff49" translate="yes" xml:space="preserve">
          <source>How do I store complex data structures with DB_File?</source>
          <target state="translated">Как хранить сложные структуры данных с помощью DB_File?</target>
        </trans-unit>
        <trans-unit id="d0810d8592d3996c240e80dd3d6e5421e650a5a9" translate="yes" xml:space="preserve">
          <source>How do I strip blank space from the beginning/end of a string?</source>
          <target state="translated">Как снять пустое место с начала/конца строки?</target>
        </trans-unit>
        <trans-unit id="8ae8648605278dba0e8e66d1aa18bb02cd9cbee2" translate="yes" xml:space="preserve">
          <source>How do I substitute case-insensitively on the LHS while preserving case on the RHS?</source>
          <target state="translated">Как заменить нечувствительный к регистру LHS,сохранив при этом регистр на RHS?</target>
        </trans-unit>
        <trans-unit id="32d79b5f1ff74cbc3bfb77b42941e7971f7cd494" translate="yes" xml:space="preserve">
          <source>How do I tell the difference between errors from the shell and perl?</source>
          <target state="translated">Как отличить ошибки в оболочке от perl?</target>
        </trans-unit>
        <trans-unit id="402cd06b394cf67e3d76498ee9b3e9b9d87437a0" translate="yes" xml:space="preserve">
          <source>How do I temporarily block warnings?</source>
          <target state="translated">Как временно заблокировать предупреждения?</target>
        </trans-unit>
        <trans-unit id="c0789eca0c8fd61b4175e61db4aa71f599404e50" translate="yes" xml:space="preserve">
          <source>How do I test whether two arrays or hashes are equal?</source>
          <target state="translated">Как проверить,равны ли два массива или хэши?</target>
        </trans-unit>
        <trans-unit id="e84b81ceb7f858ca3fa98015c2c4dfea66af9e8b" translate="yes" xml:space="preserve">
          <source>How do I timeout a slow event?</source>
          <target state="translated">Как сделать тайм-аут медленным событием?</target>
        </trans-unit>
        <trans-unit id="4865802f290eeeec02fbec1851daaa986a328389" translate="yes" xml:space="preserve">
          <source>How do I transfer files in binary mode ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46e5cb6feaa9bdc58f6ceead41bdfe807157710" translate="yes" xml:space="preserve">
          <source>How do I trap control characters/signals?</source>
          <target state="translated">Как поймать управляющие символы/сигналы?</target>
        </trans-unit>
        <trans-unit id="d2dd15b6c1b33b3c86eddf841d0c83120333ce34" translate="yes" xml:space="preserve">
          <source>How do I traverse a directory tree?</source>
          <target state="translated">Как пройти по дереву каталогов?</target>
        </trans-unit>
        <trans-unit id="e9dd0c064f83a182ab0d7dad0b56b72fe36b708b" translate="yes" xml:space="preserve">
          <source>How do I unescape a string?</source>
          <target state="translated">Как расстегнуть веревку?</target>
        </trans-unit>
        <trans-unit id="de74f402e85f9eee7aa46222792929c66c3f3ab7" translate="yes" xml:space="preserve">
          <source>How do I use MIME to make an attachment to a mail message?</source>
          <target state="translated">Как использовать MIME для вложения в почтовое сообщение?</target>
        </trans-unit>
        <trans-unit id="d3ed87430fcbcc3ae6919edba6458d4a0ecbd944" translate="yes" xml:space="preserve">
          <source>How do I use a module without installing it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6da1c1f95c027b2d1444208c25f958dcd9f486" translate="yes" xml:space="preserve">
          <source>How do I use a regular expression to strip C-style comments from a file?</source>
          <target state="translated">Как использовать регулярное выражение для удаления комментариев в стиле C из файла?</target>
        </trans-unit>
        <trans-unit id="a8b6bf66c7856a15f241de6c0802175e07cd63b3" translate="yes" xml:space="preserve">
          <source>How do I use all this in extensions?</source>
          <target state="translated">Как использовать все это в расширениях?</target>
        </trans-unit>
        <trans-unit id="b826b48e54f42be4d7b4af41a8de11eb743f6b7a" translate="yes" xml:space="preserve">
          <source>How do I use an SQL database?</source>
          <target state="translated">Как использовать базу данных SQL?</target>
        </trans-unit>
        <trans-unit id="2bdd87983f12ab09515439198b26c02b64e724f4" translate="yes" xml:space="preserve">
          <source>How do I validate input?</source>
          <target state="translated">Как подтвердить ввод?</target>
        </trans-unit>
        <trans-unit id="26964c4f36b19d9f1a78d8688cbdbdb4cea51cb7" translate="yes" xml:space="preserve">
          <source>How do I verify a credit card checksum?</source>
          <target state="translated">Как проверить контрольную сумму кредитной карты?</target>
        </trans-unit>
        <trans-unit id="4f3796bf485f2eb722b7ed35a129d4469581633e" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;; however, since &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Как мы это делаем? Вы можете сначала подумать об использовании &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; ; однако, поскольку в результате &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; пустые поля закрываются, вы никогда не узнаете, была ли запись доходом или расходом. Ой. Что ж, вы всегда можете использовать &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="103fbca18a8de8029a50cc2b1c4a72ca20bf5fba" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;split&lt;/code&gt;; however, since &lt;code&gt;split&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;substr&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb503b87f7ea09a8ed712efab2105d52de66798" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt; ? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="translated">Как мы узнаем, является ли &lt;code&gt;U&lt;/code&gt; первым форматом в &lt;code&gt;pat&lt;/code&gt; ? Что ж, если у нас есть указатель на начало &lt;code&gt;pat&lt;/code&gt; , тогда, если мы видим &lt;code&gt;U&lt;/code&gt; , мы можем проверить, находимся ли мы все еще в начале строки. Итак, вот где настраивается &lt;code&gt;pat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b8d788126db97a55dce37692218aca769c60ab7" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt;? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c2d105be109eed3cac8eac59cfe5a2af927614" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="translated">Как мы подготовимся к тому, чтобы это исправить? Сначала мы находим нужный код - &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; происходит во время выполнения, поэтому он будет в одном из</target>
        </trans-unit>
        <trans-unit id="5d7d9138e293d0199d65703623c0ff89dd97e453" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;pack&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a7f470a36048c277bd60a862a28514c120a416" translate="yes" xml:space="preserve">
          <source>How do you know that you've made the right decisions? Have you picked an interface design that will cause problems later? Have you picked the most appropriate name? Do you have any questions?</source>
          <target state="translated">Откуда ты знаешь,что принял правильные решения? Вы выбрали дизайн интерфейса,который вызовет проблемы в дальнейшем? Вы выбрали наиболее подходящее имя? У вас есть вопросы?</target>
        </trans-unit>
        <trans-unit id="41a4f1d575f0f11ff6874b18c40b76daeb66d4c2" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; ? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="translated">Как это распечатать? Почему ты не можешь сказать просто &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; ? Как вы это сортируете? Как передать его функции или получить обратно из функции? Это объект? Можете ли вы сохранить его на диск, чтобы прочитать его позже? Как получить доступ к целым строкам или столбцам этой матрицы? Все ли значения должны быть числовыми?</target>
        </trans-unit>
        <trans-unit id="7a08ef652d92b58fe7f054cbc142a1867f296373" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;print @AoA&lt;/code&gt;? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db30a52c84584239974d26d09f54763e3e6b602" translate="yes" xml:space="preserve">
          <source>How do you want to capitalize those words?</source>
          <target state="translated">Как ты хочешь написать эти слова с заглавной буквы?</target>
        </trans-unit>
        <trans-unit id="057ea76fe6b43747bac035e0aa618c75b67755d7" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">Как &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; с &lt;code&gt;P&lt;/code&gt; работает? Представьте себе какой-то указатель в буфере, который будет распакован: если это не нулевой указатель (который разумно выдаст значение &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), у нас есть начальный адрес - но что тогда? Perl не имеет возможности узнать , как долго это &amp;laquo;фиксированная длина строки&amp;raquo; есть, так что до вас , чтобы указать фактический размер как явный длина после &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb23bf82dfe8e718e7ef8eacd292b571d084be2" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;unpack&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;undef&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9905196a168946e4c1e199eb5d4a39f1df926922" translate="yes" xml:space="preserve">
          <source>How does C3 work</source>
          <target state="translated">Как работает C3</target>
        </trans-unit>
        <trans-unit id="ec67f8e66f8cd607856093fe73d4e05432e16189" translate="yes" xml:space="preserve">
          <source>How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?</source>
          <target state="translated">Как Perl сравнивается с другими языками,такими как Java,Python,REXX,Scheme или Tcl?</target>
        </trans-unit>
        <trans-unit id="1c4f7191bdf4e77d9f3df9d3633a24eb4798422b" translate="yes" xml:space="preserve">
          <source>How does Perl store UTF-8 strings?</source>
          <target state="translated">Как Perl хранит струны UTF-8?</target>
        </trans-unit>
        <trans-unit id="d6555d1bc4e0774734c01cf5a9778e9667013a49" translate="yes" xml:space="preserve">
          <source>How does UTF-8 represent Unicode characters?</source>
          <target state="translated">Как UTF-8 представляет символы Юникода?</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc6d699d794fc3ac271d46b893bbe5d8af9561d" translate="yes" xml:space="preserve">
          <source>How does the HAS_QUUX become defined where it needs to be? Well, if Foonix happens to be Unixy enough to be able to run the Configure script, and Configure has been taught about detecting and testing quux(), the HAS_QUUX will be correctly defined. In other platforms, the corresponding configuration step will hopefully do the same.</source>
          <target state="translated">Как определить HAS_QUUX там,где он должен быть? Ну,если Foonix будет достаточно Unixy для запуска скрипта Configure,а Configure будет обучена обнаружению и тестированию quux(),HAS_QUUX будет правильно определен.На других платформах,соответствующий шаг конфигурации,как мы надеемся,сделает то же самое.</target>
        </trans-unit>
        <trans-unit id="a7654b1f75662fbb39441273d3ed984d7a322d6a" translate="yes" xml:space="preserve">
          <source>How far up the call stack should &lt;code&gt;$Test&lt;/code&gt; look when reporting where the test failed.</source>
          <target state="translated">Насколько высоко в стеке вызовов должен смотреть &lt;code&gt;$Test&lt;/code&gt; сообщая, где тест не удался.</target>
        </trans-unit>
        <trans-unit id="085217ef4c6745e3415b3c7e78584430d39a3a20" translate="yes" xml:space="preserve">
          <source>How field hashes work</source>
          <target state="translated">Как работают полевые хеши</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">Как это работает</target>
        </trans-unit>
        <trans-unit id="debefefe9570a7f478b45607468c1f04ecf9084c" translate="yes" xml:space="preserve">
          <source>How long to wait for child processes and threads before aborting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aeac53e476a9bc19466fb717cce28dc3a661453" translate="yes" xml:space="preserve">
          <source>How many bits fit in the NaN depends on what kind of floating points are being used, but on the most common platforms (64-bit IEEE 754, or the x86 80-bit long doubles) there are 51 and 61 bits available, respectively. (There would be 52 and 62, but the quiet/signaling bit of NaNs takes away one.) However, because of the floating-point-to- integer-and-back conversions, please test carefully whether you get back what you put in. If your integers are only 32 bits wide, you probably should not rely on more than 32 bits of payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8392c4bc182245c6112422d8ac379f29dc0269" translate="yes" xml:space="preserve">
          <source>How many days shall we keep statistics about downloads?</source>
          <target state="translated">Сколько дней мы будем хранить статистику по скачиванию?</target>
        </trans-unit>
        <trans-unit id="a2df7a98d6c586141cd04b6aa0105c17934a6b57" translate="yes" xml:space="preserve">
          <source>How many items shall we keep in the statistics about downloads?</source>
          <target state="translated">Сколько пунктов мы будем хранить в статистике о загрузках?</target>
        </trans-unit>
        <trans-unit id="a4c476d15c4f91ec82f82f8c5a4b611455926ad6" translate="yes" xml:space="preserve">
          <source>How many things you have to skip over when moving from the beginning of a string or array to a specific position within it. Thus, the minimum offset is zero, not one, because you don&amp;rsquo;t skip anything to get to the first item.</source>
          <target state="translated">Сколько вещей вы должны пропустить при переходе от начала строки или массива к определенной позиции в нем. Таким образом, минимальное смещение равно нулю, а не единице, потому что вы ничего не пропускаете, чтобы перейти к первому элементу.</target>
        </trans-unit>
        <trans-unit id="e8f69207ec93ea9ac0d7bd7d78ad22c5fad82d93" translate="yes" xml:space="preserve">
          <source>How much memory will an X kb tar file need?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d061df76ab13c25cd39004271d0f48f24f772c" translate="yes" xml:space="preserve">
          <source>How multiple interpreters and concurrency are supported</source>
          <target state="translated">Как поддерживаются несколько переводчиков и параллелизм</target>
        </trans-unit>
        <trans-unit id="6077b2c6a621300c72c26286304312a48389905e" translate="yes" xml:space="preserve">
          <source>How often are new versions of Perl released?</source>
          <target state="translated">Как часто выходят новые версии Perl?</target>
        </trans-unit>
        <trans-unit id="09667313848c3831b4f83a58be79ca17489cfe27" translate="yes" xml:space="preserve">
          <source>How stable is Perl?</source>
          <target state="translated">Насколько стабилен Перл?</target>
        </trans-unit>
        <trans-unit id="83c34a283446a710c37e72f2a9adb47d8902892c" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to emulate backticks safely.</source>
          <target state="translated">Способ вычисления этой строки полностью зависит от интерпретатора команд в вашей системе. На большинстве платформ вам придется защищать метасимволы оболочки, если вы хотите, чтобы они обрабатывались буквально. На практике это сделать сложно, так как неясно, как избежать каких-либо символов. См. В &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; чистый и безопасный пример ручной &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; для безопасной имитации обратных кавычек.</target>
        </trans-unit>
        <trans-unit id="9eed5100d867c777939bb5769caf179997d17506" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; to emulate backticks safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c335ff6cb2a45884654c99fc61e53c7a376324b" translate="yes" xml:space="preserve">
          <source>How to &lt;code&gt;declare()&lt;/code&gt; a dotted-decimal version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0814da3e299e49d2449969ad142f5bd55fcc256" translate="yes" xml:space="preserve">
          <source>How to &lt;code&gt;parse()&lt;/code&gt; a version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e58ed61895689f9ea71e1d65dd7b363842c21f" translate="yes" xml:space="preserve">
          <source>How to Eat an Egg on a Net</source>
          <target state="translated">Как съесть яйцо в сети.</target>
        </trans-unit>
        <trans-unit id="1e92c63bea5bacbfe17288aa9b727bd5b57d76ef" translate="yes" xml:space="preserve">
          <source>How to Export</source>
          <target state="translated">Как экспортировать</target>
        </trans-unit>
        <trans-unit id="c94aa75d1f562c0c7126364d18c31a48ccae10ce" translate="yes" xml:space="preserve">
          <source>How to Import</source>
          <target state="translated">Как импортировать</target>
        </trans-unit>
        <trans-unit id="66e5306e1ee37b9c8432fab22e675761fdae05d9" translate="yes" xml:space="preserve">
          <source>How to build it - possible changes to Makefile.PL etc.</source>
          <target state="translated">Как его построить-возможные изменения в Makefile.PL и т.д.</target>
        </trans-unit>
        <trans-unit id="276af2b0e47e1128b2d6988024c5aa973d55b3ad" translate="yes" xml:space="preserve">
          <source>How to check for a legal version string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200eebf37528bcbed0445247c76a5eb54f9e1c23" translate="yes" xml:space="preserve">
          <source>How to compare version objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca504da3ad384a1782b8a80c01519809d8213b8a" translate="yes" xml:space="preserve">
          <source>How to contribute to the perlfaq</source>
          <target state="translated">Как внести свой вклад в перлфак</target>
        </trans-unit>
        <trans-unit id="d80ee544d5d5799659326d52d976ff8d1a12d506" translate="yes" xml:space="preserve">
          <source>How to contribute to this document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f26a635f2b0eee95797f21034bacde6a2960b0" translate="yes" xml:space="preserve">
          <source>How to convert a module from decimal to dotted-decimal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59750c3fc03389b5d7028878d6d502ec39f41a63" translate="yes" xml:space="preserve">
          <source>How to create a new module</source>
          <target state="translated">Как создать новый модуль</target>
        </trans-unit>
        <trans-unit id="4b6cf27d781b549a9ad503d5e122d5adb52f744e" translate="yes" xml:space="preserve">
          <source>How to declare() a dotted-decimal version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117233b2c5097bb47b4e325f79c07984d73d5ef7" translate="yes" xml:space="preserve">
          <source>How to get a package, unwrap it, and make a change before building it?</source>
          <target state="translated">Как получить пакет,развернуть его и внести изменения перед тем,как строить его?</target>
        </trans-unit>
        <trans-unit id="581ecead393f1357725f2a7ad157c2752daf62ea" translate="yes" xml:space="preserve">
          <source>How to install it.</source>
          <target state="translated">Как его установить.</target>
        </trans-unit>
        <trans-unit id="6a513660bb1d74aac4457f5e1ad35cd324a50563" translate="yes" xml:space="preserve">
          <source>How to parse() a version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ad195185248d449699ab965e2e195908cc3f7" translate="yes" xml:space="preserve">
          <source>How to release and distribute a module.</source>
          <target state="translated">Как выпустить и распространить модуль.</target>
        </trans-unit>
        <trans-unit id="fac65371d245ce74fd54b584511aa21b655f4973" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="translated">Как сообщать об ошибках. &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; говорит, что нужно генерировать исключение при любой ошибке форматирования POD. &lt;code&gt;stderr&lt;/code&gt; сообщает об ошибках при стандартной ошибке, но не создает исключение. &lt;code&gt;pod&lt;/code&gt; сообщает, что в итоговую документацию следует включить раздел &amp;laquo;ОШИБКИ POD&amp;raquo;, содержащий сводку ошибок. &lt;code&gt;none&lt;/code&gt; игнорирует ошибки POD полностью, насколько это возможно.</target>
        </trans-unit>
        <trans-unit id="d8e06e503e624ee14cb08fcb7aa8200b1d1a33be" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;die&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d2e49b42408e54cf7a34c3e80635f480f9c4a8" translate="yes" xml:space="preserve">
          <source>How to use Field Hashes</source>
          <target state="translated">Как использовать полевые хэши</target>
        </trans-unit>
        <trans-unit id="fc1ff928efd359368d94e6d36c9ac3ed9b57df61" translate="yes" xml:space="preserve">
          <source>How to use ppport.h</source>
          <target state="translated">Как использовать ppport.h</target>
        </trans-unit>
        <trans-unit id="76a1aee9e2d87dca5af8b9f3523a520421f66d36" translate="yes" xml:space="preserve">
          <source>How to use the perlfaq</source>
          <target state="translated">Как использовать перлфак</target>
        </trans-unit>
        <trans-unit id="3f24180ceba0ec0cc68f9d5c0e1e26d52c83ce1f" translate="yes" xml:space="preserve">
          <source>How you access/control keyboards, screens, and pointing devices (&quot;mice&quot;) is system-dependent. Try the following modules:</source>
          <target state="translated">Порядок доступа/управления клавиатурами,экранами и указательными устройствами (&quot;мышами&quot;)зависит от системы.Попробуйте следующие модули:</target>
        </trans-unit>
        <trans-unit id="4bc300db17dcedeb6194b557a3ba400e45f35668" translate="yes" xml:space="preserve">
          <source>How you choose to license your work is a personal decision. The general mechanism is to assert your Copyright and then make a declaration of how others may copy/use/modify your work.</source>
          <target state="translated">Как вы решили лицензировать свою работу-это личное решение.Общий механизм состоит в том,чтобы отстаивать ваше Авторское право,а затем делать заявление о том,как другие могут копировать/пользовать/изменять ваше произведение.</target>
        </trans-unit>
        <trans-unit id="eb2f13a23bf4830d2fc62239cefe549717cd58f6" translate="yes" xml:space="preserve">
          <source>How your various pieces of data relate to each other and what shape they make when you put them all together, as in a rectangular table or a triangular tree.</source>
          <target state="translated">Как соотносятся друг с другом различные кусочки данных и какую форму они придают,когда вы складываете их все вместе,как в прямоугольной таблице или треугольном дереве.</target>
        </trans-unit>
        <trans-unit id="49e45b77d6ea8c9934575389c7d37f20873b7d78" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;change()&lt;/code&gt; inherited from &lt;code&gt;Unicode::Collate&lt;/code&gt; allows such a tailoring that is reserved by &lt;code&gt;locale&lt;/code&gt;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a5d362bff5ef9a53ac39d40f0d72384a7a7980" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;entry&lt;/code&gt; is allowed, even if it is used for &lt;code&gt;locale&lt;/code&gt; support, to add or override mappings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b89735ac32202767302de6090cfe3b522ac706" translate="yes" xml:space="preserve">
          <source>However adding a Time::Piece object to another Time::Piece object will cause a runtime error.</source>
          <target state="translated">Однако добавление объекта Time::Piece в другой объект Time::Piece приведет к ошибке во время выполнения.</target>
        </trans-unit>
        <trans-unit id="30f041c654fc533b28dcc332c81f8669c3b80359" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt; ), even though the same text in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt; .</source>
          <target state="translated">Однако любые другие комбинации &lt;code&gt;\&lt;/code&gt; , за которыми следует символ, не заменяются, а только пропускаются, чтобы на следующем шаге проанализировать их как регулярные выражения. Поскольку &lt;code&gt;\c&lt;/code&gt; на этом шаге пропускается, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; в RE, возможно, обрабатывается как символ массива (например, &lt;code&gt;@foo&lt;/code&gt; ), даже если тот же текст в &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; дает интерполяцию &lt;code&gt;\c@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa46c7dac1006200659c34da5fea0149776dd8d" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt;), even though the same text in &lt;code&gt;qq//&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e29f719714863d70b942d575046dbb5cba98f5" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="translated">Однако вызов этих методов влияет только на использование перечисленных выше методов, которые могут возвращать подключение к данным. Они не влияют на методы &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; и те, которые не требуют подключения к данным.</target>
        </trans-unit>
        <trans-unit id="de13c057041819bc6b844abfeff87d29540cb81e" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd9e96cfe2926dfabdbc85765517e42ef1d89e7" translate="yes" xml:space="preserve">
          <source>However if you use them for methods it is up to you to figure out how to make inheritance work.)</source>
          <target state="translated">Однако если вы используете их в качестве методов,то только от вас зависит,как сделать так,чтобы наследование работало&quot;).</target>
        </trans-unit>
        <trans-unit id="3eb546f277a4853248567d6d99dbadcec1483c0f" translate="yes" xml:space="preserve">
          <source>However it is possible to :</source>
          <target state="translated">Однако можно :</target>
        </trans-unit>
        <trans-unit id="b048a4ce1b3f69d17018ba3c836a5e60080a819e" translate="yes" xml:space="preserve">
          <source>However the parent classes are set, the package's &lt;code&gt;@ISA&lt;/code&gt; variable will contain a list of those parents. This is simply a list of scalars, each of which is a string that corresponds to a package name.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; установлены ли родительские классы, переменная пакета @ISA будет содержать список этих родительских классов . Это просто список скаляров, каждый из которых представляет собой строку, соответствующую имени пакета.</target>
        </trans-unit>
        <trans-unit id="ba3e62d1138ee32c59c072f255ef49bd8748a854" translate="yes" xml:space="preserve">
          <source>However the results of other styles of rounding differ if the digit immediately to the right of the rounding place (skipping the decimal point) is 5 and if there are no digits, or no digits other than 0, after that 5. In such cases:</source>
          <target state="translated">Однако результаты других стилей округления различаются,если цифра непосредственно справа от места округления (пропуская десятичную точку)равна 5,и если после нее нет ни одной цифры,или ни одной цифры,отличной от 0,5.В таких случаях:</target>
        </trans-unit>
        <trans-unit id="4fbf8823a3b3cfa62eaf7d0dd429a9afbd37439d" translate="yes" xml:space="preserve">
          <source>However the test engine bleeds these message to screen in unexpected moments. Two messages of this kind</source>
          <target state="translated">Однако в непредвиденные моменты тестовый двигатель выводит это сообщение на экран.Два таких сообщения</target>
        </trans-unit>
        <trans-unit id="ef8fc937e43b67ff40714fcd8d7fd4e3c6c06fbf" translate="yes" xml:space="preserve">
          <source>However you should never rely on the numerical position of any opcode within the opset. In other words both sides of a bit vector operator should be opsets returned from Opcode functions.</source>
          <target state="translated">Однако вы никогда не должны полагаться на числовое положение любого опкода внутри опсета.Другими словами,обе стороны битового векторного оператора должны быть опсетами,возвращаемыми из функций опкода.</target>
        </trans-unit>
        <trans-unit id="553943043c049c659e40aebd03db5306b0148501" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;sudo&lt;/code&gt; sets the real user or group ID to that of the target identity, not just the effective ID as set-id bits do. As a result, Perl can't detect that it is running under &lt;code&gt;sudo&lt;/code&gt;, and so won't automatically take its own security precautions such as turning on taint mode. Where &lt;code&gt;sudo&lt;/code&gt; configuration dictates exactly which command can be run, the approved command may include a &lt;code&gt;-T&lt;/code&gt; option to perl to enable taint mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98648e73024116127cb39bd5de118b8a0a2cc6ca" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="translated">Однако Filter :: Simple достаточно умен, чтобы заметить ваш существующий &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; и сделать с ним все правильно. То есть, если вы явно определяете подпрограмму &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; в пакете, использующем Filter :: Simple, эта подпрограмма &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; все равно будет вызываться сразу после любого установленного вами фильтра.</target>
        </trans-unit>
        <trans-unit id="f6d3a8dddc21154e6d620bf1f1a45edff899ff21" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;import&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;import&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;import&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b48fb21a2bbb8cdba9c4ae239ab0a9635d85aa" translate="yes" xml:space="preserve">
          <source>However, Perl supports Unicode, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">Однако Perl поддерживает Unicode, см. &lt;a href=&quot;perluniintro&quot;&gt;Perluniintro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6f0fb90e2229030c78d6a2fabfcae7c71bc14e" translate="yes" xml:space="preserve">
          <source>However, Pod::Simple (and presumably all derived parsers) offers the &lt;code&gt;nbsp_for_S&lt;/code&gt; option which, if enabled, will suppress all S events, and instead change all spaces in the content to non-breaking spaces. This is intended for formatters that output to a format that has no code that means the same as S&amp;lt;...&amp;gt;, but which has a code/character that means non-breaking space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf2ba42f69a41e6f42882a675ee34d4602093f3" translate="yes" xml:space="preserve">
          <source>However, Pod::Simple (and presumably all derived parsers) offers the &lt;code&gt;nix_X_codes&lt;/code&gt; option which, if enabled, will suppress all X events and ignore their content. For formatters/processors that don't use X events, this is presumably quite useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aacf8e8d0ef0c63358a4dd55406f6405076e03d" translate="yes" xml:space="preserve">
          <source>However, a dynamically loaded Perl extension is forced to use some symbols from the perl executable, e.g., to know how to find the arguments to the functions: the arguments live on the perl internal evaluation stack. The solution is to put the main code of the interpreter into a DLL, and make the</source>
          <target state="translated">Однако динамически загружаемое расширение Perl вынуждено использовать некоторые символы из исполняемого файла perl,например,чтобы знать,как найти аргументы к функциям:аргументы живут на внутреннем стеке оценки perl.Решение заключается в том,чтобы поместить основной код интерпретатора в DLL и сделать так,чтобы</target>
        </trans-unit>
        <trans-unit id="cb42fd65a00722a5c95e1e740839f3eb31964f36" translate="yes" xml:space="preserve">
          <source>However, a misapplied space-to-NBSP replacement could (wrongly) produce something equivalent to this:</source>
          <target state="translated">Однако,неправильное использование пространства для замены NBSP может (ошибочно)привести к чему-то эквивалентному этому:</target>
        </trans-unit>
        <trans-unit id="81448f13f8166a4612eb5d956580cdb8ee3e6da5" translate="yes" xml:space="preserve">
          <source>However, a value assigned to &lt;code&gt;$(&lt;/code&gt; must be a single number used to set the real gid. So the value given by &lt;code&gt;$(&lt;/code&gt; should</source>
          <target state="translated">Однако значение, присвоенное &lt;code&gt;$(&lt;/code&gt; должно быть единственным числом, используемым для установки реального gid. Таким образом, значение, присвоенное &lt;code&gt;$(&lt;/code&gt; должно</target>
        </trans-unit>
        <trans-unit id="2623bb5aade26c0a0ddb97e7e99b8d0d79bed6e1" translate="yes" xml:space="preserve">
          <source>However, anyone particularly interested in getting the full value of the treelet, can just traverse the content of the treeleet @$treelet_object. To wit:</source>
          <target state="translated">Однако любой,кто особенно заинтересован в получении полного значения дерева,может просто пройтись по содержимому дерева @$treelet_object.В смысле:</target>
        </trans-unit>
        <trans-unit id="120fef724fd1ad9704e66311dce9e65e6c74f159" translate="yes" xml:space="preserve">
          <source>However, as an 80% solution it is still effective, as it has caught bugs in the past.</source>
          <target state="translated">Тем не менее,как решение на 80%,оно все еще эффективно,так как оно ловит ошибки в прошлом.</target>
        </trans-unit>
        <trans-unit id="9b024ed706553b3e26fb5776910e94a5d18ec48c" translate="yes" xml:space="preserve">
          <source>However, be aware this will delete ALL untracked content. You can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3b493b7bf70efb7fa8d258ead45b41c49f7ae9" translate="yes" xml:space="preserve">
          <source>However, because there are</source>
          <target state="translated">Однако,потому что есть</target>
        </trans-unit>
        <trans-unit id="4c76c10ddfa1b1106d8945288c840e976b5200f2" translate="yes" xml:space="preserve">
          <source>However, before calling Configure, you need to check if using adb is a viable choice in the first place. Because Android doesn't have a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4c0892873afe913676eee2f3455aa2ddb34a7e" translate="yes" xml:space="preserve">
          <source>However, between perl v5.10.0 and v5.24.0, it could be used lexically by writing &lt;code&gt;my $_&lt;/code&gt;. Making &lt;code&gt;$_&lt;/code&gt; refer to the global &lt;code&gt;$_&lt;/code&gt; in the same scope was then possible with &lt;code&gt;our $_&lt;/code&gt;. This experimental feature was removed and is now a fatal error, but you may encounter it in older code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd72d7b069cc72d81b73b3f8597e881a55bd64a6" translate="yes" xml:space="preserve">
          <source>However, calling any &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; methods in such an &lt;code&gt;END&lt;/code&gt; block will most likely</source>
          <target state="translated">Однако вызов любых методов &lt;a href=&quot;threads&quot;&gt;потоков&lt;/a&gt; в таком блоке &lt;code&gt;END&lt;/code&gt; , скорее всего,</target>
        </trans-unit>
        <trans-unit id="4d2c94143c1c2488e5582ae3924e1321e1fc2e29" translate="yes" xml:space="preserve">
          <source>However, everything referenced by the returned value is a fresh copy in the joining thread, even if a returned object had in the child thread been a copy of something that previously existed in the parent thread. After joining, the parent will therefore have a duplicate of each such object. This sometimes matters, especially if the object gets mutated; this can especially matter for private data to which a returned subroutine provides access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c314b40d0f00ce73038bbcc98e7f0ca7b1457690" translate="yes" xml:space="preserve">
          <source>However, for the following, the items are already shared, so their references are added directly to the queue, and no cloning takes place:</source>
          <target state="translated">Однако,для следующего,элементы уже являются общими,поэтому их ссылки добавляются непосредственно в очередь,и клонирование не происходит:</target>
        </trans-unit>
        <trans-unit id="bdc1303f64a141ea4136f512c4911ecba9b92d10" translate="yes" xml:space="preserve">
          <source>However, for the one-off simple case where I don't want to pull out a full templating system, I'll use a string that has two Perl scalar variables in it. In this example, I want to expand &lt;code&gt;$foo&lt;/code&gt; and &lt;code&gt;$bar&lt;/code&gt; to their variable's values:</source>
          <target state="translated">Однако для одноразового простого случая, когда я не хочу создавать полную систему шаблонов, я буду использовать строку, содержащую две скалярные переменные Perl. В этом примере я хочу расширить &lt;code&gt;$foo&lt;/code&gt; и &lt;code&gt;$bar&lt;/code&gt; до значений их переменных:</target>
        </trans-unit>
        <trans-unit id="5ff029079aabc6f922c78c4701467310a318c5e3" translate="yes" xml:space="preserve">
          <source>However, if a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt; -marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding. (&lt;code&gt;BOM&lt;/code&gt; -less UTF-8 cannot be effectively recognized or differentiated from ISO 8859-1 or other eight-bit encodings.)</source>
          <target state="translated">Однако, если сценарий Perl начинается с &lt;code&gt;BOM&lt;/code&gt; Unicode (UTF-16LE, UTF16-BE или UTF-8), или если сценарий выглядит как UTF-16 без метки &lt;code&gt;BOM&lt;/code&gt; любой степени порядка байтов, Perl будет правильно читать в script в качестве соответствующей кодировки Unicode. ( UTF-8 без &lt;code&gt;BOM&lt;/code&gt; невозможно эффективно распознать или отличить от ISO 8859-1 или других восьмибитных кодировок.)</target>
        </trans-unit>
        <trans-unit id="7a530119f7016cecda2473b0ac614ce58e818515" translate="yes" xml:space="preserve">
          <source>However, if a particular species of quote character is included in the delimiter specification, then that type of quote will be correctly handled. for example, if &lt;code&gt;$text&lt;/code&gt; is:</source>
          <target state="translated">Однако, если в спецификацию разделителя включен конкретный вид кавычек, то этот тип кавычек будет правильно обработан. например, если &lt;code&gt;$text&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9e2ebae72b3d33fdf44dedb85d641ca00f3f57a1" translate="yes" xml:space="preserve">
          <source>However, if all you want to do is change your time zone, you can probably get away with setting an environment variable:</source>
          <target state="translated">Однако,если все,что вы хотите сделать,это изменить свой часовой пояс,вы,вероятно,сможете обойтись без установки переменной окружения:</target>
        </trans-unit>
        <trans-unit id="e12d8527d56fa8ab8e8667f75a93e6392109725d" translate="yes" xml:space="preserve">
          <source>However, if hitting EOF is an expected and normal event, you do not want to exit simply because you have run out of input. Instead, you probably just want to exit an input loop. You can then test to see if an actual error has caused the loop to terminate, and act accordingly:</source>
          <target state="translated">Однако,если попадание в EOF является ожидаемым и нормальным событием,вы не хотите выходить просто потому,что у вас закончился входной сигнал.Вместо этого,вы,вероятно,просто хотите выйти из входного цикла.Затем Вы можете проверить,вызвала ли фактическая ошибка прекращение цикла,и действовать соответствующим образом:</target>
        </trans-unit>
        <trans-unit id="29e1fafc250caebd597211caeac2164bfd06193d" translate="yes" xml:space="preserve">
          <source>However, if the &lt;code&gt;]&lt;/code&gt; is the</source>
          <target state="translated">Однако, если &lt;code&gt;]&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="8b420ee9db4dd8d8741d24e9570ff42a7cdea42c" translate="yes" xml:space="preserve">
          <source>However, if the command contained arguments that contained whitespace, stringifying the command would lose the significance of the whitespace. Therefore, &lt;code&gt;IPC::Cmd&lt;/code&gt; will quote any arguments containing whitespace in your command if the command is passed as an arrayref and contains special characters.</source>
          <target state="translated">Однако, если команда содержала аргументы, содержащие пробелы, преобразование команды в строку потеряло бы значение пробелов. Следовательно, &lt;code&gt;IPC::Cmd&lt;/code&gt; будет заключать в кавычки любые аргументы, содержащие пробелы в вашей команде, если команда передается как ссылка на массив и содержит специальные символы.</target>
        </trans-unit>
        <trans-unit id="6cc1c4bf7e539678ba51b5fda046a8f31ec28dde" translate="yes" xml:space="preserve">
          <source>However, if the data can't be parsed as valid Perl, then it is passed as an uninterpreted string. For example:</source>
          <target state="translated">Однако,если данные не могут быть разобраны как действительный Perl,то они передаются как неинтерпретированная строка.Например:</target>
        </trans-unit>
        <trans-unit id="713c4744650ad1f6870512c16d626634ea8370be" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="translated">Однако, если входной текст был передан в переменную, значение &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; этой переменной обновляется, чтобы указать на первый символ после извлеченного текста. Это означает, что в контексте списка различные подпрограммы могут использоваться во многом как регулярные выражения. Например:</target>
        </trans-unit>
        <trans-unit id="95b66c82de22ae75797335cbe11c9ea09bb6550e" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;pos&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755d5a289c3e42c14904a4a718307f0b6e480799" translate="yes" xml:space="preserve">
          <source>However, if the kernel set-id script feature isn't disabled, Perl will complain loudly that your set-id script is insecure. You'll need to either disable the kernel set-id script feature, or put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="translated">Однако,если функция скрипта set-id ядра не отключена,Perl будет громко жаловаться,что ваш скрипт set-id небезопасен.Вам нужно будет либо отключить функцию скрипта kernel set-id,либо обернуть скрипт обёрткой на C.Обёртка на C-это просто скомпилированная программа,которая ничего не делает,кроме как вызывает вашу программу на Perl.Скомпилированные программы не подвержены ошибке ядра,которая вредит скриптам set-id.Вот простая обёртка,написанная на Си:</target>
        </trans-unit>
        <trans-unit id="cbc9ddee054ab9351fcec45d24db4192d4d2775c" translate="yes" xml:space="preserve">
          <source>However, if the list element is itself a variable, it appears that you can change a list element. However, the list element is the variable, not the data. You're not changing the list element, but something the list element refers to. The list element itself doesn't change: it's still the same variable.</source>
          <target state="translated">Однако,если элемент списка сам по себе является переменной,то кажется,что элемент списка можно изменить.Однако элемент списка является переменной,а не данными.Вы не изменяете элемент списка,а что-то,на что ссылается элемент списка.Сам элемент списка не изменяется:это все та же переменная.</target>
        </trans-unit>
        <trans-unit id="1ff33c873357001776962a640d53584ca4867e68" translate="yes" xml:space="preserve">
          <source>However, if the string value associated with &amp;lt;reject&amp;gt; is &quot;MAX&quot;, then &lt;code&gt;extract_tagged&lt;/code&gt; returns the complete text up to the point of failure. If the string is &quot;PARA&quot;, &lt;code&gt;extract_tagged&lt;/code&gt; returns only the first paragraph after the tag (up to the first line that is either empty or contains only whitespace characters). If the string is &quot;&quot;, the the default behaviour (i.e. failure) is reinstated.</source>
          <target state="translated">Однако, если строковое значение, связанное с &amp;lt;reject&amp;gt;, равно &amp;laquo;MAX&amp;raquo;, то &lt;code&gt;extract_tagged&lt;/code&gt; возвращает полный текст до точки сбоя. Если строка - &amp;laquo;PARA&amp;raquo;, &lt;code&gt;extract_tagged&lt;/code&gt; возвращает только первый абзац после тега (до первой строки, которая либо пуста, либо содержит только символы пробела). Если строка &quot;&quot;, поведение по умолчанию (то есть сбой) восстанавливается.</target>
        </trans-unit>
        <trans-unit id="a40e24fb0252cc9815324344313381a888c122c8" translate="yes" xml:space="preserve">
          <source>However, if there is no matching &lt;code&gt;}&lt;/code&gt;, Perl doesn't know if it was mistakenly omitted, or if &lt;code&gt;[^\n]{&lt;/code&gt; was desired, and raises this error. If you meant the former, add the right brace; if you meant the latter, escape the brace with a backslash, like so: &lt;code&gt;\N\{&lt;/code&gt;</source>
          <target state="translated">Однако, если нет соответствия &lt;code&gt;}&lt;/code&gt; , Perl не знает , если он был ошибочно указан, или если &lt;code&gt;[^\n]{&lt;/code&gt; было необходимо, и поднимает эту ошибку. Если вы имели в виду первое, добавьте правую скобку; если вы имели в виду последнее, экранируйте фигурную скобку обратной косой чертой, например: &lt;code&gt;\N\{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4db7ce89f0ac0ff04237db2ffe65056106401da4" translate="yes" xml:space="preserve">
          <source>However, if you have fixed sized records, then you might do something more like this:</source>
          <target state="translated">Однако,если вы исправили размер записи,то вы можете сделать что-то более похожее:</target>
        </trans-unit>
        <trans-unit id="f0a31e0971a11a0c1d822f02efd0eb4f79c74f3a" translate="yes" xml:space="preserve">
          <source>However, if you set &quot;_AUTO =&amp;gt; 1&quot; in the %Lexicon in, ThisProject/I18N/en.pm (assuming that English (en) is the language that all your programmers will be using for this project's internal message keys), then you don't ever have to go adding lines like this</source>
          <target state="translated">Однако, если вы установите &quot;_AUTO =&amp;gt; 1&quot; в% Lexicon in, ThisProject / I18N / en.pm (при условии, что английский (en) - это язык, который все ваши программисты будут использовать для ключей внутренних сообщений этого проекта), тогда вам никогда не нужно добавлять такие строки</target>
        </trans-unit>
        <trans-unit id="a09363cd76b1dde7e3a57d25fdf3272ced3af2ab" translate="yes" xml:space="preserve">
          <source>However, if you want the old behavior (and think carefully about that because it's a weird side effect), you can pass a hash slice instead. Perl 5.004 didn't make this a special case:</source>
          <target state="translated">Однако,если вы хотите старое поведение (и тщательно подумайте об этом,потому что это странный побочный эффект),вы можете передать кусочек гашиша вместо этого.Perl 5.004 не сделал это особым случаем:</target>
        </trans-unit>
        <trans-unit id="e5e7624dee9866ac2811666ebfbf093d8c557c15" translate="yes" xml:space="preserve">
          <source>However, if you'd like to override that just for perl, execute something like the following in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bcfc80dafa07d27c313feb7344f54609aa72b0" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt; , you can produce a diff like this:</source>
          <target state="translated">Однако, если вы не используете git, вы все равно можете создать подходящий патч. Вам понадобится чистая копия исходного кода Perl для сравнения. Носильщики предпочитают унифицированные дифференциалы. Используя GNU &lt;code&gt;diff&lt;/code&gt; , вы можете получить такой результат:</target>
        </trans-unit>
        <trans-unit id="d3945c60d94533987656e9ddcf44eefd8a3f5cf4" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt;, you can produce a diff like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912422cfe6349f661271a697889a1ce04bbb7530" translate="yes" xml:space="preserve">
          <source>However, in list context, the line input operator returns all of the lines as a list. The first line goes into &lt;code&gt;@array[1]&lt;/code&gt; and the rest of the lines mysteriously disappear:</source>
          <target state="translated">Однако в контексте списка оператор строкового ввода возвращает все строки в виде списка. Первая строка переходит в &lt;code&gt;@array[1]&lt;/code&gt; а остальные таинственным образом исчезают:</target>
        </trans-unit>
        <trans-unit id="a4cbc737f6445190a51915b10ef52747baeb38d6" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt; : it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt; ) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt; . Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="translated">Однако в случае, если вы используете &lt;code&gt;LANGUAGE&lt;/code&gt; : он влияет на язык информационных сообщений, предупреждений и сообщений об ошибках, выводимых командами (другими словами, как &lt;code&gt;LC_MESSAGES&lt;/code&gt; ), но имеет более высокий приоритет, чем &lt;code&gt;LC_ALL&lt;/code&gt; . Более того, это не отдельное значение, а &amp;laquo;путь&amp;raquo; (список, разделенный &amp;laquo;:&amp;raquo;)</target>
        </trans-unit>
        <trans-unit id="7b6e0b1c8600ac9825ba07e5dbd49e2921e845b8" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt;: it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt;) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt;. Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264a100caceb32bafbc7cc09c2eb6cec03b010a6" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdfb88ca6aeb7caca106e8a86ebad4a7bd611554" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="translated">Однако это означает, что такие функции, как &lt;code&gt;is_deeply()&lt;/code&gt; не могут использоваться для тестирования внутренних компонентов строковых перегруженных объектов. В этом случае я бы предложил &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test :: Deep,&lt;/a&gt; который содержит более гибкие функции тестирования для сложных структур данных.</target>
        </trans-unit>
        <trans-unit id="4b56d396ba6f1980056b816ee33f44e386574d54" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="translated">Однако важно помнить, что потоки Perl не могут волшебным образом делать что-либо, если потоки вашей операционной системы не позволяют этого. Так что, если ваша система блокирует весь процесс на &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; , Perl обычно тоже.</target>
        </trans-unit>
        <trans-unit id="13d58a858b7bda780cb252aafbed51984ace596c" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;sleep()&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9bc751c2a736800a6ded071584d5744291603c" translate="yes" xml:space="preserve">
          <source>However, it is possible to set up attribute handlers that are called at other points in the program's compilation or execution, by explicitly stating the phase (or phases) in which you wish the attribute handler to be called. For example:</source>
          <target state="translated">Однако,можно настроить обработчики атрибутов,которые вызываются в других точках компиляции или выполнения программы,явно указывая фазу (или фазы),в которой вы хотите вызвать обработчик атрибутов.Например:</target>
        </trans-unit>
        <trans-unit id="9f3f862372589763b899aeb3b91931550dc55057" translate="yes" xml:space="preserve">
          <source>However, it may happen that parsing must be restarted at the beginning when various circumstances occur along the way. An example is if the program turns out to be so large that there are jumps in it that won't fit in the normal 16 bits available. There are two special regops that can hold bigger jump destinations, BRANCHJ and LONGBRANCH. The parse is restarted, and these are used instead of the normal shorter ones. Whenever restarting the parse is required, the function returns failure and sets a flag as to what needs to be done. This is passed up to the top level routine which takes the appropriate action and restarts from scratch. In the case of needing longer jumps, the &lt;code&gt;RExC_use_BRANCHJ&lt;/code&gt; flag is set in the &lt;code&gt;RExC_state_t&lt;/code&gt; structure, which the functions know to inspect before deciding how to do branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495f4657c76d2b9516ad67652bc58b23f23940a2" translate="yes" xml:space="preserve">
          <source>However, it would be unwise to write tests such as:</source>
          <target state="translated">Однако писать такие тесты было бы неразумно:</target>
        </trans-unit>
        <trans-unit id="b30399fa602102d2334ab528f7c1b9ececea8d0d" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt; :</source>
          <target state="translated">Однако &lt;b&gt;выполнить&lt;/b&gt; операции в таком порядке невозможно : например, вам нужно найти значения &lt;code&gt;$b&lt;/code&gt; и &lt;code&gt;$c&lt;/code&gt; прежде чем складывать их вместе. Итак, другой поток, который проходит через дерево &lt;code&gt;op_next&lt;/code&gt; - это порядок выполнения: каждая операция имеет поле op_next, которое указывает на следующую операцию, которая будет запущена, поэтому следование этим указателям говорит нам, как Perl выполняет код. Мы можем пройти по дереву в этом порядке, используя опцию &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;B::Terse&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3c7146a5076741d60fd0b54759165e4d154c0a24" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;exec&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9a82c6ab7917617f6a85766c8d2b1d78c8def0" translate="yes" xml:space="preserve">
          <source>However, it's possible to have distinct files in different directories that intentionally has the same name, just differing in case, that should be reported. Hence, you may force the behavior by setting this to true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3fd83f97cb972df229bb4d55a4c188b477d626" translate="yes" xml:space="preserve">
          <source>However, long experience has shown that many programming tasks may be significantly simplified by using repeated subexpressions that may match zero-length substrings. Here's a simple example being:</source>
          <target state="translated">Однако,как показывает многолетний опыт,многие задачи программирования могут быть значительно упрощены за счет использования повторяющихся подвыражений,которые могут совпадать с подстроками нулевой длины.Вот простой пример:</target>
        </trans-unit>
        <trans-unit id="d855fdc3242b3ecead3a30530ccd98509a636a5c" translate="yes" xml:space="preserve">
          <source>However, not everything you can write in Perl code can be written in the above shorthand system -- not by a long shot. For example, consider the Italian translator from the beginning of this article, who wanted the Italian for &quot;I didn't find any files&quot; as a special case, instead of &quot;I found 0 files&quot;. That couldn't be specified (at least not easily or simply) in our shorthand system, and it would have to be written out in full, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc9947a9b58d2f4b1cd78cbf550721e43e5ecea" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt; . If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="translated">Однако обратите внимание, что &lt;code&gt;sv_unmagic&lt;/code&gt; удаляет всю магию определенного &lt;code&gt;type&lt;/code&gt; из &lt;code&gt;SV&lt;/code&gt; . Если вы хотите удалить только определенную магию &lt;code&gt;type&lt;/code&gt; основанного на виртуальной таблице magic, используйте вместо этого &lt;code&gt;sv_unmagicext&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="755c4cc30c87595f07d149af2b7b703fd4c79822" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt;. If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0770ad99650293f49eefd8e2631959530003f02" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;use encoding&lt;/code&gt; actually had three distinct effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3714710035618507b561178df5f82b541c8974c8" translate="yes" xml:space="preserve">
          <source>However, note that even as the specified layers are &quot;pushed on top&quot; for open() and binmode(), this doesn't mean that the effects are limited to the &quot;top&quot;: PerlIO layers can be very 'active' and inspect and affect layers also deeper in the stack. As an example there is a layer called &quot;raw&quot; which repeatedly &quot;pops&quot; layers until it reaches the first layer that has declared itself capable of handling binary data. The &quot;pushed&quot; layers are processed in left-to-right order.</source>
          <target state="translated">Однако,обратите внимание,что даже когда указанные слои &quot;нажимаются сверху&quot; для open()и binmode(),это не означает,что эффекты ограничиваются &quot;вершиной&quot;:Слои PerlIO могут быть очень &quot;активны&quot; и осматривать и воздействовать на слои также глубже в стеке.В качестве примера можно привести слой,называемый &quot;raw&quot;,который многократно &quot;всплывает&quot; до тех пор,пока не достигнет первого слоя,который объявил себя способным обрабатывать бинарные данные.Подталкиваемые&quot; слои обрабатываются в порядке слева направо.</target>
        </trans-unit>
        <trans-unit id="e68001f4c648450ca168ec0cde1c3f91a0e8624c" translate="yes" xml:space="preserve">
          <source>However, on Windows systems this isn't quite true prior to Visual Studio 15, at which point Microsoft fixed a bug. A race can occur if you use the following operations on earlier Windows platforms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237e671ead4e4f448bac6dfef4927434cec18095" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; . This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="translated">Однако в более ранних версиях Perl или если вы передаете строки подпрограммам за пределами области действия функции, вы можете принудительно использовать правила Unicode, изменив кодировку на UTF-8, выполнив &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; . Это можно безопасно использовать с любой строкой, поскольку он проверяет и не изменяет строки, которые уже были обновлены.</target>
        </trans-unit>
        <trans-unit id="84e3115d2c9ec337c66cb9d3c294ddc900febcb1" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt;. This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d790ef4b7b652054f8ef9f08eabcfceb4c9c9d7" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt; ):</source>
          <target state="translated">Однако только двойные кавычки &amp;laquo;интерполируют&amp;raquo; переменные и специальные символы, такие как новые строки ( &lt;code&gt;\n&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e743ca902ceb7982199b34d10b972ebd948b6061" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4f7d0c2e35a50b2d5589c3de0999f54d0755a9" translate="yes" xml:space="preserve">
          <source>However, other accidents of history have made Perl a well-accepted language for design of server-side programs (generally in CGI form) for Web site interfaces. Localization of static pages in Web sites is trivial, feasible either with simple language-negotiation features in servers like Apache, or with some kind of server-side inclusions of language-appropriate text into layout templates. However, I think that the localization of Perl-based search systems (or other kinds of dynamic content) in Web sites, be they public or access-restricted, is where Maketext will see the greatest use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f40951889d3378b60336de3c7c19a48f84efe15" translate="yes" xml:space="preserve">
          <source>However, over the years, changes in gcc, GNU ld, and Solaris ld have made it difficult to automatically detect which ld ultimately gets called. You may have to manually edit config.sh and add the -Wl,-E flags yourself, or else run Configure interactively and add the flags at the appropriate prompts.</source>
          <target state="translated">Однако с годами изменения в gcc,GNU ld и Solaris ld затруднили автоматическое определение того,какой ld в конце концов будет назван.Возможно,вам придётся вручную отредактировать config.sh и самостоятельно добавить флаги -Wl,-E,или же выполнить команду Configure в интерактивном режиме и добавить флаги по соответствующим подсказкам.</target>
        </trans-unit>
        <trans-unit id="fed61c8dd1afaf8e79d8960756c0fdb435ad95dc" translate="yes" xml:space="preserve">
          <source>However, people often either forget to add &lt;code&gt;BEGIN&lt;/code&gt;, or mistakenly group &lt;code&gt;use_ok&lt;/code&gt; with other tests in a single &lt;code&gt;BEGIN&lt;/code&gt; block, which can create subtle differences in execution order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abae8990eb0eaeb22dbcaa2121181a9c3213635" translate="yes" xml:space="preserve">
          <source>However, since I am running a very recent Hurd snapshot, in which a lot of bugs that were exposed by the Perl test suite have been fixed, you may encounter more failures. Likely candidates are: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;, &quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; and &quot;lib/time&quot;.</source>
          <target state="translated">Однако,так как я запустил совсем недавно Hurd снимок,в котором было исправлено много ошибок,которые были обнаружены в тестовом наборе Perl,вы можете столкнуться с большим количеством сбоев.Скорее всего,кандидаты:&quot;op/stat&quot;,&quot;lib/io_pipe&quot;,&quot;lib/io_sock&quot;,&quot;lib/io_udp&quot; и &quot;lib/time&quot;.</target>
        </trans-unit>
        <trans-unit id="0a2932991138cff6cda965e1aa59120419d51793" translate="yes" xml:space="preserve">
          <source>However, since prototype checking happens at compile time, the assignment above happens too late to be of much use. You could address this by putting the whole loop of assignments within a BEGIN block, forcing it to occur during compilation.</source>
          <target state="translated">Однако,поскольку проверка прототипа происходит во время компиляции,приведенное выше задание выполняется слишком поздно,чтобы быть полезным.Вы можете решить эту проблему,поместив весь цикл присваиваний в блок BEGIN,заставляя его происходить во время компиляции.</target>
        </trans-unit>
        <trans-unit id="f30360d0680e8617d8855ae3da4bf95cb66d3a40" translate="yes" xml:space="preserve">
          <source>However, since the name is not used by perl except as the return value of &lt;code&gt;caller&lt;/code&gt;, for stack traces or similar, there is no actual requirement that the name be syntactically valid as a perl function name. This could be used to attach extra information that could be useful in debugging stack traces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5dc0373ab5a69dc9065fd1361f3fe68378bd857" translate="yes" xml:space="preserve">
          <source>However, some people find that code harder to read than writing it with parentheses:</source>
          <target state="translated">Однако некоторые люди находят этот код более трудным для чтения,чем написание его в круглых скобках:</target>
        </trans-unit>
        <trans-unit id="b290a654499ed3de25fe105a7a5f328394110489" translate="yes" xml:space="preserve">
          <source>However, strings composed purely of ASCII code points (&lt;code&gt;0x00&lt;/code&gt;..&lt;code&gt;0x7F&lt;/code&gt;) will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33f317ee43849ba21e4562b2cfcaf42b63f23a8" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt; , shows up:</source>
          <target state="translated">Однако это не работает, если конец строки не является новой строкой. Вы можете изменить это &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; на &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; чтобы вы могли подсчитать, сколько раз появляется разделитель входной записи, &lt;code&gt;$/&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9245af6fccc9a0ce411947a6accfc71a28fd8594" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;tr///&lt;/code&gt; to a &lt;code&gt;s///&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt;, shows up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8d86d9a6fdf31c1cce87bc99b477e123d4270e" translate="yes" xml:space="preserve">
          <source>However, the &lt;b&gt;.ph&lt;/b&gt; files almost double in size when built using &lt;b&gt;-h&lt;/b&gt;.</source>
          <target state="translated">Однако при построении с использованием &lt;b&gt;-h&lt;/b&gt; файлы &lt;b&gt;.ph&lt;/b&gt; почти удваиваются в размере .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf442c2f732fb4fe8240d9ec730b9c9278986a2a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;Filter =&amp;gt; 1&lt;/code&gt; flavor of &lt;code&gt;use encoding&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf1c5152a0ddfa7cc0b45d1130d02f94e11246a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;W&lt;/code&gt; specifier does operate on whole characters, as does the &lt;code&gt;U&lt;/code&gt; specifier.</source>
          <target state="translated">Однако спецификатор &lt;code&gt;W&lt;/code&gt; работает с целыми символами, как и спецификатор &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3da026c415acace03626d9fb7e1ee90aa243fe42" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="translated">Однако приведенное выше использование приведет к созданию глобальных переменных во всей программе, что является плохой практикой программирования. Вместо этого &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; создает переменные с лексической областью видимости. Переменные ограничены блоком (т. Е. Набором операторов, окруженных фигурными скобками), в котором они определены.</target>
        </trans-unit>
        <trans-unit id="38d3383a6acfe85a3e5c76aa619706a45144742d" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;my&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a041fd9ed4a1cc9a27e266960cf76f5cd2574980" translate="yes" xml:space="preserve">
          <source>However, the behaviour it enables is always performed by &lt;code&gt;IO::Socket::IP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643bcb3d157afa153f651f6fc7ccfed78f3e704a" translate="yes" xml:space="preserve">
          <source>However, the call in:</source>
          <target state="translated">Однако,звонок:</target>
        </trans-unit>
        <trans-unit id="5357a547fd30e714675256546afb934f7d52ca74" translate="yes" xml:space="preserve">
          <source>However, the ever-increasing internationalization of the Web (whether measured in terms of amount of content, of numbers of content writers or programmers, or of size of content audiences) makes it increasingly likely that the interface to the average Web-based dynamic content service will be localized for two or maybe three languages. It is my hope that Maketext will make that task as simple as possible, and will remove previous barriers to localization for languages dissimilar to English.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ecfcc25810d7a7cdf5b6a2a73a83af471c9442" translate="yes" xml:space="preserve">
          <source>However, the generated Perl function is called in very C-ish style:</source>
          <target state="translated">Однако,сгенерированная функция Perl вызывается в очень C-образном стиле:</target>
        </trans-unit>
        <trans-unit id="be1c834c7d4d71f52243b42559f80aabe198a844" translate="yes" xml:space="preserve">
          <source>However, the matching position of the input variable would be set to &quot;exit;&quot; (i.e.</source>
          <target state="translated">Тем не менее,подходящее положение входной переменной будет установлено на &quot;exit;&quot; (т.е.</target>
        </trans-unit>
        <trans-unit id="25bf3d063af8542ff55fc69607480626e4cfa1dd" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized or assigned to. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95f0313fce5fa0d84ae8a729df3c8f4e82e2159" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized, deleted or used in assignment. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="translated">Однако результат такого среза не может быть локализован,удален или использован при назначении.В противном случае они очень хорошо согласуются с хэш-фрагментами с использованием символа @.</target>
        </trans-unit>
        <trans-unit id="c017b28f94bbc1527d3a99433c0d70601c0484be" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt; .</source>
          <target state="translated">Однако ярлык требует, чтобы вы указали ровно два аргумента командной строки, &lt;code&gt;indirs&lt;/code&gt; и &lt;code&gt;outdir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b66f8dabd20676d1be94167c3e3005cd50687163" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8789f7d9a0995a0db12e65eee11cc6c52128e982" translate="yes" xml:space="preserve">
          <source>However, the use of bare v-strings to initialize version objects is &lt;b&gt;strongly&lt;/b&gt; discouraged in all circumstances. Also, bare v-strings are not completely supported in any version of Perl prior to 5.8.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5988e176ff20437ccf0016e7e2f8d1b308901fa5" translate="yes" xml:space="preserve">
          <source>However, the way a programmer should think about references is not so much in terms of the bare reference count, but in terms of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174d3b644e004445441e24cae4b9fd65f9fed124" translate="yes" xml:space="preserve">
          <source>However, their are many, many other differences. For example, this works in Perl 5:</source>
          <target state="translated">Однако,их много,много других отличий.Например,это работает на Perl 5:</target>
        </trans-unit>
        <trans-unit id="431ca5f68339a06fd3a547e35432cecf8dddda74" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt; . They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt; . Prior to v5.20, It is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; --</source>
          <target state="translated">Однако есть места, где это ломается. Некоторые конструкции Perl предназначены только для Unicode, например &lt;code&gt;\p{Alpha}&lt;/code&gt; . Они предполагают, что 0xD7 всегда имеет значение Unicode (или эквивалент на платформах EBCDIC). Поскольку Latin1 является подмножеством Unicode, а 0xD7 является знаком умножения как в Latin1, так и в Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; никогда не будет соответствовать ему, независимо от языкового стандарта. Аналогичная проблема возникает с &lt;code&gt;\N{...}&lt;/code&gt; . До v5.20, это , следовательно , является плохой идеей использовать &lt;code&gt;\p{}&lt;/code&gt; или &lt;code&gt;\N{}&lt;/code&gt; при простом &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="bfffc2a487e4695cb332617a58fbff944ca5de8f" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt;. They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt;. Prior to v5.20, it is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;use locale&lt;/code&gt;--</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a79d341666f9d08432041587a457666ea4e643" translate="yes" xml:space="preserve">
          <source>However, there is a third way: perl DLL exports the main() function and several callbacks to customize the search path. Below is a complete example of a &quot;Perl loader&quot; which</source>
          <target state="translated">Однако есть и третий способ:perl DLL экспортирует функцию main()и несколько обратных вызовов для настройки пути поиска.Ниже приведен полный пример &quot;Perl загрузчика&quot;,который</target>
        </trans-unit>
        <trans-unit id="167fa8624f523d65d674923630d20eace6f440ad" translate="yes" xml:space="preserve">
          <source>However, there is one other function which manipulates the reference count of its argument. The &lt;code&gt;newRV_inc&lt;/code&gt; function, you will recall, creates a reference to the specified argument. As a side effect, it increments the argument's reference count. If this is not what you want, use &lt;code&gt;newRV_noinc&lt;/code&gt; instead.</source>
          <target state="translated">Однако есть еще одна функция, которая манипулирует счетчиком ссылок своего аргумента. Как вы помните, функция &lt;code&gt;newRV_inc&lt;/code&gt; создает ссылку на указанный аргумент. В качестве побочного эффекта он увеличивает счетчик ссылок аргумента. Если это не то, что вы хотите, используйте вместо этого &lt;code&gt;newRV_noinc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a934c497d33c3b96a41f7573fdbc88756bd17bf7" translate="yes" xml:space="preserve">
          <source>However, these filepaths appear in the list returned by &lt;code&gt;standard_typemap_locations()&lt;/code&gt; in reverse order,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78acaa936efa9d2893b28f11a288123a0f9298ff" translate="yes" xml:space="preserve">
          <source>However, these two XSUBs provide almost identical generated C code: &lt;b&gt;xsubpp&lt;/b&gt; compiler is smart enough to figure out the &lt;code&gt;CODE:&lt;/code&gt; section from the first two lines of the description of XSUB. What about &lt;code&gt;OUTPUT:&lt;/code&gt; section? In fact, that is absolutely the same! The &lt;code&gt;OUTPUT:&lt;/code&gt; section can be removed as well,</source>
          <target state="translated">Однако эти два XSUB предоставляют практически идентичный сгенерированный код C: компилятор &lt;b&gt;xsubpp&lt;/b&gt; достаточно умен, чтобы определить раздел &lt;code&gt;CODE:&lt;/code&gt; из первых двух строк описания XSUB. А как насчет раздела &lt;code&gt;OUTPUT:&lt;/code&gt; ? Фактически, это абсолютно то же самое! Раздел &lt;code&gt;OUTPUT:&lt;/code&gt; также можно удалить,</target>
        </trans-unit>
        <trans-unit id="84b8501e3adfdc161bae2d83215ead9cfc2ea49b" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;a href=&quot;File::Spec::Unix#canonpath%28%29&quot;&gt;&quot;canonpath()&quot; in File::Spec::Unix&lt;/a&gt;. If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8993e8546f1a446361af9208f62149f37c72c7da" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="translated">Однако этот подход ограничен первыми аргументами после &amp;laquo;root&amp;raquo; (снова см. &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). Если есть больше аргументов, которые перемещаются вверх по дереву каталогов, может быть создан недопустимый путь, выходящий за пределы корня.</target>
        </trans-unit>
        <trans-unit id="5458eab9c28fdf9d40e7593c2500908102783b51" translate="yes" xml:space="preserve">
          <source>However, this feature was undeprecated in Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01b858fc25bd1ebdcf816e174585aed80aab581" translate="yes" xml:space="preserve">
          <source>However, this function may return a Unicode string if the environment variable being expanded hasn't been assigned to via %ENV. Access to %ENV is currently always using byte semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7865ef8ee24a1f53476e6455eeebeda223f24ca5" translate="yes" xml:space="preserve">
          <source>However, this only does what you mean if &lt;code&gt;$init_fields&lt;/code&gt; is indeed a hash reference. The condition &lt;code&gt;$init_fields ~~ $REQUIRED_FIELDS&lt;/code&gt; also allows the strings &lt;code&gt;&quot;name&quot;&lt;/code&gt;, &lt;code&gt;&quot;rank&quot;&lt;/code&gt;, &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; as well as any array reference that contains &lt;code&gt;&quot;name&quot;&lt;/code&gt; or &lt;code&gt;&quot;rank&quot;&lt;/code&gt; or &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; anywhere to pass through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b29d0e56857b797fbe9046c1637ec13ba0255e" translate="yes" xml:space="preserve">
          <source>However, this produces a list of temporary integer values as long as the original list of strings, only to reduce it down to a single value again. We can compute the same result more efficiently by using &lt;code&gt;reduce&lt;/code&gt; with a code block that accumulates lengths by writing this instead as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a498e0a44f0f9f8fbe6e40968d0b21c8d56b2479" translate="yes" xml:space="preserve">
          <source>However, this request is ignored, as the current code now uses the low-level math library for directly storing the number parts.</source>
          <target state="translated">Однако этот запрос игнорируется,так как текущий код теперь использует низкоуровневую математическую библиотеку для непосредственного хранения номерных частей.</target>
        </trans-unit>
        <trans-unit id="6b7469fc2b44cf29dd35f31f1f2fa503b7de276c" translate="yes" xml:space="preserve">
          <source>However, this silent upgrading can easily cause problems, if you happen to mix unicode strings with non-Latin1 data -- i.e. byte-strings encoded in UTF-8 or other encodings. The error will not manifest until the combined string is written to output, at which time it would be impossible to see where did the silent upgrading occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c442891dca9145a3b9c79c668f4b9ec23f39a60" translate="yes" xml:space="preserve">
          <source>However, this still does not guarantee that these DLL may be loaded. The reason is the mangling of the name of the</source>
          <target state="translated">Однако это не гарантирует,что эти DLL могут быть загружены.Причиной является искажение названия</target>
        </trans-unit>
        <trans-unit id="2084b9ad89039a2ea6c4200ac2905bee170c22b7" translate="yes" xml:space="preserve">
          <source>However, to help ease understanding, it is suggested that you place a &quot;&amp;amp;&quot; next to the variable name and away from the variable type), and place a &quot;*&quot; near the variable type, but away from the variable name (as in the call to foo above). By doing so, it is easy to understand exactly what will be passed to the C function; it will be whatever is in the &quot;last column&quot;.</source>
          <target state="translated">Однако, чтобы облегчить понимание, рекомендуется поставить &amp;laquo;&amp;amp;&amp;raquo; рядом с именем переменной и в стороне от типа переменной), а &amp;laquo;*&amp;raquo; рядом с типом переменной, но в стороне от имени переменной (как в вызов foo выше). Поступая так, легко понять, что именно будет передано в функцию C; это будет то, что указано в &amp;laquo;последнем столбце&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ae3f94bdf7ac1269b60e51c2ce0911730992c14a" translate="yes" xml:space="preserve">
          <source>However, under some circumstances, this behavior may be excessively slow. For example, suppose you have a million-record file, and you want to do:</source>
          <target state="translated">Однако при некоторых обстоятельствах такое поведение может быть чрезмерно медленным.Например,предположим,что у вас есть файл с миллионными записями,и вы хотите это сделать:</target>
        </trans-unit>
        <trans-unit id="37cab8dafbfef6134cbae52136465a602af12595" translate="yes" xml:space="preserve">
          <source>However, unless you tell &lt;code&gt;Memoize&lt;/code&gt; that these calls are equivalent, it will not know that, and it will compute the values for these invocations of your function separately, and store them separately.</source>
          <target state="translated">Однако, если вы не сообщите &lt;code&gt;Memoize&lt;/code&gt; , что эти вызовы эквивалентны, он не узнает об этом и вычислит значения для этих вызовов вашей функции отдельно и сохранит их отдельно.</target>
        </trans-unit>
        <trans-unit id="142779c491fb94a0d076da32b3296ae6b26999c0" translate="yes" xml:space="preserve">
          <source>However, up through v5.20, Perl initialized things on start-up so that &lt;code&gt;LC_NUMERIC&lt;/code&gt; was set to the &quot;C&quot; locale. But if any code anywhere changed it, it would stay changed. This means that your module can't count on &lt;code&gt;LC_NUMERIC&lt;/code&gt; being something in particular, and you can't expect floating point numbers (including version strings) to have dots in them. If you don't allow for a non-dot, your code could break if anyone anywhere changed the locale. For this reason, v5.22 changed the behavior so that Perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the &quot;C&quot; locale except around the operations internally where it should be something else. Misbehaving XS code will always be able to change the locale anyway, but the most common instance of this is checked for and handled.</source>
          <target state="translated">Однако вплоть до версии 5.20 Perl инициализировал все при запуске, так что &lt;code&gt;LC_NUMERIC&lt;/code&gt; был установлен на локаль &quot;C&quot;. Но если какой-либо код где-нибудь изменит его, он останется измененным. Это означает, что ваш модуль не может рассчитывать на то, что &lt;code&gt;LC_NUMERIC&lt;/code&gt; является чем-то конкретным, и вы не можете ожидать, что числа с плавающей запятой (включая строки версий) будут содержать точки. Если вы не допускаете использование точки без точки, ваш код может сломаться, если кто-нибудь изменит языковой стандарт. По этой причине в v5.22 изменилось поведение, так что Perl пытается сохранить &lt;code&gt;LC_NUMERIC&lt;/code&gt; в локали &quot;C&quot;, за исключением внутренних операций, где это должно быть что-то еще. Неправильный код XS всегда сможет изменить языковой стандарт, но наиболее распространенный случай этого проверяется и обрабатывается.</target>
        </trans-unit>
        <trans-unit id="068b747d32004750485efe98f8d1cbafa2e0e35a" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;&amp;amp;&lt;/code&gt; in the call still overrides the prototype of &lt;code&gt;foo&lt;/code&gt; if present:</source>
          <target state="translated">Однако использование &lt;code&gt;&amp;amp;&lt;/code&gt; в вызове по-прежнему отменяет прототип &lt;code&gt;foo&lt;/code&gt; , если он присутствует:</target>
        </trans-unit>
        <trans-unit id="f9fabcfc6b8511bdc0a7ecd34a3e04f701d2b56e" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt; , or &lt;code&gt;\x0D\x0A&lt;/code&gt; ) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;code&gt;Socket&lt;/code&gt; module supplies the Right Thing for those who want it.</source>
          <target state="translated">Однако использование &lt;code&gt;\015\012&lt;/code&gt; (или &lt;code&gt;\cM\cJ&lt;/code&gt; , или &lt;code&gt;\x0D\x0A&lt;/code&gt; ) может быть утомительным и некрасивым, а также сбивать с толку тех, кто поддерживает код. Таким образом, модуль &lt;code&gt;Socket&lt;/code&gt; предоставляет правильную вещь для тех, кто этого хочет.</target>
        </trans-unit>
        <trans-unit id="bc2515b31d0fe90459c261be099beca3ae68dad0" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt;, or &lt;code&gt;\x0D\x0A&lt;/code&gt;) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;a href=&quot;socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; module supplies the Right Thing for those who want it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163537b4f5c11cd47e9722700a60c6c7ea0ade4a" translate="yes" xml:space="preserve">
          <source>However, using the code requires that you have a working C compiler and can use it to build and install a CPAN module. Here's a solution using the standard &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module, which is already on your system (assuming your system supports POSIX).</source>
          <target state="translated">Однако для использования кода требуется, чтобы у вас был работающий компилятор C и вы могли использовать его для создания и установки модуля CPAN. Вот решение, использующее стандартный модуль &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; , который уже есть в вашей системе (при условии, что ваша система поддерживает POSIX).</target>
        </trans-unit>
        <trans-unit id="a4350da00ad3028f4efc1846f8fc750c07ee286a" translate="yes" xml:space="preserve">
          <source>However, when it's a list-context assignment and you're trying to use &lt;code&gt;||&lt;/code&gt; for control flow, you probably need &lt;code&gt;&quot;or&quot;&lt;/code&gt; so that the assignment takes higher precedence.</source>
          <target state="translated">Однако, когда это присвоение контекста списка и вы пытаетесь использовать &lt;code&gt;||&lt;/code&gt; для потока управления вам, вероятно, понадобится &lt;code&gt;&quot;or&quot;&lt;/code&gt; чтобы присвоение имело более высокий приоритет.</target>
        </trans-unit>
        <trans-unit id="b662692b6fa64e61f6a9c3f800af2536f40b3b4a" translate="yes" xml:space="preserve">
          <source>However, when you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f9727ede39a1ce5211e24f06cf1afdd8d7ee83" translate="yes" xml:space="preserve">
          <source>However, you can change the way an object is smartmatched by overloading the &lt;code&gt;~~&lt;/code&gt; operator. This is allowed to extend the usual smartmatch semantics. For objects that do have an &lt;code&gt;~~&lt;/code&gt; overload, see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">Однако вы можете изменить способ интеллектуального сопоставления объекта, перегрузив оператор &lt;code&gt;~~&lt;/code&gt; . Это позволяет расширить обычную семантику smartmatch. Для объектов, которые имеют перегрузку &lt;code&gt;~~&lt;/code&gt; , см. &lt;a href=&quot;overload&quot;&gt;Перегрузку&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b89d0d284e64c095a60bef4f1dd049a654a9b8f4" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="translated">Однако вы можете подавить &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; , используя явный пустой список импорта. Оба эти события все еще происходят во время компиляции:</target>
        </trans-unit>
        <trans-unit id="260fe9f97d0d69a65905fdc8f061356d4780ef04" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;import&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb959e8b316e23c060bb14a1aa10ea6663e7a66" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt; . We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="translated">Однако при использовании постоянного интерпретатора следует быть более осторожным с пространством имен и областью действия переменных. В предыдущих примерах мы использовали глобальные переменные в пакете по умолчанию &lt;code&gt;main&lt;/code&gt; . Мы точно знали, какой код будет выполняться, и предполагали, что сможем избежать конфликтов переменных и чрезмерного роста таблицы символов.</target>
        </trans-unit>
        <trans-unit id="f80e0acb7e372dabc4a5f7b74c6498f8798ef7a3" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt;. We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66a879553ebe7b620fa37901232bfb863aa6d3d" translate="yes" xml:space="preserve">
          <source>However, you may know that you intend to use the results in a particular context, where some pragmas are already in scope. In this case, you use the &lt;b&gt;ambient_pragmas&lt;/b&gt; method to describe the assumptions you wish to make.</source>
          <target state="translated">Однако вы можете знать, что собираетесь использовать результаты в конкретном контексте, где некоторые прагмы уже находятся в области видимости. В этом случае вы используете метод &lt;b&gt;ambient_pragmas&lt;/b&gt; для описания предположений, которые вы хотите сделать.</target>
        </trans-unit>
        <trans-unit id="13143a50c1533ee9fae63ea9ed2eae1b6ad85192" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56cfa87ada9834b01835bf9c64cf509441054b7b" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="translated">Однако вам может не повезти, если вы ожидаете, что это означает, что на другой стороне есть реальный человек. С модулем &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; другая программа может выдавать себя за человека. Программа может даже приблизиться к прохождению теста Тьюринга.</target>
        </trans-unit>
        <trans-unit id="a422dec568026043ae4e005023457a913a05b272" translate="yes" xml:space="preserve">
          <source>However, you must not do this, for example:</source>
          <target state="translated">Тем не менее,вы не должны этого делать,например:</target>
        </trans-unit>
        <trans-unit id="e3a4e64a25b29be20841a60bc10f2c0bc37e06f9" translate="yes" xml:space="preserve">
          <source>However, you should &lt;b&gt;not&lt;/b&gt; blindly rely on perl always doing the right thing. Particularly, perl will mistakenly return true when you clear the hash by repeatedly calling DELETE until it is empty. You are therefore advised to supply your own SCALAR method when you want to be absolutely sure that your hash behaves nicely in scalar context.</source>
          <target state="translated">Тем не менее, вы должны &lt;b&gt;не&lt;/b&gt; слепо полагаться на Perl всегда делать правильные вещи. В частности, perl по ошибке вернет истину, когда вы очистите хэш, многократно вызывая DELETE, пока он не станет пустым. Поэтому рекомендуется предоставить свой собственный SCALAR-метод, если вы хотите быть абсолютно уверены в том, что ваш хеш ведет себя хорошо в скалярном контексте.</target>
        </trans-unit>
        <trans-unit id="684d82ac83a5f8790e5e4368c88d7c77aa0309c6" translate="yes" xml:space="preserve">
          <source>Hub ID of the hub that is represented in the parent-child relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42118b9b162322837f3cc4bb7657481f703e832" translate="yes" xml:space="preserve">
          <source>Hub subclasses (and some hub utility objects) live under this namespace. It is perfectly reasonable for third party distributions to add new hub subclasses in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a802db1cd7382689ea166fa197e7bee4e5a74a9" translate="yes" xml:space="preserve">
          <source>Hub used by interceptor to grab results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64bf0d9364108763162c7fb9f03b312d24f14b0" translate="yes" xml:space="preserve">
          <source>Hub used by subtests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d2100593fec39720245432930b526325693698" translate="yes" xml:space="preserve">
          <source>Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</source>
          <target state="translated">Хуго ван дер Занден &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="903a8361b68cfddd3da7251d755007dc0e94f5d3" translate="yes" xml:space="preserve">
          <source>Human readable description of the assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eba29a5d2ddda0020c1cac7fb53eb47535a92ce" translate="yes" xml:space="preserve">
          <source>Human readable description of the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9606d069fe25297dd11df0cc8580ee8dbe3f85e7" translate="yes" xml:space="preserve">
          <source>Human readable explanation for the plan being set. This is normally not rendered by most formatters except when the &lt;code&gt;skip&lt;/code&gt; field is also set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1a79a67a1a08817e952e2d08177e5fbf4cba31" translate="yes" xml:space="preserve">
          <source>Human readable explanation for the special behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f687605c0577ef885ee45c1c086d0ad37ee205b5" translate="yes" xml:space="preserve">
          <source>Human readable explanation of why amnesty was granted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2aebac92e9a840f478fce4b6343c22b8d0ca60" translate="yes" xml:space="preserve">
          <source>Human readable string or data structure, this is the information to display. Formatters are free to render the structures however they please. This may contain a blessed object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d2d17793130f2e86c0885a2d78da3c7f24dc7" translate="yes" xml:space="preserve">
          <source>Human readable text for display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14e46ce7d094f9326167acc499698128651be85" translate="yes" xml:space="preserve">
          <source>Hungary</source>
          <target state="translated">Hungary</target>
        </trans-unit>
        <trans-unit id="1938ed7c63e01c8a596d909427e34650befec480" translate="yes" xml:space="preserve">
          <source>HvENAME</source>
          <target state="translated">HvENAME</target>
        </trans-unit>
        <trans-unit id="6d3ea3f5bd46317a0b128c10a43f2b6c88d4d4cb" translate="yes" xml:space="preserve">
          <source>HvENAMELEN</source>
          <target state="translated">HvENAMELEN</target>
        </trans-unit>
        <trans-unit id="867db34eff4673062e6b813ed04df520c5233a3d" translate="yes" xml:space="preserve">
          <source>HvENAMEUTF8</source>
          <target state="translated">HvENAMEUTF8</target>
        </trans-unit>
        <trans-unit id="df110dc29f38c56ef4eec2b4759e744b23e69e1f" translate="yes" xml:space="preserve">
          <source>HvFILL</source>
          <target state="translated">HvFILL</target>
        </trans-unit>
        <trans-unit id="d18ff5331b7e22893e39912957fedf5b97c67829" translate="yes" xml:space="preserve">
          <source>HvNAME</source>
          <target state="translated">HvNAME</target>
        </trans-unit>
        <trans-unit id="9c77eb3e074087eb866a360b06af707ee5df0f01" translate="yes" xml:space="preserve">
          <source>HvNAMELEN</source>
          <target state="translated">HvNAMELEN</target>
        </trans-unit>
        <trans-unit id="c5d2d62591fdff3694f9b23256ac71f286680b41" translate="yes" xml:space="preserve">
          <source>HvNAMEUTF8</source>
          <target state="translated">HvNAMEUTF8</target>
        </trans-unit>
        <trans-unit id="9711a7cfeff071972d36fdd6050e80bc9d749c0b" translate="yes" xml:space="preserve">
          <source>Hyperlinks</source>
          <target state="translated">Hyperlinks</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="68ea31ac882843ca3bb7347afdcbec874605911e" translate="yes" xml:space="preserve">
          <source>I almost always use keys that are themselves valid lexicon values. One notable exception is when the value is quite long. For example, to get the screenful of data that a command-line program might return when given an unknown switch, I often just use a brief, self-explanatory key such as &quot;_USAGE_MESSAGE&quot;. At that point I then go and immediately to define that lexicon entry in the ProjectClass::L10N::en lexicon (since English is always my &quot;project language&quot;):</source>
          <target state="translated">Я почти всегда использую ключи,которые сами по себе являются допустимыми значениями лексики.Одно примечательное исключение-когда значение достаточно длинное.Например,для получения скриншотов данных,которые может вернуть программа командной строки при задании неизвестного ключа,я часто просто использую краткий,необъяснимый ключ,такой как &quot;_USAGE_MESSAGE&quot;.В этот момент я сразу же иду и определяю эту запись в лексиконе ProjectClass::L10N::en (так как английский язык всегда является моим &quot;языком проекта&quot;):</target>
        </trans-unit>
        <trans-unit id="bd142ae3cc7adab96cfaa7558d02068b158e85c3" translate="yes" xml:space="preserve">
          <source>I am also usually active on IRC as 'autarch' on &lt;code&gt;irc://irc.perl.org&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1174e9f9955c9e61d54f218d08d7285e0e0ae8" translate="yes" xml:space="preserve">
          <source>I am behind a SOCKS firewall, but the Firewall option does not work ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b0de54116e38392536f989ded25ad9bceea24f" translate="yes" xml:space="preserve">
          <source>I am behind an FTP proxy firewall, but cannot access machines outside ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12498934a0d4cbe958ea9ae2277b44bccce11e2" translate="yes" xml:space="preserve">
          <source>I am not root, how can I install a module in a personal directory?</source>
          <target state="translated">Я не корневой,как я могу установить модуль в личный каталог?</target>
        </trans-unit>
        <trans-unit id="720225fb87f4fceb999d3d3c67fa208ed54fe066" translate="yes" xml:space="preserve">
          <source>I am sure there are bugs in the code. If you do find any, or can suggest any enhancements, I would welcome your comments.</source>
          <target state="translated">Я уверен,что в коде есть ошибки.Если вы все-таки найдете какие-нибудь,или можете предложить какие-нибудь улучшения,я буду рад вашим комментариям.</target>
        </trans-unit>
        <trans-unit id="f822dc00911ca2b5b17523234c19e71174239e30" translate="yes" xml:space="preserve">
          <source>I assume that each language class derives (directly or indirectly) from your project class, and also defines its @ISA, its %Lexicon, or both. But I anticipate no dire consequences if these assumptions do not hold.</source>
          <target state="translated">Я предполагаю,что каждый класс языка происходит (прямо или косвенно)от вашего класса проекта,а также определяет его @ISA,его %Lexicon,или и то,и другое.Но я не предвижу никаких страшных последствий,если эти предположения не оправдаются.</target>
        </trans-unit>
        <trans-unit id="aac2738433180b0fc7eec7ab6421ac5a20b62f00" translate="yes" xml:space="preserve">
          <source>I believe this issue is prevalent not only for Mac Indics but also in other Indic encodings, but the above were the only Indic encodings maps that I could find at &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16283d3f67007c5d32c917f1aef8895827d0a69" translate="yes" xml:space="preserve">
          <source>I believe this issue is prevalent not only for Mac Indics but also in other Indic encodings, but the above were the only Indic encodings maps that I could find at &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4d37f069c57cb7de599233daad3bd27d0a8ebc" translate="yes" xml:space="preserve">
          <source>I can also pass callbacks to the constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bcef0f48a866ba703693e5fcdad43a764ad25a" translate="yes" xml:space="preserve">
          <source>I can also tell prove to save the results again so that it updates its idea of which tests failed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d96c393b63a12dec2fe257877addccb84b91ed" translate="yes" xml:space="preserve">
          <source>I can incorporate these options into my own version of prove. It's pretty simple. Most of the work of prove is handled by App::Prove. The important code in prove is just:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f16057cfc74a8e91522c5a546d3a88bbd9af3c3" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="translated">Я могу представить себе всевозможные обстоятельства, когда вы просто не хотите, чтобы поиск завершался неудачно (поскольку неудача обычно означает, что maketext бросает &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , хотя см. Следующий раздел для большего контроля над этим). Но вот одно обстоятельство, когда лексиконы _AUTO должны быть</target>
        </trans-unit>
        <trans-unit id="73e0e4b77d6bcf01d6041debc1a2e83d30fd057e" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;die&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08456af218bdc4a506b4e778d48d6e90d82b1d13" translate="yes" xml:space="preserve">
          <source>I can tell prove just to run the tests that are failing like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4089c61d9307c046d40cd9abd561382f7f03ee3" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use</source>
          <target state="translated">Я не могу встроить perl в мою программу,или использовать</target>
        </trans-unit>
        <trans-unit id="31d3f8a1fa15d729190062c1ddc4f7dd97a4bdd9" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use _perl.dll_ from my program.</source>
          <target state="translated">Я не могу встраивать perl в свою программу или использовать _perl.dll_из своей программы.</target>
        </trans-unit>
        <trans-unit id="e0dabde4d7970f758fc132b87f569962de8417e4" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use perl.dll from my program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfdb8e8d03951e17fc904de692bb5bbd7335317" translate="yes" xml:space="preserve">
          <source>I cannot run external programs</source>
          <target state="translated">Я не могу запускать внешние программы</target>
        </trans-unit>
        <trans-unit id="993598ed9e1ff928aa61c98c2c0a4e51ef13499b" translate="yes" xml:space="preserve">
          <source>I cleaned it up a little.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ed42e550b2837d803cc938a5c931b4a08219dc" translate="yes" xml:space="preserve">
          <source>I copied the Perl binary from one machine to another, but scripts don't work.</source>
          <target state="translated">Я скопировал двоичный файл Perl с одной машины на другую,но скрипты не работают.</target>
        </trans-unit>
        <trans-unit id="9327e89bd234d7a986b2da9100760b6e37c4547a" translate="yes" xml:space="preserve">
          <source>I could start up faster by delaying compilation until it should be needed, but this gets a &quot;panic: top_level&quot; when using the pragma form in Perl 5.001e.</source>
          <target state="translated">Я мог бы начать быстрее,отложив компиляцию до тех пор,пока она не понадобится,но при использовании прагматической формы в Perl 5.001e это становится &quot;panic:top_level&quot;.</target>
        </trans-unit>
        <trans-unit id="88a201ad71d898eadaddaac681114556a0d035b9" translate="yes" xml:space="preserve">
          <source>I do not anticipate that you will need (or particularly want) to nest bracket groups, but you are welcome to email me with convincing (real-life) arguments to the contrary.</source>
          <target state="translated">Я не ожидаю,что вам понадобятся (или особенно понадобятся)группы для гнездования,но вы можете написать мне по электронной почте с убедительными (реальными)аргументами в пользу обратного.</target>
        </trans-unit>
        <trans-unit id="3bb5142da6ee5443fb8a1f91f511fc41a8d23e27" translate="yes" xml:space="preserve">
          <source>I don't have a C compiler. How can I build my own Perl interpreter?</source>
          <target state="translated">У меня нет компилятора Си.Как я могу создать свой собственный интерпретатор Perl?</target>
        </trans-unit>
        <trans-unit id="d6d0389812dedc1090c3af8ee3195c2e1255c8d3" translate="yes" xml:space="preserve">
          <source>I foresee no problems with having multiple inheritance in your hierarchy of language classes. (As usual, however, Perl will complain bitterly if you have a cycle in the hierarchy: i.e., if any class is its own ancestor.)</source>
          <target state="translated">Я не предвижу проблем с множественным наследованием в вашей иерархии языковых классов.(Однако,как обычно,Perl будет горько жаловаться,если у вас есть цикл в иерархии:т.е.если любой класс является его собственным предком).</target>
        </trans-unit>
        <trans-unit id="371ea8fdbc8bb052c307098a6984a7c87ed2802d" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="translated">Я получаю сообщение об ошибке, когда запускаю это из своей оболочки (которая оказывается bash). Это может выглядеть так, как будто perl забыл, что у него есть функция &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; , но моя строка shebang не является путем к perl, поэтому оболочка запускает сценарий, и я получаю сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="3b40ca07783bb532ad8480c512cbc6f6a04c95d1" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;print()&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b36e7f52406231ec7c4381f27e5a02ba4d1de4" translate="yes" xml:space="preserve">
          <source>I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?</source>
          <target state="translated">Я взял исходники и попытался скомпилировать,но gdbm/динамическая загрузка/маллок/связь/...не получилось.Как мне заставить это работать?</target>
        </trans-unit>
        <trans-unit id="d3f27f69fc434f23222da72a1a4ed476958555fb" translate="yes" xml:space="preserve">
          <source>I have heard of one other type of firewall which requires a login to the firewall with an account, then a second login with &lt;code&gt;user@hostname&lt;/code&gt;. You can still use Net::FTP to traverse these firewalls, but a more manual approach must be taken, eg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aeb2257dccbb467ef10e49ef5687a5f072930e" translate="yes" xml:space="preserve">
          <source>I have no clue what this does. Strips function prefixes?</source>
          <target state="translated">Понятия не имею,что это делает.Префиксы функции полосок?</target>
        </trans-unit>
        <trans-unit id="0cb0121fc9974d9d1b5aed90c164d431509f7248" translate="yes" xml:space="preserve">
          <source>I have seen scripts call a method message, but cannot find it documented ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc30870b270d5fd5a0e0ca93284b0967a0e43a00" translate="yes" xml:space="preserve">
          <source>I have supposed that since this module is concerned with file I/O, almost all normal use of it will be heavily I/O bound. This means that the time to maintain complicated data structures inside the module will be dominated by the time to actually perform the I/O. When there was an opportunity to spend CPU time to avoid doing I/O, I usually tried to take it.</source>
          <target state="translated">Я предположил,что поскольку этот модуль связан с файловым вводом/выводом,то почти все его нормальное использование будет сильно ограничено вводом/выводом.Это означает,что время для поддержания сложных структур данных внутри модуля будет доминировать временем для фактического выполнения ввода/вывода.Когда была возможность потратить процессорное время,чтобы избежать выполнения ввода/вывода,я обычно пытался это сделать.</target>
        </trans-unit>
        <trans-unit id="9f890badb47c01638de767ac6be14f492fbbfa01" translate="yes" xml:space="preserve">
          <source>I installed a Bundle and had a couple of fails. When I retried, everything resolved nicely. Can this be fixed to work on first try?</source>
          <target state="translated">Я установил пучок и у меня была пара неудач.Когда я повторил попытку,все разрешилось хорошо.Это можно исправить с первой попытки?</target>
        </trans-unit>
        <trans-unit id="f93fb27a66a374179e4455b8d8985c2d226a8af1" translate="yes" xml:space="preserve">
          <source>I installed a new version of module X but CPAN keeps saying, I have the old version installed</source>
          <target state="translated">Я установил новую версию модуля X,но CPAN продолжает говорить,что у меня установлена старая версия.</target>
        </trans-unit>
        <trans-unit id="ce465a8fc00712ba52e5306e95737f3b12576087" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of popups</source>
          <target state="translated">Я не знаю ни одного способа узнать состояние всплывающих окон.</target>
        </trans-unit>
        <trans-unit id="50ca6fc19f7270831b580874499d55acf40e475f" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of redirection of popups to the disk</source>
          <target state="translated">Я не знаю,как узнать состояние переадресации всплывающих окон на диск.</target>
        </trans-unit>
        <trans-unit id="74eeceb13c393c687a92a5cda3bd40599b660cd1" translate="yes" xml:space="preserve">
          <source>I lost track; what encoding is the internal format really?</source>
          <target state="translated">Я сбился с пути;какая кодировка на самом деле является внутренним форматом?</target>
        </trans-unit>
        <trans-unit id="d25ced27930e65857371f29ffd1a913f02b5e4b7" translate="yes" xml:space="preserve">
          <source>I love it when a plan comes together</source>
          <target state="translated">Мне нравится,когда план собирается вместе</target>
        </trans-unit>
        <trans-unit id="606078fbab11616b11caaa1df541827c0df787a2" translate="yes" xml:space="preserve">
          <source>I maintain a mailing list on which I occasionally announce new versions of Memoize. The list is for announcements only, not discussion. To join, send an empty message to mjd-perl-memoize-request@Plover.com.</source>
          <target state="translated">Я веду список рассылки,в котором иногда объявляю о новых версиях Memoize.Список предназначен только для объявлений,а не для обсуждения.Чтобы присоединиться,отправьте пустое сообщение на mjd-perl-memoize-request@Plover.com.</target>
        </trans-unit>
        <trans-unit id="8c678b32e1afc117e7298e7cd70848ce65ee6435" translate="yes" xml:space="preserve">
          <source>I need to tell prove to use my My::TAP::Harness. If My::TAP::Harness is on Perl's @INC include path I can</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c1a5ec60a557a8f6b6b470a96e90910a56e1c7" translate="yes" xml:space="preserve">
          <source>I pointed out that &lt;code&gt;Memoize&lt;/code&gt; uses a hash, and that looking up a number in the hash is necessarily going to take a lot longer than a single multiplication. There really is no way to speed up the &lt;code&gt;square&lt;/code&gt; function.</source>
          <target state="translated">Я указал, что &lt;code&gt;Memoize&lt;/code&gt; использует хеш, и что поиск числа в хеш- коде обязательно займет намного больше времени, чем простое умножение. На самом деле нет никакого способа ускорить &lt;code&gt;square&lt;/code&gt; функцию.</target>
        </trans-unit>
        <trans-unit id="05b0f6d7121204753b37fe3a1f3d86b9576db3c7" translate="yes" xml:space="preserve">
          <source>I presume that it would be only the exceptional Web site that gets localized for English</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44584b7f38a4c7c497d3af92b7cb4267fde694f9" translate="yes" xml:space="preserve">
          <source>I promised to give you 90% of the benefit with 10% of the details, and that means I left out 90% of the details. Now that you have an overview of the important parts, it should be easier to read the &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; manual page, which discusses 100% of the details.</source>
          <target state="translated">Я обещал дать вам 90% выгоды с 10% деталей, а это значит, что я упустил 90% деталей. Теперь, когда у вас есть обзор важных частей, вам должно быть легче читать &lt;a href=&quot;perlref&quot;&gt;страницу&lt;/a&gt; руководства perlref , где обсуждаются 100% деталей.</target>
        </trans-unit>
        <trans-unit id="fe86a2ccd7bbbde333da23b987f2e2e4802f719a" translate="yes" xml:space="preserve">
          <source>I put a regular expression into $/ but it didn't work. What's wrong?</source>
          <target state="translated">Я вставил регулярное выражение в $/,но оно не сработало.Что случилось?</target>
        </trans-unit>
        <trans-unit id="73511fb1b7957dad066b5bf11010746dfb956b61" translate="yes" xml:space="preserve">
          <source>I recommend reading all of these:</source>
          <target state="translated">Я рекомендую прочитать все это:</target>
        </trans-unit>
        <trans-unit id="b7928600b482b60ec404a555ac7072bbe1486616" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="translated">Выше я сказал &amp;laquo;ваша часть стека&amp;raquo;, потому что код PP не обязательно передает себе весь стек: если ваша функция вызывает другую функцию, вы захотите предоставить только аргументы, предназначенные для вызываемой функции, а не (обязательно ) позвольте ему получить ваши собственные данные. Мы делаем это так, чтобы &amp;laquo;виртуальная&amp;raquo; нижняя часть стека была доступна для каждой функции. Стек меток хранит закладки в местах в стеке аргументов, используемых каждой функцией. Например, имея дело с связанной переменной (внутренне, что-то с магией &quot;P&quot;) Perl должен вызывать методы для доступа к связанным переменным. Однако нам нужно разделить аргументы, предоставляемые методу, на аргумент, предоставляемый исходной функции - хранилище или выборку или что-то еще. Вот's примерно, как реализуется связанный &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ; видеть &lt;code&gt;av_push&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="3b74357799ff3a807572f0228d6475d4cbcdbf36" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;push&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd010707291df43195b163d13725276025549dad" translate="yes" xml:space="preserve">
          <source>I still don't get locking. I just want to increment the number in the file. How can I do this?</source>
          <target state="translated">Я до сих пор не запираю.Я просто хочу увеличить номер в файле.Как я могу это сделать?</target>
        </trans-unit>
        <trans-unit id="0c3fa205e2bf9a49a23f4b51209de0f9232902bf" translate="yes" xml:space="preserve">
          <source>I think it would help to give some concrete examples to make it easier to understand the API. Of course I agree that the API has to be concise, but since there is no second document that is more of a guide, I think that it'd make it easier to start with the doc which is an API, but has examples in it in places where things are unclear, to a person who is not a PerlIO guru (yet).</source>
          <target state="translated">Я думаю,что это поможет привести несколько конкретных примеров,чтобы облегчить понимание API.Конечно,я согласен с тем,что API должен быть кратким,но так как нет второго документа,который был бы больше похож на руководство,я думаю,что это позволило бы легче начать с документа,который является API,но содержит примеры в тех местах,где что-то непонятно,человеку,который не является гуру PerlIO (пока).</target>
        </trans-unit>
        <trans-unit id="09ffd110a6022c3eacd4a506a275e7c45f272e0d" translate="yes" xml:space="preserve">
          <source>I think that keys as lexicon values makes the completed lexicon entries more readable:</source>
          <target state="translated">Я думаю,что клавиши в качестве значений лексики делают законченные записи лексики более читабельными:</target>
        </trans-unit>
        <trans-unit id="794953983b61d639901830159ca78a40665adca3" translate="yes" xml:space="preserve">
          <source>I used 'lynx' to fetch a file, but its contents is all wrong!</source>
          <target state="translated">Я использовал 'lynx',чтобы получить файл,но его содержимое неправильное!</target>
        </trans-unit>
        <trans-unit id="14dcb94db4c292bdfbf0b5c851ca4df4a4bf4c31" translate="yes" xml:space="preserve">
          <source>I want to clean up my mess, and install a new perl along with all modules I have. How do I go about it?</source>
          <target state="translated">Я хочу убрать свой беспорядок и установить новый perl вместе со всеми модулями,которые у меня есть.Как мне это сделать?</target>
        </trans-unit>
        <trans-unit id="3ae9e2275243ec65b397ebef16d91a7d431148ac" translate="yes" xml:space="preserve">
          <source>I want to log my test results in a database so I can track them over time. To do this I override the summary method in TAP::Harness. I start with a simple prototype that dumps the results as a YAML document:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2d698fc768ffb8cd382c1370e66993c67187ee" translate="yes" xml:space="preserve">
          <source>I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?</source>
          <target state="translated">Я {изменил директорию,изменил свое окружение}в скрипте на perl.Почему изменения исчезли,когда я выходил из скрипта? Как сделать так,чтобы мои изменения были видны?</target>
        </trans-unit>
        <trans-unit id="8d4b0ae21d1479e72399aeb9631081d458e4ae16" translate="yes" xml:space="preserve">
          <source>I&amp;lt;bar&amp;gt;</source>
          <target state="translated">I&amp;lt;bar&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3bb667cf6d485cf87366e4fa5d3fb7627b160f2b" translate="yes" xml:space="preserve">
          <source>I'll define the</source>
          <target state="translated">Я определю</target>
        </trans-unit>
        <trans-unit id="5cc9daab4dbfbc15ce11a2a71cb8dfe5485782e2" translate="yes" xml:space="preserve">
          <source>I'm afraid that we're not quite through with the alignment catch yet. The hydra raises another ugly head when you pack arrays of structures:</source>
          <target state="translated">Боюсь,что мы еще не закончили с уловом выравнивания.Гидра поднимает еще одну уродливую голову,когда ты упаковываешь массивы структур:</target>
        </trans-unit>
        <trans-unit id="f883cc87b6710df9317db1561fdc26ada281ddbe" translate="yes" xml:space="preserve">
          <source>I'm frequently irritated with the CPAN shell's inability to help me select a good mirror.</source>
          <target state="translated">Меня часто раздражает неспособность оболочки CPAN помочь мне выбрать хорошее зеркало.</target>
        </trans-unit>
        <trans-unit id="70a3ef0517de91698e88a243cc2feee12ba385a3" translate="yes" xml:space="preserve">
          <source>I'm having trouble matching over more than one line. What's wrong?</source>
          <target state="translated">У меня проблемы с совпадением по нескольким линиям.Что не так?</target>
        </trans-unit>
        <trans-unit id="8b9d03c166b0dec7e59491eb481c804d58495438" translate="yes" xml:space="preserve">
          <source>I'm not totally sure that locale names map satisfactorily to language tags. Think REAL hard about how you use this. YOU HAVE BEEN WARNED.</source>
          <target state="translated">Я не совсем уверен,что названия локалей соответствуют языковым тегам.Подумайте хорошенько о том,как вы это используете.ТЕБЯ ПРЕДУПРЕДИЛИ.</target>
        </trans-unit>
        <trans-unit id="73daa2b6bdc84827d06ade0cf82b30946cb9ce40" translate="yes" xml:space="preserve">
          <source>I'm offering this port &quot;as is&quot;. You can ask me questions, but I can't guarantee I'll be able to answer them. There are some excellent books available on the Perl language; consult a book seller.</source>
          <target state="translated">Я предлагаю этот порт &quot;как есть&quot;.Вы можете задавать мне вопросы,но я не могу гарантировать,что смогу на них ответить.Есть несколько отличных книг на языке Perl;проконсультируйтесь с продавцом книг.</target>
        </trans-unit>
        <trans-unit id="4357a589e4e3b7a00e21bb3c83ca3b640b5e0ab8" translate="yes" xml:space="preserve">
          <source>I'm ok, you're not ok.</source>
          <target state="translated">Я в порядке,ты не в порядке.</target>
        </trans-unit>
        <trans-unit id="108bd315655f1ba897c01059e340ad678da6e2f4" translate="yes" xml:space="preserve">
          <source>I'm sure most of us have seen code which looks like, (or worse than), this:</source>
          <target state="translated">Я уверен,что большинство из нас видели код,который выглядит так (или хуже):</target>
        </trans-unit>
        <trans-unit id="2f2f2a41a5729ebdf99d33e9a94c056bfe6a7622" translate="yes" xml:space="preserve">
          <source>I'm using WinZip, or some other non-POSIX client, and files are not being extracted properly!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c00e4567fd7637d5e9878ed4c5f66e616b88b8" translate="yes" xml:space="preserve">
          <source>I've considered making all the above functions that output language tags return all those tags strictly in lowercase. Having all your language tags in lowercase does make some things easier. But you might as well just lowercase as you like, or call &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; where appropriate.</source>
          <target state="translated">Я подумал о том, чтобы сделать все вышеупомянутые функции, которые выводят языковые теги, возвращают все эти теги строго в нижнем регистре. Наличие всех языковых тегов в нижнем регистре действительно упрощает некоторые вещи. Но вы можете просто использовать строчные буквы или вызвать &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; где это необходимо.</target>
        </trans-unit>
        <trans-unit id="88c5fcd7802546df837a3bf463ca41dcbe3c282a" translate="yes" xml:space="preserve">
          <source>I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?</source>
          <target state="translated">Я читал perlembed,perlguts и т.д.,но я не могу встроить perl в мою программу на C;что я делаю не так?</target>
        </trans-unit>
        <trans-unit id="4dfe11ac55007ac0949167eaeb2efbe8ea5b1f5d" translate="yes" xml:space="preserve">
          <source>I/O</source>
          <target state="translated">I/O</target>
        </trans-unit>
        <trans-unit id="c880785e491d41fc494e4fbfcd55e995f2687586" translate="yes" xml:space="preserve">
          <source>I/O Operators</source>
          <target state="translated">Операторы ввода/вывода</target>
        </trans-unit>
        <trans-unit id="1bd45ae6f90a489462015faa36411b1a7a88b1e2" translate="yes" xml:space="preserve">
          <source>I/O control operations for disk devices. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;. Most of these are to be used on physical drive devices like &lt;code&gt;&quot;//./PhysicalDrive0&quot;&lt;/code&gt;. However, &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; and &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt; should only be used on a single-partition device like &lt;code&gt;&quot;//./C:&quot;&lt;/code&gt;. Also, &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt; is documented as having been superseded but is still useful when used on a floppy device like &lt;code&gt;&quot;//./A:&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4882a6a30b4583bba173c6035cc140752a4ec0" translate="yes" xml:space="preserve">
          <source>I/O control operations for generic storage devices. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;. Includes &lt;code&gt;IOCTL_STORAGE_CHECK_VERIFY&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_MEDIA_REMOVAL&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_EJECT_MEDIA&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_LOAD_MEDIA&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_RESERVE&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_RELEASE&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_FIND_NEW_DEVICES&lt;/code&gt;, and &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa930eaf91e1f81994700657728c3a757afb3cf" translate="yes" xml:space="preserve">
          <source>I/O flow (the actual 5 minute tutorial)</source>
          <target state="translated">Поток ввода/вывода (фактическое 5-минутное учебное пособие)</target>
        </trans-unit>
        <trans-unit id="ae9cf1f9e1227f9dff6b41ea1e5f80cc2ae055d8" translate="yes" xml:space="preserve">
          <source>I/O layer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fc5fcf49da9b0ec975af77958aa41975a1fe45" translate="yes" xml:space="preserve">
          <source>I/O redirection and backgrounding</source>
          <target state="translated">перенаправление ввода/вывода и фоновое покрытие</target>
        </trans-unit>
        <trans-unit id="30d63bddfa4212ccce60957ddceaf4fa37417d27" translate="yes" xml:space="preserve">
          <source>I/O timeout value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8571fe32abe041d9dce3d7d7c47b858f248fa514" translate="yes" xml:space="preserve">
          <source>I18N AND L10N</source>
          <target state="translated">I18N И L10N</target>
        </trans-unit>
        <trans-unit id="e6b903dcac2bbc1b40e43d5e333946755137d36f" translate="yes" xml:space="preserve">
          <source>I18N::Charset</source>
          <target state="translated">I18N::Charset</target>
        </trans-unit>
        <trans-unit id="de5d730fbdbbf0183cf0f4683f1a73058ef3481c" translate="yes" xml:space="preserve">
          <source>I18N::Collate</source>
          <target state="translated">I18N::Collate</target>
        </trans-unit>
        <trans-unit id="01ad2dd6dde49d7565416cd97f4d499093f9d249" translate="yes" xml:space="preserve">
          <source>I18N::Collate - compare 8-bit scalar data according to the current locale</source>
          <target state="translated">I18N::Collate-сравните 8-битные скалярные данные в соответствии с текущей локалью.</target>
        </trans-unit>
        <trans-unit id="e106875b328699ace6767aa9c5ecab5bca3b0bd8" translate="yes" xml:space="preserve">
          <source>I18N::LangTags</source>
          <target state="translated">I18N::LangTags</target>
        </trans-unit>
        <trans-unit id="169f8297167d0e993d7316faae039b48a7c3bab1" translate="yes" xml:space="preserve">
          <source>I18N::LangTags - functions for dealing with RFC3066-style language tags</source>
          <target state="translated">I18N::LangTags-функции для работы с языковыми тегами в стиле RFC3066</target>
        </trans-unit>
        <trans-unit id="921275b7d99f260593561350c7678a20816444ed" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect</source>
          <target state="translated">I18N::LangTags::Detect</target>
        </trans-unit>
        <trans-unit id="778875cc577b876aab7ab802d4648cdcd4ee6cae" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect - detect the user's language preferences</source>
          <target state="translated">I18N::LangTags::Обнаружить-определить языковые предпочтения пользователя</target>
        </trans-unit>
        <trans-unit id="c04ea1622f377702e175508a3a481907575a2f47" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List</source>
          <target state="translated">I18N::LangTags::List</target>
        </trans-unit>
        <trans-unit id="020bb812c335fc278093b15a03a292e40918c844" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List -- tags and names for human languages</source>
          <target state="translated">I18N::LangTags::List --теги и имена для человеческих языков</target>
        </trans-unit>
        <trans-unit id="e3646198e54c82833384221bb49e8cf11f385f8f" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo</source>
          <target state="translated">I18N::Langinfo</target>
        </trans-unit>
        <trans-unit id="75f77bed8de0aee0770843a55893169b79d25155" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo - query locale information</source>
          <target state="translated">I18N::Langinfo-информация по локальным запросам</target>
        </trans-unit>
        <trans-unit id="fde9493a25e191231f11e09ab4dbdd30b2b2a8bf" translate="yes" xml:space="preserve">
          <source>I18N:Collate obsolete</source>
          <target state="translated">I18N:Собирать устаревшие</target>
        </trans-unit>
        <trans-unit id="0afef78a7afa599e29cd712fed951b6314ade53c" translate="yes" xml:space="preserve">
          <source>I18n and l10n</source>
          <target state="translated">I18n и l10n</target>
        </trans-unit>
        <trans-unit id="3886f65f7123288c1155f83462ecaa6186be5aba" translate="yes" xml:space="preserve">
          <source>I64 (8.2 and later)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d467a87245290159a1b6af42928666730653f6" translate="yes" xml:space="preserve">
          <source>IANA</source>
          <target state="translated">IANA</target>
        </trans-unit>
        <trans-unit id="0e13c62333772940b082221be7ca7762de31a069" translate="yes" xml:space="preserve">
          <source>IBM XL C for AIX</source>
          <target state="translated">IBM XL C для AIX</target>
        </trans-unit>
        <trans-unit id="c8afdae11327e149f5501c448b30becf77bc4954" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ for AIX</source>
          <target state="translated">IBM XL C/C++для AIX</target>
        </trans-unit>
        <trans-unit id="90317bc062fe454cff88014258aea7e36e9b3afc" translate="yes" xml:space="preserve">
          <source>IBM calls its implementation of long doubles 128-bit, but it is not the IEEE 128-bit (&quot;quadruple precision&quot;) which would give 116 bit of mantissa (nor it is implemented in hardware), instead it's a special software implementation called &quot;double-double&quot;, which gives 106 bits of mantissa.</source>
          <target state="translated">IBM называет свою реализацию long doubles 128-bit,но не IEEE 128-bit (&quot;четырехкратная точность&quot;),которая дала бы 116 бит мантиссы (и не реализована на аппаратном уровне),а специальная программная реализация,называемая &quot;double-double&quot;,которая дает 106 бит мантиссы.</target>
        </trans-unit>
        <trans-unit id="896c500f28ef7df0fbbd0268cb9652b7cfe0014c" translate="yes" xml:space="preserve">
          <source>IBM uses the AIX system Perl (V5.6.0 on AIX 5.1 and V5.8.2 on AIX 5.2 / 5.3 and 6.1; V5.8.8 on AIX 5.3 TL11 and AIX 6.1 TL4; V5.10.1 on AIX 7.1) for some AIX system scripts. If you switch the links in /usr/bin from the AIX system Perl (/usr/opt/perl5) to the newly build Perl then you get the same features as with the IBM AIX system Perl if the threaded options are used.</source>
          <target state="translated">IBM использует систему AIX Perl (V5.6.0 на AIX 5.1 и V5.8.2 на AIX 5.2/5.3 и 6.1;V5.8.8 на AIX 5.3 TL11 и AIX 6.1 TL4;V5.10.1 на AIX 7.1)для некоторых скриптов системы AIX.Если вы переключите ссылки в /usr/bin с системы AIX Perl (/usr/opt/perl5)на новую сборку Perl,то при использовании потоковых опций вы получите те же возможности,что и в системе IBM AIX Perl.</target>
        </trans-unit>
        <trans-unit id="ade9d724c5b212d6e78013557f35ac5c64927377" translate="yes" xml:space="preserve">
          <source>ICU Character Mapping Tables &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</source>
          <target state="translated">Таблицы сопоставления символов ICU &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92d0be3756020c7fb70f5f8d43b6e18e96de1472" translate="yes" xml:space="preserve">
          <source>ICU Home Page &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</source>
          <target state="translated">Домашняя страница ICU &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b3a4d066585cb49384b262b020e538f42a1f2ef" translate="yes" xml:space="preserve">
          <source>ICU:Conversion Data &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</source>
          <target state="translated">ICU: данные преобразования &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="821bf81957decc27fcaa8150194992b2c603308d" translate="yes" xml:space="preserve">
          <source>ICU:Conversion Data &lt;a href=&quot;https://ssl.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="46c5f048dbe4176fe265d2a79feb829754221b1e" translate="yes" xml:space="preserve">
          <source>IDENTIFYING CHARACTER CODE SETS</source>
          <target state="translated">НАБОРЫ ИДЕНТИФИКАЦИОННЫХ СИМВОЛОВ</target>
        </trans-unit>
        <trans-unit id="98eebf3bdf415d089af03ec0debc7c66f797a900" translate="yes" xml:space="preserve">
          <source>IETF Policy on Character Sets and Languages</source>
          <target state="translated">Политика IETF по наборам символов и языкам</target>
        </trans-unit>
        <trans-unit id="db4d48e5feaf920779dd2373b4efffa265df836a" translate="yes" xml:space="preserve">
          <source>IFS access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5d66d70494ee5ff5a453f224b81868447c393b" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION</source>
          <target state="translated">IMPLEMENTATION</target>
        </trans-unit>
        <trans-unit id="282613097967896b3e57bca75eb0bce558486a26" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION DETAILS</source>
          <target state="translated">ДЕТАЛИ ВНЕДРЕНИЯ</target>
        </trans-unit>
        <trans-unit id="0e35eae7c0731d3856fc41389b70ba2d34677ec0" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION NOTE</source>
          <target state="translated">ПРИМЕЧАНИЕ ПО ВЫПОЛНЕНИЮ</target>
        </trans-unit>
        <trans-unit id="00f6ac93461571c87bf08a0fa480109344a9be63" translate="yes" xml:space="preserve">
          <source>IMPLICIT LOADING</source>
          <target state="translated">НЕЯВНАЯ НАГРУЗКА</target>
        </trans-unit>
        <trans-unit id="2af61b8a92b859239b57341d2094b6ce58292a8a" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE 2: Attempting to bypass the normal stringification rules by manually applying &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; and &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; will sometimes yield surprising results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d100fb60d3feed237cfa4b32f5da84abc315f27f" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: As shown above, if your Decimal version contains more than 3 significant digits after the decimal place, it will be split on each multiple of 3, so 1.0003 is equivalent to v1.0.300, due to the need to remain compatible with Perl's own 5.005_03 == 5.5.30 interpretation. Any trailing zeros are ignored for mathematical comparison purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6d142ce7a912c87993ee95b67742ac2fb602f1" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: There is one exceptional cases shown in the above table where the &quot;initializer&quot; is not stringwise equivalent to the stringified representation. If you use the &lt;code&gt;qv&lt;/code&gt;() operator on a version without a leading 'v' &lt;b&gt;and&lt;/b&gt; with only a single decimal place, the stringified output will have a leading 'v', to preserve the sense. See the &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; operator for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb759641a6b8b6611a890056cf82c280511d2e9e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: This may mean that code which searches for a specific string (to determine whether a given module is available) may need to be changed. It is always better to use the built-in comparison implicit in &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, rather than manually poking at &lt;code&gt;class-&amp;gt;VERSION&lt;/code&gt; and then doing a comparison yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926527594f94772fcf38d60a2b632b1bb4c3c38c" translate="yes" xml:space="preserve">
          <source>IMPORTANT!</source>
          <target state="translated">IMPORTANT!</target>
        </trans-unit>
        <trans-unit id="c2e68d710cae68fae1b4d1132f818132a6f1837f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: if you use this &lt;code&gt;-S&lt;/code&gt; switch, be sure to delete the CONFIG environment variable before running the script:</source>
          <target state="translated">ВАЖНО: если вы используете этот переключатель &lt;code&gt;-S&lt;/code&gt; , обязательно удалите переменную среды CONFIG перед запуском скрипта:</target>
        </trans-unit>
        <trans-unit id="8d0c22f22ac148bf746659a76f51a0cce8f4070e" translate="yes" xml:space="preserve">
          <source>IMPORTS</source>
          <target state="translated">IMPORTS</target>
        </trans-unit>
        <trans-unit id="7696e648752c3c28012375bdb960a19fe39b8205" translate="yes" xml:space="preserve">
          <source>IMPORTS THE FUNCTIONS</source>
          <target state="translated">ИМПОРТ ФУНКЦИЙ</target>
        </trans-unit>
        <trans-unit id="6a09657af85954f963dea9fb1156c8ea7994677c" translate="yes" xml:space="preserve">
          <source>IN6ADDR_ANY, IN6ADDR_LOOPBACK</source>
          <target state="translated">IN6ADDR_ANY,IN6ADDR_LOOPBACK</target>
        </trans-unit>
        <trans-unit id="8b4b83ea115334b0957635d43569bbc4350f1369" translate="yes" xml:space="preserve">
          <source>INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</source>
          <target state="translated">INADDR_ANY,INADDR_BROADCAST,INADDR_LOOPBACK,INADDR_NONE</target>
        </trans-unit>
        <trans-unit id="ff3c82a6fc602d03a66e45a7aa9a2ebf5c59e91e" translate="yes" xml:space="preserve">
          <source>INC</source>
          <target state="translated">INC</target>
        </trans-unit>
        <trans-unit id="3c49bdd8d8e33e31f0c17fbcb306d09e8c131ead" translate="yes" xml:space="preserve">
          <source>INCLUDE_EXT</source>
          <target state="translated">INCLUDE_EXT</target>
        </trans-unit>
        <trans-unit id="648fb0ddc69c6bf59cfae2b4b521d2eea5687df1" translate="yes" xml:space="preserve">
          <source>INCREMENTAL PARSING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe356b54ea95780c909073ac988ee31715e5615" translate="yes" xml:space="preserve">
          <source>INDIVIDUAL RESULTS</source>
          <target state="translated">ЛИЧНЫЕ РЕЗУЛЬТАТЫ</target>
        </trans-unit>
        <trans-unit id="87d0fcde0a601e06d986c8740283892296dbb885" translate="yes" xml:space="preserve">
          <source>INHERITANCE</source>
          <target state="translated">INHERITANCE</target>
        </trans-unit>
        <trans-unit id="bc46a4e0420d357db7bfbcb7b5fcbc613dc48c1b" translate="yes" xml:space="preserve">
          <source>INIT</source>
          <target state="translated">INIT</target>
        </trans-unit>
        <trans-unit id="59990b467aae79667fd3fe1156086a0a147fb594" translate="yes" xml:space="preserve">
          <source>INIT HOOKS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c335a27a082cc8d17dd36dc0eda3086cb0c9baaa" translate="yes" xml:space="preserve">
          <source>INSTALL</source>
          <target state="translated">INSTALL</target>
        </trans-unit>
        <trans-unit id="bcfd83b3c8dcdbc242801037551b58c708467a92" translate="yes" xml:space="preserve">
          <source>INSTALL PERL ON CYGWIN</source>
          <target state="translated">УСТАНОВИТЬ ПЕРЛ НА ЦИГВИН</target>
        </trans-unit>
        <trans-unit id="b3642e83164b0035941a17dcaac1e8efc8ccc9e9" translate="yes" xml:space="preserve">
          <source>INSTALLARCHLIB</source>
          <target state="translated">INSTALLARCHLIB</target>
        </trans-unit>
        <trans-unit id="9d09dba09f4e15504911bf4a5e67189762904dd8" translate="yes" xml:space="preserve">
          <source>INSTALLATION</source>
          <target state="translated">INSTALLATION</target>
        </trans-unit>
        <trans-unit id="e5f21f5cfe15896cc57e4f66a25de31e67f38e54" translate="yes" xml:space="preserve">
          <source>INSTALLBIN</source>
          <target state="translated">INSTALLBIN</target>
        </trans-unit>
        <trans-unit id="a8dc0b332a8b3a30e1a3bfbf06a9ca622fa8b35a" translate="yes" xml:space="preserve">
          <source>INSTALLDIRS</source>
          <target state="translated">INSTALLDIRS</target>
        </trans-unit>
        <trans-unit id="16fff6f9fc1411630b91667c135606baff1eac91" translate="yes" xml:space="preserve">
          <source>INSTALLING PERL IN OPENVOS</source>
          <target state="translated">УСТАНОВКА ПЕРЛАМУТРА В ОТКРЫТОМ ПРОСТРАНСТВЕ</target>
        </trans-unit>
        <trans-unit id="7f052cc6553ecac6e3df0d0b879d905d556954d5" translate="yes" xml:space="preserve">
          <source>INSTALLMAN1DIR</source>
          <target state="translated">INSTALLMAN1DIR</target>
        </trans-unit>
        <trans-unit id="0e681f5032851ed30a543a900ac579e142841900" translate="yes" xml:space="preserve">
          <source>INSTALLMAN3DIR</source>
          <target state="translated">INSTALLMAN3DIR</target>
        </trans-unit>
        <trans-unit id="5933a08af3c7bebbbe6c3b67d67acaea7b113126" translate="yes" xml:space="preserve">
          <source>INSTALLPRIVLIB</source>
          <target state="translated">INSTALLPRIVLIB</target>
        </trans-unit>
        <trans-unit id="0c644278acf33a9a81880f74ea11f3e383631b34" translate="yes" xml:space="preserve">
          <source>INSTALLSCRIPT</source>
          <target state="translated">INSTALLSCRIPT</target>
        </trans-unit>
        <trans-unit id="54fcbd0bdcbf148e12836065934bc12897303524" translate="yes" xml:space="preserve">
          <source>INSTALLSITEARCH</source>
          <target state="translated">INSTALLSITEARCH</target>
        </trans-unit>
        <trans-unit id="89655a121385e7efe5f2cdc5a6d3add0eebb0223" translate="yes" xml:space="preserve">
          <source>INSTALLSITEBIN</source>
          <target state="translated">INSTALLSITEBIN</target>
        </trans-unit>
        <trans-unit id="933a51e99c70b3ad9b7b202ddc1482a7c0f44d60" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB</source>
          <target state="translated">INSTALLSITELIB</target>
        </trans-unit>
        <trans-unit id="df84db65783bcfd646d621819ed5a53534ed4081" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB=i:\perl\lib</source>
          <target state="translated">INSTALLSITELIB=i:\perl\lib</target>
        </trans-unit>
        <trans-unit id="26ed8090363cf70046fb05d12bd5b73ad1feec3a" translate="yes" xml:space="preserve">
          <source>INSTALLSITEMAN1DIR</source>
          <target state="translated">INSTALLSITEMAN1DIR</target>
        </trans-unit>
        <trans-unit id="1df2b4517a777a7e926d6a7992d6ee2806c0c778" translate="yes" xml:space="preserve">
          <source>INSTALLSITEMAN3DIR</source>
          <target state="translated">INSTALLSITEMAN3DIR</target>
        </trans-unit>
        <trans-unit id="ce3a6803fc962f8355f8305d4755ca6b09a83fff" translate="yes" xml:space="preserve">
          <source>INSTALLSITESCRIPT</source>
          <target state="translated">INSTALLSITESCRIPT</target>
        </trans-unit>
        <trans-unit id="8fee1b3f92888427d17dfd354d028dcbcbc0ee9c" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORARCH</source>
          <target state="translated">INSTALLVENDORARCH</target>
        </trans-unit>
        <trans-unit id="8b9cc74bd95a4dcfb94e960cfd6efdacf510a333" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORBIN</source>
          <target state="translated">INSTALLVENDORBIN</target>
        </trans-unit>
        <trans-unit id="c8fe30115e9bf08d3e86930e4100d4ce2c1a6393" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORLIB</source>
          <target state="translated">INSTALLVENDORLIB</target>
        </trans-unit>
        <trans-unit id="e80dab2a62b5932a7c992c9d56713d5afabb5666" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORMAN1DIR</source>
          <target state="translated">INSTALLVENDORMAN1DIR</target>
        </trans-unit>
        <trans-unit id="635ef78bb9259eec612010b989a90be923912f75" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORMAN3DIR</source>
          <target state="translated">INSTALLVENDORMAN3DIR</target>
        </trans-unit>
        <trans-unit id="64618110e901d3a5a0394dcdad64f11844b60749" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORSCRIPT</source>
          <target state="translated">INSTALLVENDORSCRIPT</target>
        </trans-unit>
        <trans-unit id="f1bd7855c675170fd5743049f5030b83e6d9486c" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE</source>
          <target state="translated">INSTALL_BASE</target>
        </trans-unit>
        <trans-unit id="972644501aef360867a4520d3945803529f2cc3e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE can be passed into Makefile.PL to change where your module will be installed. INSTALL_BASE is more like what everyone else calls &quot;prefix&quot; than PREFIX is.</source>
          <target state="translated">INSTALL_BASE может быть передан в Makefile.PL для изменения места установки вашего модуля.INSTALL_BASE больше похожа на то,что все остальные называют &quot;префиксом&quot;,чем на PREFIX.</target>
        </trans-unit>
        <trans-unit id="964f70f55608056234ee8f272195661f239be038" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE in MakeMaker and &lt;code&gt;--install_base&lt;/code&gt; in Module::Build (as of 0.28) install to the same location. If you want MakeMaker and Module::Build to install to the same location simply set INSTALL_BASE and &lt;code&gt;--install_base&lt;/code&gt; to the same location.</source>
          <target state="translated">INSTALL_BASE в MakeMaker и &lt;code&gt;--install_base&lt;/code&gt; в модуле :: Build (в 0.28) установить в том же месте. Если вы хотите, чтобы MakeMaker и Module :: Build устанавливались в одно и то же место, просто установите INSTALL_BASE и &lt;code&gt;--install_base&lt;/code&gt; в одно и то же место.</target>
        </trans-unit>
        <trans-unit id="c3f863f63a3576929f3be4a5b8b4b41019807a08" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE tells these tools to put your modules into</source>
          <target state="translated">INSTALL_BASE указывает этим инструментам,как поместить ваши модули в</target>
        </trans-unit>
        <trans-unit id="7b883de1f22bd64a8fb3db547deeba102b803a0e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE was added in 6.31.</source>
          <target state="translated">УСТАНОВКА_БАЗА добавлена в 6.31.</target>
        </trans-unit>
        <trans-unit id="886581b5b89b6e85f222ace37294af35562883c9" translate="yes" xml:space="preserve">
          <source>INST_ARCHLIB</source>
          <target state="translated">INST_ARCHLIB</target>
        </trans-unit>
        <trans-unit id="8a2379bc7653dd5379a3e78bb80106b03ea038a2" translate="yes" xml:space="preserve">
          <source>INST_BIN</source>
          <target state="translated">INST_BIN</target>
        </trans-unit>
        <trans-unit id="b3767b1163f565cbd5848c1ada0a99e721fdaa0f" translate="yes" xml:space="preserve">
          <source>INST_LIB</source>
          <target state="translated">INST_LIB</target>
        </trans-unit>
        <trans-unit id="391959e82830797dda34f122ffd715943af1eafc" translate="yes" xml:space="preserve">
          <source>INST_MAN1DIR</source>
          <target state="translated">INST_MAN1DIR</target>
        </trans-unit>
        <trans-unit id="eb72524f0c074de5e6da6ca437d4e86dc340dc3b" translate="yes" xml:space="preserve">
          <source>INST_MAN3DIR</source>
          <target state="translated">INST_MAN3DIR</target>
        </trans-unit>
        <trans-unit id="0e2cba5b7722f5d7d798d0a11841e1fc5d220d67" translate="yes" xml:space="preserve">
          <source>INST_SCRIPT</source>
          <target state="translated">INST_SCRIPT</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="325df994199a5a3b5bfde97c65a8f35d498e9bab" translate="yes" xml:space="preserve">
          <source>INTERNAL FORMAT</source>
          <target state="translated">ВНУТРЕННИЙ ФОРМАТ</target>
        </trans-unit>
        <trans-unit id="f2ee4f9d199f048c10a5b49f80f81e925ff271d9" translate="yes" xml:space="preserve">
          <source>INTERNAL VARIABLE TYPES</source>
          <target state="translated">ВНУТРЕННИЕ ПЕРЕМЕННЫЕ ТИПЫ</target>
        </trans-unit>
        <trans-unit id="ae880205d974d478a4f8301ed9ed724acfe764dd" translate="yes" xml:space="preserve">
          <source>INTERNALS</source>
          <target state="translated">INTERNALS</target>
        </trans-unit>
        <trans-unit id="0270ca97abe5bddc53ed95fb7179da4406621a18" translate="yes" xml:space="preserve">
          <source>INTRODUCTION</source>
          <target state="translated">INTRODUCTION</target>
        </trans-unit>
        <trans-unit id="0f6bca99bbb2a730f1c35f8aa2b2773658a27931" translate="yes" xml:space="preserve">
          <source>INTUIT</source>
          <target state="translated">INTUIT</target>
        </trans-unit>
        <trans-unit id="ce753ef37866a2969f587c295482b688037bd94e" translate="yes" xml:space="preserve">
          <source>IN_LOCALE</source>
          <target state="translated">IN_LOCALE</target>
        </trans-unit>
        <trans-unit id="4e3731a31894b7187bb76565396bb61a32a82161" translate="yes" xml:space="preserve">
          <source>IN_LOCALE_COMPILETIME</source>
          <target state="translated">IN_LOCALE_COMPILETIME</target>
        </trans-unit>
        <trans-unit id="b36325353ec225c227d7b482dcf439805cffb50a" translate="yes" xml:space="preserve">
          <source>IN_LOCALE_RUNTIME</source>
          <target state="translated">IN_LOCALE_RUNTIME</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="9703b620b98df0424c1d2891029b0a53270adadc" translate="yes" xml:space="preserve">
          <source>IO - load various IO modules</source>
          <target state="translated">IO-загрузка различных модулей ввода-вывода</target>
        </trans-unit>
        <trans-unit id="8218c7c584e2e73f83429a7a715ed0c77b1e9143" translate="yes" xml:space="preserve">
          <source>IO Functions</source>
          <target state="translated">IO функции</target>
        </trans-unit>
        <trans-unit id="8e8c7b4a7985c2b9c9f4e596a14848275f335be5" translate="yes" xml:space="preserve">
          <source>IO Redirect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4992825d003b9237bfbb2d1eeebbc4148368e7" translate="yes" xml:space="preserve">
          <source>IO layers (like '%s') unavailable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95153958c8a3fc0d7cc0242c39911001df17f39d" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e82ec6ecdf1d506a4bc4471deaf660ec582141" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: style интерфейс для &lt;a href=&quot;compress/zlib&quot;&gt;Compress :: Zlib&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d76ad5f2ab8e85a14e373d86896f0b50ad94632d" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base</source>
          <target state="translated">IO::Compress::Base</target>
        </trans-unit>
        <trans-unit id="f7a823195ba1022235bbaa930f5dacd9dcd2cde3" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base - Base Class for IO::Compress modules</source>
          <target state="translated">IO::Компрессор::Базовый-Базовый класс для модулей IO::Компрессорные модули</target>
        </trans-unit>
        <trans-unit id="2246092601d71db730b1277537bdfeb99922692b" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2</source>
          <target state="translated">IO::Compress::Bzip2</target>
        </trans-unit>
        <trans-unit id="4c110e2dd18855a5ac17fa0ff96df45279296253" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2 - Write bzip2 files/buffers</source>
          <target state="translated">IO::Сжатие::Bzip2-Запись bzip2 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="faeedf86bc5c3bf443dc7cb32aca40a75c1a61b1" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate</source>
          <target state="translated">IO::Compress::Deflate</target>
        </trans-unit>
        <trans-unit id="a24fa13516822c712bdf720b0c4b0786c457612f" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate - Write RFC 1950 files/buffers</source>
          <target state="translated">IO::Сжатие::Сдувание-Запись RFC 1950 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="f27ab19280760fb919a1e3287acc4b2ced04c845" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ</source>
          <target state="translated">IO::Compress::FAQ</target>
        </trans-unit>
        <trans-unit id="7dd8dce39506e0315c95f5807e0b2eb0d3b042f5" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ -- Frequently Asked Questions about IO::Compress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7fa9683b439c9ad1a7266191cc46683626bdae6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip</source>
          <target state="translated">IO::Compress::Gzip</target>
        </trans-unit>
        <trans-unit id="9e41ceaa77fd713ed3c8d8b1bfe6a609a7ddcea6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip - Write RFC 1952 files/buffers</source>
          <target state="translated">IO::Сжатие::Gzip-Запись RFC 1952 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="3205da05670e0698dd32ff4811dcf7e209aab757" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate</source>
          <target state="translated">IO::Compress::RawDeflate</target>
        </trans-unit>
        <trans-unit id="94bf2f893b55a2f57dfacc0d6c1e83c0ef44793d" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate - Write RFC 1951 files/buffers</source>
          <target state="translated">IO::Сжатие::RawDeflate-Запись RFC 1951 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="7015e5f6eae1214c2df0155ccaef808cdc7d0769" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip</source>
          <target state="translated">IO::Compress::Zip</target>
        </trans-unit>
        <trans-unit id="b05cb1e00a4226cff2f721fcd3f609b4ad94b38c" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip - Write zip files/buffers</source>
          <target state="translated">IO::Сжатие::Zip-Запись zip файлов/буферов</target>
        </trans-unit>
        <trans-unit id="4bf7c8cfd258e92c5a7a288432da2eb725c5d32c" translate="yes" xml:space="preserve">
          <source>IO::Dir</source>
          <target state="translated">IO::Dir</target>
        </trans-unit>
        <trans-unit id="f3b94128fba8d6583679638179ef4a0530bdd5d3" translate="yes" xml:space="preserve">
          <source>IO::Dir - supply object methods for directory handles</source>
          <target state="translated">IO::Dir-методы поставки объектов для дескрипторов каталогов</target>
        </trans-unit>
        <trans-unit id="1287d92d070eaf8f54116ae56a21bfe69917a99d" translate="yes" xml:space="preserve">
          <source>IO::File</source>
          <target state="translated">IO::File</target>
        </trans-unit>
        <trans-unit id="aef399115f05d82a203fb89d5e657a748c3e82de" translate="yes" xml:space="preserve">
          <source>IO::File - supply object methods for filehandles</source>
          <target state="translated">IO::Файл-методы поставки объектов для файловых дескрипторов</target>
        </trans-unit>
        <trans-unit id="85678e755d6fdd386f63c43333047c282a85eb74" translate="yes" xml:space="preserve">
          <source>IO::Handle</source>
          <target state="translated">IO::Handle</target>
        </trans-unit>
        <trans-unit id="d2ccf931b06cca09cc21fc6e3f7adaeb42eedc30" translate="yes" xml:space="preserve">
          <source>IO::Handle - supply object methods for I/O handles</source>
          <target state="translated">IO::Ручка-методы объекта питания для ручек ввода/вывода</target>
        </trans-unit>
        <trans-unit id="33e6674e03fd1f9387dffec88a9442f12eb239c1" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_formfeed(EXPR)</source>
          <target state="translated">IO::Handle-&amp;gt;format_formfeed(EXPR)</target>
        </trans-unit>
        <trans-unit id="4328314a142bc495dbcedc8dec821af05b31bc33" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_line_break_characters EXPR</source>
          <target state="translated">IO :: Handle-&amp;gt; format_line_break_characters EXPR</target>
        </trans-unit>
        <trans-unit id="6e5d46bf8e867cd748990f3121e29b41bc040337" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;input_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; input_record_separator (EXPR)</target>
        </trans-unit>
        <trans-unit id="88d38bb7198b1035ad2fe3e3a4c8b631ea81ae89" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_field_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_field_separator (EXPR)</target>
        </trans-unit>
        <trans-unit id="960c5c651b09566f1754a215a5295869a49e219e" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_record_separator (EXPR)</target>
        </trans-unit>
        <trans-unit id="7d7436d4629d382e64fc528a233e4705d021fb55" translate="yes" xml:space="preserve">
          <source>IO::Pipe</source>
          <target state="translated">IO::Pipe</target>
        </trans-unit>
        <trans-unit id="00e90fb1e0a6527593ec48869ad8bdd4be4727ec" translate="yes" xml:space="preserve">
          <source>IO::Pipe - supply object methods for pipes</source>
          <target state="translated">IO::Труба-методы объекта поставки для труб</target>
        </trans-unit>
        <trans-unit id="7411852690ce77d3e52c0392cb140a1da3c8926a" translate="yes" xml:space="preserve">
          <source>IO::Poll</source>
          <target state="translated">IO::Poll</target>
        </trans-unit>
        <trans-unit id="4af10858345e94c5247f732b4f8aeefb3d3033f8" translate="yes" xml:space="preserve">
          <source>IO::Poll - Object interface to system poll call</source>
          <target state="translated">IO::Опрос-Интерфейс объекта для вызова системного опроса</target>
        </trans-unit>
        <trans-unit id="a68be240586077bf55c7114e0c2dd0a3089b0b00" translate="yes" xml:space="preserve">
          <source>IO::Seekable</source>
          <target state="translated">IO::Seekable</target>
        </trans-unit>
        <trans-unit id="aca83121c079f3f44793e1fb400037048e6c0ec3" translate="yes" xml:space="preserve">
          <source>IO::Seekable - supply seek based methods for I/O objects</source>
          <target state="translated">IO::Seekable-методы,основанные на поиске источников питания для объектов ввода/вывода</target>
        </trans-unit>
        <trans-unit id="a4d83b02d49f96871e2c2e3d92dc1e0d34ec01f3" translate="yes" xml:space="preserve">
          <source>IO::Select</source>
          <target state="translated">IO::Select</target>
        </trans-unit>
        <trans-unit id="f909f3c8685d0640556ffd855c6e6b3161826eb6" translate="yes" xml:space="preserve">
          <source>IO::Select - OO interface to the select system call</source>
          <target state="translated">IO::Выберите-Интерфейс OO для выбранного системного вызова.</target>
        </trans-unit>
        <trans-unit id="77ccdb7781ae721df7a63530341f8d0e30eb9ba3" translate="yes" xml:space="preserve">
          <source>IO::Socket</source>
          <target state="translated">IO::Socket</target>
        </trans-unit>
        <trans-unit id="bcf86f1138a4fa3de29dc58d70750df124a76378" translate="yes" xml:space="preserve">
          <source>IO::Socket - Object interface to socket communications</source>
          <target state="translated">IO::Socket-Объектный интерфейс для связи с сокетами</target>
        </trans-unit>
        <trans-unit id="d9cad026ce1354129e7518abf6e60742a423f5cd" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET</source>
          <target state="translated">IO::Socket::INET</target>
        </trans-unit>
        <trans-unit id="21c7e3d3993af799697bb17b584159010291f1ca" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET - Object interface for AF_INET domain sockets</source>
          <target state="translated">IO::Socket::INET-Объектный интерфейс для доменных сокетов AF_INET</target>
        </trans-unit>
        <trans-unit id="847540cd1ff5e36f63fe89cede6f91a6c8dc3cc9" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET INCOMPATIBILITES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c6a2e029e8c8c79ed477acabec06a520b7120a" translate="yes" xml:space="preserve">
          <source>IO::Socket::IP</source>
          <target state="translated">IO::Socket::IP</target>
        </trans-unit>
        <trans-unit id="f8d87248556e958244a0c1aaa8d71d0e3f955f2d" translate="yes" xml:space="preserve">
          <source>IO::Socket::IP version 0.25 or IO::Socket::INET6 version 2.62 is required for IPv6 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef92351b8f3537bb6cc9713b22a0a29a3dd06aa7" translate="yes" xml:space="preserve">
          <source>IO::Socket::SSL version 2.007 or higher is required for SSL support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d370bee8efab5b347f028125483323b0c8ed6d8" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX</source>
          <target state="translated">IO::Socket::UNIX</target>
        </trans-unit>
        <trans-unit id="fd6fc205eb14f250173655f91ae8e3991e80a0fc" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX - Object interface for AF_UNIX domain sockets</source>
          <target state="translated">IO::Socket::UNIX-Объектный интерфейс для AF_UNIX доменных сокетов</target>
        </trans-unit>
        <trans-unit id="d387a4118fc41f5c91b925119de8c6c9b651a7b5" translate="yes" xml:space="preserve">
          <source>IO::Socket::atmark not implemented on this architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9efdf30a325c69f4eff01ffa74edfa8d13285c" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate</source>
          <target state="translated">IO::Uncompress::AnyInflate</target>
        </trans-unit>
        <trans-unit id="3f52359b31109c62a3cfec4235eb32afa54b7e76" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate - Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">IO::Распаковать::AnyInflate-Распаковать zlib-based (zip,gzip)файл/буфер</target>
        </trans-unit>
        <trans-unit id="9bcf772c56ff61361b8adfe8ed0930e47dd806cc" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress</source>
          <target state="translated">IO::Uncompress::AnyUncompress</target>
        </trans-unit>
        <trans-unit id="da915e62cd2924afaf5bdf41d62bf124d1816c96" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">IO::Uncompress::AnyUncompress-Uncompress gzip,zip,bzip2 или lzop файл/буфер</target>
        </trans-unit>
        <trans-unit id="a94c8d52ccfd5a43c50325b3be6e5dc8c0de211d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2, xz, lzma, lzip, lzf or lzop file/buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9d98befeabd4f68c0ee5ed490ad9ef9466ce0b" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base</source>
          <target state="translated">IO::Uncompress::Base</target>
        </trans-unit>
        <trans-unit id="6dd0aef5e96daa96cabb662e679bcaf3f782ff34" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base - Base Class for IO::Uncompress modules</source>
          <target state="translated">IO::Распаковка::Базовый-Базовый класс для модулей IO::Распаковка модулей</target>
        </trans-unit>
        <trans-unit id="47626e73b0c552496671b93615517289c7a72139" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2</source>
          <target state="translated">IO::Uncompress::Bunzip2</target>
        </trans-unit>
        <trans-unit id="558fc1d47555183743c62caa50f8fea7e57150e4" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2 - Read bzip2 files/buffers</source>
          <target state="translated">IO::Распаковка::Bunzip2-чтение bzip2 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="c56a044dac563ce20e270b6dad9d51e1ed4d67b5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip</source>
          <target state="translated">IO::Uncompress::Gunzip</target>
        </trans-unit>
        <trans-unit id="6858dbc4b4fa294b4bc17de10e3aec6d95c7a29d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip - Read RFC 1952 files/buffers</source>
          <target state="translated">IO::Распаковка::Gunzip-чтение RFC 1952 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="bdd707a0a7c129500d87baf2238a9f12252dc1a6" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate</source>
          <target state="translated">IO::Uncompress::Inflate</target>
        </trans-unit>
        <trans-unit id="9ea3fd5cd65551930396ea883f6b4523a57e56f5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate - Read RFC 1950 files/buffers</source>
          <target state="translated">IO::Распаковка::Надувание-Чтение RFC 1950 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="2387ca346858e6f631ae40207df5832845bfa4d3" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate</source>
          <target state="translated">IO::Uncompress::RawInflate</target>
        </trans-unit>
        <trans-unit id="0d1105cd05d8ddcb7bbad73158149f37cd425d0a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate - Read RFC 1951 files/buffers</source>
          <target state="translated">IO::Распаковка::RawInflate-Чтение RFC 1951 файлов/буферов</target>
        </trans-unit>
        <trans-unit id="eb25986effc3adf3d081252f8af9cf0ffcfb3a8a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip</source>
          <target state="translated">IO::Uncompress::Unzip</target>
        </trans-unit>
        <trans-unit id="7aed8f7e034916e56f4674cc0310d37a446ee94f" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip - Read zip files/buffers</source>
          <target state="translated">IO::Распаковка::Распаковка-Чтение zip-файлов/буферов</target>
        </trans-unit>
        <trans-unit id="f4c4eb93eddc35e78414020ae5db828e1e7864b8" translate="yes" xml:space="preserve">
          <source>IO::Zlib</source>
          <target state="translated">IO::Zlib</target>
        </trans-unit>
        <trans-unit id="d04446e459b1e71b578f998f8ab90764c4b0f8e3" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;../compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: Zlib - интерфейс IO :: style для &lt;a href=&quot;../compress/zlib&quot;&gt;Compress :: Zlib&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a833dc84965b791c8180a7f9bca2ad00d4ae502" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f1ff5ae16f8f008a024c94a2871ed43a079e29" translate="yes" xml:space="preserve">
          <source>IO::Zlib::READ: NBYTES must be specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b518756109da5b44c543995580fa7fa3fe28da6b" translate="yes" xml:space="preserve">
          <source>IO::Zlib::WRITE: too long LENGTH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16afa17f59e61e732bb594e1d07367170d0e3516" translate="yes" xml:space="preserve">
          <source>IO::Zlib::getlines: must be called in list context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744b77ff3abbf3b6e1e64e30f7190f2e0e168879" translate="yes" xml:space="preserve">
          <source>IO::Zlib::gzopen_external: mode '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ece9d22f9b2c053955dd1211c105cea7756474" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84556d1d56bdf3da066fa6199f9990e8d2a4eaa9" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: ':gzip_external' requires an argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33a6e3d14094a99186bbb131dd967ca442a99e2" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_read' '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430510c63254c938fe8a419081620b44e9a63369" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_read_open' requires an argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef06ad0f4357c011fb32988808d09f0b27277a4" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_write_open' '...' is illegal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cbd51a10bd74c633549cef79628135e981981b" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_write_open' requires an argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cde92750a3d48d656e69ded8901f66e2e3f4c3" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: no Compress::Zlib and no external gzip</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baefedf7f6990fe793b903ceae7ef91bfaf79c09" translate="yes" xml:space="preserve">
          <source>IO::Zlib::open: needs a filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea424d38af72dd1366a08aad1f47eca3e7ec3d24" translate="yes" xml:space="preserve">
          <source>IP</source>
          <target state="translated">IP</target>
        </trans-unit>
        <trans-unit id="e66f01e3abb1a4678f130fa0379ceec3adaec42e" translate="yes" xml:space="preserve">
          <source>IP protocol constants to use as the third argument to socket(), the level argument to getsockopt() or setsockopt(), or the value of the &lt;code&gt;SO_PROTOCOL&lt;/code&gt; socket option.</source>
          <target state="translated">Константы протокола IP для использования в качестве третьего аргумента функции socket (), аргумента уровня для функции getsockopt () или setsockopt () или значения &lt;code&gt;SO_PROTOCOL&lt;/code&gt; сокета SO_PROTOCOL .</target>
        </trans-unit>
        <trans-unit id="061b6bad243fee6cf3f9b677d21494fee55f1c64" translate="yes" xml:space="preserve">
          <source>IPA</source>
          <target state="translated">IPA</target>
        </trans-unit>
        <trans-unit id="f4aa7e6cdf843e01253be3fd2becaee731842f78" translate="yes" xml:space="preserve">
          <source>IPC</source>
          <target state="translated">IPC</target>
        </trans-unit>
        <trans-unit id="d54b59c534e736687131e3ec256172d1adbc895d" translate="yes" xml:space="preserve">
          <source>IPC AND CONCURRENCY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e5cff8767ed4c7882144c6f5c7afd4a74a2869" translate="yes" xml:space="preserve">
          <source>IPC drivers live in this namespace. It is fine to create new IPC drivers and to put them in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bb80888fafae35a8c04a482f4c52ba12354860" translate="yes" xml:space="preserve">
          <source>IPC::Cmd</source>
          <target state="translated">IPC::Cmd</target>
        </trans-unit>
        <trans-unit id="4aa727aa3bbf49a23200ff9a15dd661ace7ba750" translate="yes" xml:space="preserve">
          <source>IPC::Cmd - finding and running system commands made easy</source>
          <target state="translated">IPC::Cmd-поиск и запуск системных команд сделал легким</target>
        </trans-unit>
        <trans-unit id="9e94bec610bda8b6d6dba9768e7c89860ea7cbd2" translate="yes" xml:space="preserve">
          <source>IPC::Cmd allows you to run commands platform independently, interactively if desired, but have them still work.</source>
          <target state="translated">IPC::Cmd позволяет запускать команды платформы независимо,интерактивно,при желании,но заставить их работать.</target>
        </trans-unit>
        <trans-unit id="55a4e391e67ff1bdcc3e16ba0fb5ae458ce57904" translate="yes" xml:space="preserve">
          <source>IPC::Msg</source>
          <target state="translated">IPC::Msg</target>
        </trans-unit>
        <trans-unit id="6b32de39850adb752165f60b3bda5f0d97f34ff3" translate="yes" xml:space="preserve">
          <source>IPC::Msg - SysV Msg IPC object class</source>
          <target state="translated">IPC::Msg-SysV Msg Объектный класс IPC</target>
        </trans-unit>
        <trans-unit id="9dd902f8639b58e7edb7b6f8c06c22ac41c9ca2e" translate="yes" xml:space="preserve">
          <source>IPC::Open2</source>
          <target state="translated">IPC::Open2</target>
        </trans-unit>
        <trans-unit id="699765d9577f1c1501174faba27f2ca1f61d47cd" translate="yes" xml:space="preserve">
          <source>IPC::Open2 - open a process for both reading and writing using open2()</source>
          <target state="translated">IPC::Open2-открыть процесс как чтения,так и записи с помощью функции open2().</target>
        </trans-unit>
        <trans-unit id="6e80951681402ceb79b82897f2cb2015d59ab625" translate="yes" xml:space="preserve">
          <source>IPC::Open3</source>
          <target state="translated">IPC::Open3</target>
        </trans-unit>
        <trans-unit id="cbebbea4476633d292dae0e9b37d3ff0220e8a12" translate="yes" xml:space="preserve">
          <source>IPC::Open3 - open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">IPC::Open3-открыть процесс чтения,записи и обработки ошибок с помощью функции open3().</target>
        </trans-unit>
        <trans-unit id="e9c314ea8a55f232d58be815a30ee23b54cdb80b" translate="yes" xml:space="preserve">
          <source>IPC::Run</source>
          <target state="translated">IPC::Run</target>
        </trans-unit>
        <trans-unit id="5696dbec647d54eae7948ff758da75aceb6e7bdd" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore</source>
          <target state="translated">IPC::Semaphore</target>
        </trans-unit>
        <trans-unit id="4ac3e2f97ecebc0c9df272394b412c2bc0e4c139" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore - SysV Semaphore IPC object class</source>
          <target state="translated">IPC::Семафор-SysV Семафор IPC объектный класс</target>
        </trans-unit>
        <trans-unit id="eaac05351199d5338d0c67774a49f0ff5b08ddcd" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem</source>
          <target state="translated">IPC::SharedMem</target>
        </trans-unit>
        <trans-unit id="b67329129b7437abd470390d9b8de8b506578731" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem - SysV Shared Memory IPC object class</source>
          <target state="translated">IPC::SharedMem-SysV Shared Memory IPC объектного класса</target>
        </trans-unit>
        <trans-unit id="cac6bf077ecf12b8c4774537cb90121c12f40546" translate="yes" xml:space="preserve">
          <source>IPC::SysV</source>
          <target state="translated">IPC::SysV</target>
        </trans-unit>
        <trans-unit id="4a65a5b9999ec2f5bcb9aefce9ed4d2ebb83e351" translate="yes" xml:space="preserve">
          <source>IPC::SysV - System V IPC constants and system calls</source>
          <target state="translated">IPC::SysV-системные V IPC константы и системные вызовы</target>
        </trans-unit>
        <trans-unit id="eb04f21953f498789cba10742ad8acc6a3a6d8ee" translate="yes" xml:space="preserve">
          <source>IPC::[Run|Open3] will first read all of STDOUT, then all of STDERR, meaning the output looks like '13' on STDOUT and '24' on STDERR, instead of</source>
          <target state="translated">IPC::[Run|Open3]сначала прочитает весь STDOUT,а затем весь STDERR,что означает,что выход выглядит как '13' на STDOUT и '24' на STDERR,вместо того,чтобы</target>
        </trans-unit>
        <trans-unit id="c31963d765721dcd50b3ac6ea7828e71081eb9d0" translate="yes" xml:space="preserve">
          <source>IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...</source>
          <target state="translated">IPPROTO_IP,IPPROTO_IPV6,IPPROTO_TCP,...</target>
        </trans-unit>
        <trans-unit id="d605f8c901e4d72b551c09d9a4925d13cd9fbbb6" translate="yes" xml:space="preserve">
          <source>IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...</source>
          <target state="translated">IPTOS_LOWDELAY,IPTOS_THROUGHPUT,IPTOS_RELIABILITY,...</target>
        </trans-unit>
        <trans-unit id="b69eb35e4d4802a904ccf4f4eadf16b1c7831980" translate="yes" xml:space="preserve">
          <source>IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...</source>
          <target state="translated">IPV6_ADD_MEMBERHIP,IPV6_MTU,IPV6_V6ONLY,...</target>
        </trans-unit>
        <trans-unit id="5dcc16ca06e8e1e2d76e2715098a08de9cb62845" translate="yes" xml:space="preserve">
          <source>IP_OPTIONS, IP_TOS, IP_TTL, ...</source>
          <target state="translated">IP_OPTIONS,IP_TOS,IP_TTL,...</target>
        </trans-unit>
        <trans-unit id="52736177bb0ddc7186d53ccc0e904a6fc38535ec" translate="yes" xml:space="preserve">
          <source>IP_PMTUDISC_WANT, IP_PMTUDISC_DONT, ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68fa8efe4a09d8c0c63ae60426d9366434bccb2" translate="yes" xml:space="preserve">
          <source>IRC</source>
          <target state="translated">IRC</target>
        </trans-unit>
        <trans-unit id="e845e309f2bc4605301c4c8195c02b9ee45aab86" translate="yes" xml:space="preserve">
          <source>IRIX 6.5 documentation on syslog, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</source>
          <target state="translated">Документация IRIX 6.5 по syslog, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e349cb6fd67b0b7af90f7902a26799f4b980ca8" translate="yes" xml:space="preserve">
          <source>IRIX documentation on syslog, &lt;a href=&quot;http://nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&quot;&gt;http://nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407683774352e467c08d20959c8dcea8f6ef7fa7" translate="yes" xml:space="preserve">
          <source>ISIRI 3342, Iran System, ISIRI 2900 [Farsi]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f325d995b6d028ccc75771b1679537b623521c4" translate="yes" xml:space="preserve">
          <source>ISO</source>
          <target state="translated">ISO</target>
        </trans-unit>
        <trans-unit id="f776e0bcef88f6053e04b30cd9568a2f517c3848" translate="yes" xml:space="preserve">
          <source>ISO 6429 is available from ISO for a charge; the author of this module does not own a copy of it. Since the source material for ISO 6429 was ECMA-048 and the latter is available for free, there seems little reason to obtain the ISO standard.</source>
          <target state="translated">ISO 6429 доступен в ISO за плату;автор этого модуля не владеет его копией.Так как исходным материалом для ISO 6429 был ECMA-048,а последний доступен бесплатно,то оснований для получения стандарта ISO,похоже,мало.</target>
        </trans-unit>
        <trans-unit id="3353e215f71b71f7414efad5057c41576384753e" translate="yes" xml:space="preserve">
          <source>ISO 8859</source>
          <target state="translated">ISO 8859</target>
        </trans-unit>
        <trans-unit id="8fb0773017f88d072a29c4af9bf4189cc9c9a466" translate="yes" xml:space="preserve">
          <source>ISO 8859-1 (Latin-1)</source>
          <target state="translated">ISO 8859-1 (Латинский-1)</target>
        </trans-unit>
        <trans-unit id="58189607ac5de761659ad85bfe08184fa60a5f97" translate="yes" xml:space="preserve">
          <source>ISO codes for country sub-divisions (states, counties, provinces, etc), as defined in ISO 3166-2. This module is not part of the Locale-Codes distribution, but is available from CPAN in CPAN/modules/by-module/Locale/</source>
          <target state="translated">Коды ИСО для подразделений стран (штатов,округов,провинций и т.д.),как определено в ИСО 3166-2.Этот модуль не является частью распределения Локальных кодов,но доступен из CPAN в CPAN/modules/by-module/loocale/.</target>
        </trans-unit>
        <trans-unit id="2ee43903e014e67bbc02a16177f46410f4c5e2d5" translate="yes" xml:space="preserve">
          <source>ISO-2022</source>
          <target state="translated">ISO-2022</target>
        </trans-unit>
        <trans-unit id="0be641e76803b7f8b2767005594a25c505dcb463" translate="yes" xml:space="preserve">
          <source>ISO-2022-CN [RFC1922]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2562b9e7af09019f9f6f2808d127ef571d29778" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which adds support for JIS X 0212-1990. That means you can use the same code to decode to utf8 but not vice versa.</source>
          <target state="translated">ISO-2022-JP-1 (RFC2237)является суперсетью стандарта ISO-2022-JP (RFC1468),который добавляет поддержку JIS X 0212-1990.Это означает,что вы можете использовать тот же код для декодирования в utf8,но не наоборот.</target>
        </trans-unit>
        <trans-unit id="29cc7458d9efed7fe50460a3c77c7b87ac7a4db4" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-2 [RFC1554]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ffbc186932bc40f01e94ff7f5da5bf38a7154e" translate="yes" xml:space="preserve">
          <source>ISO-8859 and corresponding vendor mappings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19de626ae38d6fda9f9525299d239d5c0047248b" translate="yes" xml:space="preserve">
          <source>ISO-8859-8-1 [Hebrew]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846e5e5cfd7e004c49ed6ae8c1a88eb61f8816e2" translate="yes" xml:space="preserve">
          <source>ISO/IEC 10646 encoding form: Universal Character Set coded in two octets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13dc9cc90e3e41be961fd70df5f28ccfd86e620a" translate="yes" xml:space="preserve">
          <source>ISSUES</source>
          <target state="translated">ISSUES</target>
        </trans-unit>
        <trans-unit id="c5d9779f83f04a49a66dda9ed50dc9241b27d743" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_GREATER_THAN_UV_MAX bool IS_NUMBER_GREATER_THAN_UV_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f5693602a943228410c2db90175bdc9e162f71" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_INFINITY bool IS_NUMBER_INFINITY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed51a22a984a7a3384cf7607e6083139f796bac6" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_IN_UV bool IS_NUMBER_IN_UV</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b619f91f9748472f17789ce360cdba95124ee65" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NAN bool IS_NUMBER_NAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63251c261b533d85d9b19ec08396f8b333d44ea2" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NEG bool IS_NUMBER_NEG</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d56a5e4d44a907f0379be77749d8420d47b899" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT</source>
          <target state="translated">IS_NUMBER_NOT_INT</target>
        </trans-unit>
        <trans-unit id="6c84053d4886e789ea8b111c5248970e59a2046c" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if trailing decimals were seen (in which case *valuep gives the true value truncated to an integer), and IS_NUMBER_NEG if the number is negative (in which case *valuep holds the absolute value). IS_NUMBER_IN_UV is not set if e notation was used or the number is larger than a UV.</source>
          <target state="translated">IS_NUMBER_NOT_INT будет установлено значение IS_NUMBER_IN_UV,если были замечены трейлинговые децималы (в этом случае *valuep дает истинное значение,усеченное до целого числа),и IS_NUMBER_NEG,если число отрицательное (в этом случае *valuep держит абсолютное значение).IS_NUMBER_IN_UV не устанавливается,если использована e-нотация или число больше UV.</target>
        </trans-unit>
        <trans-unit id="a41c9a62c208bda09b6e0e4693fb0c85b4373197" translate="yes" xml:space="preserve">
          <source>IS_SAFE_SYSCALL</source>
          <target state="translated">IS_SAFE_SYSCALL</target>
        </trans-unit>
        <trans-unit id="e849c5f96439c1fe622e4ace3225dd079d5ce0bc" translate="yes" xml:space="preserve">
          <source>ITEM</source>
          <target state="translated">ITEM</target>
        </trans-unit>
        <trans-unit id="e98fda145e73c44d41ee1cf81a9942997f60dc03" translate="yes" xml:space="preserve">
          <source>ITEM...</source>
          <target state="translated">ITEM...</target>
        </trans-unit>
        <trans-unit id="81355db038b4c2e62588bc2f02426816803c8b50" translate="yes" xml:space="preserve">
          <source>ITEMHASH</source>
          <target state="translated">ITEMHASH</target>
        </trans-unit>
        <trans-unit id="932eaaf5a36529c34a7868b56cba634f534f39b4" translate="yes" xml:space="preserve">
          <source>IV</source>
          <target state="translated">IV</target>
        </trans-unit>
        <trans-unit id="af7024f6a1aba1b8353a4f8d081230e10f559e67" translate="yes" xml:space="preserve">
          <source>IVX</source>
          <target state="translated">IVX</target>
        </trans-unit>
        <trans-unit id="3776b457f4a64c1c2e929c3beb97e225d7174238" translate="yes" xml:space="preserve">
          <source>Iain Truskett. Updated by the Perl 5 Porters.</source>
          <target state="translated">Iain Truskett.Обновлено Perl 5 Porters.</target>
        </trans-unit>
        <trans-unit id="18334cc78787c9bf930719c033735bf066a1783e" translate="yes" xml:space="preserve">
          <source>Idaho</source>
          <target state="translated">Idaho</target>
        </trans-unit>
        <trans-unit id="d3280028436889a62f2d1e26e6623a3b63327bf8" translate="yes" xml:space="preserve">
          <source>Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, wardrobe by Calvin Klein.</source>
          <target state="translated">Идея Тони Боудена и Пола Джонсона, код Майкла Дж. Шверна &amp;lt;schwern@pobox.com&amp;gt;, гардероб от Кельвина Кляйна.</target>
        </trans-unit>
        <trans-unit id="38eaa27bde2babc938a1d3f61f24a4c3c9ee9393" translate="yes" xml:space="preserve">
          <source>Ideally, all instances of &lt;code&gt;PL_sub_generation++&lt;/code&gt; in perl source outside of</source>
          <target state="translated">В идеале все экземпляры &lt;code&gt;PL_sub_generation++&lt;/code&gt; в исходном коде perl вне</target>
        </trans-unit>
        <trans-unit id="e4477a644f309bbba5035bb03dd4d512f954eb2e" translate="yes" xml:space="preserve">
          <source>Ideally, all of these operators would completely ignore the &lt;code&gt;:utf8&lt;/code&gt; state, working only with bytes, but this would result in silently breaking existing code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501684b206c21ec5483e8cb92e79c26ad4af36ca" translate="yes" xml:space="preserve">
          <source>Ideally, all of these operators would completely ignore the &lt;code&gt;:utf8&lt;/code&gt; state, working only with bytes, but this would result in silently breaking existing code. To avoid this a future version of perl will throw an exception when any of sysread(), recv(), syswrite() or send() are called on handle with the &lt;code&gt;:utf8&lt;/code&gt; layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ac1e7c6fddbcf97426592a619f53420c1c124" translate="yes" xml:space="preserve">
          <source>Ideally, someone who's slightly familiar with your module should be able to refresh their memory without hitting &quot;page down&quot;. As your reader continues through the document, they should receive a progressively greater amount of knowledge.</source>
          <target state="translated">В идеале,тот,кто немного знаком с вашим модулем,должен иметь возможность освежить свою память,не нажимая &quot;страницу вниз&quot;.По мере того,как ваш читатель продолжает просмотр документа,он должен получать все больше и больше знаний.</target>
        </trans-unit>
        <trans-unit id="6760494b3e87b72d6f704a16dfd8c909bfd06f21" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;&quot;lrint&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c30d178b22c94b418adae6de96d27ac6651de9" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;lrint&lt;/a&gt;.</source>
          <target state="translated">Идентично &lt;a href=&quot;#lrint&quot;&gt;lrint&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c269c4512ac345c8ac0e6a3f0761757db1ece435" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;grok_number_flags()&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189f7c8820b5d91329256424f9abd34533abf5d2" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt; , but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="translated">Идентичен &lt;code&gt;has_errors&lt;/code&gt; , но также возвращает true, если какие-либо тесты TODO неожиданно завершились успешно. Это больше похоже на &amp;laquo;предупреждения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0e295a166224f4ec773840e576cbbb4eea64c35a" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt;, but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49923c15da594194a42e0f23479dad9afb3e6e18" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;seek OFFSET, WHENCE&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725851e6339b491e1de8826e667b9695d8cea364" translate="yes" xml:space="preserve">
          <source>Identical to grok_number_flags() with flags set to zero.</source>
          <target state="translated">Идентична функции grok_number_flags()с флагами,установленными в ноль.</target>
        </trans-unit>
        <trans-unit id="9052a2716f89fc7937386d07b0ec6eb570325f21" translate="yes" xml:space="preserve">
          <source>Identifier parsing</source>
          <target state="translated">Определить синтаксический анализ</target>
        </trans-unit>
        <trans-unit id="c9e9b7fc2f9e092c9b1b92a7e63d7d890ea86035" translate="yes" xml:space="preserve">
          <source>Identifier too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bd1c9d626bb40d98db0e06c9d88504407f597b" translate="yes" xml:space="preserve">
          <source>Identifies _POSIX_ARG_MAX as a constant sub, optimized to an IV. Although POSIX isn't entirely consistent across platforms, this is likely to be present in virtually all of them.</source>
          <target state="translated">Идентифицирует _POSIX_ARG_MAX как константу,оптимизированную под IV.Несмотря на то,что POSIX не является полностью совместимым между платформами,это,вероятно,присутствует практически во всех из них.</target>
        </trans-unit>
        <trans-unit id="651807fc401b8332ec409deb81843bccbd052364" translate="yes" xml:space="preserve">
          <source>Identifies md5 as an XS function. The export is needed so that BC can find it in main.</source>
          <target state="translated">Определяет md5 как функцию XS.Экспорт необходим для того,чтобы БК смог найти его в основном.</target>
        </trans-unit>
        <trans-unit id="c85a93ef2b6eb1be3e8769838c333c812af4359a" translate="yes" xml:space="preserve">
          <source>Identify a remote machine name. The auto-login process searches the .netrc file for a machine token that matches the remote machine specified. Once a match is made, the subsequent .netrc tokens are processed, stopping when the end of file is reached or an- other machine or a default token is encountered.</source>
          <target state="translated">Идентифицируйте удаленную машину.Процесс автозапуска ищет в файле .netrc маркер машины,который соответствует указанному удаленному компьютеру.После того,как найдено совпадение,обрабатываются последующие маркеры .netrc,останавливающиеся при достижении конца файла или при обнаружении другой машины или маркера по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ad36a5ddf7af0b9b2aadce75c61491b0c464af3b" translate="yes" xml:space="preserve">
          <source>Identify a user on the remote machine. If this token is present, the auto-login process will initiate a login using the specified name.</source>
          <target state="translated">Идентифицируйте пользователя на удаленной машине.Если эта маркерная кнопка присутствует,то процесс автозапуска инициирует вход с указанным именем.</target>
        </trans-unit>
        <trans-unit id="93ca58cc90c1952df3129b0ab2a244d796f9ba81" translate="yes" xml:space="preserve">
          <source>Identify and return the FQDN of the current host.</source>
          <target state="translated">Определите и верните FQDN текущего хоста.</target>
        </trans-unit>
        <trans-unit id="1b3b4987c2d4674f5207d125a1368bf151a6aeb4" translate="yes" xml:space="preserve">
          <source>Identify the C functions which use some inband info as an indication of failure. They may be candidates to return undef or an empty list in case of failure. If the failure may be detected without a call to the C function, you may want to use an INIT: section to report the failure. For failures detectable after the C function returns one may want to use a POSTCALL: section to process the failure. In more complicated cases use CODE: or PPCODE: sections.</source>
          <target state="translated">Определите функции C,которые используют некоторую информацию о полосе пропускания как признак неисправности.Они могут быть кандидатами на возврат undef или пустого списка в случае неудачи.Если сбой может быть обнаружен без вызова функции С,вы можете использовать раздел INIT:для сообщения о сбое.Для отказов,обнаруживаемых после возврата функции С,можно использовать раздел POSTCALL:для обработки отказа.В более сложных случаях используйте разделы CODE:или PPCODE:.</target>
        </trans-unit>
        <trans-unit id="b1d8de6657b1cd9ff03db4bb8c676352163c1ab9" translate="yes" xml:space="preserve">
          <source>Identify the C functions with input/output or output parameters. The XSUBs for these functions may be able to return lists to Perl.</source>
          <target state="translated">Определите функции C с входными/выходными или выходными параметрами.XSUB для этих функций могут возвращать списки на Perl.</target>
        </trans-unit>
        <trans-unit id="90f84ba2bf147a844b20d38f482ee57bb2e58f7e" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="translated">Найдите указатели в списках параметров функции C и возвращаемых значениях. Некоторые указатели могут использоваться для реализации параметров ввода / вывода или вывода, их можно обрабатывать в XS с помощью унарного оператора &lt;code&gt;&amp;amp;&lt;/code&gt; и, возможно, с помощью ключевого слова NO_INIT. Некоторые другие потребуют обработки таких типов, как &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , и нужно решить, что в таком случае будет делать полезный перевод Perl. Когда семантика ясна, рекомендуется поместить перевод в файл типовой карты.</target>
        </trans-unit>
        <trans-unit id="02c745f2a38f59b1173a4d016d93fc6da4107dea" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;int *&lt;/code&gt;, and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f574cc58fec6b5a326569871a9bc4c7e511150" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt; .)</source>
          <target state="translated">Определите структуры, используемые функциями C. Во многих случаях может быть полезно использовать карту типов T_PTROBJ для этих структур, чтобы Perl мог ими манипулировать как благословенные объекты. (Это обрабатывается автоматически командой &lt;code&gt;h2xs -x&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="010ff5be16a493cb47c53ed9163162ed618b8c47" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cadfb291553bfe2fe292f1f1bdcc23146b4ce0c" translate="yes" xml:space="preserve">
          <source>Identify which values are used by only the C and XSUB functions themselves, say, when a parameter to a function should be a contents of a global variable. If Perl does not need to access the contents of the value then it may not be necessary to provide a translation for that value from C to Perl.</source>
          <target state="translated">Определите,какие значения используются только функциями C и XSUB,например,когда параметр функции должен быть содержимым глобальной переменной.Если Perl не нуждается в доступе к содержимому значения,то,возможно,нет необходимости предоставлять перевод этого значения с C на Perl.</target>
        </trans-unit>
        <trans-unit id="56f43be29163ab63b1344b6e022e099866950791" translate="yes" xml:space="preserve">
          <source>Identifying DLLs</source>
          <target state="translated">Идентификация DLL</target>
        </trans-unit>
        <trans-unit id="82508a1705f3161aa990aa2c93c5670f8e0880f2" translate="yes" xml:space="preserve">
          <source>Identity of objects returned from threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322518cb4fde79b98b609332667667f3d3c4e560" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">Внутренняя реализация на основе Idhash с явным реестром объектов.Деструктор не нужен,а объекты являются потокобезопасными.</target>
        </trans-unit>
        <trans-unit id="bc58745f8a36f6c13d8394fd39a743ccc1e12aee" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation. Like &lt;code&gt;Name_id&lt;/code&gt; it needs a &lt;code&gt;DESTROY&lt;/code&gt; method and would need &lt;code&gt;CLONE&lt;/code&gt; for thread support.</source>
          <target state="translated">Реализация наизнанку на основе Idhash. Как &lt;code&gt;Name_id&lt;/code&gt; он нужен &lt;code&gt;DESTROY&lt;/code&gt; метод и потребуется &lt;code&gt;CLONE&lt;/code&gt; для поддержки потоков.</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="37c8800e90368fca825ac19f3c1c00b3997debbb" translate="yes" xml:space="preserve">
          <source>If $ENV{'PERLIO_DEBUG'} is not set PerlIO_debug() is a no-op.</source>
          <target state="translated">Если $ENV{'PERLIO_DEBUG'}не установлена функция PerlIO_debug(),то она не работает.</target>
        </trans-unit>
        <trans-unit id="34dc71088c30578327b9b7bd86a2add6dfe92c0b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set (see below), it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">Если установлен параметр $Term::ANSIColor::AUTOLOCAL (см.ниже),то он имеет приоритет над $Term::ANSIColor::AUTORESET,и последний игнорируется.</target>
        </trans-unit>
        <trans-unit id="d7df1e43ea1f957f59393ae695f2cf9b6d2d606b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, each sequence of color constants will be implicitly preceded by LOCALCOLOR. In other words, the following:</source>
          <target state="translated">Если установлен параметр $Term::ANSIColor::AUTOLOCAL,то каждой последовательности цветовых констант неявно будет предшествовать LOCALCOLOR.Другими словами,следующее:</target>
        </trans-unit>
        <trans-unit id="9886d30e7ae4310a71b5b389e615e24f477c9c12" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">Если установлен $Term::ANSIColor::AUTOLOCAL,то он имеет приоритет над $Term::ANSIColor::AUTORESET,и последний игнорируется.</target>
        </trans-unit>
        <trans-unit id="00b4b93a6e7c56aaf9898bc10e1ac72d3a78d804" translate="yes" xml:space="preserve">
          <source>If $base doesn't have a trailing colon, the last element of $base is assumed to be a filename. This filename is ignored. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">Если в $base нет трейлингового двоеточия,то последним элементом $base считается имя файла.Это имя файла игнорируется.Иначе все компоненты пути считаются каталогами.</target>
        </trans-unit>
        <trans-unit id="e44a850613a15c52040db7b75a563e3363f3a945" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">Если $ base отсутствует или '', тогда $ base устанавливается в текущий рабочий каталог. Если $ base является относительным, то он преобразуется в абсолютную форму с помощью &lt;code&gt;rel2abs()&lt;/code&gt; . Это означает, что он считается относительным к текущему рабочему каталогу.</target>
        </trans-unit>
        <trans-unit id="1ac0ec7cd3bc97fc5c257fe4a45200d456c5936a" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845e455de01e5f024d6cd4c4973aa19e89db7d23" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">Если $ base отсутствует или '', используется &lt;a href=&quot;../../cwd&quot;&gt;cwd ()&lt;/a&gt; . Если $ base является относительным, то он преобразуется в абсолютную форму с помощью &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()&lt;/a&gt; . Это означает, что он считается относительным к &lt;a href=&quot;../../cwd&quot;&gt;cwd ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c40ff51bf83072e14de8451f609e067639c21f4" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9272bd7bdd63c187d96603ba9d632df6f83a5a3" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">Если $ base отсутствует или '', то используется текущий рабочий каталог. Если $ base является относительным, то он преобразуется в абсолютную форму с помощью &lt;code&gt;rel2abs()&lt;/code&gt; . Это означает, что он считается относительным к текущему рабочему каталогу.</target>
        </trans-unit>
        <trans-unit id="b66c3e7b074813162992aae05acc57abf750bc24" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5fe1a187e17b34fb3d5857b8fec9a663cd647f" translate="yes" xml:space="preserve">
          <source>If $chld_in begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt;, then $chld_in will be closed in the parent, and the child will read from it directly. If $chld_out or $chld_err begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt; instead of a &lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe(2)&lt;/a&gt; made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eeec7a0508f8bfb175a7dfc1c9f776420700e6b" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">Если $ chld_out - это строка (то есть дескриптор файла, а не глобус или ссылка) и начинается с &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; , тогда дочерний элемент будет отправлять вывод непосредственно в этот дескриптор файла. Если $ chld_in - это строка, начинающаяся с &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , тогда $ chld_in будет закрыта в родительском элементе, и дочерний элемент будет читать из него напрямую. В обоих случаях вместо трубы (2) будет сделан дуп (2).</target>
        </trans-unit>
        <trans-unit id="bb5d964b870841cdc4d8247b114d6ed7feacad03" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt;, then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt; instead of a &lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe(2)&lt;/a&gt; made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fc8fa9695e13537785e072991da9317e572016" translate="yes" xml:space="preserve">
          <source>If $device is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="translated">Если дано $device,то это устройство используется для привязки исходной конечной точки перед отправкой пакета ping.Полагаю,что на данный момент это работает только с привилегиями суперпользователя и с протоколами udp и icmp.</target>
        </trans-unit>
        <trans-unit id="c0ccd65f83616cd6cb2edfc67d2ca291d582e3dc" translate="yes" xml:space="preserve">
          <source>If $dont_execute is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">Если $dont_execute равен true,то он будет печатать только то,что собирался сделать,не делая этого на самом деле.По умолчанию это ложь.</target>
        </trans-unit>
        <trans-unit id="4487f23cdc43d77eefda03ffdb355fcd16d21554" translate="yes" xml:space="preserve">
          <source>If $dry_run is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">Если $dry_run равен true,то он будет печатать только то,что собирался сделать,не делая этого на самом деле.По умолчанию это ложь.</target>
        </trans-unit>
        <trans-unit id="18c02a1762fa9a8596890767dac4fd996ccee7b8" translate="yes" xml:space="preserve">
          <source>If $file is not given, output goes to STDOUT.</source>
          <target state="translated">Если $файл не задан,то вывод идет в STDOUT.</target>
        </trans-unit>
        <trans-unit id="d0d307167134c6f267f7b1e5ea27d0a25a9d1edd" translate="yes" xml:space="preserve">
          <source>If $lang1 is not a valid language tag, returns empty-list in a list context, undef in a scalar context.</source>
          <target state="translated">Если $lang1 не является допустимым языковым тегом,возвращает пустой список в контексте списка,undef в контексте скаляра.</target>
        </trans-unit>
        <trans-unit id="6adb44f6d344c97f88c0df71861fe153cb8933a6" translate="yes" xml:space="preserve">
          <source>If $n is -12, the following values, F(0) to F(12), are returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b3052cab9399b49f31b3d6abdfc51fc8199576" translate="yes" xml:space="preserve">
          <source>If $n is -12, the following values, L(0) to L(-12), are returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee23960e33f02c0ec76877b3b88bcea62b52eb5" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt; . Defaults to true.</source>
          <target state="translated">Если $ options {allow_variables} истинно, переменные make &lt;code&gt;'$(FOO)'&lt;/code&gt; остаются нетронутыми. Если false, они будут экранированы, как и любые другие &lt;code&gt;$&lt;/code&gt; . По умолчанию true.</target>
        </trans-unit>
        <trans-unit id="5af890a74a4e63465dd086ae3936bc7cc991986f" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt;. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4290bb3a94a4f28c693632b42d671f5b272d5b" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt; .</source>
          <target state="translated">Если $ opts {allow_variables} истинно, переменные make в форме &lt;code&gt;$(...)&lt;/code&gt; не будут экранированы. Остальные &lt;code&gt;$&lt;/code&gt; будут. По умолчанию все символы &lt;code&gt;$&lt;/code&gt; экранируются .</target>
        </trans-unit>
        <trans-unit id="45a9cc1fe09732d92a99ea0ef6a79df5a1201010" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855199c44e171a04babf60aa36fe8d5f139967b6" translate="yes" xml:space="preserve">
          <source>If $opts{append} is true the $file will be appended to rather than overwritten. Default is to overwrite.</source>
          <target state="translated">Если $opts{append}равен true,то $файл будет добавлен,а не перезаписан.По умолчанию перезаписывается.</target>
        </trans-unit>
        <trans-unit id="6f940e23e748b82cd99453c8e14fb88e03638ce9" translate="yes" xml:space="preserve">
          <source>If $path and $base appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return $path. Note that previous versions of this module ignored the volume of $base, which resulted in garbage results part of the time.</source>
          <target state="translated">Если $path и $base окажутся на двух разных томах,мы не будем пытаться разрешить эти два пути,а просто вернем $path.Обратите внимание,что в предыдущих версиях этого модуля том $base игнорировался,что приводило к появлению мусорных результатов часть времени.</target>
        </trans-unit>
        <trans-unit id="cbae8edca75030504736a7e9ba0e1664c9973d5c" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath%28%29&quot;&gt;&quot;canonpath()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850236350e7bb82f14f3904d51572fc6195796da" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath()&quot;&gt;canonpath()&lt;/a&gt;.</source>
          <target state="translated">Если $ path является абсолютным, он очищается и возвращается с помощью &lt;a href=&quot;#canonpath()&quot;&gt;canonpath ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8dd162a4e3a5b7fb03319f43889033f3ce26c0ac" translate="yes" xml:space="preserve">
          <source>If $path is already absolute, it is returned and $base is ignored.</source>
          <target state="translated">Если $path уже абсолютный,то он возвращается и $base игнорируется.</target>
        </trans-unit>
        <trans-unit id="886dc2f5228118ff9d61b100bc53fdb8e15c29aa" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c7fd35866ed59635fd89f40d3d520a0dbf9c9" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">Если $ path является относительным, он преобразуется в абсолютную форму с помощью &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()&lt;/a&gt; . Это означает, что он считается относительным к &lt;a href=&quot;../../cwd&quot;&gt;cwd ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca3a7041ed2c9c63e8a6e3a8ccf54b7c562514d" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">Если $ path является относительным, он преобразуется в абсолютную форму с помощью &lt;code&gt;rel2abs()&lt;/code&gt; . Это означает, что он считается относительным к текущему рабочему каталогу.</target>
        </trans-unit>
        <trans-unit id="e06af1fee89e76c48b343a46105f41869071f188" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5254527bc2e7fffb01bf04870bf9b3803ac84a3a" translate="yes" xml:space="preserve">
          <source>If $skip is undefined then the skip file will be autodetected and used if it is found. If $skip is a reference to an array then it is assumed the array contains the list of patterns, if $skip is a true non reference it is assumed to be the filename holding the list of patterns, any other value of $skip is taken to mean that no install filtering should occur.</source>
          <target state="translated">Если $skip не определен,то файл пропуска будет автоматически обнаружен и использован,если он будет найден.Если $skip является ссылкой на массив,то предполагается,что массив содержит список шаблонов,если $skip является истинной не ссылочной,то предполагается,что это имя файла,содержащего список шаблонов,любое другое значение $skip означает,что никакой инсталляционной фильтрации не должно происходить.</target>
        </trans-unit>
        <trans-unit id="8fa5810ef2976d0d9f6da3cb5784a5117836d30e" translate="yes" xml:space="preserve">
          <source>If $tos is given, this ToS is configured into the socket.</source>
          <target state="translated">Если $tos задан,то этот ToS настраивается в сокет.</target>
        </trans-unit>
        <trans-unit id="92f994b9259d086e448ddc0c57c689110cb3a4ae" translate="yes" xml:space="preserve">
          <source>If $uninstall_shadows is true any differing versions throughout @INC will be uninstalled. This is &quot;make install UNINST=1&quot;</source>
          <target state="translated">Если $uninstall_shadows равен true,будут удалены все версии @INC.Это &quot;make install UNINST=1&quot;.</target>
        </trans-unit>
        <trans-unit id="d25dc89b5c8f1043b2555a0a5b1ef64713bc4410" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false.</source>
          <target state="translated">Если $verbose верно,то будет распечатан каждый удаленный файл.По умолчанию это ложь.</target>
        </trans-unit>
        <trans-unit id="bcca2238b940008ca2f6edea6b116ca4f08340a0" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false. This is &quot;make install VERBINST=1&quot;. $verbose values going up to 5 show increasingly more diagnostics output.</source>
          <target state="translated">Если $verbose верно,то будет распечатан каждый удаленный файл.По умолчанию это ложь.Это &quot;make install VERBINST=1&quot;.Значения $verbose,увеличивающиеся до 5,показывают все больше и больше результатов диагностики.</target>
        </trans-unit>
        <trans-unit id="769e2245fa144a60a2da225854d87529340273af" translate="yes" xml:space="preserve">
          <source>If &amp;lt;tos&amp;gt; is given, this ToS is configured into the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6210a09cf838e292147ff60a09be55f53fc7bf" translate="yes" xml:space="preserve">
          <source>If 'pattern' is an empty string, the last</source>
          <target state="translated">Если &quot;шаблон&quot;-пустая строка,то последняя</target>
        </trans-unit>
        <trans-unit id="0ebb8bcb9771923015eb97e7f45b5b7f4e5fde8a" translate="yes" xml:space="preserve">
          <source>If 0 is given as the version number, then any version is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce161c1d1a95615015e87f6deb5c4e15fba876e" translate="yes" xml:space="preserve">
          <source>If 0, allows</source>
          <target state="translated">Если 0,то разрешает</target>
        </trans-unit>
        <trans-unit id="e3e28f04766a1a5f37a30a978712cb8019a0f8ec" translate="yes" xml:space="preserve">
          <source>If 0, perl ignores setlocale() failing. May be useful with some strange</source>
          <target state="translated">Если 0,perl игнорирует неудачу setlocale().Может быть полезно с каким-нибудь странным</target>
        </trans-unit>
        <trans-unit id="0fcc1cd2f54ca974c2f03b70436631faa5fcbfff" translate="yes" xml:space="preserve">
          <source>If 0, perl would not warn of in case of unwarranted free(). With older perls this might be useful in conjunction with the module DB_File, which was buggy when dynamically linked and OMF-built.</source>
          <target state="translated">Если 0,то perl не будет предупреждать в случае неоправданной функции free().Со старыми perls это может быть полезно в сочетании с модулем DB_File,который был ошибочным при динамической компоновке и OMF-сборке.</target>
        </trans-unit>
        <trans-unit id="0184b287a86a499460e472243734776163d62a28" translate="yes" xml:space="preserve">
          <source>If 0, then you have specified the G_DISCARD flag.</source>
          <target state="translated">Если 0,то вы указали флаг G_DISCARD.</target>
        </trans-unit>
        <trans-unit id="59622b7a1ad0df9c79750964aae25dbf7a4a54d5" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section</source>
          <target state="translated">Если 1,то элемент,фактически возвращенный подпрограммой Perl,будет сохранен в стеке Perl-секция</target>
        </trans-unit>
        <trans-unit id="f287e1183da76005aad8b01623d1574c97f08bac" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section &lt;a href=&quot;#Returning-a-Scalar&quot;&gt;&quot;Returning a Scalar&quot;&lt;/a&gt; shows how to access this value on the stack. Remember that regardless of how many items the Perl subroutine returns, only the last one will be accessible from the stack - think of the case where only one value is returned as being a list with only one element. Any other items that were returned will not exist by the time control returns from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea4460b4f37611ed7726bdc86a6a203f8857086" translate="yes" xml:space="preserve">
          <source>If 1. and 2. didn't work, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for anything looking like UTF-8, and if any found, &lt;code&gt;:utf8&lt;/code&gt; is used as the default encoding for the open pragma.</source>
          <target state="translated">Если 1. и 2. не сработали, переменные среды &lt;code&gt;LC_ALL&lt;/code&gt; и &lt;code&gt;LANG&lt;/code&gt; (в указанном порядке) сопоставляются с чем-либо, похожим на UTF-8, и, если таковые имеются &lt;code&gt;:utf8&lt;/code&gt; используется как кодировка по умолчанию для открытой прагмы.</target>
        </trans-unit>
        <trans-unit id="564ba04f0c77bd18f1de6b5d8d1c4de41e90203f" translate="yes" xml:space="preserve">
          <source>If 1. didn't work but we are under the locale pragma, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for encodings (the part after &quot;&lt;code&gt;.&lt;/code&gt;&quot;, if any), and if any found, that is used as the default encoding for the open pragma.</source>
          <target state="translated">Если 1. не сработало, но мы находимся в &lt;code&gt;LC_ALL&lt;/code&gt; locale, переменные среды LC_ALL и &lt;code&gt;LANG&lt;/code&gt; (в указанном порядке) сопоставляются для кодировок (часть после &quot; &lt;code&gt;.&lt;/code&gt; &quot;, Если есть), и, если таковые найдены, используется как кодировка по умолчанию для открытой прагмы.</target>
        </trans-unit>
        <trans-unit id="3a1afd51d6a3da0d6403cee52200d8b304585c08" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, the current chunk will not be discarded. If the current chunk has not been entirely consumed, then it will not be discarded regardless of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc7e264f1e9eeedc8d7e2b14c1a68dd77cae7b4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If</source>
          <target state="translated">Если &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt; указывает на самый конец текущего фрагмента (т. Е. Текущий фрагмент был полностью использован), обычно текущий фрагмент будет отброшен одновременно с считыванием нового фрагмента. Если</target>
        </trans-unit>
        <trans-unit id="ab9b9dc2a96c1b74c9cadb45dfb3263c99d73a6b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; can read the file but cannot compile it, it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets an error message in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; cannot read the file, it returns undef and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; to the error. Always check &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; first, as compilation could fail in a way that also sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;. If the file is successfully compiled, &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; returns the value of the last expression evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf2b0be95e3bf2e4bd6ed03a9822036447b6309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; encounters an operating system error, &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; will be set with the corresponding error message. It can be helpful to check &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; and dies if the result is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878d2594c5d9d20b43a7cfef25e3d9ca8c531de7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; operator. However, there are a few situations where programs are likely to want to call &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;srand($seed)&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; after a &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10fb228e7791a04f02a88f131ae6798266242b1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt;, or filetest are returned. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa00f7897b1c66fe0a596f5bb93527533128be4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (or &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="translated">Если &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; не может быть найден (или &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console,&lt;/a&gt; если выполняется под Windows), тесты будут выполняться без цвета.</target>
        </trans-unit>
        <trans-unit id="42a72e58cfc32531fbd4fab5178d34e628485bf7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="translated">Если установлен &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: Meta&lt;/a&gt; , MakeMaker автоматически сгенерирует</target>
        </trans-unit>
        <trans-unit id="e5d244370ef566711e04ba5145e26efe3e9b271c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a37900ec3a9e29958a45c25ea701d35b6e343f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;IO::Socket::IP&quot;&gt;IO::Socket::IP&lt;/a&gt; 0.25 or later is installed, HTTP::Tiny will use it instead of &lt;a href=&quot;IO::Socket::INET&quot;&gt;IO::Socket::INET&lt;/a&gt; for transparent support for both IPv4 and IPv6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd755112fc59cf8f24f51046f0dfaee1c7bd92bf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (and &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a94e167e7f1c0794c5a0b78b8cee155e32baf87" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;http://man.he.net/man2/umask&quot;&gt;umask(2)&lt;/a&gt; is not implemented on your system and you are trying to restrict access for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c3ec58f6b5e85635c3d7dfd311e4342f5aba20" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (including &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect and &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108eca6848696cd0de287a231d549cff82edd6aa" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will take the current width of your screen from this environment variable, if available. It overrides terminal width information in TERMCAP.</source>
          <target state="translated">Если задано &lt;b&gt;-t&lt;/b&gt; , &lt;b&gt;pod2text&lt;/b&gt; будет брать текущую ширину вашего экрана из этой переменной среды, если она доступна. Он отменяет информацию о ширине терминала в TERMCAP.</target>
        </trans-unit>
        <trans-unit id="fc2c6665b79caef5aa91e98d089e901b7263b1c2" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will use the contents of this environment variable if available to determine the correct formatting sequences for your current terminal device.</source>
          <target state="translated">Если задано &lt;b&gt;-t&lt;/b&gt; , &lt;b&gt;pod2text&lt;/b&gt; будет использовать содержимое этой переменной среды, если она доступна, для определения правильных последовательностей форматирования для вашего текущего терминального устройства.</target>
        </trans-unit>
        <trans-unit id="9c867f84603d2f4182710d040ee18f9885c092cc" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt; , with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt; , which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt; , or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="translated">Если &lt;b&gt;Locale :: Maketext :: Lexicon&lt;/b&gt; отсутствует, он реализует функцию минимальной локализации, просто интерполируя &lt;code&gt;[_1]&lt;/code&gt; с первым аргументом, &lt;code&gt;[_2]&lt;/code&gt; со вторым и т. Д. Интерполированные функции, такие как &lt;code&gt;[quant,_1]&lt;/code&gt; , обрабатываются как &lt;code&gt;[_1]&lt;/code&gt; , с единственным исключением &lt;code&gt;[tense,_1,X]&lt;/code&gt; , которая будет добавлять &lt;code&gt;ing&lt;/code&gt; к &lt;code&gt;_1&lt;/code&gt; , когда Х &lt;code&gt;present&lt;/code&gt; , или добавляющий &lt;code&gt;ed&lt;/code&gt; к &amp;lt;_1&amp;gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="3da75cd17f8484e1cc0ad4bbfd2ed5b8f369d8c3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt;, with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt;, which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt;, or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3079127a0d6aa2996f8f83dac436403e0868d7e3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; .</source>
          <target state="translated">Если &lt;b&gt;все&lt;/b&gt; это так, то вам нужно установить для параметра &lt;code&gt;$eof&lt;/code&gt; значение true при последнем вызове (и только при последнем вызове) для &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0055cca9e96f566b053907d319402c20f817d1a7" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21045907ee178d775e967c06cc19006db36b57f1" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1304e40e4e83fe3d3333f01173ec1c6d1e1c6f99" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="translated">Если &lt;b&gt;pod2man&lt;/b&gt; завершается с ошибками, см. &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; и &lt;a href=&quot;pod/simple&quot;&gt;Pod :: Simple&lt;/a&gt; для получения информации о том, что могут означать эти ошибки.</target>
        </trans-unit>
        <trans-unit id="f3c086d017a2724c073cdc0c004a469d39ebb70e" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4176eb0fb0948998c97b4edf835cbf5dcd8f3b5" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="translated">Если &lt;b&gt;pod2text&lt;/b&gt; завершается с ошибками, см. &lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt; и &lt;a href=&quot;pod/simple&quot;&gt;Pod :: Simple&lt;/a&gt; для получения информации о том, что могут означать эти ошибки. Внутренне он также может производить следующую диагностику:</target>
        </trans-unit>
        <trans-unit id="988f5c207e367599a6818bf91e93811516af5517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; is optional. With the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt; , to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no interpolation is performed on the</source>
          <target state="translated">Если &lt;code&gt;&quot;/&quot;&lt;/code&gt; является разделителем, то начальное &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; необязательно. С помощью &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; вы можете использовать любую пару символов без пробелов (ASCII) в качестве разделителей. Это особенно полезно для сопоставления имен путей, содержащих &lt;code&gt;&quot;/&quot;&lt;/code&gt; , чтобы избежать LTS (синдрома наклонной зубочистки). Если &lt;code&gt;&quot;?&quot;&lt;/code&gt; является разделителем, тогда применяется правило единственного совпадения, описанное в &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; ниже. Если &lt;code&gt;&quot;'&quot;&lt;/code&gt; (одинарная кавычка) является разделителем, интерполяция не выполняется для</target>
        </trans-unit>
        <trans-unit id="6b9a8e2c3960de18a19c42696e997f8ffea4a1fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;m&lt;/code&gt; is optional. With the &lt;code&gt;m&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt;, to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no variable interpolation is performed on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd1c59bcbb68bd82e85d30cea7a785addeb35a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;A&quot;&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;&quot;B&quot;&lt;/code&gt; is a better match for &lt;code&gt;&quot;T&quot;&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc627db8f0150de994b80dc55cea56de1a9e2796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;A&quot;&lt;/code&gt; is a better match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4134f85a82aca95ee568f43289ebb0ed4545d2aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;$@&lt;/code&gt; пусто, используется строка &lt;code&gt;&quot;Died&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1898954d30bb03694346f5c287c1a5d39827435" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="translated">Если &lt;code&gt;$@&lt;/code&gt; пусто, используется строка &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd653baf1f66ef92b469ea572e07f68509c56382" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ENV{PERL_DESTRUCT_LEVEL}&lt;/code&gt; is set to an integer greater than the value of &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; its value is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8349dcfb4261ce55d683cb8a5fd2171cf0fa3a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$Storable::Deparse&lt;/code&gt; and/or &lt;code&gt;$Storable::Eval&lt;/code&gt; are set to false values, then the value of &lt;code&gt;$Storable::forgive_me&lt;/code&gt; (see below) is respected while serializing and deserializing.</source>
          <target state="translated">Если для &lt;code&gt;$Storable::Deparse&lt;/code&gt; и / или &lt;code&gt;$Storable::Eval&lt;/code&gt; заданы ложные значения, то значение &lt;code&gt;$Storable::forgive_me&lt;/code&gt; (см. Ниже) соблюдается при сериализации и десериализации.</target>
        </trans-unit>
        <trans-unit id="e98020b671aa605e805711cb6bc682413e70f748" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">Если &lt;code&gt;$_&lt;/code&gt; является лексическим в области видимости, где появляется &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; (потому что он был объявлен с устаревшей конструкцией &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; ), то, помимо локального псевдонима элементов списка, &lt;code&gt;$_&lt;/code&gt; продолжает оставаться лексическим внутри блока; то есть его нельзя увидеть снаружи, что позволяет избежать возможных побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="4f7113393512805f0f59fa7b96e8b849e1995d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">Если &lt;code&gt;$_&lt;/code&gt; является лексическим в области видимости, где отображается &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; (потому что он был объявлен с устаревшей конструкцией &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; ), тогда, помимо локального псевдонима элементов списка, &lt;code&gt;$_&lt;/code&gt; продолжает оставаться лексическим внутри блока; то есть его нельзя увидеть снаружи, что позволяет избежать возможных побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="cb93a45a461425fe55c63aa4556c32605c5c3edf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">Если &lt;code&gt;$_&lt;/code&gt; является лексическим в области видимости, где появляется &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; (потому что он был объявлен с устаревшей конструкцией &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; ), то, помимо локального псевдонима элементов списка, &lt;code&gt;$_&lt;/code&gt; продолжает оставаться лексическим внутри блока; то есть его нельзя увидеть снаружи, что позволяет избежать возможных побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="25899b6abc79ff8d8c10640cbdc4955bb3e63743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">Если &lt;code&gt;$_&lt;/code&gt; является лексическим в области видимости, где отображается &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; (потому что он был объявлен с устаревшей конструкцией &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; ), тогда, помимо локального псевдонима элементов списка, &lt;code&gt;$_&lt;/code&gt; продолжает оставаться лексическим внутри блока; то есть его нельзя увидеть снаружи, что позволяет избежать возможных побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="2bf18bea13d8e6a37cbbcfdc3ed1634945661fd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are scalars then after these statements</source>
          <target state="translated">Если &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; - скаляры, то после этих утверждений</target>
        </trans-unit>
        <trans-unit id="92cf042152ebf0550f54e6d7d3ad9a3448e3c104" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; pointed to an array of two elements then we would see the following.</source>
          <target state="translated">Если бы &lt;code&gt;$a&lt;/code&gt; указывал на массив из двух элементов, мы бы увидели следующее.</target>
        </trans-unit>
        <trans-unit id="fee2f2e0ebac86e4349ab49b826ea37defd988af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt; , which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt; . &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="translated">Если &lt;code&gt;$aref&lt;/code&gt; содержит ссылку на массив, тогда &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; является четвертым элементом массива. Не путайте это с &lt;code&gt;$aref[3]&lt;/code&gt; , который является четвертым элементом совершенно другого массива, обманчиво названного &lt;code&gt;@aref&lt;/code&gt; . &lt;code&gt;$aref&lt;/code&gt; и &lt;code&gt;@aref&lt;/code&gt; не связаны так же, как &lt;code&gt;$item&lt;/code&gt; и &lt;code&gt;@item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56cb4a03de2631e78fd42838b903ba847f7a9d3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt;, which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt;. &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c98499f2d6c2b76ade873a689c1003108b5526" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$bFailIfExists&lt;/code&gt; is true and &lt;code&gt;$sNewFileName&lt;/code&gt; is the path to a file that already exists, then &lt;code&gt;CopyFile&lt;/code&gt; will fail. If &lt;code&gt;$bFailIfExists&lt;/code&gt; is false, then the copy of the &lt;code&gt;$sOldFileNmae&lt;/code&gt; file will overwrite the &lt;code&gt;$sNewFileName&lt;/code&gt; file if it already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de74274409753dd786fd5d63e5d1412ca957382c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not defined, Euler's number (e) is used:</source>
          <target state="translated">Если &lt;code&gt;$base&lt;/code&gt; не определено, используется число Эйлера (e):</target>
        </trans-unit>
        <trans-unit id="0050f172fa605210fb670bacd9e4150d6ef91f04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;$base&lt;/code&gt; отсутствует или '', используется &lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd ()&lt;/a&gt; . Если &lt;code&gt;$base&lt;/code&gt; является относительным, то он преобразуется в абсолютную форму с помощью &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()&lt;/a&gt; . Это означает, что он считается относительным к &lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efe7c38890e29ff157911650e99baf9d891029df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7addd5930cc7a5f994dbe5d5d02d12cbcde98a29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$buffer&lt;/code&gt; consists of multiple concatenated gzip data streams only the first will be uncompressed. Use &lt;code&gt;gunzip&lt;/code&gt; with the &lt;code&gt;MultiStream&lt;/code&gt; option in the &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; module if you need to deal with concatenated data streams.</source>
          <target state="translated">Если &lt;code&gt;$buffer&lt;/code&gt; состоит из нескольких объединенных потоков данных gzip, только первый будет несжатым. Использование &lt;code&gt;gunzip&lt;/code&gt; с &lt;code&gt;MultiStream&lt;/code&gt; опции в &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; модуль , если вам нужно иметь дело с каскадными потоками данных.</target>
        </trans-unit>
        <trans-unit id="92f8dcce322cf03e285482ec192e88b4162c7d25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, the corresponding callback will be disabled. There can only ever be one callback for a given key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7811262733e4fe0a3b5f69a60aebbea5b3943e0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;decode&lt;/code&gt; will only accept valid JSON texts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1982a9afd1e57e2a8bcba28c638e592681686f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will not consider this type of conversion, and tagged JSON values will cause a parse error in &lt;code&gt;decode&lt;/code&gt;, as if tags were not part of the grammar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e48b0ec5233ac4e9e42a4dc42eb1f5c48b74c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will not consider this type of conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb7a77074d5d405efea88b2c7bbc5c701916dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will throw an exception when it encounters a blessed object that it cannot convert otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04de0fcb5da7e078ae940e967073b0177355bd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will throw an exception when it encounters anything it cannot encode as JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3086280d8ee71ea70bdfcb2afb309beaf2d06527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, no newlines or indenting will be produced, and the resulting JSON text is guaranteed not to contain any &lt;code&gt;newlines&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e975b01cc569dbba02de74e0b10f766fc4f3b4f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then JSON::PP does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be336cd490e25871d5c5a043187b4c6b849802ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will croak if it isn't passed an arrayref or hashref, as JSON texts must either be an object or array. Likewise, &lt;code&gt;decode&lt;/code&gt; will croak if given something that is not a JSON object or array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4552208ed349063bd809d4cf67b8cd611bca27cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not add any extra space at those places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e2d73b94d150c5d23686bd0382b4503285cd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not escape Unicode characters unless required by the JSON syntax or other flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3902c5124259f16919978729c3ce2be1df8d80a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not escape Unicode characters unless required by the JSON syntax or other flags. This results in a faster and more compact format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86f85aa1caeceb3912119cb7b2d498b0a32493f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will output key-value pairs in the order Perl stores them (which will likely change between runs of the same script, and can change even within the same run from 5.18 onwards).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b52abf83b8965155f261b8d742e8a34398b89a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will return the JSON string as a (non-encoded) Unicode string, while &lt;code&gt;decode&lt;/code&gt; expects thus a Unicode string. Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ad37ba20b3a29620caccad5e3ecd7a88326558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), the string returned by &lt;code&gt;encode&lt;/code&gt; will be shrunk (i.e. downgraded if possible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb4e08bf1d863891f648ce2830c8c09f60cbc10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain JSON objects whose names don't begin and end with quotation marks. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246bb991806282f44448e175226c86c650ef5e28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain strings that begin and end with single quotation marks. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67308b350cc4783d9abd2fdf5b4a1f710199873e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain unescaped [\x00-\x1f\x22\x5c] characters. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7558d7379ca02e4f9b9f352b5ef01f5fb78976eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept some extensions to normal JSON syntax (see below). &lt;code&gt;encode&lt;/code&gt; will not be affected in anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ace324f1a416d3e8da7b9e8dd1ed7db2c8c1dab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will convert big integers Perl cannot handle as integer into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; objects and convert floating numbers into &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects. &lt;code&gt;encode&lt;/code&gt; will convert &lt;code&gt;Math::BigInt&lt;/code&gt; and &lt;code&gt;Math::BigFloat&lt;/code&gt; objects into JSON numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c0e8fb85aba2afac4d627a09a871fc06d122a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491263f59c01a4eaaa7f2c7452a1609d3f1f36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt; will explicitly escape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3f1412723a3ab4e362a57dd7e73738bb982d44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt;, upon encountering a blessed object, will check for the availability of the &lt;code&gt;FREEZE&lt;/code&gt; method on the object's class. If found, it will be used to serialise the object into a nonstandard tagged JSON value (that JSON decoders cannot decode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35a5f5496c5b2efdffca81661108891f4928274" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt;, upon encountering a blessed object, will check for the availability of the &lt;code&gt;TO_JSON&lt;/code&gt; method on the object's class. If found, it will be called in scalar context and the resulting scalar will be encoded instead of the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aabc89dbe4a6bf91747a70a7f38abf24d998ff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method can convert a non-reference into its corresponding string, number or null JSON value, which is an extension to RFC4627. Likewise, &lt;code&gt;decode&lt;/code&gt; will accept those JSON values instead of croaking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd9f62480de589dfa295edb699ae5c2e11f3633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will add an extra optional space after the &lt;code&gt;:&lt;/code&gt; separating keys from values in JSON objects and extra whitespace after the &lt;code&gt;,&lt;/code&gt; separating key-value pairs and array members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40417ce6845e6ec8b53c1d5a6af47798ccba201d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will add an extra optional space before the &lt;code&gt;:&lt;/code&gt; separating keys from values in JSON objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08f5353e1c6dfda4e64411628e93b6243deb94f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will encode the JSON result into UTF-8, as required by many protocols, while the &lt;code&gt;decode&lt;/code&gt; method expects to be handled an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any characters outside the range &lt;code&gt;0..255&lt;/code&gt;, they are thus useful for bytewise/binary I/O. In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32 encoding families, as described in RFC4627.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb7643219ec296a582847f0971f541d53b49849" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will encode the resulting JSON text as latin1 (or iso-8859-1), escaping any characters outside the code range &lt;code&gt;0..255&lt;/code&gt;. The resulting string can be treated as a latin1-encoded JSON text or a native Unicode string. The &lt;code&gt;decode&lt;/code&gt; method will not be affected in any way by this flag, as &lt;code&gt;decode&lt;/code&gt; by default expects Unicode, which is a strict superset of latin1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d729ea73360087d038c168d6df4573c08be0b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will not barf when it encounters a blessed reference that it cannot convert otherwise. Instead, a JSON &lt;code&gt;null&lt;/code&gt; value is encoded instead of the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8120948e30627d79c4071787a445caabdb06a056" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will not generate characters outside the code range &lt;code&gt;0..127&lt;/code&gt; (which is ASCII). Any Unicode characters outside that range will be escaped using either a single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence, as per RFC4627. The resulting encoded JSON text can be treated as a native Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string, or any other superset of ASCII.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f442720c1ebc67a4d7d3134850e92ef85f78491" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will output JSON objects by sorting their keys. This is adding a comparatively high overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fd8141083b0c1d8b81b6f4d6866a0fb5c4899a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will use a multiline format as output, putting every array member or object/hash key-value pair into its own line, indenting them properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c05ab0710c330ccfa58b05a1d99cb1930161cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$fh&lt;/code&gt; is a filehandle, such as is returned by &lt;code&gt;IO::File&lt;/code&gt; or one of the other &lt;code&gt;IO&lt;/code&gt; modules, you may use:</source>
          <target state="translated">Если &lt;code&gt;$fh&lt;/code&gt; является дескриптором файла, например, возвращенным &lt;code&gt;IO::File&lt;/code&gt; или одним из других модулей &lt;code&gt;IO&lt;/code&gt; , вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="e3cb3fa6da7016a06a0ddc81b83c00820e64661b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$global&lt;/code&gt; is true then the driver should send the event to all hubs in all processes and threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412f2956d9be3c45dbde64ef1450e59ad2d04b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;&quot;register&quot;&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cddfe7cac5da52e604c2e95ecabe44db020236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;register&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;$id&lt;/code&gt; является идентификатором зарегистрированного объекта (см. &lt;a href=&quot;#register&quot;&gt;Регистр&lt;/a&gt; ), возвращает объект, в противном случае - неопределенное значение. Для зарегистрированных объектов это функция, обратная &lt;code&gt;id()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc434bb4b25d64e8d72b26a1167930b8ab9c02ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;$input&lt;/code&gt; является скалярной ссылкой, сжатые данные будут считаны из &lt;code&gt;$$input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260df432afe5ea3f6b10347c137307e5145777ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1deee19e273a335c0c4f6a1643abcff33ad56b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; является скалярной ссылкой, входные данные будут считаны из &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e61f15d9caa9af92bd7bab0101da2a2fc66fae53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442fe7b0ca25d4c885c4e854d9668346a5bb7269" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;anyinflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="9aa314fdcd8580313e8abf8e02f29427ab27b460" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;anyuncompress&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="18a54dcb23d30a160237fad9927225b0b52fd938" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;bunzip2&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="2674b9a8665c681ee519359fca9a33d0c649f2e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;bzip2&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="8d40f68b3835780881ecdd758b0745e5d0346006" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;deflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="4fe4284a3754ea968d5efe965b410a0bdc45da42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &amp;laquo;&amp;lt;&amp;raquo; и &amp;laquo;&amp;gt;&amp;raquo;, &lt;code&gt;gunzip&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="54bfc13f24ab6d2f1fe87f0e4095f9cb61a84059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;gzip&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="9bc5cf10f5ea974c9dba92b8ddcdee6c56efe154" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &amp;laquo;&amp;lt;&amp;raquo; и &amp;laquo;&amp;gt;&amp;raquo;, &lt;code&gt;inflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="8e074643e90fcbea02cb6c241eab28946a00d829" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;rawdeflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="c17eec5153adb41349f1323f8a2716fe9be3d4a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;rawinflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="4ab52d4fbbd216b398b3cd45ad27a194f5b5a84f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;unzip&lt;/code&gt; будет предполагать, что это</target>
        </trans-unit>
        <trans-unit id="35a8f72eaee6c21d9a2ad219023a7a4de0558584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;zip&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="2e1657129b850f80b9a61087ceca9451d92c60dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is an array reference, each element in the array must be a filename.</source>
          <target state="translated">Если &lt;code&gt;$input_filename_or_reference&lt;/code&gt; является ссылкой на массив, каждый элемент в массиве должен быть именем файла.</target>
        </trans-unit>
        <trans-unit id="f6f55f2709b4c8b210fa8171af0e426a8189b01a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$locale_name&lt;/code&gt; is not available, fallback is selected in the following order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bbc80ca8dd7a56323169258329eaced7ec9500d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$n&lt;/code&gt; is negative, returns the digit counting from left.</source>
          <target state="translated">Если &lt;code&gt;$n&lt;/code&gt; отрицательное, возвращает цифру, отсчитываемую слева.</target>
        </trans-unit>
        <trans-unit id="320bf336e74d67e7ea69246db25f2a4bdd482c4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$num_tests&lt;/code&gt; is omitted, the number of tests run will be used, like no_plan.</source>
          <target state="translated">Если &lt;code&gt;$num_tests&lt;/code&gt; опущено, будет использовано количество запущенных тестов, например no_plan.</target>
        </trans-unit>
        <trans-unit id="9d696967ac485ed4d512d17c0805aaab2b3cb743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$numeric&lt;/code&gt; is true, these will be given in numeric form rather than being resolved into names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec7e6706afeeac3972bbf967d824b032cbdeb1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$olBytesRead&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, it will be set to the actual number of bytes read, though &lt;code&gt;length($opBuffer)&lt;/code&gt; can also be used to determine this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1acd93b6a6ef1f8b92bfb6d087b55815058f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt; . Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="translated">Если &lt;code&gt;$output&lt;/code&gt; является буфером и &lt;code&gt;Append&lt;/code&gt; , все сжатые данные будут добавлены в конец &lt;code&gt;$output&lt;/code&gt; . В противном случае &lt;code&gt;$output&lt;/code&gt; будет очищен до того, как в него будут записаны какие-либо данные.</target>
        </trans-unit>
        <trans-unit id="92afc15c575b4de234228583007cad12aa627fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt;. Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8582554c9105fe0c715aaa06eeaea2d3fcfc688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a file or a filehandle, it must be seekable.</source>
          <target state="translated">Если &lt;code&gt;$output&lt;/code&gt; является файлом или дескриптором файла, он должен быть доступен для поиска.</target>
        </trans-unit>
        <trans-unit id="430d11ebbae99eabba1b751c1fb7c8e38808dc22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">Если &lt;code&gt;$output&lt;/code&gt; является дескриптором файла, указатель файла будет помещен в конец файла с помощью вызова &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; до того, как в него будут записаны какие-либо сжатые данные. В противном случае указатель файла не будет перемещен.</target>
        </trans-unit>
        <trans-unit id="f05d0ea62b4bacb21e297df6978bb119d6575e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f34a91ef18a1100dcab801875430fa2964155e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filename and &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">Если &lt;code&gt;$output&lt;/code&gt; является именем файла и включен параметр &amp;laquo; &lt;code&gt;Append&lt;/code&gt; , файл будет открыт в режиме добавления. В противном случае содержимое файла, если таковое имеется, будет усечено перед записью в него сжатых данных.</target>
        </trans-unit>
        <trans-unit id="905a4b022cfd04d4344f06eb8d1d7814fe3b2e8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;$output&lt;/code&gt; является скалярной ссылкой, сжатые данные будут сохранены в &lt;code&gt;$$output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a7576a43214d6e50502e7d58fdfce2630e01b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130d5c72326e4e51651ab55caf6ff565c16bd2ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является скалярной ссылкой, сжатые данные будут храниться в &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a39be39ddf44d7bf461e73a4324b038a6242f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e6e43463d8cf9f8c4cc955f62290b2d79a9ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является скалярной ссылкой, несжатые данные будут сохранены в &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21a168ccb52122de1bd3352cd9d3af1687ee7454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffed2a8f82140ef8dc0c4ed699c9112d9f907c47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;anyinflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="b9f151907f2e5c73c6d5a7f5e3827d63f2d086e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;anyuncompress&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="eb784e91a1d15b001b3d17241bbd0f023fa0db31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;bunzip2&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="308eaa4a6536e52e6cbbe3d9c09c32dfa80725fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;bzip2&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="632c19749781b38310b67e8cb7d2da8bcbd87fa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;deflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="4846f7304e22cdc9a232215f9939eddfa8d9211d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;gunzip&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="4f11ec72b95266da1fd717b81d461cc92a72f199" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;gzip&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="f099e710944546f4f6281f3a2de13a8288ffdd0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;inflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="cceae651ad537fbe024d4ffd9a457c78fec4fbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;rawdeflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="767601b4f86c38e1ce00ed67d4e6753dd438a660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;rawinflate&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="c227dd1ee1e8b9659ffdea7cebe0fc1ef9dd1a51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является строкой, разделенной символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;unzip&lt;/code&gt; будет предполагать, что это</target>
        </trans-unit>
        <trans-unit id="2ae55891ab5b00668d1e680f825b4abc927f84c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; - это строка, разделенная символами &quot;&amp;lt;&quot; и &quot;&amp;gt;&quot;, &lt;code&gt;zip&lt;/code&gt; будет считать, что это</target>
        </trans-unit>
        <trans-unit id="a78a9fcfd00ce247c78fb42d76b95940b9310c9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the compressed data will be pushed onto the array.</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является ссылкой на массив, сжатые данные будут помещены в массив.</target>
        </trans-unit>
        <trans-unit id="37e6606fa0b627f8a29d46dde4b8ebad46bd51a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the uncompressed data will be pushed onto the array.</source>
          <target state="translated">Если &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является ссылкой на массив, несжатые данные будут помещены в массив.</target>
        </trans-unit>
        <trans-unit id="46c17470e6cc4d6d06d981448409ffd8362d74b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;&quot;canonpath&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369470062bc6b67bd375785b11035d408478ab66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;$path&lt;/code&gt; является абсолютным, он очищается и возвращается с помощью &lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2c38c6381b06048880f2f47e06a03a66a2f0d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8992ca77fb991d344a3dd6a4f26aedbf1b0f1d7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;$path&lt;/code&gt; является относительным, он преобразуется в абсолютную форму с помощью &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs ()&lt;/a&gt; . Это означает, что он считается относительным к &lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a33d4ccec3781b021129aedf529c68c428662f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$phase&lt;/code&gt; or &lt;code&gt;$type&lt;/code&gt; are undefined or otherwise invalid, an exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529756014729906a36945c0c1d2b4d6306a5c66b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt; . The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt; , &lt;code&gt;$Config{libpth}&lt;/code&gt; , and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; . For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="translated">Если &lt;code&gt;$potential_libs&lt;/code&gt; пусто, возвращаемое значение будет пустым. В противном случае библиотеки, указанные в &lt;code&gt;$Config{perllibs}&lt;/code&gt; (см. Config.pm), будут добавлены в список &lt;code&gt;$potential_libs&lt;/code&gt; possible_libs . Библиотеки будут найдены в каталогах, указанных в &lt;code&gt;$potential_libs&lt;/code&gt; &lt;code&gt;$Config{libpth}&lt;/code&gt; , $ Config {libpth} и в &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; . Для каждой найденной библиотеки создается список полных путей к библиотекам, разделенный пробелами.</target>
        </trans-unit>
        <trans-unit id="a33dfa3cb51d3b667a9940aa0224c9aa9e3bd626" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt;. The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt;, &lt;code&gt;$Config{libpth}&lt;/code&gt;, and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt;. For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e553e7605e3100f0e3fcb5a8fa623376f34f081" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="translated">Если позволяет &lt;code&gt;$priority&lt;/code&gt; , регистрирует &lt;code&gt;$message&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; с добавлением, что &lt;code&gt;%m&lt;/code&gt; в $ message или &lt;code&gt;$format&lt;/code&gt; заменяется на &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (последнее сообщение об ошибке).</target>
        </trans-unit>
        <trans-unit id="853d4061f455f6e6d37a506979fa44f0b913548a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;sprintf($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f52d52d1ba29c4eacb016d029d5d02c84a30a69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;$ref&lt;/code&gt; является благословенной ссылкой, возвращается имя пакета, в который она включена. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5e917878adcf725e243606546ded3ddf73b8c65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference, the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e261aa8c38ef64f4ef56cc680e427a28531090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt; ). Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;$ref&lt;/code&gt; является ссылкой, базовый Perl-тип переменной, на которую указывает ссылка, возвращается в виде простой строки (такой как &lt;code&gt;ARRAY&lt;/code&gt; или &lt;code&gt;HASH&lt;/code&gt; ). В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbc02c6f36c505398dff2d8f520950bd61427281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference, the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt;). Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac5930e7537a0d644cf3490408ca500262cfef0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;$ref&lt;/code&gt; является ссылкой, адрес внутренней памяти указанного значения возвращается как простое целое число. В противном случае возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8848e692246887d1670a841851026e0d0d247e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference, the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2f6d4bd4dbef02b5adcb98b33be7311853de12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$result&lt;/code&gt; is undefined the corresponding parser has reached the end of its input (and will automatically be removed from the multiplexer).</source>
          <target state="translated">Если &lt;code&gt;$result&lt;/code&gt; не определен, соответствующий синтаксический анализатор достиг конца своего ввода (и будет автоматически удален из мультиплексора).</target>
        </trans-unit>
        <trans-unit id="78156973481681bf236b7a46f7e67281a60be7e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$string&lt;/code&gt; is given, then this string is appended to the already existing JSON fragment stored in the &lt;code&gt;$json&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a340f9f260eea8720ddb9232a9ecfe918063812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; не соответствует какой-либо части &lt;code&gt;$string&lt;/code&gt; , возвращает &lt;code&gt;-1&lt;/code&gt; в скалярном контексте и пустой список в контексте списка.</target>
        </trans-unit>
        <trans-unit id="34f2ce5e748390e7ea9b7256361ae68fda804dd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; не соответствует какой-либо части &lt;code&gt;$string&lt;/code&gt; , возвращает &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в скалярном контексте и пустой список в контексте списка.</target>
        </trans-unit>
        <trans-unit id="78ec8c638c3f85aaeb890b68130939aac53cb1a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns an empty list.</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; не соответствует какой-либо части &lt;code&gt;$string&lt;/code&gt; , возвращает пустой список.</target>
        </trans-unit>
        <trans-unit id="fc1b67e1c3f6e66a8b72265ebfbfbd5b7ef792af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c201b05fbdc585a181de55865d16278affee3294" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns &lt;code&gt;undef&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2e1e8a9a6ad69b33dbc5f664836bb1347dcf06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc9206b35b196b0963c771281e4b1c34fd9c295" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; соответствует части &lt;code&gt;$string&lt;/code&gt; , все вхождения совпадающей части заменяются на &lt;code&gt;$replacement&lt;/code&gt; ( &lt;code&gt;$string&lt;/code&gt; изменяется) и возвращается &lt;code&gt;$count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b46dcd3b846eff16d0953c63180197a9948d71b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; соответствует части &lt;code&gt;$string&lt;/code&gt; , в скалярном контексте возвращает &lt;b&gt;ссылку&lt;/b&gt; на первое вхождение совпадающей части ( &lt;code&gt;$match_ref&lt;/code&gt; всегда истинно, если совпадает, так как каждая ссылка &lt;b&gt;истинна&lt;/b&gt; ); в контексте списка возвращает первое вхождение соответствующей части.</target>
        </trans-unit>
        <trans-unit id="c160da8add608824da0efecdea8fe8dbd7d4c55a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns all the matching parts (or matching count in scalar context).</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; соответствует части &lt;code&gt;$string&lt;/code&gt; , возвращает все совпадающие части (или количество совпадений в скалярном контексте).</target>
        </trans-unit>
        <trans-unit id="c10bc187ce931b2a7b22530d13ae4fe64805817c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; соответствует части &lt;code&gt;$string&lt;/code&gt; , возвращает позицию первого вхождения совпадающей части в скалярном контексте; в контексте списка возвращает список из двух элементов, содержащий позицию и длину соответствующей части.</target>
        </trans-unit>
        <trans-unit id="d649e7e5214d8eb5d7dfa63d2b26508aa3ec136c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt; ) is returned.</source>
          <target state="translated">Если &lt;code&gt;$substring&lt;/code&gt; соответствует части &lt;code&gt;$string&lt;/code&gt; , первое вхождение совпадающей части заменяется на &lt;code&gt;$replacement&lt;/code&gt; ( &lt;code&gt;$string&lt;/code&gt; изменяется) и возвращается &lt;code&gt;$count&lt;/code&gt; (всегда равно &lt;code&gt;1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3fbde2ba093a3465cab9494d515f9997f56434f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4911ca5dae8ff08a4b4cb6051ee9c7432277080b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50330de1105cec13a916504977d0fffac051d470" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, returns all the matching parts (or matching count in scalar context).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37346d5bdc4adf2f6aafd9b3124f4a5fcee52ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7936ff462585086c63c3b202fca7c61f67f270da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt;) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923955b556ee1c107b87425fc0d239520dd618a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;$thing&lt;/code&gt; относится к объекту, эта функция возвращает имя пакета, в который был добавлен объект. Если &lt;code&gt;$thing&lt;/code&gt; не содержит ссылки на благословенный объект, функция &lt;code&gt;blessed&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6339b1ca7faa12a87dd16d8376168402efc0b0e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b5b827c9fa69b1b1193c08475c48b1b10adad6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , you've got a successful test.</source>
          <target state="translated">Если &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; и &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , вы успешно прошли тест.</target>
        </trans-unit>
        <trans-unit id="762c2fef6e9c59f981f639aa3049b28356711a9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt;, you've got a successful test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c7b300af278a42c6325ca397a30c8b1a02bd5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$uOldFlags&lt;/code&gt; were the value of the handle's flags before the call to &lt;code&gt;SetHandleInformation&lt;/code&gt;, then the value of the handle's flags afterward would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9127d14922a52db0d5d2508646de8dbb02dabc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar that has both numeric and string values, the result is true.</source>
          <target state="translated">Если &lt;code&gt;$var&lt;/code&gt; - скаляр, который имеет как числовые, так и строковые значения, результат будет истинным.</target>
        </trans-unit>
        <trans-unit id="811b177adb678df1c7fcd2ebe9a8006c41328bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring the result is true.</source>
          <target state="translated">Если &lt;code&gt;$var&lt;/code&gt; - скаляр, который был закодирован как vstring, результат верен.</target>
        </trans-unit>
        <trans-unit id="a9caaf937ca561a040c20b5fbde0fec6da524973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring, the result is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea1e5cda1b021861102b8f6816c7f61a9adac01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . '&lt;code&gt;NaN&lt;/code&gt; ' is returned when no modular multiplicative inverse exists.</source>
          <target state="translated">Если &lt;code&gt;$x&lt;/code&gt; и &lt;code&gt;$y&lt;/code&gt; не равны нулю, они должны быть относительными простыми числами, т.е. &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . &amp;laquo; &lt;code&gt;NaN&lt;/code&gt; &amp;raquo; возвращается, если модульного мультипликативного обратного не существует.</target>
        </trans-unit>
        <trans-unit id="b5fcc92529718794debebbbd28d3a6b743f73817" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt;. '&lt;code&gt;NaN&lt;/code&gt;' is returned when no modular multiplicative inverse exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1241f2fba2bddba0f0228a9100bb47c11034264" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;$z&lt;/code&gt; связан с буфером, этот метод не действует и всегда возвращает &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9624e7af7def5be294a442f4173d4d3d6d7e212" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2e0c2819ecb9af14cc06d8987b7eee133a60fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; is being operated on, if any.</source>
          <target state="translated">Если работает &lt;code&gt;%+&lt;/code&gt; или &lt;code&gt;%-&lt;/code&gt; , если есть.</target>
        </trans-unit>
        <trans-unit id="33759bad70947890a80808b87beeb0ad07a9f99a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is overloaded then the same implementation is used for both the</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; перегружен, то для обоих</target>
        </trans-unit>
        <trans-unit id="2655a0d13879bb1273409b47214e136f442c0716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character.</source>
          <target state="translated">Если &lt;code&gt;'-'&lt;/code&gt; является первым или последним символом в классе символов, он рассматривается как обычный символ.</target>
        </trans-unit>
        <trans-unit id="3fbcc9b880c1850b742f9cae8dd87f58567ba57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="translated">Если &lt;code&gt;'-'&lt;/code&gt; является первым или последним символом в классе символов, он рассматривается как обычный символ; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; и &lt;code&gt;[a\-b]&lt;/code&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="7642b1add676b77e55b012fe61fa0084ce5fe11b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt;, &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4ef209f3736a149a4cf48e4ad6ea5f08cb5ced" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is TRUE and no copy constructor is defined then, for objects not based on scalars, Perl may silently fall back on simple assignment - that is, assignment of the object reference. In effect, this disables the copy constructor mechanism since no new copy of the object data is created. This is almost certainly not what you want. (It is, however, consistent: for example, Perl's fallback for the &lt;code&gt;++&lt;/code&gt; operator is to increment the reference itself.)</source>
          <target state="translated">Если &lt;code&gt;'fallback'&lt;/code&gt; - ИСТИНА и конструктор копирования не определен, тогда для объектов, не основанных на скалярах, Perl может молча вернуться к простому назначению, то есть присвоению ссылки на объект. По сути, это отключает механизм конструктора копирования, поскольку не создается новая копия данных объекта. Это почти наверняка не то, что вам нужно. (Это, однако, непротиворечиво: например, резервный вариант Perl для оператора &lt;code&gt;++&lt;/code&gt; заключается в увеличении самой ссылки.)</target>
        </trans-unit>
        <trans-unit id="f876580a65734a569954c7e1c0d71566801b2a2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is undefined or TRUE then a copy constructor can be autogenerated, but only for objects based on scalars. In other cases it needs to be defined explicitly. Where an object's data is stored as, for example, an array of scalars, the following might be appropriate:</source>
          <target state="translated">Если &lt;code&gt;'fallback'&lt;/code&gt; не определен или TRUE, конструктор копирования может быть создан автоматически, но только для объектов, основанных на скалярах. В других случаях его нужно определять явно. Если данные объекта хранятся, например, в виде массива скаляров, может потребоваться следующее:</target>
        </trans-unit>
        <trans-unit id="aaf2bfa6a27ac22ef6886057189af7b7a1f09aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;//p&lt;/code&gt; ) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</source>
          <target state="translated">Если &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; или &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; равно &lt;code&gt;-1&lt;/code&gt; , то эта группа захвата не соответствует. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; представляет &lt;code&gt;$&amp;amp;&lt;/code&gt; (или &lt;code&gt;${^MATCH}&lt;/code&gt; под &lt;code&gt;//p&lt;/code&gt; ), а &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; соответствует &lt;code&gt;$$paren&lt;/code&gt; где &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="57dd1014f096fb43a6b9346ad9421342ded823ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;/p&lt;/code&gt;) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt;= 1&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6203f8ab9db59ac080a4fb390ff800c0d1e53c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt; . If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="translated">Если &lt;code&gt;-&lt;/code&gt; не распознанная буква переключения, getopts () поддерживает аргументы &lt;code&gt;--help&lt;/code&gt; и &lt;code&gt;--version&lt;/code&gt; . Если определены &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; и / или &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; , они вызываются; аргументами являются дескриптор выходного файла, имя пакета обработки опций, его версия и строка переключателей. Если подпрограммы не определены, делается попытка генерировать интеллектуальные сообщения; для достижения наилучших результатов определите $ main :: VERSION.</target>
        </trans-unit>
        <trans-unit id="14cd49c88b8972d01c98fe1ff97e8e713aaa02a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt;. If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7069d110eb31ac59c5fa5654832fee9ae99f4bc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Strict&lt;/code&gt; is disabled, then &lt;code&gt;$string&lt;/code&gt; can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">Если &lt;code&gt;-Strict&lt;/code&gt; отключено, тогда &lt;code&gt;$string&lt;/code&gt; может содержать любой символ, кроме NULL. Если присутствуют какие-либо нулевые символы, поле будет обрезано до первого значения NULL.</target>
        </trans-unit>
        <trans-unit id="72b90d51b78e3f86c015e424f0a9c82ae7cdd392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:full&lt;/code&gt; is present, for expansion of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;, the string</source>
          <target state="translated">Если присутствует &lt;code&gt;:full&lt;/code&gt; , для раскрытия &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; строка</target>
        </trans-unit>
        <trans-unit id="34845b5a7409ae2ff88602a784737cd832c5bd71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:short&lt;/code&gt; is present, and</source>
          <target state="translated">Если &lt;code&gt;:short&lt;/code&gt; присутствует short , и</target>
        </trans-unit>
        <trans-unit id="51514fa7ee13d4abe63d9987d2badb1e9b04ad61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; выходит из верхней части стека, он сообщает о самом высоком контексте.</target>
        </trans-unit>
        <trans-unit id="b1ac9c6b50bb86cfe48d37ba1ee2e0f181649af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) is ordered after &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt; . In this point, &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (не строка &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ) явно передается в качестве значения для этого ключа, никакая нормализация не выполняется (это может упростить настройку, если какая-либо нормализация нежелательна). При &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; разрешаются только непрерывные сокращения; например , даже если &lt;code&gt;A-ring&lt;/code&gt; (и &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) упорядочиваются после того, как &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;A-cedilla-ring&lt;/code&gt; будет первичным равно &lt;code&gt;A&lt;/code&gt; . В этом пункте &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;не&lt;/b&gt; эквивалентно &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa3ebd4a416f2ed67a7f6e0321914f19253d4061" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt; ).</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; передается явно как значение для этого ключа, файл не читается (но вы можете определить элементы сопоставления через &lt;code&gt;entry&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="311ed3b2b34ac0afe5f28bb9003642de34a3cf73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; передается явно как значение для этого ключа, вес слогов хангыль рассматривается как неопределенный без разложения на хангыль джамо. Но определение веса слогов хангыль в &lt;code&gt;table&lt;/code&gt; или &lt;code&gt;entry&lt;/code&gt; все еще в силе.</target>
        </trans-unit>
        <trans-unit id="a0847d602472c48d4557dcd264e5fd82c70ededc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; (see &lt;b&gt;-D&lt;/b&gt; flags in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;). &lt;code&gt;:opd&lt;/code&gt; is a shortcut for &lt;code&gt;:opd=st&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; директива имеет &lt;code&gt;:opd=FLAGS&lt;/code&gt; аргумент, это включается отладка кода операции отправки. &lt;code&gt;FLAGS&lt;/code&gt; должны быть комбинацией &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; и &lt;code&gt;P&lt;/code&gt; (см. Флаги &lt;b&gt;-D&lt;/b&gt; в &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; ). &lt;code&gt;:opd&lt;/code&gt; - это ярлык для &lt;code&gt;:opd=st&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dae0c23c00276e5219bdb2cdf7fffc6926c2f0f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; может прочитать файл, но не может его скомпилировать, он возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает сообщение об ошибке в &lt;code&gt;$@&lt;/code&gt; . Если &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; не может прочитать файл, он возвращает undef и устанавливает &lt;code&gt;$!&lt;/code&gt; к ошибке. Всегда сначала проверяйте &lt;code&gt;$@&lt;/code&gt; , так как компиляция может завершиться неудачно, что также приведет к установке &lt;code&gt;$!&lt;/code&gt; . Если файл успешно скомпилирован, &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; возвращает значение последнего вычисленного выражения.</target>
        </trans-unit>
        <trans-unit id="e753c27e9c7187898b162963067981265acf4ee7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; может прочитать файл, но не может его скомпилировать, он возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает сообщение об ошибке в &lt;code&gt;$@&lt;/code&gt; . Если &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; не может прочитать файл, он возвращает undef и устанавливает &lt;code&gt;$!&lt;/code&gt; к ошибке. Всегда сначала проверяйте &lt;code&gt;$@&lt;/code&gt; , так как компиляция может завершиться неудачно, что также приведет к установке &lt;code&gt;$!&lt;/code&gt; . Если файл успешно скомпилирован, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; возвращает значение последнего вычисленного выражения.</target>
        </trans-unit>
        <trans-unit id="a29f1441f3fe81108d43067a84beeb2b3df06a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; действительно необходим, рассмотрите возможность использования следующего:</target>
        </trans-unit>
        <trans-unit id="fbdbd42df3d8a3289f178b0b712d70c88452aff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; обнаруживает ошибку операционной системы, &lt;code&gt;$!&lt;/code&gt; будет установлено соответствующее сообщение об ошибке. Может быть полезно проверить &lt;code&gt;$!&lt;/code&gt; когда вы читаете с файловых дескрипторов, которым не доверяете, таких как tty или сокет. В следующем примере используется операторная форма &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; и завершается, если результат не определен.</target>
        </trans-unit>
        <trans-unit id="d241999daf1d6b5b1d790a94e12c3db4b7639b62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; не указывает на правильно сформированный символ UTF-8 и предупреждения UTF8 включены, возвращается ноль и &lt;code&gt;*retlen&lt;/code&gt; устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не NULL) в -1. Если эти предупреждения выключены, вычисленное значение, если оно четко определено (или СИМВОЛ ЗАМЕНЫ Юникода, если нет), возвращается без &lt;code&gt;*retlen&lt;/code&gt; , а * retlen устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не NULL), так что ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) является следующая возможная позиция в &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , с которой может начинаться нормальный символ. См. &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;Utf8n_to_uvchr&lt;/a&gt; для получения подробной информации о том, когда возвращается REPLACEMENT CHARACTER.</target>
        </trans-unit>
        <trans-unit id="e0d74bacc686d5d25a69c27fe56691316eb86755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; не указывает на правильно сформированный символ UTF-8 и предупреждения UTF8 включены, возвращается ноль и &lt;code&gt;*retlen&lt;/code&gt; устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не NULL) в -1. Если эти предупреждения отключены, вычисленное значение, если оно четко определено (или Unicode REPLACEMENT CHARACTER, если нет), возвращается без &lt;code&gt;*retlen&lt;/code&gt; , а * retlen устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не NULL), так что ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) следующая возможная позиция в &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , с которой может начинаться неизменный символ. См. &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;Utf8n_to_uvchr&lt;/a&gt; для получения подробной информации о том, когда возвращается REPLACEMENT CHARACTER.</target>
        </trans-unit>
        <trans-unit id="bd7ce6c8380ad430d911ba4aeab09bd5672c569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; указывает на одно из обнаруженных дефектов и включены предупреждения UTF8, возвращается ноль и &lt;code&gt;*retlen&lt;/code&gt; устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не указывает на NULL) в -1. Если эти предупреждения выключены, вычисленное значение, если оно четко определено (или СИМВОЛ ЗАМЕНЫ Юникода, если нет), возвращается без &lt;code&gt;*retlen&lt;/code&gt; , а * retlen устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не NULL), так что ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) является следующая возможная позиция в &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , с которой может начинаться нормальный символ. См. &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;Utf8n_to_uvchr&lt;/a&gt; для получения подробной информации о том, когда возвращается REPLACEMENT CHARACTER.</target>
        </trans-unit>
        <trans-unit id="f087a32f599c70b71522f617c69df5af3084d9d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; указывает на одну из обнаруженных дефектов и включены предупреждения UTF8, возвращается ноль, а &lt;code&gt;*retlen&lt;/code&gt; устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не NULL) в -1. Если эти предупреждения выключены, вычисленное значение, если оно четко определено (или СИМВОЛ ЗАМЕНЫ Юникода, если нет), возвращается без &lt;code&gt;*retlen&lt;/code&gt; , а * retlen устанавливается (если &lt;code&gt;retlen&lt;/code&gt; не NULL), так что ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) является следующая возможная позиция в &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , с которой может начинаться нормальный символ. См. &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;Utf8n_to_uvchr&lt;/a&gt; для получения подробной информации о том, когда возвращается REPLACEMENT CHARACTER.</target>
        </trans-unit>
        <trans-unit id="5f4f6bcfdeca5ca3ce7d26db71a53789a3b67e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; is invoked as &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , see &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; вызывается как &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; или без аргументов (что на самом деле означает &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , см. &lt;a href=&quot;functions/split&quot;&gt;Split&lt;/a&gt; ), Perl установит этот флаг. Затем механизм регулярных выражений может проверить это и установить дополнительные флаги SKIPWHITE и WHITE. Для этого движок Perl:</target>
        </trans-unit>
        <trans-unit id="5670ad2e09b0f96c2653919425d0503ae94298b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; не вызывается явно, он вызывается неявно без параметра при первом использовании оператора &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; . Однако есть несколько ситуаций, когда программы могут захотеть вызвать &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; . Один предназначен для получения предсказуемых результатов, как правило, для тестирования или отладки. Здесь вы используете &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; , каждый раз с одним и тем же значением &lt;code&gt;$seed&lt;/code&gt; . Другой случай: вы можете вызвать &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; после &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; чтобы дочерние процессы не использовали то же начальное значение, что и родительский (и, следовательно, друг друга).</target>
        </trans-unit>
        <trans-unit id="cccd9e31f8fdf12513d7e9607d1902ac2bd43369" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; передается специальный дескриптор файла, состоящий из подчеркивания, stat не выполняется, но возвращается текущее содержимое структуры stat из последнего &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; или filetest. Пример:</target>
        </trans-unit>
        <trans-unit id="3a943f3015131830c0ed79135dd6ffd5caeedbfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt; , then it uses &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; указана в качестве аргумента &lt;code&gt;autodie&lt;/code&gt; , то он использует &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt; , чтобы делать тяжелую работу. См. Описание этого модуля для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3a8b7802544453fc6ad5238177a90c2f0eccb634" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (включая &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) и был вызван POSIX :: setlocale (), на символ, используемый для десятичного разделителя в форматированных числах с плавающей запятой, влияет языковой стандарт &lt;code&gt;LC_NUMERIC&lt;/code&gt; . См. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; и &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="037fc9127a03dbcb60108531d797528430fc80ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; обнаруживает ошибку операционной системы, &lt;code&gt;$!&lt;/code&gt; будет установлено соответствующее сообщение об ошибке. Может быть полезно проверить &lt;code&gt;$!&lt;/code&gt; когда вы читаете с файловых дескрипторов, которым не доверяете, таких как tty или сокет. В следующем примере используется операторная форма &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; и завершается, если результат не определен.</target>
        </trans-unit>
        <trans-unit id="2d7702ac9f2d2a81c61f2c22a4643a2b4934ac53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; не вызывается явно, он вызывается неявно без параметра при первом использовании оператора &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; . Однако есть несколько ситуаций, когда программы могут захотеть вызвать &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; . Один предназначен для получения предсказуемых результатов, как правило, для тестирования или отладки. Здесь вы используете &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; , каждый раз с одним и тем же значением &lt;code&gt;$seed&lt;/code&gt; . Другой случай: вы можете вызвать &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; после &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; чтобы дочерние процессы не использовали то же начальное значение, что и родительский (и, следовательно, друг друга).</target>
        </trans-unit>
        <trans-unit id="0e39dea0f8d4bc40933767354a2f3ede98ed2f3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; передается специальный дескриптор файла, состоящий из подчеркивания, stat не выполняется, но возвращается текущее содержимое структуры stat из последнего &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; или filetest. Пример:</target>
        </trans-unit>
        <trans-unit id="4d0fc4f120e9a470fc6f07be480b6e3ed0441ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect:</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="acafe9c3ebbd6459bfa75fbfb2c2b7c67ce9bcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (включая &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) и был вызван POSIX :: setlocale (), на символ, используемый для десятичного разделителя в форматированных числах с плавающей запятой, влияет языковой стандарт &lt;code&gt;LC_NUMERIC&lt;/code&gt; . См. &lt;a href=&quot;../perllocale&quot;&gt;Perllocale&lt;/a&gt; и &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa0102bfd20d7fca81e7a9229fd0c15e53ef801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@descriptions&lt;/code&gt; is given, these correspond to the keys used in each call to the add() method. Returns an array of the requested parsers (in the requested order) in list context or an array reference in scalar context.</source>
          <target state="translated">Если &lt;code&gt;@descriptions&lt;/code&gt; , они соответствуют ключам, используемым в каждом вызове метода add (). Возвращает массив запрошенных анализаторов (в запрошенном порядке) в контексте списка или ссылку на массив в скалярном контексте.</target>
        </trans-unit>
        <trans-unit id="19fd000c86a54d51f5f77fda0d06393c9c4850ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; is a better match for &lt;code&gt;T&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;A'&lt;/code&gt; совпадают: &lt;code&gt;AB&lt;/code&gt; лучше, чем &lt;code&gt;AB'&lt;/code&gt; , если &lt;code&gt;B&lt;/code&gt; лучше подходит для &lt;code&gt;T&lt;/code&gt; , чем &lt;code&gt;B'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1cdd4b8faba979c10f3007699d2ae7796c4a29c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a better match for &lt;code&gt;S&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;A&lt;/code&gt; лучше соответствует &lt;code&gt;S&lt;/code&gt; , чем &lt;code&gt;A'&lt;/code&gt; , &lt;code&gt;AB&lt;/code&gt; лучше, чем &lt;code&gt;A'B'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4156d315c54ceb2fee7698af8b63e714f0a2462c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any compressed data is written to it.</source>
          <target state="translated">Если &lt;code&gt;Append&lt;/code&gt; включено, все сжатые данные будут добавлены в конец выходного буфера. В противном случае выходной буфер будет очищен перед записью в него сжатых данных.</target>
        </trans-unit>
        <trans-unit id="949b457391fc5cf37099eaecff56b10b510ca113" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all uncompressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any uncompressed data is written to it.</source>
          <target state="translated">Если &lt;code&gt;Append&lt;/code&gt; включено, все несжатые данные будут добавлены в конец выходного буфера. В противном случае выходной буфер будет очищен до того, как в него будут записаны несжатые данные.</target>
        </trans-unit>
        <trans-unit id="badd301fd65baa8719ba53ea1a80949656267442" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">Если &lt;code&gt;Append&lt;/code&gt; , файл будет открыт в режиме добавления. В противном случае содержимое файла, если таковое имеется, будет усечено перед записью в него сжатых данных.</target>
        </trans-unit>
        <trans-unit id="1454be0505ecbcd6144a8007fb6e1b0593fddf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">Если &lt;code&gt;Append&lt;/code&gt; , файл будет открыт в режиме добавления. В противном случае содержимое файла, если оно есть, будет обрезано перед записью в него несжатых данных.</target>
        </trans-unit>
        <trans-unit id="65081513c33900b0638266063d522dfa1dd85637" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">Если &lt;code&gt;Append&lt;/code&gt; включено, дескриптор файла будет помещен в конец файла с помощью вызова &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; до того, как в него будут записаны какие-либо сжатые данные. В противном случае указатель файла не будет перемещен.</target>
        </trans-unit>
        <trans-unit id="26fb68f8b046494190d2e776943c032f469c5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">Если &lt;code&gt;Append&lt;/code&gt; включено, дескриптор файла будет помещен в конец файла с помощью вызова &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; до того, как в него будут записаны несжатые данные. В противном случае указатель файла не будет перемещен.</target>
        </trans-unit>
        <trans-unit id="61760816f1c2f85d9599ced573f084a05cf816ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4c77f4cfed963d8872c1a7f3de19f7c8bb526f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cc3d0792e66bfb9901cb16087529158d209e53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyinflate&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к тому, что все дескрипторы файлов ввода и / или вывода будут закрыты после завершения &lt;code&gt;anyinflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e70bd36d1a537ad13b970c5e3018a8db164c8ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyuncompress&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к тому, что все дескрипторы файлов ввода и / или вывода будут закрыты после завершения &lt;code&gt;anyuncompress&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9769aa738284afde961b2f9bd816825ddcd7550" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bunzip2&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; и значение true, это приведет к закрытию всех дескрипторов файлов ввода и / или вывода после завершения &lt;code&gt;bunzip2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45ce2b192ba4b06ccb81a9f97e89861c03acbbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bzip2&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к закрытию всех дескрипторов входных и / или выходных файлов после завершения &lt;code&gt;bzip2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="931b26269125b502ee9a79f1079ca4ffe0db45ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;deflate&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к тому, что все дескрипторы файлов ввода и / или вывода будут закрыты после завершения &lt;code&gt;deflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1fd436eb74e99c1011e676ef2d33a7ca8f221d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gunzip&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к закрытию всех дескрипторов входных и / или выходных файлов после завершения работы с программой &lt;code&gt;gunzip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e88b090b73765991b48faaa8220edbbe4df365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gzip&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к закрытию всех дескрипторов файлов ввода и / или вывода после завершения &lt;code&gt;gzip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a90d9e6b94ea9918e75047142b2356a3ca3ce954" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;inflate&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; и значение true, это приведет к закрытию всех дескрипторов файлов ввода и / или вывода после завершения &lt;code&gt;inflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a6b1372a509b879eaf5e2572538481635eccd1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawdeflate&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; и установлено значение true, это приведет к закрытию всех дескрипторов файлов ввода и / или вывода после завершения &lt;code&gt;rawdeflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49cd128d450ba32be8b448e6b5ad08dbf2c6fedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawinflate&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к закрытию всех дескрипторов входных и / или выходных файлов после завершения &lt;code&gt;rawinflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0389ec2b7c0d6d8486da6034ee7b237f00728a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;unzip&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; указан и значение true, это приведет к закрытию всех дескрипторов входных и / или выходных файлов после завершения &lt;code&gt;unzip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b28f338327748e0ed3d3b45714c8c08b6240edf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;zip&lt;/code&gt; has completed.</source>
          <target state="translated">Если &lt;code&gt;AutoClose&lt;/code&gt; и задано значение true, это приведет к закрытию всех дескрипторов входных и / или выходных файлов после завершения &lt;code&gt;zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f369078e4170f80457a1f35c7563da5a1cc6678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Blocking&lt;/code&gt; is set to 0, the connection will be in nonblocking mode. If not specified it defaults to 1 (blocking mode).</source>
          <target state="translated">Если для параметра &lt;code&gt;Blocking&lt;/code&gt; установлено значение 0, соединение будет в неблокирующем режиме. Если не указано иное, по умолчанию используется 1 (режим блокировки).</target>
        </trans-unit>
        <trans-unit id="bb88f5eab4e448f2a5e55013144cf7297d82804e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;Net::Cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ca4e9e26da273f75ec2f01acbae00f6340bacd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;DATA&lt;/code&gt; не указаны, то результат будет указывать на то, что сервер желает отправить данные. Затем данные должны быть отправлены с использованием методов &lt;code&gt;datasend&lt;/code&gt; и &lt;code&gt;dataend&lt;/code&gt; , описанных в &lt;a href=&quot;cmd&quot;&gt;Net :: Cmd&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9556c0d7129263a154caaea9b76ae15222d837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Digest::MD5&lt;/code&gt; is not available, it return a string with only &lt;code&gt;0&lt;/code&gt;'s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e077eab3d667c955449b8c582fa6b4685309db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExactAddresses&lt;/code&gt; is passed to the constructor, then addresses should be a valid rfc2821-quoted address, although Net::SMTP will accept the address surrounded by angle brackets.</source>
          <target state="translated">Если в &lt;code&gt;ExactAddresses&lt;/code&gt; передается ExactAddresses , то адреса должны быть действительными адресами в кавычках rfc2821, хотя Net :: SMTP примет адрес, заключенный в угловые скобки.</target>
        </trans-unit>
        <trans-unit id="3d6f9a7de111ad6f15c5cac01bf2df035fda0020" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FH&lt;/code&gt; is specified then it is expected to be a valid filehandle and the result will be printed to it, on success a true value will be returned. If &lt;code&gt;FH&lt;/code&gt; is not specified then the return value, on success, will be a reference to an array containing the article requested, each entry in the array will contain one line of the article.</source>
          <target state="translated">Если указан &lt;code&gt;FH&lt;/code&gt; , то ожидается, что это действительный дескриптор файла, и результат будет напечатан на нем, в случае успеха будет возвращено истинное значение. Если &lt;code&gt;FH&lt;/code&gt; не указан, то в случае успеха возвращаемое значение будет ссылкой на массив, содержащий запрошенную статью, каждая запись в массиве будет содержать одну строку статьи.</target>
        </trans-unit>
        <trans-unit id="dcf85df21ad4f13a17a67e275700748df1fd4365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Features&lt;/code&gt; method reports a feature &lt;code&gt;attribs&lt;/code&gt; as present, the method &lt;code&gt;Attribs&lt;/code&gt; is not dummy.</source>
          <target state="translated">Если метод &lt;code&gt;Features&lt;/code&gt; сообщает об &lt;code&gt;attribs&lt;/code&gt; функции, метод &lt;code&gt;Attribs&lt;/code&gt; не является фиктивным.</target>
        </trans-unit>
        <trans-unit id="4e81c8aad04f59a1692e53f2e58534a0dee91bde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt; , which inherited from &lt;code&gt;Thing&lt;/code&gt; , then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="translated">Если &lt;code&gt;File&lt;/code&gt; унаследован от &lt;code&gt;DataSource&lt;/code&gt; , который унаследован от &lt;code&gt;Thing&lt;/code&gt; , то Perl при необходимости продолжит поиск &amp;laquo;вверх по цепочке&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="01422e251ecb63e2630d1526d1b2fd71e7e35b64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt;, which inherited from &lt;code&gt;Thing&lt;/code&gt;, then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871f80a19c627be0f52c1b6ef1cd6cbad1358e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="translated">Если &lt;code&gt;FileHandle::open&lt;/code&gt; задан числовой режим, он передает этот режим и необязательное значение разрешений оператору Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; . Для удобства &lt;code&gt;FileHandle::import&lt;/code&gt; пытается импортировать константы O_XXX из модуля Fcntl. Если динамическая загрузка недоступна, это может привести к сбою, но остальная часть FileHandle все равно будет работать.</target>
        </trans-unit>
        <trans-unit id="e5d4678ebb21520018d8a8ac8a3ed168c69d444f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;sysopen&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1f139d098c0a906b0eeef1ef6e5dc6d9836cd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">Если &lt;code&gt;FileHandle::open&lt;/code&gt; получает строку режима Perl (&amp;laquo;&amp;gt;&amp;raquo;, &amp;laquo;+ &amp;lt;&amp;raquo; и т. Д.) Или строку режима POSIX fopen () (&amp;laquo;w&amp;raquo;, &amp;laquo;r +&amp;raquo; и т. Д.), Он использует базовый Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; оператор.</target>
        </trans-unit>
        <trans-unit id="f576810c104d4cab1572ebfd5a073a5c50992b01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;open&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2feaf81d0c85e64b59f8f9c85179dcb22ae1819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GLOB_NOSORT&lt;/code&gt; is not in effect, sort filenames is alphabetical order (case does not matter) rather than in ASCII order.</source>
          <target state="translated">Если &lt;code&gt;GLOB_NOSORT&lt;/code&gt; не действует, имена файлов сортируются в алфавитном порядке (регистр не имеет значения), а не в порядке ASCII.</target>
        </trans-unit>
        <trans-unit id="67e8ee96965d8f4239b93f54928c2446de8f1552" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; to indicate whether the compiler is version 1 or 2. This is used in setting some of the default cflags. It is set to '' if not gcc.</source>
          <target state="translated">Если используется &lt;code&gt;GNU&lt;/code&gt; cc (gcc), эта переменная содержит &lt;code&gt;1&lt;/code&gt; или &lt;code&gt;2&lt;/code&gt; , чтобы указать, является ли компилятор версией 1 или 2. Это используется при установке некоторых флагов cflags по умолчанию. Он установлен в &quot;&quot;, если не gcc.</target>
        </trans-unit>
        <trans-unit id="ee184683f7c3453d93a7bedbc7d10e7e2d4b99bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds the operating system and version used to compile gcc. It is set to '' if not gcc, or if nothing useful can be parsed as the os version.</source>
          <target state="translated">Если используется &lt;code&gt;GNU&lt;/code&gt; cc (gcc), эта переменная содержит операционную систему и версию, используемую для компиляции gcc. Он установлен в '', если не gcc, или если ничего полезного не может быть проанализировано как версия ОС.</target>
        </trans-unit>
        <trans-unit id="c7c81dd0bd77cba1c688390cdf8b5eb031575d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable will enable (if set) the -ansi and -pedantic ccflags for building core files (through cflags script). (See</source>
          <target state="translated">Если используется &lt;code&gt;GNU&lt;/code&gt; cc (gcc), эта переменная включит (если установлена) -ansi и -pedantic ccflags для создания файлов ядра (через скрипт cflags). (Видеть</target>
        </trans-unit>
        <trans-unit id="0efd17fe9103ee1aaae0dc765c4fdcda7599e53f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">Если &lt;code&gt;IO::File::open&lt;/code&gt; задан режим, содержащий символ &lt;code&gt;:&lt;/code&gt; , он передает все три аргумента оператору &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; с тремя аргументами .</target>
        </trans-unit>
        <trans-unit id="d9d2307f492ec346285f4361272b678878cc377e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;open&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b022840a97cd5dd7f3b791be6eab1e939aa4189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="translated">Если &lt;code&gt;IO::File::open&lt;/code&gt; задан числовой режим, он передает этот режим и необязательное значение разрешений оператору Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; . Разрешения по умолчанию - 0666.</target>
        </trans-unit>
        <trans-unit id="648473154f696c7584f730b90fd7267a915b5e74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;sysopen&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e83efe8c19dc0d9571afae7a20a9dcda69bd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="translated">Если &lt;code&gt;IO::File::open&lt;/code&gt; получает строку режима Perl (&amp;laquo;&amp;gt;&amp;raquo;, &amp;laquo;+ &amp;lt;&amp;raquo; и т. Д.) Или строку режима ANSI C fopen () (&amp;laquo;w&amp;raquo;, &amp;laquo;r +&amp;raquo; и т. Д.), Он использует основной оператор &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; Perl (но защищает любые специальные символы).</target>
        </trans-unit>
        <trans-unit id="a2b31024d2546cbe74c22838b7e8daa31b3fb8b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;open&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25244641705396e9c5a0c603f886177852688f85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; is omitted, the file list is obtained from the manifest. The file list may include shell wildcards which will be expanded out.</source>
          <target state="translated">Если &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; опущен, список файлов получается из манифеста. Список файлов может включать подстановочные знаки оболочки, которые будут расширены.</target>
        </trans-unit>
        <trans-unit id="bc047fe00993cc36f1bde2a682c140574f3968b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; has been specified then XFL is set to 2. If &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; has been specified then XFL is set to 4. Otherwise XFL is set to 0.</source>
          <target state="translated">Если &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; , тогда XFL устанавливается на 2. Если указан &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; , то XFL устанавливается на 4. В противном случае XFL устанавливается на 0.</target>
        </trans-unit>
        <trans-unit id="0aa2ad74e8011287eeea7635ab9b549166e0107b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LimitOutput&lt;/code&gt; is enabled, the &lt;code&gt;ConsumeInput&lt;/code&gt; option will also be enabled.</source>
          <target state="translated">Если &lt;code&gt;LimitOutput&lt;/code&gt; включен, параметр &lt;code&gt;ConsumeInput&lt;/code&gt; также будет включен.</target>
        </trans-unit>
        <trans-unit id="6b5272a0252e677f68469c99e247e850a281513f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Listen&lt;/code&gt; is defined then a listen socket is created, else if the socket type, which is derived from the protocol, is SOCK_STREAM then connect() is called. If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">Если &lt;code&gt;Listen&lt;/code&gt; определено, создается прослушивающий сокет, иначе, если тип сокета, производный от протокола, SOCK_STREAM, вызывается connect (). Если аргумент &lt;code&gt;Listen&lt;/code&gt; задан, но false, размер очереди будет равен 5.</target>
        </trans-unit>
        <trans-unit id="119d044a27ad244e9922efb2919b95739dfc6f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; is a reference to a list of two message numbers and the second number in a range is less than or equal to the first then the range represents all messages in the group after the first message number.</source>
          <target state="translated">Если &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; - это ссылка на список из двух номеров сообщений, а второй номер в диапазоне меньше или равен первому, тогда диапазон представляет все сообщения в группе после первого номера сообщения.</target>
        </trans-unit>
        <trans-unit id="983c80c65b5dc12e5941f3ad256f42dbd5aa351d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;Net::Cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fae31070991ff1f03f3487ee3feed2b35c28afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="translated">Если &lt;code&gt;MESSAGE&lt;/code&gt; не указан, сообщение должно быть отправлено с использованием методов &lt;code&gt;datasend&lt;/code&gt; и &lt;code&gt;dataend&lt;/code&gt; из &lt;a href=&quot;cmd&quot;&gt;Net :: Cmd.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4f8b5e83cced9672fcf844844603c4b1519fbeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NEXT&lt;/code&gt; redispatching is used in the methods of a &quot;diamond&quot; class hierarchy:</source>
          <target state="translated">Если в методах иерархии классов &amp;laquo;ромб&amp;raquo; используется &lt;code&gt;NEXT&lt;/code&gt; редиспетчинг:</target>
        </trans-unit>
        <trans-unit id="fa6cc1f17445fc581970662d0c27067922cd4606" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the zip filename header field.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; не указано и параметр &lt;code&gt;$input&lt;/code&gt; представляет собой имя файла, значение &lt;code&gt;$input&lt;/code&gt; будет использоваться для поля заголовка файла zip-архива.</target>
        </trans-unit>
        <trans-unit id="16fa552eaed310969186dcb3a6fc9c674d262d84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, no zip filename field will be created.</source>
          <target state="translated">Если &lt;code&gt;Name&lt;/code&gt; не указано и параметр &lt;code&gt;$input&lt;/code&gt; не является именем файла, поле имени файла в формате zip не создается.</target>
        </trans-unit>
        <trans-unit id="90ec1912df6897d3b8157fa885ee828e31fcb30c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_LOADMOD_DENY&lt;/code&gt; is set, the module is loaded as if with &lt;code&gt;no&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d9c7a2c762fe5aa671ca88a1e57aa13b9aa7f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; is set, the module is loaded as if with an empty import list, as in &lt;code&gt;use Foo::Bar ()&lt;/code&gt;; this is the only circumstance in which the trailing optional arguments may be omitted entirely. Otherwise, if &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; is set, the trailing arguments must consist of exactly one &lt;code&gt;OP*&lt;/code&gt;, containing the op tree that produces the relevant import arguments. Otherwise, the trailing arguments must all be &lt;code&gt;SV*&lt;/code&gt; values that will be used as import arguments; and the list must be terminated with &lt;code&gt;(SV*) NULL&lt;/code&gt;. If neither &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; nor &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; is set, the trailing &lt;code&gt;NULL&lt;/code&gt; pointer is needed even if no import arguments are desired. The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; argument is decremented. In addition, the &lt;code&gt;name&lt;/code&gt; argument is modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7150b29ccf2318861af577a7533fe5cd202a009c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_ALL&lt;/code&gt; is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if &lt;code&gt;PERL_PV_ESCAPE_NONASCII&lt;/code&gt; is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt;. Otherwise, if &lt;code&gt;PERL_PV_ESCAPE_NOBACKSLASH&lt;/code&gt; then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6e934e5c2d97914014a2305fe6d83cca0f7a87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_FIRSTCHAR&lt;/code&gt; is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4556bf449af07632214df812c6e299c60c88a77e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_RE&lt;/code&gt; is set then the escape char used will be a &lt;code&gt;&quot;%&quot;&lt;/code&gt; and not a &lt;code&gt;&quot;\\&quot;&lt;/code&gt;. This is because regexes very often contain backslashed sequences, whereas &lt;code&gt;&quot;%&quot;&lt;/code&gt; is not a particularly common character in patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b287252fa0fadb9f209dd7e1ddcb194eaed64b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_UNI&lt;/code&gt; is set then the input string is treated as UTF-8 if &lt;code&gt;PERL_PV_ESCAPE_UNI_DETECT&lt;/code&gt; is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35533bcb02c546225ef493f044a6f536db7a71c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in</source>
          <target state="translated">Если &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; установлен в</target>
        </trans-unit>
        <trans-unit id="927d1c982e9f33464297a28a964aa06b97d23586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt; then any or all pairs of digits may be separated from each other by a single underscore; also a single leading underscore is accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cb6eab9df9b80f7b8043595e084ea362a195f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt; . If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl
-MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; . If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="translated">Если &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; переменная среды PERL_TEST_DIFF , она будет использоваться в качестве команды для сравнения неожиданных многострочных результатов. Если у вас установлен GNU diff, вы можете установить для &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; значение &lt;code&gt;diff -u&lt;/code&gt; . Если у вас нет подходящей программы, вы можете установить модуль &lt;code&gt;Text::Diff&lt;/code&gt; а затем установить &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; как &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; . Если &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; не установлен, но доступен модуль &lt;code&gt;Algorithm::Diff&lt;/code&gt; , он будет использоваться для отображения различий в многострочных результатах.</target>
        </trans-unit>
        <trans-unit id="4e08ae53639fc6920187fdd8042110e8e1996f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt;. If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt;. If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb3ad782aee3a8db708fe40cb7ddcd44325815d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PadnameOUTER&lt;/code&gt; is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee3b30e6a54d64d92736caa387fa1fa00014452" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PerlIO_push&lt;/code&gt; was performed and open has failed, it must &lt;code&gt;PerlIO_pop&lt;/code&gt; itself, since if it's not, the layer won't be removed and may cause bad problems.</source>
          <target state="translated">Если &lt;code&gt;PerlIO_push&lt;/code&gt; был выполнен и открытие не удалось, он должен сам &lt;code&gt;PerlIO_pop&lt;/code&gt; , поскольку в противном случае слой не будет удален и может вызвать серьезные проблемы.</target>
        </trans-unit>
        <trans-unit id="e92add0536c750719a7004e9b389b82f89f36216" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Proto&lt;/code&gt; is not given and you specify a symbolic &lt;code&gt;PeerPort&lt;/code&gt; port, then the constructor will try to derive &lt;code&gt;Proto&lt;/code&gt; from the service name. As a last resort &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot; is assumed. The &lt;code&gt;Type&lt;/code&gt; parameter will be deduced from &lt;code&gt;Proto&lt;/code&gt; if not specified.</source>
          <target state="translated">Если &lt;code&gt;Proto&lt;/code&gt; не указан и вы укажете символический порт &lt;code&gt;PeerPort&lt;/code&gt; , то конструктор попытается получить &lt;code&gt;Proto&lt;/code&gt; из имени службы. В крайнем случае предполагается &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot;. Параметр &lt;code&gt;Type&lt;/code&gt; будет выведен из &lt;code&gt;Proto&lt;/code&gt; , если не указан.</target>
        </trans-unit>
        <trans-unit id="fe5b8d2d2cf1b0bc68bdf3e0b890723eb0712304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SkipBad&lt;/code&gt; is true the &lt;code&gt;recipient&lt;/code&gt; will not return an error when a bad address is encountered and it will return an array of addresses that did succeed.</source>
          <target state="translated">Если &lt;code&gt;SkipBad&lt;/code&gt; имеет значение true, &lt;code&gt;recipient&lt;/code&gt; не будет возвращать ошибку при обнаружении неверного адреса и вернет массив адресов, которые действительно были успешными.</target>
        </trans-unit>
        <trans-unit id="d0468225999e79fdda0c8dc21ac9ecaa76acd0e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Strict&lt;/code&gt; is enabled the following behaviour will be policed:</source>
          <target state="translated">Если включен &lt;code&gt;Strict&lt;/code&gt; , будет отслеживаться следующее поведение:</target>
        </trans-unit>
        <trans-unit id="b96d3e92a2737a01f8355b6b1112adb835436235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;TIMEOUT&lt;/code&gt; отсутствует, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , меньше или равен 0, то этот вызов ведет себя так же, как &lt;code&gt;dequeue_nb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c530cec74f6e8b7055d3fa3d9efe868ec89d0a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;undef&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3dbb2f4f8d2f84122800f9964093173fd31ae6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt; 's memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt; , the entire file will be rewritten in a single pass.</source>
          <target state="translated">Если предел памяти &lt;code&gt;Tie::File&lt;/code&gt; достаточно велик, вся запись будет выполняться в памяти. Затем, когда вы вызываете &lt;code&gt;-&amp;gt;flush&lt;/code&gt; , весь файл будет перезаписан за один проход.</target>
        </trans-unit>
        <trans-unit id="86295dc1bf1fa74a00cc2da2e3439e42c182b9ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt;'s memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt;, the entire file will be rewritten in a single pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717bb6fc0375ed7c5d36f69b6a41d7203067aa19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is 26 or later, the &lt;code&gt;identical&lt;/code&gt; level is preferred; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; and &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt;&lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; should be used.</source>
          <target state="translated">Если &lt;code&gt;UCA_Version&lt;/code&gt; - 26 или новее, предпочтителен &lt;code&gt;identical&lt;/code&gt; уровень; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; и &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt; &lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02434c0e062f79bd3d8c8ef802e8385afcfb68a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or greater than 14, default is &lt;code&gt;[]&lt;/code&gt; (i.e. no rearrangement).</source>
          <target state="translated">Если &lt;code&gt;UCA_Version&lt;/code&gt; больше или равно 14, по умолчанию используется &lt;code&gt;[]&lt;/code&gt; (то есть без изменения порядка).</target>
        </trans-unit>
        <trans-unit id="b309f1cb237c3cb1331fc5e7c80d1a3dc5b1ba82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="translated">Если &lt;code&gt;VALUE&lt;/code&gt; - &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , тогда уровень отладки будет установлен на уровень отладки по умолчанию для класса.</target>
        </trans-unit>
        <trans-unit id="4e940cabf3eff6f96ef019a41252378fda2e834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44072f8a4414482a73ce8e1b198996a838545678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WHERE&lt;/code&gt; is given then the first &lt;code&gt;WHERE&lt;/code&gt; bytes of the file will not be transferred, and the remaining bytes will be appended to the local file if it already exists.</source>
          <target state="translated">Если задано &lt;code&gt;WHERE&lt;/code&gt; , то первые байты &lt;code&gt;WHERE&lt;/code&gt; файла не будут переданы, а оставшиеся байты будут добавлены к локальному файлу, если он уже существует.</target>
        </trans-unit>
        <trans-unit id="ac99e0f8353a2cf6b3d40ee09fd4abe5de979195" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allow_tags&lt;/code&gt; is enabled, &lt;code&gt;JSON::PP&lt;/code&gt; will look up the &lt;code&gt;THAW&lt;/code&gt; method of the package/classname used during serialisation (it will not attempt to load the package as a Perl module). If there is no such method, the decoding will fail with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdf8e9a5929ab26a43f519805188b99c5f0b522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="translated">Если в конструкторе объекта bunzip2 включен &lt;code&gt;appendOutput&lt;/code&gt; , несжатые данные будут добавлены в &lt;code&gt;$output&lt;/code&gt; . Если не включен, &lt;code&gt;$output&lt;/code&gt; будет обрезан перед записью в него несжатых данных.</target>
        </trans-unit>
        <trans-unit id="667286e52e2e632a32355f2300da667dd6bd7a78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f450b4455b8d11ffbd473a1bb2010cafedaed33e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="translated">Если в конструкторе объекта bzip2 включен &lt;code&gt;appendOutput&lt;/code&gt; , сжатые данные будут добавлены в &lt;code&gt;$output&lt;/code&gt; . Если не включен, &lt;code&gt;$output&lt;/code&gt; будет обрезан перед записью в него сжатых данных.</target>
        </trans-unit>
        <trans-unit id="096baeccf53db357601ffc253c8281b1e48c8ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1432fae77d6dafc174cc09ef9602a6c9c5caf4ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block&lt;/code&gt; is null then the subroutine will have no body, and for the time being it will be an error to call it. This represents a forward subroutine declaration such as &lt;code&gt;sub foo ($$);&lt;/code&gt;. If &lt;code&gt;block&lt;/code&gt; is non-null then it provides the Perl code of the subroutine body, which will be executed when the subroutine is called. This body includes any argument unwrapping code resulting from a subroutine signature or similar. The pad use of the code must correspond to the pad attached to &lt;code&gt;PL_compcv&lt;/code&gt;. The code is not expected to include a &lt;code&gt;leavesub&lt;/code&gt; or &lt;code&gt;leavesublv&lt;/code&gt; op; this function will add such an op. &lt;code&gt;block&lt;/code&gt; is consumed by this function and will become part of the constructed subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b199e24b4ee7d3c552a01dcb6637c8cc3a9e1f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bundling_override&lt;/code&gt; is enabled, bundling is enabled as with &lt;code&gt;bundling&lt;/code&gt; but now long option names override option bundles.</source>
          <target state="translated">Если &lt;code&gt;bundling_override&lt;/code&gt; включен, объединение включено, как и в случае &lt;code&gt;bundling&lt;/code&gt; но теперь длинные имена параметров переопределяют пакеты параметров.</target>
        </trans-unit>
        <trans-unit id="54b90baea8c11dc735bd2168186bca9ee27f1a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;caller()&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dc97ff755fb934bfd6f1a8ed830ff62cc4e40b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;consumeInput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, &lt;code&gt;$input&lt;/code&gt; will have all compressed data removed from it after uncompression. On &lt;code&gt;BZ_OK&lt;/code&gt; return this will mean that &lt;code&gt;$input&lt;/code&gt; will be an empty string; when &lt;code&gt;BZ_STREAM_END&lt;/code&gt;&lt;code&gt;$input&lt;/code&gt; will either be an empty string or will contain whatever data immediately followed the compressed data stream.</source>
          <target state="translated">Если в конструкторе для объекта bunzip2 включен &lt;code&gt;consumeInput&lt;/code&gt; , все сжатые данные будут удалены из &lt;code&gt;$input&lt;/code&gt; после распаковки. При &lt;code&gt;BZ_OK&lt;/code&gt; это будет означать, что &lt;code&gt;$input&lt;/code&gt; будет пустой строкой; когда &lt;code&gt;BZ_STREAM_END&lt;/code&gt; &lt;code&gt;$input&lt;/code&gt; будет либо пустой строкой, либо будет содержать любые данные, непосредственно следующие за потоком сжатых данных.</target>
        </trans-unit>
        <trans-unit id="13672333fc5b967feaa626b683b8bcc04e6c7332" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1dd05ec9d332008df8a7389201274fce30d7a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">Если &lt;code&gt;cv&lt;/code&gt; является подпрограммой-константой, подходящей для встраивания, возвращает постоянное значение, возвращаемое подпрограммой. В противном случае возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="ede33bdf6d08f63d2072630b001c1c1d527bfdbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37d86734f002378b0c0f7d856f9af361e68cbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done_testing()&lt;/code&gt; is called twice, the second call will issue a failing test.</source>
          <target state="translated">Если &lt;code&gt;done_testing()&lt;/code&gt; вызывается дважды, второй вызов выдаст неудачный тест.</target>
        </trans-unit>
        <trans-unit id="a074a15a27ab0ac63397d85c19569d7f123797eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;down()&lt;/code&gt; пытается уменьшить значение счетчика ниже нуля, он блокируется, пока счетчик не станет достаточно большим. Обратите внимание, что хотя семафор может быть создан с начальным счетчиком, равным нулю, любой &lt;code&gt;up()&lt;/code&gt; или &lt;code&gt;down()&lt;/code&gt; всегда изменяет счетчик как минимум на единицу, поэтому &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; совпадает с &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc095b856cd7bbcf568ac5723a3a668cbf72bdda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2ee9c9e231a07f99e855dc49bb00a01e62f7c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e &amp;lt; s&lt;/code&gt; or if the scan would end up past &lt;code&gt;e&lt;/code&gt;, it raises a UTF8 warning and returns the number of valid characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73e1156e34709c2cf87a897c0dfdd15558afa70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit()&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ba804a2596516d0c1570f7f282c973ab9c2345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extract&lt;/code&gt; is called without a list of file names, the entire contents of the archive are extracted.</source>
          <target state="translated">Если &lt;code&gt;extract&lt;/code&gt; вызывается без списка имен файлов, извлекается все содержимое архива.</target>
        </trans-unit>
        <trans-unit id="fd1942906fddd7c45d5614b21cfa194ab92d3708" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fallback&lt;/code&gt; is TRUE for both operands then perform the usual operation for the operator, treating the operands as numbers, strings, or booleans as appropriate for the operator (see note).</source>
          <target state="translated">Если для обоих операндов &lt;code&gt;fallback&lt;/code&gt; имеет значение ИСТИНА, выполните обычную операцию для оператора, обрабатывая операнды как числа, строки или логические значения в зависимости от оператора (см. Примечание).</target>
        </trans-unit>
        <trans-unit id="77c9ad5fa8afacb61183204af87e0582ca853195" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags &amp;amp; SV_SMAGIC&lt;/code&gt; is true, will call &lt;code&gt;SvSETMAGIC&lt;/code&gt;. If &lt;code&gt;flags &amp;amp; SV_HAS_TRAILING_NUL&lt;/code&gt; is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt;, and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt;, and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd52e0f8326669fc207b7050c548b0008ac0b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_SMAGIC is true, will call SvSETMAGIC. If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_HAS_TRAILING_NUL is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt; , and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt; , and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt; ).</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_SMAGIC истинно, вызовет SvSETMAGIC. Если &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_HAS_TRAILING_NUL истинно, тогда &lt;code&gt;ptr[len]&lt;/code&gt; должно быть &lt;code&gt;NUL&lt;/code&gt; , и перераспределение будет пропущено (т.е. буфер на самом деле как минимум на 1 байт длиннее, чем &lt;code&gt;len&lt;/code&gt; , и уже соответствует требованиям для хранения в &lt;code&gt;SvPVX&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0edc0d40cf1bae07e3194b59cda754464ac0af29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not include the &lt;code&gt;G_DISCARD&lt;/code&gt; flag then &lt;code&gt;hv_delete&lt;/code&gt; will create and return a mortal copy of the deleted value.</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; не включает флаг &lt;code&gt;G_DISCARD&lt;/code&gt; , тогда &lt;code&gt;hv_delete&lt;/code&gt; создаст и вернет смертельную копию удаленного значения.</target>
        </trans-unit>
        <trans-unit id="10df1aa8bd4f0824119d6cef9b8d19de3f0f48a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV will expand when converted to UTF-8, and skips the extra work of checking for that. Typically this flag is used by a routine that has already parsed the string and found such characters, and passes this information on so that the work doesn't have to be repeated.</source>
          <target state="translated">Если для &lt;code&gt;flags&lt;/code&gt; установлен SV_FORCE_UTF8_UPGRADE, эта функция предполагает, что PV будет расширяться при преобразовании в UTF-8, и пропускает дополнительную работу по проверке этого. Обычно этот флаг используется подпрограммой, которая уже проанализировала строку и нашла такие символы, и передает эту информацию, чтобы не приходилось повторять работу.</target>
        </trans-unit>
        <trans-unit id="ad87c09509d32a63c00d8007a6c9913223d72fda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;CV_NAME_NOTQUAL&lt;/code&gt; bit set, then the package name will not be included. If the first argument is neither a CV nor a GV, this flag is ignored (subject to change).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b250f1c8aff9dcda9cab5ceb3c6ef02e048bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on &lt;code&gt;dsv&lt;/code&gt; afterwards if appropriate. &lt;code&gt;sv_catpvn&lt;/code&gt; and &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">Если &lt;code&gt;flags&lt;/code&gt; имеет &lt;code&gt;SV_SMAGIC&lt;/code&gt; бит &lt;code&gt;dsv&lt;/code&gt; впоследствии, если необходимо , будет &lt;code&gt;mg_set&lt;/code&gt; на dsv . &lt;code&gt;sv_catpvn&lt;/code&gt; и &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; реализованы в терминах этой функции.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
