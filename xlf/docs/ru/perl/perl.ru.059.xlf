<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8bdb3d95ccb59bc0d07d098ed208693769c903c6" translate="yes" xml:space="preserve">
          <source>The code below is the example given in the section &lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;&quot;Returning a List of Values&quot;&lt;/a&gt; recoded to use &lt;code&gt;ST&lt;/code&gt; instead of &lt;code&gt;POP*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e196e9f225b5138a983bdb659d302d31a1c384a" translate="yes" xml:space="preserve">
          <source>The code below makes use of both modules, but it only enables warnings from &lt;code&gt;Derived&lt;/code&gt; .</source>
          <target state="translated">В приведенном ниже коде используются оба модуля, но разрешены только предупреждения от &lt;code&gt;Derived&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8d10f2ac8bfc175d6b9fc2029df5ae45e37aba" translate="yes" xml:space="preserve">
          <source>The code below makes use of both modules, but it only enables warnings from &lt;code&gt;Derived&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b70175bee574db6d4bbb54ae246e1319c020349" translate="yes" xml:space="preserve">
          <source>The code block introduces a new scope from the perspective of lexical variable declarations, but &lt;b&gt;not&lt;/b&gt; from the perspective of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; and similar localizing behaviours. So later code blocks within the same pattern will still see the values which were localized in earlier blocks. These accumulated localizations are undone either at the end of a successful match, or if the assertion is backtracked (compare &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). For example,</source>
          <target state="translated">Блок кода вводит новую область видимости с точки зрения объявления лексических переменных, но &lt;b&gt;не&lt;/b&gt; с точки зрения &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; и аналогичного поведения при локализации. Таким образом, более поздние блоки кода в рамках того же шаблона по-прежнему будут видеть значения, которые были локализованы в более ранних блоках. Эти накопленные локализации отменяются либо в конце успешного сопоставления, либо при возврате утверждения (сравните &amp;laquo; &lt;a href=&quot;#Backtracking&quot;&gt;Отслеживание с возвратом&amp;raquo;&lt;/a&gt; ). Например,</target>
        </trans-unit>
        <trans-unit id="1ccc31759490ed4f4b37600e130c2bd926ef15da" translate="yes" xml:space="preserve">
          <source>The code block introduces a new scope from the perspective of lexical variable declarations, but &lt;b&gt;not&lt;/b&gt; from the perspective of &lt;code&gt;local&lt;/code&gt; and similar localizing behaviours. So later code blocks within the same pattern will still see the values which were localized in earlier blocks. These accumulated localizations are undone either at the end of a successful match, or if the assertion is backtracked (compare &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;). For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98d3c5b00844f7eee566f69a2fd1ffcc0553db1" translate="yes" xml:space="preserve">
          <source>The code can only see the compartment's namespace (as returned by the &lt;b&gt;root&lt;/b&gt; method). The compartment's root package appears to be the &lt;code&gt;main::&lt;/code&gt; package to the code inside the compartment.</source>
          <target state="translated">Код может видеть только пространство имен отсека (возвращаемое &lt;b&gt;корневым&lt;/b&gt; методом). Корневой пакет отсека выглядит как &lt;code&gt;main::&lt;/code&gt; package для кода внутри отсека.</target>
        </trans-unit>
        <trans-unit id="7cc1bb98d53bdcc3465bf9409e43dfe68967ea92" translate="yes" xml:space="preserve">
          <source>The code in the enclosing block has warnings enabled, but the inner block has them disabled. In this case that means the assignment to the scalar &lt;code&gt;$c&lt;/code&gt; will trip the &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; warning, but the assignment to the scalar &lt;code&gt;$b&lt;/code&gt; will not.</source>
          <target state="translated">В коде во включающем блоке включены предупреждения, но во внутреннем блоке они отключены. В этом случае это означает, что присвоение скаляру &lt;code&gt;$c&lt;/code&gt; вызовет &lt;code&gt;&quot;Scalar value @a[0] better written as $a[0]&quot;&lt;/code&gt; , а присвоение скаляру &lt;code&gt;$b&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="3bbef419a6073b40632618263de6b83e9a3b2f8c" translate="yes" xml:space="preserve">
          <source>The code involved in &lt;code&gt;study_chunk()&lt;/code&gt; is extremely cryptic. Be careful. :-)</source>
          <target state="translated">Код, задействованный в &lt;code&gt;study_chunk()&lt;/code&gt; , чрезвычайно загадочен. Быть осторожен. :-)</target>
        </trans-unit>
        <trans-unit id="fa55939059730530d1f6070150cdfbb84afaa7d4" translate="yes" xml:space="preserve">
          <source>The code is executed</source>
          <target state="translated">Код выполнен</target>
        </trans-unit>
        <trans-unit id="8fe7ae8735b35c106099f4a767ac8bec4145c55c" translate="yes" xml:space="preserve">
          <source>The code is executed in the package &lt;code&gt;DB&lt;/code&gt; . Note that</source>
          <target state="translated">Код выполняется в &lt;code&gt;DB&lt;/code&gt; пакета . Обратите внимание, что</target>
        </trans-unit>
        <trans-unit id="4798879ea913146cee43e9bcaacaa4e16f87e07c" translate="yes" xml:space="preserve">
          <source>The code is executed in the package &lt;code&gt;DB&lt;/code&gt;. Note that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdd192de0a16314fb946ed4a5f124bbba34ce51" translate="yes" xml:space="preserve">
          <source>The code is hosted on Github: https://github.com/jonathanstowe/Term-Cap please feel free to fork, submit patches etc, etc there.</source>
          <target state="translated">Код размещен на Github:https://github.com/jonathanstowe/Term-Cap,пожалуйста,не стесняйтесь вилки,присылайте патчи и т.д.и т.п.там.</target>
        </trans-unit>
        <trans-unit id="6188bbd338f5f4453ec5eefb9a596ee762c4a047" translate="yes" xml:space="preserve">
          <source>The code is not optimized for speed, especially because we use &lt;code&gt;Math::Complex&lt;/code&gt; and thus go quite near complex numbers while doing the computations even when the arguments are not. This, however, cannot be completely avoided if we want things like &lt;code&gt;asin(2)&lt;/code&gt; to give an answer instead of giving a fatal runtime error.</source>
          <target state="translated">Код не оптимизирован для скорости, особенно потому, что мы используем &lt;code&gt;Math::Complex&lt;/code&gt; и, таким образом, приближаемся к комплексным числам при выполнении вычислений, даже если аргументы не являются. Однако этого нельзя полностью избежать, если мы хотим, чтобы такие вещи, как &lt;code&gt;asin(2)&lt;/code&gt; давали ответ вместо фатальной ошибки времени выполнения.</target>
        </trans-unit>
        <trans-unit id="eeb45ce8e4c72e0b27d2dd4e6b03aed6d8283a3c" translate="yes" xml:space="preserve">
          <source>The code isn't pretty as I mentioned -- I never thought it would be a 1000- line program when I started, or I might not have begun. :-) But I would have been less cavalier in how the parts of the program communicated with each other, etc. It might also have helped if I didn't have to divine the makeup of the stabs on the fly, and then account for micro differences between my compiler and gcc.</source>
          <target state="translated">Код не очень красивый,как я упоминал-я никогда не думал,что это будет 1000-строчная программа,когда я начинал,или я,возможно,не начинал.:-)Но я был бы менее бесцеремонен в том,как части программы общаются друг с другом и так далее.Также могло бы помочь,если бы мне не приходилось боготворить макияж ударов на лету,а затем учитывать микроразличия между моим компилятором и gcc.</target>
        </trans-unit>
        <trans-unit id="1af03be532193b63c39bccd8f3769c3c4ba84570" translate="yes" xml:space="preserve">
          <source>The code point can be any that will fit in an IV on this machine, using Perl's extension to official UTF-8 to represent those higher than the Unicode maximum of 0x10FFFF. That means that this macro is used to efficiently decide if the next few bytes in &lt;code&gt;s&lt;/code&gt; is legal UTF-8 for a single character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a38d0cd4c97e31c5c6e8ef232e032151d44d07e" translate="yes" xml:space="preserve">
          <source>The code point represented by the input UTF-8 sequence is for a Unicode non-character code point. This bit is set only if the input &lt;code&gt;flags&lt;/code&gt; parameter contains either the &lt;code&gt;UTF8_DISALLOW_NONCHAR&lt;/code&gt; or the &lt;code&gt;UTF8_WARN_NONCHAR&lt;/code&gt; flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e137833ea36c6bb446c1454de0e7f32827ac2db" translate="yes" xml:space="preserve">
          <source>The code reference associated with &lt;code&gt;Store&lt;/code&gt; will be called before any key/value is written to the database and the code reference associated with &lt;code&gt;Fetch&lt;/code&gt; will be called after any key/value is read from the database.</source>
          <target state="translated">Ссылка на код, связанная с &lt;code&gt;Store&lt;/code&gt; , будет вызываться перед записью любого ключа / значения в базу данных, а ссылка на код, связанная с &lt;code&gt;Fetch&lt;/code&gt; , будет вызываться после чтения любого ключа / значения из базы данных.</target>
        </trans-unit>
        <trans-unit id="9112803a8d3c96a68465b0bcde1920f2e7e6a455" translate="yes" xml:space="preserve">
          <source>The code to be parsed comes from</source>
          <target state="translated">Код,который нужно разобрать,исходит от</target>
        </trans-unit>
        <trans-unit id="f56dbc06407874bee55a6ea0f6f2fbee35bbf70f" translate="yes" xml:space="preserve">
          <source>The code to be parsed comes from &lt;code&gt;line&lt;/code&gt; and &lt;code&gt;rsfp&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt;, if non-null, provides a string (in SV form) containing code to be parsed. A copy of the string is made, so subsequent modification of &lt;code&gt;line&lt;/code&gt; does not affect parsing. &lt;code&gt;rsfp&lt;/code&gt;, if non-null, provides an input stream from which code will be read to be parsed. If both are non-null, the code in &lt;code&gt;line&lt;/code&gt; comes first and must consist of complete lines of input, and &lt;code&gt;rsfp&lt;/code&gt; supplies the remainder of the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471ec4c1f979a5d05323a39069daf19923ca3333" translate="yes" xml:space="preserve">
          <source>The code to run inside the subtest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">Код:</target>
        </trans-unit>
        <trans-unit id="eeae5d7673ad77a6f3fce469e318a0a0bf4653ce" translate="yes" xml:space="preserve">
          <source>The codebase is a mixture of tabs and spaces for indentation, and we are moving to spaces only. Converting lines you're patching from 8-wide tabs to spaces will help this migration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4c60f240f194fdb0d0584f5890bfd1f9a58985" translate="yes" xml:space="preserve">
          <source>The coderef you provide is returned and can be used to remove the hook later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bd0609e5f4f6c76dfb80ec0b3769b0a1ce5867" translate="yes" xml:space="preserve">
          <source>The codes generated by this module are standard terminal control codes, complying with ECMA-048 and ISO 6429 (generally referred to as &quot;ANSI color&quot; for the color codes). The non-color control codes (bold, dark, italic, underline, and reverse) are part of the earlier ANSI X3.64 standard for control sequences for video terminals and peripherals.</source>
          <target state="translated">Коды,генерируемые этим модулем,являются стандартными кодами управления терминалом,соответствующими ECMA-048 и ISO 6429 (обычно называемыми &quot;ANSI color&quot; для цветовых кодов).Нецветные коды управления (жирный,темный,курсив,подчеркивание и реверс)являются частью более раннего стандарта ANSI X3.64 для управляющих последовательностей для видеотерминалов и периферийных устройств.</target>
        </trans-unit>
        <trans-unit id="6fab56ccb009185913550effa31ed3b9edd378e9" translate="yes" xml:space="preserve">
          <source>The codesets currently supported are:</source>
          <target state="translated">В настоящее время поддерживаются кодеры:</target>
        </trans-unit>
        <trans-unit id="71e94bac38239334b6900c0a017267aa1a8ae397" translate="yes" xml:space="preserve">
          <source>The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch and cotanh/coth are aliases)</source>
          <target state="translated">Софункции гиперболического синуса,косинуса и тангенса (косех/ши и котан/зуб-псевдонимы)</target>
        </trans-unit>
        <trans-unit id="28a5561373d2289312316102a3c2581ebe7698d3" translate="yes" xml:space="preserve">
          <source>The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot are aliases)</source>
          <target state="translated">Софункции синуса,косинуса и касательной (cosec/cc и cotan/cot-псевдонимы).</target>
        </trans-unit>
        <trans-unit id="e024e4f61b24aaae2c3c812d1f87a03e707d97c4" translate="yes" xml:space="preserve">
          <source>The collation sequence can be any set of unique characters. These two cases are equivalent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1e9fabea4570a18aadb2a0be8b117d7c1d1876" translate="yes" xml:space="preserve">
          <source>The collective set of &lt;b&gt;environment variables&lt;/b&gt; your &lt;b&gt;process&lt;/b&gt; inherits from its parent. Accessed via &lt;code&gt;%ENV&lt;/code&gt; .</source>
          <target state="translated">Коллективный набор &lt;b&gt;переменных среды, которые&lt;/b&gt; ваш &lt;b&gt;процесс&lt;/b&gt; наследует от своего родителя. Доступ через &lt;code&gt;%ENV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8146e94413ec1f316b7c3977a5863b7a90080ad4" translate="yes" xml:space="preserve">
          <source>The collective set of &lt;b&gt;environment variables&lt;/b&gt; your &lt;b&gt;process&lt;/b&gt; inherits from its parent. Accessed via &lt;code&gt;%ENV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54dbe0de410d1fee14f151bad669e4e7f64514b7" translate="yes" xml:space="preserve">
          <source>The color function doesn't work unless &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is compatible with your terminal.</source>
          <target state="translated">Функция цвета не работает, если &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; не совместим с вашим терминалом.</target>
        </trans-unit>
        <trans-unit id="69123f14b307a724c7d2b32425d73c9819412a9e" translate="yes" xml:space="preserve">
          <source>The color function doesn't work unless &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; is compatible with your terminal. Additionally, &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; must be installed on windows platforms for color output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d494da03d1029e001559e320101aec67b6081a14" translate="yes" xml:space="preserve">
          <source>The color stack, including the &lt;code&gt;:pushpop&lt;/code&gt; import tag, PUSHCOLOR, POPCOLOR, LOCALCOLOR, and the $Term::ANSIColor::AUTOLOCAL variable, was added in Term::ANSIColor 2.00, included in Perl 5.10.1.</source>
          <target state="translated">Цветовой стек, включая &lt;code&gt;:pushpop&lt;/code&gt; импорта : pushpop , PUSHCOLOR, POPCOLOR, LOCALCOLOR и переменную $ Term :: ANSIColor :: AUTOLOCAL, был добавлен в Term :: ANSIColor 2.00, включенный в Perl 5.10.1.</target>
        </trans-unit>
        <trans-unit id="99f186121577072655b8ffd874560fdf2ec9538e" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76, unless &lt;b&gt;-t&lt;/b&gt; is given, in which case it's two columns less than the width of your terminal device.</source>
          <target state="translated">Столбец для переноса текста в правой части. По умолчанию 76, если не указано &lt;b&gt;-t&lt;/b&gt; , и в этом случае это на два столбца меньше ширины вашего оконечного устройства.</target>
        </trans-unit>
        <trans-unit id="dc0da64614756f754ff954c33b5269fabc02fce0" translate="yes" xml:space="preserve">
          <source>The column at which to wrap text on the right-hand side. Defaults to 76.</source>
          <target state="translated">Столбец,в который следует обернуть текст справа.По умолчанию 76.</target>
        </trans-unit>
        <trans-unit id="e8623930908f634360f3d6d3225f352295877e28" translate="yes" xml:space="preserve">
          <source>The combination of &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; allows us to process the string a bit at a time and use arbitrary Perl logic to decide what to do next. Currently, the &lt;code&gt;\G&lt;/code&gt; anchor is only fully supported when used to anchor to the start of the pattern.</source>
          <target state="translated">Комбинация &lt;code&gt;//g&lt;/code&gt; и &lt;code&gt;\G&lt;/code&gt; позволяет нам обрабатывать строку понемногу и использовать произвольную логику Perl, чтобы решить, что делать дальше. В настоящее время привязка &lt;code&gt;\G&lt;/code&gt; полностью поддерживается только тогда, когда она используется для привязки к началу шаблона.</target>
        </trans-unit>
        <trans-unit id="7ee0a722061e99b2e3ae6619dfca4f00fe8cf72e" translate="yes" xml:space="preserve">
          <source>The combination of &lt;code&gt;/g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; allows us to process the string a bit at a time and use arbitrary Perl logic to decide what to do next. Currently, the &lt;code&gt;\G&lt;/code&gt; anchor is only fully supported when used to anchor to the start of the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970e7f15d0c6ab9e35629ba58fe853786b66b02c" translate="yes" xml:space="preserve">
          <source>The combination of multiple command- line switches (</source>
          <target state="translated">Комбинация из нескольких переключателей командной строки (</target>
        </trans-unit>
        <trans-unit id="e655e997e08648320978a6ff86ae273d24047f81" translate="yes" xml:space="preserve">
          <source>The combined effect of 3 &amp;amp; 4 is that it will allow code which uses the &lt;code&gt;warnings&lt;/code&gt; pragma to control the warning behavior of $^W-type code (using a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; ) if it really wants to, but not vice-versa.</source>
          <target state="translated">Комбинированный эффект 3 и 4 заключается в том, что он позволяет коду, который использует прагму &lt;code&gt;warnings&lt;/code&gt; управлять поведением предупреждений кода типа $ ^ W (с использованием &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $^W=0&lt;/code&gt; ), если он действительно этого хочет, но не наоборот. наоборот.</target>
        </trans-unit>
        <trans-unit id="e3995e1eb61da1d6a07b530102c1f24daec8bae4" translate="yes" xml:space="preserve">
          <source>The combined effect of 3 &amp;amp; 4 is that it will allow code which uses the &lt;code&gt;warnings&lt;/code&gt; pragma to control the warning behavior of $^W-type code (using a &lt;code&gt;local $^W=0&lt;/code&gt;) if it really wants to, but not vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5195e2f756a78470c45dda1ae8fbd38d00cbe08" translate="yes" xml:space="preserve">
          <source>The command &quot;=for</source>
          <target state="translated">Команда &quot;=для</target>
        </trans-unit>
        <trans-unit id="3786e2d525dc34959fb151cbab27e80aefbcfac1" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git clean&lt;/code&gt; can with varying arguments be used as a replacement for &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8aeb4458c1560b0d5ab2e46d755733e3bb6324" translate="yes" xml:space="preserve">
          <source>The command does not start.</source>
          <target state="translated">Команда не запускается.</target>
        </trans-unit>
        <trans-unit id="7e6f4f93a21a7f88a65ff2221b6911802d75f842" translate="yes" xml:space="preserve">
          <source>The command is killed by a signal.</source>
          <target state="translated">Команда уничтожена сигналом.</target>
        </trans-unit>
        <trans-unit id="914be5b158c3cc5be779f3d3fed5d23185a3c4a4" translate="yes" xml:space="preserve">
          <source>The command line interface is tightly integrated with an &lt;b&gt;emacs&lt;/b&gt; extension and there's a &lt;b&gt;vi&lt;/b&gt; interface too.</source>
          <target state="translated">Интерфейс командной строки тесно интегрирован с расширением &lt;b&gt;emacs, также&lt;/b&gt; есть интерфейс &lt;b&gt;vi&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f789ad4d35bca82f26a9236e86bce7a57e057b98" translate="yes" xml:space="preserve">
          <source>The command line is not split by GetOptions, but by the command line interpreter (CLI). On Unix, this is the shell. On Windows, it is COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.</source>
          <target state="translated">Командная строка разделена не GetOptions,а интерпретатором командной строки (CLI).В Unix это оболочка.В Windows это COMMAND.COM или CMD.EXE.В других операционных системах есть и другие CLI.</target>
        </trans-unit>
        <trans-unit id="a12dc653b968ec55d9bfea4484d747acafd8c027" translate="yes" xml:space="preserve">
          <source>The command returns a non-zero exit value (but see below).</source>
          <target state="translated">Команда возвращает ненулевое значение выхода (но см.ниже).</target>
        </trans-unit>
        <trans-unit id="4a884c5530c697acec58e6764eb13db7fac15f02" translate="yes" xml:space="preserve">
          <source>The command to run is built as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf7fbf7b3dd60fe57ca23a7e47b3c4eeb05e932" translate="yes" xml:space="preserve">
          <source>The command used to load the debugger code. The default is:</source>
          <target state="translated">Команда,используемая для загрузки кода отладчика.По умолчанию:</target>
        </trans-unit>
        <trans-unit id="35175a977556088d11ca4a7b0e7332f1ce787324" translate="yes" xml:space="preserve">
          <source>The command's STDOUT and STDERR (and possibly STDIN, depending on your shell) will be the same as the parent's. You won't need to catch SIGCHLD because of the double-fork taking place; see below for details.</source>
          <target state="translated">Команды STDOUT и STDERR (и,возможно,STDIN,в зависимости от вашей оболочки)будут такими же,как и у родителя.Вам не нужно будет ловить SIGCHLD из-за того,что происходит двойная вилка;подробности смотрите ниже.</target>
        </trans-unit>
        <trans-unit id="75337684a9346d140506f8cf5d632c3a6fe46276" translate="yes" xml:space="preserve">
          <source>The command-line mentioned in the SYNOPSIS section corresponds to the Perl code</source>
          <target state="translated">Командная строка,упомянутая в разделе SYNOPSIS,соответствует коду Perl</target>
        </trans-unit>
        <trans-unit id="ea72136c38b086284678c74c52f83815bf874db4" translate="yes" xml:space="preserve">
          <source>The commands &lt;code&gt;=pod&lt;/code&gt; and &lt;code&gt;=cut&lt;/code&gt; do not take any arguments.</source>
          <target state="translated">Команды &lt;code&gt;=pod&lt;/code&gt; и &lt;code&gt;=cut&lt;/code&gt; не принимают никаких аргументов.</target>
        </trans-unit>
        <trans-unit id="f1e3cdc1d66a6ddbc94785be80a34d0a817fb94d" translate="yes" xml:space="preserve">
          <source>The commands available in the shell interface are methods in the package CPAN::Shell. If you enter the shell command, your input is split by the Text::ParseWords::shellwords() routine, which acts like most shells do. The first word is interpreted as the method to be invoked, and the rest of the words are treated as the method's arguments. Continuation lines are supported by ending a line with a literal backslash.</source>
          <target state="translated">Команды,доступные в интерфейсе оболочки,являются методами из пакета CPAN::Shell.Если вы вводите команду оболочки,ваш ввод разделен рутиной Text::ParseWords::shellwords(),которая действует,как большинство оболочек.Первое слово интерпретируется как метод для вызова,а остальные слова рассматриваются как аргументы метода.Строки продолжения поддерживаются завершением строки буквенным обратным слешем.</target>
        </trans-unit>
        <trans-unit id="50c172c64b8304a2667bbd4145cf67a46b69892f" translate="yes" xml:space="preserve">
          <source>The commit message should include a description of the problem that the patch corrects or new functionality that the patch adds.</source>
          <target state="translated">Сообщение о фиксации должно содержать описание проблемы,которую исправляет патч,или новой функциональности,которую добавляет патч.</target>
        </trans-unit>
        <trans-unit id="a48a6b9a39f2c1e8f05ac68afbc7708f295daa69" translate="yes" xml:space="preserve">
          <source>The common (and original) usage of B::Concise was for command-line renderings of simple code, as given in EXAMPLE. But you can also use &lt;b&gt;B::Concise&lt;/b&gt; from your code, and call compile() directly, and repeatedly. By doing so, you can avoid the compile-time only operation of O.pm, and even use the debugger to step through B::Concise::compile() itself.</source>
          <target state="translated">Обычно (и исходно) B :: Concise использовался для рендеринга простого кода из командной строки, как указано в ПРИМЕРЕ. Но вы также можете использовать &lt;b&gt;B :: Concise&lt;/b&gt; из своего кода и вызывать compile () напрямую и многократно. Поступая так, вы можете избежать операции O.pm только во время компиляции и даже использовать отладчик для пошагового выполнения самой B :: Concise :: compile ().</target>
        </trans-unit>
        <trans-unit id="092b88432af421400f5d15e398af7e25459b6caf" translate="yes" xml:space="preserve">
          <source>The comparison function is required to behave. If it returns inconsistent results (sometimes saying &lt;code&gt;$x[1]&lt;/code&gt; is less than &lt;code&gt;$x[2]&lt;/code&gt; and sometimes saying the opposite, for example) the results are not well-defined.</source>
          <target state="translated">Функция сравнения должна работать. Если он возвращает противоречивые результаты (иногда говорят, что &lt;code&gt;$x[1]&lt;/code&gt; меньше, чем &lt;code&gt;$x[2]&lt;/code&gt; а иногда, например, говорят обратное), результаты не являются четко определенными.</target>
        </trans-unit>
        <trans-unit id="edfa309c58fb1bf1eba2e1c0e1a54aa1aefcb60b" translate="yes" xml:space="preserve">
          <source>The compilation of a subroutine can be affected by a few compiler directives, &lt;b&gt;pragmas&lt;/b&gt;. These are:</source>
          <target state="translated">На компиляцию подпрограммы могут влиять несколько директив компилятора, &lt;b&gt;прагм&lt;/b&gt; . Эти:</target>
        </trans-unit>
        <trans-unit id="ecde94171862ef8b275c6d67c44a792fcd8d5efd" translate="yes" xml:space="preserve">
          <source>The compile tree is executed in a runops function. There are two runops functions, in</source>
          <target state="translated">Дерево компиляции выполняется в функции runops.Существует две функции рун,в</target>
        </trans-unit>
        <trans-unit id="79a77bf1e2569d28ea6eda34147b4768d49e28ad" translate="yes" xml:space="preserve">
          <source>The compiler will search for typemap files called</source>
          <target state="translated">Компилятор будет искать файлы типовых карт с именами</target>
        </trans-unit>
        <trans-unit id="111471390604961ec6523ced1b372373b53d8003" translate="yes" xml:space="preserve">
          <source>The compiler would immediately flag that as an error</source>
          <target state="translated">Компилятор сразу же поставит флаг,что в качестве ошибки</target>
        </trans-unit>
        <trans-unit id="89f4eed42cf9fec88c7f54948d286e3b27120ba8" translate="yes" xml:space="preserve">
          <source>The complementary error function [C99].</source>
          <target state="translated">Функция дополнительной ошибки [C99].</target>
        </trans-unit>
        <trans-unit id="685be68b0319918e48d33648874bae1d830f5b52" translate="yes" xml:space="preserve">
          <source>The complete Perl documentation is available with the Perl distribution. If you have Perl installed locally, you probably have the documentation installed as well: type &lt;code&gt;perldoc perl&lt;/code&gt; in a terminal or &lt;a href=&quot;http://perldoc.perl.org/perl.html&quot;&gt;view online&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6f778f02ef1fa177aa048ce5ee5aeaef666a7f" translate="yes" xml:space="preserve">
          <source>The complete Perl documentation is available with the Perl distribution. If you have Perl installed locally, you probably have the documentation installed as well: type &lt;code&gt;perldoc perl&lt;/code&gt; in a terminal or &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;view online&lt;/a&gt;.</source>
          <target state="translated">Полная документация Perl доступна в дистрибутиве Perl. Если у вас установлен Perl локально, возможно, у вас также установлена ​​документация: введите &lt;code&gt;perldoc perl&lt;/code&gt; в терминале или &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fperldoc.perl.org%2fperl.html&quot;&gt;просмотрите в Интернете&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57baa9f3a7f45d5b826ba3f575ba401b008d6f75" translate="yes" xml:space="preserve">
          <source>The complete Perl documentation is available with the Perl distribution. If you have Perl installed locally, you probably have the documentation installed as well: type &lt;code&gt;perldoc perl&lt;/code&gt; in a terminal or &lt;a href=&quot;https://perldoc.perl.org/perl.html&quot;&gt;view online&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068df1cb71064dd3af102dcffe784783c3c8d76f" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is compressed.</source>
          <target state="translated">Полный массив будет обходить,чтобы убедиться,что он содержит только действительные имена файлов,прежде чем любые данные будут сжаты.</target>
        </trans-unit>
        <trans-unit id="3bc7e120c73e8eddc193ee78a2c4c1f364b17641" translate="yes" xml:space="preserve">
          <source>The complete array will be walked to ensure that it only contains valid filenames before any data is uncompressed.</source>
          <target state="translated">Полный массив будет обходить,чтобы убедиться,что он содержит только действительные имена файлов,прежде чем любые данные будут распакованы.</target>
        </trans-unit>
        <trans-unit id="98b6ca723bf0fecfbf2258563e5ac721bc8076d0" translate="yes" xml:space="preserve">
          <source>The complete list of keys that can be specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are given, separated by spaces, in the values of the hash &lt;code&gt;%overload::ops&lt;/code&gt; :</source>
          <target state="translated">Полный список ключей, которые могут быть указаны в директиве &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , дается через пробел в значениях хэша &lt;code&gt;%overload::ops&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39b8357b2b8bda435df838b871e13a6e868a463b" translate="yes" xml:space="preserve">
          <source>The complete list of keys that can be specified in the &lt;code&gt;use overload&lt;/code&gt; directive are given, separated by spaces, in the values of the hash &lt;code&gt;%overload::ops&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c281d1dec7eebd9b6bf4d9cf26bf4311a392cc" translate="yes" xml:space="preserve">
          <source>The complete table can be found in the Sun Managers' FAQ &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&lt;/a&gt; under &quot;9.1) Which Sun models run which versions of SunOS?&quot;.</source>
          <target state="translated">Полную таблицу можно найти в FAQ менеджеров Sun &lt;a href=&quot;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq&quot;&gt;ftp://ftp.cs.toronto.edu/pub/jdd/sunmanagers/faq в&lt;/a&gt; разделе &amp;laquo;9.1) Какие модели Sun работают с какими версиями SunOS?&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="243520c31a219c7d1aad4ef85de5d88764701e20" translate="yes" xml:space="preserve">
          <source>The completion character &amp;lt;tab&amp;gt; cannot be changed.</source>
          <target state="translated">Знак завершения &amp;lt;tab&amp;gt; нельзя изменить.</target>
        </trans-unit>
        <trans-unit id="23ff44fc7bcd5bb4196b4eabff893cd96c4f3b50" translate="yes" xml:space="preserve">
          <source>The complexity of the language you're trying to output a phrase in is entirely abstracted inside (and encapsulated within) the Maketext module for that interface. When you call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17b9f988fe18d77702fa8f938bb3b8ecfcbaea7a" translate="yes" xml:space="preserve">
          <source>The complicated syntaxes of this code are discussed at length in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;&quot;Formatting Codes&quot; in perlpod&lt;/a&gt;, and implementation details are discussed below, in &lt;a href=&quot;#About-L-Codes&quot;&gt;&quot;About L&amp;lt;...&amp;gt; Codes&quot;&lt;/a&gt;. Parsing the contents of L&amp;lt;content&amp;gt; is tricky. Notably, the content has to be checked for whether it looks like a URL, or whether it has to be split on literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so on,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f8fbb5c61dbf32a6295f7091431384e77ad0b9" translate="yes" xml:space="preserve">
          <source>The complicated syntaxes of this code are discussed at length in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;, and implementation details are discussed below, in &lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;About L&amp;lt;...&amp;gt; Codes&lt;/a&gt;. Parsing the contents of L&amp;lt;content&amp;gt; is tricky. Notably, the content has to be checked for whether it looks like a URL, or whether it has to be split on literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so on,</source>
          <target state="translated">Сложный синтаксис этого кода подробно обсуждается в &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;разделе &amp;laquo;Коды форматирования в perlpod&amp;raquo;&lt;/a&gt; , а подробности реализации обсуждаются ниже в разделе &amp;laquo; &lt;a href=&quot;#About-L%3c...%3e-Codes&quot;&gt;О кодах L &amp;lt;...&amp;gt;&amp;raquo;&lt;/a&gt; . Разбирать содержимое L &amp;lt;content&amp;gt; сложно. Примечательно, что содержимое должно быть проверено на предмет того, выглядит ли оно как URL-адрес или его нужно разделить на буквальный символ &quot;|&quot; и / или &quot;/&quot; (в правильном порядке!) и т. д.,</target>
        </trans-unit>
        <trans-unit id="3e080e954af33f166a94bcfa488743e85b7e060c" translate="yes" xml:space="preserve">
          <source>The compound way of writing these is like &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (short: &lt;code&gt;\p{gc:n}&lt;/code&gt; ). But Perl furnishes shortcuts in which everything up through the equal or colon separator is omitted. So you can instead just write &lt;code&gt;\pN&lt;/code&gt; .</source>
          <target state="translated">Составной способ их записи выглядит как &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (сокращенно: &lt;code&gt;\p{gc:n}&lt;/code&gt; ). Но Perl предоставляет сокращения, в которых опускается все, что до разделителя равно или двоеточия. Вместо этого вы можете просто написать &lt;code&gt;\pN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f504fa5a5306a0e609df2f9c35729a9aad217004" translate="yes" xml:space="preserve">
          <source>The compound way of writing these is like &lt;code&gt;\p{General_Category=Number}&lt;/code&gt; (short: &lt;code&gt;\p{gc:n}&lt;/code&gt;). But Perl furnishes shortcuts in which everything up through the equal or colon separator is omitted. So you can instead just write &lt;code&gt;\pN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4be8f3e8beb322b0e55f10e2929087827e8f380" translate="yes" xml:space="preserve">
          <source>The computer on which a program or other data resides.</source>
          <target state="translated">Компьютер,на котором находится программа или другие данные.</target>
        </trans-unit>
        <trans-unit id="cfcbad8d7cd3118bc2c84750149f972c9d76bac3" translate="yes" xml:space="preserve">
          <source>The concatenation operator is &quot;.&quot;, not the null string. (Using the null string would render &lt;code&gt;/pat/ /pat/&lt;/code&gt; unparsable, because the third slash would be interpreted as a division operator--the tokenizer is in fact slightly context sensitive for operators like &quot;/&quot;, &quot;?&quot;, and &quot;&amp;gt;&quot;. And in fact, &quot;.&quot; itself can be the beginning of a number.)</source>
          <target state="translated">Оператор конкатенации - &amp;laquo;.&amp;raquo;, А не пустая строка. (Использование нулевой строки сделает &lt;code&gt;/pat/ /pat/&lt;/code&gt; неразборчивым, потому что третья косая черта будет интерпретироваться как оператор деления - токенизатор на самом деле немного контекстно-зависимый для таких операторов, как &amp;laquo;/&amp;raquo;, &amp;laquo;?&amp;raquo; И &amp;laquo;&amp;gt; &quot;. И на самом деле&quot;. &quot;Может быть началом числа.)</target>
        </trans-unit>
        <trans-unit id="7397c296c9007588d87f382f9ceff5394823ef48" translate="yes" xml:space="preserve">
          <source>The concise style uses symbols to convey maximum info with minimal clutter (like hex addresses). With just a little practice, you can start to see the flowers, not just the branches, in the trees.</source>
          <target state="translated">Краткий стиль использует символы для передачи максимальной информации с минимальным нагромождением (например,шестнадцатеричные адреса).С помощью небольшой практики вы можете начать видеть цветы,а не только ветви,на деревьях.</target>
        </trans-unit>
        <trans-unit id="d9749679dc3561ae81ba863d8e80238321089767" translate="yes" xml:space="preserve">
          <source>The concrete formatter must implement</source>
          <target state="translated">Конкретное формообразующее средство должно реализовывать</target>
        </trans-unit>
        <trans-unit id="ff1705816e805e2b10cae23ac0d85181e713e425" translate="yes" xml:space="preserve">
          <source>The condition expression of a &lt;code&gt;for&lt;/code&gt; loop gets the same magic treatment of &lt;code&gt;readline&lt;/code&gt; et al that the condition expression of a &lt;code&gt;while&lt;/code&gt; loop gets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6253a94addb83f76f25a71c4752860278fa23c" translate="yes" xml:space="preserve">
          <source>The conditions can be any Perl expression. See the list of operators in the next section for information on comparison and boolean logic operators, which are commonly used in conditional statements.</source>
          <target state="translated">Условиями могут быть любые выражения на Perl.Информацию о сравнительных и булевых логических операторах,которые обычно используются в условных операторах,смотрите в списке операторов в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="660b170e644dc462db23e032c8de8f3cadb36f87" translate="yes" xml:space="preserve">
          <source>The conduit through which all events flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543b88d3ab70df9ad92d2d1112ca25224746b1f5" translate="yes" xml:space="preserve">
          <source>The configuration data is held globally in a file in the perl installation tree, but a user may override any of these values by providing their own. This can be done by having a &lt;code&gt;.libnetrc&lt;/code&gt; file in their home directory. This file should return a reference to a HASH containing the keys described below. For example</source>
          <target state="translated">Данные конфигурации хранятся глобально в файле в дереве установки Perl, но пользователь может переопределить любое из этих значений, указав свое собственное. Это можно сделать, имея файл &lt;code&gt;.libnetrc&lt;/code&gt; в их домашнем каталоге. Этот файл должен возвращать ссылку на HASH, содержащий ключи, описанные ниже. Например</target>
        </trans-unit>
        <trans-unit id="9a78f97fbb5cf4075595c0b03128bde7af0266c1" translate="yes" xml:space="preserve">
          <source>The configuration dialog can be started any time later again by issuing the command &lt;code&gt; o conf init &lt;/code&gt; in the CPAN shell. A subset of the configuration dialog can be run by issuing &lt;code&gt;o conf init WORD&lt;/code&gt; where WORD is any valid config variable or a regular expression.</source>
          <target state="translated">Диалог конфигурации можно снова запустить в любое время позже, введя команду &lt;code&gt; o conf init &lt;/code&gt; в оболочке CPAN. Подмножество диалогового окна конфигурации можно запустить, &lt;code&gt;o conf init WORD&lt;/code&gt; команду o conf init WORD, где WORD - любая допустимая переменная конфигурации или регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="b4c7562be2672acce7fe43e87808c7f47379f387" translate="yes" xml:space="preserve">
          <source>The configuration parameter check_sigs is there to turn signature checking on or off.</source>
          <target state="translated">В конфигурационном параметре check_sigs предусмотрена возможность включения или выключения проверки сигнатур.</target>
        </trans-unit>
        <trans-unit id="e8f4fc6abff769c701a3cd104bd7d5e13a65f76f" translate="yes" xml:space="preserve">
          <source>The configure phase occurs before any dynamic configuration has been attempted. Libraries required by the configure phase &lt;b&gt;must&lt;/b&gt; be available for use before the distribution building tool has been executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb35472fba52fde6c0d287b9880009008ce62bd4" translate="yes" xml:space="preserve">
          <source>The conformance test for the UCA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e8c71c043d1ee5895cf5c5a239168a7f0a8975" translate="yes" xml:space="preserve">
          <source>The confusion arises because people incorrectly assume that the sigil denotes the variable type.</source>
          <target state="translated">Путаница возникает из-за того,что люди ошибочно полагают,что знак обозначает тип переменной.</target>
        </trans-unit>
        <trans-unit id="72def2ab61e0c7e7dccd965b3f9393136d20aa03" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;pi&lt;/code&gt; and some handy multiples of it (pi2, pi4, and pip2 (pi/2) and pip4 (pi/4)) are also available if separately exported:</source>
          <target state="translated">Константа &lt;code&gt;pi&lt;/code&gt; и некоторые удобные кратные ей (pi2, pi4 и pip2 (pi / 2) и pip4 (pi / 4)) также доступны при отдельном экспорте:</target>
        </trans-unit>
        <trans-unit id="c81821f9e03375c52f91dde5667119328458dcfd" translate="yes" xml:space="preserve">
          <source>The constant function &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; returns a comparable number that represents the highest file version number that this version of Storable fully supports (but see discussion of &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; above). The constant &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; function returns what file version is written and might be less than &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; in some configurations.</source>
          <target state="translated">Постоянная функция &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; возвращает сопоставимое число, которое представляет наивысший номер версии файла, который полностью поддерживает эта версия Storable (но см. Обсуждение &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; выше). Постоянная &lt;code&gt;Storable::BIN_WRITE_VERSION_NV&lt;/code&gt; возвращает версию записанного файла и может быть меньше, чем &lt;code&gt;Storable::BIN_VERSION_NV&lt;/code&gt; в некоторых конфигурациях.</target>
        </trans-unit>
        <trans-unit id="1404d0959d5fe2f0dd1fe9c942e64fc147050eb7" translate="yes" xml:space="preserve">
          <source>The constants for specific &lt;code&gt;code&lt;/code&gt; values can be imported individually or using the &lt;code&gt;:signal_h_si_code&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9018d00ba0cf85500f9049cabc293077c6a815d2" translate="yes" xml:space="preserve">
          <source>The construct</source>
          <target state="translated">Конструкция</target>
        </trans-unit>
        <trans-unit id="8226460345430ec3df47c2bd35c2d238766995a6" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt; , and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt; .</source>
          <target state="translated">Конструкция &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; используемая в приведенном выше примере, имеет &lt;b&gt;двоякое&lt;/b&gt; назначение: во-первых, когда эта строка обрабатывается &lt;b&gt;xsubpp&lt;/b&gt; , фрагмент Perl &lt;code&gt;$v{timep}=$arg&lt;/code&gt; вычисляется $ arg . Во-вторых, текст оцененного фрагмента выводится в сгенерированный файл C (внутри комментария C)! Во время обработки строки &lt;code&gt;char *host&lt;/code&gt; &lt;code&gt;$arg&lt;/code&gt; будет оценивать как &lt;code&gt;ST(0)&lt;/code&gt; , а &lt;code&gt;$v{timep}&lt;/code&gt; будет оценивать как &lt;code&gt;ST(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2f29b3b2c632054cc482de2585e44d1631920b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;\$v{timep}=@{[$v{timep}=$arg]}&lt;/code&gt; used in the above example has a two-fold purpose: first, when this line is processed by &lt;b&gt;xsubpp&lt;/b&gt;, the Perl snippet &lt;code&gt;$v{timep}=$arg&lt;/code&gt; is evaluated. Second, the text of the evaluated snippet is output into the generated C file (inside a C comment)! During the processing of &lt;code&gt;char *host&lt;/code&gt; line, &lt;code&gt;$arg&lt;/code&gt; will evaluate to &lt;code&gt;ST(0)&lt;/code&gt;, and &lt;code&gt;$v{timep}&lt;/code&gt; will evaluate to &lt;code&gt;ST(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59007854896f819ee065a798da86e7867bce96e" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; object.</source>
          <target state="translated">Конструктор &lt;code&gt;new&lt;/code&gt; создает и возвращает пустой объект &lt;code&gt;TAP::Parser::YAMLish::Reader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bad8668cdf1d431ad701326f6748ece18b79658" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;new&lt;/code&gt; creates and returns an empty &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; object.</source>
          <target state="translated">Конструктор &lt;code&gt;new&lt;/code&gt; создает и возвращает пустой объект &lt;code&gt;TAP::Parser::YAMLish::Writer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2fcf35a44aabf097cd59f3a3854953c70e5fcd" translate="yes" xml:space="preserve">
          <source>The constructor can also accept additional parameters that define the object. Let's write a real constructor for the &lt;code&gt;File&lt;/code&gt; class we used earlier:</source>
          <target state="translated">Конструктор также может принимать дополнительные параметры, определяющие объект. Напишем реальный конструктор для класса &lt;code&gt;File&lt;/code&gt; ,который мы использовали ранее:</target>
        </trans-unit>
        <trans-unit id="3a88176407788666ff0021721dd4e56b3400cf3f" translate="yes" xml:space="preserve">
          <source>The constructor creates a new object and optionally initialises it with a set of handles.</source>
          <target state="translated">Конструктор создает новый объект и опционально инициализирует его набором дескрипторов.</target>
        </trans-unit>
        <trans-unit id="26002f2b8ad63b7adc28307355437aa48afa5d7b" translate="yes" xml:space="preserve">
          <source>The constructor for a &lt;code&gt;Net::Netrc&lt;/code&gt; object is not called new as it does not really create a new object. But instead is called &lt;code&gt;lookup&lt;/code&gt; as this is essentially what it does.</source>
          <target state="translated">Конструктор для объекта &lt;code&gt;Net::Netrc&lt;/code&gt; не называется новым, поскольку на самом деле он не создает новый объект. Но вместо этого это называется &lt;code&gt;lookup&lt;/code&gt; как это по сути то, что он делает.</target>
        </trans-unit>
        <trans-unit id="5e4047980f5ac3eb3127d3d68b5f254e9299a0fd" translate="yes" xml:space="preserve">
          <source>The constructor for all the singletons used to represent modules, distributions, authors, and bundles. If the object already exists, this method returns the object; otherwise, it calls the constructor.</source>
          <target state="translated">Конструктор для всех синглонов,используемых для представления модулей,дистрибутивов,авторов и связок.Если объект уже существует,то этот метод возвращает объект;в противном случае он вызывает конструктор.</target>
        </trans-unit>
        <trans-unit id="392e17e9526fa6867e8438f1a219ca39e5568acc" translate="yes" xml:space="preserve">
          <source>The constructor must be passed a metadata structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54cf785d15de998f3ac18ade864f218319b1ee1" translate="yes" xml:space="preserve">
          <source>The constructor of a generated class can be passed a list of</source>
          <target state="translated">Конструктору сгенерированного класса может быть передан список</target>
        </trans-unit>
        <trans-unit id="bb7df7aab984a9c0e691c8f805de279350cf56e0" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;Digest::MD5&lt;/code&gt; object which encapsulate the state of the MD5 message-digest algorithm.</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;Digest::MD5&lt;/code&gt; который инкапсулирует состояние алгоритма дайджеста сообщения MD5.</target>
        </trans-unit>
        <trans-unit id="2e6b2441df01bfc969fd7dfde15484f966dcaf52" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; . Если &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt; не установлен, возвращает undef.</target>
        </trans-unit>
        <trans-unit id="4747d0a8e21ed88de854df16a2a22a83e805b50c" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Color&lt;/code&gt; object. If &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; is not installed, returns undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972195b07373ba2fa384173c37fb399dc7626fb1" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; object.</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Formatter::Console::Session&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64d08d3b354e3667ab5da2f82eaec44dd6d25ea5" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; . Если &lt;a href=&quot;../harness&quot;&gt;TAP :: Harness&lt;/a&gt; не создается с не &lt;code&gt;formatter&lt;/code&gt; в &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; автоматически создается. Если для TAP :: Harness-&amp;gt; new были заданы какие-либо из следующих параметров, они должны быть переданы этому конструктору, который принимает дополнительный хэш-адрес, разрешенные ключи которого:</target>
        </trans-unit>
        <trans-unit id="8909e70f1c9cdb1bc8623d8b0a2d889cffc98a88" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; object. If a &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; is created with no &lt;code&gt;formatter&lt;/code&gt; a &lt;code&gt;TAP::Formatter::Console&lt;/code&gt; is automatically created. If any of the following options were given to TAP::Harness-&amp;gt;new they well be passed to this constructor which accepts an optional hashref whose allowed keys are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf8ec5d8f9e8688b8b1e013d18928a0b5fdbbeb" translate="yes" xml:space="preserve">
          <source>The constructor returns a new &lt;code&gt;TAP::Harness&lt;/code&gt; object. It accepts an optional hashref whose allowed keys are:</source>
          <target state="translated">Конструктор возвращает новый объект &lt;code&gt;TAP::Harness&lt;/code&gt; . Он принимает необязательный хэш-адрес, разрешенные ключи которого:</target>
        </trans-unit>
        <trans-unit id="093c7ac00d4bfb4c1a8deee532d1b8ad2334e8c0" translate="yes" xml:space="preserve">
          <source>The constructor returns some object that encapsulate the state of the message-digest algorithm. You can add data to the object and finally ask for the digest. The &quot;XXX&quot; should of course be replaced by the proper name of the digest algorithm you want to use.</source>
          <target state="translated">Конструктор возвращает некоторый объект,который инкапсулирует состояние самого дайджеста сообщений.Вы можете добавить данные к объекту и,наконец,запросить дайджест.Разумеется,&quot;XXX&quot; должно быть заменено на правильное имя алгоритма дайджеста,который вы хотите использовать.</target>
        </trans-unit>
        <trans-unit id="b8c0174cc6aa4e80ad4122d0657361b0e191a979" translate="yes" xml:space="preserve">
          <source>The constructor should be passed a valid metadata structure but invalid structures are accepted. If no meta-spec version is provided, version 1.0 will be assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4929a7c6855e45789fbb16fa26a8399b54ccaf" translate="yes" xml:space="preserve">
          <source>The content from the __DATA__ block is not filtered. This is a serious limitation, e.g. for the &lt;a href=&quot;switch&quot;&gt;Switch&lt;/a&gt; module. See &lt;a href=&quot;http://search.cpan.org/perldoc?Switch#LIMITATIONS&quot;&gt;http://search.cpan.org/perldoc?Switch#LIMITATIONS&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ebdab724a22632fec3a1d054882b1bc817c7d6" translate="yes" xml:space="preserve">
          <source>The content of the here doc is treated just as it would be if the string were embedded in backticks. Thus the content is interpolated as though it were double quoted and then executed via the shell, with the results of the execution returned.</source>
          <target state="translated">Содержимое этого документа обрабатывается так же,как если бы строка была встроена в бэк-стик.Таким образом,содержимое интерполируется так,как если бы оно было заключено в двойные кавычки,а затем выполняется через оболочку,при этом возвращаются результаты выполнения.</target>
        </trans-unit>
        <trans-unit id="2c33213d12b4d00abe49d77a5bff9aee654312d3" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af50a9986dd8fc345d5bd2a482a8608eafdf212" translate="yes" xml:space="preserve">
          <source>The content of the text chunk in the buffer is commonly exactly one complete line of input, up to and including a newline terminator, but there are situations where it is otherwise. The octets of the buffer may be intended to be interpreted as either UTF-8 or Latin-1. The function &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; tells you which. Do not use the &lt;code&gt;SvUTF8&lt;/code&gt; flag on this scalar, which may disagree with it.</source>
          <target state="translated">Содержимое фрагмента текста в буфере обычно представляет собой ровно одну полную строку ввода, вплоть до символа конца строки включительно, но бывают ситуации, когда это бывает иначе. Октеты буфера могут быть интерпретированы как UTF-8 или Latin-1. Функция &lt;a href=&quot;#lex_bufutf8&quot;&gt;lex_bufutf8&lt;/a&gt; сообщает вам, какие именно. Не используйте флаг &lt;code&gt;SvUTF8&lt;/code&gt; на этом скаляре , который может с ним не согласиться.</target>
        </trans-unit>
        <trans-unit id="3c50b9c6cd39ffa60fa752e0357613216ec7e1d3" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$/&lt;/code&gt; are used to determine what constitutes a line terminator.</source>
          <target state="translated">Содержимое &lt;code&gt;$/&lt;/code&gt; используется для определения признака конца строки.</target>
        </trans-unit>
        <trans-unit id="09777bcf55808641ba4d5a5b61fa0d9ce1740b32" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;$@&lt;/code&gt; immediately after autodie triggered an exception. This may be useful when dealing with modules such as &lt;a href=&quot;Text::Balanced&quot;&gt;Text::Balanced&lt;/a&gt; that set (but do not throw) &lt;code&gt;$@&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ca5978cb2d9772e7d9f41db4210fa03ba32d12" translate="yes" xml:space="preserve">
          <source>The contents of SVs may be printed using the &lt;code&gt;SVf&lt;/code&gt; format, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d18ed7c7a8db27a58a80fd58640cc3bbfe1bce" translate="yes" xml:space="preserve">
          <source>The contents of the Comment header field, if present. If no comment is present, the value will be undef. Note this is different from a zero length comment, which will return an empty string.</source>
          <target state="translated">Содержимое поля заголовка комментария,если таковое имеется.Если комментарий отсутствует,значение будет недоступно.Обратите внимание,что это отличается от комментария нулевой длины,который вернет пустую строку.</target>
        </trans-unit>
        <trans-unit id="f67589a8aeaaf0494de7c02234d42e486e771e87" translate="yes" xml:space="preserve">
          <source>The contents of the Name header field, if present. If no name is present, the value will be undef. Note this is different from a zero length name, which will return an empty string.</source>
          <target state="translated">Содержимое поля заголовка &quot;Имя&quot;,если таковое имеется.Если имя отсутствует,значение будет недоступно.Обратите внимание,что это отличается от имени нулевой длины,которое вернет пустую строку.</target>
        </trans-unit>
        <trans-unit id="9456b1413183ce2a7cacbf69ac958ec33df9e078" translate="yes" xml:space="preserve">
          <source>The contents of the above &quot;=begin :yetanotherformat&quot; ... &quot;=end :yetanotherformat&quot; region</source>
          <target state="translated">Содержание вышеприведенного &quot;=начало :yetanotherformat&quot; ...&quot;=завершить :yetanotherformat&quot; ...</target>
        </trans-unit>
        <trans-unit id="7bdc8b3d3c8ea3698e851bea6c870ef22be74842" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; . As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="translated">Содержимое строки разделяется на аргументы с помощью вызова &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt; . Как и в случае с &lt;code&gt;GetOptionsFromArray&lt;/code&gt; , глобальный &lt;code&gt;@ARGV&lt;/code&gt; не затрагивается.</target>
        </trans-unit>
        <trans-unit id="07cf397badd80566fee8d86ba0e84ac06f7a748f" translate="yes" xml:space="preserve">
          <source>The contents of the string are split into arguments using a call to &lt;code&gt;Text::ParseWords::shellwords&lt;/code&gt;. As with &lt;code&gt;GetOptionsFromArray&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0a191734836657a10b5b7b1f37002c95e61a13" translate="yes" xml:space="preserve">
          <source>The contents of the string changes, but not the nature of the string. Perl doesn't know any more after the call than before that the contents of the string indicates the affirmative.</source>
          <target state="translated">Меняется содержимое строки,но не ее природа.Perl не знает после вызова больше,чем до того,что содержимое строки указывает на утвердительность.</target>
        </trans-unit>
        <trans-unit id="fa23695f3fe9b71ce5ed23d56ccd05be2c1e1b36" translate="yes" xml:space="preserve">
          <source>The contents should be an integer; different bits of it are used for different pragmatic flags. Here's an example:</source>
          <target state="translated">Содержимое должно быть целым числом,разные его биты используются для разных прагматических флагов.Вот пример:</target>
        </trans-unit>
        <trans-unit id="29b067c45824f7dfd004988f65509a605101a269" translate="yes" xml:space="preserve">
          <source>The context (void, scalar or list) for the return value(s) for &lt;code&gt;-&amp;gt;join()&lt;/code&gt; is determined at the time of thread creation.</source>
          <target state="translated">Контекст (void, скаляр или список) для возвращаемых значений для &lt;code&gt;-&amp;gt;join()&lt;/code&gt; определяется во время создания потока.</target>
        </trans-unit>
        <trans-unit id="2981bb07b7171fe17187abbda366aca2482181b3" translate="yes" xml:space="preserve">
          <source>The context in which the subroutine was called by autodie; usually the same as the context in which you called the autodying subroutine. This can be 'list', 'scalar', or undefined (unknown). It will never be 'void', as &lt;code&gt;autodie&lt;/code&gt; always captures the return value in one way or another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecdacee8e16379859c5cc73f585093cfac3b0ac5" translate="yes" xml:space="preserve">
          <source>The context object has API compatible implementations of the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d48ce1ec215b9e3fdc0488fca135ada53527334" translate="yes" xml:space="preserve">
          <source>The context object is the primary interface for authors of testing tools written with &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. The context object represents the context in which a test takes place (File and Line Number), and provides a quick way to generate events from that context. The context object also takes care of sending events to the correct &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafef0e58c037c46bb556fc0f1a1471183c9edb3" translate="yes" xml:space="preserve">
          <source>The context type may also be used as the</source>
          <target state="translated">Тип контекста может также использоваться в качестве</target>
        </trans-unit>
        <trans-unit id="67c74c2a8a5b26d0759477b6c197cf9395cba8a0" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does &lt;code&gt;dTHX;&lt;/code&gt; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3e46d3e11cb302e5746c299ddd22b0f06326e3" translate="yes" xml:space="preserve">
          <source>The context-free version of Perl_warner is called Perl_warner_nocontext, and does not take the extra argument. Instead it does dTHX; to get the context from thread-local storage. We &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; so that extensions get source compatibility at the expense of performance. (Passing an arg is cheaper than grabbing it from thread-local storage.)</source>
          <target state="translated">Контекстно-свободная версия Perl_warner называется Perl_warner_nocontext и не принимает дополнительный аргумент. Вместо этого он делает dTHX; чтобы получить контекст из локального хранилища потока. Мы &lt;code&gt;#define warner Perl_warner_nocontext&lt;/code&gt; , чтобы расширения получали исходную совместимость за счет производительности. (Передача аргумента дешевле, чем его получение из локального хранилища потока.)</target>
        </trans-unit>
        <trans-unit id="427dbaaec2be0f9303d86d3fada6d103291e20da" translate="yes" xml:space="preserve">
          <source>The contexts where no warnings or errors are raised are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a306525389293789c4d3b564d2695ad27f640911" translate="yes" xml:space="preserve">
          <source>The conversion from Perl to C is left as an exercise to the reader, but the prototype would be:</source>
          <target state="translated">Преобразование из Perl в C оставлено как упражнение для читателя,но прототипом будет:</target>
        </trans-unit>
        <trans-unit id="5dab7a329fdfbc3426218724b9a43e87edffc6ee" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt; . It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="translated">Конструктор копирования вызывается только перед вызовом функции, объявленной для реализации мутатора, например, if &lt;code&gt;++$b;&lt;/code&gt; в приведенном выше коде выполняется с помощью метода, объявленного для ключа &lt;code&gt;'++'&lt;/code&gt; (или 'nomethod', переданного &lt;code&gt;'++'&lt;/code&gt; в качестве четвертого аргумента), или путем автогенерации &lt;code&gt;'+='&lt;/code&gt; . Он не вызывается, если операция приращения выполняется вызовом метода для &lt;code&gt;'+'&lt;/code&gt; , поскольку в эквивалентном коде</target>
        </trans-unit>
        <trans-unit id="1a338324ec1f9edaef696d6d917c941261b8a116" translate="yes" xml:space="preserve">
          <source>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if &lt;code&gt;++$b;&lt;/code&gt; in the code above is effected via a method declared for key &lt;code&gt;'++'&lt;/code&gt; (or 'nomethod', passed &lt;code&gt;'++'&lt;/code&gt; as the fourth argument) or, by autogeneration, &lt;code&gt;'+='&lt;/code&gt;. It is not called if the increment operation is effected by a call to the method for &lt;code&gt;'+'&lt;/code&gt; since, in the equivalent code,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed73a5b2044d7fb703c52c07bf589cfde908abd5" translate="yes" xml:space="preserve">
          <source>The copy constructor is not called if Perl determines that it is unnecessary because there is no other reference to the data being modified.</source>
          <target state="translated">Конструктор копирования не вызывается,если Perl определяет,что он не нужен,так как нет другой ссылки на изменяемые данные.</target>
        </trans-unit>
        <trans-unit id="535c9ed5919c829adefa54d7a3ea16590ff263e1" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;Devel::Peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc11db58db7976be6cbb0391f46874d6c6c0bdfd" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP::Tiny&lt;/a&gt; module can fetch web resources and give their content back to you as a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd210b745dfa94e566cd092061cca3c4c3e619ac" translate="yes" xml:space="preserve">
          <source>The core &lt;a href=&quot;devel/peek&quot;&gt;Devel::Peek&lt;/a&gt; module lets us examine SVs from a Perl program. Let's see, for instance, how Perl treats the constant &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</source>
          <target state="translated">Ядро &lt;a href=&quot;devel/peek&quot;&gt;Devel :: Peek&lt;/a&gt; модуль позволяет нам исследовать из КИ программы Perl. Давайте посмотрим, например, как Perl обрабатывает константу &lt;code&gt;&quot;hello&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="216872d0879be12be32ab51a2f74dd9e0b301e2c" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;archives&lt;/a&gt; or read the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;faq&lt;/a&gt;, or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="translated">Основная группа разработчиков (известная как Perl Porters) - это группа очень альтруистических людей, приверженных созданию более качественного программного обеспечения бесплатно, чем вы могли бы надеяться купить за деньги. Вы можете следить за незавершенными разработками через &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.nntp.perl.org%2fgroup%2fperl.perl5.porters%2f&quot;&gt;архивы&lt;/a&gt; или читать &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fdev.perl.org%2fperl5%2fdocs%2fp5p-faq.html&quot;&gt;часто задаваемые вопросы&lt;/a&gt; , или вы можете подписаться на список рассылки, отправив perl5-porters-subscribe@perl.org запрос на подписку (пустое сообщение без темы - нормально).</target>
        </trans-unit>
        <trans-unit id="722caaf3f888051207be247f57e2eb71f8ea20ba" translate="yes" xml:space="preserve">
          <source>The core development team (known as the Perl Porters) are a group of highly altruistic individuals committed to producing better software for free than you could hope to purchase for money. You may snoop on pending developments via the &lt;a href=&quot;http://www.nntp.perl.org/group/perl.perl5.porters/&quot;&gt;archives&lt;/a&gt; or you can subscribe to the mailing list by sending perl5-porters-subscribe@perl.org a subscription request (an empty message with no subject is fine).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd6f3115d2d6dbe91a070c10c729356bd227008" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt; , set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt; . On a Bourne-like shell, this can be done as</source>
          <target state="translated">Базовый дистрибутив теперь может выполнять свои регрессионные тесты параллельно на Unix-подобных платформах. Вместо запуска &lt;code&gt;make test&lt;/code&gt; установите для &lt;code&gt;TEST_JOBS&lt;/code&gt; в вашей среде количество тестов, которые будут выполняться параллельно, и запустите &lt;code&gt;make test_harness&lt;/code&gt; . На оболочке типа Борна это можно сделать как</target>
        </trans-unit>
        <trans-unit id="b674b66d3912143b8c38b5c16cba55bf33d927a4" translate="yes" xml:space="preserve">
          <source>The core distribution can now run its regression tests in parallel on Unix-like platforms. Instead of running &lt;code&gt;make test&lt;/code&gt;, set &lt;code&gt;TEST_JOBS&lt;/code&gt; in your environment to the number of tests to run in parallel, and run &lt;code&gt;make test_harness&lt;/code&gt;. On a Bourne-like shell, this can be done as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cc3805e3a5e355489c3ee53c0ef93bf5066f34" translate="yes" xml:space="preserve">
          <source>The core provides a wrapper program,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e662bc8801eef788dff3d6316ec77e7ad811db79" translate="yes" xml:space="preserve">
          <source>The core uses the same testing style as the rest of Perl, a simple &quot;ok/not ok&quot; run through Test::Harness, but there are a few special considerations.</source>
          <target state="translated">Ядро использует тот же стиль тестирования,что и остальные Perl,простое &quot;ok/not ok&quot; проходит через Test::Harness,но есть несколько особых соображений.</target>
        </trans-unit>
        <trans-unit id="a3ac8ff08d630fcfeea5350e81e0c2b799df3c84" translate="yes" xml:space="preserve">
          <source>The corpse of a &lt;b&gt;process&lt;/b&gt;, in the form of a file left in the &lt;b&gt;working directory&lt;/b&gt; of the process, usually as a result of certain kinds of fatal errors.</source>
          <target state="translated">Труп &lt;b&gt;процесса&lt;/b&gt; в виде файла, оставшегося в &lt;b&gt;рабочем каталоге&lt;/b&gt; процесса, обычно в результате определенных видов фатальных ошибок.</target>
        </trans-unit>
        <trans-unit id="ad72ec528dbf7e40ea844e46e3a129f3b3eadb6f" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; .</source>
          <target state="translated">Правильный код: &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d267e23c37d16b49140100273b7c13b82e17e524" translate="yes" xml:space="preserve">
          <source>The correct code is &lt;code&gt;MAN3PODS =&amp;gt; { }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb7322d9e711d10a989215f61754b35fdcb57a5" translate="yes" xml:space="preserve">
          <source>The correct procedure, then, is to use &lt;code&gt;newRV_noinc&lt;/code&gt; instead of &lt;code&gt;newRV_inc&lt;/code&gt; . Then, if and when the last reference is destroyed, the reference count of the SV will go to zero and it will be destroyed, stopping any memory leak.</source>
          <target state="translated">Следовательно, правильная процедура - использовать &lt;code&gt;newRV_noinc&lt;/code&gt; вместо &lt;code&gt;newRV_inc&lt;/code&gt; . Затем, если и когда последняя ссылка будет уничтожена, счетчик ссылок SV станет нулевым, и он будет уничтожен, остановив любую утечку памяти.</target>
        </trans-unit>
        <trans-unit id="e90480b056b891e1197a3bfca2f65f9341469925" translate="yes" xml:space="preserve">
          <source>The correspondence between OPs and</source>
          <target state="translated">Переписка между ОП и</target>
        </trans-unit>
        <trans-unit id="3e632bae0f91b7fe9b42695b7f4eb9541547d7ab" translate="yes" xml:space="preserve">
          <source>The corresponding bright foreground color attributes (colors 8 to 15) are:</source>
          <target state="translated">Соответствующими яркими атрибутами цвета переднего плана (цвета от 8 до 15)являются:</target>
        </trans-unit>
        <trans-unit id="15d3a8f91abd0b678be46a5c74457eb9c1a22a59" translate="yes" xml:space="preserve">
          <source>The corresponding command to get the current value of &lt;code&gt;$version&lt;/code&gt; is:</source>
          <target state="translated">Соответствующая команда для получения текущего значения &lt;code&gt;$version&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05b1215b3085d02b291dbd96e47ab01de8dfb44a" translate="yes" xml:space="preserve">
          <source>The corresponding values are interpreted as regular expressions. The &lt;code&gt;distribution&lt;/code&gt; related one will be matched against the canonical distribution name, e.g. &quot;AUTHOR/Foo-Bar-3.14.tar.gz&quot;.</source>
          <target state="translated">Соответствующие значения интерпретируются как регулярные выражения. &lt;code&gt;distribution&lt;/code&gt; один связанный будет сравниваться с каноническим именем распределения, например , &amp;laquo;АВТОР / Foo-Bar-3.14.tar.gz&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="128893376b086988df0b6fe82266dcff7ded3c2c" translate="yes" xml:space="preserve">
          <source>The corresponding values are references to functions which take three arguments: the first one is the</source>
          <target state="translated">Соответствующими значениями являются ссылки на функции,которые принимают три аргумента:первый-это</target>
        </trans-unit>
        <trans-unit id="6d3c7b629f0ebabb7666a1418d689e5fcefefd4a" translate="yes" xml:space="preserve">
          <source>The count of the saved lines in the history (assuming &lt;code&gt;HistFile&lt;/code&gt; above).</source>
          <target state="translated">Количество сохраненных строк в истории (при условии, что &lt;code&gt;HistFile&lt;/code&gt; выше).</target>
        </trans-unit>
        <trans-unit id="8a76e9ed23620e2d0138b893f98a44b589dac036" translate="yes" xml:space="preserve">
          <source>The cpd tool detects cut-and-paste coding. If one instance of the cut-and-pasted code changes, all the other spots should probably be changed, too. Therefore such code should probably be turned into a subroutine or a macro.</source>
          <target state="translated">Инструмент cpd обнаруживает кодировку нарезки и вставки.Если один экземпляр прорезанного кода изменяется,то,скорее всего,должны быть изменены и все остальные места.Поэтому такой код,скорее всего,следует превратить в подпрограмму или макрос.</target>
        </trans-unit>
        <trans-unit id="3e999a3fce2098896facdee408ae939b810f6fc0" translate="yes" xml:space="preserve">
          <source>The cperl PERL_PERTURB_KEYS_TOP hash strategy has a known problem with restricted hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4315b91912980da8ee0d1d0ed73982372319566a" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt; , which is why there are no rules, only guidelines.</source>
          <target state="translated">При рассмотрении производительности важно помнить, что не существует такой вещи, как &amp;laquo; &lt;code&gt;Golden Bullet&lt;/code&gt; , поэтому здесь нет правил, а есть только рекомендации.</target>
        </trans-unit>
        <trans-unit id="fe5e8a5c2d99ce7c51902edfccff2bd041c5e28d" translate="yes" xml:space="preserve">
          <source>The critical thing when considering performance is to remember there is no such thing as a &lt;code&gt;Golden Bullet&lt;/code&gt;, which is why there are no rules, only guidelines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2f6d378553efd3b9ab7bab3a4069e081f7b24e" translate="yes" xml:space="preserve">
          <source>The crucial thing to understand about the Windows environment is that the command line you type in is processed twice before Perl sees it. First, your command shell (usually CMD.EXE) preprocesses the command line, to handle redirection, environment variable expansion, and location of the executable to run. Then, the perl executable splits the remaining command line into individual arguments, using the C runtime library upon which Perl was built.</source>
          <target state="translated">Ключевым моментом,который необходимо понять в среде Windows,является то,что командная строка,которую вы вводите,обрабатывается дважды,прежде чем Perl увидит ее.Во-первых,ваша командная оболочка (обычно CMD.EXE)препроцессирует командную строку,чтобы обрабатывать перенаправление,расширение переменных окружения и расположение исполняемого файла для выполнения.Затем исполняемый файл perl разбивает оставшуюся командную строку на отдельные аргументы,используя библиотеку времени выполнения C,на которой был собран Perl.</target>
        </trans-unit>
        <trans-unit id="1bc259f8a74780b8f0344bb67ea81414fbf6762f" translate="yes" xml:space="preserve">
          <source>The crypt package distributed with Cygwin is a Linux compatible 56-bit DES crypt port by Corinna Vinschen.</source>
          <target state="translated">Пакет крипт,распространяемый вместе с Cygwin,представляет собой 56-битный DES-порт крипта,совместимый с Linux,разработанный Коринной Виншен.</target>
        </trans-unit>
        <trans-unit id="39208a8b75f909c397f1ded48c8402dc3fb7d1f8" translate="yes" xml:space="preserve">
          <source>The crypt() function is unimplemented due to excessive paranoia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831281b1eb1b6cf65cdf498d326c123b4d2ac980" translate="yes" xml:space="preserve">
          <source>The csh_glob() function can also be exported, but you should not use it directly unless you really know what you are doing. It splits the pattern into words and feeds each one to bsd_glob(). Perl's own glob() function uses this internally.</source>
          <target state="translated">Функция csh_glob()также может быть экспортирована,но вы не должны использовать ее напрямую,если вы действительно не знаете,что делаете.Она разделяет паттерн на слова и передает каждый из них в bsd_glob().Собственная функция Perl glob()использует это внутренне.</target>
        </trans-unit>
        <trans-unit id="bb0c5fc2762311ff2f0c2ca9c51463e63c575d45" translate="yes" xml:space="preserve">
          <source>The ctime() function provides a way of getting at the scalar sense of the original CORE::localtime() function.</source>
          <target state="translated">Функция ctime()обеспечивает способ получения скалярного смысла исходной функции CORE::localtime().</target>
        </trans-unit>
        <trans-unit id="cc603efa123dedf5ee9218533c5f2218c02b0847" translate="yes" xml:space="preserve">
          <source>The cube root [C99].</source>
          <target state="translated">Кубический корень [C99].</target>
        </trans-unit>
        <trans-unit id="64bb5be49b5cecef1e72ffa347e55d8d7f71bf40" translate="yes" xml:space="preserve">
          <source>The current Unicode definition of a Word Boundary matches between every white space character. Perl tailors this, starting in version 5.24, to generally not break up spans of white space, just as plain &lt;code&gt;\b&lt;/code&gt; has always functioned. This allows &lt;code&gt;\b{wb}&lt;/code&gt; to be a drop-in replacement for &lt;code&gt;\b&lt;/code&gt;, but with generally better results for natural language processing. (The exception to this tailoring is when a span of white space is immediately followed by something like U+0303, COMBINING TILDE. If the final space character in the span is a horizontal white space, it is broken out so that it attaches instead to the combining character. To be precise, if a span of white space that ends in a horizontal space has the character immediately following it have any of the Word Boundary property values &quot;Extend&quot;, &quot;Format&quot; or &quot;ZWJ&quot;, the boundary between the final horizontal space character and the rest of the span matches &lt;code&gt;\b{wb}&lt;/code&gt;. In all other cases the boundary between two white space characters matches &lt;code&gt;\B{wb}&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64523d7c78b273edb939e95b2a44e78339d21a0e" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt; ), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="translated">Текущее имя формата хранится в переменной &lt;code&gt;$~&lt;/code&gt; ( &lt;code&gt;$FORMAT_NAME&lt;/code&gt; ), а текущее имя формата верхней части формы находится в &lt;code&gt;$^&lt;/code&gt; ( &lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt; ). Номер текущей выходной страницы хранится в &lt;code&gt;$%&lt;/code&gt; ( &lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt; ), а количество строк на странице - в &lt;code&gt;$=&lt;/code&gt; ( &lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt; ). Сохраняется ли автоматическая очистка вывода для этого дескриптора в &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt; ). Строка, выводимая перед каждой верхней частью страницы (кроме первой), сохраняется в &lt;code&gt;$^L&lt;/code&gt; ( &lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt; ). Эти переменные устанавливаются для каждого дескриптора файла, поэтому вам нужно будет выбрать () другой, чтобы повлиять на них:</target>
        </trans-unit>
        <trans-unit id="15997f5af8679b322c9a721da40c3667459ea331" translate="yes" xml:space="preserve">
          <source>The current format name is stored in the variable &lt;code&gt;$~&lt;/code&gt; (&lt;code&gt;$FORMAT_NAME&lt;/code&gt;), and the current top of form format name is in &lt;code&gt;$^&lt;/code&gt; (&lt;code&gt;$FORMAT_TOP_NAME&lt;/code&gt;). The current output page number is stored in &lt;code&gt;$%&lt;/code&gt; (&lt;code&gt;$FORMAT_PAGE_NUMBER&lt;/code&gt;), and the number of lines on the page is in &lt;code&gt;$=&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_PER_PAGE&lt;/code&gt;). Whether to autoflush output on this handle is stored in &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$OUTPUT_AUTOFLUSH&lt;/code&gt;). The string output before each top of page (except the first) is stored in &lt;code&gt;$^L&lt;/code&gt; (&lt;code&gt;$FORMAT_FORMFEED&lt;/code&gt;). These variables are set on a per-filehandle basis, so you'll need to select() into a different one to affect them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbf873260d45973f075c0f7d16575580f2c6333" translate="yes" xml:space="preserve">
          <source>The current hierarchy is:</source>
          <target state="translated">Текущая иерархия:</target>
        </trans-unit>
        <trans-unit id="824b38e0c77c472868114a17d1e97b269bb0ba11" translate="yes" xml:space="preserve">
          <source>The current implementation does not allow specification of the required version of the module.</source>
          <target state="translated">Текущая реализация не позволяет специфицировать требуемую версию модуля.</target>
        </trans-unit>
        <trans-unit id="282bec354d0f4d4b762dd47ad0eb5b6ecfd1f6ce" translate="yes" xml:space="preserve">
          <source>The current input line is normally in $_, not $0. It generally does not have the newline stripped. ($0 is the name of the program executed.) See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">Текущая строка ввода обычно находится в $ _, а не в $ 0. Обычно в нем не удаляется новая строка. ($ 0 - это имя выполняемой программы.) См. &lt;a href=&quot;perlvar&quot;&gt;Perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18f618cc025364ce800e5f345611b3c1497a1ed6" translate="yes" xml:space="preserve">
          <source>The current kinds of Magic Virtual Tables are:</source>
          <target state="translated">Текущие виды Виртуальных Волшебных Столов:</target>
        </trans-unit>
        <trans-unit id="5c4fde69768c885a1c05aaf0e69e2380f88e2b66" translate="yes" xml:space="preserve">
          <source>The current leading implementation of Perl 6, Rakudo, released a &quot;useful, usable, 'early adopter'&quot; distribution of Perl 6 (called Rakudo Star) in July of 2010. Please see &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; for more information.</source>
          <target state="translated">Текущая ведущая реализация Perl 6, Rakudo, в июле 2010 года выпустила &amp;laquo;полезный, удобный и&amp;laquo; ранний последователь &amp;raquo;&amp;raquo; дистрибутива Perl 6 (называемого Rakudo Star). Пожалуйста, посетите &lt;a href=&quot;http://rakudo.org/&quot;&gt;http://rakudo.org/&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0ee5778fbc1ab8fe240410952dd5b9eaf045d059" translate="yes" xml:space="preserve">
          <source>The current line number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf758edb971b2b4dec99794c86a54d09eddea2b6" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot; in perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d3f495bb4240a9d3bab6ec75da601351d12c2b" translate="yes" xml:space="preserve">
          <source>The current locale is exposed to XS code except possibly &lt;code&gt;LC_NUMERIC&lt;/code&gt; (explained in the next paragraph). There have not been reports of problems with the other categories. Perl initializes things on start-up so that the current locale is the one which is indicated by the user's environment in effect at that time. See &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;ENVIRONMENT in perllocale&lt;/a&gt;.</source>
          <target state="translated">Текущая локаль доступна для кода XS, за исключением, возможно, &lt;code&gt;LC_NUMERIC&lt;/code&gt; (объяснено в следующем абзаце). Сообщений о проблемах с другими категориями не поступало. Perl инициализирует вещи при запуске, так что текущая локаль - это та, которая указана в среде пользователя, действующей в то время. Смотрите &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;ENVIRONMENT в perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06e14b6dd5c0c60379e0f9fc4367987da9456c3d" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional and Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061c069ca3fcc48e2c1a6a5055f7be81ca6838c7" translate="yes" xml:space="preserve">
          <source>The current locale is set at execution time by &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; described below. If that function hasn't yet been called in the course of the program's execution, the current locale is that which was determined by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; in effect at the start of the program. If there is no valid environment, the current locale is whatever the system default has been set to. On POSIX systems, it is likely, but not necessarily, the &quot;C&quot; locale. On Windows, the default is set via the computer's &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; (or its current equivalent).</source>
          <target state="translated">Текущая локаль устанавливается во время выполнения с помощью &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale (),&lt;/a&gt; описанной ниже. Если эта функция еще не была вызвана в ходе выполнения программы, текущая локаль - это то, что было определено &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ОКРУЖЕНИЕМ,&lt;/a&gt; действующим в начале программы. Если допустимая среда отсутствует, текущая локаль - это то, что было установлено по умолчанию в системе. В системах POSIX это вероятно, но не обязательно, локаль &quot;C&quot;. В Windows значение по умолчанию устанавливается через &lt;code&gt;Control Panel-&amp;gt;Regional &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; Language Options&lt;/code&gt; компьютера - &amp;gt; Язык и региональные стандарты (или его текущий эквивалент).</target>
        </trans-unit>
        <trans-unit id="b7f42f27fb52f98cb07c551fabc648053a689c30" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;functions/system&quot;&gt;system LIST&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="translated">Текущая локаль используется при выходе из Perl с такими операциями, как &lt;a href=&quot;functions/system&quot;&gt;системный LIST&lt;/a&gt; или &lt;a href=&quot;perlop#qx%2fSTRING%2f&quot;&gt;qx //&lt;/a&gt; , если эти операции зависят от локали.</target>
        </trans-unit>
        <trans-unit id="69e663f7c7a676b0d28d32e89828d9474ab1d29d" translate="yes" xml:space="preserve">
          <source>The current locale is used when going outside of Perl with operations like &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;system()&lt;/a&gt; or &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;qx//&lt;/a&gt;, if those operations are locale-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea51628874f50840c20248e49e31ecc39bc8aab0" translate="yes" xml:space="preserve">
          <source>The current major release of Perl is Perl 5, first released in 1994. It can run scripts from the previous major release, Perl 4 (March 1991), but has significant differences.</source>
          <target state="translated">В настоящее время основным релизом Perl является Perl 5,впервые выпущенный в 1994 году.Он может выполнять скрипты предыдущего мажорного релиза,Perl 4 (март 1991),но имеет значительные отличия.</target>
        </trans-unit>
        <trans-unit id="1ad75b57a59621fb77288b117b229032ac9f513f" translate="yes" xml:space="preserve">
          <source>The current naming convention is:</source>
          <target state="translated">Текущее соглашение об именах:</target>
        </trans-unit>
        <trans-unit id="b2e2b3b69c2218e4d8359acb1335a4024632d82a" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt; ) is restored at the end of</source>
          <target state="translated">Текущее смещение во внутреннем стеке Perl (см. &lt;code&gt;SP&lt;/code&gt; ) восстанавливается в конце</target>
        </trans-unit>
        <trans-unit id="6ab9fb3b5f482c273ca6d801c743b02bcacec72c" translate="yes" xml:space="preserve">
          <source>The current offset on the Perl internal stack (cf. &lt;code&gt;SP&lt;/code&gt;) is restored at the end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c030186501458b34adb46e2d42aa7b81f218a056" translate="yes" xml:space="preserve">
          <source>The current page length (printable lines) of the currently selected output channel. The default is 60.</source>
          <target state="translated">Текущая длина страницы (строки для печати)текущего выбранного выходного канала.По умолчанию 60.</target>
        </trans-unit>
        <trans-unit id="3d4eb19bb10369473283d32cc7dd71a86ff46c90" translate="yes" xml:space="preserve">
          <source>The current page number of the currently selected output channel.</source>
          <target state="translated">Номер текущей страницы текущего выбранного выходного канала.</target>
        </trans-unit>
        <trans-unit id="770296232bd3d822ead8ffe492b7e0e282b9f95e" translate="yes" xml:space="preserve">
          <source>The current phase of the perl interpreter.</source>
          <target state="translated">Текущая фаза работы переводчика perl.</target>
        </trans-unit>
        <trans-unit id="2864f23a19f0c83d2f66d97a56cf54892b44918f" translate="yes" xml:space="preserve">
          <source>The current process identifier is normally also available via the predefined $$ variable. Under fork() emulation however $$ may contain a pseudo-process identifier that is only meaningful to the Perl kill(), wait() and waitpid() functions. The Win32::GetCurrentProcessId() function will always return the regular Windows process id, even when called from inside a pseudo-process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2857cd700aaf0537f04949257bdb10786ea5148" translate="yes" xml:space="preserve">
          <source>The current set of characters after which a string may be broken to fill continuation fields (starting with &lt;code&gt;^&lt;/code&gt;) in a format. The default is &quot; \n-&quot;, to break on a space, newline, or a hyphen.</source>
          <target state="translated">Текущий набор символов, после которого строка может быть разбита для заполнения полей продолжения (начиная с &lt;code&gt;^&lt;/code&gt; ) в формате. По умолчанию используется &amp;laquo;\ n-&amp;raquo;, чтобы разделить пробел, новую строку или дефис.</target>
        </trans-unit>
        <trans-unit id="d0bc78c2888afaf94160d8cd4bd4fdc74663bf04" translate="yes" xml:space="preserve">
          <source>The current set of official keys is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981300e195cac4e7353f833304330d8ac58b67a9" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="translated">Текущий набор предупредительных проверок включен в &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; прагмы. Он имеет ту же область видимости, что и переменные &lt;code&gt;$^H&lt;/code&gt; и &lt;code&gt;%^H&lt;/code&gt; Точные значения считаются внутренними для прагмы &lt;a href=&quot;warnings&quot;&gt;предупреждений&lt;/a&gt; и могут изменяться в зависимости от версии Perl.</target>
        </trans-unit>
        <trans-unit id="5ff870c28a76abb15c6ef8bc6c01da1732cfc87c" translate="yes" xml:space="preserve">
          <source>The current set of warning checks enabled by the &lt;code&gt;use warnings&lt;/code&gt; pragma. It has the same scoping as the &lt;code&gt;$^H&lt;/code&gt; and &lt;code&gt;%^H&lt;/code&gt; variables. The exact values are considered internal to the &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; pragma and may change between versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48b124af22e055d2f998460eddfa2b05c504d05" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt;.</source>
          <target state="translated">Текущие настройки для конкретного резюме можно получить с помощью &lt;a href=&quot;#cv_get_call_checker&quot;&gt;cv_get_call_checker&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="043e73127d721a29085be4df3900bb1371bf6328" translate="yes" xml:space="preserve">
          <source>The current setting for a particular CV can be retrieved by &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b952480064e555e874a4e5bab67374e0afa43170" translate="yes" xml:space="preserve">
          <source>The current state is quite close to this target. Known limitations:</source>
          <target state="translated">Текущее состояние довольно близко к этой цели.Известные ограничения:</target>
        </trans-unit>
        <trans-unit id="ba6118e27828276e003be0b716e1e27e35775418" translate="yes" xml:space="preserve">
          <source>The current time, hires or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c893fdb58e68676d453e9772eca0458d9ee9ef15" translate="yes" xml:space="preserve">
          <source>The current value giving the maximum number of open but unclosed parenthetical groups there may be at any point during a regular expression compilation. The default is currently 1000 nested groups. You may adjust it depending on your needs and the amount of memory available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc73114057d5a2e203bbe1e6af0220ea5c0d6452" translate="yes" xml:space="preserve">
          <source>The current value of &lt;a href=&quot;perlvar#%24%2C&quot;&gt;&lt;code&gt;$,&lt;/code&gt;&lt;/a&gt; (if any) is printed between each LIST item. The current value of &lt;a href=&quot;perlvar#%24%5C&quot;&gt;&lt;code&gt;$\&lt;/code&gt;&lt;/a&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt;, but that doesn't look as good).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b45957d0c48ff5a61159add09d1cced4fe06354" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">Текущее значение &lt;code&gt;$,&lt;/code&gt; (если есть) печатается между каждым элементом СПИСКА. Текущее значение &lt;code&gt;$\&lt;/code&gt; (если есть) печатается после того, как будет напечатан весь СПИСОК. Поскольку print принимает СПИСОК, все, что есть в СПИСКЕ, оценивается в контексте списка, включая любые подпрограммы, списки возврата которых вы передаете на &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . Будьте осторожны и не ставьте за ключевым словом print левую круглую скобку, если только вы не хотите, чтобы соответствующая правая скобка завершала аргументы печати; заключите все аргументы в круглые скобки (или вставьте &lt;code&gt;+&lt;/code&gt; , но это выглядит не очень хорошо).</target>
        </trans-unit>
        <trans-unit id="d3b381c8d22a96ce946901e90864741d92df1af5" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$,&lt;/code&gt; (if any) is printed between each LIST item. The current value of &lt;code&gt;$\&lt;/code&gt; (if any) is printed after the entire LIST has been printed. Because print takes a LIST, anything in the LIST is evaluated in list context, including any subroutines whose return lists you pass to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;. Be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print; put parentheses around all arguments (or interpose a &lt;code&gt;+&lt;/code&gt; , but that doesn't look as good).</source>
          <target state="translated">Текущее значение &lt;code&gt;$,&lt;/code&gt; (если есть) печатается между каждым элементом СПИСКА. Текущее значение &lt;code&gt;$\&lt;/code&gt; (если есть) печатается после того, как будет напечатан весь СПИСОК. Поскольку print принимает СПИСОК, все, что есть в СПИСКЕ, оценивается в контексте списка, включая любые подпрограммы, списки возврата которых вы передаете на &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . Будьте осторожны и не ставьте за ключевым словом print левую круглую скобку, если только вы не хотите, чтобы соответствующая правая скобка завершала аргументы печати; заключите все аргументы в круглые скобки (или вставьте &lt;code&gt;+&lt;/code&gt; , но это выглядит не очень хорошо).</target>
        </trans-unit>
        <trans-unit id="16a7c40e8bbfe13e91d735da741af8520eabede2" translate="yes" xml:space="preserve">
          <source>The current value of &lt;code&gt;$archname&lt;/code&gt; can be found with this command:</source>
          <target state="translated">Текущее значение &lt;code&gt;$archname&lt;/code&gt; можно найти с помощью этой команды:</target>
        </trans-unit>
        <trans-unit id="db4a25bfed587546962de5c8d6543f967c92521a" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; accumulator for &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; lines. A format contains &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt; . After calling its format, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;functions/formline&quot;&gt;formline PICTURE,LIST&lt;/a&gt;.</source>
          <target state="translated">Текущее значение аккумулятора &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; для строк &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; . Формат содержит &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; вызовы , которые ставят их результат в &lt;code&gt;$^A&lt;/code&gt; . После вызова своего формата &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; распечатает содержимое &lt;code&gt;$^A&lt;/code&gt; и опустошает. Таким образом, вы никогда не увидите содержимое &lt;code&gt;$^A&lt;/code&gt; если вы &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline()&lt;/a&gt;&lt;/code&gt; не вызовете formline (), а затем посмотрите на него. Смотрите &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; и &lt;a href=&quot;functions/formline&quot;&gt;formline ИЗОБРАЖЕНИЕ, СПИСОК&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf446124f3a4c45cac5e41b4dd3df5f6adedf891" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;write()&lt;/code&gt; accumulator for &lt;code&gt;format()&lt;/code&gt; lines. A format contains &lt;code&gt;formline()&lt;/code&gt; calls that put their result into &lt;code&gt;$^A&lt;/code&gt;. After calling its format, &lt;code&gt;write()&lt;/code&gt; prints out the contents of &lt;code&gt;$^A&lt;/code&gt; and empties. So you never really see the contents of &lt;code&gt;$^A&lt;/code&gt; unless you call &lt;code&gt;formline()&lt;/code&gt; yourself and then look at it. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; and &lt;a href=&quot;perlfunc#formline-PICTURE%2CLIST&quot;&gt;&quot;formline PICTURE,LIST&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cef4c84f23112c510335f5bb9c61930fcb65b7" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its &lt;a href=&quot;perlrun#-Dletters&quot;&gt;command-line equivalent&lt;/a&gt;, you can use numeric or symbolic values, e.g. &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt;. See &lt;a href=&quot;perlrun#-Dnumber&quot;&gt;&quot;&lt;b&gt;-D&lt;/b&gt;&lt;i&gt;number&lt;/i&gt;&quot; in perlrun&lt;/a&gt;. The contents of this variable also affects the debugger operation. See &lt;a href=&quot;perldebguts#Debugger-Internals&quot;&gt;&quot;Debugger Internals&quot; in perldebguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed07dc52d8f87fe5efbcd1795acd592cb2bcdd55" translate="yes" xml:space="preserve">
          <source>The current value of the debugging flags. May be read or set. Like its command-line equivalent, you can use numeric or symbolic values, eg &lt;code&gt;$^D = 10&lt;/code&gt; or &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</source>
          <target state="translated">Текущее значение флагов отладки. Можно прочитать или установить. Как и его эквивалент в командной строке, вы можете использовать числовые или символьные значения, например, &lt;code&gt;$^D = 10&lt;/code&gt; или &lt;code&gt;$^D = &quot;st&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761048a9f6779920117c38b6975281ec2824cbaa" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt; .</source>
          <target state="translated">Текущее значение флага, связанного с переключателем &lt;b&gt;-c&lt;/b&gt; . В основном используется с &lt;b&gt;-MO = ...,&lt;/b&gt; чтобы позволить коду изменять свое поведение при компиляции, например, в &lt;code&gt;AUTOLOAD&lt;/code&gt; во время компиляции, а не при нормальной отложенной загрузке. Установка &lt;code&gt;$^C = 1&lt;/code&gt; аналогична вызову &lt;code&gt;B::minus_c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dafa28f68632a10855a57c5eacb6743b86c198f" translate="yes" xml:space="preserve">
          <source>The current value of the flag associated with the &lt;b&gt;-c&lt;/b&gt; switch. Mainly of use with &lt;b&gt;-MO=...&lt;/b&gt; to allow code to alter its behavior when being compiled, such as for example to &lt;code&gt;AUTOLOAD&lt;/code&gt; at compile time rather than normal, deferred loading. Setting &lt;code&gt;$^C = 1&lt;/code&gt; is similar to calling &lt;code&gt;B::minus_c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5468ce0ac69ee02e09a591df294df02b8e8e00dd" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to disable inplace editing.</source>
          <target state="translated">Текущее значение расширения inplace-edit. Используйте &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , чтобы отключить редактирование на месте.</target>
        </trans-unit>
        <trans-unit id="eb25a57f6557411f85b4814f0d93efdbea2e3515" translate="yes" xml:space="preserve">
          <source>The current value of the inplace-edit extension. Use &lt;code&gt;undef&lt;/code&gt; to disable inplace editing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0d30902e8f62034444f0c46f34be59caec65d2" translate="yes" xml:space="preserve">
          <source>The current value of the regex debugging flags. Set to 0 for no debug output even when the &lt;code&gt;re 'debug'&lt;/code&gt; module is loaded. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for details.</source>
          <target state="translated">Текущее значение флагов отладки регулярного выражения. Установите значение 0, чтобы отладочная информация не выводилась, даже если загружен модуль &lt;code&gt;re 'debug'&lt;/code&gt; . Подробности смотрите в &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a22922d7a166dbc35ec6d0a0c534fd11892caf1b" translate="yes" xml:space="preserve">
          <source>The current value of the warning switch, initially true if &lt;b&gt;-w&lt;/b&gt; was used, false otherwise, but directly modifiable.</source>
          <target state="translated">Текущее значение переключателя предупреждения, изначально истина, если использовалась &lt;b&gt;-w&lt;/b&gt; , в противном случае - ложь, но может быть изменена напрямую.</target>
        </trans-unit>
        <trans-unit id="434ca8d76bd8ecc27a064789f98b19395ab4f212" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="translated">Текущая версия стандартов для &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; доступна по адресу &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b563eb1b6cfef1294ee2d2ec105a8fc001fb852" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;atan2&lt;/code&gt; is available at &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93816bd1396e46a9b945ed8579592c7f8809bc3" translate="yes" xml:space="preserve">
          <source>The current version of the standards for &lt;code&gt;atan2&lt;/code&gt; is available at &lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/functions/atan2.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af70deb3b449e89c48e84135fbdeb7d79f07a9c" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">Текущая версия этого модуля всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;http://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt; . Он также является частью основного дистрибутива Perl начиная с версии 5.6.0.</target>
        </trans-unit>
        <trans-unit id="b31c3cebc8faae4e8a4925e48535264d89073d95" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="translated">Текущая версия этого модуля всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a8854edfd01b7a5e559e1a5294ccbba9d0afe6" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">Текущая версия этого модуля всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; . Он также является частью основного дистрибутива Perl начиная с версии 5.6.0.</target>
        </trans-unit>
        <trans-unit id="cbd165143fe6d4a52227133b4ee1638e509ed516" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/ansicolor/&quot;&gt;https://www.eyrie.org/~eagle/software/ansicolor/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a674a12f3426ba3d689c7c921dc0c45b179571fc" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c2bb6087cce8c28cf4e7d17487f87fbaa02086" translate="yes" xml:space="preserve">
          <source>The current version of this module is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47cd4fd8d9bd245ee61848360efac4088607cb6" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="translated">Текущая версия этого сценария всегда доступна на его веб-сайте &lt;a href=&quot;http://www.eyrie.org/~eagle/software/podlators/&quot;&gt;http://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt; . Он также является частью основного дистрибутива Perl начиная с версии 5.6.0.</target>
        </trans-unit>
        <trans-unit id="7b5c546ea518bb4350e7bf7b54f3310abe5cc06c" translate="yes" xml:space="preserve">
          <source>The current version of this script is always available from its web site at &lt;a href=&quot;https://www.eyrie.org/~eagle/software/podlators/&quot;&gt;https://www.eyrie.org/~eagle/software/podlators/&lt;/a&gt;. It is also part of the Perl core distribution as of 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8fe5626c6979a9718f106c0652b7d905296f64" translate="yes" xml:space="preserve">
          <source>The current version was written by Graham Barr.</source>
          <target state="translated">Текущая версия была написана Грэмом Барром.</target>
        </trans-unit>
        <trans-unit id="7c32f08e82229236d88693ec9eaad5ec8a635209" translate="yes" xml:space="preserve">
          <source>The current working directory of the program is</source>
          <target state="translated">Текущая рабочая директория программы</target>
        </trans-unit>
        <trans-unit id="403572c903ddf0d90233f3ad9327b2e78dc32883" translate="yes" xml:space="preserve">
          <source>The currently active COP (control op) roughly representing the current statement in the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588f5e820c106e9822f858102bdf0e7ae9b574c7" translate="yes" xml:space="preserve">
          <source>The customary Perl approach for processing all the lines in a file is to do so one line at a time:</source>
          <target state="translated">Обычный Perl-подход для обработки всех строк в файле состоит в том,чтобы делать это по одной строке за раз:</target>
        </trans-unit>
        <trans-unit id="a4504c4a63cdd557da723133c8d2b75666dc8630" translate="yes" xml:space="preserve">
          <source>The cwd() is the most natural form for the current architecture. For most systems it is identical to `pwd` (but without the trailing line terminator).</source>
          <target state="translated">cwd()является наиболее естественной формой для текущей архитектуры.Для большинства систем она идентична `pwd` (но без терминатора трейлинговой линии).</target>
        </trans-unit>
        <trans-unit id="40c9ebfbdf9a557c5ad182c1d60f03fd99fa74ef" translate="yes" xml:space="preserve">
          <source>The data argument passes in the value (if any) associated with the attribute. For example, if &lt;code&gt;&amp;amp;foo&lt;/code&gt; had been declared:</source>
          <target state="translated">Аргумент данных передает значение (если есть), связанное с атрибутом. Например, если был объявлен &lt;code&gt;&amp;amp;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4057a2800ea2edef8acd376fce4a738947ca16f2" translate="yes" xml:space="preserve">
          <source>The data can be aggregated into obvious structures, especially if there's a large amount of data in each aggregate.</source>
          <target state="translated">Данные могут быть агрегированы в очевидные структуры,особенно если в каждой из них имеется большой объем данных.</target>
        </trans-unit>
        <trans-unit id="f1737bbb402e005395886a66a62fefd166798f8a" translate="yes" xml:space="preserve">
          <source>The data is stored as a list of values from the time and times functions:</source>
          <target state="translated">Данные сохраняются в виде списка значений из функций времени и времени:</target>
        </trans-unit>
        <trans-unit id="083ecdb4eb83b1283f9d7370b6905eb300e214e7" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="translated">Данные могут быть получены с помощью функции &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; если известен базовый тип байтового потока.</target>
        </trans-unit>
        <trans-unit id="71f7b6c4c962003ad0e8bfcff7666dfb17bf3d56" translate="yes" xml:space="preserve">
          <source>The data may be retrieved using the &lt;code&gt;unpack&lt;/code&gt; function if the underlying type of the byte stream is known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63af91535a394b6aa4a43c6ecef621c3c5bffb80" translate="yes" xml:space="preserve">
          <source>The data of the file is not immediately available. This attribute indicates that the file data has been physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb2c0f943e4592858ab2d05373119174b2d2dda" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt; , so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="translated">Данные были добавлены как строка Unicode, и при записи на диск дисциплина строки &lt;code&gt;:utf8&lt;/code&gt; не была установлена ​​с помощью &lt;code&gt;Archive::Tar&lt;/code&gt; , поэтому Perl попытался преобразовать строку в ISO-8859 и потерпел неудачу. Теперь записанный файл содержит мусор.</target>
        </trans-unit>
        <trans-unit id="a586674f2132d76d932dd3ae8f2556dfbebc1fb6" translate="yes" xml:space="preserve">
          <source>The data was added as a Unicode string and when writing it out to disk, the &lt;code&gt;:utf8&lt;/code&gt; line discipline wasn't set by &lt;code&gt;Archive::Tar&lt;/code&gt;, so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ccb288f67ba8fe0c8510721b3e70886d45432a" translate="yes" xml:space="preserve">
          <source>The date and day names in dates formatted by &lt;code&gt;strftime()&lt;/code&gt; could be manipulated to advantage by a malicious user able to subvert the &lt;code&gt;LC_DATE&lt;/code&gt; locale. (&quot;Look--it says I wasn't in the building on Sunday.&quot;)</source>
          <target state="translated">Имена даты и дня в датах, отформатированных с помощью &lt;code&gt;strftime()&lt;/code&gt; могут быть использованы злонамеренным пользователем, способным &lt;code&gt;LC_DATE&lt;/code&gt; локаль LC_DATE . (&amp;laquo;Послушайте, там написано, что меня не было в здании в воскресенье&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="c40b16f78ce75cc859be91a0613f27d3f68c2364" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; function. Without an argument &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; uses the current time.</source>
          <target state="translated">День года находится в списке, возвращаемом функцией &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; . Без аргумента &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; использует текущее время.</target>
        </trans-unit>
        <trans-unit id="1c7a95dfcca9858a8405f98faf2612dd1935a1f7" translate="yes" xml:space="preserve">
          <source>The day of the year is in the list returned by the &lt;code&gt;localtime&lt;/code&gt; function. Without an argument &lt;code&gt;localtime&lt;/code&gt; uses the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d7e957f2b60e8e8af1a45f78007f3a710223c2" translate="yes" xml:space="preserve">
          <source>The days of just flinging strings around are over. It's well established that modern programs need to be capable of communicating funny accented letters, and things like euro symbols. This means that programmers need new habits. It's easy to program Unicode capable software, but it does require discipline to do it right.</source>
          <target state="translated">Дни,когда просто бросали струны,закончились.Хорошо известно,что современные программы должны быть способны передавать смешные акцентированные буквы и вещи вроде евросимволов.Это значит,что программистам нужны новые привычки.Программировать программы,способные работать с Unicode,легко,но для того,чтобы сделать это правильно,требуется дисциплина.</target>
        </trans-unit>
        <trans-unit id="7d9856be0d4d4aa47742843ac8ee15803c0a6dbf" translate="yes" xml:space="preserve">
          <source>The debugger does not currently work in conjunction with the &lt;b&gt;-W&lt;/b&gt; command-line switch, because it itself is not free of warnings.</source>
          <target state="translated">Отладчик в настоящее время не работает вместе с параметром командной строки &lt;b&gt;-W&lt;/b&gt; , потому что сам он не свободен от предупреждений.</target>
        </trans-unit>
        <trans-unit id="bff20683f233c3b1a43e85dddcc26c68e9457e08" translate="yes" xml:space="preserve">
          <source>The debugger has numerous options settable using the &lt;code&gt;o&lt;/code&gt; command, either interactively or from the environment or an rc file. (./.perldb or ~/.perldb under Unix.)</source>
          <target state="translated">Отладчик имеет множество опций, которые можно установить с помощью команды &lt;code&gt;o&lt;/code&gt; либо в интерактивном режиме, либо из среды или файла rc. (./.perldb или ~ / .perldb под Unix.)</target>
        </trans-unit>
        <trans-unit id="2b8f02d76c62b5ac783a580e7846d6536aa86d85" translate="yes" xml:space="preserve">
          <source>The debugger probably contains enough configuration hooks that you won't ever have to modify it yourself. You may change the behaviour of the debugger from within the debugger using its &lt;code&gt;o&lt;/code&gt; command, from the command line via the &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable, and from customization files.</source>
          <target state="translated">Отладчик, вероятно, содержит достаточно хуков настройки, которые вам никогда не придется изменять самостоятельно. Вы можете изменить поведение отладчика изнутри отладчика, используя его команду &lt;code&gt;o&lt;/code&gt; , из командной строки через &lt;code&gt;PERLDB_OPTS&lt;/code&gt; среды PERLDB_OPTS и из файлов настройки.</target>
        </trans-unit>
        <trans-unit id="24bc00b2a7165b041b9ffd101df7fc63fd2218dd" translate="yes" xml:space="preserve">
          <source>The debugger prompt is something like</source>
          <target state="translated">Подсказка отладчика-это что-то вроде</target>
        </trans-unit>
        <trans-unit id="f8e855d0dba7087b2dc163f59ea22e7610600301" translate="yes" xml:space="preserve">
          <source>The debugging output at compile time looks like this:</source>
          <target state="translated">Вывод отладки во время компиляции выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="5cc26823ddc27c25d44117d4b49405e558f3683c" translate="yes" xml:space="preserve">
          <source>The declared variable is not introduced (is not visible) until after the current statement. Thus,</source>
          <target state="translated">Объявленная переменная не вводится (не видна)до тех пор,пока не появится текущее утверждение.Таким образом,</target>
        </trans-unit>
        <trans-unit id="9ae51c467cb04a1b525475d0b1964978fbf97d39" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; as described above; interrupted &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; calls will always be retried.</source>
          <target state="translated">По умолчанию &lt;code&gt;:perlio&lt;/code&gt; слой perlio пытается &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; как описано выше; прерванные вызовы &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; всегда будут повторяться.</target>
        </trans-unit>
        <trans-unit id="cc07a8196664bfcb190df25e9665ffed3bb1d528" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;:perlio&lt;/code&gt; layer retries &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt; as described above; interrupted &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;waitpid&lt;/code&gt; calls will always be retried.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af57631245798d230b9a42590aed5504edc7411" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="translated">Метод &lt;code&gt;TIEHASH&lt;/code&gt; по умолчанию сохраняет &amp;laquo;лишние&amp;raquo; аргументы функции tie (), начиная со смещения 1 в массиве, на который ссылается &lt;code&gt;&lt;a href=&quot;../functions/tied&quot;&gt;tied(%tiedhash)&lt;/a&gt;&lt;/code&gt; ; это тот же алгоритм хранения, что и в подпрограмме TIEHASH выше. Следовательно, типичный пакет, унаследованный от &lt;b&gt;Tie :: ExtraHash&lt;/b&gt; , не требует перезаписи этого метода.</target>
        </trans-unit>
        <trans-unit id="d8f318f7bfa1b89c48af52e1a8f99d1af186c96f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;TIEHASH&lt;/code&gt; method stores &quot;extra&quot; arguments to tie() starting from offset 1 in the array referenced by &lt;code&gt;tied(%tiedhash)&lt;/code&gt;; this is the same storage algorithm as in TIEHASH subroutine above. Hence, a typical package inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt; does not need to overwrite this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5e1aaf469c61ad0505179ca4ef693920d67bf62" translate="yes" xml:space="preserve">
          <source>The default behavior for matching can be changed, using various modifiers. Modifiers that relate to the interpretation of the pattern are listed just below. Modifiers that alter the way a pattern is used by Perl are detailed in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bacf1d67275db56db4c207815d6942a42814176" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="translated">Поведение по умолчанию восстанавливается с помощью прагмы &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; или по достижении конца блока, включающего &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; . Обратите внимание, что вызовы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; могут быть вложенными, и что то, что действует во внутренней области, вернется к правилам внешней области в конце внутренней области.</target>
        </trans-unit>
        <trans-unit id="7e3af61d974b45e2899ef4868c4839bde44f6b43" translate="yes" xml:space="preserve">
          <source>The default behavior is restored with the &lt;code&gt;no locale&lt;/code&gt; pragma, or upon reaching the end of the block enclosing &lt;code&gt;use locale&lt;/code&gt;. Note that &lt;code&gt;use locale&lt;/code&gt; calls may be nested, and that what is in effect within an inner scope will revert to the outer scope's rules at the end of the inner scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc252c3cc028e1614732f1daa492845981dc49a" translate="yes" xml:space="preserve">
          <source>The default behavior is to allow either VMS or Unix syntax on input and to return VMS syntax on output unless Unix syntax has been explicitly requested via the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL feature.</source>
          <target state="translated">Поведение по умолчанию - разрешить синтаксис VMS или Unix на входе и вернуть синтаксис VMS на выходе, если синтаксис Unix не был явно запрошен с помощью функции &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; CRTL.</target>
        </trans-unit>
        <trans-unit id="d9abf79a3fe513de5ab5f6341a0a6954a2315c50" translate="yes" xml:space="preserve">
          <source>The default behaviour for what</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dccc7bf2df4ee545fc6ed04ddf3f01c1358bdf3" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="translated">По умолчанию операторы проверки файлов используют биты простого режима, возвращаемые семейством системных вызовов stat (). Однако многие операционные системы имеют дополнительные функции для определения более сложных прав доступа, например ACL (списки контроля доступа). В таких средах &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; может помочь операторам разрешений возвращать результаты, более согласованные с другими инструментами.</target>
        </trans-unit>
        <trans-unit id="b1be0363bbe710d46dddb1e57d79fb15e7183b86" translate="yes" xml:space="preserve">
          <source>The default behaviour of file test operators is to use the simple mode bits as returned by the stat() family of system calls. However, many operating systems have additional features to define more complex access rights, for example ACLs (Access Control Lists). For such environments, &lt;code&gt;use filetest&lt;/code&gt; may help the permission operators to return results more consistent with other tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3d08e8e13d1af1b8292d5961459da70c0fafa4" translate="yes" xml:space="preserve">
          <source>The default blacklist for Locale::Maketext also prevents use of the following methods in bracket notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e443bdcb2163a4573139a1dc139dfc380443bd8" translate="yes" xml:space="preserve">
          <source>The default blacklist is [qw|ftp|], as &lt;code&gt;/bin/ftp&lt;/code&gt; is rather unreliable.</source>
          <target state="translated">Черный список по умолчанию - [qw | ftp |], так как &lt;code&gt;/bin/ftp&lt;/code&gt; довольно ненадежен.</target>
        </trans-unit>
        <trans-unit id="ed0767b7e5643475189138ab836319b55629d878" translate="yes" xml:space="preserve">
          <source>The default buffer size is 4096.</source>
          <target state="translated">По умолчанию размер буфера 4096.</target>
        </trans-unit>
        <trans-unit id="8bc00fd19b1a0edf6b2c0d08377dcc6685c37357" translate="yes" xml:space="preserve">
          <source>The default can be overridden by setting the environment variable PERLIO to a space separated list of layers (&lt;code&gt;unix&lt;/code&gt; or platform low level layer is always pushed first).</source>
          <target state="translated">Значение по умолчанию можно переопределить, установив для переменной среды PERLIO список слоев, разделенных пробелами ( уровень нижнего уровня &lt;code&gt;unix&lt;/code&gt; или платформы всегда помещается первым).</target>
        </trans-unit>
        <trans-unit id="34b91bbcac281ec343e20574aee63c504ba37c87" translate="yes" xml:space="preserve">
          <source>The default command shells on DOS descendant operating systems (such as they are) usually do not expand wildcard arguments supplied to programs. They consider it the application's job to handle that. This is commonly achieved by linking the application (in our case, perl) with startup code that the C runtime libraries usually provide. However, doing that results in incompatible perl versions (since the behavior of the argv expansion code differs depending on the compiler, and it is even buggy on some compilers). Besides, it may be a source of frustration if you use such a perl binary with an alternate shell that *does* expand wildcards.</source>
          <target state="translated">Командные оболочки по умолчанию на операционных системах-потомках DOS (таких,как они есть)обычно не расширяют аргументы подстановки подстановки,предоставляемые программам.Они считают это задачей приложения.Обычно это достигается компоновкой приложения (в нашем случае perl)с исходным кодом,который обычно предоставляют библиотеки времени исполнения C.Однако,это приводит к несовместимым версиям perl (так как поведение кода расширения argv отличается в зависимости от компилятора,а на некоторых компиляторах это даже является ошибкой).Кроме того,это может быть источником разочарования,если вы используете такой бинарный файл perl с альтернативной оболочкой,которая *does*расширяет подстановочные знаки.</target>
        </trans-unit>
        <trans-unit id="83afe3e15499ebffd14384524a4838c21ad9ac57" translate="yes" xml:space="preserve">
          <source>The default delivery policy of signals changed in Perl v5.8.0 from immediate (also known as &quot;unsafe&quot;) to deferred, also known as &quot;safe signals&quot;. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more information.</source>
          <target state="translated">Политика доставки сигналов по умолчанию в Perl v5.8.0 была изменена с немедленной (также известной как &amp;laquo;небезопасная&amp;raquo;) на отложенную, также известную как &amp;laquo;безопасные сигналы&amp;raquo;. См. &lt;a href=&quot;perlipc&quot;&gt;Perlipc&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="d0b1ff51c2db16d895d3583e8ea3357f71cb7399" translate="yes" xml:space="preserve">
          <source>The default directory for this is the &lt;code&gt;plugins/CPAN::Plugin::Specfile&lt;/code&gt; directory in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e779baf9efd4d9532a5adc61d0ecb2fb82fd6ccb" translate="yes" xml:space="preserve">
          <source>The default exports of &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; do a complicated calculation when given a year value less than 1000. This leads to surprising results in many cases. See &lt;a href=&quot;#Year-Value-Interpretation&quot;&gt;&quot;Year Value Interpretation&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60de20ca32864441bb2ece16480b765adbc68d5" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">По умолчанию перевод имени файла примерно равен &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr|/.|./|;&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f540cdd4f440c064d7b134e9369a41da6337cfdb" translate="yes" xml:space="preserve">
          <source>The default filename translation is roughly &lt;code&gt;tr|/.|./|&lt;/code&gt;, swapping dots and slashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b0d8e26001e75f3757789c285eac1caf4919f4" translate="yes" xml:space="preserve">
          <source>The default for &lt;code&gt;$svShare&lt;/code&gt; is &lt;code&gt;&quot;rw&quot;&lt;/code&gt; which provides the same sharing as using regular perl &lt;code&gt;open()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189d94e0a4457922028f86938b0ce7520f054dc0" translate="yes" xml:space="preserve">
          <source>The default for this field, if it cannot be extracted, is to copy &lt;code&gt;$Config{osname}&lt;/code&gt;. The two may be differing in casing (OpenBSD vs openbsd).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141616a08e099cc503e54695ac44f2c439029e1f" translate="yes" xml:space="preserve">
          <source>The default for this option is off.</source>
          <target state="translated">По умолчанию эта опция выключена.</target>
        </trans-unit>
        <trans-unit id="841e53532f4d336433d317d532f99affc692102b" translate="yes" xml:space="preserve">
          <source>The default hash function has been modified with the intention of making it harder to infer the hash seed.</source>
          <target state="translated">Функция хэша по умолчанию была изменена с целью затруднить вывод семени хэша.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">Реализация по умолчанию ничего не делает.</target>
        </trans-unit>
        <trans-unit id="ba4a564c2fb984db1b9ac70f6b103f10fd3f2c07" translate="yes" xml:space="preserve">
          <source>The default in Perl 5.8.0 and later is to automatically use the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">По умолчанию в Perl 5.8.0 и новее автоматически используется слой &lt;code&gt;:perlio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b539403338a04682d5065664097088c7ee8126" translate="yes" xml:space="preserve">
          <source>The default indent space length is three. You can use &lt;code&gt;indent_length&lt;/code&gt; to change the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c034d8cea0ccefbe74b407c47763a2d7febf85bd" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt; .</source>
          <target state="translated">Входной &lt;b&gt;поток&lt;/b&gt; по умолчанию для вашей программы, которому, если возможно, не важно, откуда берутся его данные. Представлен в программе Perl &lt;b&gt;дескриптором файла &lt;/b&gt; &lt;code&gt;STDIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb8819256c2fefb2deae155f9c497a4ece2df39" translate="yes" xml:space="preserve">
          <source>The default input &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is coming from. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDIN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65b453abcd65763f1788a5bfac88b6cf8e06702" translate="yes" xml:space="preserve">
          <source>The default input and pattern-searching space. The following pairs are equivalent:</source>
          <target state="translated">Пространство для ввода и поиска шаблонов по умолчанию.Следующие пары эквивалентны:</target>
        </trans-unit>
        <trans-unit id="cea52ce10c001ee673712587e9b895266781fd26" translate="yes" xml:space="preserve">
          <source>The default installation directory of Perl under PASE is /QOpenSys/perl. This can be modified if needed with Configure parameter -Dprefix=/some/dir.</source>
          <target state="translated">По умолчанию каталогом установки Perl в PASE является /QOpenSys/perl.При необходимости его можно изменить с помощью параметра Configure -Dprefix=/some/dir.</target>
        </trans-unit>
        <trans-unit id="c02bd4590e22b3fdced3d71cd3c3281cc1a0a660" translate="yes" xml:space="preserve">
          <source>The default installation location for this release uses the traditional UNIX directory layout under /usr/local. This is the recommended location for most users, and will leave the Apple-supplied Perl and its modules undisturbed.</source>
          <target state="translated">Место установки по умолчанию для этого выпуска использует традиционную раскладку каталогов UNIX в каталоге /usr/local.Это рекомендуемое место установки для большинства пользователей,оно оставит нетронутым поставляемый Apple Perl и его модули.</target>
        </trans-unit>
        <trans-unit id="2cf27b908bba58a1adbe27495a165db5ad0a8770" translate="yes" xml:space="preserve">
          <source>The default is 0.</source>
          <target state="translated">По умолчанию 0.</target>
        </trans-unit>
        <trans-unit id="b6e007f998a46a63459c07f21e8e579bcd3ddb9e" translate="yes" xml:space="preserve">
          <source>The default is 0;</source>
          <target state="translated">По умолчанию 0;</target>
        </trans-unit>
        <trans-unit id="2fede1b14731afaa7b9b9368ecc641901f9fa509" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="translated">По умолчанию 1, когда &lt;a href=&quot;../warnings&quot;&gt;предупреждения&lt;/a&gt; включены, в противном случае - 0;</target>
        </trans-unit>
        <trans-unit id="b58a909406f580df200ff808a155d67c594063fb" translate="yes" xml:space="preserve">
          <source>The default is 1 when &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; are enabled, 0 otherwise;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515832f976590cbb3c71bc0d7d3d0a86a107732b" translate="yes" xml:space="preserve">
          <source>The default is 1.</source>
          <target state="translated">По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="895305ba9904fa755bf8e86c105e9e415a01803b" translate="yes" xml:space="preserve">
          <source>The default is 15 seconds. If you set this value to 0, no timeout will occur, but this is not recommended.</source>
          <target state="translated">По умолчанию 15 секунд.Если вы установите это значение в 0,таймаут не произойдет,но это не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="df47c42104d45d72a320a61c09a39d1b3d97871e" translate="yes" xml:space="preserve">
          <source>The default is 1;</source>
          <target state="translated">По умолчанию 1;</target>
        </trans-unit>
        <trans-unit id="f462ad28c3fd0db899a9c6ebf2e36d1b531777fa" translate="yes" xml:space="preserve">
          <source>The default is 4096.</source>
          <target state="translated">По умолчанию 4096.</target>
        </trans-unit>
        <trans-unit id="32bc975de1e1a4635ed927b65955622d6412a442" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d612105f440a62563ca32f22b838324e618ccdeb" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b05c3b862baf5dbb3b6628baf4b68b1570abdb4" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">По умолчанию &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e7ce922e57105bce0e95e91cfca276a6a4bf1ac" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt; for the root user and &lt;code&gt;0&lt;/code&gt; for normal users.</source>
          <target state="translated">По умолчанию это &lt;code&gt;1&lt;/code&gt; для пользователя root и &lt;code&gt;0&lt;/code&gt; для обычных пользователей.</target>
        </trans-unit>
        <trans-unit id="96a31382338c2cce7d4e50686f56e0e9ff7debef" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf2b1ea0900573472d5b071e3de19f7567ee6bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">По умолчанию - &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b961dbd8be6b25800dc4b37b67546efccad28f8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfbfc9925e2dd8470367ef4195617d71c6222d8e" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc194b0254a7cf1688815756a4f2837510b9b267" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a908c10942fd5ae6b565f1ce15f1bbfadcedfbe1" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40557fe038c23288a394f8bc56206a7b66f1744c" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;die&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb390eebfd5c04071c6f9ae432a01e30ec460a80" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt; .</source>
          <target state="translated">По умолчанию - &lt;code&gt;pod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a27550390154dabd1f6cbb3ac3486e6b597d5bd" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;pod&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0a0f1ca8eef2f6fbf6f39dbd7668ad5fbc612a" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_COMPRESSION.</source>
          <target state="translated">По умолчанию Z_DEFAULT_COMPRESSION.</target>
        </trans-unit>
        <trans-unit id="ae93ce6388b29eb983caf1def75b439a9873a0b9" translate="yes" xml:space="preserve">
          <source>The default is Z_DEFAULT_STRATEGY.</source>
          <target state="translated">По умолчанию Z_DEFAULT_STRATEGY.</target>
        </trans-unit>
        <trans-unit id="c52e69ffb8153da22fcf2e0c6d6adcb6a6ff963d" translate="yes" xml:space="preserve">
          <source>The default is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30329767ad59c2dc5630061d1ce79106ced2716" translate="yes" xml:space="preserve">
          <source>The default is no dictionary.</source>
          <target state="translated">По умолчанию не существует словаря.</target>
        </trans-unit>
        <trans-unit id="0eaff3b0b1b9eb661e7fc7bd656a07d77ba2a1ef" translate="yes" xml:space="preserve">
          <source>The default is not to cuddle.</source>
          <target state="translated">По умолчанию-не обниматься.</target>
        </trans-unit>
        <trans-unit id="7226202181b27bad8c72a76152482ae3e839b2c6" translate="yes" xml:space="preserve">
          <source>The default is to simply return the event package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c65dc0d3752b5562d0e04006d66de6352709010" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; . Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="translated">По умолчанию используется &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;tcp&lt;/code&gt; , &lt;code&gt;udp&lt;/code&gt; , &lt;code&gt;unix&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;stream&lt;/code&gt; , &lt;code&gt;console&lt;/code&gt; . В системах с Win32 API &lt;code&gt;eventlog&lt;/code&gt; будет добавлен в качестве первого механизма для проверки доступности &lt;code&gt;Win32::EventLog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae6954e08dfdc077f1f7dcc91f272e939cf877ea" translate="yes" xml:space="preserve">
          <source>The default is to try &lt;code&gt;native&lt;/code&gt;, &lt;code&gt;tcp&lt;/code&gt;, &lt;code&gt;udp&lt;/code&gt;, &lt;code&gt;unix&lt;/code&gt;, &lt;code&gt;pipe&lt;/code&gt;, &lt;code&gt;stream&lt;/code&gt;, &lt;code&gt;console&lt;/code&gt;. Under systems with the Win32 API, &lt;code&gt;eventlog&lt;/code&gt; will be added as the first mechanism to try if &lt;code&gt;Win32::EventLog&lt;/code&gt; is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb3e1a426b5cc38eac62d98ea857e63ed9b5dd" translate="yes" xml:space="preserve">
          <source>The default iterator variable in a &lt;code&gt;foreach&lt;/code&gt; loop if no other variable is supplied.</source>
          <target state="translated">Переменная итератора по умолчанию в цикле &lt;code&gt;foreach&lt;/code&gt; , если не указана другая переменная.</target>
        </trans-unit>
        <trans-unit id="375ddf0ab7799023484d02f8a221ca6afd3b2054" translate="yes" xml:space="preserve">
          <source>The default memory limit is 2Mib. You can adjust the maximum read cache size by supplying the &lt;code&gt;memory&lt;/code&gt; option. The argument is the desired cache size, in bytes.</source>
          <target state="translated">Предел памяти по умолчанию - 2 МБ. Вы можете настроить максимальный размер кэша чтения, указав параметр &lt;code&gt;memory&lt;/code&gt; . Аргументом является желаемый размер кеша в байтах.</target>
        </trans-unit>
        <trans-unit id="97d617432e38273ff2337188090afe707d321e91" translate="yes" xml:space="preserve">
          <source>The default method is ZIP_CM_DEFLATE.</source>
          <target state="translated">Метод по умолчанию ZIP_CM_DEFLATE.</target>
        </trans-unit>
        <trans-unit id="d06faea5104288d8b0b633dc0567b8b191f0df74" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt; .</source>
          <target state="translated">Имя нового файла конфигурации по умолчанию - &amp;laquo;libnet.cfg&amp;raquo;, и по умолчанию он записывается в текущий каталог, если иное не указано с помощью параметра -o, &lt;code&gt;-o newfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="408dfa6f2b57602d832595e17787ee724e235423" translate="yes" xml:space="preserve">
          <source>The default name of the new configuration file is &quot;libnet.cfg&quot;, and by default it is written to the current directory, unless otherwise specified using the -o option, &lt;code&gt;-o newfile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5074809750e6c620d635552cb416989d3d15b2" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt; , and it is searched first from the current directory, and then from your module path.</source>
          <target state="translated">Имя старого файла конфигурации по умолчанию - &quot;libnet.cfg&quot;, если иное не указано с помощью параметра -i, &lt;code&gt;-i oldfile&lt;/code&gt; , и поиск выполняется сначала из текущего каталога, а затем из пути к вашему модулю.</target>
        </trans-unit>
        <trans-unit id="1fef6f94288b1eff625c2f95ef7ecffd1ba05913" translate="yes" xml:space="preserve">
          <source>The default name of the old configuration file is by default &quot;libnet.cfg&quot;, unless otherwise specified using the -i option, &lt;code&gt;-i oldfile&lt;/code&gt;, and it is searched first from the current directory, and then from your module path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb6185afb472dae00827acf41154ba83b345446" translate="yes" xml:space="preserve">
          <source>The default normalizer just concatenates the arguments with character 28 in between. (In ASCII, this is called FS or control-\.) This always works correctly for functions with only one string argument, and also when the arguments never contain character 28. However, it can confuse certain argument lists:</source>
          <target state="translated">Нормализатор по умолчанию просто конкапсулирует аргументы с символом 28 между ними.(В ASCII это называется FS или control-\.)Это всегда корректно работает для функций только с одним строковым аргументом,а также когда аргументы никогда не содержат символ 28.Однако,это может запутать некоторые списки аргументов:</target>
        </trans-unit>
        <trans-unit id="b39e82de8afe051a851d53770ae84cf3c68d41cb" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; . That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="translated">Нормализатор по умолчанию превратит это во что-то вроде &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt; . Это было бы хорошо, за исключением того, что последующий массив чисел может храниться в другом месте, даже если он содержит те же данные. Если это произойдет, &lt;code&gt;Memoize&lt;/code&gt; будет думать, что аргументы разные, даже если они эквивалентны. В этом случае подходит такой нормализатор:</target>
        </trans-unit>
        <trans-unit id="82517263c6d17f4e83cb2dad91556a271e1fb059" translate="yes" xml:space="preserve">
          <source>The default normalizer will turn this into something like &lt;code&gt;&quot;13\034ARRAY(0x436c1f)&quot;&lt;/code&gt;. That would be all right, except that a subsequent array of numbers might be stored at a different location even though it contains the same data. If this happens, &lt;code&gt;Memoize&lt;/code&gt; will think that the arguments are different, even though they are equivalent. In this case, a normalizer like this is appropriate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d60aed408340ddef56e731c14beba1f193a756" translate="yes" xml:space="preserve">
          <source>The default of building Perl statically may cause problems with complex applications like Tk: in that case consider building shared Perl</source>
          <target state="translated">По умолчанию сборка Perl статически может вызвать проблемы со сложными приложениями,такими как Tk:в этом случае рассмотрим сборку общего Perl</target>
        </trans-unit>
        <trans-unit id="ac5f6413f6edd9db793b85ce42ea2d862be3c9a0" translate="yes" xml:space="preserve">
          <source>The default operator mask for a newly created compartment is the ':default' optag.</source>
          <target state="translated">Оператором по умолчанию для вновь созданного помещения является оптаг ':по умолчанию'.</target>
        </trans-unit>
        <trans-unit id="cd7a35f6ae99c836f5d425b35999dec2510b2218" translate="yes" xml:space="preserve">
          <source>The default options gathered by Configure with the assistance of</source>
          <target state="translated">Опции по умолчанию,собранные Настроить с помощью</target>
        </trans-unit>
        <trans-unit id="340bacd1cab82a806d284b26719b4d768c188a8d" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt; . You can use this stream explicitly, but the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="translated">Вывода по умолчанию &lt;b&gt;поток&lt;/b&gt; для противных замечаний , которые не входят в &lt;b&gt;стандартный вывод&lt;/b&gt; . Представлен в программе Perl выходным&amp;gt; &lt;b&gt;дескриптором файла &lt;/b&gt; &lt;code&gt;STDERR&lt;/code&gt; . Вы можете использовать этот поток явно, но встроенные модули &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; записываются в стандартный поток ошибок автоматически (если только они не были захвачены или перехвачены иным образом).</target>
        </trans-unit>
        <trans-unit id="9d2c9ac156cbf55108641e915b384d66d9246e77" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for nasty remarks that don&amp;rsquo;t belong in &lt;b&gt;standard output&lt;/b&gt;. Represented within a Perl program by the output&amp;gt; &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDERR&lt;/code&gt;. You can use this stream explicitly, but the &lt;code&gt;die&lt;/code&gt; and &lt;code&gt;warn&lt;/code&gt; built-ins write to your standard error stream automatically (unless trapped or otherwise intercepted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa254ec270a416bb3ac03f5a884b155a435c80cb" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">Выходной &lt;b&gt;поток&lt;/b&gt; по умолчанию для вашей программы, которому, если возможно, не важно, куда идут его данные. Представлен в программе Perl &lt;b&gt;дескриптором файла &lt;/b&gt; &lt;code&gt;STDOUT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce1dc62266e22cc3e68d183b4a85d64622b5e7d5" translate="yes" xml:space="preserve">
          <source>The default output &lt;b&gt;stream&lt;/b&gt; for your program, which if possible shouldn&amp;rsquo;t care where its data is going. Represented within a Perl program by the &lt;b&gt;filehandle&lt;/b&gt;&lt;code&gt;STDOUT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96d4d616212a6cfd4d2816b5ab3f17c9db66319" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">Вывод по умолчанию самореферентных структур может быть &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , но вложенные ссылки на &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab4464102ba1e6fbe0c2c60b9748efe43e91939d" translate="yes" xml:space="preserve">
          <source>The default output of self-referential structures can be &lt;code&gt;eval&lt;/code&gt;ed, but the nested references to &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f2d9e51d87e9b71a9bd992e69d11af3ccda88f" translate="yes" xml:space="preserve">
          <source>The default path for perl binary is /QOpenSys/perl/bin/perl. You'll want to symlink /QOpenSys/usr/bin/perl to this file so you don't have to modify your path.</source>
          <target state="translated">Путь по умолчанию для двоичного файла perl-/QOpenSys/perl/bin/perl.Вы захотите создать сим-ссылку /QOpenSys/usr/bin/perl на этот файл,чтобы вам не пришлось изменять путь.</target>
        </trans-unit>
        <trans-unit id="c0e7903465e131bba24e8f9fa0f5926ebf1b8dce" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size for different platforms varies significantly, and is almost always far more than is needed for most applications. On Win32, Perl's makefile explicitly sets the default stack to 16 MB; on most other platforms, the system default is used, which again may be much larger than is needed.</source>
          <target state="translated">Размер стека по умолчанию для разных платформ значительно варьируется и почти всегда намного больше,чем требуется для большинства приложений.На Win32 makefile Perl явно устанавливает размер стека по умолчанию в 16 МБ;на большинстве других платформ используется системный стек по умолчанию,который опять-таки может быть намного больше,чем требуется.</target>
        </trans-unit>
        <trans-unit id="02fbe3c9bc6d319100d5d82a643c83d45a2aaf27" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; :</source>
          <target state="translated">Размер стека по умолчанию для каждого потока может быть установлен при запуске приложения с помощью переменной среды &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="94af03e91a740f430511958dbcda39a82148e50f" translate="yes" xml:space="preserve">
          <source>The default per-thread stack size may be set at the start of the application through the use of the environment variable &lt;code&gt;PERL5_ITHREADS_STACK_SIZE&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17c04396f5d2338f66524479b64e4296e2bc5c4" translate="yes" xml:space="preserve">
          <source>The default perl executable is flexible enough to support most usages. However, one may want something yet more flexible; for example, one may want to find Perl DLL relatively to the location of the EXE file; or one may want to ignore the environment when setting the Perl-library search patch, etc.</source>
          <target state="translated">Исполняемый файл perl по умолчанию достаточно гибкий,чтобы поддерживать большинство функций.Однако,может понадобиться что-то более гибкое;например,можно найти Perl DLL относительно места расположения EXE-файла;или можно игнорировать окружение при установке патча для поиска Perl-библиотеки и т.д.</target>
        </trans-unit>
        <trans-unit id="7009bdcf386245a7873fc69dc2c48c3bfdcf71d9" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;.)</source>
          <target state="translated">Разрешения по умолчанию, используемые при создании нового файла. Фактические разрешения будут изменены umask пользователя, поэтому вам, вероятно, следует использовать здесь 0666. (См. &lt;a href=&quot;functions/umask&quot;&gt;Umask&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="81e2f33b41f0b680f7cab719bcc71740e182cd7b" translate="yes" xml:space="preserve">
          <source>The default permissions to use if a new file is created. The actual permissions will be modified by the user's umask, so you should probably use 0666 here. (See &lt;a href=&quot;perlfunc#umask&quot;&gt;&quot;umask&quot; in perlfunc&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af672db5716c0b823ab6d08666d2a653d572eae5" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="translated">Место по умолчанию для размещения следующего значения или входной записи, когда &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; или результат &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; операции проверяется сам по себе в качестве единственного критерия теста &lt;code&gt;while&lt;/code&gt; . Вне в &lt;code&gt;while&lt;/code&gt; тест, это не произойдет.</target>
        </trans-unit>
        <trans-unit id="d37b151c3f1ab65346e3808827390e5bd84764e9" translate="yes" xml:space="preserve">
          <source>The default place to put the next value or input record when a &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;readdir&lt;/code&gt; or &lt;code&gt;each&lt;/code&gt; operation's result is tested by itself as the sole criterion of a &lt;code&gt;while&lt;/code&gt; test. Outside a &lt;code&gt;while&lt;/code&gt; test, this will not happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5df9208ed1f779ba0f9d5864d277d9b22483511" translate="yes" xml:space="preserve">
          <source>The default rendering is top-down, so they're not in execution order. This form reflects the way the stack is used to parse and evaluate expressions; the add operates on the two terms below it in the tree.</source>
          <target state="translated">По умолчанию рендеринг ведется сверху вниз,поэтому они не находятся в порядке исполнения.Эта форма отражает то,как стек используется для разбора и оценки выражений;добавление оперирует двумя терминами,расположенными под ним в дереве.</target>
        </trans-unit>
        <trans-unit id="2fc20ab6a2146e41cd4461ac23c56be7f29f5c25" translate="yes" xml:space="preserve">
          <source>The default rounding mode is 'even'. By using &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; you can get and set the default mode for subsequent rounding. The usage of &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; is no longer supported. The second parameter to the round functions then overrides the default temporarily.</source>
          <target state="translated">По умолчанию используется режим округления &amp;laquo;четный&amp;raquo;. Используя &lt;code&gt;Math::BigFloat-&amp;gt;round_mode($round_mode);&lt;/code&gt; вы можете получить и установить режим по умолчанию для последующего округления. Использование &lt;code&gt;$Math::BigFloat::$round_mode&lt;/code&gt; больше не поддерживается. Затем второй параметр функций округления временно отменяет значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0c0082ed0ee0f68ac7247af3405f6e36532a7d14" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms</source>
          <target state="translated">Набор слоев по умолчанию должен давать приемлемые результаты на всех платформах</target>
        </trans-unit>
        <trans-unit id="df981f37a11491520138a9699f03c2d8e3a6701d" translate="yes" xml:space="preserve">
          <source>The default set of layers should give acceptable results on all platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f212f2163021f600388dfedb85757788b2ee77" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt; . &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; , used above, is the numerical comparison operator.</source>
          <target state="translated">Функция сортировки по умолчанию - cmp, сравнение строк, которая сортирует &lt;code&gt;(1, 2, 10)&lt;/code&gt; в &lt;code&gt;(1, 10, 2)&lt;/code&gt; . &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; , использованный выше, является оператором числового сравнения.</target>
        </trans-unit>
        <trans-unit id="353560b1cc4cc620cb2f91f0d6a0c54645b715f0" translate="yes" xml:space="preserve">
          <source>The default sort function is cmp, string comparison, which would sort &lt;code&gt;(1, 2, 10)&lt;/code&gt; into &lt;code&gt;(1, 10, 2)&lt;/code&gt;. &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;, used above, is the numerical comparison operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d032c7cba8f64635473f913417491617017d4ca8" translate="yes" xml:space="preserve">
          <source>The default stringification for version objects returns exactly the same string as was used to create it, whether you used &lt;code&gt;new()&lt;/code&gt; or &lt;code&gt;qv()&lt;/code&gt;, with one exception. The sole exception is if the object was created using &lt;code&gt;qv()&lt;/code&gt; and the initializer did not have two decimal places or a leading 'v' (both optional), then the stringified form will have a leading 'v' prepended, in order to support round-trip processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa9ec2a72f812d2fff5978a7051ec1d9ead2a46" translate="yes" xml:space="preserve">
          <source>The default subscript separator is &quot;\034&quot;, the same as SUBSEP in &lt;b&gt;awk&lt;/b&gt;.</source>
          <target state="translated">Разделитель нижнего индекса по умолчанию - &quot;\ 034&quot;, такой же, как SUBSEP в &lt;b&gt;awk&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="497fecb3c603ebf0c33d9ba37b78e38f23ed6d1f" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedbef30ad12f7c78358c3195161f7bf65ed2265" translate="yes" xml:space="preserve">
          <source>The default text formatter is &lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;. The base class for Pod::Usage can be defined by pre-setting &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</source>
          <target state="translated">Средство форматирования текста по умолчанию - &lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt; . Базовый класс для Pod :: Usage можно определить, предварительно установив &lt;code&gt;$Pod::Usage::Formatter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2eca7e39567cc3a4e38f07441f8e4f7046f9b14f" translate="yes" xml:space="preserve">
          <source>The default type for the constants. If not specified &lt;code&gt;IV&lt;/code&gt; is assumed.</source>
          <target state="translated">Тип по умолчанию для констант. Если не указано иное, предполагается &lt;code&gt;IV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6f652439685a6a403073936eade467faa79602" translate="yes" xml:space="preserve">
          <source>The default typemap in the</source>
          <target state="translated">Типовая карта по умолчанию в</target>
        </trans-unit>
        <trans-unit id="82f3cb0c641077271c3068ea9c85e22ba715cfbb" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;div_scale&lt;/code&gt; is 40.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;div_scale&lt;/code&gt; - 40.</target>
        </trans-unit>
        <trans-unit id="609bf4918ead31f720f19323f5cf2348643f6d2e" translate="yes" xml:space="preserve">
          <source>The default value for CCHOME in the makefiles for Visual C++ may not be correct for some versions. Make sure the default exists and is valid.</source>
          <target state="translated">Значение по умолчанию для CCHOME в makefiles для Visual C++может быть некорректным для некоторых версий.Убедитесь,что значение по умолчанию существует и является правильным.</target>
        </trans-unit>
        <trans-unit id="80bc06aeaa38f855546b7a2a3a5c29a6a05fdf78" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;30&lt;/code&gt; seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f34862d6782defbe2c5b2a0445c8f00de39fa4d" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; . An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; и &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt; . Ключевое слово INTERFACE с пустым списком функций может быть опущено, если используется ключевое слово INTERFACE_MACRO.</target>
        </trans-unit>
        <trans-unit id="32834cb885f5de67f85718b2d51a3b3a71e20354" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;XSINTERFACE_FUNC&lt;/code&gt; and &lt;code&gt;XSINTERFACE_FUNC_SET&lt;/code&gt;. An INTERFACE keyword with an empty list of functions can be omitted if INTERFACE_MACRO keyword is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae2f809fd681df4fcb45c0c13d99a0283fc66b8" translate="yes" xml:space="preserve">
          <source>The definition used for complex arguments of atan2() is</source>
          <target state="translated">Определение,используемое для сложных аргументов atan2(),следующее</target>
        </trans-unit>
        <trans-unit id="6431fb44fb840f90a758f20a67dcf8b7a9374aa9" translate="yes" xml:space="preserve">
          <source>The del_dup() Method</source>
          <target state="translated">Метод del_dup()</target>
        </trans-unit>
        <trans-unit id="4c063e0f96bfc07d5c7996a96961c2627b3a8bf5" translate="yes" xml:space="preserve">
          <source>The delimiter is used to determine the &lt;b&gt;exact&lt;/b&gt; whitespace to remove from the beginning of each line. All lines &lt;b&gt;must&lt;/b&gt; have at least the same starting whitespace (except lines only containing a newline) or perl will croak. Tabs and spaces can be mixed, but are matched exactly. One tab will not be equal to 8 spaces!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1ded41373481d9b3a2afdb892465f6f5d0d39d" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; .</source>
          <target state="translated">Разделитель, предоставленный для &lt;code&gt;extract_bracketed&lt;/code&gt; , не был одним из &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4b77b961d2e96dc174edd63ec1e4a27ffd7394" translate="yes" xml:space="preserve">
          <source>The delimiter provided to &lt;code&gt;extract_bracketed&lt;/code&gt; was not one of &lt;code&gt;'()[]&amp;lt;&amp;gt;{}'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6b6844fe43a8d8ec1aad6ff952638a46635ab3" translate="yes" xml:space="preserve">
          <source>The denizens of makemaker@perl.org.</source>
          <target state="translated">Денизены makemaker@perl.org.</target>
        </trans-unit>
        <trans-unit id="04df92977d147f1a13e2b1c8b477d27313374630" translate="yes" xml:space="preserve">
          <source>The deprecated features will be grouped by the version of Perl in which they will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1156b058c0b8098efde49eb59cb1671d23c2fe" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;&quot;Postfix Dereference Syntax&quot; in perlref&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c12d31655a68b617bd8f8ac7d7b41ffa97d8df" translate="yes" xml:space="preserve">
          <source>The dereferencing cases (as opposed to method-calling cases) are somewhat extended by the experimental &lt;code&gt;postderef&lt;/code&gt; feature. For the details of that feature, consult &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;Postfix Dereference Syntax in perlref&lt;/a&gt;.</source>
          <target state="translated">Варианты разыменования (в отличие от случаев вызова методов) несколько расширены экспериментальной &lt;code&gt;postderef&lt;/code&gt; . Для получения подробной информации об этой функции обратитесь &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;к синтаксису разыменования постфикса в perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1ecac0ff0943f872a0e4773ff40533e7fc7967" translate="yes" xml:space="preserve">
          <source>The description will also include tags for other special editions, like &quot;R2&quot;, &quot;Media Center&quot;, &quot;Tablet PC&quot;, or &quot;Starter Edition&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06b4b9a1d8e7058531ada60d67614dbcf01dfd0" translate="yes" xml:space="preserve">
          <source>The deserializing hook called on the object during deserialization. But wait: if we're deserializing, there's no object yet... right?</source>
          <target state="translated">Крючок для десериализации вызывал объект во время десериализации.Но подождите:если мы дезериализуем,то пока нет никакого объекта...верно?</target>
        </trans-unit>
        <trans-unit id="8a2f99ef5bda346c32f63e70a7361acb83da8b02" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="translated">Замысел проекта состоит в том, чтобы &lt;code&gt;\d&lt;/code&gt; точно соответствовал набору символов, который можно безопасно использовать с &quot;нормальным&quot; позиционным десятичным синтаксисом с прямым порядком байтов, где, например, 123 означает одну &quot;сотню&quot; плюс две &quot;десятки&quot; плюс три &quot; один. Это позиционное обозначение не обязательно применяется к символам, которые соответствуют другому типу &amp;laquo;цифры&amp;raquo;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , и поэтому &lt;code&gt;\d&lt;/code&gt; им не соответствует.</target>
        </trans-unit>
        <trans-unit id="f61094774e8ce7d5c193ad9edc881d479e0d9584" translate="yes" xml:space="preserve">
          <source>The design intent is for &lt;code&gt;\d&lt;/code&gt; to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one 'hundred', plus two 'tens', plus three 'ones'. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, and so &lt;code&gt;\d&lt;/code&gt; doesn't match them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a51af6f52e45aaf611688acf5b39dc61f9ae40" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&lt;code&gt;``&lt;/code&gt;&lt;/a&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ec3b1b57d74d9cf92c20c7537d430a4cb91982" translate="yes" xml:space="preserve">
          <source>The desire of users to express filenames of the form &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; on the command line unquoted causes problems, too: &lt;code&gt;``&lt;/code&gt; command output capture has to perform a guessing game. It assumes that a string &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; is a reference to an environment variable, whereas anything else involving &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; is redirection, and generally manages to be 99% right. Of course, the problem remains that scripts cannot rely on any Unix tools being available, or that any tools found have Unix-like command line arguments.</source>
          <target state="translated">Желание пользователей выразить имена файлов в форме &lt;code&gt;&amp;lt;Foo$Dir&amp;gt;.Bar&lt;/code&gt; в командной строке без кавычек также вызывает проблемы: &lt;code&gt;``&lt;/code&gt; захват вывода команды должен выполнять игру в угадывание. Предполагается, что строка &lt;code&gt;&amp;lt;[^&amp;lt;&amp;gt;]+\$[^&amp;lt;&amp;gt;]&amp;gt;&lt;/code&gt; является ссылкой на переменную окружения, тогда как все остальное, связанное с &lt;code&gt;&amp;lt;&lt;/code&gt; или &lt;code&gt;&amp;gt;&lt;/code&gt; , является перенаправлением и, как правило, оказывается правильным на 99%. Конечно, проблема остается в том, что сценарии не могут полагаться на какие-либо доступные инструменты Unix или что любые найденные инструменты имеют аргументы командной строки, подобные Unix.</target>
        </trans-unit>
        <trans-unit id="a11af240187e8ce0ea57c0f5d9817fa72798ba59" translate="yes" xml:space="preserve">
          <source>The desired exit status to pass to the &lt;b&gt;exit()&lt;/b&gt; function. This should be an integer, or else the string &quot;NOEXIT&quot; to indicate that control should simply be returned without terminating the invoking process.</source>
          <target state="translated">Желаемый статус выхода для перехода к функции &lt;b&gt;exit ()&lt;/b&gt; . Это должно быть целое число или строка &amp;laquo;NOEXIT&amp;raquo;, указывающая, что управление должно быть просто возвращено без завершения вызывающего процесса.</target>
        </trans-unit>
        <trans-unit id="a47bdc95431692c8deb0f97084523a81a5887de3" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the corresponding value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the corresponding value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed.</source>
          <target state="translated">Желаемый уровень &quot;глаголовой неопределенности&quot; для использования при печати сообщения об использовании.Если соответствующее значение равно 0,то печатается только раздел &quot;SYNOPSIS&quot; документации по подставке.Если соответствующее значение равно 1,то печатается раздел &quot;СИНОПСИС&quot;,а также любой раздел под названием &quot;ВНИМАНИЯ&quot;,&quot;АРГУМЕНТЫ&quot; или &quot;ВНИМАНИЯ И АРГУМЕНТЫ&quot;.Если соответствующее значение равно 2 или более,то печатается вся рабочая страница.</target>
        </trans-unit>
        <trans-unit id="a260934a8f226c98347f68c3fcc330ccf45f5926" translate="yes" xml:space="preserve">
          <source>The desired level of &quot;verboseness&quot; to use when printing the usage message. If the value is 0, then only the &quot;SYNOPSIS&quot; section of the pod documentation is printed. If the value is 1, then the &quot;SYNOPSIS&quot; section, along with any section entitled &quot;OPTIONS&quot;, &quot;ARGUMENTS&quot;, or &quot;OPTIONS AND ARGUMENTS&quot; is printed. If the corresponding value is 2 or more then the entire manpage is printed, using &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; if available; otherwise &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; is used for the formatting. For better readability, the all-capital headings are downcased, e.g. &lt;code&gt;SYNOPSIS&lt;/code&gt; =&amp;gt; &lt;code&gt;Synopsis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3e64d006f3001c3df4472f5962fd664df30c48" translate="yes" xml:space="preserve">
          <source>The desired level of verbosity to use:</source>
          <target state="translated">Желаемый уровень глаголов:</target>
        </trans-unit>
        <trans-unit id="d21703722988891fb3f110d6e6d4a04ddd13048a" translate="yes" xml:space="preserve">
          <source>The destination directory is C:\Symbian\perl\X.Y.Z. For more details, see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8c4d84dbcf0f5f2d69ca16b4ced3235af3fefd" translate="yes" xml:space="preserve">
          <source>The destination for the option must be an array or array reference.</source>
          <target state="translated">Местом назначения опции должен быть массив или ссылка на массив.</target>
        </trans-unit>
        <trans-unit id="409e973fa41301f9011188be107ecc88ef0e437c" translate="yes" xml:space="preserve">
          <source>The details for those items which may deviate from what this emulation returns and what a native &lt;code&gt;nl_langinfo()&lt;/code&gt; would return are specified in &lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N::Langinfo&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2940ce84da888fbb72c23c514c9cdd4e2c7bab4a" translate="yes" xml:space="preserve">
          <source>The detection algorithm works something like this:</source>
          <target state="translated">Алгоритм обнаружения работает примерно так:</target>
        </trans-unit>
        <trans-unit id="8e261118eabba6fd9f550b8549a8f692c8f65be6" translate="yes" xml:space="preserve">
          <source>The develop phase's prereqs are libraries needed to work on the distribution's source code as its author does. These tools might be needed to build a release tarball, to run author-only tests, or to perform other tasks related to developing new versions of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd0b50108607e59344e69b0de3bc9fd4f301247" translate="yes" xml:space="preserve">
          <source>The diagnostics Pragma</source>
          <target state="translated">Диагностика Прагма</target>
        </trans-unit>
        <trans-unit id="9e8272da23da05393615d77b37bcea56278deff5" translate="yes" xml:space="preserve">
          <source>The diagnostics of this test normally just refer to 'the object'. If you'd like them to be more specific, you can supply an $object_name (for example 'Test customer').</source>
          <target state="translated">Диагностика этого теста обычно относится только к &quot;объекту&quot;.Если вы хотите,чтобы они были более конкретными,то можете указать имя $object_name (например,'Test customer').</target>
        </trans-unit>
        <trans-unit id="67027b213e7e98e89fd8e5ebf75f4789f0806d73" translate="yes" xml:space="preserve">
          <source>The diagram below represents a single source stream, with the flow of source from a Perl script file on the left into the Perl parser on the right. This is how Perl normally operates.</source>
          <target state="translated">Диаграмма ниже представляет собой единый поток исходных текстов,с потоком исходных текстов из файла скрипта Perl слева в парсер Perl справа.Так обычно работает Perl.</target>
        </trans-unit>
        <trans-unit id="09d12bc25e1c17128a784d1b2ff7f2b3ea6c5f9e" translate="yes" xml:space="preserve">
          <source>The die on line 4 pops the context stack back down to the CxEVAL, leaving it as:</source>
          <target state="translated">На четвертой строке появляется контекстный стек обратно вниз к CxEVAL,оставляя его как:</target>
        </trans-unit>
        <trans-unit id="930610eed704196a6c02e9606fed36fd7cdf0a59" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , and control returns to the top &lt;code&gt;docatch&lt;/code&gt; . This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="translated">&lt;code&gt;CxEVAL&lt;/code&gt; первый CxEVAL из стека контекста, устанавливает из него &lt;code&gt;PL_restartop&lt;/code&gt; , выполняет &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , и управление возвращается в верхний &lt;code&gt;docatch&lt;/code&gt; . Затем запускается еще один уровень runops третьего уровня, который выполняет операции nextstate, pushmark и die в строке 4. В момент, когда &lt;code&gt;pp_die&lt;/code&gt; второй pp_die , стек вызовов C выглядит точно так же, как указано выше, даже если мы уже не внутри внутренний eval; это из-за оптимизации, упомянутой ранее. Однако стек контекста теперь выглядит так, т.е. с выдвинутым верхним CxEVAL:</target>
        </trans-unit>
        <trans-unit id="bbbbc185d1013ac982e3992e43afeb11193aeae4" translate="yes" xml:space="preserve">
          <source>The die pops the first &lt;code&gt;CxEVAL&lt;/code&gt; off the context stack, sets &lt;code&gt;PL_restartop&lt;/code&gt; from it, does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;, and control returns to the top &lt;code&gt;docatch&lt;/code&gt;. This then starts another third-level runops level, which executes the nextstate, pushmark and die ops on line 4. At the point that the second &lt;code&gt;pp_die&lt;/code&gt; is called, the C call stack looks exactly like that above, even though we are no longer within an inner eval; this is because of the optimization mentioned earlier. However, the context stack now looks like this, ie with the top CxEVAL popped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed5acbfe1a4a69e2eecb34b13c8306880da82cf" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt; , is that those generated subroutines:</source>
          <target state="translated">Разница между &lt;code&gt;extract_tagged&lt;/code&gt; и анонимными подпрограммами, сгенерированными &lt;code&gt;gen_extract_tagged&lt;/code&gt; , заключается в том, что эти сгенерированные подпрограммы:</target>
        </trans-unit>
        <trans-unit id="4192a9e6844188f610795705ae7b4477088fe04b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;extract_tagged&lt;/code&gt; and the anonymous subroutines generated by &lt;code&gt;gen_extract_tagged&lt;/code&gt;, is that those generated subroutines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6f28f40692ae97e2ea2e8080e59d267505ccf0" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;minlen&lt;/code&gt; and &lt;code&gt;minlenret&lt;/code&gt; can be seen in the following pattern:</source>
          <target state="translated">Разницу между &lt;code&gt;minlen&lt;/code&gt; и &lt;code&gt;minlenret&lt;/code&gt; можно увидеть в следующем образце:</target>
        </trans-unit>
        <trans-unit id="f8ae9fbf98646f2ef8526e7b39bf817f11262438" translate="yes" xml:space="preserve">
          <source>The difference between a block and a script is that scripts are closer to the linguistic notion of a set of code points required to represent languages, while block is more of an artifact of the Unicode code point numbering and separation into blocks of consecutive code points (so far the size of a block is some multiple of 16, like 128 or 256).</source>
          <target state="translated">Отличие блока от скрипта состоит в том,что скрипты ближе к языковому понятию набора точек кода,необходимых для представления языков,в то время как блок является скорее артефактом нумерации точек кода Юникода и разделения на блоки последовательных точек кода (до сих пор размер блока несколько кратный 16,например 128 или 256).</target>
        </trans-unit>
        <trans-unit id="4e0fd5df1eb8c3e578915cd6f8934c4fe5cf676a" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt; . Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="translated">Разница между этими двумя свойствами заключается в символах, которые используются в нескольких скриптах. Например, цифры от &amp;laquo;0&amp;raquo; до &amp;laquo;9&amp;raquo; используются во многих частях мира. Они помещаются в скрипт с именем &lt;code&gt;Common&lt;/code&gt; . Другие символы используются всего в нескольких сценариях. Например, &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; используется в обоих японских шрифтах, Катакане и Хирагане, но больше нигде. Свойство &lt;code&gt;Script&lt;/code&gt; помещает все символы, которые используются в нескольких сценариях, в &lt;code&gt;Common&lt;/code&gt; сценарий, а свойство &lt;code&gt;Script_Extensions&lt;/code&gt; помещает символы , которые используются только в нескольких сценариях, в каждый из этих сценариев; пока все еще используется &lt;code&gt;Common&lt;/code&gt; для тех, которые используются во многих скриптах. Таким образом, оба эти совпадения:</target>
        </trans-unit>
        <trans-unit id="6e605910d48501bdad38af7496eb4f572c4cfa33" translate="yes" xml:space="preserve">
          <source>The difference between these two properties involves characters that are used in multiple scripts. For example the digits '0' through '9' are used in many parts of the world. These are placed in a script named &lt;code&gt;Common&lt;/code&gt;. Other characters are used in just a few scripts. For example, the &lt;code&gt;&quot;KATAKANA-HIRAGANA DOUBLE HYPHEN&quot;&lt;/code&gt; is used in both Japanese scripts, Katakana and Hiragana, but nowhere else. The &lt;code&gt;Script&lt;/code&gt; property places all characters that are used in multiple scripts in the &lt;code&gt;Common&lt;/code&gt; script, while the &lt;code&gt;Script_Extensions&lt;/code&gt; property places those that are used in only a few scripts into each of those scripts; while still using &lt;code&gt;Common&lt;/code&gt; for those used in many scripts. Thus both these match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc2b3e05da478b77fc3b12b2fa311b0e5889311" translate="yes" xml:space="preserve">
          <source>The difference here is the addition of the temporary variable &lt;code&gt;$data&lt;/code&gt;. This is used to store a copy of the compressed data while it is being uncompressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f324cedd823e628f1ed8025386bfb26cab3778ab" translate="yes" xml:space="preserve">
          <source>The difference is clear to see and the dereferencing approach is slower. While it managed to execute an average of 628,930 times a second during our test, the direct approach managed to run an additional 204,403 times, unfortunately. Unfortunately, because there are many examples of code written using the multiple layer direct variable access, and it's usually horrible. It is, however, minusculy faster. The question remains whether the minute gain is actually worth the eyestrain, or the loss of maintainability.</source>
          <target state="translated">Разница очевидна,а подход с использованием разыменования происходит медленнее.В то время как во время нашего теста ему удалось выполнить в среднем 628 930 раз в секунду,при прямом подходе,к сожалению,удалось выполнить еще 204 403 раза.К сожалению,потому что примеров кода,написанного с использованием многоуровневого прямого доступа к переменным,много,и это,как правило,ужасно.Однако он работает в несколько раз быстрее.Остается вопрос,стоит ли на самом деле минутный выигрыш зрительного нерва,или же это потеря удобства обслуживания.</target>
        </trans-unit>
        <trans-unit id="c9d466e6cdc3e3b171ba671cc22acace7243054b" translate="yes" xml:space="preserve">
          <source>The difference is the sigil, that special character in front of the array name. The &lt;code&gt;$&lt;/code&gt; sigil means &quot;exactly one item&quot;, while the &lt;code&gt;@&lt;/code&gt; sigil means &quot;zero or more items&quot;. The &lt;code&gt;$&lt;/code&gt; gets you a single scalar, while the &lt;code&gt;@&lt;/code&gt; gets you a list.</source>
          <target state="translated">Разница в сигиле, специальном символе перед именем массива. Символ &lt;code&gt;$&lt;/code&gt; означает &amp;laquo;ровно один элемент&amp;raquo;, а символ &lt;code&gt;@&lt;/code&gt; означает &amp;laquo;ноль или более элементов&amp;raquo;. &lt;code&gt;$&lt;/code&gt; Получает вас один скаляр, в то время как &lt;code&gt;@&lt;/code&gt; получает вам список.</target>
        </trans-unit>
        <trans-unit id="82ff75d7fe49900a75f8b7a1628df2b78931946c" translate="yes" xml:space="preserve">
          <source>The difference to &lt;code&gt;incr_reset&lt;/code&gt; is that only text until the parse error occurred is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b0921f524dbbf7564616e5853365d0c767bfc6" translate="yes" xml:space="preserve">
          <source>The digest can be delivered in three formats:</source>
          <target state="translated">Дайджест может быть доставлен в трех форматах:</target>
        </trans-unit>
        <trans-unit id="0155d0c091234cee22dc790957626f27306487e0" translate="yes" xml:space="preserve">
          <source>The direction you must follow the great circle (also known as</source>
          <target state="translated">Направление,в котором вы должны следовать по большому кругу (также известному как</target>
        </trans-unit>
        <trans-unit id="03d134305af0df1045ab396312ef86cfab55c5d9" translate="yes" xml:space="preserve">
          <source>The direction you would have to go from London to Tokyo (in radians, straight north being zero, straight east being pi/2).</source>
          <target state="translated">Направление от Лондона до Токио (в радиусах,прямо на север-ноль,прямо на восток-пи/2).</target>
        </trans-unit>
        <trans-unit id="9159a72a045b505fc788bec97c5202fb7f87247c" translate="yes" xml:space="preserve">
          <source>The directory portion may or may not be returned with a trailing '/'.</source>
          <target state="translated">Часть каталога может возвращаться или не возвращаться с замыкающим символом &quot;/&quot;.</target>
        </trans-unit>
        <trans-unit id="efd54b0e8774d4521e37e9c7dad7074640dfad53" translate="yes" xml:space="preserve">
          <source>The directory you are put into when you log in. On a Unix system, the name is often placed into &lt;code&gt;$ENV{HOME}&lt;/code&gt; or &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; by</source>
          <target state="translated">Каталог, в который вы попадаете при входе в систему. В системе Unix имя часто помещается в &lt;code&gt;$ENV{HOME}&lt;/code&gt; или &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; помощью</target>
        </trans-unit>
        <trans-unit id="0f834768c044521ed2139a347066ecd1f6fd454d" translate="yes" xml:space="preserve">
          <source>The directory, if specified, must appear immediately following the &lt;b&gt;-x&lt;/b&gt; with no intervening whitespace.</source>
          <target state="translated">Каталог, если он указан, должен располагаться сразу после &lt;b&gt;-x&lt;/b&gt; без пробелов.</target>
        </trans-unit>
        <trans-unit id="d7f8724048da79577878989633dd2a49c69c9ec2" translate="yes" xml:space="preserve">
          <source>The display name describes the native Windows version, so even on a 32-bit Perl this function may return a &quot;Windows ... (64-bit)&quot; name when running on a 64-bit Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33156bb6057d33c4b599fbfc979b33f776601d44" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;OBJECT&lt;/code&gt; and &lt;code&gt;LDFROM&lt;/code&gt;: &lt;code&gt;OBJECT&lt;/code&gt; is the make target, so make will try to build it. However, &lt;code&gt;LDFROM&lt;/code&gt; is what will actually be linked together to make the shared object or static library (SO/SL), so if you override it, make sure it includes what you want to make the final SO/SL, almost certainly including the XS basename with &lt;code&gt;$(OBJ_EXT)&lt;/code&gt; appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52decfdd93c450a71874ee33c51b4afa2f1bd5c0" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU General Public License version 2 (&lt;a href=&quot;http://opensource.org/licenses/GPL-2.0&quot;&gt;http://opensource.org/licenses/GPL-2.0&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f7a312b10d8dba569018003de4b4d745d6733e" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU General Public License version 2 (&lt;a href=&quot;https://opensource.org/licenses/GPL-2.0&quot;&gt;http://opensource.org/licenses/GPL-2.0&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cba2181eae9ea18443bd663a1f8c3a87fbabe62" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU Lesser General Public License version 2 (&lt;a href=&quot;http://opensource.org/licenses/LGPL-2.1&quot;&gt;http://opensource.org/licenses/LGPL-2.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3177a2d254e4049cd5703a62b3c7254c5901cf" translate="yes" xml:space="preserve">
          <source>The distribution is distributed under the terms of the GNU Lesser General Public License version 2 (&lt;a href=&quot;https://opensource.org/licenses/LGPL-2.1&quot;&gt;http://opensource.org/licenses/LGPL-2.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4888c0e08e74f6e2698369bc2f948843f746c57a" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under a license that is &lt;b&gt;not&lt;/b&gt; approved by &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org&lt;/a&gt; but that allows distribution without restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18e66ed77e39494025272eb1fa0055f83f4e24c" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under a license that is not approved by &lt;a href=&quot;http://www.opensource.org/&quot;&gt;www.opensource.org&lt;/a&gt; but that allows distribution without restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f50f8aa35b8ab9124cad20b747796d784792a1" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under some other Open Source Initiative-approved license listed at &lt;a href=&quot;http://www.opensource.org/licenses/&quot;&gt;http://www.opensource.org/licenses/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78bde88df9f9ec717c7aea6abe37d463f7f3091" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Apache Software License version 1.1 (&lt;a href=&quot;http://opensource.org/licenses/Apache-1.1&quot;&gt;http://opensource.org/licenses/Apache-1.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41c56048d495f68fa17d2702a6fae9331220570" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Apache Software License version 1.1 (&lt;a href=&quot;https://opensource.org/licenses/Apache-1.1&quot;&gt;http://opensource.org/licenses/Apache-1.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de749c864adb80ca7d1e8d280af821d8d4c9935" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Artistic License version 1, as specified by the Artistic file in the standard perl distribution (&lt;a href=&quot;http://opensource.org/licenses/Artistic-Perl-1.0&quot;&gt;http://opensource.org/licenses/Artistic-Perl-1.0&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493bdb23a0c07973b365570b83f58ceb6c2dfba1" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Artistic License version 1, as specified by the Artistic file in the standard perl distribution (&lt;a href=&quot;https://opensource.org/licenses/Artistic-Perl-1.0&quot;&gt;http://opensource.org/licenses/Artistic-Perl-1.0&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ac3a668622bd0a049080f2c7b27295e3ec4b97" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the BSD 3-Clause License (&lt;a href=&quot;http://opensource.org/licenses/BSD-3-Clause&quot;&gt;http://opensource.org/licenses/BSD-3-Clause&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a5dbb9763d0d32992216b7fadd31ff3a133d07" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the BSD 3-Clause License (&lt;a href=&quot;https://opensource.org/licenses/BSD-3-Clause&quot;&gt;http://opensource.org/licenses/BSD-3-Clause&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b566ce554e210d4ce11e3e299eeba816ff34110" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the MIT License (&lt;a href=&quot;http://opensource.org/licenses/MIT&quot;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b444ccbec19f09693c3d3d959fed672cb70e08" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the MIT License (&lt;a href=&quot;https://opensource.org/licenses/MIT&quot;&gt;http://opensource.org/licenses/MIT&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aac6612aedc9abedbc7808782068e6b14c9dad1" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Mozilla Public License. (&lt;a href=&quot;http://opensource.org/licenses/MPL-1.0&quot;&gt;http://opensource.org/licenses/MPL-1.0&lt;/a&gt; or &lt;a href=&quot;http://opensource.org/licenses/MPL-1.1&quot;&gt;http://opensource.org/licenses/MPL-1.1&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62105cabd05f5d5f502b03e9dc993cb390c00140" translate="yes" xml:space="preserve">
          <source>The distribution is licensed under the Mozilla Public License. (&lt;a href=&quot;https://opensource.org/licenses/MPL-1.0&quot;&gt;http://opensource.org/licenses/MPL-1.0&lt;/a&gt; or &lt;a href=&quot;https://opensource.org/licenses/MPL-1.1&quot;&gt;http://opensource.org/licenses/MPL-1.1&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ec48fe5b9db3aa7699bae9e6f37f57f64c6873" translate="yes" xml:space="preserve">
          <source>The distribution may be copied and redistributed under the same terms as perl itself (this is by far the most common licensing option for modules on CPAN). This is a dual license, in which the user may choose between either the GPL or the Artistic license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6a3b8d2999345748a288e76e75c0daa029db33" translate="yes" xml:space="preserve">
          <source>The distribution may be copied and redistributed under the same terms as perl itself (this is by far the most common licensing option for modules on CPAN). This is a dual license, in which the user may choose between either the GPL version 1 or the Artistic version 1 license.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68561decd1a625d00c793764ccc0278b512e1101" translate="yes" xml:space="preserve">
          <source>The distribution may not be redistributed without special permission from the author and/or copyright holder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b84d36cdfd8993b5da988b0d1072e922c4f772" translate="yes" xml:space="preserve">
          <source>The distribution metadata for a CPAN dist</source>
          <target state="translated">Метаданные распределения для дистрибутива CPAN</target>
        </trans-unit>
        <trans-unit id="36683b868091d21c8930b291476202549c6dcddb" translate="yes" xml:space="preserve">
          <source>The distribution of a bundle should follow the same convention as other distributions.</source>
          <target state="translated">Распределение пакета должно соответствовать той же конвенции,что и другие распределения.</target>
        </trans-unit>
        <trans-unit id="51432e8130a916aea0132035b34ce241b04f9cf8" translate="yes" xml:space="preserve">
          <source>The distroprefs system of &lt;code&gt;CPAN.pm&lt;/code&gt; addresses this problem by allowing the user to specify extra informations and recipes in YAML files to either</source>
          <target state="translated">Система distroprefs &lt;code&gt;CPAN.pm&lt;/code&gt; решает эту проблему, позволяя пользователю указывать дополнительную информацию и рецепты в файлах YAML, чтобы либо</target>
        </trans-unit>
        <trans-unit id="593a274a7d2141476dcb8b11db34f2f4536141e3" translate="yes" xml:space="preserve">
          <source>The division (/) and the following functions</source>
          <target state="translated">Разделение (/)и следующие функции</target>
        </trans-unit>
        <trans-unit id="863f717363dbe8d220d352a111c6c709f1a560be" translate="yes" xml:space="preserve">
          <source>The djgpp environment for DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; and &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;.</source>
          <target state="translated">Среда djgpp для DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; и &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02d01132aeec36ca260315fce03b39bb29168535" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="translated">Эквиваленты типа &amp;laquo;сделай или умри&amp;raquo; устанавливаются простым вызовом процедуры &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; Fatal , передавая ей имена заменяемых функций. Таким способом можно заключить как пользовательские функции, так и переопределяемые операторы CORE (кроме &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; или любых других встроенных функций, которые не могут быть выражены через прототипы).</target>
        </trans-unit>
        <trans-unit id="d89559d6a4bade96c4b212e54a4534bbb62aa15a" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;import&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15384d55904491a7259b275ff7854d9b17c0ddff" translate="yes" xml:space="preserve">
          <source>The documentation below is only for the methods of the CPAN::Meta object. For information on the meaning of individual fields, consult the spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467707c3656000f994482e7ea5cafe87685ee6c8" translate="yes" xml:space="preserve">
          <source>The documentation for the Perl API explains what some of the internal functions do, as well as the many macros used in the source.</source>
          <target state="translated">Документация по Perl API объясняет,что делают некоторые внутренние функции,а также многие макросы,используемые в исходных текстах.</target>
        </trans-unit>
        <trans-unit id="f1c9061e68c820097f175c9e3bd485176b2a01c2" translate="yes" xml:space="preserve">
          <source>The documentation of &lt;a href=&quot;Locale::Maketext&quot;&gt;Locale::Maketext&lt;/a&gt; advises that the standard bracket method &lt;code&gt;numf&lt;/code&gt; is limited and that you must override that for better results. It even suggests the use of &lt;a href=&quot;Number::Format&quot;&gt;Number::Format&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae102196b6b483518d27e0d97d3595cd35f7b66" translate="yes" xml:space="preserve">
          <source>The dot</source>
          <target state="translated">Точка</target>
        </trans-unit>
        <trans-unit id="3f38f6b4980cd9d2e94100bc5fdda9f827f655ac" translate="yes" xml:space="preserve">
          <source>The dot (or period), &lt;code&gt;.&lt;/code&gt; is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the</source>
          <target state="translated">Точка (или период) &lt;code&gt;.&lt;/code&gt; вероятно, наиболее часто используемый и, безусловно, самый известный класс символов. По умолчанию точка соответствует любому символу, кроме символа новой строки. Это значение по умолчанию можно изменить, чтобы добавить соответствие новой строке, используя</target>
        </trans-unit>
        <trans-unit id="a8d050074e0d8db225e0ced36924986b2d59e591" translate="yes" xml:space="preserve">
          <source>The dynamic nature of the regular expression variables means that their value is limited to the block that they are in, as demonstrated by this bit of code:</source>
          <target state="translated">Динамическая природа переменных регулярных выражений означает,что их значение ограничено блоком,в котором они находятся,что демонстрирует данный бит кода:</target>
        </trans-unit>
        <trans-unit id="4214b1d60eaaef0d8bb7337abe8a20ad57121d02" translate="yes" xml:space="preserve">
          <source>The earliest development of &lt;code&gt;newgetopt.pl&lt;/code&gt; started in 1990, with Perl version 4. As a result, its development, and the development of Getopt::Long, has gone through several stages. Since backward compatibility has always been extremely important, the current version of Getopt::Long still supports a lot of constructs that nowadays are no longer necessary or otherwise unwanted. This section describes briefly some of these 'features'.</source>
          <target state="translated">Самая ранняя разработка &lt;code&gt;newgetopt.pl&lt;/code&gt; началась в 1990 году с Perl версии 4. В результате его разработка и разработка Getopt :: Long прошли несколько этапов. Поскольку обратная совместимость всегда была чрезвычайно важна, текущая версия Getopt :: Long по-прежнему поддерживает множество конструкций, которые в настоящее время больше не нужны или нежелательны. В этом разделе кратко описаны некоторые из этих &amp;laquo;функций&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a629fbdcc51d0664a749c16709dba8d145f34d93" translate="yes" xml:space="preserve">
          <source>The easier it is to reproduce your bug, the more likely it will be fixed -- if nobody can duplicate your problem, it probably won't be addressed.</source>
          <target state="translated">Чем проще воспроизвести вашу ошибку,тем больше вероятность того,что она будет исправлена-если никто не сможет дублировать вашу проблему,она,скорее всего,не будет устранена.</target>
        </trans-unit>
        <trans-unit id="a0f603eb4b75174f5f5f8c92980d04d40846be1f" translate="yes" xml:space="preserve">
          <source>The easier it is to understand a reproducible bug, the more likely it will be fixed. Any insight you can provide into the problem will help a great deal. In other words, try to analyze the problem (to the extent you can) and report your discoveries.</source>
          <target state="translated">Чем легче понять воспроизводимую ошибку,тем больше вероятность того,что она будет исправлена.Любое понимание проблемы,которое вы можете дать,очень поможет.Другими словами,постарайтесь проанализировать проблему (насколько это возможно)и сообщить о своих открытиях.</target>
        </trans-unit>
        <trans-unit id="affd4579291392539b898984b2d64fdfbc46e13c" translate="yes" xml:space="preserve">
          <source>The easiest and most portable option available for creating your own source filter is to write it completely in Perl. To distinguish this from the previous two techniques, I'll call it a Perl source filter.</source>
          <target state="translated">Самый простой и портативный вариант,доступный для создания собственного исходного фильтра-полностью записать его на Perl.Чтобы отличить это от двух предыдущих методов,я назову его фильтром исходных текстов на Perl.</target>
        </trans-unit>
        <trans-unit id="74aa13205a264868ad41eb543a1a088589f0736a" translate="yes" xml:space="preserve">
          <source>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</source>
          <target state="translated">Самое простое концептуальное решение заключается в том,чтобы считать строки в файле,затем начать с начала и вывести количество строк (минус последняя N)в новый файл.</target>
        </trans-unit>
        <trans-unit id="06308af6d2242e4fa49dd6cd28115c9993df529e" translate="yes" xml:space="preserve">
          <source>The easiest way is to have a module also named CPAN do it for you by using the &lt;code&gt;cpan&lt;/code&gt; command that comes with Perl. You can give it a list of modules to install:</source>
          <target state="translated">Самый простой способ - сделать это за вас модуль, также называемый CPAN, с помощью команды &lt;code&gt;cpan&lt;/code&gt; , поставляемой с Perl. Вы можете указать ему список модулей для установки:</target>
        </trans-unit>
        <trans-unit id="2cfa0d7d193c99cb54063076caae508cae649aa1" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ecd0af899536563eb76ce8a93b28def2b41789" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="translated">Самый простой способ сделать это - прочитать ключ в неблокирующем режиме с &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;помощью&lt;/a&gt; модуля Term :: ReadKey из CPAN, передав ему аргумент -1, чтобы указать не блокировать:</target>
        </trans-unit>
        <trans-unit id="3b2853b05b0394d3d1c3bfe698cbfe924daa1822" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;B::Terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt; and CPAN module &amp;lt;B::Debug do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab82d3c686ea0162144c8d6cfd2e56593a5e530" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;b/terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt; and &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt; do.</source>
          <target state="translated">Самый простой способ проверить дерево операций - остановить Perl после того, как он завершит синтаксический анализ, и заставить его выгружать дерево. Это именно то, что &lt;a href=&quot;b/terse&quot;&gt;делают бэкенды&lt;/a&gt; компилятора B :: Terse , &lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt; и &lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e420b4167196d87c0672e2ec36244ffaaeacf17d" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt; ) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="translated">Самый простой способ получить шаблонный набор макросов для использования - это указать параметр &lt;code&gt;-g&lt;/code&gt; ( &lt;code&gt;--global&lt;/code&gt; ) с помощью h2xs (см. &lt;a href=&quot;h2xs&quot;&gt;H2xs&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c6326467cfffc66387125a93100da358b0b5c86" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt;) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c9c21dcd497445970db52d8583cffea3bdb68e" translate="yes" xml:space="preserve">
          <source>The easiest way to specify an individual typable character is to enclose it in brackets:</source>
          <target state="translated">Самый простой способ указать индивидуальный печатный символ-заключить его в скобки:</target>
        </trans-unit>
        <trans-unit id="d739701e48fac0ec01f64967528c5978352a4aef" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;B::Deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt;, one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b4571e42b1eb8646fcc517dc4040a5571233f2" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt; , one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="translated">Самый простой способ узнать, была ли подпрограмма встроена, - использовать &lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt; . Рассмотрим этот пример двух подпрограмм, возвращающих &lt;code&gt;1&lt;/code&gt; , одна с прототипом &lt;code&gt;()&lt;/code&gt; , заставляющим его быть встроенным, а другая без (с усеченным для ясности выводом):</target>
        </trans-unit>
        <trans-unit id="0f8acfaed2cccc718ab47b22e571180e63f71aac" translate="yes" xml:space="preserve">
          <source>The easiest way to test is to do something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0eee7295ee278e006e907a6f9a925e3a5df708" translate="yes" xml:space="preserve">
          <source>The easist way to deal with this issue is to use the pre-defined &quot;utf8&quot; &lt;b&gt;DBM_Filter&lt;/b&gt; (see &lt;a href=&quot;dbm_filter&quot;&gt;DBM_Filter&lt;/a&gt;) that was designed to deal with this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1861cd9be51843a146c51b85f741a8d483f14173" translate="yes" xml:space="preserve">
          <source>The easy answer is &quot;Don't do that!&quot;</source>
          <target state="translated">Легкий ответ:&quot;Не делай этого!&quot;</target>
        </trans-unit>
        <trans-unit id="8aef9d5f47b23df02c1f4b866ddffffba9a2ae25" translate="yes" xml:space="preserve">
          <source>The effect of &lt;code&gt;:std&lt;/code&gt; is not lexical as it modifies the layer stack of the global handles. If you wish to apply only this global effect and not the effect on handles that are opened in that scope, you can isolate the call to this pragma in its own lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4605050fae7c9f6ca47b8c647d8260a448789c" translate="yes" xml:space="preserve">
          <source>The effect of multiple &lt;code&gt;-I&lt;/code&gt; options is to &lt;code&gt;unshift&lt;/code&gt; them onto &lt;code&gt;@INC&lt;/code&gt; from right to left. So for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0597cca28cb7230a0e356c17782e46be9384f5c8" translate="yes" xml:space="preserve">
          <source>The effect of using &quot;failure_auto_handler&quot; is like an AUTO lexicon, except that it 1) compiles $key even if it starts with &quot;_&quot;, and 2) you have a record in the new hashref $lh-&amp;gt;{'failure_lex'} of all the keys that have failed for this object. This should avoid your program dying -- as long as your keys aren't actually invalid as bracket code, and as long as they don't try calling methods that don't exist.</source>
          <target state="translated">Эффект от использования &amp;laquo;failure_auto_handler&amp;raquo; похож на лексикон AUTO, за исключением того, что он 1) компилирует $ key, даже если он начинается с &amp;laquo;_&amp;raquo;, и 2) у вас есть запись в новом хэше $ lh -&amp;gt; {'failure_lex'} всех ключей, которые вышли из строя для этого объекта. Это должно избежать смерти вашей программы - пока ваши ключи не являются недействительными как код в скобках, и пока они не пытаются вызывать методы, которых не существует.</target>
        </trans-unit>
        <trans-unit id="e111bef16ba68c39a0b6040a000b635141c8f1f2" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">Эффективный гид этого процесса. Если вы находитесь на машине, которая поддерживает членство в нескольких группах одновременно, выдает список групп, в которых вы &lt;code&gt;getegid()&lt;/code&gt; через пробел . Первое число - это число, возвращаемое функцией getegid () , а последующие - &lt;code&gt;getgroups()&lt;/code&gt; , одна из которых может быть таким же, как первое число.</target>
        </trans-unit>
        <trans-unit id="c57c7b93a855188d4ab0c627a896d86afd3718eb" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391c814eb86428160d8ecfb1e5d99a0a23856f18" translate="yes" xml:space="preserve">
          <source>The effective uid of this process. For example:</source>
          <target state="translated">Эффективное завершение этого процесса.Например:</target>
        </trans-unit>
        <trans-unit id="78e522cbb08752f888e4a4c422be723520118862" translate="yes" xml:space="preserve">
          <source>The element &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; is special: when read, it returns Perl's current default device and directory, and when set, it resets them, regardless of the definition of</source>
          <target state="translated">Элемент &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; является особенным: при чтении он возвращает текущее устройство и каталог Perl по умолчанию, а когда установлен, он сбрасывает их, независимо от определения</target>
        </trans-unit>
        <trans-unit id="1927e85810982ff4bedcbd8fe6ac46c4f4acfd36" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">Элемент представляет собой хеш, инициализированный по умолчанию как &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2bffd6b7ca0e9e867ed8229203222ba2cd6dd2" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010155a37e502b613f4bf666146b070b50ac9cf2" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;Initializing with new&lt;/a&gt;).</source>
          <target state="translated">Элемент является скаляром и по умолчанию инициализируется &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (но см. &lt;a href=&quot;#Initializing-with-new&quot;&gt;Инициализация с новым&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f75fd8ea331a93e38c3ea51d7c4505b3a3d036f7" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;undef&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;&quot;Initializing with new&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7fe592a2def98474e3260c74013058ff355fc6" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">Элемент представляет собой массив, инициализированный по умолчанию как &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52aeddd404b7b928ef7ca86f1f29047b71eeb8ca" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942bdb865668cc5d25526303c780ec9824d73845" translate="yes" xml:space="preserve">
          <source>The element's value must be a reference blessed to the named class or to one of its subclasses. The element is not initialized by default.</source>
          <target state="translated">Значение элемента должно быть ссылкой,благословленной на именованный класс или на один из его подклассов.По умолчанию элемент не инициализируется.</target>
        </trans-unit>
        <trans-unit id="96e4b34c1d85fc2315f1a2e433a4a09c9e1219d5" translate="yes" xml:space="preserve">
          <source>The elements must be identical</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb20ee6aa799cc8c00cade7ca9b921cb0624824" translate="yes" xml:space="preserve">
          <source>The elements we're getting from the array start with a &lt;code&gt;$&lt;/code&gt; because we're getting just a single value out of the array; you ask for a scalar, you get a scalar.</source>
          <target state="translated">Элементы, которые мы получаем из массива, начинаются с символа &lt;code&gt;$&lt;/code&gt; , потому что мы получаем только одно значение из массива; вы просите скаляр, вы получаете скаляр.</target>
        </trans-unit>
        <trans-unit id="c2d2a5272ddb492896f4b1aa2fdc89f7d8b57cf1" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement, since the &lt;code&gt;...&lt;/code&gt; is also the three-dot version of the flip-flop operator (see &lt;a href=&quot;perlop#Range-Operators&quot;&gt;Range Operators in perlop&lt;/a&gt;).</source>
          <target state="translated">Эллиптический оператор не может заменять выражение, которое является частью более крупного оператора, поскольку &lt;code&gt;...&lt;/code&gt; также является &lt;a href=&quot;perlop#Range-Operators&quot;&gt;трехточечной версией&lt;/a&gt; оператора триггера (см. Операторы диапазона в perlop ).</target>
        </trans-unit>
        <trans-unit id="81b37f465ff28273358e52fdc4fa0d8ce3005267" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement. These examples of attempts to use an ellipsis are syntax errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545891d79255fc3bc69760f930c3f25bc8ae8965" translate="yes" xml:space="preserve">
          <source>The email you got when you received your CPAN ID will tell you how to log in to PAUSE, the Perl Authors Upload SErver. From the menus there, you can upload your module to CPAN.</source>
          <target state="translated">Электронное сообщение,которое вы получили после получения вашего CPAN ID,расскажет вам,как войти в PAUSE,Perl Authors Upload SErver.Из меню там вы можете загрузить свой модуль в CPAN.</target>
        </trans-unit>
        <trans-unit id="327ff1bdde855523cde51b50cbe96fda9133ba11" translate="yes" xml:space="preserve">
          <source>The empty pattern &lt;code&gt;//&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4129d1babbccbe45b1d8ec086eee7286a139eb46" translate="yes" xml:space="preserve">
          <source>The encoding being specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64546adcd99f15ed4491ee50ced298a5f03d14c6" translate="yes" xml:space="preserve">
          <source>The encoding event is generated when a test file wants to specify the encoding to be used when formatting its output. This event is intended to be produced by formatter classes and used for interpreting test names, message contents, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588a9b522600848c7a034e730acfdc94a0b61885" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, on entry the PV of the sv is assumed to be octets in that encoding, and the sv will be converted into Unicode (and UTF-8).</source>
          <target state="translated">Предполагается,что кодировка-это объект Encode,при вводе PV sv предполагается,что это октеты в этой кодировке,а sv будет преобразовано в Unicode (и UTF-8).</target>
        </trans-unit>
        <trans-unit id="2aac7e4350e18d454240d654ed5501855f5c3e7e" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, the PV of the ssv is assumed to be octets in that encoding and decoding the input starts from the position which (PV + *offset) pointed to. The dsv will be concatenated the decoded UTF-8 string from ssv. Decoding will terminate when the string tstr appears in decoding output or the input ends on the PV of the ssv. The value which the offset points will be modified to the last input position on the ssv.</source>
          <target state="translated">Предполагается,что кодировка-это объект Encode,а PV ssv-октеты в этой кодировке,и декодирование входного сигнала начинается с позиции,на которую (PV+*offset)указывает.dsv будет сконцентрирована декодированная строка UTF-8 из ssv.Декодирование завершится,когда в выводе кодировки появится строка tstr или когда входная кодировка закончится на PV ssv.Значение,в котором точки смещения будут изменены на последнюю входную позицию на ssv.</target>
        </trans-unit>
        <trans-unit id="e2d9b11db298559d7d705aec3e36d98ebb2389cc" translate="yes" xml:space="preserve">
          <source>The encoding name determined to be suitable for file system interfaces involving file names. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know this encoding as &quot;locale_fs&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050d2bf9033fce6c43078983175c16f9530f4831" translate="yes" xml:space="preserve">
          <source>The encoding name determined to be suitable for the current locale. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know this encoding as &quot;locale&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3062423073ff3110a760ac5983fd2a737512781" translate="yes" xml:space="preserve">
          <source>The encoding pragma is not supported on EBCDIC platforms.</source>
          <target state="translated">Прагма кодирования не поддерживается на платформах EBCDIC.</target>
        </trans-unit>
        <trans-unit id="04abf26a5ca58977d603141fc0ef79876490369d" translate="yes" xml:space="preserve">
          <source>The encoding requested is not supported by the Encode module.</source>
          <target state="translated">Запрашиваемая кодировка не поддерживается кодировочным модулем.</target>
        </trans-unit>
        <trans-unit id="dc406e81e6f88430afa8892d13871c0d72a82fe4" translate="yes" xml:space="preserve">
          <source>The encoding that corresponds to ANSI varies between different editions of Windows. For many western editions of Windows ANSI corresponds to CP-1252 which is a character set similar to ISO-8859-1. Conceptually the ANSI character set is a similar concept to the POSIX locale CODESET so this module figures out what the ANSI code page is and make this available as $ENCODING_LOCALE and the &quot;locale&quot; Encoding alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b0be99c7e0fde92c59a2dde4b75bd2c5e6a66a" translate="yes" xml:space="preserve">
          <source>The encodings of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are individually settable by parameters to the pragma:</source>
          <target state="translated">Кодировки &lt;code&gt;STDIN&lt;/code&gt; и &lt;code&gt;STDOUT&lt;/code&gt; настраиваются индивидуально с помощью параметров прагмы:</target>
        </trans-unit>
        <trans-unit id="6d62118e6065a9d454aaecd74844f2def3aa8534" translate="yes" xml:space="preserve">
          <source>The encodings to be used for reading and writing output to the a console. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; know these encodings as &quot;console_in&quot; and &quot;console_out&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d58ea5991c657606e31a1ebddfdcbdfe42b5a94" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt; . In this example the data structure returned will look like this</source>
          <target state="translated">Конечным результатом всего этого является список пар имен файлов. По умолчанию это то, что возвращает &lt;code&gt;globmap&lt;/code&gt; . В этом примере возвращенная структура данных будет выглядеть так</target>
        </trans-unit>
        <trans-unit id="d6253ff05c4cc919ddf707ca73edb1a406fe9c35" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt;. In this example the data structure returned will look like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fda9b67eec164f9ff303e259fb27be29ca04c85" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;pack()&lt;/code&gt; Perl function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66180c8b26ee487f27a0dc49b26d2d5244b75b6e" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;pack()&lt;/code&gt; Perl function. Note: parameters &lt;code&gt;next_in_list&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; are not used. This call should not be used; use &lt;code&gt;packlist&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463670dd77f9d4b250cfbf1933d859da20649fdf" translate="yes" xml:space="preserve">
          <source>The engine implementing &lt;code&gt;unpack()&lt;/code&gt; Perl function. Note: parameters &lt;code&gt;strbeg&lt;/code&gt;, &lt;code&gt;new_s&lt;/code&gt; and &lt;code&gt;ocnt&lt;/code&gt; are not used. This call should not be used, use &lt;code&gt;unpackstring&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733a0f46f2e4433da326d8b3d8649ddcec9e6f67" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function.</source>
          <target state="translated">Движок,реализующий функцию pack()Perl.</target>
        </trans-unit>
        <trans-unit id="3347858c5b43f539e0e1c803ce10b0c1e284b3a5" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function. Note: parameters next_in_list and flags are not used. This call should not be used; use packlist instead.</source>
          <target state="translated">Движок,реализующий функцию pack()Perl.Замечание:параметры next_in_list и флаги не используются.Этот вызов не должен использоваться,вместо этого используйте packlist.</target>
        </trans-unit>
        <trans-unit id="1108f56aaa943f349a8b769e2a9d1fa1d3614cf4" translate="yes" xml:space="preserve">
          <source>The engine implementing the &lt;code&gt;unpack()&lt;/code&gt; Perl function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5023a760442586ad60fa18e526984ee22ee1b465" translate="yes" xml:space="preserve">
          <source>The engine implementing the unpack() Perl function.</source>
          <target state="translated">Движок,реализующий функцию распаковки()Perl.</target>
        </trans-unit>
        <trans-unit id="23836ad0aab663b81186836eab5aaaa304905073" translate="yes" xml:space="preserve">
          <source>The engine implementing unpack() Perl function. Note: parameters strbeg, new_s and ocnt are not used. This call should not be used, use unpackstring instead.</source>
          <target state="translated">Движок,реализующий функцию распаковки()Perl.Замечание:параметры strbeg,new_s и ocnt не используются.Этот вызов не должен использоваться,вместо этого используйте распаковку.</target>
        </trans-unit>
        <trans-unit id="d9382e3775d5db72bf3f9d8d46eb30460f658e51" translate="yes" xml:space="preserve">
          <source>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as &lt;code&gt;extflags&lt;/code&gt; unless the engine chose to modify one of them.</source>
          <target state="translated">Личная копия флагов движка, с которыми был скомпилирован паттерн. Обычно это то же самое, что и &lt;code&gt;extflags&lt;/code&gt; , если движок не изменил один из них.</target>
        </trans-unit>
        <trans-unit id="9ce2a132adf5c2ffffe82f2f2320a1ff022e1a1c" translate="yes" xml:space="preserve">
          <source>The entire file system is compressed such as via &quot;DoubleSpace&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e628a3e380b1bb720e0473c9d50225fb2d2a7bf" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt; ; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="translated">Вся подсистема getaddrinfo () может быть экспортирована с помощью тега &lt;code&gt;:addrinfo&lt;/code&gt; ; это экспортирует функции getaddrinfo () и getnameinfo (), а также все &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; и &lt;code&gt;EAI_*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9deffc2b03edaef07355a1dc99c65f075b4e32e" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt;; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt;, &lt;code&gt;NI_*&lt;/code&gt;, &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425561102978b28bf5fcfefe3513eb2739c2c06d" translate="yes" xml:space="preserve">
          <source>The entire hardware and software context in which a program runs. A program written in a platform-dependent language might break if you change any of the following: machine, operating system, libraries, compiler, or system configuration. The</source>
          <target state="translated">Весь контекст аппаратного и программного обеспечения,в котором выполняется программа.Программа,написанная на платформозависимом языке,может сломаться,если вы измените что-либо из следующего:машину,операционную систему,библиотеки,компилятор или конфигурацию системы..</target>
        </trans-unit>
        <trans-unit id="062ee9dd6945c627c0db8805ff34b8bebe56650f" translate="yes" xml:space="preserve">
          <source>The entire upgrading/downgrading is still experimental and might not work as you expect or may even have bugs. You might get errors like this:</source>
          <target state="translated">Весь процесс обновления/отключения все еще является экспериментальным и может работать не так,как вы ожидаете,или даже иметь ошибки.Вы можете получить такие ошибки:</target>
        </trans-unit>
        <trans-unit id="5e462b82c7819411d2795ec13fd404d6485cf8ac" translate="yes" xml:space="preserve">
          <source>The environment is not automatically made available as separate scalar variables.</source>
          <target state="translated">Среда не становится автоматически доступной в качестве отдельных скалярных переменных.</target>
        </trans-unit>
        <trans-unit id="4a714b26cc76c6e720a2c1944b7c3273669f5c69" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt; .</source>
          <target state="translated">Переменная среды &lt;code&gt;PERL_RL&lt;/code&gt; определяет, какой клон ReadLine загружается. Если значение ложно, используется фиктивный интерфейс. Если значение истинно, оно должно быть концом имени используемого пакета, например &lt;code&gt;Perl&lt;/code&gt; или &lt;code&gt;Gnu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="390b6e9b1745d2d828a2345d3a86cf8b0b336f56" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee4db4f603bb2d952278fab3f0573c9f206b756" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; is set to &lt;code&gt;unsafe&lt;/code&gt; (see &lt;a href=&quot;perlrun#PERL_SIGNALS&quot;&gt;&quot;PERL_SIGNALS&quot; in perlrun&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c8987c252d8945d5eef3157bdde1da3d4677a3" translate="yes" xml:space="preserve">
          <source>The error function [C99].</source>
          <target state="translated">Функция ошибки [C99].</target>
        </trans-unit>
        <trans-unit id="c03bfb5951202558a79d3146a129bcd7599c5997" translate="yes" xml:space="preserve">
          <source>The error level, should be 'WARNING' or 'ERROR'.</source>
          <target state="translated">Уровень ошибки должен быть 'ПРЕДУПРЕЖДЕНИЕ' или 'ОШИБКА'.</target>
        </trans-unit>
        <trans-unit id="489643f4ea640ba730461cfbd32bed09509bae25" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="translated">Сообщение об ошибке или объект будут использоваться как исключение, по умолчанию возвращая управление ближайшему охватывающему &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , но при условии изменения обработчиком &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; . В любом случае функция &lt;code&gt;croak_sv&lt;/code&gt; никогда не возвращает нормально.</target>
        </trans-unit>
        <trans-unit id="4301dd87f0c694dc26ff0db9df44403205bacc19" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;eval&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664a7836db566d6a3f4c07aec582c78faf8e8984" translate="yes" xml:space="preserve">
          <source>The error message or object will by default be written to standard error, but this is subject to modification by a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler.</source>
          <target state="translated">Сообщение об ошибке или объект по умолчанию будут записаны в стандартную ошибку, но это может быть &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; обработчиком $ SIG {__ WARN__} .</target>
        </trans-unit>
        <trans-unit id="b67bc4e2f3fe19fc43d4ef72e9869cbd0c9674e2" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="translated">Сообщение об ошибке будет использоваться как исключение, по умолчанию возвращающее управление ближайшему охватывающему &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , но может быть &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; обработчиком $ SIG {__ DIE__} . В любом случае функция &lt;code&gt;croak&lt;/code&gt; никогда не возвращается нормально.</target>
        </trans-unit>
        <trans-unit id="b00b7771ac407f2dd89d3f22f11d4228e791df56" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;eval&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900d77a6d61d64e8af52decba69cafd8be937ac1" translate="yes" xml:space="preserve">
          <source>The error number returned by a &lt;b&gt;syscall&lt;/b&gt; when it fails. Perl refers to the error by the name &lt;code&gt;$!&lt;/code&gt; (or &lt;code&gt;$OS_ERROR&lt;/code&gt; if you use the English module).</source>
          <target state="translated">Номер ошибки, возвращаемый &lt;b&gt;системным вызовом в&lt;/b&gt; случае сбоя. Perl называет ошибку &lt;code&gt;$!&lt;/code&gt; (или &lt;code&gt;$OS_ERROR&lt;/code&gt; если вы используете английский модуль).</target>
        </trans-unit>
        <trans-unit id="4c482150704e0bf7cda4048aa90adb166f9af2aa" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EAI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b014cdbfece5798eb6937c7e465a37ae5041c3" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EAI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953076d4b6c381c0ffffe4399cd4fbc39f8ceb23" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="translated">Значение ошибки будет двойной величиной; сопоставимы с &lt;code&gt;EI_*&lt;/code&gt; ошибок EI_ * или могут быть распечатаны в виде удобочитаемой строки сообщения об ошибке. Если ошибок не было, это будет числовой ноль и пустая строка.</target>
        </trans-unit>
        <trans-unit id="4f48137cede1f63ecf865be7641415458ec370ab" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="translated">Значение ошибки будет двойной величиной; сопоставимы с &lt;code&gt;EI_*&lt;/code&gt; ошибок EI_ * или могут быть распечатаны в виде удобочитаемой строки сообщения об ошибке. Имена хоста и службы будут простыми строками.</target>
        </trans-unit>
        <trans-unit id="69f6f9a5df3062e908bd0165d9c2b9fe0563d15c" translate="yes" xml:space="preserve">
          <source>The errors facet is a list instead of a single item, any number of errors can be listed. In this facet &lt;code&gt;details&lt;/code&gt; describes the error, or may contain the raw error message itself (such as an exception). In perl exception may be blessed objects, as such the raw data for this facet may contain nested items which are blessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce05d758ea509461baa38b741595abae13996ba5" translate="yes" xml:space="preserve">
          <source>The escape is the beginning or final end point of a range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1c1519bb36749c3cad434bbe27ce9cca770380" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; wraps an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="translated">Модификатор оценки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; оборачивает &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; вокруг строки замены, и результат оценки заменяется на найденную подстроку. Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="acb75763cbe80034d5f373af05d3a0392a02769b" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;s///e&lt;/code&gt; wraps an &lt;code&gt;eval{...}&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfba3806303ac6dda3f30dd80fde49f7e2183210" translate="yes" xml:space="preserve">
          <source>The event from &lt;code&gt;ok(1, &quot;pass&quot;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863be168c93a9b4e951447892af8574c10035f63" translate="yes" xml:space="preserve">
          <source>The event of a plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c657becf62f17dba34f2c0a7892b03eec9664a" translate="yes" xml:space="preserve">
          <source>The exact implementation of this macro varies by architecture and version of perl, and the return value may change per invocation, so the value is only valid for the duration of a single perl process.</source>
          <target state="translated">Точная реализация этого макроса варьируется в зависимости от архитектуры и версии perl,а возвращаемое значение может меняться при каждом вызове,поэтому значение действует только в течение одного процесса perl.</target>
        </trans-unit>
        <trans-unit id="77f569ab2ca56d55a753f65526e499d75cae3e5d" translate="yes" xml:space="preserve">
          <source>The exact line number may vary, but if the warning (W) comes from a line line this</source>
          <target state="translated">Точный номер строки может варьироваться,но если предупреждение (W)приходит из строки,то следующее</target>
        </trans-unit>
        <trans-unit id="995bdcd8d207fa374f9f43b6e279df6bd565026b" translate="yes" xml:space="preserve">
          <source>The exact line numbers may vary between Perl releases. The warnings are benign and can be ignored: in later C compiler releases the warnings should be gone.</source>
          <target state="translated">Точные номера строк могут отличаться в зависимости от версии Perl.Предупреждения доброкачественны и могут быть проигнорированы:в более поздних релизах компилятора Си предупреждения должны быть проигнорированы.</target>
        </trans-unit>
        <trans-unit id="44fc79e864b1257675cf101f1f7fd3a57bf639a9" translate="yes" xml:space="preserve">
          <source>The exact manner in which the address is returned in $symref is not currently defined. The only initial requirement is that $symref can be passed to, and understood by, dl_install_xsub().</source>
          <target state="translated">Точный способ возврата адреса в $symref в настоящее время не определен.Единственным начальным требованием является то,что $symref может быть передан и понятен функцией dl_install_xsub().</target>
        </trans-unit>
        <trans-unit id="e70c2ef4d5d588ebbe05350bafa35fc8f80a6a1c" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">Точное значение поля $ gcos различается, но обычно оно содержит настоящее имя пользователя (в отличие от имени для входа) и другую информацию, относящуюся к пользователю. Однако помните, что во многих системах пользователи могут изменять эту информацию, и поэтому ей нельзя доверять, и, следовательно, $ gcos испорчен (см. &lt;a href=&quot;../perlsec&quot;&gt;Perlsec&lt;/a&gt; ). $ Passwd и $ shell, зашифрованный пароль пользователя и оболочка входа в систему также испорчены по той же причине.</target>
        </trans-unit>
        <trans-unit id="d7d6887be4411b65036ddda7abbe1d73b16c3d9f" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">Точное значение поля $ gcos различается, но обычно оно содержит настоящее имя пользователя (в отличие от имени для входа) и другую информацию, относящуюся к пользователю. Однако помните, что во многих системах пользователи могут изменять эту информацию, и поэтому ей нельзя доверять, и, следовательно, $ gcos испорчен (см. &lt;a href=&quot;perlsec&quot;&gt;Perlsec&lt;/a&gt; ). $ Passwd и $ shell, зашифрованный пароль пользователя и оболочка входа в систему также испорчены по той же причине.</target>
        </trans-unit>
        <trans-unit id="6462c6eed55545498a4b1274ffec108a59806854" translate="yes" xml:space="preserve">
          <source>The exact rules for how often (??{}) and (?{}) are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="translated">Точные правила того,как часто (?{})и (?{})выполняются в шаблоне,не определены.В случае успешного совпадения можно предположить,что они DWIM и будут выполняться в порядке слева направо,соответствующее количество раз в приемном пути шаблона,как и любая другая мета-маскара.То,как непринятие путей и неудачные совпадения влияют на количество раз выполнения шаблона,конкретно не указано и может варьироваться в зависимости от того,какие оптимизации могут быть применены к шаблону и,скорее всего,будут меняться от версии к версии.</target>
        </trans-unit>
        <trans-unit id="fdf1655ab3b8310f5b318568059958f807b33f0d" translate="yes" xml:space="preserve">
          <source>The exact rules for how often &lt;code&gt;(??{})&lt;/code&gt; and &lt;code&gt;(?{})&lt;/code&gt; are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7beaad311b9cd2e0a10bf6f8d5a018e83ebb91c" translate="yes" xml:space="preserve">
          <source>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</source>
          <target state="translated">Точно такого же эффекта,кстати,можно добиться с помощью одного пункта &quot;=для&quot;:</target>
        </trans-unit>
        <trans-unit id="fb72ca6692327d6fee94ee24d9e91cba6dc1e016" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma, and attributes are handled using the &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;a href=&quot;Attribute::Handlers&quot;&gt;Attribute::Handlers&lt;/a&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61acc8b78f6506711798cda20b87d0c0557e6d78" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">Точная семантика и интерфейс TYPE и ATTRS все еще развиваются. TYPE в настоящее время привязан к использованию директивы &lt;code&gt;fields&lt;/code&gt; , а атрибуты обрабатываются с помощью директивы &lt;code&gt;attributes&lt;/code&gt; или, начиная с Perl 5.8.0, также через модуль &lt;code&gt;Attribute::Handlers&lt;/code&gt; . См. Подробные сведения о &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;частных переменных через my () в perlsub&lt;/a&gt; , а также о &lt;a href=&quot;../fields&quot;&gt;полях&lt;/a&gt; , &lt;a href=&quot;../attributes&quot;&gt;атрибутах&lt;/a&gt; и &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: Handlers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90e321854a7d357a33050984753578010a7cc972" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">Точная семантика и интерфейс TYPE и ATTRS все еще развиваются. TYPE в настоящее время привязан к использованию директивы &lt;code&gt;fields&lt;/code&gt; , а атрибуты обрабатываются с помощью директивы &lt;code&gt;attributes&lt;/code&gt; или, начиная с Perl 5.8.0, также через модуль &lt;code&gt;Attribute::Handlers&lt;/code&gt; . См. Подробные сведения о &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;частных переменных через my () в perlsub&lt;/a&gt; , а также о &lt;a href=&quot;fields&quot;&gt;полях&lt;/a&gt; , &lt;a href=&quot;attributes&quot;&gt;атрибутах&lt;/a&gt; и &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b162d38593f0c61d02eda524507bf4fd01fab9" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;use constant&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#__PACKAGE__&quot;&gt;&lt;code&gt;__PACKAGE__&lt;/code&gt;&lt;/a&gt;. It is currently bound to the use of the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma, and attributes are handled using the &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; pragma, or starting from Perl 5.8.0 also via the &lt;a href=&quot;Attribute::Handlers&quot;&gt;Attribute::Handlers&lt;/a&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c046e7769f3ecfcaed8dd98a806a8be83eb888" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;__PACKAGE__&lt;/code&gt; . It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">Точная семантика и интерфейс TYPE и ATTRS все еще развиваются. TYPE может быть голым словом, константой, объявленной с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , или &lt;code&gt;__PACKAGE__&lt;/code&gt; . В настоящее время он привязан к использованию директивы &lt;code&gt;fields&lt;/code&gt; , а атрибуты обрабатываются с помощью директивы &lt;code&gt;attributes&lt;/code&gt; или, начиная с Perl 5.8.0, также через модуль &lt;code&gt;Attribute::Handlers&lt;/code&gt; . См. Подробные сведения о &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;частных переменных через my () в perlsub&lt;/a&gt; , а также о &lt;a href=&quot;fields&quot;&gt;полях&lt;/a&gt; , &lt;a href=&quot;attributes&quot;&gt;атрибутах&lt;/a&gt; и &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: Handlers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8bfadb028cf247124d08e25f901567b324753c6" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt;. It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">Точная семантика и интерфейс TYPE и ATTRS все еще развиваются. TYPE может быть голым словом, константой, объявленной с &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt; . В настоящее время он привязан к использованию директивы &lt;code&gt;fields&lt;/code&gt; , а атрибуты обрабатываются с помощью директивы &lt;code&gt;attributes&lt;/code&gt; или, начиная с Perl 5.8.0, также через модуль &lt;code&gt;Attribute::Handlers&lt;/code&gt; . См. Подробные сведения о &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;частных переменных через my () в perlsub&lt;/a&gt; , а также о &lt;a href=&quot;../fields&quot;&gt;полях&lt;/a&gt; , &lt;a href=&quot;../attributes&quot;&gt;атрибутах&lt;/a&gt; и &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: Handlers&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8d599de382831818fdc3314909d743d15fa4f85" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">Точный набор символов, соответствующих &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; и &lt;code&gt;\w&lt;/code&gt; зависит от различных модификаторов прагмы и регулярного выражения. Можно ограничить соответствие диапазоном ASCII с помощью модификатора регулярного выражения &lt;code&gt;/a&lt;/code&gt; . Смотрите &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23a6f9e0bca7b676930bcaa64329c3c867e0685e" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="319ae490a71e74c46be21bc09971371ff532d6a8" translate="yes" xml:space="preserve">
          <source>The example above uses &lt;code&gt;select()&lt;/code&gt;, but any similar mechanism should work analogously. &lt;code&gt;IO::Socket::IP&lt;/code&gt; takes care when creating new socket filehandles to preserve the actual file descriptor number, so such techniques as &lt;code&gt;poll&lt;/code&gt; or &lt;code&gt;epoll&lt;/code&gt; should be transparent to its reallocation of a different socket underneath, perhaps in order to switch protocol family between &lt;code&gt;PF_INET&lt;/code&gt; and &lt;code&gt;PF_INET6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130d6baa202fd58693c4e06f24211f73d068ae4b" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The &lt;code&gt;DEFINE&lt;/code&gt; group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c6e96fbcd4407d552a2d3c6f391d06e2768883" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The DEFINE group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="translated">В примере,приведенном ниже,иллюстрируется использование детали для чисел с плавающей точкой,которая была представлена ранее.Три подмаски,которые используются более одного раза,являются необязательным знаком,цифровой последовательностью для целого числа и десятичной дробью.Группа DEFINE в конце детали содержит их определение.Обратите внимание,что десятичная дробь является первым местом,где мы можем повторно использовать целочисленный шаблон.</target>
        </trans-unit>
        <trans-unit id="c669b79bf926dbbee70a1aab0498c88f6e21bd08" translate="yes" xml:space="preserve">
          <source>The example below shows what you need if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95b2fc7c1cff73cb10b6820506fd203858d5dd0" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt; , put &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;SECURITY in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="translated">В примере не удаляется краска &lt;code&gt;$data&lt;/code&gt; если &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , поскольку символы, соответствующие &lt;code&gt;\w&lt;/code&gt; , определяются локалью. Perl считает, что определения локали ненадежны, потому что они содержат данные извне программы. Если вы пишете локализованную знают программу и хотите желоба данных с регулярным выражением , содержащим &lt;code&gt;\w&lt;/code&gt; , положить &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; впереди выражения в том же блоке. См. &lt;a href=&quot;perllocale#SECURITY&quot;&gt;БЕЗОПАСНОСТЬ в perllocale&lt;/a&gt; для дальнейшего обсуждения и примеров.</target>
        </trans-unit>
        <trans-unit id="36698f0de180b3f94fb468b665a41ca7be987afb" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;use locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt;, put &lt;code&gt;no locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;&quot;SECURITY&quot; in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1c21f507054a9e5bf00808f679503b139b9cd1" translate="yes" xml:space="preserve">
          <source>The examples above use a relative path to the perl interpreter, getting whatever version is first in the user's path. If you want a specific version of Perl, say, perl5.14.1, you should place that directly in the &lt;code&gt;#!&lt;/code&gt; line's path.</source>
          <target state="translated">В приведенных выше примерах используется относительный путь к интерпретатору perl, получая любую версию, которая стоит первой в пути пользователя. Если вам нужна конкретная версия Perl, например, perl5.14.1, вы должны поместить ее прямо в &lt;code&gt;#!&lt;/code&gt; путь линии.</target>
        </trans-unit>
        <trans-unit id="ba7768ce3ab49f321e6775f2de42c2a895f7304f" translate="yes" xml:space="preserve">
          <source>The examples given at the start of the document (an error handler and an event driven program) are typical of the two main sorts of flow control that you are likely to encounter with callbacks. There is a very important distinction between them, so pay attention.</source>
          <target state="translated">Примеры,приведенные в начале документа (обработчик ошибок и программа,управляемая событиями),типичны для двух основных типов управления потоком,с которыми вы,вероятно,столкнетесь при обратном вызове.Между ними есть очень важное различие,так что будьте внимательны.</target>
        </trans-unit>
        <trans-unit id="d5744c543ee5f3d510361cac5aaaa06664739511" translate="yes" xml:space="preserve">
          <source>The examples illustrate several aspects: the first three queries target modules, authors, or distros directly and yield exactly one result. The last two use regular expressions and yield several results. The last one targets all of bundles, modules, authors, and distros simultaneously. When more than one result is available, they are printed in one-line format.</source>
          <target state="translated">Примеры иллюстрируют несколько аспектов:первые три запроса целевых модулей,авторов или дистрибутивов напрямую и дают ровно один результат.Последние два используют регулярные выражения и дают несколько результатов.Последний запрос нацелен одновременно на все связки,модули,авторов и дистрибутивы.При наличии нескольких результатов они распечатываются в однострочном формате.</target>
        </trans-unit>
        <trans-unit id="ddf2315db7343aee83255d9099df21a0faac3030" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</source>
          <target state="translated">Примеры в предыдущем разделе демонстрируют досадную слабость. Мы подбирали только слова из 3 букв или фрагменты слов из 4 букв или меньше. Мы хотели бы иметь возможность сопоставлять слова или, в более общем смысле, строки любой длины, не выписывая утомительные альтернативы, такие как &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da6aadb818ba37828bf9750c2c1c42a56a0d0753" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a56adef05fecf63fd9cba639dd925bcaf1cb87b" translate="yes" xml:space="preserve">
          <source>The examples show a very simple class that implements a</source>
          <target state="translated">Примеры показывают очень простой класс,реализующий a</target>
        </trans-unit>
        <trans-unit id="45802eeee4d1f7759548f95073ecb55a63eb7a92" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="translated">Примеры показывают, что этот класс реализован с разными уровнями поддержки с помощью &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . Показаны все поддерживаемые комбинации. Разница между реализациями зачастую довольно мала. Реализации:</target>
        </trans-unit>
        <trans-unit id="7cfc17e4302419b2090ffa8fca11900025b88c94" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt;. All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51ffd2e5bcc1a6d7d14bd6f95a324550850104d" translate="yes" xml:space="preserve">
          <source>The excellent Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</source>
          <target state="translated">Превосходный FAQ по календарю на &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b98aabfe9b6ba71ecfd39be082dced0eadaf1cc4" translate="yes" xml:space="preserve">
          <source>The excellent Filter::Util::Call module (by Paul Marquess) provides a usable Perl interface to source filtering, but it is often too powerful and not nearly as simple as it could be.</source>
          <target state="translated">Отличный модуль Filter::Util::Call (автор Paul Marquess)предоставляет удобный интерфейс Perl для фильтрации исходных текстов,но часто он слишком мощный и не настолько простой,насколько это может быть.</target>
        </trans-unit>
        <trans-unit id="52ea595fb3e7d2ce456e743df519b555912d5e12" translate="yes" xml:space="preserve">
          <source>The exception is for organization-specific email (e.g. foo@yourcompany.com) where policy can be codified in your program. In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&amp;lt;) in scalar context, like so:</source>
          <target state="translated">Исключение составляет адрес электронной почты организации (например, foo@yourcompany.com), где политика может быть кодифицирована в вашей программе. В этом случае вы можете посмотреть на $ ENV {USER}, $ ENV {LOGNAME} и getpwuid ($ &amp;lt;) в скалярном контексте, например:</target>
        </trans-unit>
        <trans-unit id="1b5fd23c00f654857837ce525e2feca5e5a60486" translate="yes" xml:space="preserve">
          <source>The exception to the above rule is when the left-hand string begins with &lt;code&gt;0&lt;/code&gt; and is longer than one character, in this case the magic increment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc87b76bc5dac6308b19a21f2fb89ffe909a88b" translate="yes" xml:space="preserve">
          <source>The exception to the principle of &quot;one tainted value taints the whole expression&quot; is with the ternary conditional operator &lt;code&gt;?:&lt;/code&gt;. Since code with a ternary conditional</source>
          <target state="translated">Исключением из принципа &amp;laquo;одно испорченное значение портит все выражение&amp;raquo; является тернарный условный оператор &lt;code&gt;?:&lt;/code&gt; . Поскольку код с тернарным условным</target>
        </trans-unit>
        <trans-unit id="5c4020c3e362c07677c68b98797130c8e33e53fa" translate="yes" xml:space="preserve">
          <source>The exception to this rule are</source>
          <target state="translated">Исключением из этого правила являются</target>
        </trans-unit>
        <trans-unit id="06cb57f51318b2c753120a0083873c4679095e1b" translate="yes" xml:space="preserve">
          <source>The exception to this rule is if you are calling a Perl subroutine directly from an XSUB function. In this case it is not necessary to use the &lt;code&gt;dSP&lt;/code&gt; macro explicitly--it will be declared for you automatically.</source>
          <target state="translated">Исключением из этого правила является вызов подпрограммы Perl непосредственно из функции XSUB. В этом случае нет необходимости явно использовать макрос &lt;code&gt;dSP&lt;/code&gt; - он будет объявлен за вас автоматически.</target>
        </trans-unit>
        <trans-unit id="0d894dabcea23f9b036a1c82348cf80da10ab49b" translate="yes" xml:space="preserve">
          <source>The exceptions are:</source>
          <target state="translated">Исключения:</target>
        </trans-unit>
        <trans-unit id="3e26c68194190c41dfdad74105f0e492dc235a18" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3
4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</source>
          <target state="translated">Порядок выполнения обозначен знаками &lt;code&gt;===&amp;gt;&lt;/code&gt; , то есть &lt;code&gt;3 4 5 6&lt;/code&gt; (узел &lt;code&gt;6&lt;/code&gt; не включен в листинг выше), т.е. &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db1745f72327cdbec0c0f35f7353b51ef20c7bd5" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3 4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a81e1fe7a2f079c1b9f8b207b9fe9d777e92c5" translate="yes" xml:space="preserve">
          <source>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you're removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you're allowed to.</source>
          <target state="translated">Резюме:узнайте,как работает ваша файловая система.Разрешения на файл говорят о том,что может произойти с данными в этом файле.Права на каталог говорят о том,что может произойти со списком файлов в этом каталоге.Если вы удаляете файл,вы удаляете его имя из каталога (поэтому операция зависит от прав на каталог,а не на файл).Если вы попытаетесь записать файл,то разрешения файла будут зависеть от того,разрешено ли вам это.</target>
        </trans-unit>
        <trans-unit id="8bd1d5ba511947aaf27cf0898729cbcdb3363ec9" translate="yes" xml:space="preserve">
          <source>The existence of a rule does not imply selecting a test. You must still specify the tests to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fc393062d8546f20ed1b167ba8df5f73019ce5" translate="yes" xml:space="preserve">
          <source>The exit code of the executed program.</source>
          <target state="translated">Выходной код выполненной программы.</target>
        </trans-unit>
        <trans-unit id="137ed18115f3228ba7f07a48e55913ee96e30593" translate="yes" xml:space="preserve">
          <source>The exit status value to return.</source>
          <target state="translated">Значение состояния выхода для возврата.</target>
        </trans-unit>
        <trans-unit id="0c5c8d24f00e7eedd0cb8f1fea1a1b90fbdc8c11" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">Функция exit () не всегда завершается немедленно. Сначала он вызывает любые определенные подпрограммы &lt;code&gt;END&lt;/code&gt; , но эти подпрограммы &lt;code&gt;END&lt;/code&gt; сами не могут прервать выход. Точно так же любые деструкторы объекта, которые необходимо вызвать, вызываются перед настоящим выходом. Подпрограммы и деструкторы &lt;code&gt;END&lt;/code&gt; могут изменять статус выхода, изменяя &lt;code&gt;$?&lt;/code&gt; . Если это проблема, вы можете вызвать &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; чтобы избежать обработки END и деструктора. Подробности смотрите в &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="680c902ef0b900a40fad1c488731545af94f9d10" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">Функция exit () не всегда завершается немедленно. Сначала он вызывает любые определенные подпрограммы &lt;code&gt;END&lt;/code&gt; , но эти подпрограммы &lt;code&gt;END&lt;/code&gt; сами не могут прервать выход. Точно так же любые деструкторы объекта, которые необходимо вызвать, вызываются перед настоящим выходом. Подпрограммы и деструкторы &lt;code&gt;END&lt;/code&gt; могут изменять статус выхода, изменяя &lt;code&gt;$?&lt;/code&gt; . Если это проблема, вы можете вызвать &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; чтобы избежать обработки END и деструктора. Подробности смотрите в &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="878ff23487a7f8c43fec8d4483cc1765c4df9eb4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;given&lt;/code&gt; statement is</source>
          <target state="translated">Экспериментально &lt;code&gt;given&lt;/code&gt; утверждение</target>
        </trans-unit>
        <trans-unit id="19bd303111f858742510d8d90c5638313c02c5ce" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;legacy&lt;/code&gt; pragma was swallowed by the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Прагма экспериментального &lt;code&gt;legacy&lt;/code&gt; была поглощена прагмой &lt;code&gt;feature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52d7e8e19cc3efaf2aec8d989a33421d70ed317d" translate="yes" xml:space="preserve">
          <source>The experimental declared_refs feature is not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccc48fde094b67b79701d699ac45d91d085adcc" translate="yes" xml:space="preserve">
          <source>The experimental feature &lt;code&gt;&quot;(?[...])&quot;&lt;/code&gt; starting in v5.18 accomplishes this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868cc46704185b2a446e1b7a62d0312275a48c48" translate="yes" xml:space="preserve">
          <source>The explanation above has omitted some detail; refer to UAX#24 &quot;Unicode Script Property&quot;: &lt;a href=&quot;https://www.unicode.org/reports/tr24&quot;&gt;https://www.unicode.org/reports/tr24&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0349830ce8cbe97566441b2e1c5b4811ccfb44c1" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;'e'&lt;/code&gt; or &lt;code&gt;'E'&lt;/code&gt;, followed by an integer. So the exponent regexp is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f321e42a52fdc6b5d89f69bf0fc91962da84c32f" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; , followed by an integer. So the exponent regexp is</source>
          <target state="translated">Показателем степени является &lt;code&gt;e&lt;/code&gt; или &lt;code&gt;E&lt;/code&gt; , за которым следует целое число. Таким образом, регулярное выражение экспоненты равно</target>
        </trans-unit>
        <trans-unit id="dc560dadf22f2caa4887dcda366e49e8868f1d51" translate="yes" xml:space="preserve">
          <source>The exponentiation operator is &quot;**&quot;, not &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one could get the feeling that &lt;b&gt;awk&lt;/b&gt; is basically incompatible with C.)</source>
          <target state="translated">Оператор возведения в степень - &amp;laquo;**&amp;raquo;, а не &amp;laquo;^&amp;raquo;. &amp;laquo;^&amp;raquo; - это оператор XOR, как в C. (Вы знаете, может возникнуть ощущение, что &lt;b&gt;awk&lt;/b&gt; в основном несовместима с C.)</target>
        </trans-unit>
        <trans-unit id="009dcc9526e9f6902be1b067b6a2b9829ed8f757" translate="yes" xml:space="preserve">
          <source>The expression is evaluated in scalar context. So the following will work:</source>
          <target state="translated">Выражение оценивается в скалярном контексте.Таким образом,сработает следующее:</target>
        </trans-unit>
        <trans-unit id="09c23065a9eeac610af39d5a880a04c9ff912e79" translate="yes" xml:space="preserve">
          <source>The ext/ODBM_File/odbm is known to fail with static builds (Configure -Uusedl) due to a known bug in Tru64's static libdbm library. The good news is that you very probably don't need to ever use the ODBM_File extension since more advanced NDBM_File works fine, not to mention the even more advanced DB_File.</source>
          <target state="translated">Известно,что ext/ODBM_File/odbm не работает со статическими сборками (Configure -Uusedl)из-за известной ошибки в статической библиотеке libdbm Tru64.Хорошая новость заключается в том,что вам,скорее всего,никогда не придется использовать расширение ODBM_File,так как более продвинутый NDBM_File работает нормально,не говоря уже о еще более продвинутом DB_File.</target>
        </trans-unit>
        <trans-unit id="31ec63f172c0fdca1326836d5d87e5fe035f0607" translate="yes" xml:space="preserve">
          <source>The extended filetest functionality is used by Perl only when the argument of the operators is a filename, not when it is a filehandle.</source>
          <target state="translated">Расширенная функциональность филе используется Perl только в том случае,если аргументом операторов является имя файла,а не в том случае,если это файловая ручка.</target>
        </trans-unit>
        <trans-unit id="b669bdb080a6675f7c6ed5d24b2ef14539648c80" translate="yes" xml:space="preserve">
          <source>The extension is dynamically linked</source>
          <target state="translated">Расширение динамически связано</target>
        </trans-unit>
        <trans-unit id="f990232badfb418cbf7dd0574833889e9f679aa9" translate="yes" xml:space="preserve">
          <source>The extension is pure perl, so doesn't need linking to the perl executable</source>
          <target state="translated">Расширение является чистым perl,поэтому нет необходимости привязывать его к исполняемому файлу perl.</target>
        </trans-unit>
        <trans-unit id="13f70d182dd718c2ffdf92971d2248139cbe171e" translate="yes" xml:space="preserve">
          <source>The extension is statically linked to the perl binary</source>
          <target state="translated">Удлинитель статически связан с бинарным perl.</target>
        </trans-unit>
        <trans-unit id="b14db60112e20420246ea9d3dec3923a929f96a3" translate="yes" xml:space="preserve">
          <source>The extracted information is stored in 5 entries in the &lt;code&gt;build&lt;/code&gt; hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1beda77ee5a84052f068e6757ef13cea3f36f8f" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Извлеченная строка, включая указанные разделители. Если извлечение не удается, возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2570abc8ab1be73d003248dd246a24a2fc5f319" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3130a57897b10b0bc008c6b4f6ef79e3b3444412" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</source>
          <target state="translated">Извлеченная запись termcap доступна в объекте как &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adf0aca1542de815275e994553ee7120f60337c3" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c328df413a33fa608e46c6826495b03f8d0ee0f6" translate="yes" xml:space="preserve">
          <source>The extraction process works by applying each extractor in sequence to the text string.</source>
          <target state="translated">Процесс извлечения работает путем последовательного применения каждого экстрактора к текстовой строке.</target>
        </trans-unit>
        <trans-unit id="7ad2005947669b79c8509770fad3b2b296acf5fd" translate="yes" xml:space="preserve">
          <source>The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *. You should not call &lt;code&gt;fclose()&lt;/code&gt; on the file unless you call &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; to disassociate it from the PerlIO *. (Do not use PerlIO_importFILE() for doing the disassociation.)</source>
          <target state="translated">Факт того, что такой ФАЙЛ * был &amp;laquo;экспортирован&amp;raquo;, записывается (обычно путем добавления нового &amp;laquo;слоя&amp;raquo;: stdio на PerlIO *), что может повлиять на будущие операции PerlIO на исходном PerlIO *. Вам не следует вызывать &lt;code&gt;fclose()&lt;/code&gt; для файла, если вы не вызываете &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; чтобы отделить его от PerlIO *. (Не используйте PerlIO_importFILE () для диссоциации.)</target>
        </trans-unit>
        <trans-unit id="357aafdac768e27bb52a043649452bd876a53d4d" translate="yes" xml:space="preserve">
          <source>The factory itself is never instantiated (this</source>
          <target state="translated">Сама фабрика никогда не инстанцируется (это</target>
        </trans-unit>
        <trans-unit id="ee17924499933b661b8e0c34b82c36eff25eeaf5" translate="yes" xml:space="preserve">
          <source>The fastgetcwd() function is provided as a synonym for cwd().</source>
          <target state="translated">Функция fastgetcwd()является синонимом функции cwd().</target>
        </trans-unit>
        <trans-unit id="3c06a8aa0a4d260ed2765600496ce1fc1ffcef9e" translate="yes" xml:space="preserve">
          <source>The feature logical name &lt;code&gt;PERL_VMS_VTF7_FILENAMES&lt;/code&gt; controls if UNICODE characters in Unix filenames are encoded in VTF-7 notation in the resulting OpenVMS file specification. [Currently under development]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533f832808f430e9fde8557e2b27391f20356a2e" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt; . To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt; .</source>
          <target state="translated">Логическое имя функции DECC $ FILENAME_UNIX_REPORT изменяет традиционное поведение Perl при преобразовании спецификаций файлов из формата Unix в формат VMS, чтобы следовать расширенным правилам обработки символов, которые теперь ожидаются CRTL. В частности, когда действует эта функция, &lt;code&gt;./.../&lt;/code&gt; в пути Unix теперь преобразуется в &lt;code&gt;[.^.^.^.]&lt;/code&gt; Вместо традиционного VMS &lt;code&gt;[...]&lt;/code&gt; . Чтобы быть совместимым с тем, что ожидает MakeMaker, если путь VMS не может быть преобразован в путь Unix, он передается без изменений, поэтому &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; вернет &lt;code&gt;[...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd427ddb1d40a440a4569bc32b983da79c223869" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt;. To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ee4cd3c900fba7f346eaf4d73c2e59283171b2" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</source>
          <target state="translated">Эту функцию необходимо включить с помощью &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1fe35afa1a3972e367d70f65936f774e7c1fb4" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9967e9df7e264da6bcdb44f5aee030bc917d02a" translate="yes" xml:space="preserve">
          <source>The features you got from your mother and father, mixed together unpredictably. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;single inheritance&lt;/b&gt;.) In computer languages (including Perl), it is the notion that a given class may have multiple direct ancestors or &lt;b&gt;base classes&lt;/b&gt;.</source>
          <target state="translated">Черты лица, которые вы унаследовали от матери и отца, непредсказуемо смешались. (См. Также &lt;b&gt;наследование&lt;/b&gt; и &lt;b&gt;одиночное наследование&lt;/b&gt; .) В компьютерных языках (включая Perl) есть понятие, что данный класс может иметь несколько прямых предков или &lt;b&gt;базовых классов&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ddb61ef14874404dd766423660c7d397637ace24" translate="yes" xml:space="preserve">
          <source>The features you got from your mother, if she told you that you don&amp;rsquo;t have a father. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.) In computer languages, the idea that &lt;b&gt;classes&lt;/b&gt; reproduce asexually so that a given class can only have one direct ancestor or &lt;b&gt;base class&lt;/b&gt;. Perl supplies no such restriction, though you may certainly program Perl that way if you like.</source>
          <target state="translated">Черты лица, которые ты получил от своей матери, если она сказала тебе, что у тебя нет отца. (См. Также &lt;b&gt;наследование&lt;/b&gt; и &lt;b&gt;множественное наследование&lt;/b&gt; .) В компьютерных языках идея о том, что &lt;b&gt;классы&lt;/b&gt; воспроизводятся бесполым путем, так что данный класс может иметь только одного прямого предка или &lt;b&gt;базовый класс&lt;/b&gt; . Perl не предоставляет таких ограничений, хотя вы, конечно, можете запрограммировать Perl таким образом, если хотите.</target>
        </trans-unit>
        <trans-unit id="587f845c68a8e5df6c3b5c11be163e859d4bde0c" translate="yes" xml:space="preserve">
          <source>The few places where stricter matching is used is in the middle of numbers, the &quot;name&quot; property, and in the Perl extension properties that begin or end with an underscore. Stricter matching cares about white space (except adjacent to non-word characters), hyphens, and non-interior underscores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3635eb281607d1f863de82b6a5a308964a4737" translate="yes" xml:space="preserve">
          <source>The field &quot;@*&quot; can be used for printing multi-line, nontruncated values; it should (but need not) appear by itself on a line. A final line feed is chomped off, but all other characters are emitted verbatim.</source>
          <target state="translated">Поле &quot;@*&quot; может быть использовано для печати многострочных,непересекающихся значений;оно должно (но не обязательно)появляться само по себе на строке.Окончательный перевод строки отсекается,но все остальные символы выделяются дословно.</target>
        </trans-unit>
        <trans-unit id="90122eb3cf35f8e2aff21a4431fdb4311bb6f9c0" translate="yes" xml:space="preserve">
          <source>The field of Linguistics has expended a great deal of effort over the past century trying to find grammatical patterns which hold across languages; it's been a constant process of people making generalizations that should apply to all languages, only to find out that, all too often, these generalizations fail -- sometimes failing for just a few languages, sometimes whole classes of languages, and sometimes nearly every language in the world except English. Broad statistical trends are evident in what the &quot;average language&quot; is like as far as what its rules can look like, must look like, and cannot look like. But the &quot;average language&quot; is just as unreal a concept as the &quot;average person&quot; -- it runs up against the fact no language (or person) is, in fact, average. The wisdom of past experience leads us to believe that any given language can do whatever it wants, in any order, with appeal to any kind of grammatical categories wants -- case, number, tense, real or metaphoric characteristics of the things that words refer to, arbitrary or predictable classifications of words based on what endings or prefixes they can take, degree or means of certainty about the truth of statements expressed, and so on, ad infinitum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f6e6f64de0d391d989196e8ebb7ddb708ac60a" translate="yes" xml:space="preserve">
          <source>The fields are discussed in more detail below:</source>
          <target state="translated">Более подробно эти поля рассматриваются ниже:</target>
        </trans-unit>
        <trans-unit id="c46c3f9340cdb846123d0b6b0164cec0b439e50c" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in &lt;code&gt;S_parse_body&lt;/code&gt;, and the :offset (might be missing) tells how much inside the &lt;code&gt;S_parse_body&lt;/code&gt; the program counter was.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21955b9d1337383a18b406fff73dac35d4d6488" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in S_parse_body, and the :offset (might be missing) tells how much inside the S_parse_body the program counter was.</source>
          <target state="translated">Поля разделены на таблички.Первый столбец-это глубина (ноль-это самая внутренняя неоткрытая рамка).В hex:offset счетчик программы находится в S_parse_body,а :offset (может отсутствовать)говорит о том,сколько внутри S_parse_body находился счетчик программы.</target>
        </trans-unit>
        <trans-unit id="f2427d714dfbcb812d5c2c0e464389b37b28e37a" translate="yes" xml:space="preserve">
          <source>The fields in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aabcb5c5289f7ad819b54aa9417f88080d7fec5" translate="yes" xml:space="preserve">
          <source>The fields of interest which may appear in this line are</source>
          <target state="translated">Поля интересов,которые могут появиться в этой строке,следующие</target>
        </trans-unit>
        <trans-unit id="834f0bb251e57720466af45a551b7e653c4d2d6b" translate="yes" xml:space="preserve">
          <source>The fields of the context struct and the arguments to the &lt;code&gt;cx_*&lt;/code&gt; functions are subject to change between perl releases, representing whatever is convenient or efficient for that release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">Файл</target>
        </trans-unit>
        <trans-unit id="99944ba23fa1671290cc70fdf7f917ecb5343db9" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in.</source>
          <target state="translated">Файл (имя),в котором произошла ошибка.</target>
        </trans-unit>
        <trans-unit id="801d0d7bebcd5bd5a38aa07b4d567dc82dc85f4a" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in. Defaults to the name of the current file being processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74280467b06cd39e1ebe6f256e50f06eca04fcbe" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;perlio.c&lt;/code&gt; provides the following layers:</source>
          <target state="translated">Файл &lt;code&gt;perlio.c&lt;/code&gt; содержит следующие слои:</target>
        </trans-unit>
        <trans-unit id="b4bb1e7661bc100161f83c2b2d4bc9930cd6bed6" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">Файл MANIFEST.SKIP может содержать регулярные выражения файлов, которые должны игнорироваться mkmanifest () и filecheck (). Регулярные выражения должны появляться по одному в каждой строке. Пустые строки и строки, начинающиеся с символа &lt;code&gt;#&lt;/code&gt; , пропускаются. Используйте &lt;code&gt;\#&lt;/code&gt; если вам нужно, чтобы регулярное выражение начиналось с символа &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4d65899438f61d608a7cb61bcc5fc30c8781c4" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2791b558da2cb7ec65180cdaeb2459b7a1726fa1" translate="yes" xml:space="preserve">
          <source>The file Makefile.PL should look something like this:</source>
          <target state="translated">Файл Makefile.PL должен выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="76e388baaf2a00fb72a8272cf31814ec70994241" translate="yes" xml:space="preserve">
          <source>The file Mytest.pm should start with something like this:</source>
          <target state="translated">Файл Mytest.pm должен начинаться с чего-то подобного:</target>
        </trans-unit>
        <trans-unit id="a37078c2a2fb3ae7f022a61feee12e4a85c77a67" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2001-2012 Unicode, Inc. Distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt;.</source>
          <target state="translated">Файл Unicode / Collate / allkeys.txt был дословно скопирован с &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt; . Для этого файла авторское право (c) 2001-2012 Unicode, Inc. Распространяется в соответствии с Условиями использования на &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30a5f318824f5507113c28e19247cf8309413692" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2016 Unicode, Inc.; distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/terms_of_use.html&quot;&gt;http://www.unicode.org/terms_of_use.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62650cf0603ff005f62bd4285e66f368ae95b8ff" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;https://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2016 Unicode, Inc.; distributed under the Terms of Use in &lt;a href=&quot;https://www.unicode.org/terms_of_use.html&quot;&gt;http://www.unicode.org/terms_of_use.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588cd9780438caba5355d1e82516b077a96efe46" translate="yes" xml:space="preserve">
          <source>The file in which the error occurred (eg, &lt;code&gt;myscript.pl&lt;/code&gt; or &lt;code&gt;MyTest.pm&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1744236e794a4c53bf20da07fd1df8dc62fc8e81" translate="yes" xml:space="preserve">
          <source>The file is</source>
          <target state="translated">Файл</target>
        </trans-unit>
        <trans-unit id="e4567b3de0171c763b083662777b94d3405e1c0f" translate="yes" xml:space="preserve">
          <source>The file is a sparse file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a1515b1fc6663ef9dea0c0281497256e9502ad" translate="yes" xml:space="preserve">
          <source>The file is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because often the application deletes the temporary file shortly after the handle is closed. In that case, the system can entirely avoid writing the data. Otherwise, the data will be written after the handle is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a42520a58ddeeb12292112f2a308b0310a0a00" translate="yes" xml:space="preserve">
          <source>The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.</source>
          <target state="translated">Файл удаляется при закрытии дескриптора или при выходе из программы.Доступ к имени файла не предоставляется.</target>
        </trans-unit>
        <trans-unit id="5b68113e94418bbe01dba1e8408762baaba90492" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt; , in case you add more statements.</source>
          <target state="translated">Файл должен возвращать истину в качестве последнего оператора, чтобы указать на успешное выполнение любого кода инициализации, поэтому обычно такой файл заканчивается &lt;code&gt;1;&lt;/code&gt; если вы не уверены, что в противном случае он вернет true. Но лучше просто поставить &lt;code&gt;1;&lt;/code&gt; , на случай, если вы добавите больше заявлений.</target>
        </trans-unit>
        <trans-unit id="db479c8e212dd28f37cf11de532fb13a4706ab4c" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt;, in case you add more statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda785c206d1d83026d51c7970996f0a544bbd22" translate="yes" xml:space="preserve">
          <source>The file named in VERSION_FROM is not added as a dependency to Makefile. This is not really correct, but it would be a major pain during development to have to rewrite the Makefile for any smallish change in that file. If you want to make sure that the Makefile contains the correct VERSION macro after any change of the file, you would have to do something like</source>
          <target state="translated">Файл с именем VERSION_FROM не добавляется в качестве зависимости от Makefile.Это не совсем верно,но было бы большой болью при разработке,если бы пришлось переписывать Makefile для любого небольшого изменения в этом файле.Если вы хотите убедиться,что Makefile содержит правильный макрос VERSION после любого изменения файла,вам нужно будет сделать что-то вроде</target>
        </trans-unit>
        <trans-unit id="1264aef66e240939ce372646b5dc5401497e1664" translate="yes" xml:space="preserve">
          <source>The file or directory has an associated reparse point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af548b827b63fa83aaea96b3b1471e3f70a720b8" translate="yes" xml:space="preserve">
          <source>The file or directory has no other attributes set. This attribute is valid only if used alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a20833b40e53533fae911a70eb77893d34ddc0e" translate="yes" xml:space="preserve">
          <source>The file or directory is an archive file or directory. Applications use this attribute to mark files for backup or removal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a28a2595e27b62a75bd273e98ef20b3ef8db95b" translate="yes" xml:space="preserve">
          <source>The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d84e09e4ae07a74635af247678d4e0053654f7b" translate="yes" xml:space="preserve">
          <source>The file or directory is encrypted. For a file, this means that all data streams in the file are encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97235d485d43a9b6726df3990eccad2157355604" translate="yes" xml:space="preserve">
          <source>The file or directory is hidden. It is not included in an ordinary directory listing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511d8ef3c0880481e73ffbe5546aad0ca9af7623" translate="yes" xml:space="preserve">
          <source>The file or directory is part of, or is used exclusively by, the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a862ef7b392abfc56ec7987f674bfc97e4e196" translate="yes" xml:space="preserve">
          <source>The file or directory is read-only. Applications can read the file but cannot write to it or delete it. In the case of a directory, applications cannot delete it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdaf2cba4d9764ecdf7f47c7aa146b4c33b7bbf0" translate="yes" xml:space="preserve">
          <source>The file redirection characters &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, and &quot;|&quot; can be quoted by double quotes (although there are suggestions that this may not always be true). Single quotes are not treated as quotes by the shell or the C runtime, they don't get stripped by the shell (just to make this type of quoting completely useless). The caret &quot;^&quot; has also been observed to behave as a quoting character, but this appears to be a shell feature, and the caret is not stripped from the command line, so Perl still sees it (and the C runtime phase does not treat the caret as a quote character).</source>
          <target state="translated">Символы перенаправления файлов &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot; и &quot;|&quot; можно заключить в двойные кавычки (хотя есть предположения, что это не всегда может быть правдой). Одиночные кавычки не обрабатываются оболочкой или средой выполнения C как кавычки, они не удаляются оболочкой (просто чтобы сделать этот тип цитирования совершенно бесполезным). Каретка &amp;laquo;^&amp;raquo; также ведет себя как символ кавычек, но это похоже на функцию оболочки, и каретка не удаляется из командной строки, поэтому Perl все еще видит ее (а фаза выполнения C не обрабатывает каретка как символ кавычки).</target>
        </trans-unit>
        <trans-unit id="50901ff92251eec862c454e35476bb796a0417dd" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the &lt;code&gt;binmode()&lt;/code&gt; function to change the mode of the filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fb6cb3aabc05d2c0113ff975b6b538671a53b3" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the C</source>
          <target state="translated">Файл,возвращенный по команде File::Temp,будет открыт в двоичном режиме,если такой режим доступен.Если это неправильно,используйте C</target>
        </trans-unit>
        <trans-unit id="ce9457f95e305ab599387997a39303f4f4596d9a" translate="yes" xml:space="preserve">
          <source>The file specifications of &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; will be converted to &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[-]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1bf193f0391c5390c8fed583c48df05d19c307" translate="yes" xml:space="preserve">
          <source>The file system preserves Unicode in file names [true for &quot;NTFS&quot;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb5efb93d11a4fd3e9514acb9b3c301836d1d02" translate="yes" xml:space="preserve">
          <source>The file system preserves the case of file names [usually true]. That is, it doesn't change the case of file names such as forcing them to upper- or lower-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04a32c75b0e4d58abe85e387d4b6865a5c9ef55" translate="yes" xml:space="preserve">
          <source>The file system supports compression on a per-file basis [true for &quot;NTFS&quot;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d32a15b0b05b7bd2cbe516ad58a7e5b3062c6e8" translate="yes" xml:space="preserve">
          <source>The file system supports setting Access Control Lists on files [true for &quot;NTFS&quot;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78fe12a81a2024d0eb3a6b039559611ea6c933d5" translate="yes" xml:space="preserve">
          <source>The file system supports the ability to not ignore the case of file names [but might ignore case the way you are using it]. That is, the file system has the ability to force you to get the letter case of a file's name exactly right to be able to open it. This is true for &quot;NTFS&quot; file systems, even though case in file names is usually still ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3318e11fa92791fcdb7d551f55db23d41576d211" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;a href=&quot;perlfunc#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c1f1869978b35696fb14c540a8ba10948b7605" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="translated">Тип файла или расширение всегда присутствует в спецификации файла формата VMS, даже если он нулевой длины. Это означает, что по умолчанию &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; вернет конечную точку в файле без расширения, поэтому там, где вы увидите &lt;code&gt;&quot;a&quot;&lt;/code&gt; в Unix, вы увидите &lt;code&gt;&quot;a.&quot;&lt;/code&gt; на VMS. Однако &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; точка может быть подавлена ​​включением функции DECC $ READDIR_DROPDOTNOTYPE в среде (см. Документацию CRTL о логических именах функций).</target>
        </trans-unit>
        <trans-unit id="4023271c9fc7425e571468846ea1d383c9d49eba" translate="yes" xml:space="preserve">
          <source>The file types are:</source>
          <target state="translated">Типы файлов:</target>
        </trans-unit>
        <trans-unit id="913f7be6fa85f1e72e30e862d223c440b0b1e681" translate="yes" xml:space="preserve">
          <source>The file will not be indexed by the content indexing service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43719b35ec87acc604024ce99c0c8fb60624b26e" translate="yes" xml:space="preserve">
          <source>The file's mode</source>
          <target state="translated">Режим файла</target>
        </trans-unit>
        <trans-unit id="a95c16ea1ecea8120f9e1164c67484d409f61395" translate="yes" xml:space="preserve">
          <source>The file's name</source>
          <target state="translated">Имя файла</target>
        </trans-unit>
        <trans-unit id="4b9a5685b1075bc4b20ae964579e2b1d813d620d" translate="yes" xml:space="preserve">
          <source>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</source>
          <target state="translated">Родительский процесс ведет себя нормально,но ввод/вывод к этому файловому процессу осуществляется из/в STDOUT/STDIN дочернего процесса.В дочернем процессе файловая папка не открывается-вход/выход происходит из/к новому STDOUT/STDIN.Обычно это используется как обычный открытый конвейер,когда вы хотите получить больше контроля над тем,как выполняется команда канала,например,при запуске setuid,и вам не нужно сканировать команды оболочки на наличие метасимволов.</target>
        </trans-unit>
        <trans-unit id="92ee26a1481d9c364e91c69e1999f81d1550b5da" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d3d5cbabb04fbe3144e08782ff5dbb8eaf643d" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">Дескриптор файла будет закрыт, когда его счетчик ссылок достигнет нуля. Если это переменная с лексической областью видимости, объявленная с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , это обычно означает конец охватывающей области. Однако это автоматическое закрытие не проверяет наличие ошибок, поэтому лучше явно закрыть дескрипторы файлов, особенно те, которые используются для записи:</target>
        </trans-unit>
        <trans-unit id="c6da7495029a8eadd3a9c0429778422e3ffb1d61" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">Дескриптор файла будет закрыт, когда его счетчик ссылок достигнет нуля. Если это переменная с лексической областью видимости, объявленная с помощью &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , это обычно означает конец охватывающей области. Однако это автоматическое закрытие не проверяет наличие ошибок, поэтому лучше явно закрыть дескрипторы файлов, особенно те, которые используются для записи:</target>
        </trans-unit>
        <trans-unit id="f157c14e0e96a0cb19a8e1a0df5c9ee87ca4b5e2" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details on this.</source>
          <target state="translated">Дескрипторы файлов STDIN, STDOUT и STDERR предопределены. (Дескрипторы файлов &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; также будут работать, за исключением пакетов, где они будут интерпретироваться как локальные идентификаторы, а не как глобальные.) Дополнительные дескрипторы файлов могут быть созданы , среди прочего, с помощью функции &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; . См. &lt;a href=&quot;perlopentut&quot;&gt;Perlopentut&lt;/a&gt; и &lt;a href=&quot;functions/open&quot;&gt;откройте&lt;/a&gt; подробности об этом.</target>
        </trans-unit>
        <trans-unit id="dabead5f141fbdd7cbaf6b6ee9ed1c9d5ac4b10f" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;open()&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for details on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586bcd238ccd4b9fecd344d54e37e9531bdb9cd2" translate="yes" xml:space="preserve">
          <source>The filehandles may also be integers, in which case they are understood as file descriptors.</source>
          <target state="translated">Файловые дескрипторы также могут быть целыми числами,в этом случае они понимаются как дескрипторы файлов.</target>
        </trans-unit>
        <trans-unit id="66a7978092f9f45d843d817f4a627ae3fdb00a8b" translate="yes" xml:space="preserve">
          <source>The filename of the data store holding the data that App::Prove::State reads.</source>
          <target state="translated">Имя файла хранилища данных,содержащего данные,которые App::Prove::State читает.</target>
        </trans-unit>
        <trans-unit id="6d594502076d5702a51ff03f260fd4c765a898ae" translate="yes" xml:space="preserve">
          <source>The filename of the perllibrary that will be used together with this extension. Defaults to libperl.a.</source>
          <target state="translated">Имя файла перллибразы,который будет использоваться вместе с этим расширением.По умолчанию libperl.a.</target>
        </trans-unit>
        <trans-unit id="76201dda41fb8f7d14160ae0f46e9ddf9f7d7f60" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b0656face1bd799f2d3aeeb4a33e8ccdb99fbf" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="translated">Имя файла,переданное в одно-и двухпараметрическую форму open(),будет иметь лидирующий и трейлинговый пробельные символы,удаленные,и нормальные символы перенаправления будут соблюдены.Это свойство,известное как &quot;magic open&quot;,часто может быть использовано для достижения хорошего эффекта.Пользователь может указать имя файла</target>
        </trans-unit>
        <trans-unit id="6d720ff4e8b207a8fa86d2d1f6ed053fe36cb247" translate="yes" xml:space="preserve">
          <source>The files</source>
          <target state="translated">Файлы</target>
        </trans-unit>
        <trans-unit id="5e8ac4ea16fdec255bb3d994323e38344f15cd1a" translate="yes" xml:space="preserve">
          <source>The files in the &quot;qnx&quot; directory are:</source>
          <target state="translated">Файлы в каталоге &quot;qnx&quot;:</target>
        </trans-unit>
        <trans-unit id="ccf1a34f9c5304eccd7056360fe19cfcc880dfc0" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither access timestamp nor change timestamp (meaning that about the only portable timestamp is the modification timestamp), or one second granularity of any timestamps (e.g. the FAT filesystem limits the time granularity to two seconds).</source>
          <target state="translated">Файловая система может не поддерживать ни метку времени доступа,ни метку времени изменения (это означает,что единственной переносимой меткой времени является метка времени изменения),ни одну секунду гранулярности любых меток времени (например,файловая система FAT ограничивает гранулярность времени двумя секундами).</target>
        </trans-unit>
        <trans-unit id="9640e3801c8da6fb8d4c4212946957e9fbfe8dbf" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;a href=&quot;perlfunc#link-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;link&lt;/code&gt;&lt;/a&gt;) nor symbolic links (&lt;a href=&quot;perlfunc#symlink-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;symlink&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#readlink-EXPR&quot;&gt;&lt;code&gt;readlink&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acc2f4b822151bd730e57f84d225c79d062f507" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;) nor symbolic links (&lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Файловая система не может поддерживать ни жесткие ссылки ( &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; ), ни символические ссылки ( &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="15629c3f6edb637003db8544e5aa317bc95e5e82" translate="yes" xml:space="preserve">
          <source>The filesystem of Symbian devices uses DOSish syntax, &quot;drives&quot; separated from paths by a colon, and backslashes for the path. The exact assignment of the drives probably varies between platforms, but for example in Series 60 you might see C: as the (flash) main memory, D: as the RAM drive, E: as the memory card (MMC), Z: as the ROM. In Series 80 D: is the memory card. As far the devices go the NUL: is the bit bucket, the COMx: are the serial lines, IRCOMx: are the IR ports, TMP: might be C:\System\Temp. Remember to double those backslashes in doublequoted strings.</source>
          <target state="translated">Файловая система устройств Symbian использует синтаксис DOSish,&quot;диски&quot;,отделенные от путей двоеточием,и обратные слэши для пути.Точное назначение дисков,вероятно,варьируется в зависимости от платформы,но,например,в Серии 60 вы можете видеть C:в качестве (флэш)основной памяти,D:в качестве привода оперативной памяти,E:в качестве карты памяти (MMC),Z:в качестве ПЗУ.В Серии 80 D:это карта памяти.Что касается устройств,то NUL:это ведро битов,COMx:это последовательные линии,IRCOMx:это ИК-порты,TMP:может быть C:\System\Temp.Не забудьте удвоить эти обратные слэши в строках в двойных кавычках.</target>
        </trans-unit>
        <trans-unit id="60abfd860ab77072c0ffed33f686231d933f221b" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="translated">Операторы проверки файлов &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; и &lt;code&gt;-B&lt;/code&gt; не реализованы, поскольку для них требуется больше информации, чем просто буфер статистики.</target>
        </trans-unit>
        <trans-unit id="2f0292fee7197d3e8ac530c889c496fd989569af" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32f19af093b1f7fb24c634263035e297b5a2ba3" translate="yes" xml:space="preserve">
          <source>The filter ensures that Perl parses the code between the &amp;lt;DEBUG_BEGIN&amp;gt; and &lt;code&gt;DEBUG_END&lt;/code&gt; markers only when the &lt;code&gt;DEBUG&lt;/code&gt; environment variable exists. That means that when &lt;code&gt;DEBUG&lt;/code&gt; does exist, the code above should be passed through the filter unchanged. The marker lines can also be passed through as-is, because the Perl parser will see them as comment lines. When &lt;code&gt;DEBUG&lt;/code&gt; isn't set, we need a way to disable the debug code. A simple way to achieve that is to convert the lines between the two markers into comments:</source>
          <target state="translated">Фильтр гарантирует, что Perl анализирует код между маркерами &amp;lt;DEBUG_BEGIN&amp;gt; и &lt;code&gt;DEBUG_END&lt;/code&gt; только при наличии переменной среды &lt;code&gt;DEBUG&lt;/code&gt; . Это означает, что когда &lt;code&gt;DEBUG&lt;/code&gt; действительно существует, приведенный выше код должен быть пропущен через фильтр без изменений. Строки маркеров также можно передавать как есть, потому что синтаксический анализатор Perl увидит их как строки комментариев. Когда &lt;code&gt;DEBUG&lt;/code&gt; не установлен, нам нужен способ отключить код отладки. Простой способ добиться этого - преобразовать строки между двумя маркерами в комментарии:</target>
        </trans-unit>
        <trans-unit id="3cfa6a6fd2754ac19a694b001066c8361c789aec" translate="yes" xml:space="preserve">
          <source>The filter included are:</source>
          <target state="translated">Фильтр входит в комплект поставки:</target>
        </trans-unit>
        <trans-unit id="06dac022e678c85372a6fa4a8e6e10c155086a90" translate="yes" xml:space="preserve">
          <source>The filter is applied to</source>
          <target state="translated">Фильтр применяется для</target>
        </trans-unit>
        <trans-unit id="6311b9692024a04fd6e913eb59f189ec85a241cf" translate="yes" xml:space="preserve">
          <source>The filter is applied to the key</source>
          <target state="translated">Фильтр применяется к ключу</target>
        </trans-unit>
        <trans-unit id="edd6196707ee8763311d3aafd47d83821af190dd" translate="yes" xml:space="preserve">
          <source>The filter is applied to the value</source>
          <target state="translated">Фильтр применяется к значению</target>
        </trans-unit>
        <trans-unit id="6693f0e2b9229e67ead2ac6746c8771a8ed55fa9" translate="yes" xml:space="preserve">
          <source>The final &lt;code&gt;PUTBACK&lt;/code&gt; is used to leave the Perl stack in a consistent state before exiting the function. This is necessary because when we popped the return value from the stack with &lt;code&gt;POPi&lt;/code&gt; it updated only our local copy of the stack pointer. Remember, &lt;code&gt;PUTBACK&lt;/code&gt; sets the global stack pointer to be the same as our local copy.</source>
          <target state="translated">Последний &lt;code&gt;PUTBACK&lt;/code&gt; используется, чтобы оставить стек Perl в согласованном состоянии перед выходом из функции. Это необходимо, потому что, когда мы извлекаем возвращаемое значение из стека с помощью &lt;code&gt;POPi&lt;/code&gt; , обновляется только наша локальная копия указателя стека. Помните, что &lt;code&gt;PUTBACK&lt;/code&gt; устанавливает глобальный указатель стека таким же, как наша локальная копия.</target>
        </trans-unit>
        <trans-unit id="6d574089f345d41e6ac1476fc2b80885aa410f07" translate="yes" xml:space="preserve">
          <source>The final character can't be a hyphen, colon, or period. URLs ending with these characters, while allowed by XHTML, can be awkward to extract from plain text.</source>
          <target state="translated">Последним персонажем не может быть дефис,толстая кишка или точка.URL-адреса,заканчивающиеся этими символами,хотя и разрешены XHTML,могут быть неудобными для извлечения из простого текста.</target>
        </trans-unit>
        <trans-unit id="0a99e11f3a928dd6413c811829c3b9af3764501f" translate="yes" xml:space="preserve">
          <source>The final difference between regular bracketed character classes and these, is that it is not possible to get these to match a multi-character fold. Thus,</source>
          <target state="translated">Последняя разница между обычными классами символов,заключенными в квадратные скобки,заключается в том,что их невозможно получить,чтобы они совпадали с многосимвольными сгибами.Таким образом,</target>
        </trans-unit>
        <trans-unit id="cde87782285bb08650f77bdd2e4ce0e06adc25ff" translate="yes" xml:space="preserve">
          <source>The final element of a list assignment may be an array or a hash:</source>
          <target state="translated">Последним элементом назначения списка может быть массив или хэш:</target>
        </trans-unit>
        <trans-unit id="bee7b4f4630bbb2daf491aa012bc945e164b3e70" translate="yes" xml:space="preserve">
          <source>The final example shows that the characters &lt;code&gt;&quot;{&quot;&lt;/code&gt; and &lt;code&gt;&quot;}&quot;&lt;/code&gt; are metacharacters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74663d384e88ec12c85ff6a9f4b23592b8a3858" translate="yes" xml:space="preserve">
          <source>The final line (with Index [242]) means that the value for all code points above the legal Unicode maximum code point have the value &quot;No_Block&quot;, which is the term Unicode uses for a non-existing block.</source>
          <target state="translated">Последняя строка (с индексом [242])означает,что значение для всех кодовых точек,расположенных выше легальной максимальной кодовой точки Юникода,имеет значение &quot;No_Block&quot;,которое является термином,используемым в Юникоде для несуществующего блока.</target>
        </trans-unit>
        <trans-unit id="e6811c076957053b2764757de731f2de38b4111a" translate="yes" xml:space="preserve">
          <source>The final operation uses the backslash character to invalidate the special meaning of an open square bracket &lt;code&gt;[&lt;/code&gt;, the asterisk, backslash or the question mark. Two backslashes in sequence will result in the evaluation of the backslash as a character with no special meaning.</source>
          <target state="translated">В последней операции используется символ обратной косой черты, чтобы аннулировать специальное значение открытой квадратной скобки &lt;code&gt;[&lt;/code&gt; , звездочки, обратной косой черты или вопросительного знака. Последовательные две обратные косые черты приведут к оценке обратной косой черты как символа без особого значения.</target>
        </trans-unit>
        <trans-unit id="be0c78c80ebce8da51fa36633d30ae64f567f49f" translate="yes" xml:space="preserve">
          <source>The final semicolon in a block is optional, as is the final comma in a list. Good style (see &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;) says to put them in except for one-liners:</source>
          <target state="translated">Последняя точка с запятой в блоке необязательна, как и последняя запятая в списке. Хороший стиль (см. &lt;a href=&quot;perlstyle&quot;&gt;Perlstyle&lt;/a&gt; ) говорит, что нужно вставить их, кроме однострочных:</target>
        </trans-unit>
        <trans-unit id="16f205f9e57e8503952af3471732d873e8a9fc93" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR or within the BLOCK.</source>
          <target state="translated">Окончательная точка с запятой,если таковая имеется,может быть опущена из значения EXPR или в пределах БЛОКИРОВКИ.</target>
        </trans-unit>
        <trans-unit id="701bfb8c787a64e7b1b253a3f8fa1a79c79b9b4d" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f49a63a6bf839dcb9a9ccbe0a34339c52904e4c" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from within the BLOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee4566a0600358ccd1fe8d6c5a93a6cd48a9d99" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="translated">На последнем этапе вызывается &lt;code&gt;test_test&lt;/code&gt; , который просто сравнивает то, что вы предварительно объявили, с тем, что на самом деле выводит &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; , и сообщает результаты с &amp;laquo;ok&amp;raquo; или &amp;laquo;not ok&amp;raquo; (с отладкой) с нормальным выводом.</target>
        </trans-unit>
        <trans-unit id="a77ba1afa8fadab31ac1c8125c1a4cf3b74fcb5e" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31473d1a074747714a49e0fc3e7edd46729c2ea4" translate="yes" xml:space="preserve">
          <source>The final step involves passing each filename matched by the &lt;code&gt;*.tar.gz&lt;/code&gt; file glob through the derived Perl regular expression in turn and expanding the output fileglob using it.</source>
          <target state="translated">Последний шаг включает в себя прохождение каждого имени файла, совпадающего с глобусом файла &lt;code&gt;*.tar.gz&lt;/code&gt; , через производное регулярное выражение Perl по очереди и расширение выходного глобуса файла с его помощью.</target>
        </trans-unit>
        <trans-unit id="d96d9b1e4edc6c2a13a6362b88a7c6a709b1d43c" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;//c&lt;/code&gt; , concern multiple matches. The modifier &lt;code&gt;//g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Последние два модификатора, которые мы здесь обсудим, &lt;code&gt;//g&lt;/code&gt; и &lt;code&gt;//c&lt;/code&gt; , относятся к нескольким совпадениям. Модификатор &lt;code&gt;//g&lt;/code&gt; обозначает глобальное сопоставление и позволяет оператору сопоставления выполнять сопоставление в строке как можно больше раз. В скалярном контексте при последующих вызовах строки &lt;code&gt;//g&lt;/code&gt; будет переходить от совпадения к совпадению, отслеживая положение в строке по мере ее продвижения. Вы можете получить или установить позицию с помощью функции &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="789fdded843f5a388c6234d5037a293bfbacec0d" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;/g&lt;/code&gt; and &lt;code&gt;/c&lt;/code&gt;, concern multiple matches. The modifier &lt;code&gt;/g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;/g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;pos()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68bb0429a21250927b8f2328dd69f3ab3c62b7fa" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange%28%29&quot;&gt;&quot;charinrange()&quot;&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b0c89da94c5764d6322358005c665b7a6ec505" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="translated">Последний, четвертый элемент (индекс [3], присвоенный &lt;code&gt;$default&lt;/code&gt; в примере &amp;laquo;блока&amp;raquo;) в списке из четырех элементов, возвращаемых этой функцией, используется с типами формата &lt;code&gt;&quot;a&quot;&lt;/code&gt; ; это также может быть полезно для приложений, которые хотят преобразовать возвращенную структуру данных карты инверсии в какую-либо другую, например хэш. Он дает отображение, которое соответствует большинству кодовых точек под свойством. Если вы установите соглашение, согласно которому любая кодовая точка, явно не указанная в вашей структуре данных, сопоставляется с этим значением, вы потенциально можете сделать структуру данных намного меньше. Создавая структуру данных из структуры, возвращаемой этой функцией, просто игнорируйте те диапазоны, которые соответствуют этому значению. Например, для преобразования в структуру данных, доступную для поиска с помощью &lt;a href=&quot;#charinrange()&quot;&gt;charinrange ()&lt;/a&gt;, вы можете следовать этому рецепту для свойств, которые не требуют настройки:</target>
        </trans-unit>
        <trans-unit id="20c1b5c18477e5291b6b00c55abb0e8a3b781429" translate="yes" xml:space="preserve">
          <source>The find_dup() Method</source>
          <target state="translated">Метод find_dup()</target>
        </trans-unit>
        <trans-unit id="a4105f4f4646c65f036c1e5edea46eddb3a8418a" translate="yes" xml:space="preserve">
          <source>The first (and now failed) goal of Unicode was to map all character repertoires into a fixed-length integer so that programmers are happy. Since each character is either a</source>
          <target state="translated">Первой (и теперь неудачной)целью Юникода было отобразить все репертуары символов в целое число фиксированной длины,чтобы программисты были довольны.Так как каждый символ является либо</target>
        </trans-unit>
        <trans-unit id="172226a1c7ce5a6d06797585142c70179c0ec58b" translate="yes" xml:space="preserve">
          <source>The first &lt;b&gt;PAUSE&lt;/b&gt; author to upload a &lt;b&gt;namespace&lt;/b&gt; automatically becomes the &lt;b&gt;primary maintainer&lt;/b&gt; for that namespace. The &amp;ldquo;first come&amp;rdquo; permissions distinguish a &lt;b&gt;primary maintainer&lt;/b&gt; who was assigned that role from one who received it automatically.</source>
          <target state="translated">Первый автор &lt;b&gt;PAUSE,&lt;/b&gt; загрузивший &lt;b&gt;пространство имен,&lt;/b&gt; автоматически становится &lt;b&gt;основным сопровождающим&lt;/b&gt; для этого пространства имен. Разрешения &amp;laquo;первым пришел&amp;raquo; отличает &lt;b&gt;основного сопровождающего,&lt;/b&gt; которому была назначена эта роль, от того, кто получил ее автоматически.</target>
        </trans-unit>
        <trans-unit id="97526a10437e54c9f14361d8f57177e27604beab" translate="yes" xml:space="preserve">
          <source>The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo. The second Perl argument would be treated as a string pointer and assigned to the variable b. The</source>
          <target state="translated">Первый аргумент Perl для этой функции будет рассматриваться как char и присваиваться переменной a,а ее адрес передаваться в функцию foo.Второй аргумент Perl будет обработан как строковый указатель и присвоен переменной b.The</target>
        </trans-unit>
        <trans-unit id="c3453154bc2cd37e63c9b0f3f784faca750ac354" translate="yes" xml:space="preserve">
          <source>The first alternative includes everything from the last pattern delimiter (&lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;(?:&quot;&lt;/code&gt; (described later),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e4f6464deede9ad4eff50e6de5039522d07e08" translate="yes" xml:space="preserve">
          <source>The first and second arguments may be strings, typeglobs, typeglob references, or objects inheriting from IO::Handle; they are used in all cases to obtain the</source>
          <target state="translated">Первым и вторым аргументами могут быть строки,typeglobs,typeglob ссылки,или объекты,наследуемые от IO::Handle;во всех случаях они используются для получения</target>
        </trans-unit>
        <trans-unit id="f11ee434e9fca49f11d7860f46bcba7e793d3dea" translate="yes" xml:space="preserve">
          <source>The first and second forms explicitly identify the name of the class being created. The third form assumes the current package name as the class name.</source>
          <target state="translated">Первая и вторая формы явно идентифицируют имя создаваемого класса.Третья форма принимает текущее имя пакета как имя класса.</target>
        </trans-unit>
        <trans-unit id="1490a2bc188cd4f0f1d7d40df76c523f30ba9b64" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;pointer&lt;/code&gt; should be the name of a variable that will point to the newly allocated memory.</source>
          <target state="translated">Первым &lt;code&gt;pointer&lt;/code&gt; аргумента должно быть имя переменной, которая будет указывать на вновь выделенную память.</target>
        </trans-unit>
        <trans-unit id="80c48ff540490ea5dad5fc5e056d6677cb16264e" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;&quot;LOCALE CATEGORIES&quot;&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f43aa625d664f2ba3718ef0a1149ca5df8580dd" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="translated">Первый аргумент &lt;code&gt;setlocale()&lt;/code&gt; дает &lt;b&gt;категорию&lt;/b&gt; , второй - &lt;b&gt;локаль&lt;/b&gt; . Категория указывает, в каком аспекте обработки данных вы хотите применить правила, зависящие от локали. Названия категорий обсуждаются в &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;ЛОКАЛЬНЫХ КАТЕГОРИЯХ&lt;/a&gt; и &lt;a href=&quot;#ENVIRONMENT&quot;&gt;СРЕДЕ&lt;/a&gt; . Локаль - это имя набора информации о настройке, соответствующей определенной комбинации языка, страны или территории и кодового набора. Читайте советы по именованию локалей: не все системы называют локали, как в примере.</target>
        </trans-unit>
        <trans-unit id="fede859d91b131301182a8f517e78fcd79928ade" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;The wanted function&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7b3a91ac2b665d00253c60dfd683fd8e3981ca" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below.</source>
          <target state="translated">Первый аргумент функции &lt;code&gt;find()&lt;/code&gt; - это либо ссылка на код вашей функции &lt;code&gt;&amp;amp;wanted&lt;/code&gt; , либо ссылка на хэш, описывающая операции, которые необходимо выполнить для каждого файла. Ссылка на код описана в &lt;a href=&quot;#The-wanted-function&quot;&gt;разделе &amp;laquo;Требуемая функция&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="7c957468bac2255084a035a3220d83572a45006f" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;open&lt;/code&gt;, labeled FILEHANDLE in this reference, is usually a scalar variable. (Exceptions exist, described in &quot;Other considerations&quot;, below.) If the call to &lt;code&gt;open&lt;/code&gt; succeeds, then the expression provided as FILEHANDLE will get assigned an open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbf5c859ede86efd02d67b5ed562cbefaa9fa86" translate="yes" xml:space="preserve">
          <source>The first call creates a mortal SV (with no value), the second converts an existing SV to a mortal SV (and thus defers a call to &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), and the third creates a mortal copy of an existing SV. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; , etc. :</source>
          <target state="translated">Первый вызов создает смертный SV (без значения), второй преобразует существующий SV в смертный SV (и, таким образом, откладывает вызов &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), а третий создает смертную копию существующего SV. Поскольку &lt;code&gt;sv_newmortal&lt;/code&gt; не дает новому SV никакого значения, он обычно должен быть задан через &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; и т. Д . :</target>
        </trans-unit>
        <trans-unit id="4477498f36568777dd7d39a288f8eb78c180c0b5" translate="yes" xml:space="preserve">
          <source>The first call will cache the result, say 37, in the scalar cache; the second will cach the list &lt;code&gt;(37)&lt;/code&gt; in the list cache. The third call doesn't call the real &lt;code&gt;complicated&lt;/code&gt; function; it gets the value 37 from the scalar cache.</source>
          <target state="translated">Первый вызов кэширует результат, скажем, 37, в скалярный кеш; второй будет кэшировать список &lt;code&gt;(37)&lt;/code&gt; в кэше списков. Третий вызов не вызывает реальной &lt;code&gt;complicated&lt;/code&gt; функции; он получает значение 37 из скалярного кеша.</target>
        </trans-unit>
        <trans-unit id="cb2fb10ae2990b48a149ecb6c3ef672018aecbe1" translate="yes" xml:space="preserve">
          <source>The first call-back registered is the call back for waiting. It is expected that the callback will call the current event loop until there is something waiting to get on the input filehandle. The parameter passed in is the return value of the second call back.</source>
          <target state="translated">Первый зарегистрированный обратный вызов-это обратный вызов для ожидания.Предполагается,что обратный вызов будет вызывать текущий цикл обработки событий до тех пор,пока не появится что-то ожидающее,чтобы попасть на обработчик входного файла.Параметр,переданный во входном файле,является возвращаемым значением второго обратного вызова.</target>
        </trans-unit>
        <trans-unit id="356bc7c1108ec743988bf0e03b81bb507c0cc12b" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e0061b9a6b011cebcff05349c5ac1b63fa9755" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">Возвращается первая точка кода версии в сложенном виде (но обратите внимание,как объяснялось выше,что их может быть больше).</target>
        </trans-unit>
        <trans-unit id="f94f6bc950fffc56630abef7e060753be71264b0" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e520b61d264ebe77754743fca0b946c106ddd342" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more). It will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return the REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff810cbc1a30c3df94411ded7219d0513e8678c" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">Возвращается первый пункт кода строчной версии (но обратите внимание,как объяснялось выше,что их может быть больше).</target>
        </trans-unit>
        <trans-unit id="d7f11b85b3fd5fa2f0a6c5645eeff96adc2054e0" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caeb3f58f789aa5ac3e09cf711fff7133bd0293e" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">Возвращается первый пункт кода заглавной версии (но обратите внимание,как объяснялось выше,что может быть и больше).</target>
        </trans-unit>
        <trans-unit id="3acdfbd051e586c1763fcef89bd42028b50c7068" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa79c84ba894862a3bdfa5a898231ba1c669dc5c" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained at &lt;a href=&quot;#Character-case-changing&quot;&gt;the top of this section&lt;/a&gt;, that there may be more.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150061371074e1d388cb756c8513ea3bae095580" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">Возвращается первый пункт кода прописной версии (но обратите внимание,как объяснялось выше,что может быть и больше).</target>
        </trans-unit>
        <trans-unit id="b31a69e396cbea336ac162c9e038d50204a60559" translate="yes" xml:space="preserve">
          <source>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale is in effect that changes the &lt;code&gt;\s&lt;/code&gt; matching).</source>
          <target state="translated">Первый столбец дает кодовую точку Unicode символа (в шестнадцатеричном формате), второй столбец дает имя (Unicode). Третий столбец указывает, по какому классу (классам) соответствует символ (при условии, что никакая локаль не влияет на соответствие &lt;code&gt;\s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8beadb10ab71cda6dd02fa1a65287381a215cc85" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">Первый столбец в таблице - это название свойства; второй столбец - это альтернативное имя, если оно есть, плюс, возможно, некоторые аннотации. Альтернативным именем является полное имя свойства, если только это не будет просто повторять первый столбец, и в этом случае второй столбец указывает краткое имя свойства (если оно отличается). Аннотации даются только в записи на полное имя. Если свойство является устаревшим, и т.д., то запись будет помечена с теми же символами , используемых в таблице в &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;разделе выше&lt;/a&gt; , как &lt;b&gt;D&lt;/b&gt; или &lt;b&gt;S&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="0a9e1d7bc901ecffb197db410cd69bf5871b1113" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. The annotations for binary properties include a list of the first few ranges that the property matches. To avoid any ambiguity, the SPACE character is represented as &lt;code&gt;\x20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eff62aa7ff2adaee41faf8fb6df470068a01954" translate="yes" xml:space="preserve">
          <source>The first column is a set of flags, the second column the return type, the third column the name. Columns after that are the arguments. The flags are documented at the top of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b11168c63a090c6a2f9c94f928cd13ec49996f7" translate="yes" xml:space="preserve">
          <source>The first command sends both standard out and standard error to the temporary file. The second command sends only the old standard output there, and the old standard error shows up on the old standard out.</source>
          <target state="translated">Первая команда посылает во временный файл как стандартную ошибку,так и стандартную ошибку.Вторая команда посылает туда только старый стандартный вывод,а старая стандартная ошибка отображается на старом стандартном выходе.</target>
        </trans-unit>
        <trans-unit id="05c623db7c7d3a79e0f86ce6c1022ffde1e91677" translate="yes" xml:space="preserve">
          <source>The first element of @os_flavor is the major family (ie. Unix, Windows, VMS, OS/2, etc...) and the rest are sub families.</source>
          <target state="translated">Первым элементом @os_flavor является основное семейство (т.е.Unix,Windows,VMS,OS/2 и т.д...),а остальные-подсемейства.</target>
        </trans-unit>
        <trans-unit id="bf7e5d87f2410537daa86408c9c3f1321c88ab2f" translate="yes" xml:space="preserve">
          <source>The first entry in the string will run all tests in the top-level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b34621cb98b9f5d1895e9bf56ac10c10fa486de" translate="yes" xml:space="preserve">
          <source>The first example will be driven by an object of the class CPAN::Module, the second by an object of class CPAN::Distribution.</source>
          <target state="translated">Первый пример будет управляться объектом класса CPAN::Module,второй-объектом класса CPAN::Distribution.</target>
        </trans-unit>
        <trans-unit id="0a27c7509a2d370dd780c83c9db9ebfcd9028447" translate="yes" xml:space="preserve">
          <source>The first extension is an embedded comment &lt;code&gt;(?#text)&lt;/code&gt;. This embeds a comment into the regular expression without affecting its meaning. The comment should not have any closing parentheses in the text. An example is</source>
          <target state="translated">Первое расширение - это встроенный комментарий &lt;code&gt;(?#text)&lt;/code&gt; . Это встраивает комментарий в регулярное выражение, не влияя на его значение. В тексте комментария не должно быть закрывающих скобок. Примером является</target>
        </trans-unit>
        <trans-unit id="222cb4b3d3e8dffe112445249bb168e941db04b2" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , replacing your previous perl binary.</source>
          <target state="translated">Первая дополнительная инструкция устанавливает переменную среды FNCASE DJGPP таким образом, чтобы новый двоичный файл perl, который вы должны создать для модуля XS-типа, был построен правильно. Вторая дополнительная инструкция перестраивает двоичный файл perl в каталоге вашего модуля перед запуском команды &amp;laquo;make test&amp;raquo;, чтобы вы тестировали новый код модуля, созданный с помощью команды make. Третья дополнительная инструкция устанавливает двоичный файл perl из каталога вашего модуля в стандартный двоичный каталог DJGPP &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , заменяя предыдущий двоичный файл perl.</target>
        </trans-unit>
        <trans-unit id="238d815e97aa4aefd914191a6984e7eea1bebbe7" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt;, replacing your previous perl binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae143bbfd14644c2528b32b8737fee2a5bff385" translate="yes" xml:space="preserve">
          <source>The first few lines tell you the modules that Net::FTP uses and their versions, this is useful data to me when a user reports a bug. The last seven lines show the communication with the server. Each line has three parts. The first part is the object itself, this is useful for separating the output if you are using multiple objects. The second part is either &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; to show data coming from the server or &lt;code&gt;&amp;amp;gt&amp;amp;gt&amp;amp;gt&amp;amp;gt&lt;/code&gt; to show data going to the server. The remainder of the line is the command being sent or response being received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b17d18688be07602898309d70943af3ccee567" translate="yes" xml:space="preserve">
          <source>The first few members of the struct give a function table size for compatibility check &quot;name&quot; for the layer, the size to &lt;code&gt;malloc&lt;/code&gt; for the per-instance data, and some flags which are attributes of the class as whole (such as whether it is a buffering layer), then follow the functions which fall into four basic groups:</source>
          <target state="translated">Первые несколько членов структуры задают размер таблицы функций для &quot;имени&quot; проверки совместимости для уровня, размер для &lt;code&gt;malloc&lt;/code&gt; для данных для каждого экземпляра и некоторые флаги, которые являются атрибутами класса в целом (например, является ли он слой буферизации), затем следуйте функциям, которые делятся на четыре основные группы:</target>
        </trans-unit>
        <trans-unit id="5570358324850dc9a5c098d989e656b82d59427c" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\F&lt;/code&gt; . For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;.</source>
          <target state="translated">Первые пять из них , как управляющие последовательности &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , и &lt;code&gt;\F&lt;/code&gt; . Для Titlecase см. &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt; ; Для Foldcase см. &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="679923e26685f0bf8bfaf94ea7988b4c7276fdb8" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\F&lt;/code&gt;. For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;&quot;Titlecase&quot;&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;&quot;Foldcase&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056eb59b4cd627258e760e1417c53352badda0af" translate="yes" xml:space="preserve">
          <source>The first form causes the most-significant</source>
          <target state="translated">Первая форма приводит к тому,что наиболее значимая</target>
        </trans-unit>
        <trans-unit id="655fd20aca46eac1f13d92b5af802dc31b11d56c" translate="yes" xml:space="preserve">
          <source>The first form is used to request a</source>
          <target state="translated">Первая форма используется для запроса</target>
        </trans-unit>
        <trans-unit id="37eddcbe0416a7dc5593d702e9505efc3b548dce" translate="yes" xml:space="preserve">
          <source>The first form lists all distribution files in and below an author's CPAN directory as stored in the CHECKSUMS files distributed on CPAN. The listing recurses into subdirectories.</source>
          <target state="translated">В первой форме перечислены все файлы распределения в и под авторским каталогом CPAN,хранящимся в файлах CHECKSUMS,распространяемых на CPAN.Список возвращается в подкаталоги.</target>
        </trans-unit>
        <trans-unit id="46eae92ecd4f74796835635e06aeea1b041739b2" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt; . In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt; . You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="translated">Первая функция вычисляет длину добавляемой строки с помощью &lt;code&gt;strlen&lt;/code&gt; . Во втором вы сами указываете длину строки. Третья функция обрабатывает свои аргументы, как &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , и добавляет форматированный вывод. Четвертая функция работает как &lt;code&gt;vsprintf&lt;/code&gt; . Вы можете указать адрес и длину массива SV вместо аргумента va_list. Пятая функция расширяет строку, хранящуюся в первом SV, строкой, хранящейся во втором SV. Это также заставляет интерпретировать второй SV как строку.</target>
        </trans-unit>
        <trans-unit id="090b5d34cd572296fdf844e61d55479b085e6558" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt;. In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;sprintf&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt;. You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f464748e3494ffffc2bddda9e0371a39740923" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt; . The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="translated">Первая функция принимает буквальную строку, вторая использует строку, хранящуюся в SV. Помните, что тайник - это просто хеш-таблица, поэтому вы получите &lt;code&gt;HV*&lt;/code&gt; . &lt;code&gt;flags&lt;/code&gt; флаг будет создан новый пакет , если он установлен в GV_ADD.</target>
        </trans-unit>
        <trans-unit id="753de98607835382ac405aaaec94b8f9df443117" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt;. The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835ff098919bab433ee120cffa3fe9f71b92c1c9" translate="yes" xml:space="preserve">
          <source>The first gives data on bucket chain lengths and provides insight on how much work a fetch *miss* will take. In this case we have to inspect every item in a bucket before we can be sure the item is not in the list. The performance for an insert is equivalent to this case, as is a delete where the item is not in the hash.</source>
          <target state="translated">Первый дает данные о длине ковшовой цепи и дает представление о том,сколько работы понадобится для получения *мисс*.В этом случае мы должны осмотреть каждый предмет в ведре,прежде чем будем уверены,что его нет в списке.Производительность для вставки эквивалентна этому случаю,как и удаление,когда элемент не находится в хэше.</target>
        </trans-unit>
        <trans-unit id="44b1707c0aa3d824f6a27ecfef8a4304420287cd" translate="yes" xml:space="preserve">
          <source>The first interface is an object approach. &lt;code&gt;IO::Dir&lt;/code&gt; provides an object constructor and methods, which are just wrappers around perl's built in directory reading routines.</source>
          <target state="translated">Первый интерфейс - это объектный подход. &lt;code&gt;IO::Dir&lt;/code&gt; предоставляет конструктор объекта и методы, которые являются просто оболочкой для встроенных в perl подпрограмм чтения каталогов.</target>
        </trans-unit>
        <trans-unit id="f4941dd26bc8de71bda8bbde95f00b715fc9713b" translate="yes" xml:space="preserve">
          <source>The first is an asterisk &lt;code&gt;*&lt;/code&gt; to match any sequence of zero or more characters.</source>
          <target state="translated">Первый - это звездочка &lt;code&gt;*&lt;/code&gt; , обозначающая любую последовательность из нуля или более символов.</target>
        </trans-unit>
        <trans-unit id="e06aed8ca3d744d52c854ac09d0dcc88676f13d3" translate="yes" xml:space="preserve">
          <source>The first is the '*' metacharacter. This will be replaced by the complete filename matched by the input file glob. So</source>
          <target state="translated">Первый-&quot;*&quot; метахарактер.Он будет заменен полным именем файла,совпадающим с глобусом входного файла.Итак,</target>
        </trans-unit>
        <trans-unit id="53f5cd295a83b9a3745b8897953b75db40666387" translate="yes" xml:space="preserve">
          <source>The first is the 'default' format, which is used in both basic and exec modes to print all opcodes. The 2nd, goto-format, is used in exec mode when branches are encountered. They're not real opcodes, and are inserted to look like a closing curly brace. The tree-format is tree specific.</source>
          <target state="translated">Первый-это формат 'по умолчанию',который используется как в базовом режиме,так и в режиме исполнения для печати всех опкодов.Второй,goto-формат,используется в режиме exec,когда встречаются ветки.Они не являются настоящими опкодами и вставляются,чтобы выглядеть как закрывающаяся фигурная скобка.Древовидный формат является древовидным.</target>
        </trans-unit>
        <trans-unit id="32f6bb26a2f4ae1e809986ad78dbd60042fd1a3c" translate="yes" xml:space="preserve">
          <source>The first item is not fixable (except by upgrading to a later Visual Studio release), but it would be possible to work around the latter two items by using the Windows API functions &lt;code&gt;GetNumberFormat&lt;/code&gt; and &lt;code&gt;GetCurrencyFormat&lt;/code&gt;; patches welcome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34237558f2321ff711f52a04588fb6ee8079ad92" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fe0d63874f53e08f9d51c255d101fe5f08a938" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">Первая строка (с индексом [0]) означает, что значение для кодовой точки 0 - &amp;laquo;Базовая латынь&amp;raquo;. Запись &amp;laquo;0x0080&amp;raquo; в столбце @blocks_ranges во второй строке означает, что значение из первой строки, &amp;laquo;Basic Latin&amp;raquo;, распространяется на все кодовые точки в диапазоне от 0 до 0x0080, но не включая 0x0080, то есть до 127. Другими словами, все кодовые точки от 0 до 127 находятся в блоке &amp;laquo;Basic Latin&amp;raquo;. Точно так же все кодовые точки в диапазоне от 0x0080 до (но не включая) 0x0100 находятся в блоке с именем &amp;laquo;Latin-1 Supplement&amp;raquo; и т. Д. (Обратите внимание, что возвращаются имена блоков в старом стиле; см. Сравнение &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;старого стиля с новые имена блоков&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0686c2b572c16f799b84765daa2d3e48250c69f7" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in scalar context, an explicit &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; keyword is required.</source>
          <target state="translated">Первая строка выше определяет &lt;code&gt;TIMESTAMP&lt;/code&gt; как список из 9 элементов, возвращаемый &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; в контексте списка. Чтобы установить его в строку, возвращаемую &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; в скалярном контексте, требуется явное ключевое слово &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69decd40a9a2c32528b6b5800434c2cba08678b1" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;localtime()&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;localtime()&lt;/code&gt; in scalar context, an explicit &lt;code&gt;scalar&lt;/code&gt; keyword is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d82ab0cc733d5c69ba599aa083f54d41b0cd704" translate="yes" xml:space="preserve">
          <source>The first line ensures that the errors in your argument specification are found early. When you ship your application you should comment out the first line, since it makes the second one useless.</source>
          <target state="translated">Первая строка гарантирует,что ошибки в спецификации аргументов будут найдены раньше.При отправке приложения вы должны прокомментировать первую строку,так как это делает вторую бесполезной.</target>
        </trans-unit>
        <trans-unit id="1d816990178774f44d4b8769d3c845c853e30a87" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="translated">Первая строка здесь указывает, что таблица смещения / длины содержит 45 записей. Каждая запись представляет собой пару целых чисел, обозначаемых &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Записи нумеруются, начиная с 1, поэтому запись №1 здесь &lt;code&gt;1[4]&lt;/code&gt; а запись №12 - &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; указывает, что узел с меткой &lt;code&gt;1:&lt;/code&gt; ( &lt;code&gt;1: ANYOF[bc]&lt;/code&gt; ) начинается с позиции символа 1 в предварительно скомпилированной форме регулярного выражения и имеет длину 4 символа. &lt;code&gt;5[1]&lt;/code&gt; в позиции 12 указывает, что узел с меткой &lt;code&gt;12:&lt;/code&gt; ( &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt; ) начинается с позиции символа 5 в предварительно скомпилированной форме регулярного выражения и имеет длину 1 символ. &lt;code&gt;12[1]&lt;/code&gt; в позиции 14 указывает, что узел с меткой &lt;code&gt;14:&lt;/code&gt; ( &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt; ) начинается с позиции символа 12 в предварительно скомпилированной форме регулярного выражения и имеет длину 1 символ. --- то есть соответствует символу &lt;code&gt;+&lt;/code&gt; в предварительно скомпилированном регулярном выражении.</target>
        </trans-unit>
        <trans-unit id="e2bf1de2c16e8c0adbab29364ba1219b9e1777c7" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[length]&lt;/code&gt;. Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt;. &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3daa98ec524432df6c19e25f5089a0ae5fbe0898" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">Первая строка - это сокращение для следующих двух строк, за исключением того, что она не создает лишнюю переменную массива &lt;code&gt;@array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7be109e4ec8d67123623c616eb3634806eefdaf2" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c7b267b0324e3ee08f49728c4657a96f3be74f" translate="yes" xml:space="preserve">
          <source>The first line is the plan - it specifies the number of tests I'm going to run so that it's easy to check that the test script didn't exit before running all the expected tests. The following lines are the test results - 'ok' for pass, 'not ok' for fail. Each test has a number and, optionally, a description. And that's it. Any language that can produce output like that on STDOUT can be used to write tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cea67f4153eeb52ccd2e3da747660523e22317" translate="yes" xml:space="preserve">
          <source>The first line of a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07b113f7912ed4a47b2646ff4b1fee0ebfd1d07" translate="yes" xml:space="preserve">
          <source>The first line of the commit message should be a short description without a period. It should be no longer than the subject line of an email, 50 characters being a good rule of thumb.</source>
          <target state="translated">Первая строка сообщения о фиксации должна быть кратким описанием без периода.Она не должна быть больше,чем строка темы письма,50 символов-хорошее эмпирическое правило.</target>
        </trans-unit>
        <trans-unit id="ae7ce29a18436b04a3b95f17b59a8ba620a5dab2" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt; *8. The next line shows the label</source>
          <target state="translated">Первая строка показывает предварительно скомпилированную форму регулярного выражения. Второй показывает размер скомпилированной формы (в произвольных единицах, обычно 4-байтовых словах) и общее количество байтов, выделенных для таблицы смещения / длины, обычно 4+ &lt;code&gt;size&lt;/code&gt; * 8. В следующей строке отображается метка</target>
        </trans-unit>
        <trans-unit id="a20c750a487464791d892a303a995f218caaa79f" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt;*8. The next line shows the label</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7723c265ae779d21866a1c9e48b6be3d9e2e441" translate="yes" xml:space="preserve">
          <source>The first method takes periodically samples of the CPU program counter, and since the program counter can be correlated with the code generated for functions, we get a statistical view of in which functions the program is spending its time. The caveats are that very small/fast functions have lower probability of showing up in the profile, and that periodically interrupting the program (this is usually done rather frequently, in the scale of milliseconds) imposes an additional overhead that may skew the results. The first problem can be alleviated by running the code for longer (in general this is a good idea for profiling), the second problem is usually kept in guard by the profiling tools themselves.</source>
          <target state="translated">В первом методе периодически выполняется выборка счетчика процессорной программы,а так как программный счетчик можно соотнести с кодом,генерируемым для функций,то мы получаем статистическое представление о том,в каких функциях программа проводит свое время.Оговорка заключается в том,что очень маленькие/быстрые функции имеют меньшую вероятность появления в профиле,а периодическое прерывание программы (обычно это делается довольно часто,в масштабе миллисекунд)накладывает дополнительные накладные расходы,которые могут исказить результаты.Первую проблему можно решить,запустив код подольше (в целом это хорошая идея для профилирования),вторую проблему обычно защищают сами инструменты профилирования.</target>
        </trans-unit>
        <trans-unit id="108fd116edbd3a8efddc6a912d5c851d634fe27e" translate="yes" xml:space="preserve">
          <source>The first name is called the</source>
          <target state="translated">Первое имя называется</target>
        </trans-unit>
        <trans-unit id="0263570650724ebe71f62b454fad700a5d663c69" translate="yes" xml:space="preserve">
          <source>The first number doesn't really mean anything, but it has to be 1. It's the second number that's important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c95867addff6e3f2248f91516c23a2994856b3e" translate="yes" xml:space="preserve">
          <source>The first of the three available techniques is to write the filter completely in C. The external module you create interfaces directly with the source filter hooks provided by Perl.</source>
          <target state="translated">Первая из трех доступных методик заключается в том,чтобы полностью записать фильтр на C.Внешний модуль,который вы создаете,взаимодействует непосредственно с исходными фильтрующими крючками,предоставляемыми Perl.</target>
        </trans-unit>
        <trans-unit id="2cf31ee7914fd21827d64f65da992c78e2dd2481" translate="yes" xml:space="preserve">
          <source>The first of these is the operand providing the overloaded operator implementation - in this case, the object whose &lt;code&gt;minus()&lt;/code&gt; method is being called.</source>
          <target state="translated">Первый из них - это операнд, обеспечивающий реализацию перегруженного оператора - в данном случае объект, чей метод &lt;code&gt;minus()&lt;/code&gt; вызывается.</target>
        </trans-unit>
        <trans-unit id="32df19252ad74319d4ce1046b1c9ffb0a16536ba" translate="yes" xml:space="preserve">
          <source>The first of these two functions checks if a hash table entry exists, and the second deletes it.</source>
          <target state="translated">Первая из этих двух функций проверяет,существует ли запись в хэш-таблице,а вторая ее удаляет.</target>
        </trans-unit>
        <trans-unit id="2baee74dbd5d9705ba409f49c41818c111db8f9c" translate="yes" xml:space="preserve">
          <source>The first one explicitly passes in the context, which is needed for e.g. threaded builds. The second one does that implicitly; do not get them mixed. If you are not passing in a aTHX_, you will need to do a dTHX (or a dVAR) as the first thing in the function.</source>
          <target state="translated">Первый явно передается в контексте,который необходим,например,для поточных сборок.Второй делает это неявно;не смешивайте их.Если вы не передаете в aTHX_,то в качестве первой вещи в функции нужно сделать dTHX (или dVAR).</target>
        </trans-unit>
        <trans-unit id="b5d9b746eaf9594387396efaab0691495a0a8b7a" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt; , which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . You can revert to the default by setting the &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Первый - &lt;code&gt;&quot;format&quot;&lt;/code&gt; , который представляет собой строку формата в стиле sprintf (), которая используется для обеих числовых частей комплексного числа (ов). В некоторой степени зависит от системы, но чаще всего соответствует &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . Вы можете вернуться к значению по умолчанию, установив &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51d3fa9f9095d6ba6fd87e541115beff9437b3d9" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt;, which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt;. You can revert to the default by setting the &lt;code&gt;format&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64110520d33c3683502b6895ec7f686e2b691a83" translate="yes" xml:space="preserve">
          <source>The first one is a B::PADNAMELIST under Perl 5.22, and a B::AV under earlier versions. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="translated">Первый-B::PADNAMELIST на Perl 5.22 и B::AV на более ранних версиях.Остальные в настоящее время являются объектами B::AV,но это может измениться в будущих версиях.</target>
        </trans-unit>
        <trans-unit id="094fe85cd4712afd8983c54311ea1fc6e32b5e2d" translate="yes" xml:space="preserve">
          <source>The first parameter is a scalar into which, upon success, the wide character represented by the multi-byte string contained in the second parameter is stored. The optional third parameter is ignored if it is larger than the actual length of the second parameter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b59fd7f35cf6d9692928110737a220c45e66d67" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;UTF8fARG&lt;/code&gt; is a boolean: 1 if the string is in UTF-8; 0 if string is in native byte encoding (Latin1). The second parameter is the number of bytes in the string to print. And the third and final parameter is a pointer to the first byte in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ea0aa1b4ed42878caaa6bf56a3d5e35dfb1b12" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="translated">Первый параметр &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt; , - это</target>
        </trans-unit>
        <trans-unit id="bbc40cbdc77266be7323541d7a55e0277f7ff986" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7f0d7f3250dff196379a82ef1042cf92584eab" translate="yes" xml:space="preserve">
          <source>The first part of each item is the language tag, between {...}. It is followed by an English name for the language or language-group. Language tags that I judge to be not for general use, are bracketed.</source>
          <target state="translated">Первая часть каждого элемента-это языковой тег,между {...}.За ней следует английское название языка или языковой группы.Языковые метки,которые,по моему мнению,не предназначены для общего использования,заключены в скобки.</target>
        </trans-unit>
        <trans-unit id="2850ab20f1390861bb35445270293546335b53f4" translate="yes" xml:space="preserve">
          <source>The first part of the report already shows the critical information regarding which subroutines are using the most time. The next gives some statistics about the source files profiled.</source>
          <target state="translated">В первой части отчета уже показана критическая информация о том,какие подпрограммы используют больше всего времени.В следующей приведены некоторые статистические данные о профилированных исходных файлах.</target>
        </trans-unit>
        <trans-unit id="397f188600044026c7930c78c4ec45f2d657488a" translate="yes" xml:space="preserve">
          <source>The first pass is finding the end of the quoted construct. This results in saving to a safe location a copy of the text (between the starting and ending delimiters), normalized as necessary to avoid needing to know what the original delimiters were.</source>
          <target state="translated">Первый проход-нахождение конца цитируемой конструкции.В результате в безопасное место сохраняется копия текста (между начальным и конечным разделителями),нормализованная по мере необходимости,чтобы избежать необходимости знать,что такое оригинальные разделители.</target>
        </trans-unit>
        <trans-unit id="52dc28c1ba280be3247117e934caac44df1ea80f" translate="yes" xml:space="preserve">
          <source>The first portions of this document contains instructions to cross-compile Perl for Android 2.0 and later, using the binaries provided by Google. The latter portions describe how to build perl native using one of the toolchains available on the Play Store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fe7088bb4f27d081fbb7bc1dcf8f8999b582b8" translate="yes" xml:space="preserve">
          <source>The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.</source>
          <target state="translated">Первый квантификатор &quot;.*&quot; начинается с совпадения всей строки &quot;кот в шляпе&quot;.</target>
        </trans-unit>
        <trans-unit id="9c1c8c14ec1e3a07903d82f126aec6635328f772" translate="yes" xml:space="preserve">
          <source>The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regex match. The second quantifier &lt;code&gt;.*&lt;/code&gt; has no string left to it, so it matches 0 times.</source>
          <target state="translated">Первый квантификатор &lt;code&gt;.*&lt;/code&gt; Захватывает как можно большую часть строки, сохраняя соответствие регулярному выражению. Для второго квантификатора &lt;code&gt;.*&lt;/code&gt; Не осталось строки, поэтому он соответствует 0 раз.</target>
        </trans-unit>
        <trans-unit id="6e528105bd9590f0533aed7b713042470a33b8f6" translate="yes" xml:space="preserve">
          <source>The first reason is that this technique</source>
          <target state="translated">Первая причина в том,что эта техника</target>
        </trans-unit>
        <trans-unit id="b01253c2ebd001b8b295bfdd61014e6f7807bcd2" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . The space character ' ' is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &lt;code&gt;'World '&lt;/code&gt; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="translated">Первый &lt;code&gt;world&lt;/code&gt; регулярных выражений не соответствует, потому что регулярные выражения чувствительны к регистру. Второе регулярное выражение соответствует, потому что подстрока &lt;code&gt;'o W'&lt;/code&gt; встречается в строке &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . Пробел '' обрабатывается как любой другой символ в регулярном выражении и необходим для сопоставления в этом случае. Отсутствие пробела - причина того, что третье регулярное выражение &lt;code&gt;'oW'&lt;/code&gt; не совпадает. Четвертое регулярное выражение &lt;code&gt;'World '&lt;/code&gt; не совпадает, потому что в конце регулярного выражения есть пробел, но нет в конце строки. Урок здесь в том, что регулярные выражения должны соответствовать части строки.</target>
        </trans-unit>
        <trans-unit id="d791e1a0374a959ba40ed9f40fd370a5d5a456cb" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;. The space character &lt;code&gt;' '&lt;/code&gt; is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &quot;&lt;code&gt;World &lt;/code&gt;&quot; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddca4d833894463530776d04e09076c4eab205cd" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt; . Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="translated">Первое регулярное выражение не соответствует, потому что строка содержит больше, чем &lt;code&gt;keep&lt;/code&gt; . Поскольку второе регулярное выражение - это именно строка, она совпадает. Использование в регулярном выражении как &lt;code&gt;^&lt;/code&gt; ,так и &lt;code&gt;$&lt;/code&gt; заставляет всю строку соответствовать, поэтому это дает вам полный контроль над тем, какие строки соответствуют, а какие нет. Предположим, вы ищете одного парня по имени Берт:</target>
        </trans-unit>
        <trans-unit id="467dd0993aab8207646a6fe07d7110c16e4ae880" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt;. Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187948592e3895c96d921caa597048a315b504cd" translate="yes" xml:space="preserve">
          <source>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</source>
          <target state="translated">Первые сообщают,что оба этих хэша содержат одни и те же данные,в то время как вторые сообщают,что их нет.Который вы предпочитаете оставить как упражнение для читателя.</target>
        </trans-unit>
        <trans-unit id="8860a773058066d93bd3eee9e9232f1b245f86d6" translate="yes" xml:space="preserve">
          <source>The first section describes POSIX functions from the 1003.1 specification. The second section describes some classes for signal objects, TTY objects, and other miscellaneous objects. The remaining sections list various constants and macros in an organization which roughly follows IEEE Std 1003.1b-1993.</source>
          <target state="translated">В первом разделе описаны функции POSIX из спецификации 1003.1.Во втором разделе описаны некоторые классы для сигнальных объектов,объектов TTY и других различных объектов.В остальных разделах перечислены различные константы и макросы в организации,которая примерно следует стандарту IEEE 1003.1b-1993.</target>
        </trans-unit>
        <trans-unit id="9a3305f1afd295681118d876dec01ed7a5b8a456" translate="yes" xml:space="preserve">
          <source>The first section maps various C data types to a name, which corresponds somewhat with the various Perl types. The second section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle input parameters. The third section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle output parameters.</source>
          <target state="translated">В первом разделе различные типы данных C сопоставляются с именами, которые отчасти соответствуют различным типам Perl. Второй раздел содержит код C, который &lt;b&gt;xsubpp&lt;/b&gt; использует для обработки входных параметров. Третий раздел содержит код C, который &lt;b&gt;xsubpp&lt;/b&gt; использует для обработки выходных параметров.</target>
        </trans-unit>
        <trans-unit id="5dec21809b3e94bb56bbf06b1ab08c273929b8df" translate="yes" xml:space="preserve">
          <source>The first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, &quot;Common Pitfalls&quot;, describes some of the most popular mistakes made by CPAN authors.</source>
          <target state="translated">В первом разделе этого документа приводится постатейный контрольный перечень;в последующих разделах более подробно рассматриваются вопросы,включенные в перечень.Заключительный раздел,&quot;Общие ловушки&quot;,описывает некоторые из наиболее популярных ошибок,допущенных авторами CPAN.</target>
        </trans-unit>
        <trans-unit id="873fa0119aa76096529ccc05f5ae97f00f810fd3" translate="yes" xml:space="preserve">
          <source>The first set of stats gives some summary statistical information, including the quality score translated into &quot;Good&quot;, &quot;Poor&quot; and &quot;Bad&quot;, (score&amp;lt;=1.05, score&amp;lt;=1.2, score&amp;gt;1.2). See the documentation in bucket_stats() for more details.</source>
          <target state="translated">Первый набор статистики дает некоторую сводную статистическую информацию, включая оценку качества, переведенную в &amp;laquo;Хорошо&amp;raquo;, &amp;laquo;Плохо&amp;raquo; и &amp;laquo;Плохо&amp;raquo; (оценка &amp;lt;= 1,05, оценка &amp;lt;= 1,2, оценка&amp;gt; 1,2). См. Документацию в bucket_stats () для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="da5f31247c2eb407c67afefcfd779d23549ec3df" translate="yes" xml:space="preserve">
          <source>The first situation being much more frequent, it makes sense to rewrite the boilerplate as</source>
          <target state="translated">В первой ситуации,которая встречается гораздо чаще,имеет смысл переписать шаблон как</target>
        </trans-unit>
        <trans-unit id="ad55dcbd2815a02cf9af8564c1fdb6a55d76bf9e" translate="yes" xml:space="preserve">
          <source>The first state may happen in &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; and &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handlers.</source>
          <target state="translated">Первое состояние может произойти в обработчиках &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; и &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="470d1d04836c0a5dd42cc354e122ff4ddc8f36a3" translate="yes" xml:space="preserve">
          <source>The first step is to add this line:</source>
          <target state="translated">Первый шаг-добавить эту строку:</target>
        </trans-unit>
        <trans-unit id="1d92a911344060c6031358fbe99f5d7b26fb10e8" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; call to convert everything to binary:</source>
          <target state="translated">Первым шагом обработки такой строки является преобразование шестнадцатеричных данных в двоичные для получения четырех полей при проверке контрольной суммы. Здесь нет ничего удивительного: мы начнем с простого вызова &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; чтобы преобразовать все в двоичный код:</target>
        </trans-unit>
        <trans-unit id="3d051bbcc0b2bf5e763df328cc13763c82b21bfe" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;pack&lt;/code&gt; call to convert everything to binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2237935485a4e0e57cc8ab0badea71ce05f470d" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . At this position, the minimal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt; . Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;$&lt;/code&gt; to match the rest of the string.</source>
          <target state="translated">Первая строковая позиция, которой может соответствовать это регулярное выражение, - это первая &lt;code&gt;'m'&lt;/code&gt; в &lt;code&gt;programming&lt;/code&gt; . В этой позиции минимальное значение &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; соответствует только одному &lt;code&gt;'m'&lt;/code&gt; . Хотя второй квантификатор &lt;code&gt;.*?&lt;/code&gt; предпочел бы не соответствовать никаким символам, он ограничен привязкой конца строки &lt;code&gt;$&lt;/code&gt; , чтобы соответствовать остальной части строки.</target>
        </trans-unit>
        <trans-unit id="5f895607d70ebcfe9c61321d68de376e6e1b258c" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt;. At this position, the minimal &lt;code&gt;m{1,2}?&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt;. Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;'$'&lt;/code&gt; to match the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea599d468c324040fff443da5016a605f7268fd" translate="yes" xml:space="preserve">
          <source>The first task in building a regexp is to decide what we want to match and what we want to exclude. In our case, we want to match both integers and floating point numbers and we want to reject any string that isn't a number.</source>
          <target state="translated">Первая задача при построении регеxp-решить,что мы хотим сопоставить,а что исключить.В нашем случае мы хотим сопоставить и целые числа,и числа с плавающей точкой,и мы хотим отвергнуть любую строку,которая не является числом.</target>
        </trans-unit>
        <trans-unit id="a253a2302f0dd4214c0fa19a3c7600e1aeb7c19f" translate="yes" xml:space="preserve">
          <source>The first thing after the &quot;=over&quot; command should be an &quot;=item&quot;, unless there aren't going to be any items at all in this &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">Первое,что после команды &quot;=over&quot; должно быть &quot;=item&quot;,если только в этом &quot;=over&quot; вообще не будет элементов ...&quot;=назад&quot;.</target>
        </trans-unit>
        <trans-unit id="b4182d2194d7b0a192c4908dabaf70426956c4b1" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt; , then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt; . Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt; , then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt; . The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="translated">Первый поток захватит блокировку &lt;code&gt;$x&lt;/code&gt; , а затем, после паузы, во время которой второй поток, вероятно, успел выполнить некоторую работу, попытается захватить блокировку &lt;code&gt;$y&lt;/code&gt; . Между тем, второй поток захватывает блокировку &lt;code&gt;$y&lt;/code&gt; , а затем пытается захватить блокировку &lt;code&gt;$x&lt;/code&gt; . Вторая попытка блокировки для обоих потоков будет заблокирована, каждый будет ждать, пока другой освободит свою блокировку.</target>
        </trans-unit>
        <trans-unit id="1b0e5abdf339f37172dcc121e02e6f88bb538337" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt;, then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt;. Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt;, then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt;. The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97805142bc0d01ba991305a8f5bc28f8f3fcba12" translate="yes" xml:space="preserve">
          <source>The first time through the loop, you will rewrite the entire file, from line 0 through the end. The second time through the loop, you will rewrite the entire file from line 1 through the end. The third time through the loop, you will rewrite the entire file from line 2 to the end. And so on.</source>
          <target state="translated">В первый раз в цикле вы перезапишите весь файл,начиная со строки 0 и заканчивая концом.Во второй раз в цикле перезаписывается весь файл со строки 1 до конца.В третий раз по циклу перезаписываем весь файл со второй строки на конец.И так далее.</target>
        </trans-unit>
        <trans-unit id="0d6a59a26170358aef33f4d3978afce2e252997e" translate="yes" xml:space="preserve">
          <source>The first two arguments taken by this method are the name of the symbol and the value which should be assigned to it. The optional third argument is a string specifying the symbol table to be used; 'GLOBAL' specifies the global symbol table, and any other string specifies the local symbol table. If this argument is omitted, the default symbol table for the object is used. &lt;code&gt;setsym&lt;/code&gt; returns TRUE if successful, and FALSE otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579873cee61866ba7eb29c6c1922769d306aac89" translate="yes" xml:space="preserve">
          <source>The first two fields give the total amount of memory perl sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The third number is what perl thinks about continuity of returned chunks. So long as this number is positive, malloc() will assume that it is probable that sbrk(2) will provide continuous memory.</source>
          <target state="translated">Первые два поля дают общий объем памяти на perl sbrk(2)ed (ess-broken? :-)и количество используемых sbrk(2).Третье число-это то,что perl думает о непрерывности возвращаемых кусков.Пока это число положительное,malloc()будет считать,что sbrk(2),скорее всего,будет обеспечивать непрерывную память.</target>
        </trans-unit>
        <trans-unit id="0819c6d2283041c7cfda116e5fb9ae13c3a8c8e6" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4becb05f0bd7170201aca65de03c239266000dbc" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="translated">Первые две формы возвращают &lt;b&gt;истину,&lt;/b&gt; если &lt;a href=&quot;#code-point-argument&quot;&gt;аргумент кодовой точки&lt;/a&gt; не должен создаваться нормализацией композиции. Чтобы последние две формы вернули &lt;b&gt;истину&lt;/b&gt; , дополнительно требуется, чтобы этот факт нельзя было определить иным образом из базы данных Unicode.</target>
        </trans-unit>
        <trans-unit id="7edeb46a7cf77b29322b042169fd6545cca7858e" translate="yes" xml:space="preserve">
          <source>The first value to be substituted in the output string ( usually the column in a cursor addressing capability )</source>
          <target state="translated">Первое значение,подставляемое в выходную строку (обычно столбец в возможности адресации курсора).</target>
        </trans-unit>
        <trans-unit id="6c0a32c5664fb58c1965f29a470eb892918927d8" translate="yes" xml:space="preserve">
          <source>The first version of TAP to include an explicit version number is 13.</source>
          <target state="translated">Первая версия TAP с явным номером версии-13.</target>
        </trans-unit>
        <trans-unit id="23a0afbda307c4ae7b5c2196fca71616dba92438" translate="yes" xml:space="preserve">
          <source>The first version of this article originally appeared in The Perl Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba908120df7bb5731ed530b89b4f89b55fe9cb39" translate="yes" xml:space="preserve">
          <source>The first version of this document appeared on Perl Monks, where several people had useful suggestions. Thank you, Perl Monks.</source>
          <target state="translated">Первая версия этого документа появилась на Perl Monks,где несколько человек имели полезные предложения.Спасибо,Перл Монакс.</target>
        </trans-unit>
        <trans-unit id="af8e62f88abda0ab386f2cc101dff094b50fe117" translate="yes" xml:space="preserve">
          <source>The first version, the one without the indirect object, ran the</source>
          <target state="translated">Первая версия,без косвенного объекта,запустила</target>
        </trans-unit>
        <trans-unit id="6781fdff7b279779b03d140931fe35f9d498c177" translate="yes" xml:space="preserve">
          <source>The first will run all test files in all first-level subdirectories and all subdirectories they contain. The second will run tests in only the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf53ff13525a226bb832b26adcd06a8433dba05" translate="yes" xml:space="preserve">
          <source>The fix is to remove all Test::Builder1.5/2 related code. Either use the legacy Test::Builder API, or use Test2 directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b513d7712476adb9fe5c913d728ae8bf500df8" translate="yes" xml:space="preserve">
          <source>The fix is to use the API specified in &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; to look at or modify state as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5db8a38d2c3f00c90a5e9484dd046d60b873cc" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Шрифт фиксированной ширины для дословного текста и кода. По умолчанию &lt;code&gt;CW&lt;/code&gt; . Некоторым системам вместо этого может потребоваться &lt;code&gt;CR&lt;/code&gt; . Имеет значение только для вывода &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="4411138b75b6f4d0eb399c58a09f8dac2bce859c" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="translated">Шрифт фиксированной ширины для дословного текста и кода. По умолчанию &lt;code&gt;CW&lt;/code&gt; . Некоторым системам вместо этого может потребоваться &lt;code&gt;CR&lt;/code&gt; . Имеет значение только для вывода troff (1).</target>
        </trans-unit>
        <trans-unit id="e30f3c3943bfb47da6b22d33c6d6f3755c5c4c90" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt;. Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f14452e50daa176a2948e6c80e179269ad7ea89" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt;. Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ad2fb87b3a3c9138524933b76f13bbb404b147" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;SVs_PADSTALE&lt;/code&gt; is cleared on lexicals each time the &lt;code&gt;my()&lt;/code&gt; is executed, and set on scope exit. This allows the &lt;code&gt;&quot;Variable $x is not available&quot;&lt;/code&gt; warning to be generated in evals, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239752a03e595c22089872230ac5d8660b72070d" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;UNICODE_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt; selects all three of the above WARN flags; and &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; selects all three DISALLOW flags. &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; restricts the allowed inputs to the strict UTF-8 traditionally defined by Unicode. Similarly, &lt;code&gt;UNICODE_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; are shortcuts to select the above-Unicode and surrogate flags, but not the non-character ones, as defined in &lt;a href=&quot;https://www.unicode.org/versions/corrigendum9.html&quot;&gt;Unicode Corrigendum #9&lt;/a&gt;. See &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;&quot;Noncharacter code points&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f7fca8c3cfcccf779409e2e759e639d09b18b3" translate="yes" xml:space="preserve">
          <source>The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed, and set on scope exit. This allows the 'Variable $x is not available' warning to be generated in evals, such as</source>
          <target state="translated">Флаг SVs_PADSTALE сбрасывается на лексике каждый раз,когда выполняется функция my(),и устанавливается при выходе из области видимости.Это позволяет генерировать предупреждение 'Переменная $x недоступна' в эквалах,таких как</target>
        </trans-unit>
        <trans-unit id="f2aaf40e59e4745cf25b943d852f6d075ba40074" translate="yes" xml:space="preserve">
          <source>The flags &lt;code&gt;UTF8_WARN_ILLEGAL_INTERCHANGE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_SURROGATE&lt;/code&gt;, &lt;code&gt;UTF8_WARN_NONCHAR&lt;/code&gt;, and &lt;code&gt;UTF8_WARN_SUPER&lt;/code&gt; will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; is also specified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78429f471bd064af1845edc82bca0aa6e6778ce" translate="yes" xml:space="preserve">
          <source>The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if UTF8_CHECK_ONLY is also specified.)</source>
          <target state="translated">Флаги UTF8_WARN_ILLEGAL_INTERCHANGE,UTF8_WARN_SURROGATE,UTF8_WARN_NONCHAR и UTF8_WARN_SUPER приведут к тому,что будут подняты предупреждающие сообщения для соответствующих категорий,но в противном случае кодовые пункты будут считаться действительными (не пороки).Для того,чтобы и та,и другая категория рассматривалась как деформация и вызывала предупреждение,укажите флаги WARN и DISALLOW.(Но обратите внимание,что предупреждения не поднимаются,если лексически отключены,а также если указан флаг UTF8_CHECK_ONLY).</target>
        </trans-unit>
        <trans-unit id="5e9a6e0acd0b69b277831006219122b07719e738" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</source>
          <target state="translated">Флаги по умолчанию равны нулю, если вам нужно что-то другое, вы можете либо использовать &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , либо вы можете унаследовать от POSIX :: SigRt и определить свой собственный &lt;code&gt;new()&lt;/code&gt; (метод связанного хэша STORE для &lt;code&gt;%SIGRT&lt;/code&gt; вызывает &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , где &lt;code&gt;$rtsig&lt;/code&gt; изменяется от нуля до &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="723ee765d373688ffd88695151d122551f3cfc41" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;local&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt;, or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt;, where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13aa1a177f443868b50bc938e7eaafe94399ebc" translate="yes" xml:space="preserve">
          <source>The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</source>
          <target state="translated">Параметр &quot;флаги&quot; является обязательным.Действительными значениями флагов являются R_CURSOR,R_FIRST,R_LAST,R_NEXT и R_PREV.</target>
        </trans-unit>
        <trans-unit id="3f1710e98626f16d762b28b22c17439d043e302f" translate="yes" xml:space="preserve">
          <source>The flags specify dictionary order and case folding:</source>
          <target state="translated">Флаги задают порядок следования словарей и складывания регистров:</target>
        </trans-unit>
        <trans-unit id="10543ef8424f431d7ff14981f10f88f0c585ac15" translate="yes" xml:space="preserve">
          <source>The flavor</source>
          <target state="translated">Вкус</target>
        </trans-unit>
        <trans-unit id="0aa322e2f3acfe06e30a26fc0d60aa65599ac7cd" translate="yes" xml:space="preserve">
          <source>The floating point infinity can be exported as a subroutine Inf():</source>
          <target state="translated">Бесконечность с плавающей точкой может быть экспортирована как подпрограмма Inf():</target>
        </trans-unit>
        <trans-unit id="b219578f1fed53f8498341e6252dcc91a786ab6d" translate="yes" xml:space="preserve">
          <source>The floating point number is taken and split first on the single decimal place, then each group of three digits to the right of the decimal makes up the next digit, and so on until the number of significant digits is exhausted, &lt;b&gt;plus&lt;/b&gt; enough trailing zeros to reach the next multiple of three.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5e2b0312afcc71cd5da99161e1d75eaff20f77" translate="yes" xml:space="preserve">
          <source>The focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.</source>
          <target state="translated">Основное внимание уделяется элементам стиля,которые видны пользователям модуля,а не тем частям,которые видны только разработчикам модуля.Тем не менее,многие из рекомендаций,представленных в этом документе,могут быть экстраполированы и успешно применены во внутреннем устройстве модуля.</target>
        </trans-unit>
        <trans-unit id="9981cb315250daca0797ec1ef39fd43f6c6f6a86" translate="yes" xml:space="preserve">
          <source>The following &quot;public&quot; global names can be read by clients of this API. Beware that these should be considered &quot;readonly&quot;.</source>
          <target state="translated">Следующие &quot;публичные&quot; глобальные имена могут быть прочитаны клиентами данного API.Остерегайтесь,что их следует рассматривать как &quot;только для чтения&quot;.</target>
        </trans-unit>
        <trans-unit id="20617679e0f828efd3412a47a9694c121128bc85" translate="yes" xml:space="preserve">
          <source>The following &quot;virtual&quot; methods can be defined by the client. They will be called by the API at appropriate points. Note that unless specified otherwise, the debug API only defines empty, non-functional default versions of these methods.</source>
          <target state="translated">Клиент может определить следующие &quot;виртуальные&quot; методы.Они будут вызываться API в соответствующих точках.Обратите внимание,что если не указано иначе,отладочный API определяет только пустые,нефункциональные версии этих методов по умолчанию.</target>
        </trans-unit>
        <trans-unit id="74f1711fbc30180876f2a4788abe7e66574474a6" translate="yes" xml:space="preserve">
          <source>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</source>
          <target state="translated">Далее (неэффективно)удаляются все значения %HASH и @ARRAY:</target>
        </trans-unit>
        <trans-unit id="d00c5dd059bf93f0972cfd4b44a56b57fd0caf81" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt; s). Where the above macros take &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, a similar function takes &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</source>
          <target state="translated">Следующий список API содержит функции, поэтому необходимо явно указать указатели на изменяемые данные (либо указатели C, либо Perlish &lt;code&gt;GV *&lt;/code&gt; s). Если указанные выше макросы принимают &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; , аналогичная функция принимает &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7722c25bc63a475d0687db360090ccce2f038b0" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt;s). Where the above macros take &lt;code&gt;int&lt;/code&gt;, a similar function takes &lt;code&gt;int *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1909e3498aef1b158b54d7174bc50b2ee9e5d97" translate="yes" xml:space="preserve">
          <source>The following API uses parts of Perl's internals in the current implementation. As such, they are efficient but may change in a future release.</source>
          <target state="translated">Следующий API использует части внутреннего интерфейса Perl в текущей реализации.Как таковые,они эффективны,но могут измениться в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="4a57e29ab087cd96e1aaf0f9eb948df8f4a4939a" translate="yes" xml:space="preserve">
          <source>The following CVE reports were previously filed against File-Path and are believed to have been addressed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cab3979d794d7afb5425a45a32e9d6f7ad6a57" translate="yes" xml:space="preserve">
          <source>The following NNTP command are unsupported by the package, and there are no plans to do so.</source>
          <target state="translated">Следующая команда NNTP не поддерживается пакетом и не планируется.</target>
        </trans-unit>
        <trans-unit id="2d9e72c95e25f90c1fd2f371c21c4c0499d49748" translate="yes" xml:space="preserve">
          <source>The following RFC959 commands have not been implemented:</source>
          <target state="translated">Следующие команды RFC959 не были реализованы:</target>
        </trans-unit>
        <trans-unit id="8ed1bcda5c1f977c3cd2bdcf823f30eee9e9931d" translate="yes" xml:space="preserve">
          <source>The following SDK and compiler configurations and Nokia phones were tested at some point in time (+ = compiled and PerlApp run, - = not), both for Perl 5.8.x and 5.9.x:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237479489ace35ae45dfd88db2279ca4abed31a5" translate="yes" xml:space="preserve">
          <source>The following VMS-specific information applies to the indicated &quot;special&quot; Perl variables, in addition to the general information in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. Where there is a conflict, this information takes precedence.</source>
          <target state="translated">Следующая информация, &lt;a href=&quot;perlvar&quot;&gt;относящаяся к&lt;/a&gt; VMS, применяется к указанным &amp;laquo;специальным&amp;raquo; переменным Perl в дополнение к общей информации в perlvar . В случае конфликта эта информация имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="a7dd0dcb80676e8669cc8ad178e5203d579a6cf3" translate="yes" xml:space="preserve">
          <source>The following Win32-Methods are built-in:</source>
          <target state="translated">Встроены следующие Win32-методы:</target>
        </trans-unit>
        <trans-unit id="1c76188e19e8645c61f6a21008485b728f914f68" translate="yes" xml:space="preserve">
          <source>The following XS code shows the getnetconfigent() function which is used with ONC+ TIRPC. The getnetconfigent() function will return a pointer to a C structure and has the C prototype shown below. The example will demonstrate how the C pointer will become a Perl reference. Perl will consider this reference to be a pointer to a blessed object and will attempt to call a destructor for the object. A destructor will be provided in the XS source to free the memory used by getnetconfigent(). Destructors in XS can be created by specifying an XSUB function whose name ends with the word &lt;b&gt;DESTROY&lt;/b&gt;. XS destructors can be used to free memory which may have been malloc'd by another XSUB.</source>
          <target state="translated">Следующий код XS показывает функцию getnetconfigent (), которая используется с ONC + TIRPC. Функция getnetconfigent () вернет указатель на структуру C и имеет прототип C, показанный ниже. В этом примере будет показано, как указатель C станет ссылкой на Perl. Perl будет считать эту ссылку указателем на благословенный объект и попытается вызвать деструктор для этого объекта. В исходном коде XS будет предоставлен деструктор для освобождения памяти, используемой getnetconfigent (). Деструкторы в XS можно создать, указав функцию XSUB, имя которой заканчивается словом &lt;b&gt;DESTROY&lt;/b&gt; . Деструкторы XS могут использоваться для освобождения памяти, которая могла быть заблокирована другим XSUB.</target>
        </trans-unit>
        <trans-unit id="63aaf3d4311946370f948fe1a874ef3b8b5e106b" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; , and &lt;code&gt;XSUB.h&lt;/code&gt; , will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="translated">В следующем XS-файле показана XS-подпрограмма или XSUB, демонстрирующая один из возможных интерфейсов для функции rpcb_gettime (). Этот XSUB представляет собой прямой перевод между C и Perl и поэтому сохраняет интерфейс даже из Perl. Этот XSUB будет вызываться из Perl с использованием, показанным выше. Обратите внимание, что первые три оператора #include для &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; и &lt;code&gt;XSUB.h&lt;/code&gt; всегда будут присутствовать в начале файла XS. Этот и другие подходы будут расширены позже в этом документе. &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; для PERL_NO_GET_CONTEXT должен присутствовать для более эффективного получения контекста интерпретатора, подробности см. В &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d04933d03d9fe0141ffb2c1060f6f198f4e41d2" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt;, &lt;code&gt;perl.h&lt;/code&gt;, and &lt;code&gt;XSUB.h&lt;/code&gt;, will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47250eb8cd4ed87f2a860c613d9258f03e5ab61" translate="yes" xml:space="preserve">
          <source>The following XSUB allows a Perl program to access a C library function called sin(). The XSUB will imitate the C function which takes a single argument and returns a single value.</source>
          <target state="translated">Следующий XSUB позволяет программе на Perl получить доступ к функции библиотеки Си,вызываемой sin().XSUB будет имитировать функцию C,которая принимает единственный аргумент и возвращает единственное значение.</target>
        </trans-unit>
        <trans-unit id="71f3a3c3ea9ed7f75901c1ba18beceaf1cdd2fef" translate="yes" xml:space="preserve">
          <source>The following XSUB is for a C function which requires special handling of its parameters. The Perl usage is given first.</source>
          <target state="translated">Следующий XSUB предназначен для функции C,которая требует особой обработки ее параметров.Сначала указывается использование Perl.</target>
        </trans-unit>
        <trans-unit id="4f90e96487752832ff267e1d1e37b8167fdf3f66" translate="yes" xml:space="preserve">
          <source>The following XSUB uses the &lt;code&gt;SV *&lt;/code&gt; return type as a mnemonic only, and uses a CODE: block to indicate to the compiler that the programmer has supplied all the necessary code. The sv_newmortal() call will initialize the return value to undef, making that the default return value.</source>
          <target state="translated">Следующий XSUB использует возвращаемый тип &lt;code&gt;SV *&lt;/code&gt; как мнемонику и использует блок CODE :, чтобы указать компилятору, что программист предоставил весь необходимый код. Вызов sv_newmortal () инициализирует возвращаемое значение undef, делая его возвращаемым значением по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a1bc7555b268b447bf525bbb361d23e74ba70916" translate="yes" xml:space="preserve">
          <source>The following XSUB will call the C rpcb_gettime() function and will return its two output values, timep and status, to Perl as a single list.</source>
          <target state="translated">Следующий XSUB вызовет функцию C rpcb_gettime()и вернет два ее выходных значения,таймпель и статус,Perl в виде единого списка.</target>
        </trans-unit>
        <trans-unit id="a13ba96373d895202485d58b843fc94572bbb6f9" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char
*host, time_t timep)&lt;/code&gt; , but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt; .</source>
          <target state="translated">Следующий XSUB сгенерирует неправильный код C. &lt;b&gt;Xsubpp&lt;/b&gt; компилятор превратит это в код , который вызывает &lt;code&gt;rpcb_gettime()&lt;/code&gt; с параметрами &lt;code&gt;(char *host, time_t timep)&lt;/code&gt; , но реальная &lt;code&gt;rpcb_gettime()&lt;/code&gt; хочет &lt;code&gt;timep&lt;/code&gt; параметр с типом &lt;code&gt;time_t*&lt;/code&gt; , а не &lt;code&gt;time_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8ca7ce02dc17e5f491e4977939dfb34745c228" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char *host, time_t timep)&lt;/code&gt;, but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e3e7ea3cadf3d440df4d4dd029f14c329e3532" translate="yes" xml:space="preserve">
          <source>The following are Win32 multilanguage editor/IDEs that support Perl:</source>
          <target state="translated">Ниже приведены мультиязычные редакторы/IDE Win32,поддерживающие Perl:</target>
        </trans-unit>
        <trans-unit id="878ebe02234cd6605f8faf412927071c9b53a803" translate="yes" xml:space="preserve">
          <source>The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl</source>
          <target state="translated">Ниже перечислены дополнения,которые были запрошены,но я не хотел их добавлять,так как они очень просты в реализации на perl</target>
        </trans-unit>
        <trans-unit id="f30d9daa89e8ddd37f1202a1d64d4bf0b2c5e1f9" translate="yes" xml:space="preserve">
          <source>The following are all accessor methods -- that is, they don't do anything on their own, but just alter the contents of the conversion object, which comprises the options for this particular batch conversion.</source>
          <target state="translated">Ниже перечислены все методы доступа-то есть,они ничего не делают сами по себе,а просто изменяют содержимое объекта преобразования,который включает в себя опции для данного конкретного пакетного преобразования.</target>
        </trans-unit>
        <trans-unit id="cd4d07e071310dab311d4b0da4565a6a9fb7c1f6" translate="yes" xml:space="preserve">
          <source>The following are also defined by POSIX/SUSv3, but unfortunately not very widely implemented:</source>
          <target state="translated">Следующее также определено POSIX/SUSv3,но,к сожалению,не очень широко распространено:</target>
        </trans-unit>
        <trans-unit id="5b36027844e4806a69f430d629440d5e7ecab300" translate="yes" xml:space="preserve">
          <source>The following are common causes of compilation and/or execution failures, not common to Perl as such. The C FAQ is good bedtime reading. Please test your changes with as many C compilers and platforms as possible; we will, anyway, and it's nice to save oneself from public embarrassment.</source>
          <target state="translated">Ниже приведены общие причины сбоев компиляции и/или выполнения,не характерные для Perl как такового.C FAQ-это хорошее чтение на ночь.Пожалуйста,проверяйте свои изменения с как можно большим количеством компиляторов и платформ C;мы это сделаем в любом случае,и это хорошо,чтобы избавить себя от публичного смущения.</target>
        </trans-unit>
        <trans-unit id="e2853c6c7f110e3e4c7ed324a99e91a718ca2300" translate="yes" xml:space="preserve">
          <source>The following are exported:</source>
          <target state="translated">Экспортируется следующее:</target>
        </trans-unit>
        <trans-unit id="7791b6ab4309dfc3ea821f7f1d4091cb49b39854" translate="yes" xml:space="preserve">
          <source>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</source>
          <target state="translated">Ниже приведены быстрые преобразования из байтов ISO 8859-1 (Латинский-1)в байты UTF-8 и обратно,код работает даже со старыми версиями Perl 5.</target>
        </trans-unit>
        <trans-unit id="c852e811877cc6e9c98b0f2d5fb593ccfc901a95" translate="yes" xml:space="preserve">
          <source>The following are methods in the DB base class. A client must access these methods by inheritance (*not* by calling them directly), since the API keeps track of clients through the inheritance mechanism.</source>
          <target state="translated">Ниже приведены методы в базовом классе БД.Клиент должен получить доступ к этим методам путем наследования (*not*путем прямого вызова),так как API отслеживает клиентов через механизм наследования.</target>
        </trans-unit>
        <trans-unit id="10865635be3faf44cc57e9f25634d2220e52c67d" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3c274cc89ec17e7b845a436f38d1540dbbe5c4" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="translated">Вот такие интерфейсы. Также см &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;. Ошибка Unicode&lt;/a&gt; . Для всех этих интерфейсов Perl в настоящее время (начиная с v5.16.0) просто принимает байтовые строки в качестве аргументов и результатов или строки UTF-8, если использовалась (устаревшая) прагма &lt;code&gt;encoding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bd9bb59d1e1fb0197ed7d9b93043408c8c9a510" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for subroutines:</source>
          <target state="translated">Ниже приведены встроенные атрибуты для подпрограмм:</target>
        </trans-unit>
        <trans-unit id="e8e3f6674cdb74d0958b2c8c99d763306f790276" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for variables:</source>
          <target state="translated">Ниже приведены встроенные атрибуты для переменных:</target>
        </trans-unit>
        <trans-unit id="ff4fdef880964ea16866f7dda3f218be964bbbac" translate="yes" xml:space="preserve">
          <source>The following are unsupported due to the lack of mapping data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2f2e3af66effdb52e3d7832a18951cdcafd9d0" translate="yes" xml:space="preserve">
          <source>The following are valid ($t1 and $t2 are Time::Piece objects):</source>
          <target state="translated">Действительны следующие условия ($t1 и $t2-Time::Piece objects):</target>
        </trans-unit>
        <trans-unit id="cbc24e337c1d628f49530f574e24235d24a7392e" translate="yes" xml:space="preserve">
          <source>The following article by Sean M. Burke and Jordan Lachler first appeared in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5045c4560d45f5e572e375de5ca429c353310df0" translate="yes" xml:space="preserve">
          <source>The following assume that the error has been copied into a separate scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f353aa81f91d6dfefc37a9410a376bf8429ba4d4" translate="yes" xml:space="preserve">
          <source>The following attributes may be specified as arguments to WriteMakefile() or as NAME=VALUE pairs on the command line. Attributes that became available with later versions of MakeMaker are indicated.</source>
          <target state="translated">Следующие атрибуты могут быть указаны в качестве аргументов в WriteMakefile()или в качестве пар NAME=VALUE в командной строке.Указываются атрибуты,которые стали доступны в более поздних версиях MakeMaker.</target>
        </trans-unit>
        <trans-unit id="b84f68ccf7654a835d7d4e99c76422bf128a4813" translate="yes" xml:space="preserve">
          <source>The following blocks are more or less equivalent:</source>
          <target state="translated">Следующие блоки более или менее эквивалентны:</target>
        </trans-unit>
        <trans-unit id="8676339e37a5a253bdb0cffb28423c7698d023a0" translate="yes" xml:space="preserve">
          <source>The following boolean methods are useful in determining the</source>
          <target state="translated">Следующие логические методы полезны при определении</target>
        </trans-unit>
        <trans-unit id="b20d8378cbbcad7ea8e16d1f3872a95fae060afe" translate="yes" xml:space="preserve">
          <source>The following bzip2 constants are exported by this module</source>
          <target state="translated">Этот модуль экспортирует следующие константы bzip2</target>
        </trans-unit>
        <trans-unit id="f401e4eb4fd748677014cc2aaf006246c60d726e" translate="yes" xml:space="preserve">
          <source>The following checks are currently performed:</source>
          <target state="translated">В настоящее время выполняются следующие проверки:</target>
        </trans-unit>
        <trans-unit id="a62f3d4985ed23dc7ef4b06d5778fb97c9f68862" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , or &lt;code&gt;\\&lt;/code&gt; ] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; , and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="translated">В следующем коде показано, как предоставить код инициализации для параметров функции. Код инициализации оценивается компилятором в двойных кавычках перед добавлением к выходным данным, поэтому все, что следует интерпретировать буквально [в основном &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; или &lt;code&gt;\\&lt;/code&gt; ], должно быть защищено обратными косыми чертами . Переменные &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; и &lt;code&gt;$type&lt;/code&gt; можно использовать как в картах типов.</target>
        </trans-unit>
        <trans-unit id="9746ef7b7145a5c34d6668413bb27b113b96441f" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, or &lt;code&gt;\\&lt;/code&gt;] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt;, &lt;code&gt;$arg&lt;/code&gt;, and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994718a63d0e6e92c9d2b82a651bf83693f2d577" translate="yes" xml:space="preserve">
          <source>The following code opens up an output handle that will convert any output to a hexadecimal dump of the output bytes: for example &quot;A&quot; will be converted to &quot;41&quot; (on ASCII-based machines, on EBCDIC platforms the &quot;A&quot; will become &quot;c1&quot;)</source>
          <target state="translated">Следующий код открывает выходной хэндл,который будет преобразовывать любой вывод в шестнадцатеричный дамп выходных байтов:например,&quot;A&quot; будет преобразовываться в &quot;41&quot; (на машинах,основанных на ASCII,на EBCDIC платформах &quot;A&quot; станет &quot;c1&quot;)</target>
        </trans-unit>
        <trans-unit id="b646612d9dad6d0db0d9ef47258da28b3b64f1c7" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="translated">Следующий код создаст строку ASCII с надписью &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . В комментариях отображается строка после каждого шага. Обратите внимание, что этот код работает одинаково на машинах с прямым или обратным порядком байтов.</target>
        </trans-unit>
        <trans-unit id="036e8023d85aa6d81194f031f72a68fa7f59b794" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt;. The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67a84b8d82f9d95c5a2c0536fda7094ec319c8b" translate="yes" xml:space="preserve">
          <source>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</source>
          <target state="translated">Следующий код работает для одноуровневых массивов.Он использует строковое сравнение и не различает определенные и неопределенные пустые строки.Модифицируйте,если у вас есть другие потребности.</target>
        </trans-unit>
        <trans-unit id="b42ca297dfa48bfb8bd9e9eb19ab8d4d7764f6d5" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</source>
          <target state="translated">Все следующие сопоставления имеют смысл, и вы можете встретить любое из них, если &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c757c0b2a139bcc3c8432fda1a1f80dbad9e220" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5819e2e60b0b7a2348ddc793c274025d6f7880f" translate="yes" xml:space="preserve">
          <source>The following command characters are defined:</source>
          <target state="translated">Определены следующие командные символы:</target>
        </trans-unit>
        <trans-unit id="94b38038de165a0daa7082711aa19c3a2036cf7d" translate="yes" xml:space="preserve">
          <source>The following command line switches behave differently under VMS than described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. Note also that in order to pass uppercase switches to Perl, you need to enclose them in double-quotes on the command line, since the CRTL downcases all unquoted strings.</source>
          <target state="translated">Следующие параметры командной строки в VMS &lt;a href=&quot;perlrun&quot;&gt;работают&lt;/a&gt; иначе, чем в perlrun . Также обратите внимание, что для передачи переключателей верхнего регистра в Perl необходимо заключить их в двойные кавычки в командной строке, поскольку CRTL опускает все строки без кавычек.</target>
        </trans-unit>
        <trans-unit id="52448ab44f7b84ff23c0bb42cd9a8e27687108c1" translate="yes" xml:space="preserve">
          <source>The following command shows how to compute digests for typical inputs such as the NIST test vector &quot;abc&quot;:</source>
          <target state="translated">Следующая команда показывает,как вычислять дайджесты для типичных входов,таких как тестовый вектор NIST &quot;abc&quot;:</target>
        </trans-unit>
        <trans-unit id="ab2ed20fd1e01c9d474d41404b2754af8ec50648" translate="yes" xml:space="preserve">
          <source>The following compilation warnings may happen in HP-UX releases earlier than 11.31 but are harmless:</source>
          <target state="translated">Следующие предупреждения компиляции могут появиться в релизах HP-UX раньше 11.31,но они безвредны:</target>
        </trans-unit>
        <trans-unit id="3f82c625cf5e705c9b15fb1534c5c11410cab28f" translate="yes" xml:space="preserve">
          <source>The following compiler versions are currently supported by IBM:</source>
          <target state="translated">Следующие версии компилятора в настоящее время поддерживаются IBM:</target>
        </trans-unit>
        <trans-unit id="f0ad64f79a84fc4d8e60a250b5c99592e7f5b9c7" translate="yes" xml:space="preserve">
          <source>The following compound statements may be used to control flow:</source>
          <target state="translated">Для управления потоком можно использовать следующие утверждения состава:</target>
        </trans-unit>
        <trans-unit id="a4b58da98f934bf4b5cdd1337624b0bd2ba9de07" translate="yes" xml:space="preserve">
          <source>The following compression formats are supported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd012592d06772e0ce9bcaaa2cfc233e60576f7d" translate="yes" xml:space="preserve">
          <source>The following constants may be returned by getaddrinfo() or getnameinfo(). Others may be provided by the OS.</source>
          <target state="translated">Следующие константы могут быть возвращены функцией getaddrinfo()или getnameinfo().Другие могут быть предоставлены операционной системой.</target>
        </trans-unit>
        <trans-unit id="b842779c0173418719ebe5c2a7970e42d7d014a5" translate="yes" xml:space="preserve">
          <source>The following constants may be supplied as $xflags.</source>
          <target state="translated">Следующие константы могут быть поставлены в виде $xflags.</target>
        </trans-unit>
        <trans-unit id="1be3497b66f11b1f18ed534aa513910c71b80ff0" translate="yes" xml:space="preserve">
          <source>The following debugger is actually useful:</source>
          <target state="translated">Следующий отладчик действительно полезен:</target>
        </trans-unit>
        <trans-unit id="becc45c3efb50622f9f813d964b04c0775034a75" translate="yes" xml:space="preserve">
          <source>The following describes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c779f6e32c9824a654c3d3bb9768a1c5fd1243ca" translate="yes" xml:space="preserve">
          <source>The following description of methods is still under development. Please refer to the code for not suitably documented sections and complain loudly to the makemaker@perl.org mailing list. Better yet, provide a patch.</source>
          <target state="translated">Следующее описание методов находится в стадии разработки.Пожалуйста,обратитесь к коду за недостаточно документированными разделами и громко пожалуйтесь на список рассылки makemaker@perl.org.Лучше предоставьте заплатку.</target>
        </trans-unit>
        <trans-unit id="b3965f0e7b97198aca0dad023bdfa649bc3d7a07" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to use FATAL warnings but the perl5 porters strongly recommend that you understand the risks before doing so, especially for library code intended for use by others, as there is no way for downstream users to change the choice of fatal categories.</source>
          <target state="translated">Следующая документация описывает,как использовать предупреждения FATAL,но порталы perl5 настоятельно рекомендуют перед этим понять риски,особенно для библиотечного кода,предназначенного для использования другими пользователями,т.к.у пользователей,находящихся ниже по течению,нет возможности изменить выбор фатальных категорий.</target>
        </trans-unit>
        <trans-unit id="a7395fbf98116a6fe303ce2ccf2e783d73f2e981" translate="yes" xml:space="preserve">
          <source>The following efficiently counts the number of set bits in a bit vector:</source>
          <target state="translated">Ниже эффективно подсчитывается количество заданных битов в битовом векторе:</target>
        </trans-unit>
        <trans-unit id="b85e86d2a59836c1bf602fd66fd49161e113bc9d" translate="yes" xml:space="preserve">
          <source>The following encodings are always available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb10534c1168ba80ae676bc74fad8ea1b177125" translate="yes" xml:space="preserve">
          <source>The following encodings are not supported as yet; some because they are rarely used, some because of technical difficulties. They may be supported by external modules via CPAN in the future, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2679279cde508d70a24c6c066ec89faf688d0162" translate="yes" xml:space="preserve">
          <source>The following entries are used during installation &amp;amp; testing on the libnet package</source>
          <target state="translated">Следующие записи используются во время установки и тестирования пакета libnet.</target>
        </trans-unit>
        <trans-unit id="f9b777d6ecffc2871fa8ad1bd878e3ae6a3e84c6" translate="yes" xml:space="preserve">
          <source>The following environment variables are not specific to Perl: They are part of the standardized (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; method for controlling an application's opinion on data. Windows is non-POSIX, but Perl arranges for the following to work as described anyway. If the locale given by an environment variable is not valid, Perl tries the next lower one in priority. If none are valid, on Windows, the system default locale is then tried. If all else fails, the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale is used. If even that doesn't work, something is badly broken, but Perl tries to forge ahead with whatever the locale settings might be.</source>
          <target state="translated">Следующие переменные среды не являются специфическими для Perl: они являются частью стандартизированного (ISO C, XPG4, POSIX 1.c &lt;code&gt;setlocale()&lt;/code&gt; метода setlocale () для управления мнением приложения о данных. Windows не является POSIX, но Perl в любом случае организовывает работу, как описано ниже. Если языковой стандарт, заданный переменной среды, недопустим, Perl пробует следующий более низкий приоритет. Если ни один из них не является допустимым, в Windows затем пробуется языковой стандарт системы по умолчанию. Если ничего не помогает, используется локаль &lt;code&gt;&quot;C&quot;&lt;/code&gt; . Если даже это не сработает, что-то сильно сломано, но Perl пытается продвигаться вперед с любыми настройками локали.</target>
        </trans-unit>
        <trans-unit id="ec33aa555d27541d5a7185de1c1d5ba6a82fafba" translate="yes" xml:space="preserve">
          <source>The following equivalences hold (assuming &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</source>
          <target state="translated">Имеют место следующие эквивалентности (при условии, что &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="85ca43521cd7775d8d33759b4074f5573158c1e6" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is considered experimental and is subject to change pending feedback from users.</source>
          <target state="translated">Следующий механизм обработки ошибок считается экспериментальным и может быть изменен в ожидании обратной связи от пользователей.</target>
        </trans-unit>
        <trans-unit id="31f04627eff0a8273cc4b4ecad29c912ce9d0e0e" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is consistent throughout all code paths EXCEPT in cases where the ROOT node is nonexistent. In version 2.11 the maintainers attempted to rectify this inconsistency but too many downstream modules encountered problems. In such case, if you require root node evaluation or error checking prior to calling &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt;, you should take additional precautions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd63c469244aad9fa5f13ff0ec636281c8ddaf6b" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</source>
          <target state="translated">Следующая ошибка возникает из-за Cygwin &lt;code&gt;#define&lt;/code&gt; из &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21e6156937fd6a5960b9a95ea9a5b12a0208719f" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8339d5177634294fee1f0a35f0053c9114caf8" translate="yes" xml:space="preserve">
          <source>The following errors were encountered while parsing the POD:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6803ff3ff7c0a56cc9e903a6a90daace782e458" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations whose delimiters aren't single quotes (&lt;code&gt;&quot;'&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111335c40da2391bb6d2b1d90ed4f7cf911e6e5" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations:</source>
          <target state="translated">Следующие экранирующие последовательности доступны в конструкциях,которые интерполируют,и в транслитерациях:</target>
        </trans-unit>
        <trans-unit id="82159e16248ad6f2c09cd225ffdcbbf320f234ef" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, but not in transliterations.</source>
          <target state="translated">Следующие экранирующие последовательности доступны в конструкциях,которые интерполируют,но не в транслитерации.</target>
        </trans-unit>
        <trans-unit id="62d1bc8a7a340748e143b5a954b697a1e9a92d04" translate="yes" xml:space="preserve">
          <source>The following example contains all supported keywords and structures with the exception of &lt;code&gt;eexpect&lt;/code&gt; which can be used instead of &lt;code&gt;expect&lt;/code&gt; .</source>
          <target state="translated">Следующий пример содержит все поддерживаемые ключевые слова и структуры, за исключением &lt;code&gt;eexpect&lt;/code&gt; , который можно использовать вместо &lt;code&gt;expect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8665fd8b339dfb9b20108d0f4ac2879711d7bca" translate="yes" xml:space="preserve">
          <source>The following example counts all the possible matching strings in a pattern (without actually matching any of them).</source>
          <target state="translated">В следующем примере подсчитываются все возможные совпадения строк в шаблоне (без фактического совпадения ни одной из них).</target>
        </trans-unit>
        <trans-unit id="b54547ad1ef83c76b354b1c5c3bcd26f7c112217" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt; , which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="translated">В следующем примере реализуется простой демон, который перезапускается каждый раз при получении сигнала &lt;code&gt;SIGHUP&lt;/code&gt; . Фактический код находится в подпрограмме &lt;code&gt;code()&lt;/code&gt; , которая просто выводит некоторую отладочную информацию, чтобы показать, что она работает; его следует заменить реальным кодом.</target>
        </trans-unit>
        <trans-unit id="72ef6e9fa58ad7d92fd5d070a5b1ff44ddb10726" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt;, which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db59d80ee391c290c8e0098f7b4cb5a921d343a" translate="yes" xml:space="preserve">
          <source>The following example shows a variation of the rpcb_gettime() function. This function uses the timep variable only as an output variable and does not care about its initial contents.</source>
          <target state="translated">В следующем примере показан вариант функции rpcb_gettime().Эта функция использует переменную времени только в качестве выходной и не заботится о ее исходном содержимом.</target>
        </trans-unit>
        <trans-unit id="6e5930c0e8a4086018f7b728e0496b7b5959e325" translate="yes" xml:space="preserve">
          <source>The following example shows how the input parameter &lt;code&gt;timep&lt;/code&gt; can be evaluated late, after a PREINIT.</source>
          <target state="translated">В следующем примере показано, как входной параметр &lt;code&gt;timep&lt;/code&gt; может быть вычислен позже, после PREINIT.</target>
        </trans-unit>
        <trans-unit id="f2d336b88b655db564d2a7de7cc37f5570d6138e" translate="yes" xml:space="preserve">
          <source>The following example will create aliases &lt;code&gt;FOO::gettime()&lt;/code&gt; and &lt;code&gt;BAR::getit()&lt;/code&gt; for this function.</source>
          <target state="translated">В следующем примере для этой функции будут &lt;code&gt;FOO::gettime()&lt;/code&gt; псевдонимы FOO :: gettime () и &lt;code&gt;BAR::getit()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97da872b2dd68324aaeb980a55e38dbf65cc1f09" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt; : a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">В следующем примере импортируется сама &lt;code&gt;langinfo()&lt;/code&gt; и три константы, которые будут использоваться в качестве аргументов в &lt;code&gt;langinfo()&lt;/code&gt; : константа для сокращенного первого дня недели (нумерация начинается с воскресенья = 1) и еще две константы для утвердительного и отрицательные ответы на вопрос &quot;да / нет&quot; в текущей локали.</target>
        </trans-unit>
        <trans-unit id="fa3452b428040cf2c56efc56c05eb14116e2d423" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt;: a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fe38084e5e619d96b5a9797595ec407ba06c97" translate="yes" xml:space="preserve">
          <source>The following example will import the langinfo() function itself and three constants to be used as arguments to langinfo(): a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">В следующем примере в langinfo()будет импортирована сама функция langinfo()и три константы,которые будут использоваться в качестве аргументов:константа для сокращенного первого дня недели (нумерация начинается с воскресенья=1)и еще две константы для утвердительных и отрицательных ответов на вопрос &quot;да/нет&quot; в текущей локали.</target>
        </trans-unit>
        <trans-unit id="1d1e35923d66b27df87bbd4951c7d28f5e911d07" translate="yes" xml:space="preserve">
          <source>The following example will start the XS code and will place all functions in a package named RPC.</source>
          <target state="translated">Следующий пример запустит код XS и поместит все функции в пакет с именем RPC.</target>
        </trans-unit>
        <trans-unit id="dcb1a8c644e732663ae2a1c5ba3b577a1beb1ffa" translate="yes" xml:space="preserve">
          <source>The following examples all demonstrate how &lt;code&gt;reduce&lt;/code&gt; could be used to implement the other list-reduction functions in this module. (They are not in fact implemented like this, but instead in a more efficient manner in individual C functions).</source>
          <target state="translated">Все следующие примеры демонстрируют, как можно использовать &lt;code&gt;reduce&lt;/code&gt; для реализации других функций сокращения списка в этом модуле. (На самом деле они реализованы не так, а более эффективно в отдельных функциях C).</target>
        </trans-unit>
        <trans-unit id="887954cfa884d676e908a97b64a1555b23e32dbf" translate="yes" xml:space="preserve">
          <source>The following examples are equivalent, but if the code is using complex typemaps then the first example is safer.</source>
          <target state="translated">Следующие примеры эквивалентны,но если в коде используются сложные типовые карты,то первый пример безопаснее.</target>
        </trans-unit>
        <trans-unit id="49473e8ccd96036c2dcbbff4100727b567ca00bb" translate="yes" xml:space="preserve">
          <source>The following examples assume</source>
          <target state="translated">Следующие примеры предполагают</target>
        </trans-unit>
        <trans-unit id="c8963d9d7205dc5eeae0e9a51c29c23916de6bfc" translate="yes" xml:space="preserve">
          <source>The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl. The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).</source>
          <target state="translated">Следующие примеры не пытаются показать все,так как это было бы монументальным заданием,и,честно говоря,мы не хотим,чтобы эта страница была документом для Perl.Примеры действительно демонстрируют некоторые основы необработанных типов данных Perl,и их должно быть достаточно,чтобы привлечь наиболее целеустремленных людей.Нет ни путеводителей,ни подстраховочных сетей,ни сверкающих троп,так что будьте готовы к путешествию в одиночку от этой точки и дальше и,если это возможно,не попадайте в зыбучие пески (это плохо для бизнеса).</target>
        </trans-unit>
        <trans-unit id="6687cc4c1adb4921b8b4b2318949d366c6deb7ae" translate="yes" xml:space="preserve">
          <source>The following examples show standard binary, octal, decimal, and hexadecimal conversion. All examples return 250.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93e6ebc989a84ca950fac6b12d34738b1701d5f" translate="yes" xml:space="preserve">
          <source>The following extension layers are bundled with perl:</source>
          <target state="translated">Следующие удлинительные слои укомплектованы перлом:</target>
        </trans-unit>
        <trans-unit id="162be8fe3d219b0d9c97c2e524d7220d440e0dd3" translate="yes" xml:space="preserve">
          <source>The following extra flags are added:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7106b07b78b7a3440b3c0ad4f4323e11abe72903" translate="yes" xml:space="preserve">
          <source>The following extra operations are supported on both real and complex numbers:</source>
          <target state="translated">Следующие дополнительные операции поддерживаются как над реальными,так и над комплексными числами:</target>
        </trans-unit>
        <trans-unit id="44559e75149012ee5d0aabd7169096ab8b9b70c9" translate="yes" xml:space="preserve">
          <source>The following feature bundles are available:</source>
          <target state="translated">Доступны следующие наборы функций:</target>
        </trans-unit>
        <trans-unit id="bfb5fd7e91227c5f530d75f35f7920db7fa46141" translate="yes" xml:space="preserve">
          <source>The following file is certain to trigger a few errors at both runtime and compiletime:</source>
          <target state="translated">Следующий файл,несомненно,вызовет несколько ошибок как во время выполнения,так и во время компиляции:</target>
        </trans-unit>
        <trans-unit id="21aca79b002af6c026c59989c512a774a1e9d423" translate="yes" xml:space="preserve">
          <source>The following files were created.</source>
          <target state="translated">Были созданы следующие файлы.</target>
        </trans-unit>
        <trans-unit id="c2d8b9dded738fa01824e3880baab2ed9227058b" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised as $flags. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">Следующие константы флагов распознаются как флаги $.Могут существовать и другие константы флагов,предусмотренные операционной системой.</target>
        </trans-unit>
        <trans-unit id="650acaa8d024a737244b8df389c437c35b54545d" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised in the $hints hash. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">Следующие флаговые константы распознаются в хэше $hints.Могут существовать и другие флаговые константы,предусмотренные операционной системой.</target>
        </trans-unit>
        <trans-unit id="8b04fa6f897518e44671c43d372c1d8cbb29d5b0" translate="yes" xml:space="preserve">
          <source>The following flag has been added in the Perl implementation for csh compatibility:</source>
          <target state="translated">Следующий флаг был добавлен в реализацию Perl для совместимости с csh:</target>
        </trans-unit>
        <trans-unit id="50651d66e2238c03eee6171d8e3c138d824ff88d" translate="yes" xml:space="preserve">
          <source>The following flags and properties are for JSON::PP only. If you use any of these, you can't make your application run faster by replacing JSON::PP with JSON::XS. If you need these and also speed boost, you might want to try &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel::JSON::XS&lt;/a&gt;, a fork of JSON::XS by Reini Urban, which supports some of these (with a different set of incompatibilities). Most of these historical flags are only kept for backward compatibility, and should not be used in a new application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd8e3861113caf88d2e286d8b55139fd349b7d0" translate="yes" xml:space="preserve">
          <source>The following flags would be nice to have but they would first need their own Augean stablemaster:</source>
          <target state="translated">Следующие флаги было бы неплохо иметь,но сначала им понадобился бы собственный аугейский конюх:</target>
        </trans-unit>
        <trans-unit id="e731ee95c2996f14c508bcbd1c142f7cd0808c33" translate="yes" xml:space="preserve">
          <source>The following four convenience wrappers may be used to obtain one of the two values returned here. If both host and service names are required, this method is preferable to the following wrappers, because it will call &lt;code&gt;getnameinfo(3)&lt;/code&gt; only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9100eb4e02b3634a97be9d3c35013fdbb0474e55" translate="yes" xml:space="preserve">
          <source>The following four files sum up all the details discussed so far.</source>
          <target state="translated">Следующие четыре файла суммируют все детали,обсуждавшиеся до сих пор.</target>
        </trans-unit>
        <trans-unit id="c34a482a0a61764634c9a647354d1ae932661df4" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">Следующая функция копирует строку в SV, ссылка на которую - &lt;code&gt;rv&lt;/code&gt; . Установите длину в 0, чтобы Perl мог вычислить длину строки. SV благословляется, если имя &lt;code&gt;classname&lt;/code&gt; равно нулю.</target>
        </trans-unit>
        <trans-unit id="d572303a215881dcd48f5b462f35572b6b301a6c" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt;. Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0cf226e396fa1b152052f0820e83e7d855fd95" translate="yes" xml:space="preserve">
          <source>The following function copies the pointer value (</source>
          <target state="translated">Следующая функция копирует значение указателя (</target>
        </trans-unit>
        <trans-unit id="2e073fa19276cae1009d363a0e5463744a8cdb65" translate="yes" xml:space="preserve">
          <source>The following function is available on Perls built on 64 bit OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL support is in principle available as of OpenVMS v7.3-1, and better configuration support could detect this.</source>
          <target state="translated">Следующая функция доступна на Perls,построенном на 64-битном OpenVMS v8.2,с включенными жесткими ссылками на отформатированном сборочном диске ODS-5.Поддержка CRTL в принципе доступна начиная с OpenVMS v7.3-1,и это может быть обнаружено с помощью лучшей поддержки конфигурации.</target>
        </trans-unit>
        <trans-unit id="1d791c23038d9fe8780d570ab1f25e41c2c30bfa" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is a reference to a blessed object.</source>
          <target state="translated">Следующая функция проверяет,является ли SV ссылкой на благословенный объект.</target>
        </trans-unit>
        <trans-unit id="e97d512753d6d3628f54f7cc67945848127ebcd9" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is blessed into the specified class. It does not check inheritance relationships.</source>
          <target state="translated">Следующая функция проверяет,является ли SV благословенным в указанном классе.Она не проверяет отношения наследования.</target>
        </trans-unit>
        <trans-unit id="df3aa6043ddcb399a0be1d9f05fb30512b44c0e8" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is derived from the specified class. SV can be either a reference to a blessed object or a string containing a class name. This is the function implementing the &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; functionality.</source>
          <target state="translated">Следующая функция проверяет, является ли SV производным от указанного класса. SV может быть ссылкой на благословенный объект или строкой, содержащей имя класса. Это функция, реализующая функциональность &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2556ab0e8df33f1383226a4c6f98cdd750d952a" translate="yes" xml:space="preserve">
          <source>The following function upgrades rv to reference if not already one. Creates a new SV for rv to point to. If &lt;code&gt;classname&lt;/code&gt; is non-null, the SV is blessed into the specified class. SV is returned.</source>
          <target state="translated">Следующая функция обновляет rv до ссылки, если она еще не была. Создает новый SV, на который указывает rv. Если имя &lt;code&gt;classname&lt;/code&gt; равно нулю, SV благословляется в указанный класс. SV возвращается.</target>
        </trans-unit>
        <trans-unit id="29dc5cc89743cc721a2ee3907403e1585ed5aaa4" translate="yes" xml:space="preserve">
          <source>The following functions</source>
          <target state="translated">следующие функции</target>
        </trans-unit>
        <trans-unit id="d058fd87c96266d5fdc51527ace77cd0d78cdd43" translate="yes" xml:space="preserve">
          <source>The following functions all perform some useful activity on reference values.</source>
          <target state="translated">Все перечисленные ниже функции выполняют определенную полезную работу по справочным значениям.</target>
        </trans-unit>
        <trans-unit id="2911d89162772ba03d36f6973e469a4101bb2cc6" translate="yes" xml:space="preserve">
          <source>The following functions are Perl implementations of the mktemp() family of temp file generation system calls.</source>
          <target state="translated">Следующими функциями являются реализации на Perl семейства mktemp()системных вызовов temp-файлов.</target>
        </trans-unit>
        <trans-unit id="e0a3d6bc866a23a74bfc5cb99a24046225a27424" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later.</source>
          <target state="translated">Следующие функции доступны на Perls,собранном на 64-битной OpenVMS v8.2 и более поздних версиях.</target>
        </trans-unit>
        <trans-unit id="c3192aa510cfad4d7ff0a5d49cbe59b87b3bf2ce" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS v7.3-2, and better configuration support could detect this.</source>
          <target state="translated">Следующие функции доступны на Perls,собранном на 64-битной OpenVMS v8.2 и более поздних версиях.Поддержка CRTL в принципе доступна начиная с OpenVMS v7.3-2,и это может быть обнаружено при лучшей поддержке конфигурации.</target>
        </trans-unit>
        <trans-unit id="9298194e3e006b8fbe7257f536dde080822b8c50" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on VMS 7.2 or greater:</source>
          <target state="translated">Следующие функции доступны на Perls,построенных на VMS 7.2 или более поздних версиях:</target>
        </trans-unit>
        <trans-unit id="5c953c5f1b476c550370e7b30065e8a151627682" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls compiled with Dec C 5.2 or greater and running VMS 7.0 or greater:</source>
          <target state="translated">Следующие функции доступны на Perls,скомпилированных с Dec C 5.2 или более поздней версии и работающих под управлением VMS 7.0 или более поздней версии:</target>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="translated">Доступны следующие функции.</target>
        </trans-unit>
        <trans-unit id="5950979e93d5397c31fbc2a28b94b256eeabee34" translate="yes" xml:space="preserve">
          <source>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</source>
          <target state="translated">Следующие функции в настоящее время не документированы.Если вы используете одну из них,возможно,вы захотите рассмотреть вопрос о создании и подаче документации для нее.</target>
        </trans-unit>
        <trans-unit id="886ab3bb8b191680b7816c0256fd741faf8bc7ec" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="translated">Следующие функции определены ядром Perl в пакете &lt;code&gt;utf8::&lt;/code&gt; . Вам не нужно говорить об &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; чтобы использовать их, и на самом деле вы не должны говорить это, если вы действительно не хотите иметь исходный код UTF-8.</target>
        </trans-unit>
        <trans-unit id="04035437cedd81d97c7436275ce862e9db956a98" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;use utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d924d0242f33a4bd7b878adc5df25af14f3fc818" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Filter::Util::Call&lt;/code&gt; экспортирует следующие функции :</target>
        </trans-unit>
        <trans-unit id="880d841885ac667bfdecc26d11ccfd01c2ab96a8" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab0faf40d4a413b76ab20e1f7c9c1ce5f8e0b08" translate="yes" xml:space="preserve">
          <source>The following functions are exported by default.</source>
          <target state="translated">По умолчанию экспортируются следующие функции.</target>
        </trans-unit>
        <trans-unit id="f74d5f0be47eadceddfa059884e47684f407a94a" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module. Please note that these are functions (not methods) and therefore &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; take an implicit first argument.</source>
          <target state="translated">Этот модуль экспортирует следующие функции. Обратите внимание, что это функции (а не методы), поэтому &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; принимают неявный первый аргумент.</target>
        </trans-unit>
        <trans-unit id="ecbe41a265e73d2f25c7e96c76a4a747b067fbd6" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="translated">Этот модуль экспортирует следующие функции: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; и &lt;code&gt;cond_broadcast&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a286ac22b6e657ba87cab3b6eff4036bd887933" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt;, &lt;code&gt;shared_clone&lt;/code&gt;, &lt;code&gt;is_shared&lt;/code&gt;, &lt;code&gt;cond_wait&lt;/code&gt;, &lt;code&gt;cond_timedwait&lt;/code&gt;, &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359dedf5643622ca4347a5ad1835485c0f626223" translate="yes" xml:space="preserve">
          <source>The following functions are exported only by request.</source>
          <target state="translated">Следующие функции экспортируются только по запросу.</target>
        </trans-unit>
        <trans-unit id="6ff004aea51ff452f5a6a3680250ec66d08e006e" translate="yes" xml:space="preserve">
          <source>The following functions are not considered to be part of the public interface. They are documented here for the benefit of future maintainers of this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb1dbec7cc374a481e866646b73ca4b04e611a0" translate="yes" xml:space="preserve">
          <source>The following functions are now implemented in FastCalc.xs:</source>
          <target state="translated">Следующие функции теперь реализованы в FastCalc.xs:</target>
        </trans-unit>
        <trans-unit id="685959529a3484efa19ac7a3baaeafce45e37b9a" translate="yes" xml:space="preserve">
          <source>The following functions are provided by the &lt;code&gt;Digest::MD5&lt;/code&gt; module. None of these functions are exported by default.</source>
          <target state="translated">Следующие функции предоставляются модулем &lt;code&gt;Digest::MD5&lt;/code&gt; . По умолчанию ни одна из этих функций не экспортируется.</target>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="translated">Предусмотрены следующие функции:</target>
        </trans-unit>
        <trans-unit id="cb80d66061f0196a6ca192d5341a430ee1b0eb26" translate="yes" xml:space="preserve">
          <source>The following functions are supported:</source>
          <target state="translated">Поддерживаются следующие функции:</target>
        </trans-unit>
        <trans-unit id="89bf61ba64cc618bf2874d4293a3aae6452f1aba" translate="yes" xml:space="preserve">
          <source>The following functions can be imported from this module. No functions are exported by default.</source>
          <target state="translated">Из этого модуля можно импортировать следующие функции.По умолчанию функции не экспортируются.</target>
        </trans-unit>
        <trans-unit id="76627ad7f894d0c3e9a81281fe41fe4c1c985047" translate="yes" xml:space="preserve">
          <source>The following functions check whether the string is in that normalization form.</source>
          <target state="translated">Следующие функции проверяют,находится ли строка в этой форме нормализации.</target>
        </trans-unit>
        <trans-unit id="a27da5eeba1599f572e14a8c9329aa08b0e2cd4f" translate="yes" xml:space="preserve">
          <source>The following functions convert between lists of Perl values and packed binary strings representing structures.</source>
          <target state="translated">Следующие функции преобразуют между списками значений Perl и упакованными двоичными строками,представляющими структуры.</target>
        </trans-unit>
        <trans-unit id="2ccfd58b6052a416773b606e17f327b9dd3cd108" translate="yes" xml:space="preserve">
          <source>The following functions have been flagged as part of the public API, but are currently undocumented. Use them at your own risk, as the interfaces are subject to change. Functions that are not listed in this document are not intended for public use, and should NOT be used under any circumstances.</source>
          <target state="translated">Следующие функции были помечены как часть публичного API,но в настоящее время не документированы.Используйте их на свой страх и риск,так как интерфейсы могут быть изменены.Функции,не перечисленные в этом документе,не предназначены для публичного использования и НЕ должны использоваться ни при каких обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="824636764a16367a90dfdeffbf74adccac69c5cb" translate="yes" xml:space="preserve">
          <source>The following functions in the &lt;code&gt;POSIX&lt;/code&gt; module are no longer available: &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, and &lt;code&gt;isxdigit&lt;/code&gt;. The functions are buggy and don't work on UTF-8 encoded strings. See their entries in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f79fe7f0a766eea8a6363560d09b1b418f37a54" translate="yes" xml:space="preserve">
          <source>The following functions may or may not be implemented, depending on what type of socket support you've built into your copy of Perl:</source>
          <target state="translated">Следующие функции могут быть реализованы,а могут и не быть,в зависимости от того,какой тип поддержки сокетов вы встроили в вашу копию Perl:</target>
        </trans-unit>
        <trans-unit id="2d8b2c9f184b69863b362bc365b152ff7d6a2cc5" translate="yes" xml:space="preserve">
          <source>The following functions use &lt;code&gt;$_&lt;/code&gt; as a default argument:</source>
          <target state="translated">Следующие функции используют &lt;code&gt;$_&lt;/code&gt; в качестве аргумента по умолчанию:</target>
        </trans-unit>
        <trans-unit id="0dd434c67978a923f9ec0ee28d2a5538ba5682f6" translate="yes" xml:space="preserve">
          <source>The following functions were not implemented in the VMS port, and calling them produces a fatal error (usually) or undefined behavior (rarely, we hope):</source>
          <target state="translated">Следующие функции не были реализованы в порту VMS,и их вызов приводит к фатальной ошибке (обычно)или неопределенному поведению (надеемся,редко):</target>
        </trans-unit>
        <trans-unit id="cdfa439e416672c343b7c0368293d837f0c0576b" translate="yes" xml:space="preserve">
          <source>The following functions would all be inlined:</source>
          <target state="translated">Все нижеперечисленные функции будут включены:</target>
        </trans-unit>
        <trans-unit id="f04cb90467492e19af66e5b899cfc303ddef4110" translate="yes" xml:space="preserve">
          <source>The following global variables are associated with arenas:</source>
          <target state="translated">Следующие глобальные переменные связаны с аренами:</target>
        </trans-unit>
        <trans-unit id="0d3412aee89bad6343f641caa3a5d4996443527e" translate="yes" xml:space="preserve">
          <source>The following illustrates use of the Benchmark object:</source>
          <target state="translated">Ниже проиллюстрировано использование объекта Бенчмарк:</target>
        </trans-unit>
        <trans-unit id="21c5c52868e5d5448c65efac8d8979602bb9419b" translate="yes" xml:space="preserve">
          <source>The following information applies to gcc version 2. Volunteers to update it as appropriately for gcc version 3 would be appreciated.</source>
          <target state="translated">Следующая информация действительна для версии gcc 2.Приветствуются добровольцы,желающие обновить его соответствующим образом для 3-й версии gcc.</target>
        </trans-unit>
        <trans-unit id="62ec6b5e797715143c688dee03c54b63962fd46a" translate="yes" xml:space="preserve">
          <source>The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.</source>
          <target state="translated">Для совместимости с существующими API предусмотрены следующие интерфейсы.Их не следует использовать в новом коде.</target>
        </trans-unit>
        <trans-unit id="0bdb13054ff9ef26849b463627b5915db32807ca" translate="yes" xml:space="preserve">
          <source>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</source>
          <target state="translated">Ниже приведен длинный раздел различных требований и предложений,связанных с обработкой стручков.</target>
        </trans-unit>
        <trans-unit id="9eebaea88bec8281bdda401db84ecb8529c5edbd" translate="yes" xml:space="preserve">
          <source>The following is an example of a typemap that could be used for this C++ example.</source>
          <target state="translated">Ниже приведен пример типовой карты,которая может быть использована для этого примера C++.</target>
        </trans-unit>
        <trans-unit id="a14c2ddd24e4bc7ed4b474606997260d2d723a26" translate="yes" xml:space="preserve">
          <source>The following is the old c2ph.doc documentation by Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; Date: 25 Jul 91 08:10:21 GMT</source>
          <target state="translated">Ниже приводится старая документация c2ph.doc Тома Кристиансена &amp;lt;tchrist@perl.com&amp;gt; Дата: 25 июля 91 г., 08:10:21 по Гринвичу</target>
        </trans-unit>
        <trans-unit id="838c8cc6acec4e734454e6016dba1f13113970de" translate="yes" xml:space="preserve">
          <source>The following is used to &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; core modules beyond a certain version of Perl:</source>
          <target state="translated">Следующее используется для &lt;a href=&quot;deprecate&quot;&gt;исключения&lt;/a&gt; основных модулей за пределами определенной версии Perl:</target>
        </trans-unit>
        <trans-unit id="0c3fbe199ab2c0c87ca2506f58ce4cc1ff1336a3" translate="yes" xml:space="preserve">
          <source>The following keys allowed for callbacks. These keys are case-sensitive.</source>
          <target state="translated">Для обратного вызова разрешены следующие ключи.Эти клавиши чувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="ace2dc9ae3a6b314c56205001ea3e99826b29341" translate="yes" xml:space="preserve">
          <source>The following keys are optional.</source>
          <target state="translated">Следующие клавиши являются необязательными.</target>
        </trans-unit>
        <trans-unit id="87593abf1938664ef0461a9fc202ad24f5f827db" translate="yes" xml:space="preserve">
          <source>The following keys are recognised in the option hash:</source>
          <target state="translated">В хэше опции распознаются следующие клавиши:</target>
        </trans-unit>
        <trans-unit id="938c23249f0abe69d61c5caeb8c241a3b1c97b48" translate="yes" xml:space="preserve">
          <source>The following keys are valid, but only &lt;code&gt;version&lt;/code&gt; is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e29171b7f3395c93aba1c43b176e6a5f79f9da1" translate="yes" xml:space="preserve">
          <source>The following keys in the hash reference $CPAN::Config are currently defined:</source>
          <target state="translated">Следующие ключи в ссылке хэша $CPAN::Config в настоящее время определены:</target>
        </trans-unit>
        <trans-unit id="8faa1306b5e277a45ec730d9a598e8adafe08efc" translate="yes" xml:space="preserve">
          <source>The following layers are currently defined:</source>
          <target state="translated">В настоящее время определены следующие слои:</target>
        </trans-unit>
        <trans-unit id="d62e448414706bf58b56c68adcd155be3caa2f9f" translate="yes" xml:space="preserve">
          <source>The following license strings are also valid and indicate other licensing not described above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8819c5fc895570a060c0cc0274e5435ca8214190" translate="yes" xml:space="preserve">
          <source>The following line is taken from the testsuite for &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File::Map&lt;/a&gt;:</source>
          <target state="translated">Следующая строка взята из набора тестов для &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File :: Map&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b26a944c006c4ed66106c7db11bb76fd456329ff" translate="yes" xml:space="preserve">
          <source>The following lines are equivalent:</source>
          <target state="translated">Следующие строки эквивалентны:</target>
        </trans-unit>
        <trans-unit id="f188bcdc507d79e65b8c87878e9261e514ba50b4" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27fa1a573ac1c2bd0bdaed0b154f8a047e4a778" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level N&quot; and the section numbers refer to the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13, from August 2008.</source>
          <target state="translated">Следующий список функций,поддерживаемых Юникодом для регулярных выражений,описывает все функции,которые в настоящее время напрямую поддерживаются ядром Perl.Ссылки на &quot;Уровень N&quot; и номера разделов относятся к Техническому стандарту Юникода №18 &quot;Регулярные выражения Юникода&quot;,версия 13,с августа 2008 года.</target>
        </trans-unit>
        <trans-unit id="fd9860b919a8b832481067980e3c3a381ec06f0c" translate="yes" xml:space="preserve">
          <source>The following list of license strings are valid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d2ac78ac8de1d9653897258388c5a4d402853b" translate="yes" xml:space="preserve">
          <source>The following macros must always be used to access the contents of hash entries. Note that the arguments to these macros must be simple variables, since they may get evaluated more than once. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions of these macros.</source>
          <target state="translated">Следующие макросы всегда должны использоваться для доступа к содержимому хеш-записей. Обратите внимание, что аргументы этих макросов должны быть простыми переменными, поскольку они могут оцениваться более одного раза. См. &lt;a href=&quot;perlapi&quot;&gt;Perlapi&lt;/a&gt; для подробного описания этих макросов.</target>
        </trans-unit>
        <trans-unit id="54cabd1569f977ca3a4b00bfe48c1954ef75d0d2" translate="yes" xml:space="preserve">
          <source>The following methods all return a boolean value and are to be overridden in the appropriate subclass.</source>
          <target state="translated">Все следующие методы возвращают булевое значение и должны быть переопределены в соответствующем подклассе.</target>
        </trans-unit>
        <trans-unit id="2e28c1a68a0ac1abaa1b238b7c5b433afa448fce" translate="yes" xml:space="preserve">
          <source>The following methods are available for all &lt;code&gt;Digest::&lt;/code&gt; modules:</source>
          <target state="translated">Для всех модулей &lt;code&gt;Digest::&lt;/code&gt; доступны следующие методы :</target>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="translated">Доступны следующие методы:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
