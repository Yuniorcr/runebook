<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">ДОКЛАД ОТЧЕТА О БУГЕ</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">БУГ-ОТЧЕТЫ</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">ОШИБКИ И ПРЕДОСТЕРЕЖЕНИЯ</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">ОШИБКИ И РАЗДРАЖЕНИЯ</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">ОШИБКИ И ОГРАНИЧЕНИЯ</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">ОШИБКИ И ПОДВОДНЫЕ КАМНИ</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">ОШИБКИ И ПРЕДУПРЕЖДЕНИЯ</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">БУГГЫ НА ЦИГВИНЕ</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">БУГИ и КАВЕАТЫ</target>
        </trans-unit>
        <trans-unit id="6c450a35b54bd0a62e732cbab24c3d7221d9a194" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=%24ModuleName&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">BUGS - это электронная почта или URL-адрес для публикации отчетов об ошибках. Для модулей с UPSTREAM =&amp;gt; 'blead' используйте perl5-porters@perl.org. Кажется, что rt.cpan.org автоматически предоставляет URL для модулей CPAN; любое значение, указанное здесь, отменяет значение по умолчанию: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt; $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">СБОРКА И УСТАНОВКА</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">СОЗДАВАТЬ НОВЫЕ РАСШИРЕНИЯ</target>
        </trans-unit>
        <trans-unit id="915ac3e12b39990a3ff0eb519c7c070afd799641" translate="yes" xml:space="preserve">
          <source>BUILDING</source>
          <target state="translated">BUILDING</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">ПОСТРОЕНИЕ И УСТАНОВКА МОДУЛЕЙ ПО ДОЗИРОВКЕ</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">СТРОИТЕЛЬНЫЙ ПЕРЛ ДЛЯ OPENVOS</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">ПЕРЛ НА АМИГАЯХ</target>
        </trans-unit>
        <trans-unit id="d40a175e7a653e9eaa67c4da87c76fc937184284" translate="yes" xml:space="preserve">
          <source>BUILD_REQUIRES</source>
          <target state="translated">BUILD_REQUIRES</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">Еще до того, как в Perl появилась система XS для соединения с библиотеками C, программисты получали константы библиотеки путем чтения файлов заголовков C. Вы можете по-прежнему видеть &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; или аналогичный -</target>
        </trans-unit>
        <trans-unit id="a14d8f418667d750d655e37f8fb2aa536926510a" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;require 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">Тогда диапазон 0xD800-0xDFFF не выделялся. Давайте разделим этот диапазон пополам и используем первую половину для представления &lt;code&gt;upper half of a character&lt;/code&gt; а вторую половину - для представления &lt;code&gt;lower half of a character&lt;/code&gt; . Таким образом, вы можете представить 1024 * 1024 = 1048576 дополнительных символов. Теперь мы можем хранить диапазоны символов до \ x {10ffff} даже с 16-битными кодировками. Эта пара полусимволов теперь называется</target>
        </trans-unit>
        <trans-unit id="8b862d333105bea92e016a8abca6974a21d6cf0e" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower half of a character&lt;/code&gt;. That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe6515e366531ac45779e3d5c9b5a456560e812" translate="yes" xml:space="preserve">
          <source>Back to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">Возвращаемся к преобразованию данных.Если у вас есть (или вы хотите)данные в родной 8-битной кодировке вашей системы (например,Latin-1,EBCDIC и т.д.),вы можете использовать pack/unpack для конвертирования в/из Unicode.</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">Бэкэнд для создания тестовых библиотек</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">Фоновые процессы</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">Фон и PERL_IMPLICIT_CONTEXT</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">Сделай себе такую подоплеку:</target>
        </trans-unit>
        <trans-unit id="fec43a1301d416fe4b43d921e7178671d812a1b8" translate="yes" xml:space="preserve">
          <source>Background: &lt;code&gt;atoi&lt;/code&gt; has severe problems with illegal inputs, it cannot be used for incremental parsing, and therefore should be avoided &lt;code&gt;atoi&lt;/code&gt; and &lt;code&gt;strtol&lt;/code&gt; are also affected by locale settings, which can also be seen as a bug (global state controlled by user environment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eced385684cc6954de21105c9b174aaf3bba4295" translate="yes" xml:space="preserve">
          <source>Backported version unknown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422ea69f009b9513c410e1c50a5058f352b88507" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">Обратная ссылка на именованную группу захвата. Эквивалентно &lt;code&gt;\g{NAME}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">Ссылки в заменах используют &quot;$&quot;,а не &quot;\&quot;.</target>
        </trans-unit>
        <trans-unit id="f6f78ea4ce7c5612a0f7211383bd0176dfc079e5" translate="yes" xml:space="preserve">
          <source>Backslash Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">Секвенции обратной связи</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">Обратная косая черта,как обычно,используется,чтобы избежать следующего персонажа.</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">Классы символов обратной последовательности не могут образовывать одну из конечных точек диапазона.Таким образом,вы не можете сказать:</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">последовательности обратного слеша</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">Символы с обратной косой чертой либо заменяются соответствующими буквенными строками (как с &lt;code&gt;\{&lt;/code&gt; ), либо генерируют специальные узлы в конечном автомате (как с &lt;code&gt;\b&lt;/code&gt; ). Специальные символы для механизма RE (такие как &lt;code&gt;|&lt;/code&gt; ) создают соответствующие узлы или группы узлов. &lt;code&gt;(?#...)&lt;/code&gt; комментарии игнорируются. Все остальное либо преобразуется в буквальные строки для сопоставления, либо игнорируется (как пробелы и комментарии в стиле &lt;code&gt;#&lt;/code&gt; , если присутствует &lt;code&gt;/x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5aeb8eb150f9b708f4b9ee0e63969a864d6fc87f" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt;). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt;-style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Метасимволы с обратной косой чертой в Perl являются буквенно-цифровыми, например &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . В отличие от некоторых других языков регулярных выражений, здесь нет буквенно-цифровых символов с обратной косой чертой. Таким образом, все, что выглядит как \\, \ (, \), \ [, \], \ {или \}, всегда интерпретируется как буквальный символ, а не как метасимвол. Когда-то это использовалось в общей идиоме для отключения или цитирования специальных значений метасимволов регулярного выражения в строке, которую вы хотите использовать для шаблона. Просто заключайте в кавычки все символы, не являющиеся словами:</target>
        </trans-unit>
        <trans-unit id="a9e4564a4cffc22857c4489a19486bf89ae25eff" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;. Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\(&lt;/code&gt;, &lt;code&gt;\)&lt;/code&gt;, &lt;code&gt;\[&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, &lt;code&gt;\{&lt;/code&gt;, or &lt;code&gt;\}&lt;/code&gt; is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">В аргументах командной строки используется обратная косая черта &lt;code&gt;()&lt;/code&gt; . Не обрабатывает рекурсивные конструкции Makefile &lt;code&gt;$(...)&lt;/code&gt; , но обрабатывает простые.</target>
        </trans-unit>
        <trans-unit id="a44d458ea8adc4ce2457e80d59480bf2444b0e2c" translate="yes" xml:space="preserve">
          <source>Backticks</source>
          <target state="translated">Backticks</target>
        </trans-unit>
        <trans-unit id="cada2d153702b188c804c9ed93a320132370a768" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">Обратные кавычки &lt;code&gt;``&lt;/code&gt; (см. &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;Операторы ввода-вывода в perlop&lt;/a&gt; ) с командой, содержащей метасимволы перенаправления или оболочки;</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">Обратные кавычки создают подпроцесс и передают ему заключенную строку для выполнения как DCL-команду. Поскольку подпроцесс создается напрямую через &lt;code&gt;lib$spawn()&lt;/code&gt; , можно указать любую допустимую командную строку DCL.</target>
        </trans-unit>
        <trans-unit id="93a46463866e4337a557918eb7f92cb737fcdb4d" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">Управляющие глаголы обратного хода</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">Отслеживание во время беспощадного поиска матча может быть пустой тратой времени,особенно когда матч будет неудачным.Рассмотрим простой шаблон</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">Поиск с возвратом более эффективен, чем повторные попытки с разными регулярными выражениями. Если существует несколько регулярных выражений и соответствие любому из них допустимо, то их можно объединить в набор альтернатив. Если отдельные выражения являются входными данными, это можно сделать, запрограммировав операцию соединения. Мы будем использовать эту идею в улучшенной версии программы &lt;code&gt;simple_grep&lt;/code&gt; : программы, которая соответствует нескольким шаблонам:</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">Обратная совместимость</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">Обратная совместимость</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">обратно совместимая шаблонная плита</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">Обратная совместимость</target>
        </trans-unit>
        <trans-unit id="7d01557ea44942b942393d66060697fec065318a" translate="yes" xml:space="preserve">
          <source>Bad arg length for %s, is %u, should be %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165656139a26613694c64dbf201f062c5151055a" translate="yes" xml:space="preserve">
          <source>Bad color mapping %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ab08a2349cea719fd65e95a92efa2f68979a67" translate="yes" xml:space="preserve">
          <source>Bad escape sequence %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e53bd47a32a9c5ca5b26c7f73e5af6cefd27e1" translate="yes" xml:space="preserve">
          <source>Bad evalled substitution pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">Плохой пример:</target>
        </trans-unit>
        <trans-unit id="6b1ede25e2d280b57ab0ce582f6faf1b35cf90a7" translate="yes" xml:space="preserve">
          <source>Bad exit or wait status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390acb944960513fda956a00da4e57aecfbdc40d" translate="yes" xml:space="preserve">
          <source>Bad filehandle: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2545bb8b8757d12600ee0fd7c8d21fd5ad24ec74" translate="yes" xml:space="preserve">
          <source>Bad free() ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d801fbd5f10bc4ae72d676efa25b3f102ac7bc5e" translate="yes" xml:space="preserve">
          <source>Bad hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e025cf017a8d1ec1929f0fe963368b8537306db" translate="yes" xml:space="preserve">
          <source>Bad name after %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9adf2eb1c251e659c032b900434bcbefd880c7" translate="yes" xml:space="preserve">
          <source>Bad plugin affecting keyword '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec81356ab8541823884a0a82a618613aa9cbd7b4" translate="yes" xml:space="preserve">
          <source>Bad realloc() ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da31fb3200e756607d3e2e50254f7cea20fa96d" translate="yes" xml:space="preserve">
          <source>Bad subroutine name for Fatal: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42447de9c1418f0e2c311d00634195d77eb4c7e0" translate="yes" xml:space="preserve">
          <source>Bad symbol for array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65b92f2abbe5aa53ce089c4d6d379ebd454bfc3" translate="yes" xml:space="preserve">
          <source>Bad symbol for dirhandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66844a23804f5fa9fb3dbb57550acc9e7e5e7dd" translate="yes" xml:space="preserve">
          <source>Bad symbol for filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f407c0868b2e3ed85e66aedb4e0f3e18c18e11" translate="yes" xml:space="preserve">
          <source>Bad symbol for hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cf554f79f8dc5600aa8436990c34983c96cb70" translate="yes" xml:space="preserve">
          <source>Bad symbol for scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bd2e42ef1c41d1f7a37013a433505cff6f0d53" translate="yes" xml:space="preserve">
          <source>Badly placed ()'s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f60e950209318c3cca05ba1dcb8123b97e1b18f" translate="yes" xml:space="preserve">
          <source>Bailout</source>
          <target state="translated">Bailout</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">Жетон результата спасения.</target>
        </trans-unit>
        <trans-unit id="2e1aced5d91a77947ec0c1e15905db2c6dabdd2d" translate="yes" xml:space="preserve">
          <source>Bailout!</source>
          <target state="translated">Bailout!</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Балаж Сабо (dLux), dlux@kapu.hu</target>
        </trans-unit>
        <trans-unit id="fa6c3752cd00f7f1277fd7e5604ab8d2edaf26b8" translate="yes" xml:space="preserve">
          <source>Bangladesh</source>
          <target state="translated">Bangladesh</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="38e31cd750cd9c5c8abfa83e3cc07bbe5eb34dbc" translate="yes" xml:space="preserve">
          <source>Bare here-document terminators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2f9eceeee98d7bac9099dfb477548bd0d00fe3" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; not allowed while &quot;strict subs&quot; in use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74184baa622016b052c2c66c26dc81d35681d05a" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; refers to nonexistent package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f9425456098bc5db3b65fe0b670ee4dc328cf5" translate="yes" xml:space="preserve">
          <source>Bareword found in conditional</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c6c09ca8e54434a9e30a3ee7363deeca4c4687" translate="yes" xml:space="preserve">
          <source>Bareword in require contains &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99617bf4b7525e79f27dc14c638f75b9b86decd2" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to disallowed filename &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e217673de1982c957abdb450217720b611015045" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to empty filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b08d7d96976813240018e31332af5b98b35fa0d" translate="yes" xml:space="preserve">
          <source>Bareword in require must not start with a double-colon: &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">Голые слова не покрываются перегруженными строковыми константами.</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">Базовый класс для IO::Компрессорные модули</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">Базовый класс для модулей ввода-вывода::Некомпрессионные модули</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">Базовые конструкции</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">Определения базового класса для связанных ручек</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">Определения базового класса для связанных хешей</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">Определения базового класса для связанных скаляров</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">Базовый класс для ВСЕХ классов (благословенные ссылки)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">Базовый класс для расширений оболочки CPAN</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">Базовый класс для ExtUtils::Постоянные объекты</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">Базовый класс для итераторов источника TAP</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">Базовый класс для TAP::Объекты вывода парсера</target>
        </trans-unit>
        <trans-unit id="a0880f8d682b9138475bd47a938947c12338445c" translate="yes" xml:space="preserve">
          <source>Base class for Test2 IPC drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cde81f5a0639d96966be94bffabdcc2cee72d19" translate="yes" xml:space="preserve">
          <source>Base class for all event facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab0f65808322aafffdf4f4c4569b0ca559cecd" translate="yes" xml:space="preserve">
          <source>Base class for all event objects that get passed through &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">Базовый класс для создания фильтров POD и трансляторов</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">Базовый класс для различных обработчиков TAP источников</target>
        </trans-unit>
        <trans-unit id="6d6b96a9e4df11d307d7125ce342fa82d8eb0fc3" translate="yes" xml:space="preserve">
          <source>Base class for events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">Базовый класс для делегатов по выходу на жгут</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">Базовый класс для тестовых модулей</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">Базовый класс для привязанных массивов</target>
        </trans-unit>
        <trans-unit id="4c8eae847ee205298317c9b96e374f69e5e9feb1" translate="yes" xml:space="preserve">
          <source>Base class package &quot;%s&quot; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5134fdf6155e7a9843c83a26849d1aff846f4d88" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">Базовый класс, обеспечивающий общие функции &lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parser&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">Базовый класс, обеспечивающий общие функции для всех модулей &lt;code&gt;TAP::*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">База для форматоров Pod::Perldoc</target>
        </trans-unit>
        <trans-unit id="bf06e03b88934d434a87ce7787240b8e99aae0b0" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">На основе &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;класса&lt;/a&gt; Стевана Литтла :: C3</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;Pod :: Text :: pod2text (),&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;Pod :: Text :: pod2text (1),&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;Pod :: Текст,&lt;/b&gt; написанный Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;pod2text (1),&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">На основе кода для &lt;b&gt;pod2text,&lt;/b&gt; написанного Томом Кристиансеном &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">На основе кода,написанного Сигио Ямагути.</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">На основе примера,который был изначально добавлен в MIME::QuotedPrint.pm для дистрибутива 5.8.0 для Perl.</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">На основе идей Тима &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;lt; Tim.Bunce@ig.co.uk &amp;gt; и</target>
        </trans-unit>
        <trans-unit id="01bb16997fde52e47c429c6fd628c8c4ddf3054c" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt;&amp;gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">На основе слоя &lt;code&gt;:perlio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">На основе &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; Ларри Уолла и Perl 5 Porters, который был выпущен на тех же условиях лицензии.</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">На основании Глоссария</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">На основе кода xsubpp,написанного Ларри Уоллом.</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">Базовые БЛОКИРОВКИ</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">Основные операции ввода-вывода</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">Базовая многоязычная плоскость</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">Базовая структура</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">Поддержка основных потоков</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">Базовые утилиты для программистов</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">Основные команды:</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">Основные методы</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">Основная операция чтения.</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">Основные семафоры</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">Обзор синтаксиса на основных языках</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">Основные утилиты для написания тестов.</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">Основная операция записи.</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">В основном,процессоры Intel и VAX являются little-endian,в то время как все остальные,включая Motorola m68k/88k,PPC,Sparc,HP PA,Power и Cray,являются big-endian.Альфа и MIPS тоже могут быть:Digital/Compaq использует (хорошо,используется)их в режиме little-endian,но SGI/Cray использует их в режиме big-endian.</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">В основном,вы получаете индивидуальные результаты из TAP.Шесть типов с примерами каждого из них следующие:</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4beb8f757ba4e13e29ffb8c6a2d654b5eee3dc8e" translate="yes" xml:space="preserve">
          <source>Baud rate values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">Имейте в виду два важных момента:</target>
        </trans-unit>
        <trans-unit id="9042cbc9bb8a8748d18e82d265eee86b54008013" translate="yes" xml:space="preserve">
          <source>Be aware that all exceptions are stringified during construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">Имейте в виду,что все имена,возвращенные из файла::Glob,испорчены.</target>
        </trans-unit>
        <trans-unit id="3297ac638d07f74b1cf62949925d4b3e23422ec7" translate="yes" xml:space="preserve">
          <source>Be aware that many files in the distribution are derivative--avoid patching them, because git won't see the changes to them, and the build process will overwrite them. Patch the originals instead. Most utilities (like perldoc) are in this category, i.e. patch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">Имейте в виду , что установка &lt;code&gt;@DB::args&lt;/code&gt; является</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">Имейте в виду,что подпрограммы дайджеста бесшумно преобразуют вход UTF-8 в эквивалентную ему последовательность байт в родной кодировке (ср.utf8::downgrade).Этот побочный эффект влияет только на то,как Perl хранит данные внутри себя,но в остальном оставляет фактическое значение данных нетронутым.</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">Имейте в виду,что тип/создатель и ресурсная развилка файла будут потеряны,что обычно и требуется в кроссплатформенных архивах.</target>
        </trans-unit>
        <trans-unit id="64b3ff265c6f33aa278b5fc7ab5adbd6a628d376" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">Имейте в виду, что главная ценность этого модуля - его простота. Обратите внимание, что уже существуют более амбициозные модули, такие как &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f073a8ab4396a4ea1a82c329831db3a4c81e7bb9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; had a chance to get the information. That means that &lt;code&gt;caller(N)&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt;. In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">Имейте в виду, что оптимизатор мог оптимизировать кадры вызова до того, как &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; получил возможность получить информацию. Это означает, что &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; может не вернуть информацию о ожидаемом кадре вызова при &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . В частности, &lt;code&gt;@DB::args&lt;/code&gt; может содержать информацию о предыдущем вызове &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">Имейте в виду, что оптимизатор мог оптимизировать кадры вызова до того, как &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; получил возможность получить информацию. Это означает, что &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; может не вернуть информацию о ожидаемом кадре вызова при &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . В частности, &lt;code&gt;@DB::args&lt;/code&gt; может содержать информацию о предыдущем вызове &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">Имейте в виду, что переход по символическим ссылкам может быть опасным. В зависимости от структуры дерева каталогов (включая символические ссылки на каталоги) вы можете пройти по заданному (физическому) каталогу более одного раза (только если &lt;code&gt;follow_fast&lt;/code&gt; ). Более того, удаление или изменение файлов в символически связанном каталоге может вызвать очень неприятные сюрпризы, поскольку вы удаляете или изменяете файлы в неизвестном каталоге.</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">Имейте в виду,что эти операции являются полными вилками Unix,что означает,что они могут быть неправильно реализованы на всех инопланетных системах.</target>
        </trans-unit>
        <trans-unit id="edbf362a8476b23d76d24466d122396a40549047" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems. See &lt;a href=&quot;perlport#open&quot;&gt;&quot;open&quot; in perlport&lt;/a&gt; for portability details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4c04a6ec8f48645b28a87376c9f6999c39b61b" translate="yes" xml:space="preserve">
          <source>Be aware that this option makes you accept invalid JSON texts as if they were valid!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9573a203063d54f5dc27408bed7844c1be7ddce6" translate="yes" xml:space="preserve">
          <source>Be aware that this will export ANSI_COLORS_DISABLED to any child processes of your program as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9011ae4d69e158b2d5d9fa7d3f0fa4181ed416ab" translate="yes" xml:space="preserve">
          <source>Be aware that writing a multi-threaded application will not be portable to a platform which lacks the native thread-safe locale support. On systems that do have it, you automatically get this behavior for threaded perls, without having to do anything. If for some reason, you don't want to use this capability (perhaps the POSIX 2008 support is buggy on your system), you can manually compile Perl to use the old non-thread-safe implementation by passing the argument &lt;code&gt;-Accflags='-DNO_THREAD_SAFE_LOCALE'&lt;/code&gt; to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">Имейте в виду, что при использовании этой опции входная кодировка вашего источника POD должна быть правильно объявлена, если это не US-ASCII или Latin-1. Предполагается, что ввод POD без команды &lt;code&gt;=encoding&lt;/code&gt; находится в Latin-1, а если он действительно в UTF-8, вывод будет дважды закодирован. Видеть</target>
        </trans-unit>
        <trans-unit id="112ebc66d2bbad303aae87da4af1076cd40b1dbe" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will produce warnings. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14539a0200a018d8bfd0c01f3ce67edac22b2e5e" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2man&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b528c0888545102ae09966c077f548f42a0a07e8" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2text&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">Более того,имейте в виду,что даже среди Unix-систем есть вариации.</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">Будь осторожен с синтаксисом,</target>
        </trans-unit>
        <trans-unit id="f8fdb4158175acb38dcf577960ceb71bd1d96eb9" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt;&lt;code&gt;formline&lt;/code&gt;&lt;/a&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">Будьте осторожны, если вы заключите изображение в двойные кавычки, потому что символ &lt;code&gt;@&lt;/code&gt; может означать начало имени массива. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; всегда возвращает true. См. Другие примеры в &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">Будьте осторожны, если вы заключите изображение в двойные кавычки, потому что символ &lt;code&gt;@&lt;/code&gt; может означать начало имени массива. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; всегда возвращает true. См. Другие примеры в &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4aaaf54937dcd1947fa04a848c937575a75bb3aa" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; after a failed system call. Using &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; for anything else than displaying it as output is doubtful (though see the &lt;a href=&quot;errno&quot;&gt;&lt;code&gt;Errno&lt;/code&gt;&lt;/a&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">Будьте осторожны с тестами, которые вы поставляете с вашим модулем или программами. Код модуля может быть полностью переносимым, но его тесты - нет. Это часто происходит, когда тесты порождаются другими процессами или вызывают внешние программы для помощи в тестировании, или когда (как указано выше) тесты предполагают определенные вещи о файловой системе и путях. Будьте осторожны, чтобы не зависеть от конкретного стиля вывода ошибок, например, при проверке &lt;code&gt;$!&lt;/code&gt; после неудачного системного вызова. Используя &lt;code&gt;$!&lt;/code&gt; для чего-либо другого, кроме отображения его в качестве вывода, сомнительно (хотя см. модуль &lt;code&gt;Errno&lt;/code&gt; для тестирования разумной переносимости для значения ошибки). Некоторые платформы ожидают определенного формата вывода, и Perl на этих платформах мог быть соответствующим образом скорректирован. В частности, не привязывайте регулярное выражение при проверке значения ошибки.</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">Будьте осторожны,чтобы проверить,что то,что вы передаете в chdir(),определено и не пусто,иначе вы можете оказаться в вашем домашнем каталоге.</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">Будьте внимательны при проверке возвращаемых значений как из функции open(),так и из функции close().Если вы</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">Будьте осторожны,повторяйте эту процедуру каждый раз,когда перекомпилируете расширение,если только вы не уверены,что установочные каталоги AFS все еще действительны.</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">Будьте осторожны при использовании шаблона сброса ветви в сочетании с именованными захватами.Именованные захваты реализуются в виде псевдонимов пронумерованных групп,удерживающих захваты,что препятствует реализации шаблона сброса ветви.Если вы используете именованные захваты в шаблоне сброса ответвления,то лучше всего использовать одинаковые имена,в том же порядке,в каждом из изменений:</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">Но будьте осторожны,никогда не комбинируйте текстовые строки с двоичными.Если вам нужен текст в двоичном потоке,кодируйте сначала свои текстовые строки в соответствующей кодировке,а затем соединяйте их с двоичными строками.См.также:&quot;Что,если я не кодирую?&quot;.</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">Будьте осторожны:qx(),system(),и некоторые модули для вызова внешних команд делают fork(),затем ждут результата.Таким образом,будет вызван обработчик вашего сигнала.Так как функция wait()уже вызывалась system()или qx(),то функция wait()в обработчике сигнала больше не будет видеть зомби и поэтому будет блокироваться.</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">Соответствовать существующим модулям.</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">Будь последователен.</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">Будьте описательны (т.е.точно опишите назначение модуля).</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">Будь то &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; или любое расширение, которое не упоминает Unicode в справочной странице, вам необходимо убедиться, что флаг UTF8 отключен. Обратите внимание, что на момент написания этой статьи (январь 2012 г.) упомянутые модули не поддерживают UTF-8. Пожалуйста, проверьте документацию, чтобы убедиться, что это все еще правда.</target>
        </trans-unit>
        <trans-unit id="9583b4e268c09c5404dc953e2a7280e9a611066c" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt;, &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">Будь вежлив.</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">Не используйте пустое слово в качестве имени обработчика сигналов,чтобы случайно его не назвать.</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">Убедитесь,что ваш yacc установлен,включая все необходимые файлы шаблонов парсера.Если вы еще этого не сделали,убедитесь в этом:</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">Не забудьте адекватно прокомментировать свой код.Хотя комментировать каждую строку не нужно,все,что использует побочные эффекты операторов,что создает изменения,которые будут ощущаться за пределами исправляемой функции,или что другие могут найти путаницу,должно быть задокументировано.Если вы собираетесь ошибаться,лучше ошибиться,добавив слишком много комментариев,чем слишком мало.</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">Не забудьте указать &lt;b&gt;точные&lt;/b&gt; сообщения об ошибках, если таковые имеются. &amp;laquo;Perl выдал ошибку&amp;raquo; не является точным сообщением об ошибке.</target>
        </trans-unit>
        <trans-unit id="fb3f786d0833cb9684920951669ea14a5f8c452b" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;&quot;ENCODING&quot;&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">Обязательно прочтите &lt;a href=&quot;#ENCODING&quot;&gt;КОДИРОВАНИЕ,&lt;/a&gt; если ваш Pod содержит символы, отличные от ASCII.</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">Внимательно ознакомьтесь с инструкциями,расположенными в верхней части макияжа.</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Обязательно укажите требования к версии Perl как в Makefile.PL или Build.PL, так и в &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; или аналогичном. См. Подробности в разделе, посвященном &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="395569931cbd630cae76e8ec72604be440821c6b" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;require 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;use VERSION&lt;/code&gt; of &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">Для извлечения файла perl-5.x.x.x.tar.gz обязательно используйте программу tar,скомпилированную под Solaris (а не под SunOS 4.x).Не используйте GNU tar,скомпилированный под SunOS4 на Solaris.(GNU tar,скомпилированный для Solaris,должен быть в порядке.)Когда вы запускаете исполняемые файлы SunOS4 на Solaris,система запуска волшебным образом изменяет патнамы,соответствующие m#lib/locale#,так что когда tar пытается создать lib/locale.pm,вместо него создается файл с именем lib/oldlocale.pm.Если вы нашли эту рекомендацию слишком поздно и все равно использовали tar,скомпилированный в SunOS4,вы должны найти неверно переименованный файл и перенести его обратно на lib/locale.pm.</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">Обязательно используйте библиотеки и модули,поставляемые с тестируемой версией,а не те,которые уже были установлены.</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">Будьте очень осторожны с операциями Perl,которые изменяют значение переменной.Добавление чего-либо к переменной,например,может потребовать перераспределения ее хранения,оставив вам указатель в чужой земле.</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">Предупреждаем,что ни создание,ни удаление файлов не гарантируется как атомарная операция над NFS.То есть два процесса могут успешно создать или удалить один и тот же файл! Поэтому O_EXCL не является таким эксклюзивным,как вы могли бы пожелать.</target>
        </trans-unit>
        <trans-unit id="15b58e5a1a4863b537d4c8fb01a3a9bfffd23c29" translate="yes" xml:space="preserve">
          <source>Be warned that proxying an &lt;code&gt;https&lt;/code&gt; connection opens you to the risk of a man-in-the-middle attack by the proxy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">Предупреждаем,что некоторые форматоры не могут надежно отображать символы за пределами 32-126;и многие из них способны обрабатывать 32-126 и 160-255,но не более 255.</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">Предупреждаем,что эта функция считается экспериментальной и может быть изменена без предварительного уведомления.</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">Однако &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; виду, что в отличие от регулярных выражений, если шаблон распаковки не соответствует входящим данным, Perl закричит и умрет.</target>
        </trans-unit>
        <trans-unit id="02d6d74dc9a4db2057c5683472b9fbbb7012f2b3" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;unpack&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">Предупреждаю:так же как C-препроцессор не знает C,фильтр отладки не знает Perl.Его легко обмануть:</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOS-это BeOS.</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">Поскольку &quot;perlio.h&quot; является тонким слоем (для эффективности),семантика этих функций в некоторой степени зависит от базовой реализации.Там,где эти вариации понимаются,они отмечены ниже.</target>
        </trans-unit>
        <trans-unit id="370f88e98782bfa7f114dbe532b100225210e150" translate="yes" xml:space="preserve">
          <source>Because 1 + 1 is 2, it prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e172ead13ccd2d2e8aa5c2a8960bb8d1e75406d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#scalar-EXPR&quot;&gt;&lt;code&gt;scalar&lt;/code&gt;&lt;/a&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b453ad82fa85092fb1368c3fb85257f0cedd1e" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddac942d8eb120d517202681a1ab56648b51a75" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is a global variable, be careful that analyzing an exception caught by &lt;code&gt;eval&lt;/code&gt; doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">Поскольку &lt;b&gt;perldoc&lt;/b&gt; не запускается должным образом и, как известно, имеет проблемы с безопасностью, при запуске от имени суперпользователя он попытается сбросить привилегии, установив эффективные и реальные идентификаторы для чьей-либо учетной записи или учетной записи пользователя, или -2, если недоступен. Если он не может отказаться от своих привилегий, он не будет работать.</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">Поскольку интерполяция триггера &lt;code&gt;$&lt;/code&gt; или &lt;code&gt;@&lt;/code&gt; , вам нужно будет использовать что-то вроде &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; чтобы сопоставить их буквально.</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">Поскольку &lt;code&gt;$sv&lt;/code&gt; имеет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; когда к нему применяется оператор &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; , транслитерация фактически не выполняется, и программа не &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Это отличается от поведения 5.8 и более ранних версий, поскольку тогда переменные захвата были переменными ТОЛЬКО ДЛЯ ЧТЕНИЯ; теперь они просто умрут, когда назначены в движке по умолчанию.</target>
        </trans-unit>
        <trans-unit id="6c984d748d72c5bb3b2196996f098ba27134cde9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; when the &lt;code&gt;y///&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;die&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b914e32b809fa7c48d9ec627188d82ebed09a33b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt;. The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt;s from the input list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">Поскольку &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если любой из операндов имеет значение &lt;code&gt;NaN&lt;/code&gt; (не число), будьте осторожны при сортировке с помощью функции сравнения, такой как &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; любых списков, которые могут содержать &lt;code&gt;NaN&lt;/code&gt; . В следующем примере используется &lt;code&gt;NaN != NaN&lt;/code&gt; для исключения любых &lt;code&gt;NaN&lt;/code&gt; из входного списка.</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">Поскольку &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если любой из операндов имеет значение &lt;code&gt;NaN&lt;/code&gt; (не число), будьте осторожны при сортировке с помощью функции сравнения, такой как &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; любых списков, которые могут содержать &lt;code&gt;NaN&lt;/code&gt; . В следующем примере используется &lt;code&gt;NaN != NaN&lt;/code&gt; для исключения любых &lt;code&gt;NaN&lt;/code&gt; из входного списка.</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">Потому что &lt;code&gt;.&lt;/code&gt; является специальным в регулярных выражениях и может соответствовать любому одиночному символу, регулярное выражение &lt;code&gt;P.&lt;/code&gt; здесь соответствует &amp;lt;Pl&amp;gt; в исходной строке.</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">Потому что &lt;code&gt;.&lt;/code&gt; использовался в качестве разделителя каталогов, и имена файлов не могли считаться уникальными после 10 символов, Acorn реализовал компилятор C для удаления конечных суффиксов &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; и &lt;code&gt;.o&lt;/code&gt; из имен файлов, указанных в исходном коде, и сохранения соответствующих файлов в подкаталогах, названных по суффиксу. Следовательно файлы переводятся:</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; - это оператор времени выполнения, он выполняется каждый раз в цикле. Следовательно, более эффективно локализовать переменные вне цикла.</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; является унарным оператором, если вы случайно используете список в скобках для EXPR, это ведет себя как выражение скалярной запятой, оценивая все элементы, кроме последнего, в пустом контексте и возвращая последний элемент, оцененный в скалярном контексте. Это редко то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вступает в силу во время компиляции, оно не соблюдает обычное управление потоком компилируемого кода. В частности, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; внутри ложной ветви условного выражения не препятствует его обработке. Если модуль или прагму нужно загрузить только условно, это можно сделать с помощью прагмы &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; является унарным оператором, если вы случайно используете список в скобках для EXPR, это ведет себя как выражение скалярной запятой, оценивая все элементы, кроме последнего, в пустом контексте и возвращая последний элемент, оцененный в скалярном контексте. Это редко то, что вам нужно.</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; вступает в силу во время компиляции, оно не соблюдает обычное управление потоком компилируемого кода. В частности, &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; внутри ложной ветви условного выражения не препятствует его обработке. Если модуль или прагму нужно загрузить только условно, это можно сделать с помощью прагмы &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3f563a9178b31c7b0b34b9e11ab4a6bde66fbd45" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global status variables that might be set by anything you do in your &lt;code&gt;DESTROY&lt;/code&gt; method. If you are in doubt about a particular status variable, it doesn't hurt to localize it. There are five global status variables, and the safest way is to localize all five of them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">Поскольку методы &lt;code&gt;DESTROY&lt;/code&gt; могут быть вызваны в любое время, вам следует локализовать любые глобальные переменные, которые вы можете обновить в своем &lt;code&gt;DESTROY&lt;/code&gt; . В частности, если вы используете &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , вам следует локализовать &lt;code&gt;$@&lt;/code&gt; , а если вы используете &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; или обратные кавычки, вы должны локализовать &lt;code&gt;$?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">Поскольку &lt;code&gt;PERL5LIB&lt;/code&gt; часто используется во время тестирования для добавления каталогов сборки в &lt;code&gt;@INC&lt;/code&gt; , доказывается, что имена любых каталогов, найденных в &lt;code&gt;PERL5LIB&lt;/code&gt; ,передаются в качестве ключей -I. &lt;code&gt;PERL5LIB&lt;/code&gt; результатом этого является то, что PERL5LIB соблюдается, даже когда доказательство выполняется в режиме заражения.</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">Поскольку &lt;code&gt;PERL5LIB&lt;/code&gt; часто используется во время тестирования для добавления каталогов сборки в &lt;code&gt;@INC&lt;/code&gt; , &lt;code&gt;Test::Harness&lt;/code&gt; передает имена любых каталогов, найденных в &lt;code&gt;PERL5LIB&lt;/code&gt; , как переключатели -I. &lt;code&gt;PERL5LIB&lt;/code&gt; результатом этого является то, что PERL5LIB соблюдается даже в режиме заражения.</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">Поскольку &lt;code&gt;PL_restartop&lt;/code&gt; не равен нулю, &lt;code&gt;run_body&lt;/code&gt; запускает новый цикл runops и выполнение продолжается.</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">Поскольку &lt;code&gt;STORABLE_attach&lt;/code&gt; передается классу (а не объекту), он также возвращает объект напрямую, а не изменяет переданный объект.</target>
        </trans-unit>
        <trans-unit id="65e2bf1b173528f8a073f03b46510698c20426ce" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;local&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Поскольку Acorns использует ASCII с новой строкой ( &lt;code&gt;\n&lt;/code&gt; ) в текстовых файлах как &lt;code&gt;\012&lt;/code&gt; как в Unix, и поскольку эмуляция имени файла в Unix включена по умолчанию, большинство простых сценариев, вероятно, будут работать &amp;laquo;из коробки&amp;raquo;. Собственная файловая система является модульной, и отдельные файловые системы могут быть чувствительны к регистру или нечувствительны, и обычно с сохранением регистра. Некоторые собственные файловые системы имеют ограничения на длину имен, при этом имена файлов и каталогов автоматически усекаются, чтобы соответствовать. Сценарии должны знать, что стандартная файловая система в настоящее время имеет ограничение на длину имени в &lt;b&gt;10&lt;/b&gt; символов и до 77 элементов в каталоге, но другие файловые системы могут не накладывать таких ограничений.</target>
        </trans-unit>
        <trans-unit id="28c382ede78c908c2143af19dbf455bab6188b9c" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt;) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">Поскольку в Си нет встроенной функции для целочисленного выражения,давайте сделаем оператор Perl's **доступным для него (это менее полезно,чем кажется,потому что Perl реализует **с помощью C's</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Поскольку Perl позволяет вам использовать голые слова для имен пакетов и имен подпрограмм, он иногда неправильно интерпретирует их значение. Например, конструкция &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; может интерпретироваться как &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; или как &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . На английском языке эта вторая интерпретация читается как &amp;laquo;вызвать подпрограмму с именем Class (), затем вызвать new () как метод для возвращаемого значения Class ()&amp;raquo;. Если в текущем пространстве имен есть подпрограмма с именем &lt;code&gt;Class()&lt;/code&gt; , Perl всегда будет интерпретировать &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; как вторую альтернативу: вызов &lt;code&gt;new()&lt;/code&gt; для объекта, возвращенного вызовом &lt;code&gt;Class()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0ebaa0b26d8e2869e78f420c4e273d09ec93726" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt;. In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Поскольку Perl преобразует сообщения о неперехваченных исключениях перед отображением, вы, вероятно, захотите перегрузить операции строкового преобразования для объектов исключений. Подробнее об этом см. &lt;a href=&quot;../overload&quot;&gt;Перегрузка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Поскольку Perl преобразует сообщения о неперехваченных исключениях перед отображением, вы, вероятно, захотите перегрузить операции строкового преобразования для объектов исключений. Подробнее об этом см. &lt;a href=&quot;overload&quot;&gt;Перегрузка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="451d2525676f60927dbbc662f71037a75004b879" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that. The stringified message should be non-empty, and should end in a newline, in order to fit in with the treatment of string exceptions. Also, because an exception object reference cannot be stringified without destroying it, Perl doesn't attempt to append location or other information to a reference exception. If you want location information with a complex exception object, you'll have to arrange to put the location information into the object yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">Поскольку Perl использует внутри себя числа типа double (или long double, если настроено) для всех числовых вычислений, преобразование из double в float, а затем в double снова теряет точность, поэтому &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ) не будет в общем равно $ foo.</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">Поскольку UTF-8 является одним из внутренних форматов Perl,часто можно просто пропустить шаг кодирования или декодирования и напрямую манипулировать флагом UTF8.</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">Поскольку UTF-EBCDIC очень похож на UTF-8, различия в основном скрыты от вас; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (а НЕ что-то вроде &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) объявляет, что сценарий находится в &amp;laquo;родной&amp;raquo; 8-битной кодировке Unicode платформы. (Аналогично для слоя &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="f78470b23c3e4057a6f3bfa3fb579763a7c89c67" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;use utf8&lt;/code&gt; (and NOT something like &lt;code&gt;use utfebcdic&lt;/code&gt;) declares the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">Потому что коды выхода VMS очень,очень отличаются от остальных частей вселенной,и Perl делает ужасные калечащие их,которые попадаются на моем пути,он работает так на VMS.</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">Поскольку модули XS требуют перекомпоновки бинарного файла perl,для сборки модуля расширения XS вам понадобится как бинарное распределение perl,так и распределение исходных текстов perl.Кроме того,вам нужно будет собрать двоичный файл perl из дистрибутива исходных текстов таким образом,чтобы все компоненты двоичного файла perl были доступны на требуемом этапе компоновки.</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Поскольку неудачное совпадение &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; не сбрасывает смещение, возврат из &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; также не изменится в этом случае. См. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; и &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Поскольку неудачное совпадение &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; не сбрасывает смещение, возврат из &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; также не изменится в этом случае. См. &lt;a href=&quot;../perlre&quot;&gt;Perlre&lt;/a&gt; и &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7ae901f4727ecaa2d777b8bd8dde60ff479daae" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;m//gc&lt;/code&gt; match doesn't reset the offset, the return from &lt;a href=&quot;#pos-SCALAR&quot;&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/a&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">Поскольку список потенциальных кандидатов вернулись, в &lt;code&gt;while&lt;/code&gt; цикл пытается каждый , в свою очередь , пока не найдет ту , которая преуспевает как сокет () и Connect () звонки.</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">Поскольку в будущих выпусках Unicode может быть добавлено исправление имени, имя, &lt;code&gt;viacode&lt;/code&gt; возвращает viacode, может в результате измениться. Это редкое событие, но оно случается.</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">Поскольку точка является метасимволом, ее необходимо экранировать, чтобы она соответствовала обычной точке. Так как, например, &lt;code&gt;\d&lt;/code&gt; и &lt;code&gt;\w&lt;/code&gt; являются наборами символов, неправильно думать о &lt;code&gt;[^\d\w]&lt;/code&gt; как о &lt;code&gt;[\D\W]&lt;/code&gt; ; на самом деле &lt;code&gt;[^\d\w]&lt;/code&gt; то же самое, что &lt;code&gt;[^\w]&lt;/code&gt; , что то же самое, что и &lt;code&gt;[\W]&lt;/code&gt; . Подумайте о законах ДеМоргана.</target>
        </trans-unit>
        <trans-unit id="7b8b1120df9a594afd2813233aa665ec7f417ba1" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt;; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt;. Think DeMorgan's laws.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df556755141c60db4ee1a86c658450735dbe881" translate="yes" xml:space="preserve">
          <source>Because a url like &lt;code&gt;http://myrepo.example.com/&lt;/code&gt; is ambiguous as to type, producers should provide a &lt;code&gt;type&lt;/code&gt; whenever a &lt;code&gt;url&lt;/code&gt; key is given. The &lt;code&gt;type&lt;/code&gt; field should be the name of the most common program used to work with the repository, e.g. &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;svn&lt;/code&gt;, &lt;code&gt;cvs&lt;/code&gt;, &lt;code&gt;darcs&lt;/code&gt;, &lt;code&gt;bzr&lt;/code&gt; or &lt;code&gt;hg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">Поскольку access () не вызывает stat () (по крайней мере, не видимым для Perl способом), &lt;b&gt;кэш результатов stat &quot;_&quot; не установлен&lt;/b&gt; . Это означает, что результаты следующих двух тестов различаются. Первый имеет биты статистики</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">Поскольку назначение ссылки на печатный шрифт создает псевдоним,это может быть использовано для создания того,что фактически является локальной функцией или,по крайней мере,локальным псевдонимом.</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">Поскольку обратные ссылки не влияют на стандартную ошибку,используйте синтаксис дескрипторов файлов оболочки (предполагая,что оболочка поддерживает это),если вы хотите решить эту проблему.Для захвата STDERR и STDOUT команды вместе:</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">Так как CRLF и LF заканчиваются в LF,сепаратор входной записи может быть установлен в LF и любая CR снимается позже.Лучше писать:</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">Поскольку фигурные скобки (фигурные скобки) используются для нескольких других вещей, включая БЛОКИ, иногда вам может потребоваться устранять неоднозначность фигурных скобок в начале оператора, помещая &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; вперед, чтобы Perl понимал, что открывающая фигурная скобка не запускает БЛОК . Экономия и мнемоническая ценность использования завитушек оправдывают эти периодические дополнительные хлопоты.</target>
        </trans-unit>
        <trans-unit id="06e52ad8990a21a081873c75e0650e648002cb3f" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;return&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">Потому что в зависимости от каталога,чтобы просто убедиться,что он существует,не работает слишком хорошо (измененное время меняется слишком часто)dir_target()создает файл .exists в созданном каталоге.Именно от этого вы должны зависеть.В целях переносимости вы должны использовать макрос $(DIRFILESEP),а не '/',чтобы отделить каталог от файла.</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">Поскольку каждый операнд оценивается в целочисленной форме, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; вернет два элемента в контексте списка.</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">Потому что даже на портах, отличных от Unix, функция glob в Perl следует стандартной семантике подстановки Unix. Вам понадобится &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; чтобы получить все (не скрытые) файлы. Это делает glob () переносимым даже в устаревшие системы. Ваш порт также может включать проприетарные функции подстановки. Подробности смотрите в документации.</target>
        </trans-unit>
        <trans-unit id="4527823ffed4457ee7db37d2aeb7752e646692c1" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;glob(&quot;*&quot;)&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a019fec3551e537f7d797537de86770f8cb583e9" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;a href=&quot;#-Idirectory&quot;&gt;-I&lt;/a&gt; switch could also cause odd results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">Поскольку исторически некоторые операционные системы молча отключили интерпретацию ядра &lt;code&gt;#!&lt;/code&gt; строка после 32 символов, некоторые ключи могут быть переданы в командной строке, а некоторые нет; вы даже можете получить знак &amp;laquo;-&amp;raquo; без буквы, если не будете осторожны. Вы, вероятно, захотите убедиться, что все ваши переключатели упали до или после этой 32-символьной границы. Большинство переключателей на самом деле не заботятся о том, обрабатываются ли они избыточно, но получение &amp;laquo;-&amp;raquo; вместо полного переключателя может привести к тому, что Perl попытается выполнить стандартный ввод вместо вашей программы. И частичный переключатель &lt;b&gt;-I&lt;/b&gt; также может привести к странным результатам.</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">Потому что , если _1 это один, вы получите &amp;laquo;1 документы &lt;b&gt;были&lt;/b&gt; согласованы&amp;raquo;. Приемлемый способ взлома - сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">Поскольку невозможно надежно отличить UTF-8 от собственных 8-битных кодировок, вам понадобится либо отметка порядка байтов в начале исходного кода, либо &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , чтобы проинструктировать perl.</target>
        </trans-unit>
        <trans-unit id="ad4161b2b0cababc93ea492bc495fcb997c97d88" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;use utf8;&lt;/code&gt;, to instruct perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2126d70bfd6541291d6dfdce3ec02ad289bb688a" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, &lt;code&gt;NEXT&lt;/code&gt; has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">Поскольку это модуль,а не неотъемлемая часть интерпретатора,NEXT.pm должен угадать,где был найден окружающий вызов в последовательности поиска метода.При наличии алмазных паттернов наследования он иногда угадывает неправильно.</target>
        </trans-unit>
        <trans-unit id="24e659fa848838e6ef33ca050446877416a84202" translate="yes" xml:space="preserve">
          <source>Because literal conversions also work on empty strings, it may surprise some people:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">Поскольку загрузка в класс &lt;code&gt;IO::Handle&lt;/code&gt; - дорогостоящая операция, вам следует научиться использовать обычные встроенные переменные.</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">Поскольку многие операционные системы разрешают любому, у кого есть доступ для чтения к программному файлу Perl, делать его копию, исправлять копию, а затем выполнять копию, программист Perl, заботящийся о безопасности, должен позаботиться о том, чтобы вызвать установленную копию perl, а не копия ссылается &lt;code&gt;$^X&lt;/code&gt; . Следующие ниже операторы достигают этой цели и создают путь, который можно вызывать как команду или ссылаться как на файл.</target>
        </trans-unit>
        <trans-unit id="dd84b64cdc62e50ad281c65222f1464d48cdcca2" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt;. The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">Поскольку собственные дескрипторы файлов операционной системы являются глобальными и в настоящее время выделяются меньше 255, где 0 является зарезервированным значением, библиотека эмуляции Unix эмулирует дескрипторы файлов Unix. Следовательно, вы не можете полагаться на передачу &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; или &lt;code&gt;STDERR&lt;/code&gt; своим детям.</target>
        </trans-unit>
        <trans-unit id="775710224a556c9491575c5fd5adccb463f6fd25" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">Поскольку объекты в Perl реализованы в виде ссылок,можно иметь и круговые ссылки с объектами.Представьте себе класс TreeNode,в котором каждый узел ссылается на свои родительские и дочерние узлы.Любой узел с родительскими ссылками будет частью круговой ссылки.</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">Из-за смены летнего времени существует много часовых поясов, в которых одно и то же местное время происходит в два разных времени по Гринвичу в один и тот же день. Например, в часовом поясе &quot;Европа / Париж&quot; местное время 2001-10-28 02:30:00 может представлять либо 2001-10-28 00:30:00 GMT, &lt;b&gt;либо&lt;/b&gt; 2001-10-28 01: 30:00 по Гринвичу.</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">Из-за ошибки в perl (# 19213), по крайней мере, в версии 5.6.1, мы должны жестко запрограммировать разделитель путей для требования в Win32, чтобы он был &lt;code&gt;/&lt;/code&gt; , как в Unix, а не в Win32 &lt;code&gt;\&lt;/code&gt; . В противном случае Perl не будет читать свой собственный% INC, точно дважды загружая файлы, если они потребуются снова, или, в худшем случае, дамп ядра.</target>
        </trans-unit>
        <trans-unit id="bddbdae97f197ffe17554a082cd1e7f07c2861e6" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt;. Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">Из-за отсутствия чего-либо лучшего,данный модуль использует свои собственные процедуры для упаковки и распаковки ICMP-пакетов.Лучше написать отдельный модуль,который понимает всевозможные виды ICMP-пакетов.</target>
        </trans-unit>
        <trans-unit id="c6dcc7b169aa07008925e53db149a044f2ea93db" translate="yes" xml:space="preserve">
          <source>Because of all the alias issues, and because in the general case encodings have state, &quot;Encode&quot; uses an encoding object internally once an operation is in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">Из-за всех этих проблем,начиная с версии v5.22,Perl выдаст предупреждение,если используется многобайтовая (отсюда и Юникод)точка кода,когда действует однобайтовая локаль.(Хотя он не проверяет на это,если это приведет к неоправданному замедлению выполнения).</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">Из-за обратной совместимости с унаследованными кодировками,идея &quot;уникального числа для каждого символа&quot; немного ломается:вместо этого есть &quot;по крайней мере,одна цифра для каждого символа&quot;.Один и тот же символ может быть представлен по-разному в нескольких старых кодировках.Обратное не верно:некоторые точки кода не имеют назначенного символа.Во-первых,внутри иначе используемых блоков есть нераспределенные точки кода.Во-вторых,существуют специальные символы управления Unicode,которые не представляют собой истинные символы.</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">Из-за возможности опустить фигурные скобки в простом случае &lt;code&gt;$$x&lt;/code&gt; , люди часто делают ошибку, рассматривая символы разыменования как правильные операторы, и задаются вопросом об их приоритете. Если бы это было так, вы могли бы использовать круглые скобки вместо фигурных скобок. Это не так. Обратите внимание на разницу ниже; case 0 - это сокращенная версия case 1,</target>
        </trans-unit>
        <trans-unit id="e8951f412eada97de516eafdeec177d3c0f76b4b" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt;, people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">Из-за детализации часов время истечения может наступить на одну секунду раньше, чем вы ожидаете. Например, предположим, что вы сохраняете значение со временем жизни в десять секунд, и вы сохраняете его в 12: 00: 00.998 определенного дня. Memoize посмотрит на часы и увидит 12:00:00. Затем через 9,01 секунды, в 12: 00: 10.008 вы пытаетесь прочитать его. Memoize посмотрит на часы, увидит 12:00:10 и сделает вывод, что значение истекло. Вероятно, этого не произойдет, если у вас установлен &lt;code&gt;Time::HiRes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">Из-за идиосинкразии OS/2 нельзя иметь все яйца в одной корзине (хотя среда EMX изо всех сил пытается преодолеть эти ограничения,так что ситуация может как-то улучшить).В дистрибутиве есть 4 исполняемых файла для Perl:</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">Из-за своего глобального эффекта эта настройка не должна использоваться внутри модулей и тому подобное.</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">Из-за наших проблем с родным yacc мы использовали GNU bison,чтобы сгенерировать чистый (=reentrant)парсер для perly.y.Так что наш yacc-это действительно следующий сценарий:</target>
        </trans-unit>
        <trans-unit id="57e65a7490f61f523f42c4deffd151e416a21006" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;-ing to locations you got from &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; (and no others), and you are usually free to use &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; even in &quot;text&quot; mode. Using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; or other file operations may be non-portable. If you use &lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on a file, however, you can usually &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; with arbitrary values safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">Из-за &amp;laquo;текст&amp;raquo; режим перевода, DOSish Перлз имеют ограничения в использовании &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; о файле , доступ в режиме &amp;laquo;текст&amp;raquo;. Придерживайтесь &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; мест, которые вы получили от &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (и никаких других), и вы обычно можете использовать &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; даже в &amp;laquo;текстовом&amp;raquo; режиме. Использование &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; или другие файловые операции могут быть непереносимой. Однако, если вы используете &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; в файле, вы обычно можете безопасно &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; произвольные значения.</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">Из-за 16-битности,UTF-16 зависит от порядка байт.Сама по себе кодировка UTF-16 может использоваться для вычислений в памяти,но если требуется хранение или передача,необходимо выбрать кодировку UTF-16BE (big-endian)или UTF-16LE (little-endian).</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">Из-за используемого алгоритма серия ISO-8859 и другие однобайтовые кодировки не работают хорошо,если только ни одна из кодировок ISO-8859 не является единственной подозреваемой (кроме ascii и utf8).</target>
        </trans-unit>
        <trans-unit id="5cf1c92c7c06c92a6e6b33e7b9bd233615db8e45" translate="yes" xml:space="preserve">
          <source>Because of the nature of the Perl parsing and tokenizing routines, certain initialization values &lt;b&gt;must&lt;/b&gt; be quoted in order to correctly parse as the intended version, especially when using the &lt;code&gt;declare&lt;/code&gt; or &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; methods. While you do not have to quote decimal numbers when creating version objects, it is always safe to quote &lt;b&gt;all&lt;/b&gt; initial values when using version.pm methods, as this will ensure that what you type is what is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e124c1c916c9b7a769264558af430e4f129d0a7" translate="yes" xml:space="preserve">
          <source>Because of the nature of the features it enables, forward compatibility can not be guaranteed in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89787285641f86ade5feb7e0702432198446d5b1" translate="yes" xml:space="preserve">
          <source>Because of the overhead associated with obtaining the list of defined symbols for the tied hash iterator, it is only done once, and the list is reused for subsequent iterations. Changes to symbols made through this package are recorded, but in the rare event that someone changes the process' symbol table from outside (as is possible using some software from the net), the iterator will be out of sync with the symbol table. If you expect this to happen, you can reset the cache by calling this method. In addition, if you pass a FALSE value as the first argument, caching will be disabled. It can be re-enabled later by calling &lt;code&gt;clearcache&lt;/code&gt; again with a TRUE value as the first argument. It returns TRUE or FALSE to indicate whether caching was previously enabled or disabled, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fd1b6b9fa8982a77e6c457f5e31e6dd1a8e6bb" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only explicitly use it to maintain weird backward compatibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">Из-за неожиданного поведения,связанного с этим модификатором,вероятно,следует использовать его только для поддержания странных обратных совместимостей.</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">Из-за их специального использования функцией sort(),переменные $a и $b освобождаются от этой проверки.</target>
        </trans-unit>
        <trans-unit id="79393165c5e367768108e6eb51a718f96e4510a4" translate="yes" xml:space="preserve">
          <source>Because of this fallback feature of JSON.pm, JSON::PP tries not to be more JavaScript-friendly than JSON::XS (i.e. not to escape extra characters such as U+2028 and U+2029, etc), in order for you not to lose such JavaScript-friendliness silently when you use JSON.pm and install JSON::XS for speed or by accident. If you need JavaScript-friendly RFC7159-compliant pure perl module, try &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON::Tiny&lt;/a&gt;, which is derived from &lt;a href=&quot;mojolicious&quot;&gt;Mojolicious&lt;/a&gt; web framework and is also smaller and faster than JSON::PP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">Из-за этого механизма важно, чтобы &lt;b&gt;AutoLoader&lt;/b&gt; всегда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d и не &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d.</target>
        </trans-unit>
        <trans-unit id="915eb569e5cd5ca772dbf6184e1e9e7f7c40e009" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;use&lt;/code&gt;d and not &lt;code&gt;require&lt;/code&gt;d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">Из-за этих двух факторов,подход к кодированию,используемый в ucm-based Encoding SOMETIMES,не работает,поэтому этот модуль был написан.</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">Поскольку шаблоны обрабатываются как строки в двойных кавычках,работают и следующие:</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">Поскольку perl должен проанализировать скрипт перед применением этой прагмы, такие кодировки, как Shift_JIS и Big-5, которые могут содержать &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) во втором байте, терпят неудачу, потому что второй байт может случайно ускользнуть от следующего за ним символа кавычек .</target>
        </trans-unit>
        <trans-unit id="e3192cbde985ba3a61564abae80a07c49199034c" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt;) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">Поскольку размер указателя не обязательно равен целочисленному размеру,используйте следующие макросы,чтобы сделать это правильно.</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">Поскольку скрипты различаются по своей направленности (например, иврит и арабский пишутся справа налево), Unicode предоставляет свойство &lt;code&gt;Bidi_Class&lt;/code&gt; . Это свойство может иметь следующие значения:</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">Поскольку испорченность связана с каждым скалярным значением, некоторые элементы массива или хэша могут быть испорчены, а другие нет. Ключи хеша &lt;b&gt;никогда не&lt;/b&gt; испорчены.</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">Потому что значение &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ed будет иметь разделитель, когда оно будет записано обратно в файл. Невозможно создать файл, в котором отсутствует конечная строка разделителя записей.</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">Поскольку функция &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в конце файла или при ошибке, иногда вы можете увидеть, что она используется следующим образом:</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">Поскольку оператор &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; подразумевает блок &lt;code&gt;BEGIN&lt;/code&gt; , импорт семантики происходит, как только оператор &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; компилируется, до компиляции остальной части файла. Вот как он может функционировать как механизм прагмы, а также как модули могут объявлять подпрограммы, которые затем отображаются в виде списка или унарных операторов для остальной части текущего файла. Это не сработает, если вы используете &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; . С помощью &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; вы можете столкнуться с этой проблемой:</target>
        </trans-unit>
        <trans-unit id="3c3e36ebc253e6320dfa90cfe5b728b065ce3f37" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;chomp&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">Поскольку &lt;code&gt;here&lt;/code&gt; перед &lt;code&gt;.*&lt;/code&gt; В шаблоне, его положение можно определить точно. Однако это не так для &lt;code&gt;there&lt;/code&gt; ; он мог появиться в любой момент после того, как появилась закрепленная строка. Perl использует оба варианта для оптимизации, предпочитая более длинный или, если они равны, плавающий.</target>
        </trans-unit>
        <trans-unit id="fef986661cf1ec507db2ffa4c44fc0d6ca39bba4" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt;; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2431412f653ac2d48b2590f72b1ae7bed247322" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;mark&lt;/code&gt; variable is converted to a pointer on the value stack, extra care must be taken if &lt;code&gt;EXTEND&lt;/code&gt; or any of the &lt;code&gt;XPUSH&lt;/code&gt; macros are invoked within the function, because the stack may need to be moved to extend it and so the existing pointer will now be invalid. If this may be a problem, a possible solution is to track the mark offset as an integer and track the mark itself later on after the stack had been moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a1dea2b8dc5fa2f3798b76ce3f11a720999a6b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;readline&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206300e9a9cae7d4d33910fad6d81cd5f5d5cc80" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;use&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;use&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;require&lt;/code&gt; instead of &lt;code&gt;use&lt;/code&gt;. With &lt;code&gt;require&lt;/code&gt; you can get into this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb97ff89f00546d3eb19d15e7c154022a6e40c9" translate="yes" xml:space="preserve">
          <source>Because the L&amp;lt;...&amp;gt; is the most complex construct in the language, it should not surprise you that the events it generates are the most complex in the language. Most of complexity is hidden away in the attribute values, so for those of you writing a Pod formatter that produces a non-hypertextual format, you can just ignore the attributes and treat an L event structure like a formatting element that (presumably) doesn't actually produce a change in formatting. That is, the content of the L event structure (as opposed to its attributes) is always what text should be displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1ecaef6dcc4b2b01535ebf9f55c2fce3a55dd0" translate="yes" xml:space="preserve">
          <source>Because the arithmetic operators all have fixed arity and are postfixed, there is no need for operator precedence, nor for a grouping operator to override precedence. This is half of the point of RPN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">Поскольку присвоение копирует значения, это также приводит к превращению вызова по ссылке в вызов по значению. В противном случае функция может &lt;code&gt;@_&lt;/code&gt; изменения в @_ на месте и изменять значения вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="ef6e720933c8cfb7b84641d15fcb0ddf15b2f13b" translate="yes" xml:space="preserve">
          <source>Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), the byte values that result are in an unspecified encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">Поскольку преобразование происходит на месте,данные,которые должны быть преобразованы,не могут быть строковой константой:это должна быть скалярная переменная.</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">Поскольку в текущей реализации используется таблица и размеры ключей для алгоритма хэширования,то нет средств,с помощью которых можно динамически изменять значение любого из параметров инициализации.</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">Так как цель этой функции в первую очередь заключается в том,чтобы позволить вам определять подпрограммы,которые работают как встроенные функции,вот прототипы некоторых других функций,которые анализируют почти точно так же,как и соответствующие встроенные функции.</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">Поскольку внутренний формат часто бывает UTF-8,эти ошибки трудно обнаружить,потому что UTF-8-это обычно та кодировка,которую вы хотели! Но не ленитесь и не используйте в своих интересах тот факт,что внутренний формат Perl-UTF-8.Кодируйте явно,чтобы избежать странных ошибок и показать обслуживающему программисту,что вы все продумали.</target>
        </trans-unit>
        <trans-unit id="92b5a68a7f930a6d97c59ffe2faa9fff5db40d0e" translate="yes" xml:space="preserve">
          <source>Because the magical increment only works on non-empty strings matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;, the following will only return an alpha:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">Поскольку режим содержит как тип файла, так и его разрешения, вы должны замаскировать часть типа файла и (-ы) printf, используя &lt;code&gt;&quot;%o&quot;&lt;/code&gt; если вы хотите увидеть реальные разрешения.</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">Поскольку в результате &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; все метасимволы заключены в кавычки, нет возможности вставить литерал &lt;code&gt;$&lt;/code&gt; или &lt;code&gt;@&lt;/code&gt; внутри пары &lt;code&gt;\Q\E&lt;/code&gt; Если защищено &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; будет заключено в кавычки, чтобы стать &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; в противном случае он интерпретируется как начало интерполированного скаляра.</target>
        </trans-unit>
        <trans-unit id="097258c8be4cbb48ed4be0fc9859bc5c3825bc9a" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt;; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">Так как оператор smartmatch возвращается на вложенные массивы,он все равно будет сообщать,что &quot;красный&quot; находится в массиве.</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">Поскольку стандартное сообщение об ошибке, которое &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; выдает всякий раз, когда тест терпит неудачу, будет обычным явлением в вашем выводе ошибок теста, и поскольку оно изменилось между версиями Test :: Builder, вместо того, чтобы заставлять вас вызывать &lt;code&gt;test_err&lt;/code&gt; со строкой, такое время</target>
        </trans-unit>
        <trans-unit id="87490af32e5b48ef0bb10c89847f02a1cf0e7677" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">Так как цель используется повторно,вы должны быть осторожны при выталкивании нескольких значений в стеке.Следующий код не будет делать то,что вы думаете:</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">Поскольку таблица транслитерации строится во время компиляции,ни</target>
        </trans-unit>
        <trans-unit id="c4a2190965562aceb584191519393c161752b237" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; may depend on the hardware architecture, it can vary more than the value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">Поскольку значение &lt;code&gt;$Config{archname}&lt;/code&gt; может зависеть от архитектуры аппаратных средств, она может изменяться более чем значение &lt;code&gt;$^O&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">Поскольку строка значений может содержать произвольные выражения (для полей,а не для каретных полей),вы можете передать более сложную обработку в другие функции,такие как sprintf()или одну из ваших собственных.Например:</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">Поскольку переменная становится допустимой сразу после &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , до тех пор, пока в области нет переменной с таким именем, вы можете снова ссылаться на переменную пакета даже в том же операторе.</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">Поскольку переменная становится допустимой сразу после &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , до тех пор, пока в области нет переменной с таким именем, вы можете снова ссылаться на переменную пакета даже в том же операторе.</target>
        </trans-unit>
        <trans-unit id="10adcfecf1a02c362d02294237aa3b65ee35acfd" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;use strict 'vars'&lt;/code&gt;, so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">Так как существует более трех аргументов для функции open(),вилки команды ps(1)</target>
        </trans-unit>
        <trans-unit id="327e12e185eccd28ae382163925adec0406495ff" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), it forks the ps(1) command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">Потому что есть люди, у которых есть свои точные ожидания относительно того, кто может устанавливать где в пути @INC и кто использует какой массив @INC. В точно настроенной среде &lt;code&gt;UNINST=1&lt;/code&gt; может вызвать повреждение.</target>
        </trans-unit>
        <trans-unit id="61339e91fc8e465df58897366d437a1f422fcc97" translate="yes" xml:space="preserve">
          <source>Because there is currently no way for a distribution to specify a dependency on an optional feature of another dependency, the use of &lt;code&gt;optional_feature&lt;/code&gt; is discouraged. Instead, create a separate, installable distribution that ensures the desired feature is available. For example, if &lt;code&gt;Foo::Bar&lt;/code&gt; has a &lt;code&gt;Baz&lt;/code&gt; feature, release a separate &lt;code&gt;Foo-Bar-Baz&lt;/code&gt; distribution that satisfies requirements for the feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">Поскольку считается, что эти объекты ресурсов принадлежат всему процессу / системе, а не &amp;laquo;свойству&amp;raquo; того, что сериализуется, никакие ссылки под объектом не должны включаться в сериализованную строку. Таким образом, в любом классе, реализующем &lt;code&gt;STORABLE_attach&lt;/code&gt; , метод &lt;code&gt;STORABLE_freeze&lt;/code&gt; не может возвращать никаких ссылок, а &lt;code&gt;Storable&lt;/code&gt; выдаст ошибку, если &lt;code&gt;STORABLE_freeze&lt;/code&gt; попытается вернуть ссылки.</target>
        </trans-unit>
        <trans-unit id="26af08e2f43bfef9b9e40cba2b2ed696b0549e29" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt;, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">Поскольку эта команда в некотором смысле является новой, выдается предупреждение, если вместо этого вы случайно вошли в блок. Если это то, что вы хотите сделать, напишите это как с &lt;code&gt;;{ ... }&lt;/code&gt; или даже &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74266b6323d7ce62912d6c101e78cdb916449da7" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;do { ... }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe0d4d00dfd6cabe863bda5f9354b347e13a163" translate="yes" xml:space="preserve">
          <source>Because this construct compiles under &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt;, unrecognized escapes that generate warnings in normal classes are fatal errors here, as well as all other warnings from these class elements, as well as some practices that don't currently warn outside &lt;code&gt;re 'strict'&lt;/code&gt;. For example you cannot say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618c1116f848d64cf69ade37db078db462072bd" translate="yes" xml:space="preserve">
          <source>Because this function operates at the byte level, and because of the inherent characteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the needle and the haystack are strings with the same UTF-8ness, but not if the UTF-8ness differs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">Поскольку эта функция использует mktemp(),она может страдать от гоночных условий.</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">Поскольку эта информация не хранится в самом исполняемом файле perl,возможно (но маловероятно),что она не относится к фактическому двоичному файлу perl,который используется для доступа к нему.</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">Поскольку это широко открытый интерфейс,таким же образом реализуются прагмы (директивы компилятора).В настоящее время реализованы прагмы:</target>
        </trans-unit>
        <trans-unit id="872c328b526f9b9864d2cfe0b4165fd06ef13624" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Some of the currently implemented pragmas are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">Поскольку этот оператор выдает присваиваемый результат,использование присваиваний без круглых скобок приведет к неприятностям.Например,это:</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">Так как это способствует действиям на расстоянии,это антиинтуитивное поведение может быть исправлено в будущем релизе.</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">Поскольку создание потока и присоединение к потоку могут происходить в разных контекстах, может быть желательно указать контекст явно для функции точки входа потока. Это можно сделать, вызвав &lt;code&gt;-&amp;gt;create()&lt;/code&gt; с хеш-ссылкой в ​​качестве первого аргумента:</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">Поскольку ссылки на переменные всегда начинаются с '$','@' или '%',то слова &quot;зарезервированы&quot; в отношении имен переменных на самом деле не зарезервированы.Они .</target>
        </trans-unit>
        <trans-unit id="cf7852aa0f7da3fa109ef4464da14b644fe19dd6" translate="yes" xml:space="preserve">
          <source>Because various errors may only be detected by close() (e.g. buffering could allow the &lt;code&gt;print&lt;/code&gt; in this example to return true even when the disk is full), it is dangerous to ignore its result. So when it happens implicitly, perl will signal errors by warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">Потому что сейчас нас беспокоит возвратное значение из</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">Потому что мы используем SV,чтобы позвонить</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">Так как мы создали временные значения (с помощью вызовов sv_2mortal()),нам придется привести в порядок стек Perl и утилизировать смертельные SV.</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">Так как мы указали G_DISCARD,нет необходимости проверять значение,возвращаемое с</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">Потому что, когда &lt;code&gt;autochomp&lt;/code&gt; отключен, &lt;code&gt;$a[10]&lt;/code&gt; будет считываться как &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (или как там есть строка разделителя записей.)</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">Потому что вы только что переместили существующий стандартный &lt;b&gt;вывод&lt;/b&gt; в другое место.</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">Потому что ты используешь нечто подобное,что усекает файл.</target>
        </trans-unit>
        <trans-unit id="230b0b84c4580dce513ede6c977fdc5dbaffa5e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10, setting &lt;code&gt;$*&lt;/code&gt; to a true value globally enabled multi-line matching within a string. This relique from the past lost its special meaning in 5.10. Use of this variable will be a fatal error in Perl 5.30, freeing the variable up for a future special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">До Perl 5.10.0 и 5.8.8, PERL5SHELL не проверялся на заражение при запуске внешних команд. Рекомендуется явно установить (или удалить) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; при работе в режиме заражения под Windows.</target>
        </trans-unit>
        <trans-unit id="ebab29b2af9a7a7c7ceefc18fae2257d84323d02" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some, but not all errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">До Perl 5.14 присвоение &lt;code&gt;$@&lt;/code&gt; происходило перед восстановлением локализованных переменных, что означает, что для запуска вашего кода в более старых версиях требуется временное значение, если вы хотите замаскировать некоторые, но не все ошибки:</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">До версии Perl 5.14 связь между перегрузкой и привязкой была нарушена.Перегрузка была спровоцирована или не спровоцирована по принципу</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">До Perl 5.18 &lt;code&gt;given(EXPR)&lt;/code&gt; присваивалось значение</target>
        </trans-unit>
        <trans-unit id="8ed431b288a3361b742578011935581f2edfcced" translate="yes" xml:space="preserve">
          <source>Before Perl 5.28, the returned values are unreliable for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; locale constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba6dd90f594f9b5d19255a91f0ae4487b358318" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot; in perlsub&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">До Perl 5.6 вам приходилось использовать нотацию &lt;code&gt;*FH&lt;/code&gt; или &lt;code&gt;\*FH&lt;/code&gt; . Это &amp;laquo;typeglobs&amp;raquo; - см. &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs и Filehandles в perldata&lt;/a&gt; и особенно &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference в perlsub&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">Перед установкой Perl 5.8.0 установите Perl-код для работы с сигналами,подвергающими Вас опасности двух вещей.Во-первых,лишь немногие функции системной библиотеки возвращаются в систему.Если сигнал прерывается во время выполнения Perl одной функции (например,malloc(3)или printf(3)),а затем Ваш обработчик сигнала снова вызывает ту же самую функцию,Вы можете получить непредсказуемое поведение-часто дамп ядра.Во-вторых,Perl сам по себе не возвращается на самых низких уровнях.Если сигнал прерывает Perl в то время,когда Perl изменяет свои собственные внутренние структуры данных,это может привести к такому же непредсказуемому поведению.</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">До Perl v5.8.0 использование &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; использовалось для объявления того, что операции в текущем блоке или файле будут поддерживать Unicode. Эта модель оказалась ошибочной или, по крайней мере, неуклюжей: &amp;laquo;Уникальность&amp;raquo; теперь переносится с данными, а не с операциями. Начиная с Perl v5.8.0, остается только один случай, когда требуется явное &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; : если сам сценарий Perl закодирован в UTF-8, вы можете использовать UTF-8 в именах идентификаторов, а также в литералах строк и регулярных выражений, говоря, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . Это не по умолчанию, потому что скрипты с устаревшими 8-битными данными могут сломаться. См. &lt;a href=&quot;utf8&quot;&gt;Utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa99c9f82e7be9fceb5a0c188011fae1cb7cad5" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;use utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;use utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;use utf8&lt;/code&gt;. This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">До появления Юникода большинство кодировок использовали 8 бит (один байт)для кодирования каждого символа.Таким образом,символ был байтом,а байт-символом,а возможных символов могло быть только 256 или меньше.&quot;Семантика байтов&quot; в заголовке этого раздела относится к такому поведению.Нет необходимости различать &quot;байт&quot; и &quot;персонаж&quot;.</target>
        </trans-unit>
        <trans-unit id="98f333eb7b1048c01de83e53fdf2f8f76121657f" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">До Unicode, когда символ был байтом, Perl знал только о 128 символах, определенных ASCII, кодовых точках от 0 до 127 (за исключением &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). Это оставило кодовые точки со 128 по 255 как неназначенные и доступные для любого использования, которое может потребоваться программе. Единственная семантика, которую они имеют, - это их порядковые номера и то, что они не являются членами ни одного из классов неотрицательных символов. Никто не считается , чтобы соответствовать &lt;code&gt;\w&lt;/code&gt; , например, но весь матч &lt;code&gt;\W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">Перед выполнением любой команды или в случае возникновения непредвиденной ошибки &lt;code&gt;code()&lt;/code&gt; вернет &amp;laquo;421&amp;raquo; (временный сбой соединения), а &lt;code&gt;message()&lt;/code&gt; вернет undef.</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">Прежде чем что-то еще,тебе нужен план тестирования.Он,по сути,объявляет,сколько тестов ваш скрипт будет выполнять для защиты от преждевременного отказа.</target>
        </trans-unit>
        <trans-unit id="62bd9b6df52b51e065387fd43e36061f890b0944" translate="yes" xml:space="preserve">
          <source>Before calling copy() or move() on a filehandle, the caller should close or flush() the file to avoid writes being lost. Note that this is the case even for move(), because it may actually copy the file, depending on the OS-specific implementation, and the underlying filesystem(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">Перед установкой патчей на С-компилятор IBM необходимо знать уровень патча для операционной системы.Команда IBM 'oslevel' покажет базу,но не всегда является полной (в данном примере oslevel показывает 4.3.NULL,в то время как система может работать большую часть 4.3.THREE):</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">До версии perl5.6 приходилось иметь дело с различными идиомами типографских шрифтов,которые можно увидеть в старом коде.</target>
        </trans-unit>
        <trans-unit id="cb7ffbda991b922f283aad1fac8b7fea6f1f3918" translate="yes" xml:space="preserve">
          <source>Before pushing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ceb0c5361b0c57292563baaff9c21803203fbb" translate="yes" xml:space="preserve">
          <source>Before pushing any change to a maint version, make sure you've satisfied the steps in &lt;a href=&quot;#Committing-to-blead&quot;&gt;&quot;Committing to blead&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">До версии 5 Perl было сложно представить сложные структуры данных,потому что все ссылки должны были быть символическими-и даже тогда было трудно ссылаться на переменную вместо записи в таблице символов.Теперь Perl не только упрощает использование символьных ссылок на переменные,но и позволяет иметь &quot;жесткие&quot; ссылки на любой фрагмент данных или кода.Любой скаляр может содержать жесткую ссылку.Поскольку массивы и хэши содержат скаляры,теперь можно легко строить массивы массивов,массивы хэшей,хэши массивов,массивы хэшей функций и так далее.</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">Перед отправкой сообщения об ошибке убедитесь,что традиционный метод сборки пакета модуля Perl из оболочки,следуя инструкциям по установке этого пакета,все еще работает в вашем окружении.</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">Перед завершением функция &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; должна явно установить фильтр, вызвав &lt;code&gt;filter_add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c19a9bcc3d0fce58bd4d9d25f82f4cb8c5d35503" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;import&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Прежде чем интерпретатор Perl сможет выполнить сценарий Perl, он должен сначала прочитать его из файла в память для анализа и компиляции. Если этот сценарий сам включает в себя другие сценарии с инструкциями &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , то каждый из этих сценариев также должен быть прочитан из соответствующих файлов.</target>
        </trans-unit>
        <trans-unit id="c6081a0bc2c6ca5d40e9bce0501b5e221be236ae" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">До появления поддержки Unicode в Perl оператор &lt;code&gt;eq&lt;/code&gt; просто сравнивал строки, представленные двумя скалярами. Начиная с Perl 5.8, &lt;code&gt;eq&lt;/code&gt; сравнивает две строки с одновременным учетом</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">До введения лексических предупреждений Perl имел два класса предупреждений:обязательные и необязательные.</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">Еще до того,как мы начнем соскребать код,есть несколько вещей,которые мы захотим сделать заранее.</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">Прежде чем мы пойдем дальше, вы захотите узнать, как выйти из отладчика: используйте только букву &amp;laquo; &lt;b&gt;q&lt;/b&gt; &amp;raquo;, а не слова &amp;laquo;выйти&amp;raquo; или &amp;laquo;выйти&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="10af6d27d8d05a680d682b1087a82d6e520c2fff" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;&quot;CAVEATS&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">Прежде чем писать XS, прочтите раздел &lt;a href=&quot;#CAVEATS&quot;&gt;ПРЕДОСТЕРЕЖЕНИЯ&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">Перед тем,как рассматривать возможность отправки сообщения об ошибке,пожалуйста,проконсультируйтесь и,возможно,отправьте сообщение на дискуссионный форум,чтобы узнать,является ли то,с чем вы столкнулись,известной проблемой.</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">Прежде чем продолжить, обратите внимание на порядок сортировки переменных. Обычно мы сначала перечисляем переменные в почти лексиграфическом порядке без учета регистра (игнорируя предшествующие слова &lt;code&gt;{&lt;/code&gt; или &lt;code&gt;^&lt;/code&gt; , как в &lt;code&gt;${^UNICODE}&lt;/code&gt; или &lt;code&gt;$^T&lt;/code&gt; ), хотя &lt;code&gt;$_&lt;/code&gt; и &lt;code&gt;@_&lt;/code&gt; перемещаются вверх из сваи. Для переменных с одним и тем же идентификатором мы перечисляем его в порядке скаляра, массива, хэша и голого слова.</target>
        </trans-unit>
        <trans-unit id="e90a6f007e6fb64dd92c6079f36a3d06c252dda3" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt;), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">Перед тем,как вы решите объединить два хэша,вы должны решить,что делать,если оба хэша содержат одинаковые ключи,и если вы хотите оставить оригинальные хэши такими,какими они были.</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Прежде чем делать что-либо еще, вы можете помочь себе, убедившись, что Perl сообщит вам о проблемных областях вашего кода. Включив предупреждения и ограничения, вы можете предотвратить многие проблемы, прежде чем они станут слишком большими. Вы можете узнать больше об этом в &lt;a href=&quot;strict&quot;&gt;разделе &amp;laquo;Строгие правила&lt;/a&gt; и &lt;a href=&quot;warnings&quot;&gt;предупреждения&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">Перед тем как сделать это, сначала убедитесь, что псевдоним не существует, с помощью &lt;code&gt;resolve_alias()&lt;/code&gt; , который возвращает его каноническое имя. Например:</target>
        </trans-unit>
        <trans-unit id="9fa55498f41c7cd4663e8d59ae7b91ebb05c3bad" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt;, which returns the canonical name thereof. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">Прежде чем приступить к &lt;a href=&quot;perlxs&quot;&gt;изучению&lt;/a&gt; остальной части этого документа, было бы неплохо прочитать следующие два документа - perlxs и &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">Прежде чем паниковать, знайте, что многие люди действительно используют &lt;code&gt;Moose&lt;/code&gt; для инструментов командной строки и другого кода, чувствительного к запуску. Мы рекомендуем вам сначала попробовать &lt;code&gt;Moose&lt;/code&gt; , прежде чем беспокоиться о скорости запуска.</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">Прежде чем вы начнете</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">Прежде чем вы начнете,важно кое-что узнать:</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">Перед тем,как начать,необходимо просмотреть файл README,находящийся в каталоге верхнего уровня,в который был извлечен дистрибутив Perl.Убедитесь,что вы прочитали и поняли условия,на которых распространяется это программное обеспечение.</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">Перед тем,как начать,вы должны просмотреть файл README,находящийся в каталоге верхнего уровня,где был извлечен дистрибутив Perl.Убедитесь,что вы прочитали и поняли условия,на которых распространяется это программное обеспечение.</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">Начните получение файла с именем &lt;code&gt;FILE&lt;/code&gt; с удаленного сервера.</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">Примечание для новичков: в примере 2 указанные выше &lt;code&gt;$columns&lt;/code&gt; импортируются в локальное пространство имен и устанавливаются локально. В примере 3 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; устанавливается в собственном пространстве имен без его импорта.</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">Новичкам часто кажется,что они хотят,чтобы переменная содержала имя переменной.</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">Начиная с Perl 5.12, Perl принимает многоточие &amp;laquo; &lt;code&gt;...&lt;/code&gt; &amp;raquo; в качестве заполнителя для кода, который вы еще не реализовали. Эту форму многоточия, нереализованного оператора, не следует путать с оператором двоичного триггера &lt;code&gt;...&lt;/code&gt; Один - это оператор, а другой - оператор. (Perl обычно не путает их, потому что обычно Perl может сказать, хочет ли он оператор или инструкцию, но см. Ниже исключения.)</target>
        </trans-unit>
        <trans-unit id="dc88deeacfc5c23c60a84d0e355d8d08bad0853c" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt;&quot;, as a placeholder for code that you haven't implemented yet. When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c724bcc9cdece1aeab2aab45c2518eb7791435" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.28, multi-threaded locale operation is supported on systems that implement either the POSIX 2008 or Windows-specific thread-safe locale operations. Many modern systems, such as various Unix variants and Darwin do have this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a346d69c5ac7465ea021c968ddc77fd7f137feb" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;&quot;Using References&quot;&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">Начиная с v5.20.0, доступен постфиксный синтаксис для использования ссылок. Он ведет себя, как описано в &lt;a href=&quot;#Using-References&quot;&gt;разделе &amp;laquo;Использование ссылок&amp;raquo;&lt;/a&gt; , но вместо сигилы с префиксом используется сигил со звездочкой с префиксом.</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">Начиная с версии v5.22.0,можно назначить оператор ссылки.Он выполняет операцию наложения псевдонима,так что имя переменной,на которую делается ссылка с левой стороны,становится псевдонимом для вещи,на которую делается ссылка с правой стороны:</target>
        </trans-unit>
        <trans-unit id="ffa0956923ab92c4c7492c5469e046b41154fb80" translate="yes" xml:space="preserve">
          <source>Beginning in v5.26.0, the referencing operator can come after &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;local&lt;/code&gt;. This syntax must be enabled with &lt;code&gt;use feature 'declared_refs'&lt;/code&gt;. It is experimental, and will warn by default unless &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">Начиная с HP-UX 11.00,программы,скомпилированные под HP-UX,могут использовать преимущества среды программирования LP64 (LP64 означает Longs и Pointers шириной 64 бита),в которой скалярные переменные смогут с полной точностью удерживать числа,превышающие 2^32.Perl доказал свою последовательность и надежность в 64-битном режиме начиная с версии 5.8.1 на всех HP-UX 11.xx.</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">Начиная с версии HP-UX 10.20,можно создавать файлы размером более 2 ГБ (2^31 байт)и манипулировать ими.Для этого доступны три отдельных метода.Из этих методов лучшим для Perl является компиляция с использованием флага -Duselargefiles to Configure.Это приводит к тому,что Perl компилируется с использованием структур и функций,в которых они имеют ширину 64 бита,а не 32 бита.(Заметим,что это будет работать только с ANSI C компилятором HP.Если вы хотите скомпилировать Perl,используя gcc,то вам потребуется версия компилятора,поддерживающая 64-битные операции.Смотрите выше,где его найти).</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Начиная с Perl 5.10.0, вы можете объявлять переменные с ключевым словом &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . Однако для того, чтобы это работало, вы должны включить эту функцию заранее, либо с помощью прагмы &lt;code&gt;feature&lt;/code&gt; , либо с помощью &lt;code&gt;-E&lt;/code&gt; для однострочных строк (см. &lt;a href=&quot;feature&quot;&gt;Функцию&lt;/a&gt; ). Начиная с Perl 5.16, форма &lt;code&gt;CORE::state&lt;/code&gt; не требует прагмы &lt;code&gt;feature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="043ad372200ab11184230c8b464cbbec604d0f73" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;state&lt;/code&gt; keyword in place of &lt;code&gt;my&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Начиная с Perl 5.18, вы можете объявить частную подпрограмму с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; . Как и в случае с переменными &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; ключевое слово состояния доступно только при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; или при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; или выше.</target>
        </trans-unit>
        <trans-unit id="4f40c1f7eb582d4b15076061b6d0a8e085b355dc" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt;. As with state variables, the &lt;code&gt;state&lt;/code&gt; keyword is only available under &lt;code&gt;use feature 'state'&lt;/code&gt; or &lt;code&gt;use 5.010&lt;/code&gt; or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb06f268b9e85c6ee8127ae9f07256660624d8e4" translate="yes" xml:space="preserve">
          <source>Beginning with Perl version 5.26, a much simpler and cleaner way to write indented here documents has been added to the language: the tilde (~) modifier. See &lt;a href=&quot;perlop#Indented-Here-docs&quot;&gt;&quot;Indented Here-docs&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">Начиная с Perl 5.10.0, вы можете также использовать &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; переменные имеют лексические, которые инициализируются только один раз (см &lt;a href=&quot;feature&quot;&gt;функции&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="62b599a702a0e45efa83ae9abd2c72ac9e40e2f7" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;state&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">Начиная с версии 5.004,поддерживаются также следующие функции:</target>
        </trans-unit>
        <trans-unit id="5a1a2270a454451ac22b568bca58999ca2a57b3c" translate="yes" xml:space="preserve">
          <source>Beginning/End of line positions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dfcf5f267b41370cad897910ad80d037ac22ab" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;#newCONSTSUB_flags&quot;&gt;&quot;newCONSTSUB_flags&quot;&lt;/a&gt;, except that &lt;code&gt;name&lt;/code&gt; is nul-terminated rather than of counted length, and no flags are set. (This means that &lt;code&gt;name&lt;/code&gt; is always interpreted as Latin-1.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6fd5b0516beaff8d8429855f694694659eb195" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;http://man.he.net/man2/wait&quot;&gt;wait(2)&lt;/a&gt; on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;. Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb78858d773149c7141146370197d2f530d8902f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">В вашей системе действует аналогично wait (2): он ожидает завершения дочернего процесса и возвращает pid умершего процесса или &lt;code&gt;-1&lt;/code&gt; , если дочерних процессов нет. Статус возвращается в &lt;code&gt;$?&lt;/code&gt; и &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Обратите внимание, что возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически, как описано в &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">В вашей системе действует аналогично wait (2): он ожидает завершения дочернего процесса и возвращает pid умершего процесса или &lt;code&gt;-1&lt;/code&gt; , если дочерних процессов нет. Статус возвращается в &lt;code&gt;$?&lt;/code&gt; и &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Обратите внимание, что возвращаемое значение &lt;code&gt;-1&lt;/code&gt; может означать, что дочерние процессы выполняются автоматически, как описано в &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="756aaec531bd197c8baf40355b6e7560606340ee" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">Ведет себя так же, как &lt;a href=&quot;#croak&quot;&gt;кваканье&lt;/a&gt; , за исключением возвращаемого типа. Его следует использовать только там, где требуется возвращаемый тип &lt;code&gt;OP *&lt;/code&gt; . Функция никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="e3b8ea26eb4d496c3c9598880a77b0e504f2a647" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;&quot;croak_sv&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">Ведет себя так же, как &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt; , за исключением возвращаемого типа. Его следует использовать только там, где требуется возвращаемый тип &lt;code&gt;OP *&lt;/code&gt; . Функция никогда не возвращается.</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">Поведение других функций Perl в вилочных псевдо-процессах</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">Поведение этой функции сильно варьируется в зависимости от реализации вашей системы.Например,она обычно не будет работать через границы файловой системы,даже если система</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">Поведение с версии 2.11</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">За кулисами</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">За кулисами функция &lt;code&gt;globmap&lt;/code&gt; выполняет комбинацию файла glob для сопоставления существующих имен файлов с последующей заменой для создания новых имен файлов.</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">Будучи перл-специфической,эта функция эволюционировала во времени.В настоящее время ее можно назвать следующим образом:</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">Механический процесс pl2pm не является пуленепробиваемым.Преобразованный код нуждается в тщательной проверке,особенно это касается любых утверждений о пакетах.Не удаляйте оригинальный .pl файл до тех пор,пока не заработает новый .pm один!</target>
        </trans-unit>
        <trans-unit id="7f0407ad618a0bd51d559ec6185eae8ed67ffedb" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. If you do just &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;&quot;, $B)&lt;/code&gt;, the filehandle &lt;code&gt;$A&lt;/code&gt; will not have the same file descriptor as &lt;code&gt;$B&lt;/code&gt;, and therefore &lt;code&gt;flock($A)&lt;/code&gt; will not &lt;code&gt;flock($B)&lt;/code&gt; nor vice versa. But with &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;=&quot;, $B)&lt;/code&gt;, the filehandles will share the same underlying system file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">Экономия файловых дескрипторов также полезна (помимо экономии), например, когда что-то зависит от файловых дескрипторов, например, блокировка с помощью flock (). Если вы просто &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , дескриптор файла A не будет иметь тот же дескриптор файла, что и B, и поэтому flock (A) не будет flock (B), и наоборот. Но с &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; дескрипторы файлов будут использовать один и тот же базовый файловый дескриптор.</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">Экономия файловых дескрипторов также полезна (помимо экономии), например, когда что-то зависит от файловых дескрипторов, например, блокировка с помощью flock (). Если вы просто &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , дескриптор файла A не будет иметь тот же дескриптор файла, что и B, и поэтому flock (A) не будет flock (B), и наоборот. Но с &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; дескрипторы файлов будут использовать один и тот же базовый файловый дескриптор.</target>
        </trans-unit>
        <trans-unit id="027a12c2fc8568e8b70b07ff536faf288a013670" translate="yes" xml:space="preserve">
          <source>Belarus</source>
          <target state="translated">Belarus</target>
        </trans-unit>
        <trans-unit id="5cb4c9d828175ed3931ec52305b32f47173a8e04" translate="yes" xml:space="preserve">
          <source>Belgium</source>
          <target state="translated">Belgium</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">Колокольчик звучит,когда слово заканчивается неудачно.</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">Ниже приведены несколько примеров глобусов.</target>
        </trans-unit>
        <trans-unit id="8b537b36a224ab3855e5388cf5af4a7324861d08" translate="yes" xml:space="preserve">
          <source>Below comes a verbose discussion of these flags. Note that a &quot;codeset&quot; is simply an abstract set of character-codepoint pairs, while an encoding takes those codepoint numbers and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">Ниже приведена</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">Ниже приведен список нескольких фреймворков с комментариями,которые могут помочь вам в принятии решения в зависимости от ваших конкретных требований.Начните с чтения документации,затем задайте вопросы по соответствующему списку рассылки или IRC-каналу.</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">Ниже приведен список файлов в базе данных Unicode,которые Perl в настоящее время не использует,а также очень краткое описание их назначения.Некоторые из названий файлов были сокращены по сравнению с теми,что используются в Юникоде,чтобы их можно было отличить от одноименных файлов на файловых системах,для которых значимы только первые 8 символов названия.</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">Ниже приведен список доступных методов.</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">Ниже приведен список действительных вариантов:</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">Ниже представлено отображение того,какие утилиты будут использоваться в каком порядке для каких схем,если таковые имеются:</target>
        </trans-unit>
        <trans-unit id="19c0c3663e2dbbc758912a1313a649285c7d7339" translate="yes" xml:space="preserve">
          <source>Below is a mod_perl Apache compression module, called &lt;code&gt;Apache::GZip&lt;/code&gt;, taken from &lt;a href=&quot;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">Ниже приведена возможная реализация скрипта для выполнения переименования (случаи ошибок пропущены)</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">Ниже приведен сценарий, использующий &lt;code&gt;gzreadline&lt;/code&gt; . Он реализует очень простой</target>
        </trans-unit>
        <trans-unit id="dc35361ae28756350bcadeedc93fea7a717eda63" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt;. It implements a very simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">Ниже приведен простой сценарий &quot;переименования&quot;, который использует &lt;code&gt;globmap&lt;/code&gt; для определения имен файлов источника и назначения.</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">Ниже приведен пример модуля,использующего макросы.</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">Ниже приведен пример программы &lt;code&gt;cpp_test&lt;/code&gt; , в которой используется этот фильтр. Номера строк были добавлены, чтобы можно было легко ссылаться на конкретные строки.</target>
        </trans-unit>
        <trans-unit id="b304a8ff907f2b83be9fd715d004cdf9a531f584" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt;, which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">Ниже приведен только один пример, иллюстрирующий глагол управления &lt;code&gt;(*FAIL)&lt;/code&gt; , который может быть сокращен как &lt;code&gt;(*F)&lt;/code&gt; . Если это будет вставлено в регулярное выражение, оно приведет к сбою, так же как это было бы при некотором несоответствии между шаблоном и строкой. Обработка регулярного выражения продолжается, как и после любого &amp;laquo;нормального&amp;raquo; сбоя, так что, например, будет проверена следующая позиция в строке или другая альтернатива. Поскольку несоответствие не сохраняет группы захвата и не дает результатов, может потребоваться использовать это в сочетании со встроенным кодом.</target>
        </trans-unit>
        <trans-unit id="8dfcb4bdf0851e123d1da057d122d3eaadab35bd" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt;, which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt;. If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">Ниже приведен пример того,что нужно сделать,чтобы воспроизвести конфигурацию на моей машине.На сайте</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">Ниже приведен типичный код, показывающий, как использовать &lt;code&gt;LimitOutput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7690c7bdc8f256fde6341fc38dc8edeb2bb2bde" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">Бен Тилли</target>
        </trans-unit>
        <trans-unit id="e231863abeba6b63203ae12c8ced1dd832bf1e27" translate="yes" xml:space="preserve">
          <source>Ben Tilly &amp;lt;btilly@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">Эталон-эталон времени работы Perl-кода</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">объект тестирования</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">Бенчмарк наследуется ни от какого другого класса,кроме,конечно же,от Exporter.</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Время выполнения кода Perl</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">Бенджамин Хольцман (Benjamin Holzman)предоставил поддержку связанных переменных,Эндрю Форд (Andrew Ford)-канонический порядок для хэшей,а Жизель Аас (Gisle Aas)исправил несколько моих недоразумений относительно внутренних perl,а также оптимизировал излучение &quot;тегов&quot; в выходных потоках,просто считая объекты,а не тегируя их (что привело к бинарной несовместимости для образа Storable,начиная с версии 0.6-изображения держателя,конечно же,все еще правильно поняты).Мюррей Несбит (Murray Nesbitt)сделал Storable потокобезопасным.Марк Леманн добавил перегрузку и ссылки на поддержку связанных элементов.Бенджамин Хольцман добавил улучшение производительности для перегруженных классов;спасибо Grant Street Group за поддержку счета.</target>
        </trans-unit>
        <trans-unit id="97adf5b0f3e282d4b4c33cdd224636f12368207c" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill. Reini Urban took over maintainance from p5p, and added security fixes and huge object support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce63cc3b1fa95fc4c74ca1cad11a70531a58a69f" translate="yes" xml:space="preserve">
          <source>Benjamin Noggle &amp;lt;agwind@users.noreply.github.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB позволяет создавать базы данных в памяти, используя NULL (то есть &lt;code&gt;(char *)0&lt;/code&gt; в C) вместо имени файла. &lt;b&gt;DB_File&lt;/b&gt; использует &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вместо NULL для обеспечения этой функциональности.</target>
        </trans-unit>
        <trans-unit id="b44f74f0eaff4623bb4f32a3bc9a77a5a293d873" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;undef&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DB - это библиотека C, которая обеспечивает согласованный интерфейс для ряда форматов баз данных. &lt;b&gt;DB_File&lt;/b&gt; предоставляет интерфейс для всех трех типов баз данных, которые в настоящее время поддерживаются Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">БД Беркли использует функцию dbopen()для открытия или создания БД.Вот прототип функции dbopen()на языке C:</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">BerkeleyDB доступен для Cygwin.</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">Кроме import()и AUTOLOAD()есть только несколько других методов.</target>
        </trans-unit>
        <trans-unit id="8eaf9c16309e0e030fec414bcececf296c9fd80c" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#Metacharacters&quot;&gt;&lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt;&lt;/a&gt;, Perl defines the following zero-width assertions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba06ebae884c8bbbcddfe487f2f73c4f3cbe88a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;&quot;decode&quot;&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;&quot;encode&quot;&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">Помимо &lt;a href=&quot;#decode&quot;&gt;декодирования&lt;/a&gt; и &lt;a href=&quot;#encode&quot;&gt;кодирования&lt;/a&gt; , доступны и другие методы. Например, &lt;code&gt;name()&lt;/code&gt; возвращает каноническое имя объекта кодирования.</target>
        </trans-unit>
        <trans-unit id="c3f604e026977938c21e0b164fdc42c9575f5038" translate="yes" xml:space="preserve">
          <source>Besides being a metacharacter, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; is an example of a &quot;character class&quot;, something that can match any single character of a given set of them. In its case, the set is just about all possible characters. Perl predefines several character classes besides the &lt;code&gt;&quot;.&quot;&lt;/code&gt;; there is a separate reference page about just these, &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212828aa9819262a5dba3e04d7db334b30f00e96" translate="yes" xml:space="preserve">
          <source>Besides being able to say &lt;code&gt;\p{Name=...}&lt;/code&gt;, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt;, &lt;code&gt;charnames::vianame()&lt;/code&gt;, and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;use charnames ();&lt;/code&gt; to be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">Помимо проверки существующего кода XS, сценарий также можно использовать для получения информации о совместимости для различных вызовов API с помощью &lt;code&gt;--api-info&lt;/code&gt; командной строки --api-info . Например:</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">Кроме многих других тестов,он проверит каждую локаль,которую найдет на вашей системе,на соответствие стандарту POSIX.Если у кого-то из них есть ошибки,он включит в себя сводку,в конце вывода которой локали прошли все свои тесты,и какая из них провалилась,и почему.</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">Кроме помещения кросс-компилятора и остального инструментария в PATH,это также обеспечит переменную QNX_TARGET,которую мы передадим в команду Configure через -Dsysroot.</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">Помимо сохранения этих хэшей в качестве атрибутов хэш-ссылки &lt;code&gt;name2path&lt;/code&gt; и &lt;code&gt;path2name&lt;/code&gt; , вызов этой функции также возвращает эти хеш-ссылки. В контексте списка возвращаемое значение &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; - это список &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . В скалярном контексте возвращаемое значение - &lt;code&gt;\%name2path&lt;/code&gt; . Или вы можете просто назвать это в пустом контексте.</target>
        </trans-unit>
        <trans-unit id="68eae0359edab349209444648a1ef905188cfbd0" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt;, calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt;. In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt;. Or you can just call this in void context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db52c932112966f376fe8b88f42b909a1d77f94" translate="yes" xml:space="preserve">
          <source>Besides taking away the special meaning of a metacharacter, a prefixed backslash changes some letter and digit characters away from matching just themselves to instead have special meaning. These are called &quot;escape sequences&quot;, and all such are described in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;. A backslash sequence (of a letter or digit) that doesn't currently have special meaning to Perl will raise a warning if warnings are enabled, as those are reserved for potential future use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">Помимо &lt;code&gt;$|&lt;/code&gt; специальной переменной, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; , чтобы присвоить дескриптору файла слой &lt;code&gt;:unix&lt;/code&gt; , который не буферизуется:</target>
        </trans-unit>
        <trans-unit id="28b7e372985d4c31ff927994e7e34211eb124b71" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;binmode&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">Помимо описанного выше символа NBSP, разработчикам напоминается о существовании другого &amp;laquo;специального&amp;raquo; символа в Latin-1, символа &amp;laquo;мягкий дефис&amp;raquo;, также известного как &amp;laquo;дискреционный дефис&amp;raquo;, то есть &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). Этот символ обозначает необязательную точку переноса. То есть обычно он отображается как ничего, но может отображаться как &quot;-&quot;, если средство форматирования прерывает слово в этой точке. Средства форматирования Pod должны, при необходимости, выполнить одно из следующих действий: 1) отобразить это с помощью кода с тем же значением (например, &quot;\ -&quot; в RTF), 2) передать его, ожидая, что средство форматирования понимает этот символ как такие, или 3) удалить.</target>
        </trans-unit>
        <trans-unit id="fb9d8bd5854ba8b088687eedfedb188dbc42540c" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt;). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">Помимо обычного зацикливания индекса массива, &lt;code&gt;for&lt;/code&gt; может использоваться во многих других интересных приложениях. Вот тот, который позволяет избежать проблемы, с которой вы столкнетесь, если вы явно протестируете конец файла в интерактивном файловом дескрипторе, из-за чего ваша программа будет зависать.</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">Кроме очевидных документов,исходный код может быть поучительным.Некоторые патологические примеры использования ссылок можно найти в разделе</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">Помимо очевидных преобразований подов, Pod :: Man также заботится о форматировании func (), func (3) и простых ссылок на переменные, таких как $ foo или @bar, поэтому вам не нужно использовать для них экранирование кода; сложные выражения, такие как &lt;code&gt;$fred{'stuff'}&lt;/code&gt; все равно придется экранировать. Он также переводит тире, которые не используются в качестве дефисов, в короткие тире, превращает длинные тире - как это - в правильные длинные тире, исправляет &quot;парные кавычки&quot;, заставляет C ++ выглядеть правильно, помещает небольшой промежуток между двойными подчеркиваниями, делает ALLCAPS немного меньше в &lt;b&gt;troff&lt;/b&gt; и избегает вещей, которые * roff рассматривает как особые, так что вам не нужно.</target>
        </trans-unit>
        <trans-unit id="5bb351a96d9e7856a11971d899903843a4ce13f1" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">Помимо очевидных преобразований подов, Pod :: Man и, следовательно, pod2man также заботятся о форматировании func (), func (n) и простых ссылок на переменные, таких как $ foo или @bar, поэтому вам не нужно использовать для них экранирование кода. ; сложные выражения, такие как &lt;code&gt;$fred{'stuff'}&lt;/code&gt; все равно придется экранировать. Он также переводит тире, которые не используются в качестве дефисов, в короткие тире, превращает длинные тире - как это - в правильные длинные тире, исправляет &amp;laquo;парные кавычки&amp;raquo; и заботится о некоторых других настройках, связанных с troff. См. &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; для полной информации.</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">Помимо хорошо известных кодов &amp;laquo;E &amp;lt;lt&amp;gt;&amp;raquo; и &amp;laquo;E &amp;lt;gt&amp;gt;&amp;raquo; для значений &amp;laquo;меньше и больше&amp;raquo;, парсеры Pod должны понимать &amp;laquo;E &amp;lt;sol&amp;gt;&amp;raquo; для &amp;laquo;/&amp;raquo; (косая черта, косая черта) и &amp;laquo; E &amp;lt;verbar&amp;gt; &quot;для&quot; | &quot; (вертикальная полоса, труба). Парсеры Pod также должны понимать &quot;E &amp;lt;lchevron&amp;gt;&quot; и &quot;E &amp;lt;rchevron&amp;gt;&quot; как устаревшие коды для символов 171 и 187, т. Е. &quot;Двойная угловая кавычка, указывающая влево&quot; = &quot;гильмета, указывающая влево&quot; и &quot;двойная угловая кавычка, указывающая вправо&quot; угловая кавычка &quot;=&quot; игла, указывающая вправо &quot;. (Они выглядят как маленькие &amp;laquo;&amp;lt;&amp;lt;&amp;raquo; и &amp;laquo;&amp;gt;&amp;gt;&amp;raquo;, и теперь они предпочтительно выражаются кодами HTML / XHTML &amp;laquo;E &amp;lt;laquo&amp;gt;&amp;raquo; и &amp;laquo;E &amp;lt;raquo&amp;gt;&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="860a34f94eb6573e4bc9c4a64ff033a99b23eda5" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;Unicode::UCD#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Помимо этого, все свойства символов Юникода, упомянутые выше (за исключением тех, которые помечены как предназначенные для внутреннего использования Perl), также доступны через &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist () в Unicode :: UCD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">Кроме целых фраз,предназначенных для вывода,в класс Projname::L10N::en_us должно быть помещено все,что зависит от языка,будь то методы или записи в лексиконе-это обсуждается в разделе &quot;Записи в каждом лексиконе&quot;,выше.</target>
        </trans-unit>
        <trans-unit id="ab1d9532fa300263b037333b93fafef9210c8c57" translate="yes" xml:space="preserve">
          <source>Besides, I don't know how to write the damned things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">Передовой опыт создания нового модуля.</target>
        </trans-unit>
        <trans-unit id="ae28545952ad516171bc8541be8a3d6e7dcf583f" translate="yes" xml:space="preserve">
          <source>Better diagnostics capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d4f16c5fc7da807c79c20a2575508b93d90392" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;unpairs&lt;/code&gt;, a higher-order list function can be used to operate on the pairs as single scalars; such as the following near-equivalents of the other &lt;code&gt;pair*&lt;/code&gt; higher-order functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">Между Mac OS X 10.3 &quot;Panther&quot; и 10.6 &quot;Snow Leopard&quot;,&quot;Command Line Tools&quot; набор назывался &quot;unix инструменты&quot;,и обычно поставлялся с установочными DVD-дисками Mac OS.</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">Между &lt;code&gt;%&lt;/code&gt; и буквой формата вы можете указать несколько дополнительных атрибутов, управляющих интерпретацией формата. По порядку это:</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">Остерегайтесь также порядка более сложных выражений типа:</target>
        </trans-unit>
        <trans-unit id="6cfef1757642ae2cc2b58e48199cf1ffe99563dc" translate="yes" xml:space="preserve">
          <source>Beware of casting the entire expression, as this would cast the result, at which point it is too late:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">Остерегайтесь простого &quot;кастинга&quot; всего выражения,это приведет только к преобразованию уже вычисленного результата:</target>
        </trans-unit>
        <trans-unit id="993aa75891c2224a1f9c297f58bf1ffa758e779f" translate="yes" xml:space="preserve">
          <source>Beware of the &quot;else syndrome&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9c3aa0cee4b1c15e1e5a6a65e3ca3cde192e4e" translate="yes" xml:space="preserve">
          <source>Beware of using &lt;code&gt;&quot;$&quot;&lt;/code&gt; to indicate to match the end of the string. It can too easily be interpreted as being a punctuation variable, like &lt;code&gt;$/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">Остерегайся:</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">Помните, что если вы поместите буквальную обратную косую черту (те, которые не находятся внутри интерполированных переменных) между &lt;code&gt;\Q&lt;/code&gt; и &lt;code&gt;\E&lt;/code&gt; , интерполяция обратной косой черты в двойных кавычках может привести к запутанным результатам. если ты</target>
        </trans-unit>
        <trans-unit id="eebfc88db53433dbd95a0208b9c35bedb078dc7e" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;, double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5349c42e3fc571db11577ff5f6cb8d88af8429b8" translate="yes" xml:space="preserve">
          <source>Beware that in a UTF-8 locale, anything you pass to this function must be in UTF-8; and when not in a UTF-8 locale, anything passed must not be UTF-8 encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">Остерегайтесь,что некоторые командные оболочки могут накладывать ограничения на длину командной строки.Вы должны убедиться,что ваши строки не превышают этот предел после любых необходимых интерполяций.Более подробную информацию о вашей конкретной среде см.в примечаниях к версии для конкретной платформы.</target>
        </trans-unit>
        <trans-unit id="9cd8d5856a80822f4c1d90c9c02e95de943bc843" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#join-EXPR%2CLIST&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">Помните, что, в отличие от &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; не принимает шаблон в качестве первого аргумента. Сравните &lt;a href=&quot;#split&quot;&gt;сплит&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">Помните, что, в отличие от &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; не принимает шаблон в качестве первого аргумента. Сравните &lt;a href=&quot;split&quot;&gt;сплит&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">Берегись:Эта функция еще не полностью реализована.</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">Берегись:Этот список не полный.</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">Осторожно: после возврата из этой функции &lt;code&gt;ptr&lt;/code&gt; и SvPVX_const (sv) больше не могут ссылаться на один и тот же фрагмент данных.</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">За пределами точек кода Юникода</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">Beyond make test</target>
        </trans-unit>
        <trans-unit id="16881dc1b286f9fd89e3c68a1307509ea4208790" translate="yes" xml:space="preserve">
          <source>Beyond raw access to the API calls and related constants, this module handles smart buffer allocation and translation of return codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">Помимо этой справки,параметр urllist config-ваш.Вы можете добавлять и удалять сайты по своему усмотрению.Вы должны выяснить,какие сайты имеют наибольшую актуальность,пропускную способность,надежность и т.д.и находятся в топологической близости к вам.Некоторые люди предпочитают быструю загрузку,другие-актуальность,третьи-надежность.Вы решаете,что попробовать в каком порядке.</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">Кроме того, самый простой отладчик - это функция &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . Используйте его для просмотра значений при запуске вашей программы:</target>
        </trans-unit>
        <trans-unit id="cc8c0bdbbf061aa1132ad0db52bd5ab409c1d5c4" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;print&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">Кроме того,вы должны рассмотреть несколько вещей и решить,что лучше для вас.</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">Помимо обычных мер, описанных для ускорения или уменьшения размеров обычных Perl-программ, у CGI-программы есть дополнительные проблемы. Он может запускаться несколько раз в секунду. Учитывая, что каждый раз, когда он запускается, его нужно будет перекомпилировать и часто будет выделять мегабайт или больше системной памяти, это может быть убийственным. Компиляция в C вам &lt;b&gt;не поможет,&lt;/b&gt; потому что узкое место - это накладные расходы на запуск процесса.</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">Помимо очевидных проблем,связанных с предоставлением специальных привилегий таким гибким системам,как скрипты,во многих версиях Unix скрипты set-id изначально небезопасны.Проблема заключается в состоянии гонки в ядре.Между тем,как ядро открывает файл,чтобы увидеть,какой интерпретатор нужно запустить,и когда интерпретатор (now-set-id)разворачивается и заново открывает файл,чтобы интерпретировать его,файл,о котором идет речь,мог измениться,особенно если у вас в системе есть символические ссылки.</target>
        </trans-unit>
        <trans-unit id="cfa5b349eaf3622485b4949d5b4c1629b7136aa6" translate="yes" xml:space="preserve">
          <source>BhkDISABLE</source>
          <target state="translated">BhkDISABLE</target>
        </trans-unit>
        <trans-unit id="097eaa76fb990cb3c085617a09bb68f2d2dd28d0" translate="yes" xml:space="preserve">
          <source>BhkENABLE</source>
          <target state="translated">BhkENABLE</target>
        </trans-unit>
        <trans-unit id="56657a5c49e88295c9fdbd426498620306255970" translate="yes" xml:space="preserve">
          <source>BhkENTRY</source>
          <target state="translated">BhkENTRY</target>
        </trans-unit>
        <trans-unit id="eed78c8324c929e21a7725f018dc13f233941d2d" translate="yes" xml:space="preserve">
          <source>BhkENTRY_set</source>
          <target state="translated">BhkENTRY_set</target>
        </trans-unit>
        <trans-unit id="6303b515a179b4880dfa9b0c5bdeef24554d4d0d" translate="yes" xml:space="preserve">
          <source>BhkFLAGS</source>
          <target state="translated">BhkFLAGS</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="c81d74ec4f5774b83707b81c40273f9931cc6799" translate="yes" xml:space="preserve">
          <source>BidiCharacterTest.txt</source>
          <target state="translated">BidiCharacterTest.txt</target>
        </trans-unit>
        <trans-unit id="69ecda50c93df6838e91e9e521a5ea42b19e7e09" translate="yes" xml:space="preserve">
          <source>BidiTest.txt</source>
          <target state="translated">BidiTest.txt</target>
        </trans-unit>
        <trans-unit id="603c926318562657586c9e1146fc9dbe3c25c988" translate="yes" xml:space="preserve">
          <source>Bidirectional Character Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">Двунаправленная связь с другим процессом</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">Двунаправленная связь с самим собой</target>
        </trans-unit>
        <trans-unit id="de1698114af4355c5ccd60424049fded636df6a2" translate="yes" xml:space="preserve">
          <source>Big5</source>
          <target state="translated">Big5</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">Подпрограмма bcmp () BigInt в настоящее время возвращает undef, чтобы сигнализировать о том, что в сравнении участвовало NaN. Однако код перегрузки превращает это значение в 1 или '', и поэтому такие операции, как &lt;code&gt;NaN != NaN&lt;/code&gt; могут возвращать неправильные значения.</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">Большие Числа</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;!=&quot;&lt;/code&gt; Возвращает истину, если левый аргумент численно не равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;!~&quot;&lt;/code&gt; Аналогичен &lt;code&gt;&quot;=~&quot;&lt;/code&gt; за исключением того, что возвращаемое значение инвертируется в логическом смысле.</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; С неразрушающим замещения ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ) или транслитерации ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; ) является синтаксической ошибкой.</target>
        </trans-unit>
        <trans-unit id="669b5730a4de160e3201236f63831582ab97b4ad" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;s///r&lt;/code&gt;) or transliteration (&lt;code&gt;y///r&lt;/code&gt;) is a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;%&quot;&lt;/code&gt; - это оператор по модулю, который вычисляет остаток от деления первого аргумента относительно второго аргумента. Для целочисленных операндов &lt;code&gt;$m&lt;/code&gt; и &lt;code&gt;$n&lt;/code&gt; : если &lt;code&gt;$n&lt;/code&gt; положительно, то &lt;code&gt;$m % $n&lt;/code&gt; равно &lt;code&gt;$m&lt;/code&gt; минус наибольшее кратное для &lt;code&gt;$n&lt;/code&gt; меньшее или равное &lt;code&gt;$m&lt;/code&gt; . Если &lt;code&gt;$n&lt;/code&gt; отрицательно, тогда &lt;code&gt;$m % $n&lt;/code&gt; равно &lt;code&gt;$m&lt;/code&gt; минус наименьшее кратное &lt;code&gt;$n&lt;/code&gt; , которое не меньше &lt;code&gt;$m&lt;/code&gt; (то есть результат будет меньше или равен нулю). Если операнды &lt;code&gt;$m&lt;/code&gt; и &lt;code&gt;$n&lt;/code&gt; являются значениями с плавающей запятой, а абсолютное значение &lt;code&gt;$n&lt;/code&gt; (то есть &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ) меньше &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , в операции будет использоваться только целая часть &lt;code&gt;$m&lt;/code&gt; и &lt;code&gt;$n&lt;/code&gt; (Примечание: здесь &lt;code&gt;UV_MAX&lt;/code&gt; означает максимум целого типа без знака). Если абсолютное значение правого операнда ( &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ) больше или равно &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; вычисляет остаток &lt;code&gt;$r&lt;/code&gt; с плавающей запятой в уравнении &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; где &lt;code&gt;$i&lt;/code&gt; - некоторое целое число, при котором &lt;code&gt;$r&lt;/code&gt; имеет тот же знак, что и правый операнд &lt;code&gt;$n&lt;/code&gt; ( &lt;b&gt;не&lt;/b&gt; как левый операнд &lt;code&gt;$m&lt;/code&gt; как функция C &lt;code&gt;fmod()&lt;/code&gt; ) и абсолютное значение меньше, чем у &lt;code&gt;$n&lt;/code&gt; . Обратите внимание, что когда в области видимости &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; дает вам прямой доступ к оператору по модулю, реализованному вашим компилятором C. Этот оператор не так хорошо определен для отрицательных операндов, но он будет выполняться быстрее.</target>
        </trans-unit>
        <trans-unit id="41e316d0ff24f3ca1a3464d44861dfcd88d324d8" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt;: If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt;. If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;abs($n)&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;abs($n)&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt;) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt;. Note that when &lt;code&gt;use integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a326cd0bd8e1d3d414fab02e5019eeeb66d4b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; возвращает свои операнды, соединенные вместе бит за битом. Хотя в настоящее время не возникает никаких предупреждений, результат не определен должным образом, когда эта операция выполняется с операндами, которые не являются ни числами (см. &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленную арифметику&lt;/a&gt; ), ни битовыми строками (см. &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Побитовые строковые операторы&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; выполняет короткое замыкание логической операции И. То есть, если левый операнд ложен, правый операнд даже не оценивается. Скалярный контекст или контекст списка распространяется вниз до правого операнда, если он вычислен.</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно больше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="7b8b841de5eb99d0ccb88b329de6ee433524b771" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; возвращает значение своего левого аргумента, сдвинутое вправо на количество битов, заданное правым аргументом. Аргументы должны быть целыми числами. (См. Также &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленную арифметику&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно больше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно меньше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="699e70a5fa87498319583ad7600759912b343d42" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; возвращает значение своего левого аргумента, сдвинутое влево на количество битов, указанное в правом аргументе. Аргументы должны быть целыми числами. (См. Также &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Целочисленную арифметику&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно меньше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; возвращает -1, 0 или 1 в зависимости от того, является ли левый аргумент численно меньше, равен или больше правого аргумента. Если ваша платформа поддерживает &lt;code&gt;NaN&lt;/code&gt; (не числа) в виде числовых значений, использование их с &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; возвращает undef. &lt;code&gt;NaN&lt;/code&gt; не является чем-либо &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; или &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; (даже &lt;code&gt;NaN&lt;/code&gt; ), поэтому эти 5 возвращают false. &lt;code&gt;NaN != NaN&lt;/code&gt; возвращает истину, как и &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04a45698769168d1350bede297cc638685f279" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt;'s (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;==&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt;), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;*&quot;&lt;/code&gt; умножает два числа.</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;**&quot;&lt;/code&gt; - это оператор возведения в степень. Он связывает даже сильнее, чем унарный минус, поэтому &lt;code&gt;-2**4&lt;/code&gt; равно &lt;code&gt;-(2**4)&lt;/code&gt; , а не &lt;code&gt;(-2)**4&lt;/code&gt; . (Это реализовано с помощью функции C &lt;code&gt;pow(3)&lt;/code&gt; , которая фактически работает с двойниками внутри.)</target>
        </trans-unit>
        <trans-unit id="ea1f5488b58109753bdbb42f40a1d426d3469962" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt;, not &lt;code&gt;(-2)**4&lt;/code&gt;. (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;+&quot;&lt;/code&gt; возвращает сумму двух чисел.</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;,&quot;&lt;/code&gt; - оператор запятой. В скалярном контексте он оценивает свой левый аргумент, отбрасывает это значение, затем оценивает свой правый аргумент и возвращает это значение. Это похоже на оператор запятой в C.</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">Двоичный знак &lt;code&gt;&quot;-&quot;&lt;/code&gt; возвращает разницу двух чисел.</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;.&quot;&lt;/code&gt; объединяет две строки.</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;..&quot;&lt;/code&gt; - это оператор диапазона, который на самом деле представляет собой два разных оператора в зависимости от контекста. В контексте списка он возвращает список значений, отсчитываемых (на единицы) от левого значения к правому. Если левое значение больше правого, возвращается пустой список. Оператор диапазона полезен для написания циклов &lt;code&gt;foreach (1..10)&lt;/code&gt; и для выполнения операций среза над массивами. В текущей реализации временный массив не создается, когда оператор диапазона используется в качестве выражения в циклах &lt;code&gt;foreach&lt;/code&gt; , но более старые версии Perl могут сжигать много памяти, когда вы пишете что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;/&quot;&lt;/code&gt; делит два числа.</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;==&quot;&lt;/code&gt; возвращает истину, если левый аргумент численно равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;=~&quot;&lt;/code&gt; связывает скалярное выражение с сопоставлением с образцом. Некоторые операции ищут или изменяют строку &lt;code&gt;$_&lt;/code&gt; по умолчанию. Этот оператор заставляет такую ​​операцию работать с другой строкой. Правильный аргумент - это шаблон поиска, подстановка или транслитерация. Левый аргумент - это то, что предполагается искать, заменять или транслитерировать вместо значения по умолчанию &lt;code&gt;$_&lt;/code&gt; . При использовании в скалярном контексте возвращаемое значение обычно указывает на успех операции. Исключениями являются подстановка ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ) и транслитерация ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ) с параметром &lt;code&gt;/r&lt;/code&gt; (неразрушающий), которые вызывают &lt;b&gt;r&lt;/b&gt;Возвратное значение будет результатом замены. Поведение в контексте списка зависит от конкретного оператора. См. Подробности в &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;разделе Операторы, &lt;/a&gt;&lt;a href=&quot;perlretut&quot;&gt;подобные кавычкам в Regexp,&lt;/a&gt; и примеры использования этих операторов.</target>
        </trans-unit>
        <trans-unit id="79a4495643878d498724e64ed7f89a0f4674d534" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt;. When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;s///&lt;/code&gt;) and transliteration (&lt;code&gt;y///&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot;&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;^&quot;&lt;/code&gt; возвращает свои операнды, объединенные по принципу XOR, побитно.</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">Двоичное &lt;code&gt;&quot;and&quot;&lt;/code&gt; возвращает логическое соединение двух окружающих выражений. Это эквивалент &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , за исключением очень низкого приоритета. Это означает, что он замыкается: правое выражение оценивается, только если левое выражение истинно.</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; возвращает -1, 0 или 1 в зависимости от того, является ли левый аргумент строковым меньшим, равным или большим, чем правый аргумент.</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;eq&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;ge&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке больше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;gt&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке больше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;le&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке меньше или равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;lt&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке меньше правого аргумента.</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">Двоичное &lt;code&gt;&quot;ne&quot;&lt;/code&gt; возвращает истину, если левый аргумент по строке не равен правому аргументу.</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">Двоичное &lt;code&gt;&quot;or&quot;&lt;/code&gt; возвращает логическое разделение двух окружающих выражений. Это эквивалентно &lt;code&gt;||&lt;/code&gt; за исключением очень низкого приоритета. Это делает его полезным для потока управления:</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;x&quot;&lt;/code&gt; - это оператор повторения. В скалярном контексте или если левый операнд не заключен в круглые скобки, он возвращает строку, состоящую из левого операнда, повторенного количество раз, указанное правым операндом. В контексте списка, если левый операнд заключен в круглые скобки или является списком, сформированным &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; , он повторяет список. Если правый операнд равен нулю или отрицателен (возникает предупреждение об отрицательном результате), он возвращает пустую строку или пустой список, в зависимости от контекста.</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;xor&quot;&lt;/code&gt; возвращает исключающее ИЛИ двух окружающих выражений. Он не может закоротить (конечно).</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;|&quot;&lt;/code&gt; возвращает свои операнды, объединенные по принципу ИЛИ.</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;||&quot;&lt;/code&gt; выполняет операцию логического ИЛИ короткого замыкания. То есть, если левый операнд истинен, правый операнд даже не оценивается. Скалярный контекст или контекст списка распространяется вниз до правого операнда, если он вычислен.</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">Двоичный &lt;code&gt;&quot;~~&quot;&lt;/code&gt; выполняет интеллектуальное сопоставление своих аргументов. Интеллектуальное сопоставление описано в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="474b37cbe0d6e0c72ec20c7e955273bab42d36ef" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;isa&lt;/code&gt; evaluates to true when the left argument is an object instance of the class (or a subclass derived from that class) given by the right argument. If the left argument is not defined, not a blessed object instance, nor does not derive from the class given by the right argument, the operator evaluates as false. The right argument may give the class either as a bareword or a scalar expression that yields a string class name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cc7ad1e48a139eed3a38cd085aae1011cbc98f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;x&lt;/code&gt; is the repetition operator. In scalar context, or if the left operand is neither enclosed in parentheses nor a &lt;code&gt;qw//&lt;/code&gt; list, it performs a string repetition. In that case it supplies scalar context to the left operand, and returns a string consisting of the left operand string repeated the number of times specified by the right operand. If the &lt;code&gt;x&lt;/code&gt; is in list context, and the left operand is either enclosed in parentheses or a &lt;code&gt;qw//&lt;/code&gt; list, it performs a list repetition. In that case it supplies list context to the left operand, and returns a list consisting of the left operand list repeated the number of times specified by the right operand. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">Бинарная обратная совместимость; эта функция является макросом, но также имеет реализацию &lt;code&gt;Perl_&lt;/code&gt; (которая экспортируется).</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">Бинарные дистрибутивы для некоторых проприетарных платформ можно найти в каталоге &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; . Поскольку они не являются частью стандартного дистрибутива, они могут и действительно отличаются от базового порта Perl во многих отношениях. Вам нужно будет проверить соответствующие примечания к выпуску, чтобы увидеть, в чем различия. Эти различия могут быть как положительными (например, расширения для функций конкретной платформы, которые не поддерживаются в исходной версии perl), так и отрицательными (например, могут быть основаны на менее актуальной версии исходного кода perl).</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">Двоичный инсталлятор также создает папку на рабочем столе с некоторыми полезными объектами.Если вам нужно изменить некоторые аспекты работы бинарного инсталлятора,не стесняйтесь редактировать файл</target>
        </trans-unit>
        <trans-unit id="b3b1f88d8a58f93a423339c57b3f74f2d820a432" translate="yes" xml:space="preserve">
          <source>Binary number &amp;gt; 0b11111111111111111111111111111111 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">Двоичные строки (строки байтов)</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">Связывающие операторы</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">Объединение нескольких утверждений в макро</target>
        </trans-unit>
        <trans-unit id="be19add4d0d70fd9e2b19a5940d1ed397561b92a" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;a href=&quot;http://man.he.net/man2/bind&quot;&gt;bind(2)&lt;/a&gt; does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee51bd7870301b5b50c94bd801894ab927735dc" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;code&gt;bind(2)&lt;/code&gt; does. Returns true if it succeeded, false otherwise. You should provide a packed address of the appropriate type for the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Привязывает сетевой адрес к сокету, как это делает bind (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Привязывает сетевой адрес к сокету, как это делает bind (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d4a984a59802112ea9e0afc9140f13f4e5333e8" translate="yes" xml:space="preserve">
          <source>Binmode</source>
          <target state="translated">Binmode</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Биррелл, Эндрю Д. Введение в программирование с помощью потоков. Digital Equipment Corporation, 1989, DEC-SRC Research Report # 35 онлайн по &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;адресу ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (настоятельно рекомендуется)</target>
        </trans-unit>
        <trans-unit id="36b5cf92c2fb97a05ef7bf770fab59d48c1cb050" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&quot;&gt;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a110cc2137a88f53fa983eabf18c6a369cdd6cc9" translate="yes" xml:space="preserve">
          <source>Bisecting</source>
          <target state="translated">Bisecting</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">Оператор дополнения битов ~ And vec()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">Битовые струны</target>
        </trans-unit>
        <trans-unit id="ba34e7ebde4a9f60d96348693e30b97a898d1671" translate="yes" xml:space="preserve">
          <source>Bit vector size &amp;gt; 32 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">Биты - это атомы в мире памяти. Доступ к отдельным битам может потребоваться либо как последнее средство, либо потому, что это наиболее удобный способ обработки ваших данных. Битовая строка (не) упаковка преобразуется между строками, содержащими серию из &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; символов, и последовательность байтов, каждая из которых содержит группу из 8 бит. Это почти так же просто, как кажется, за исключением того, что есть два способа записать содержимое байта в виде битовой строки. Давайте посмотрим на аннотированный байт:</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">Биты, которые &lt;b&gt;владелец&lt;/b&gt; файла устанавливает или снимает, чтобы разрешить или запретить доступ другим людям. Эти биты флага являются частью слова &lt;b&gt;режима,&lt;/b&gt; возвращаемого встроенной &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; когда вы спрашиваете о файле. В системах Unix вы можете проверить</target>
        </trans-unit>
        <trans-unit id="aca05ef0109989b493ae0975df5c4747401f63d8" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;stat&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">Битовые строки любого размера могут управляться поразрядными операторами ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">Прямо пропорционально или эксклюзивно,или</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">Операторы с битовой струной</target>
        </trans-unit>
        <trans-unit id="60dab14d1038a5ab6653c6e814d064d60e1699d8" translate="yes" xml:space="preserve">
          <source>Bitwise methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">Прямоточные операторы</target>
        </trans-unit>
        <trans-unit id="8a7fb7c64ed6d34c679867c6172b911e0f987e0b" translate="yes" xml:space="preserve">
          <source>Bitwise operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6124b539fbe18e72605192e10e84abc660b435" translate="yes" xml:space="preserve">
          <source>Bizarre SvTYPE [%d]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6569857bf0d6ff7a8e148a4adb3a9e8ee5c017ec" translate="yes" xml:space="preserve">
          <source>Bizarre copy of %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97eb984318634f0d968a3f61bf23fd2faf3f45b" translate="yes" xml:space="preserve">
          <source>Bizarre space in item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">Пустые линии между кусочками,которые делают разные вещи.</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">Благословенные Ссылки и объекты класса</target>
        </trans-unit>
        <trans-unit id="68214e18c0b1867aaa68202e63eba7567e9b30a9" translate="yes" xml:space="preserve">
          <source>Blessed objects are not directly representable in JSON, but &lt;code&gt;JSON::PP&lt;/code&gt; allows various ways of handling objects. See &lt;a href=&quot;#OBJECT-SERIALISATION&quot;&gt;&quot;OBJECT SERIALISATION&quot;&lt;/a&gt;, below, for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c23f408055d193d91f1b67442a45565695178a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;&lt;a href=&quot;#gv_stashpv&quot;&gt;&quot;gv_stashpv&quot;&lt;/a&gt;&lt;/code&gt;). The reference count of the SV is unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">Благословляет SV в указанный пакет. SV должен быть RV. Пакет должен быть обозначен его &lt;code&gt;gv_stashpv()&lt;/code&gt; см. Gv_stashpv () ). Счетчик ссылок SV не изменяется.</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="548174d374d3a6d330e0dce28420c09b6c8a9390" translate="yes" xml:space="preserve">
          <source>Blessing a shared item after it has been nested in another shared item does not propagate the blessing to the shared reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">Слепое прохождение va_list</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">Слепое использование вариадических макросов</target>
        </trans-unit>
        <trans-unit id="82dd2cdf36f9436d89f404454654ad3e53fd428d" translate="yes" xml:space="preserve">
          <source>Block</source>
          <target state="translated">Block</target>
        </trans-unit>
        <trans-unit id="3df7eee072ad8f186abf1b2d2565ea2787bb93b4" translate="yes" xml:space="preserve">
          <source>Block eval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">Имена блоков сопоставляются в составной форме, например &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; или &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . В отличие от большинства других свойств, только несколько имен блоков имеют краткое имя, определенное в Unicode. Но Perl действительно предоставляет (небольшой, больше не рекомендуемый) ярлык: вы можете сказать, например, &lt;code&gt;\p{In_Arrows}&lt;/code&gt; или &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75cda6989df1a079fcf560c9e780003cd931ab30" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt;. Unlike most other properties, only a few block names have a Unicode-defined short name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="bbaa0510707f42633a5b2810cc339df2222d09f5" translate="yes" xml:space="preserve">
          <source>Blocking =&amp;gt; BOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="91c2278276bfdf926da91f0d87d6f0041b36f310" translate="yes" xml:space="preserve">
          <source>Blocks versus Scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">Тело отчета. Если не указано в командной строке или в файле с параметром &lt;b&gt;-f&lt;/b&gt; , у вас будет возможность отредактировать сообщение.</target>
        </trans-unit>
        <trans-unit id="b1b26c9b3704fe7427bfc6aa57886af38bc8fd15" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Полужирный курсив (возможно, на самом деле наклонный) вариант шрифта фиксированной ширины. Pod :: Man не предполагает, что это у вас есть, и по умолчанию использует &lt;code&gt;CB&lt;/code&gt; . В некоторых системах (например, Solaris) этот шрифт доступен как &lt;code&gt;CX&lt;/code&gt; . Имеет значение только для вывода &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">Полужирный курсив (возможно, на самом деле наклонный) вариант шрифта фиксированной ширины. Pod :: Man не предполагает, что это у вас есть, и по умолчанию использует &lt;code&gt;CB&lt;/code&gt; . В некоторых системах (например, Solaris) этот шрифт доступен как &lt;code&gt;CX&lt;/code&gt; . Имеет значение только для вывода troff (1).</target>
        </trans-unit>
        <trans-unit id="feeb11edec497ca4f54c665a95df5130b4c829b2" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302306e8a29ac5f2d9ddbda14d6dbb86f08c19c5" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Полужирный вариант шрифта с фиксированной шириной. По умолчанию &lt;code&gt;CB&lt;/code&gt; . Имеет значение только для вывода &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">Полужирный вариант шрифта с фиксированной шириной. По умолчанию &lt;code&gt;CB&lt;/code&gt; . Имеет значение только для вывода troff (1).</target>
        </trans-unit>
        <trans-unit id="4826fec0f048131f813dc8e60e9509d935802a38" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21be102197e929754c4d027624958a11458b8256" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">Bool. Если этот параметр равен true, отсутствие необходимых модулей (или их правильных версий) будет фатальным. &lt;code&gt;perl Makefile.PL&lt;/code&gt; будет &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; вместо того , чтобы просто информировать пользователя о недостающих зависимостей.</target>
        </trans-unit>
        <trans-unit id="aa02db7b0e1536fcc3f6de1b2a7dcf01412dc0c6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;die&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">Булл.Если этот параметр верен,то предварительные условия будут распечатаны в stdout и MakeMaker выйдет.Формат вывода-оценочный хэш-ссылку.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="09eca632f0dfa4476bacf2f878b87c41a27eb16f" translate="yes" xml:space="preserve">
          <source>Boolean context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eefeb78b1690ec4b9fb5543382dba69c8c96d9" translate="yes" xml:space="preserve">
          <source>Boolean logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">логические методы</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">логические операторы</target>
        </trans-unit>
        <trans-unit id="55aef5e3c5e0b75d499308ca6279e82ab808182b" translate="yes" xml:space="preserve">
          <source>Boolean operators &lt;code&gt;is_zero()&lt;/code&gt;, &lt;code&gt;is_one()&lt;/code&gt;, &lt;code&gt;is_inf()&lt;/code&gt;, etc. return true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">Булевые варианты:</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">Логическое значение. Если false, отключает счетчик тестов &lt;code&gt;X/Y&lt;/code&gt; , который отображается во время выполнения тестов.</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">Булева,которая говорит MakeMaker,что он должен включать в себя правила,чтобы сделать perl.Это автоматически обрабатывается как переключатель в MakeMaker.Обычно он не нужен пользователю.</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">Булев.Атрибут для блокировки спуска в подкаталоги.</target>
        </trans-unit>
        <trans-unit id="09273e0b3502cd35874b01a3ba91c106f87a667f" translate="yes" xml:space="preserve">
          <source>Bootstrapping</source>
          <target state="translated">Bootstrapping</target>
        </trans-unit>
        <trans-unit id="62ac59b7255ce5ff9fee8ac49157bdd9bc4445e2" translate="yes" xml:space="preserve">
          <source>Bosnia and Herzegovina</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">Оба &amp;laquo;объекта&amp;raquo;, которые включены в класс &lt;code&gt;two_refs1&lt;/code&gt; , являются ссылками на ссылку на массив, таким образом, ссылаются на</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated">И #1,и #2 делают $data состоящим из полностью действительной строки UTF-8,но только #2 включает флаг UTF8.#1 эквивалентно:</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">Как &lt;code&gt;bstr()&lt;/code&gt; и &lt;code&gt;bsstr()&lt;/code&gt; а также автоматическое преобразование в строку с помощью перегрузки теперь удаляют начальный знак &quot;+&quot;. Старый код вернет &amp;laquo;+3&amp;raquo;, новый - &amp;laquo;3&amp;raquo;. Это должно согласовываться с Perl и заставить &lt;code&gt;cmp&lt;/code&gt; (особенно с перегрузкой) работать так, как вы ожидаете. Он также решает проблемы с &lt;code&gt;Test.pm&lt;/code&gt; и &lt;a href=&quot;../test/more&quot;&gt;Test :: More&lt;/a&gt; , которые преобразовывают аргументы в строку перед их сравнением.</target>
        </trans-unit>
        <trans-unit id="a620ebe99c93fe5ad5f0770d99e27217bee38fe8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as stringify via overload drop the leading '+'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">Оба &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; и &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; вернут &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; не находится в NFC (его NFC - это &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), а &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; находится в NFC.</target>
        </trans-unit>
        <trans-unit id="4a5a39017b338373b526416f145175959e75a080" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt;. &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt;), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dc99557ca052a1f52b6aa9fe01653c0b56cfaf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;cmp&lt;/code&gt; and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; operators perform the same comparison between terms (upgrading to a version object automatically). Perl automatically generates all of the other comparison operators based on those two. In addition to the obvious equalities listed below, appending a single trailing 0 term does not change the value of a version for comparison purposes. In other words &quot;v1.2&quot; and &quot;1.2.0&quot; will compare as identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">И &lt;code&gt;timelocal()&lt;/code&gt; и &lt;code&gt;timegm()&lt;/code&gt; квакают, если указаны даты за пределами поддерживаемого диапазона.</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">Оба &lt;code&gt;wrap()&lt;/code&gt; и &lt;code&gt;fill()&lt;/code&gt; возвращают одну строку.</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">Обе функции Perl ожидают объект в качестве первого параметра. В сгенерированном коде C ++ объект называется &lt;code&gt;THIS&lt;/code&gt; , и вызов метода будет выполняться для этого объекта. Итак, в коде C ++ методы blue () и set_blue () будут вызываться следующим образом:</target>
        </trans-unit>
        <trans-unit id="7be927e1ed4202312ce2dde8192f9556312f51fd" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt;, and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">Как YAML.pm,так и YAML::Syck способны десериализовать код.Поскольку для этого требуется оценка строки,что может представлять риск для безопасности,вы можете использовать эту опцию для включения или отключения десериализации кода с помощью CPAN::DeferredCode.(Замечание:Это не работает в соответствии с разделом 5.6).</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">И то,и другое плохо,и сломано,и непредсказуемо.Используйте макрос PTR2IV(),который делает это правильно.(Также есть PTR2UV(),PTR2NV(),INT2PTR()и NUM2PTR()).</target>
        </trans-unit>
        <trans-unit id="e8f3fbafa937e38c34348185c6cef931d0a050c2" translate="yes" xml:space="preserve">
          <source>Both colored() and many uses of the color constants will add the reset escape sequence after a newline. If a program mixes colored output to standard output with output to standard error, this can result in the standard error text having the wrong color because the reset escape sequence hasn't yet been flushed to the display (since standard output to a terminal is line-buffered by default). To avoid this, either set autoflush() on STDOUT or set $Term::ANSIColor::EACHLINE to &lt;code&gt;&quot;\n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">Оба проекта приветствуют добровольцев. Чтобы принять участие в дымовом тестировании самого perl, посетите &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt; . Чтобы начать дымовое тестирование модулей CPAN, посетите &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org / dist / CPAN-Reporter /&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae562d3087c6e461927df57072977056d07bc9d8" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;https://metacpan.org/release/Test-Smoke&quot;&gt;https://metacpan.org/release/Test-Smoke&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;https://metacpan.org/release/CPANPLUS-YACSmoke&quot;&gt;https://metacpan.org/release/CPANPLUS-YACSmoke&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/minismokebox&quot;&gt;https://metacpan.org/release/minismokebox&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/CPAN-Reporter&quot;&gt;https://metacpan.org/release/CPAN-Reporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d4c4d23a88d207ea9fa065963f476f871b153f" translate="yes" xml:space="preserve">
          <source>Both encode and decode methods propagate &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; when encoding and decoding the MIME charset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">Обе формы эквивалентны.</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">Обе функции возвращают эквивалентную информацию (например, &lt;code&gt;gettimeofday&lt;/code&gt; ), но с разными представлениями. Названия &lt;code&gt;NVtime&lt;/code&gt; и &lt;code&gt;U2time&lt;/code&gt; были выбраны в основном потому, что они не зависят от операционной системы. ( &lt;code&gt;gettimeofday&lt;/code&gt; ориентирован на Unix, хотя на некоторых платформах, таких как Win32 и VMS, есть эмуляции для него.)</target>
        </trans-unit>
        <trans-unit id="5c4e6f175302e55e83c34f1bf1849d831a9de257" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt;) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">И install(),и uninstall()специфичны для способа,которым ExtUtils::MakeMaker управляет установкой и деинсталляцией perl модулей.Они не предназначены для общего использования.</target>
        </trans-unit>
        <trans-unit id="5627699dd1ad2924464995985beca5c6cf35ef97" translate="yes" xml:space="preserve">
          <source>Both methods will prevent the import() method from firing and exporting the &lt;code&gt;qv()&lt;/code&gt; sub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">Принимаются как числовые,так и строковые значения,но учтите,что строковые значения чувствительны к регистру.По умолчанию эта настройка имеет значение &quot;RANDOM&quot; или 1.</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">Оба приведенных выше символа соответствуют символам &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , но &lt;code&gt;\x09&lt;/code&gt; выглядит так, как будто это могло быть ошибка, поэтому для нее выдается предупреждение (как &lt;code&gt;re 'strict'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6cba8f2c40b0b7e7464484e646fc77656ccf2181" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt;, ... &lt;code&gt;\N{U+08}&lt;/code&gt;, &lt;code&gt;\N{U+09}&lt;/code&gt;, but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt;) for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19034866ba0e5cf040b7023a16a969fddf08ed53" translate="yes" xml:space="preserve">
          <source>Both of the provided scalars are already compiled as regular expressions and do not contain either anchors or implicit groupings, so they can be included in your own regular expressions freely. For example, consider the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fc8a94496c661c5e9f86f3352074c1b6a4eef2" translate="yes" xml:space="preserve">
          <source>Both of these methods will produce similar version objects, in that the default stringification will yield the version &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt; only if required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a103cc718ae6b6f4898e4597463858c0b08dfa7" translate="yes" xml:space="preserve">
          <source>Both or neither range ends should be Unicode in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">Доступ как для чтения,так и для записи.</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">Обе программы возвращают ссылку на управляемый хэш.</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">Оба обозначают текст в стиле монопространства (c[ода]),состоящий из &quot;$x&quot;,одного пробела,&quot;?&quot;,одного пробела,&quot;:&quot;,одного пробела,&quot;$z&quot;.Разница состоит в том,что в последнем,с кодом S,эти пробелы не являются &quot;нормальными&quot;,а являются неразрывными пробелами.</target>
        </trans-unit>
        <trans-unit id="ed699d8c766ffac9fc7609020189bb30a788c2d9" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">И stringify, и bstr () теперь отбрасывают ведущий &quot;+&quot;. Старый код вернет &amp;laquo;+1,23&amp;raquo;, новый - &amp;laquo;1,23&amp;raquo;. См. Документацию в &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; для объяснения и подробностей.</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">Оба стиля работают либо с объектами,либо с печатными шрифтами реальных файловых ручек.(При некоторых обстоятельствах они также могут работать со строками,но это рискованно).</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">Обе подпрограммы здесь вызываются в скалярном контексте,в то время как внутри:</target>
        </trans-unit>
        <trans-unit id="88a5a602af253e21581322ee44c47e54f2ad5148" translate="yes" xml:space="preserve">
          <source>Both sysread() and recv() currently use only the &lt;code&gt;:utf8&lt;/code&gt; flag for the stream, ignoring the actual layers. Since sysread() and recv() do no UTF-8 validation they can end up creating invalidly encoded scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">Оба параметра &lt;code&gt;$key&lt;/code&gt; и &lt;code&gt;$value&lt;/code&gt; будут установлены на пару ключ / значение, прочитанную из базы данных.</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">И функция &lt;code&gt;FETCH&lt;/code&gt; ing, и функции &lt;code&gt;EXISTS&lt;/code&gt; имеют одинаковую сигнатуру: аргументы - &lt;code&gt;$key, $data&lt;/code&gt; ; $ data - это то же значение, что и аргумент во время tie () ing. Обе функции должны возвращать пустой список, если значение не существует. Если функция &lt;code&gt;EXISTS&lt;/code&gt; отличается от функции &lt;code&gt;FETCH&lt;/code&gt; ing, она должна вернуть значение ИСТИНА в случае успеха. Функция &lt;code&gt;FETCH&lt;/code&gt; ing должна возвращать предполагаемое значение, если ключ действителен.</target>
        </trans-unit>
        <trans-unit id="26d9da8f5ad7069914e20430c62d4e761633b2e9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt;ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt;; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt;ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt;ing function should return the intended value if the key is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">Оба экземпляра &lt;code&gt;\p&lt;/code&gt; всегда предполагают, что действуют правила Unicode. На платформах ASCII это означает, что они предполагают, что кодовые точки от 128 до 255 - это Latin-1, а это означает, что использовать их в соответствии с правилами локали неразумно, если только локаль не гарантированно будет Latin-1 или UTF-8. Напротив, классы символов POSIX полезны в соответствии с правилами локали. На них влияют действующие правила, а именно:</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">Оба метода &lt;code&gt;filter&lt;/code&gt; используемые с</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Фильтры Store и Fetch управляют &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fb703f0b0c3a852ad76e2cb00f9c501f48f8ec4" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">Обе функции могут импортировать указанные функции.</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">Как основной процесс,так и любые дочерние процессы вилки имеют одинаковые файловые дескрипторы STDIN,STDOUT и STDERR.Если оба процесса попытаются получить доступ к ним одновременно,могут произойти странные вещи.Вы также можете захотеть закрыть или открыть заново файловые дескрипторы для дочернего процесса.Вы можете обойти это,открыв канал с помощью open(),но на некоторых системах это означает,что дочерний процесс не может пережить родителя.</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">И основной процесс, и фоновый (&amp;laquo;дочерний&amp;raquo; процесс) используют одни и те же дескрипторы файлов STDIN, STDOUT и STDERR. Если оба попытаются получить к ним доступ одновременно, могут произойти странные вещи. Вы можете закрыть или снова открыть их для ребенка. Вы можете обойти это, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; канал (см. &lt;a href=&quot;functions/open&quot;&gt;Open&lt;/a&gt; ), но в некоторых системах это означает, что дочерний процесс не может пережить родительский.</target>
        </trans-unit>
        <trans-unit id="f7d92bf0fef8c6d376360d3e96b538b59d69f577" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;open&lt;/code&gt;ing a pipe (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89a0af2055da02fc83d8afed6e917b5cc66d525" translate="yes" xml:space="preserve">
          <source>Both the native cc and gcc seem to consume lots of memory when building Perl. toke.c is a known trouble spot when optimizing: 256 megabytes of data section seems to be enough. Another known trouble spot is the mktables script which builds the Unicode support tables. The default setting of the process data section in Tru64 should be one gigabyte, but some sites/setups might have lowered that. The configuration process of Perl checks for too low process limits, and lowers the optimization for the toke.c if necessary, and also gives advice on how to raise the process limits (for example: &lt;code&gt;ulimit -d 262144&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">Как специальные,так и обычные картографические отображения хранятся в</target>
        </trans-unit>
        <trans-unit id="e87bc450de2089bfd62a5bd96629fc5b32ff6be9" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">Оба этих объявления XS соответствуют типу &lt;code&gt;char*&lt;/code&gt; C, но имеют разную семантику, см &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;. Унарный оператор &amp;amp;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">Оба этих метода автоматически вставляют &lt;code&gt;&quot;:full&quot;&lt;/code&gt; в качестве первого аргумента (если не указан другой аргумент), и вы также можете явно указать &lt;code&gt;&quot;:full&quot;&lt;/code&gt; , например</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">Обе эти проблемы можно вылечить.Скажем,если мы хотим перегрузить хэш-рассылку на ссылку на объект,которым является</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">Как имя дня (день),так и имя месяца (месяц)позволяют пропустить в списке для индексации названия дней.Это может быть полезно,если вам необходимо реализовать некую форму локализации без фактической установки или использования локалей.</target>
        </trans-unit>
        <trans-unit id="7251257be5507cef24fe3fb21a50fe67755c29b8" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales. Note that this is a global override and will affect all Time::Piece instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">Подпрограмма декодирования UTF-8 нижнего уровня. Возвращает значение собственной кодовой точки первого символа в строке &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , которая, как предполагается, имеет кодировку UTF-8 (или UTF-EBCDIC) и не длиннее &lt;code&gt;curlen&lt;/code&gt; байтов; &lt;code&gt;*retlen&lt;/code&gt; (если &lt;code&gt;retlen&lt;/code&gt; не NULL) будет установлена ​​длина этого символа в байтах.</target>
        </trans-unit>
        <trans-unit id="dfa04ba4cca5e78047dc43990129bc3ae3f19bff" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;s&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">Границы слогов Хангула определяются в соответствии с прилегающим поведением Джамо в</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Бойкин,Джозеф,Дэвид Киршен,Алан Лангерман и Сьюзан ЛоВерсо.Программирование под Mach.Эддисон-Уэсли,1994,ISBN 0-201-52739-1.</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">Приготовьтесь к благодарности,сообщениям об ошибках,письмам ненависти и спаму,приходящим в результате предыдущего шага.Ни одно доброе дело не должно остаться безнаказанным!</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">Фигурные скобки необходимы для ссылки на именованные группы захвата, но не обязательны для групп с абсолютными или относительными номерами. Фигурные скобки более безопасны при создании регулярного выражения путем объединения меньших строк. Например, если у вас &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;$a&lt;/code&gt; содержит &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , а &lt;code&gt;$b&lt;/code&gt; содержит &lt;code&gt;&quot;37&quot;&lt;/code&gt; , вы получите &lt;code&gt;/\g137/&lt;/code&gt; что, вероятно, не то, что вы планировали.</target>
        </trans-unit>
        <trans-unit id="18fd4ec0e937de91c70828b19eb3454f88d75941" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">Нотация кронштейна-важнейшая особенность Locale::Maketext.Я имею в виду Bracket Notation,чтобы обеспечить замену использования форматирования sprintf.Все,что вы делаете с нотацией в скобках,может быть сделано с помощью подблока,но нотация в скобках предназначена для того,чтобы быть более лаконичной.</target>
        </trans-unit>
        <trans-unit id="bb9b16ff2deefe21cce7105f1030ffe04c9ef94b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">Нотация в скобках похожа на систему миниатюрных &amp;laquo;шаблонов&amp;raquo; (в смысле &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt; , а не в смысле шаблонов C ++), где обычный текст передается в основном как есть, но текст в специальных областях интерпретируется особым образом. В скобках вы используете квадратные скобки (&amp;laquo;[...]&amp;raquo;), а не фигурные скобки (&amp;laquo;{...}&amp;raquo;), чтобы отметить разделы, которые интерпретируются особым образом.</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">Нотация в скобках обсуждается в следующем разделе.Обратите внимание,что попытка скомпилировать строку в нотацию в квадратных скобках может привести к возникновению исключения,если строка не является синтаксически корректной (скажем,не балансируя скобки справа).</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">Группы в квадратных скобках,которые пусты или состоят только из пробельных символов,игнорируются.(Примеры:&quot;[]&quot;,&quot;[]&quot; или[и а]с возвратами и/или закладками и/или пробелами между ними.</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">Классы с заключенными в скобки символами</target>
        </trans-unit>
        <trans-unit id="1d6defc184cd831ef1a40a992a7bc00f4a08d7aa" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the /xx pattern modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56159ead51e4e16a6e6e36a9eba26b713462d135" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the &lt;code&gt;/xx&lt;/code&gt; pattern modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">Классы символов в квадратных скобках представлены структурами &lt;code&gt;regnode_charclass&lt;/code&gt; , которые имеют четырехбайтовый аргумент, а затем 32-байтовое (256-битное) битовое отображение, указывающее, какие символы в диапазоне Latin1 включены в класс.</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">Скобки вокруг символической ссылки могут просто служить для того,чтобы изолировать идентификатор или имя переменной от остальной части выражения,точно так же,как они всегда есть внутри строки.Например,</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">Кронштейны должны быть сбалансированы - каждый открытый кронштейн должен иметь один соответствующий закрывающий кронштейн, и наоборот. Итак, все это &lt;b&gt;недействительно&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">Брэд Эпплтон &amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Брэд Эпплтон &amp;lt;bradapp@enteract.com&amp;gt; (начальная версия), Марек Рушал &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6593228df02466d50b8cc0c36e813c08ba422fcb" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, Marc Green &amp;lt;marcgreen@cpan.org&amp;gt; (port to Pod::Simple) Ricardo Signes &amp;lt;rjbs@cpan.org&amp;gt; (more porting to Pod::Simple) Karl Williamson &amp;lt;khw@cpan.org&amp;gt; (more porting to Pod::Simple)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Брэд Эпплтон &amp;lt;bradapp@enteract.com&amp;gt;, Марек Рушаль &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ace391da91b3b622751d8ebf145fd4091f241ba4" translate="yes" xml:space="preserve">
          <source>Brad Gilbert &amp;lt;bgills@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae43dcfe840a5e3a18a13f5b3acd9cb0f221ef8" translate="yes" xml:space="preserve">
          <source>Brandon Browning,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">Брэндон Л. Блэк, &amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fb6fe57c36bfedd5ff6f16a948fc45d01c7d083" translate="yes" xml:space="preserve">
          <source>Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37497aa5a2272c49714aee1b07e8edf973a95f59" translate="yes" xml:space="preserve">
          <source>Brazil</source>
          <target state="translated">Brazil</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">Выйти из &lt;code&gt;given()&lt;/code&gt; блока.</target>
        </trans-unit>
        <trans-unit id="70e84e284b7238bd647c1d2ad9dae3dcf040b2c5" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">&lt;code&gt;autouse&lt;/code&gt; выполнение вашей программы, если модуль, который вы автоматически запускаете, имеет некоторую инициализацию, которую он ожидает сделать раньше.</target>
        </trans-unit>
        <trans-unit id="848f64a4802a4e63379bfcaf66c37f0f07a8afee" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt;d has some initialization which it expects to be done early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">Разбивайте текст на строки в соответствии с правилами Юникода.</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">Разбейте код многоразового использования на один или несколько отдельных файлов модуля.</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Breakable линии отмечены &lt;code&gt;:&lt;/code&gt; . Строки с точками останова помечены буквой &lt;code&gt;b&lt;/code&gt; , а строки с действиями - &lt;code&gt;a&lt;/code&gt; . Строка, которая должна быть выполнена, помечена &lt;code&gt;==&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cca55190538278526fdb090660eae35486629fc" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt;. Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt;. The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cb8429b43020f4d84d456449c4c5b228dde417" translate="yes" xml:space="preserve">
          <source>Breaking gettext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">Выход в свет</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">Разрывает связь между файлом DBM и хэшем.</target>
        </trans-unit>
        <trans-unit id="fece5a66de93443d7bff991c12beae4eb8074f61" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">Разрывает связь между переменной и пакетом. (См. &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;Связь&lt;/a&gt; .) Не действует, если переменная не привязана.</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">У Brent Powers есть модуль &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; который был разработан для работы с Memoize и обеспечивает истечение срока действия наименее используемых данных. В кэше хранится фиксированное количество записей, и когда поступают новые данные, срок действия наименее недавно использованных данных истекает. См. &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;Http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c27cf707cf417ff0a776233c5044d0c0f1f7ca1a" translate="yes" xml:space="preserve">
          <source>Brian Fraser &amp;lt;fraserbn@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f48c0d1bc27a1a6d3322c34a40dc48ed4836827" translate="yes" xml:space="preserve">
          <source>Brian Mowrey &amp;lt;brian@drlabs.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">Вкратце, &lt;code&gt;/l&lt;/code&gt; устанавливает набор символов для любого &lt;b&gt;L&lt;/b&gt; ocale, действующего во время выполнения сопоставления с образцом.</target>
        </trans-unit>
        <trans-unit id="617a3fbf545ee5333943d4e71b255277bef3b51a" translate="yes" xml:space="preserve">
          <source>Broadcast =&amp;gt; BOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">В широком смысле,выполнение сопоставления строки с шаблоном включает в себя следующие шаги:</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">Разрушенные системы</target>
        </trans-unit>
        <trans-unit id="1def5ba77699f04961452989de376f438210ae2b" translate="yes" xml:space="preserve">
          <source>Bucket Order Perturbance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93b6657484eea5e944049ac0b3ddce1a19d87f5" translate="yes" xml:space="preserve">
          <source>Buffer overflow in prime_env_iter: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">Буферный скаляр, содержащий рассматриваемый в данный момент фрагмент текста, который в настоящее время обрабатывается. Это всегда простой скаляр строки (для которого &lt;code&gt;SvPOK&lt;/code&gt; верен). Он не предназначен для использования в качестве скаляра обычными скалярными средствами; вместо этого обращайтесь к буферу напрямую с помощью переменных-указателей, описанных ниже.</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">Сообщения об ошибках и другие отзывы приветствуются.</target>
        </trans-unit>
        <trans-unit id="4a6ed58e35768beb4922face36916e3eb34ceb32" translate="yes" xml:space="preserve">
          <source>Bug reports should be submitted to the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;. The &lt;b&gt;perlbug@perl.org&lt;/b&gt; address no longer automatically opens tickets. You can use this tool to compose your report and save it to a file which you can then submit to the issue tracker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">Отчеты об ошибках, патчи и нытье, предоставленные множеством людей - всем спасибо! Особая благодарность Майклу Шверну &amp;lt;schwern@envirolink.org&amp;gt; за то, что он уверил меня, что &amp;amp; nested_quotewords () был бы полезен, и Джеффу Фридлу &amp;lt;jfriedl@yahoo-inc.com&amp;gt; за то, что он сказал мне не беспокоиться о проверке ошибок (вроде как - ты должен был быть там).</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Исправление ошибок выполнено Питером Джоном Экламом &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</target>
        </trans-unit>
        <trans-unit id="238715da3b418db89372b9015297a37b9b381344" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2016.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="60757698bb42548c3dda76e0d4ec377b0dd06d65" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though GitHub: &lt;a href=&quot;https://github.com/Test-More/test-more/issues&quot;&gt;https://github.com/Test-More/test-more/issues&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">Об ошибках (и запросах на новые функции) можно сообщать автору через систему CPAN RT: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">Ошибки/Особенности Запросы</target>
        </trans-unit>
        <trans-unit id="58d170e283eb8eb2d13abdce7bd1aa5026377f10" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local/issues&quot;&gt;https://github.com/houseabsolute/Time-Local/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a450dc1be8865ad9e376ea507387ccd3c0e65886" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-File-Temp@rt.cpan.org&quot;&gt;bug-File-Temp@rt.cpan.org&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147820deb7b5b2f1e33d540237db5f728a826fed" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-Module-Metadata@rt.cpan.org&quot;&gt;bug-Module-Metadata@rt.cpan.org&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">Ошибки,которые ты не планируешь исправлять.:-)</target>
        </trans-unit>
        <trans-unit id="bbd80cf7e2ded5efed8f4ee9151ab57a8ab66392" translate="yes" xml:space="preserve">
          <source>Build</source>
          <target state="translated">Build</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">Построить аномалии с Perl на OS/390</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">Построить FAQ</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">Построить Предпосылки для Perl на AmigaOS</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">Создайте итератор, который находит файлы distroprefs в дереве под заданным каталогом. В пределах дерева каталоги, совпадающие с &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f5e8d7b401e7067eefc5a283830fcc846d1ee9e" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;m/^[._]/&lt;/code&gt; are pruned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f0d013521af98c935739685e85fd389eb57d10" translate="yes" xml:space="preserve">
          <source>Build hash based classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">Инструкции по &lt;a href=&quot;perlos2&quot;&gt;сборке&lt;/a&gt; для OS / 2, perlos2</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">Инструкции по &lt;a href=&quot;perlwin32&quot;&gt;сборке&lt;/a&gt; Win32 в perlwin32 или в среде Cygnus в &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">Построить man-страницы тоже</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">Построить систему</target>
        </trans-unit>
        <trans-unit id="857fee8f38d36d4d66b3ca310ad74ff4223ccbe4" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the UTF-8 encoded string &lt;code&gt;spv&lt;/code&gt;, length &lt;code&gt;len&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &lt;code&gt;&quot;...&quot;&lt;/code&gt; will be appended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">Создайте в скалярном &lt;code&gt;dsv&lt;/code&gt; отображаемую версию скалярного &lt;code&gt;sv&lt;/code&gt; , причем отображаемая версия имеет &lt;code&gt;pvlim&lt;/code&gt; не более pvlim байтов (если она длиннее, то остальная часть усекается и к ней будет добавлено &quot;...&quot;).</target>
        </trans-unit>
        <trans-unit id="46af0313d23f0c460bfa1f3a9e5387975e8b2b74" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">Создайте в скалярном &lt;code&gt;dsv&lt;/code&gt; отображаемую версию строки &lt;code&gt;spv&lt;/code&gt; , длина &lt;code&gt;len&lt;/code&gt; , причем отображаемая версия имеет &lt;code&gt;pvlim&lt;/code&gt; не более pvlim байтов (если она длиннее, то остальная часть усекается, а к ней добавляется &quot;...&quot;).</target>
        </trans-unit>
        <trans-unit id="c6bd3f51881e4d26f104fbcd7a9347aa8d6d5282" translate="yes" xml:space="preserve">
          <source>Build, Configure, Make, Install</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">Сборка,тестирование,установка Perl на OS/390</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Класс сборщика для Windows-платформ</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">Строительство 32-битного Perl в Ирикс</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">Строительство 64-битного Perl в Ирикс</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">Строительные динамические расширения на AIX</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">Создание динамических расширений в AIX &amp;lt;5L</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">Строительные динамические расширения на HP-UX</target>
        </trans-unit>
        <trans-unit id="e3d2578989b066f6d4e0e3d492f28b294aef6801" translate="yes" xml:space="preserve">
          <source>Building Extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">Строительство модулей не XS на DOS</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">Строительный Перл для WinCE</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">Строительство Perl на DOS</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">Построение предпосылок для Perl на DOS</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">Построение модулей XS на DOS</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">Сборка 64-битного gcc на PA-RISC из исходников возможна только при наличии компилятора HP C-ANSI C или уже работающего 64-битного двоичного gcc.Наилучшая производительность для perl достигается с помощью родного компилятора HP.</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">Построение бинарного распределения</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">Строительство регепа</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">Строительство LP64 perl</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">Строительный обычай</target>
        </trans-unit>
        <trans-unit id="38b3b94607428da1a192459760b9b24f29336537" translate="yes" xml:space="preserve">
          <source>Building custom .EXE files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">Создание пользовательских _.EXE_файлов</target>
        </trans-unit>
        <trans-unit id="e10bbd8c13474666bee2a919ca9d0cf777bfbdb2" translate="yes" xml:space="preserve">
          <source>Building debugging-enabled binaries (with -g or -g3) will increase the chance of getting these errors. Prevent -g if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60333d2c51f8933ea40f3711d31effe77527e1a4" translate="yes" xml:space="preserve">
          <source>Building perl at older commits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">Сборка должна вестись по-разному в зависимости от того,присутствует ли уже установленная вами версия perl и используется ли она в вашей системе,или же это новая версия,которая еще не используется.Описание ниже предполагает,что версия является новой,поэтому устанавливайте ее DLL и</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">Здание с резьбой в Ирикс</target>
        </trans-unit>
        <trans-unit id="c882cff5cf66c8bc0ee9d0ac391aee6b3e4faba4" translate="yes" xml:space="preserve">
          <source>Buildtype.bat</source>
          <target state="translated">Buildtype.bat</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">Встроенные атрибуты</target>
        </trans-unit>
        <trans-unit id="03c641eb4ff3905fcf16d5ff9fd329806e0d8127" translate="yes" xml:space="preserve">
          <source>Built-in Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">Сборка операторов и функций</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">Типы сборки включают в себя:</target>
        </trans-unit>
        <trans-unit id="5c77726358c5daf98ad9cdccd0882bca0f718b88" translate="yes" xml:space="preserve">
          <source>Bulgaria</source>
          <target state="translated">Bulgaria</target>
        </trans-unit>
        <trans-unit id="572f7127eed71e662d147110ecd2618b7d80c972" translate="yes" xml:space="preserve">
          <source>Bultibuffer count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c511a735d99d5e1aad2b7d21a4ed9e5dff3aca" translate="yes" xml:space="preserve">
          <source>Bumped version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">Код в комплекте::Locale</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">Пакеты специально обработаны в пакете CPAN.Если вы скажете 'установите Bundle::Tkkit' (если такой пакет существует),CPAN установит все модули в секции CONTENTS в pod.Вы можете установить свои собственные пакеты локально,поместив соответствующий файл пакета куда-нибудь в путь @INC.Команда autobundle(),доступная в интерфейсе оболочки,сделает это за вас,включив все установленные в данный момент модули в файл пакета снимков.</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">Но (в обозримом будущем),Pod не предоставляет авторам Pod никакого способа,чтобы отличить,какая группировка подразумевается под вышеуказанной &quot;=пункт&quot;-кластерной структурой.Поэтому форматировщики должны отформатировать его таким образом:</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">Но я считаю,что в какой-то степени это отвлекает меня от работы,чтобы заставить работать основной код-не говоря уже о том,что мне часто приходится несколько раз поиграть с программой,прежде чем я смогу решить,какая именно формулировка мне нужна в сообщениях (что в данном случае потребовало бы от меня смены трех строк кода:вызова maketext с этим ключом,а затем двух строк в ThisProject/I18N/en.pm).</target>
        </trans-unit>
        <trans-unit id="68ec332e5b845e28e04fd0941baf17f046ea1744" translate="yes" xml:space="preserve">
          <source>But Perl treats &lt;code&gt;\n&lt;/code&gt; as the start- and end-line delimiter, whereas Unicode specifies more characters that should be so-interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">Но намерение Unicode состоит в том, чтобы унифицировать существующие стандарты и методы набора символов, и несколько ранее существовавших стандартов содержат отдельные символы, которые означают то же самое, что и некоторые из этих комбинаций, например ISO-8859-1, в котором их довольно много. Например, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; уже была в этом стандарте, когда появился Юникод. Поэтому Unicode добавил его в свой репертуар как этот единственный символ. Но этот символ считается Unicode эквивалентным последовательности, состоящей из символа &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; за которым следует символ &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc372f6b713e0d837f8396fac1cbf07d86470ffa" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">Но предупреждение в порядке.При следующем использовании для создания копии числа будет сделана только мелкая копия.</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">Но любые модификаторы все равно будут применяться ко всем компонентам:</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">Но,как ты можешь себе представить,это может стать довольно грубым для читателя.</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">Но присвоение веса унифицированным идеограммам CJK в &lt;code&gt;table&lt;/code&gt; или &lt;code&gt;entry&lt;/code&gt; по-прежнему действует. Если &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; передается явно как значение для этого ключа, веса для унифицированных идеографов CJK обрабатываются как неопределенные. Однако, когда &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; не имеет особого значения.</target>
        </trans-unit>
        <trans-unit id="3d36eb62a097e882438bf9a3637e15c6d9e493e5" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; undef)&lt;/code&gt; has no special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">Но будьте уверены, что &lt;code&gt;ok&lt;/code&gt; вызывается ровно столько раз в первом блоке, сколько &lt;code&gt;skip&lt;/code&gt; вызывается во втором блоке.</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">Но и то,и другое медленнее,чем присвоение пустого списка или неуточнение %HASH или @ARRAY,что является обычным способом опорожнения агрегата:</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">Но не беспокойте его,он на пенсии.</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">Но не ставьте</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">Но из-за неустранимой ошибки (ее исправление может привести к поломке множества существующих модулей CPAN) в файле typemap, счетчик ссылок &lt;code&gt;AV *&lt;/code&gt; не уменьшается должным образом. Таким образом, указанный выше XSUB будет вызывать утечку памяти при каждом вызове. Та же проблема существует для &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; и &lt;code&gt;SVREF&lt;/code&gt; (что указывает на скалярную ссылку, а не на общий &lt;code&gt;SV *&lt;/code&gt; ). В коде XS на perls, начиная с perl 5.16, вы можете переопределить карты типов для любого из этих типов с помощью версии, которая имеет правильную обработку refcount. В разделе &lt;code&gt;TYPEMAP&lt;/code&gt; сделайте</target>
        </trans-unit>
        <trans-unit id="3bda93cc7a8a89f24895e1ee457675fc5ec79f7f" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt;, &lt;code&gt;CV *&lt;/code&gt;, and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt;). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">Но проще всего использовать этот символ как литерал, например &lt;code&gt;&quot;A&quot;&lt;/code&gt; или &lt;code&gt;&quot;%&quot;&lt;/code&gt; ; если это не так конкретно, вы можете использовать use &lt;code&gt;\N{}&lt;/code&gt; , если побочные эффекты не вызывают проблем. Просто укажите все символы в шестнадцатеричном &lt;code&gt;\xZZ&lt;/code&gt; , используя &lt;code&gt;\N{U+ZZ}&lt;/code&gt; вместо \ xZZ . &lt;code&gt;\N{}&lt;/code&gt; - это имя Unicode, поэтому оно всегда дает вам символ Unicode. &lt;code&gt;\N{U+41}&lt;/code&gt; - это символ, у которого кодовая точка Unicode равна &lt;code&gt;0x41&lt;/code&gt; , следовательно, это &lt;code&gt;'A'&lt;/code&gt; на всех платформах. Побочные эффекты:</target>
        </trans-unit>
        <trans-unit id="2d7d9f0491fdf8f26d2ae8e336ebfac29d297c05" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt;, to use that; if not so specificable, you can use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt;. &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt;, hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">Но fail_handler_auto,вместо того,чтобы умереть или что-то в этом роде,компилирует $key,кэшируя его в</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">Но не бойтесь, есть простое решение. Модуль &lt;code&gt;Sub::Name&lt;/code&gt; проникнет внутрь perl и назначит имя анонимной подпрограмме за вас. Просто сделайте это:</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">Но для &amp;laquo;директории&amp;raquo;, вы хотите &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; , так что наш элементарный &lt;code&gt;quant&lt;/code&gt; метод не считает , что множественное число от &amp;laquo;каталога&amp;raquo; является &amp;laquo;directorys&amp;raquo;. И вы можете обнаружить, что вывод может звучать лучше, если вы укажете отрицательную форму, например:</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">Но пока давайте рассмотрим общие вопросы,общие для всех этих типов структур данных.</target>
        </trans-unit>
        <trans-unit id="44e2925861f8472f51f5341cbaaf661343ddc11e" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt;/&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">Но для других языков (как подробно обсуждается в &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13&lt;/a&gt; ), простой &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; недостаточно. Для особо проблемных славянских языков вам может понадобиться метод, который вы предоставите с числом, формой цитирования существительного для количественной оценки, а также падежом и полом, которые синтаксис предложения проецирует на это место существительного. Затем метод будет отвечать за определение того, какое грамматическое число эта цифра проецирует на свою именную фразу, и с каким падежем и полом оно может замещать нормальный падеж и род; а затем он будет искать существительное в лексиконе, предоставляя все необходимые изменяемые формы.</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">Но для некоторых процессоров / форматов это нелегко контролировать; как и в примере HTML, поведение нескольких неоднозначных &amp;lt;a name = &quot;</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">Но,как правило,блок ограничивается фигурными скобками,также известными как фигурные скобки.Мы назовем эту синтаксическую конструкцию BLOCK.</target>
        </trans-unit>
        <trans-unit id="12fcc42a7dd22316cac44e40d51daa68deca033b" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK. Because enclosing braces are also the syntax for hash reference constructor expressions (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;), you may occasionally need to disambiguate by placing a &lt;code&gt;;&lt;/code&gt; immediately after an opening brace so that Perl realises the brace is the start of a block. You will more frequently need to disambiguate the other way, by placing a &lt;code&gt;+&lt;/code&gt; immediately before an opening brace to force it to be interpreted as a hash reference constructor expression. It is considered good style to use these disambiguating mechanisms liberally, not only when Perl would otherwise guess incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">Но если клиент попросит &quot;i-Mingo&quot; или &quot;x-mingo&quot;,или &quot;Fr&quot;,то поиск в %greetings провалится.Это неправильная вещь.</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">Но если документ начнется:</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">Но если вы подкласс Pod::Simple::Methody,то он сделает это,когда увидит &quot;=head1 Hi there&quot;:</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">Но если ты попробуешь это:</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">Но если вам нужны вложенные вхождения от &lt;code&gt;START&lt;/code&gt; до &lt;code&gt;END&lt;/code&gt; , вы столкнетесь с проблемой, описанной в вопросе в этом разделе о сопоставлении сбалансированного текста.</target>
        </trans-unit>
        <trans-unit id="3edd5ad7f10118d3c50f146510574f8277f3c749" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt;, you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">Но если вы пишете код, который использует &lt;code&gt;\005&lt;/code&gt; для обозначения TAB или &lt;code&gt;\xC1&lt;/code&gt; для обозначения &amp;laquo;A&amp;raquo;, или &lt;code&gt;\xDF&lt;/code&gt; для обозначения &amp;laquo;&amp;yuml;&amp;raquo; (маленький &lt;code&gt;&quot;y&quot;&lt;/code&gt; с тремой), то ваш код вполне может работать на вашем Платформа EBCDIC, но не на платформе ASCII. Это нормально, если никто никогда не захочет запускать ваш код на платформе ASCII; но предвзятость в этом документе будет заключаться в написании кода, переносимого между системами EBCDIC и ASCII. Опять же, если каждый символ, который вам нужен, легко вводится с вашей клавиатуры, вам не нужно ничего знать об ASCII, но многие клавиатуры не позволяют вам напрямую вводить, скажем, символ &lt;code&gt;\xDF&lt;/code&gt; , поэтому вам нужно указать его косвенно, например, используя &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape-последовательность. В таких случаях проще всего узнать что-нибудь о наборах символов ASCII / Unicode. Если вы знаете, что маленький &amp;laquo;&amp;yuml;&amp;raquo; - это &lt;code&gt;U+00FF&lt;/code&gt; , то вы можете вместо этого указать его как &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , и компьютер автоматически переведет его в &lt;code&gt;\xDF&lt;/code&gt; на вашей платформе и оставьте его как &lt;code&gt;\xFF&lt;/code&gt; на ASCII. Или вы можете указать его по имени, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; и не нужно знать числа. Любой способ работает, но требует знания Юникода.</target>
        </trans-unit>
        <trans-unit id="8c5b9a3f892143e75b663a18f94ea6753bbb8def" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be towards writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt;, so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt;, then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt;, and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but both require familiarity with Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">Но если вы программист на perl,то для вас у меня есть нечто гораздо более удивительное,чем просто структурный офсетный принтер.</target>
        </trans-unit>
        <trans-unit id="b5d1347e7974f3a5c8f6ee662fc96a7143711f4b" translate="yes" xml:space="preserve">
          <source>But if you're using &lt;code&gt;PerlIO_printf()&lt;/code&gt;, it's less typing and visual clutter to use the &lt;code&gt;%z&lt;/code&gt; length modifier (for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">Но в любом случае постарайтесь разделить функции и операционные системы.</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">Но на случай,если тебе понадобится...</target>
        </trans-unit>
        <trans-unit id="3425ba57841c54a0c594ad2ebd352f7a60dfde42" translate="yes" xml:space="preserve">
          <source>But in general, such surprises are rare when entire sentences are being translated, especially when the functional context is restricted to that of a computer interacting with a user either to convey a fact or to prompt for a piece of information. So, for purposes of localization, translation by phrase (generally by sentence) is both the simplest and the least problematic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d7167267546a3345c93288a69c7eaaae59c46" translate="yes" xml:space="preserve">
          <source>But in many cases, especially multi-byte CJK encodings, you have to tweak a little more. Your network connection may not accept any data with the Most Significant Bit set, and your computer may not be able to tell if a given byte is a whole character or just half of it. So you have to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56073db003479cbcc5aa02dbdcbc3839993740e4" translate="yes" xml:space="preserve">
          <source>But in other cases, it just is that no one has implemented support yet. Patches welcome! Some elements are ported backward for some releases, but not all the way to 5.003_07.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">Но в данном конкретном примере,вы,вероятно,действительно хотите.</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">Но на самом деле все складывается вот так:</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">Но она также помещает ту же информацию в определенные поля самого XSUB:</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">Но он также работает и с лексически декларированными агрегатами.</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">Но с таким же успехом можно было бы обсудить три (связанных или эквивалентных)пункта:&quot;Неке&quot;,&quot;Порро&quot; и &quot;Квисквам Эст&quot;,за которыми следует пункт,разъясняющий все эти пункты,а затем новый пункт &quot;Ут Эним&quot;.В этом случае,возможно,вы захотите отформатировать его таким образом:</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">Но в Perl 6 это вообще не работает. Вместо этого вы должны использовать (распараллеливаемый) оператор &lt;code&gt;any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5bdbc1f908497576f552335e7ff9cc35570484f5" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Raku. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">Но она закричит,если..:</target>
        </trans-unit>
        <trans-unit id="934319e95a665a2a7425edac031de11ea5229dad" translate="yes" xml:space="preserve">
          <source>But most importantly, it works on systems that don't have &lt;code&gt;nl_langinfo&lt;/code&gt;, such as Windows, hence makes your code more portable. Of the fifty-some possible items specified by the POSIX 2008 standard, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&lt;/a&gt;, only one is completely unimplemented, though on non-Windows platforms, another significant one is also not implemented). It uses various techniques to recover the other items, including calling &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt;, both of which are specified in C89, so should be always be available. Later &lt;code&gt;strftime()&lt;/code&gt; versions have additional capabilities; &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for those not available on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">Но никогда не используйте пустой знак &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; не установив предварительно кодировку по умолчанию. В противном случае Perl не сможет знать, какой из многих, многих, многих возможных вариантов текстового файла у вас есть, и Perl не будет знать, как правильно сопоставить данные в вашем файле с реальными символами, с которыми он может работать. Другие распространенные форматы кодирования, включая &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; и даже &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . См. &lt;a href=&quot;perlunitut&quot;&gt;Perlunitut&lt;/a&gt; для получения дополнительной информации о кодировках.</target>
        </trans-unit>
        <trans-unit id="a0747e69fd78e083ffa59b04def2af91b0c7abf3" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt;, &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt;, &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt;, and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt;. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">Но обратите внимание, что эти последние три макроса действительны, только если &lt;code&gt;SvPOK()&lt;/code&gt; истинно.</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">Но обратите внимание, что это не означает, что любой из символов в строке необходим в кодировке UTF-8, или что любой из символов имеет кодовые точки больше, чем 0xFF (255) или даже 0x80 (128), или что строка имеет вообще никаких персонажей. Все, что &lt;code&gt;is_utf8()&lt;/code&gt; , - это возвращает значение внутреннего флага &quot;utf8ness&quot;, прикрепленного к &lt;code&gt;$string&lt;/code&gt; . Если флаг выключен, байты в скаляре интерпретируются как однобайтовая кодировка. Если этот флаг установлен, байты в скаляре интерпретируются как кодовые точки символов в кодировке UTF-8 (переменной длины, потенциально многобайтовые). Байты, добавленные в строку в кодировке UTF-8, автоматически обновляются до UTF-8. Если смешанные скаляры не-UTF-8 и UTF-8 объединяются (интерполяция в двойных кавычках, явная конкатенация или подстановка параметров printf / sprintf), результат будет закодирован в UTF-8, как если бы копии байтовых строк были обновлены до UTF. -8: например,</target>
        </trans-unit>
        <trans-unit id="f3b88a9932e49bdc61514a0893c4a2b1cc99c884" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt;. If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">Но до версии 5.16 вы должны четко указать, какой набор имен символов вы хотите. Имя &lt;code&gt;:full&lt;/code&gt; - это официальное имя, псевдоним или последовательность символов Юникода, которые имеют общее пространство имен.</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">Но помните,что не все операционные системы поддерживают форкинг или захват вывода команд,поэтому этот сложный оператор может быть не портативным.</target>
        </trans-unit>
        <trans-unit id="80db3d6002a0ea4be473c7d7a0631f6d66de4e4e" translate="yes" xml:space="preserve">
          <source>But second off, it's not isomorphic -- the &quot;solution&quot; (i.e., the phrasebook entries) for Chinese maps from these four English phrases to the one Chinese phrase that fits for all of them. In other words, the informal solution would be &quot;The way to say what you want in Chinese is with the one phrase 'For your question, in Y directories you would find X files'&quot; -- and so the implemented solution should be, isomorphically, just a straightforward way to spit out that one phrase, with numerals properly interpolated. It shouldn't have to map from the complexity of other languages to the simplicity of this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">Но некоторые модули не могут быть построены с помощью этой мантры.Они пытаются получить некоторые дополнительные данные от пользователя через среду,дополнительные аргументы или интерактивно-это мешает установке больших пакетов,таких как Phalanx100 или модулей с множеством зависимостей,таких как Plagger.</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">Но строчите его,и вы получите только текстовое содержимое:</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">Но будьте осторожны,чтобы не пропустить это,как,например.</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">Но проверка на запятнанность пока что дает вам только возможность.Иногда нужно просто очистить данные от пятен.Значения могут быть не запятнаны,используя их в качестве ключей в хэше,иначе единственный способ обойти механизм запятнания-это обратиться к подмаскадкам из совпадения регулярных выражений.Perl предполагает,что если вы ссылаетесь на подстроку,использующую $1,$2 и т.д.в не содержащем подстроек шаблоне,то вы знали,что делаете,когда писали этот шаблон.Это означает,что используя немного подумать-не стоит просто слепо ничего не замечать,или вы проиграете весь механизм.Лучше проверить,что в переменной есть только хорошие символы (для определенных значений &quot;хорошие&quot;),чем проверять,нет ли в ней плохих символов.Это потому,что слишком легко пропустить плохие символы,о которых вы никогда не думали.</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">Но в некоторых случаях это может привести к неоднозначному синтаксису,поэтому часто лучше использовать подход прямого вызова метода:</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">Но это не совпадает,по крайней мере,не так,как ты надеешься.Он утверждает,что в строке нет 123.Вот более ясная картина того,почему этот паттерн совпадает,вопреки ожиданиям популярных людей:</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">Но вторая &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; идет впереди. В шаблоне не используется простая буквальная строка. Так что, возможно, нам стоит представить ...</target>
        </trans-unit>
        <trans-unit id="ebd21a1f53afcb90bb2e6fa1c3ee1beda8c1e31a" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;unpack&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">Но это не очень красиво.Может быть,в конце концов,вам будет проще или понятнее делать такие вещи:</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">Но это довольно неэффективно.Лучший способ сделать это-начать свою программу:</target>
        </trans-unit>
        <trans-unit id="3c5623d3d8f73ddcc75bce9ec5d80243561beb13" translate="yes" xml:space="preserve">
          <source>But the Arabic translator is the next to write back. First off, your code for &quot;I scanned %g directory.&quot; or &quot;I scanned %g directories.&quot; assumes there's only singular or plural. But, to use linguistic jargon again, Arabic has grammatical number, like English (but unlike Chinese), but it's a three-term category: singular, dual, and plural. In other words, the way you say &quot;directory&quot; depends on whether there's one directory, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">Но HERE_TARGET все равно должен быть смыт с края.Если вы хотите,чтобы этот отступ также был выведен,вам нужно будет процитировать его.</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">Но следующий код довольно плохой:</target>
        </trans-unit>
        <trans-unit id="903f25d05dc48316bba755ecdc1e7944baec6c3c" translate="yes" xml:space="preserve">
          <source>But the marked code isn't syntactically correct to be such an interpolated class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">Но бывают случаи, когда работает только это решение (например, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="f444a7ccc18a957e30bdbe83f2e4500327151823" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;goto &amp;amp;maybe::next::method&lt;/code&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">Но в некоторых случаях вы можете захотеть узнать, с каким набором символов вы работаете. Один из возможных примеров - &lt;a href=&quot;#SORTING&quot;&gt;сортировка&lt;/a&gt; во внутренних циклах, где производительность имеет решающее значение.</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">Но нет никакой реальной необходимости, чтобы &lt;b&gt;оба&lt;/b&gt; были временными файлами ... следующее должно работать точно так же, без взаимоблокировок:</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">Но они могут быть произвольно длинными:</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">Но они могут охватывать несколько (не пустых)строк:</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">Но это не имеет того эффекта, который мог бы ожидать кто-то, читающий код, поскольку пересечение относится только к &lt;code&gt;\p{Thai}&lt;/code&gt; , за исключением лаосского. Подобных ловушек можно избежать, заключив в скобки компоненты:</target>
        </trans-unit>
        <trans-unit id="3e961579d9e8252ea504999636a1d461e186d84b" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the source code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt;, excluding the Laotian. Its best to compile the subcomponents, but you could also parenthesize the component pieces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">Но это не совпадает, по крайней мере, не так, как можно было бы ожидать. Только после вставки интерполированного &lt;code&gt;$a99a&lt;/code&gt; и просмотра полученного полного текста регулярного выражения становится очевидно, что обратные ссылки дали обратный эффект. Подвыражение &lt;code&gt;(\w+)&lt;/code&gt; перехватило номер 1 и &lt;code&gt;$a99a&lt;/code&gt; группы в $ a99a на один ранг. Этого можно избежать, используя относительные обратные ссылки:</target>
        </trans-unit>
        <trans-unit id="6783211af3a27626c9e0e73fe10e75f068ecbc7b" translate="yes" xml:space="preserve">
          <source>But this is not guaranteed to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">Но это не так:</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">Но чтобы избежать предупреждений о переносимости (см. &lt;a href=&quot;functions/use&quot;&gt;Использование&lt;/a&gt; ), вы можете предпочесть:</target>
        </trans-unit>
        <trans-unit id="f9f8099c8d1ed2b0fc4c9abd170ecd56ff0e63b5" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;), you may prefer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Но подождите: разве &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; просто не возвращает последовательность байтов? Как мы можем передать эту строку байтов в некоторый код C, ожидающий указателя, который, в конце концов, является не чем иным, как числом? Ответ прост: мы должны получить числовой адрес из байтов, возвращаемых &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8b172e82350b535193e00efe170bf43ca91d34" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;pack&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;pack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681fa12b5aa88395e6be12e5639cef0794d6ebaa" translate="yes" xml:space="preserve">
          <source>But what about user-defined subroutines from modules? If you use &lt;code&gt;autodie&lt;/code&gt; on a user-defined subroutine then it assumes the following behaviour to demonstrate failure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1178148d2666470319bf944b3a6373f8bd5ec43c" translate="yes" xml:space="preserve">
          <source>But what happens if your test program dies halfway through?! Since we didn't say how many tests we're going to run, how can we know it failed? No problem, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; employs some magic to catch that death and turn the test into a failure, even if every test passed up to that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">Но что, если бы у нас было неопределенное количество слов? Это своего рода задач &lt;code&gt;//g&lt;/code&gt; было сделано для. Чтобы извлечь все слова, сформируйте простое регулярное выражение &lt;code&gt;(\w+)&lt;/code&gt; и переберите все совпадения с помощью &lt;code&gt;/(\w+)/g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="90358bd78c20e742086dbdc6ea3490a9deb3bfcc" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;/g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">Но когда &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; используется вместо &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="818681641ebe6c47ebb66c7080c5a8f6b3070c54" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">Но когда в конце добавляются следующие строки:</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">Но с фактическим деревом компиляции для &lt;code&gt;$a = $b + $c&lt;/code&gt; все иначе: некоторые узлы</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">Но не сработает,когда позвонят как:</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">Но на самом деле тебе не нужно делать два звонка по трубе.Если у вас есть системный вызов socketpair(),он сделает все это за вас.</target>
        </trans-unit>
        <trans-unit id="eb429c70b04342714cf4d23c433974bea348e678" translate="yes" xml:space="preserve">
          <source>But you put it aside for the moment, and optimistically hope that the other translators won't have this problem, and that their languages will be better behaved -- i.e., that they will be just like English.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">Но вы все еще не можете делать предположений о том,верно ли это,если только ваша политика не говорит об этом.Лучше всего спросить пользователя.</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">Но у тебя все еще есть эти забавные select().Так что просто используйте модуль FileHandle.Теперь вы можете получить доступ к этим специальным переменным,используя вместо этого строчные имена методов:</target>
        </trans-unit>
        <trans-unit id="c127d3080f3bd57d92c9f856e712493975078203" translate="yes" xml:space="preserve">
          <source>But you still have to localize it for all the languages you're producing this software for, so you pull Locale::gettext off of CPAN so you can access the &lt;code&gt;gettext&lt;/code&gt; C functions you've heard are standard for localization tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a3c4f45d8b18ec4a584229683442d84d642772" translate="yes" xml:space="preserve">
          <source>But you then read in the gettext manual (Drepper, Miller, and Pinard 1995) that this is not a good idea, since how a single word like &quot;directory&quot; or &quot;directories&quot; is translated may depend on context -- and this is true, since in a case language like German or Russian, you'd may need these words with a different case ending in the first instance (where the word is the object of a verb) than in the second instance, which you haven't even gotten to yet (where the word is the object of a preposition, &quot;in %g directories&quot;) -- assuming these keep the same syntax when translated into those languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d919612387e489786e93250f1cb6101f4eb4f66e" translate="yes" xml:space="preserve">
          <source>But!</source>
          <target state="translated">But!</target>
        </trans-unit>
        <trans-unit id="45dd0cd91dc6886148fd373bfb4f17c3a9594ab0" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">Но при извлечении директивы с помощью &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; символ '&amp;gt;' обрабатывается только как разделенный на самом внешнем уровне блока кода, поэтому директива анализируется правильно .</target>
        </trans-unit>
        <trans-unit id="30f80e7cf502991565c61822cae8756f6fbb85c6" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', undef, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9550f9852e2d8ab541a52ef7f81900ea09883af" translate="yes" xml:space="preserve">
          <source>But, even for portable ranges, it is not generally obvious what is included without having to look things up in the manual. A sound principle is to use only ranges that both begin from, and end at, either ASCII alphabetics of equal case (&lt;code&gt;b-e&lt;/code&gt;, &lt;code&gt;B-E&lt;/code&gt;), or digits (&lt;code&gt;1-4&lt;/code&gt;). Anything else is unclear (and unportable unless &lt;code&gt;\N{...}&lt;/code&gt; is used). If in doubt, spell out the character sets in full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64523236f0a5dcac7b40cdaff74c2e2dc5991adf" translate="yes" xml:space="preserve">
          <source>But, starting with Perl v5.28, locales are thread-safe on platforms that support this functionality. Windows has this starting with Visual Studio 2005. Many other modern platforms support the thread-safe POSIX 2008 functions. The C &lt;code&gt;#define&lt;/code&gt;&lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; will be defined iff this build is using these. From Perl-space, the read-only variable &lt;code&gt;${SAFE_LOCALES}&lt;/code&gt; is 1 if either the build is not threaded, or if &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; is defined; otherwise it is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adebbf716096e26741f223bcfa719eec45495d73" translate="yes" xml:space="preserve">
          <source>Buzzword: Concision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b968913e712f1017ea8c46a9442142f5b0258e4f" translate="yes" xml:space="preserve">
          <source>Buzzword: Inheritance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9a9237da961c2681cd1e9d5c45f274b009d9f4" translate="yes" xml:space="preserve">
          <source>Buzzword: Isomorphism</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caad58d09c49a59cd7461be6687704deef207767" translate="yes" xml:space="preserve">
          <source>Buzzwords: Abstraction and Encapsulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b354100dcfbea76bd0e9e5a69bf58ebc32ab47" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Not supplying any argument returns the current settings.</source>
          <target state="translated">Вызывая метод класса &lt;code&gt;Math::Complex::display_format&lt;/code&gt; и &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; в качестве аргумента либо &lt;code&gt;&quot;polar&quot;&lt;/code&gt; либо &amp;laquo;декартовый&amp;raquo; , вы переопределяете стиль отображения по умолчанию, который является &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Отсутствие аргумента возвращает текущие настройки.</target>
        </trans-unit>
        <trans-unit id="43dd785845dcbec8cafe7f755ed628d733e41645" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt;. Not supplying any argument returns the current settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd6475e714f8f18a3dfbb9986cb52d7a25b9828" translate="yes" xml:space="preserve">
          <source>By carefully looking at the encoded byte sequence, you can find that the byte sequence conforms a unique number. In that sense, EUC is a CCS generated by a CES above from up to four CCS (complicated?). UTF-8 falls into this category. See &lt;a href=&quot;perlunicode#UTF-8&quot;&gt;&quot;UTF-8&quot; in perlUnicode&lt;/a&gt; to find out how UTF-8 maps Unicode to a byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d08c1f941525ad751e4a25955a26ef38161991" translate="yes" xml:space="preserve">
          <source>By contrast, if</source>
          <target state="translated">Напротив,если</target>
        </trans-unit>
        <trans-unit id="d13b7913a7d5727103d5a0ff02bb43cd904ec898" translate="yes" xml:space="preserve">
          <source>By convention, CPAN Digest modules do &lt;b&gt;not&lt;/b&gt; pad their Base64 output. Problems can occur when feeding such digests to other software that expects properly padded Base64 encodings.</source>
          <target state="translated">По соглашению, модули дайджеста CPAN &lt;b&gt;не&lt;/b&gt; дополняют свой вывод Base64. Проблемы могут возникнуть при загрузке таких дайджестов в другое программное обеспечение, которое ожидает правильно заполненные кодировки Base64.</target>
        </trans-unit>
        <trans-unit id="fa63c3f7831848cc55dec885e0aadbe7e110091f" translate="yes" xml:space="preserve">
          <source>By convention, all the calls to OS/2 API should indicate their failures by resetting $^E. All the Perl-accessible functions which call OS/2 API may be broken into two classes: some die()s when an API error is encountered, the other report the error via a false return value (of course, this does not concern Perl-accessible functions which</source>
          <target state="translated">По общему правилу,все звонки в OS/2 API должны указывать на свои сбои,сбросив $^E.Все Perl-доступные функции,вызывающие OS/2 API,могут быть разбиты на два класса:одни die()s при обнаружении ошибки API,другие сообщают об ошибке через ложное возвращаемое значение (конечно,это не относится к Perl-доступным функциям,которые</target>
        </trans-unit>
        <trans-unit id="98616871ec55526e1b310a455ba5f2d84e33363e" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt; . They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt; ) (which in turn are called from</source>
          <target state="translated">По соглашению, подпрограммы проверки имеют имена &lt;code&gt;ck_*&lt;/code&gt; . Обычно они вызываются из &lt;code&gt;new*OP&lt;/code&gt; подпрограмм * OP (или &lt;code&gt;convert&lt;/code&gt; ) (которые, в свою очередь, вызываются из</target>
        </trans-unit>
        <trans-unit id="21e06347ae19cac9895adb4f7e858bf0ed8086b5" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt;. They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt;) (which in turn are called from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac2669af1abb44ebf6531e7e05b8563aa92056a" translate="yes" xml:space="preserve">
          <source>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see:</source>
          <target state="translated">По условию,каждому тесту присваивается номер по порядку.В основном это делается автоматически для вас.Однако,часто бывает очень полезно присвоить имя каждому тесту.Которое вы предпочитаете видеть:</target>
        </trans-unit>
        <trans-unit id="9314c5f036387917642398c26237bf03490cfd4b" translate="yes" xml:space="preserve">
          <source>By default</source>
          <target state="translated">По умолчанию</target>
        </trans-unit>
        <trans-unit id="a90acddb58b18220dbe08ab0b09969aa5f8ece27" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; will uncompress</source>
          <target state="translated">По умолчанию &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; распаковывает</target>
        </trans-unit>
        <trans-unit id="2b6ad4cdfaab155648e7ab26ef526a2e2f9bb93e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; will build with a private copy of version 1.2.5 of the zlib library. (See the</source>
          <target state="translated">По умолчанию &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; будет компилироваться с частной копией версии 1.2.5 библиотеки zlib. (См.</target>
        </trans-unit>
        <trans-unit id="13d1bc9ce24c11cc5f6efdcd3fee51a91c8038f7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Hash::Util&lt;/code&gt; does not export anything.</source>
          <target state="translated">По умолчанию &lt;code&gt;Hash::Util&lt;/code&gt; ничего не экспортирует.</target>
        </trans-unit>
        <trans-unit id="62c898d4495e40824d05af53004d3c74a134ca35" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbc45d166d6a142bcf7adafd5a3ff246af5dec6" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bzip2&lt;/code&gt; will only uncompress the first bzip2 data stream in a pbzip2 file. To uncompress the complete pbzip2 file you must include the &lt;code&gt;MultiStream&lt;/code&gt; option, like this.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
