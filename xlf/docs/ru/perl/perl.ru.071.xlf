<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="3e543092d93dedef30b6a118c959f36cd73b7b20" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">Предупреждает с помощью &lt;code&gt;@message&lt;/code&gt; , но сообщение будет появляться с того места, где была вызвана исходная тестовая функция ( &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d24c39aea457b02505102a29c905de4cac82e99" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27a6644654593ac9e5d122b1155ff23752c8073" translate="yes" xml:space="preserve">
          <source>Washington</source>
          <target state="translated">Washington</target>
        </trans-unit>
        <trans-unit id="d321acbea9d4ab268b54e61d4d0b39001cfb34d4" translate="yes" xml:space="preserve">
          <source>Wayne Thompson</source>
          <target state="translated">Уэйн Томпсон</target>
        </trans-unit>
        <trans-unit id="43464fb1e06d4c1bc9db7081e9ca038cc1269495" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.16.x and earlier are now out of support. As of the release of 5.22.0, we will &quot;officially&quot; end support for Perl 5.18.x, other than providing security updates as described below.</source>
          <target state="translated">Мы &quot;официально&quot; поддерживаем две последние стабильные серии релизов.5.16.x и более ранние версии теперь не поддерживаются.Начиная с релиза 5.22.0,мы &quot;официально&quot; закончим поддержку Perl 5.18.x,за исключением предоставления обновлений безопасности,как описано ниже.</target>
        </trans-unit>
        <trans-unit id="6d4d00accf40364d9a03449bdf5ad7e154d1f316" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.26.x and earlier are now out of support. As of the release of 5.32.0, we will &quot;officially&quot; end support for Perl 5.28.x, other than providing security updates as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a0049b3e8190b56f011a925a65f0578bf35206" translate="yes" xml:space="preserve">
          <source>We already talked about the special &lt;code&gt;@ISA&lt;/code&gt; array and the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma.</source>
          <target state="translated">Мы уже говорили о специальном массиве &lt;code&gt;@ISA&lt;/code&gt; и &lt;a href=&quot;parent&quot;&gt;родительской&lt;/a&gt; прагме.</target>
        </trans-unit>
        <trans-unit id="99f6d15ea0dac8c570f259e877f08f9c6317a1cf" translate="yes" xml:space="preserve">
          <source>We also recommend using this method to check whether a module has a sufficient version. The internal implementation uses the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module to make sure that different types of version numbers are compared correctly.</source>
          <target state="translated">Мы также рекомендуем использовать этот метод, чтобы проверить, достаточно ли у модуля версии. Внутренняя реализация использует &lt;a href=&quot;version&quot;&gt;версию&lt;/a&gt; модуля , чтобы убедиться , что сделать различные типы номеров версий сравниваются правильно.</target>
        </trans-unit>
        <trans-unit id="777641065ef9fefa679b6e058d833646233119c1" translate="yes" xml:space="preserve">
          <source>We are at the end of the regexp, so we are done! We have matched 'abcd' out of the string &quot;abcde&quot;.</source>
          <target state="translated">Мы в конце регэксплуатации,так что мы закончили! Мы сравнили 'abcd' со строкой 'abcde'.</target>
        </trans-unit>
        <trans-unit id="88e6eb598d1ae4c98a1710166c586176804c4ac7" translate="yes" xml:space="preserve">
          <source>We are done!</source>
          <target state="translated">Мы закончили!</target>
        </trans-unit>
        <trans-unit id="b8c42eb02770fa660f067266841b9afabfa1a1c9" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt; . A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">Мы выполняем только одну операцию хеширования в этой функции, которая сохраняет новый скаляр под ключом с использованием &lt;code&gt;hv_store&lt;/code&gt; . Хэш представлен указателем HV *. Как и массивы, функции для управления хешами из XSUB отражают функциональность, доступную в Perl. См. Подробности в &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; и &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6308f6a80327169a668ffa81bc777a5db0a8f1" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt;. A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d6aa4a367d4b3962d66c4c93f795d417974b93" translate="yes" xml:space="preserve">
          <source>We are used to using the term (character)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd90ced3661ebd845235cda2b54db721e3957aec" translate="yes" xml:space="preserve">
          <source>We aren't interested in anything returned from</source>
          <target state="translated">Мы не заинтересованы в том,чтобы что-нибудь возвращалось от</target>
        </trans-unit>
        <trans-unit id="b554448ff034d8f0532aebe7287733b598ce6629" translate="yes" xml:space="preserve">
          <source>We aren't passing any parameters to</source>
          <target state="translated">Мы не передаем никаких параметров</target>
        </trans-unit>
        <trans-unit id="4e3a929680591b90a57e354fe70746318049b8f9" translate="yes" xml:space="preserve">
          <source>We build perl using GNU make. We tried the native make once and it worked too.</source>
          <target state="translated">Мы собираем perl,используя марку GNU.Однажды мы попробовали нативный make,и он тоже сработал.</target>
        </trans-unit>
        <trans-unit id="41071245738df49d45438a45bb484058bfc57858" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt; , and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt; . This'll give us similar output to &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt;.</source>
          <target state="translated">Мы также можем выгрузить эту операцию: текущая &lt;code&gt;PL_op&lt;/code&gt; всегда сохраняется в PL_op , и мы можем выгрузить ее с помощью &lt;code&gt;Perl_op_dump&lt;/code&gt; . Это даст нам результат, аналогичный &lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a951916387170e99fc981f4b1d58e4dc7bd8c60" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt;, and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt;. This'll give us similar output to CPAN module B::Debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c3c25dd241cffc69783f122b1016732a7e65b" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;@&lt;/code&gt; to jump to an offset, with 0 being the position where we were when the last &lt;code&gt;(&lt;/code&gt; was encountered:</source>
          <target state="translated">Мы также можем использовать &lt;code&gt;@&lt;/code&gt; для перехода к смещению, где 0 - это позиция, в которой мы были, когда было обнаружено последнее &lt;code&gt;(&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbea0db461430bae70d9c35bb3e6a3ab77cd3179" translate="yes" xml:space="preserve">
          <source>We can also use a variable to store a reference to the data structure that is being blessed as our object:</source>
          <target state="translated">Мы также можем использовать переменную для хранения ссылки на структуру данных,которая благословляется в качестве нашего объекта:</target>
        </trans-unit>
        <trans-unit id="3ae43a4ae8c47d1af2dad91e0ab8b4c97424cc6a" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">Мы также можем использовать оператор транслитерации &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . В этом примере сторона списка поиска нашего &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; ничего не содержит, но опция &lt;code&gt;c&lt;/code&gt; дополняет ее, поэтому она содержит все. Список замен также ничего не содержит, поэтому транслитерация практически не выполняется, поскольку она не выполняет никаких замен (или, точнее, заменяет символ самим собой). Однако параметр &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; сжимает повторяющиеся и последовательные символы в строке, поэтому символ не отображается рядом с собой.</target>
        </trans-unit>
        <trans-unit id="0bc5ebb55ff053059629cd57779115c15a2ccce5" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;tr///&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;tr///&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;s&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5deb5cdcf6e21e86d4cfa078a33ffd7c085ef4" translate="yes" xml:space="preserve">
          <source>We can ask autodie to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbd56817858a9e2d4db427c7f1f11d2cf2d4b00" translate="yes" xml:space="preserve">
          <source>We can combine the last 3 lines of the above like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9637ace5e985325b750e53a0a2e0777af26ff5" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">Мы можем справиться с этим,используя и утверждение,и отрицание.Мы скажем,что за первой частью в $1 должна следовать и цифра,и что-то,что не &quot;123&quot;.Помните,что look-aheads-это выражения с нулевой шириной-они только выглядят,но не потребляют ни одной строки в своем совпадении.Так что переписывание таким образом производит то,что вы ожидаете;т.е.случай 5 будет неудачным,а случай 6-успешным:</target>
        </trans-unit>
        <trans-unit id="337b65de98d527cb6d5b86fba92bc577466c5413" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in &lt;code&gt;$1&lt;/code&gt; must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the lookaheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e73838de4aed15f5d24b688fd13aef192fb3f9" translate="yes" xml:space="preserve">
          <source>We can extend the example above:</source>
          <target state="translated">Мы можем расширить приведенный выше пример:</target>
        </trans-unit>
        <trans-unit id="84c843f2491ce2ba91f8ea33bd419c025bcac31f" translate="yes" xml:space="preserve">
          <source>We can manipulate &lt;code&gt;@_&lt;/code&gt; in other ways too:</source>
          <target state="translated">Мы можем манипулировать &lt;code&gt;@_&lt;/code&gt; и другими способами:</target>
        </trans-unit>
        <trans-unit id="c8e881a1155e87edea33bdbd7aaa36ea47df11e3" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt; . To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt; , we form the regex &lt;code&gt;dog|cat&lt;/code&gt; . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt; . If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt; . If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">Мы можем сопоставлять разные символьные строки с помощью метасимвола &lt;b&gt;чередования &lt;/b&gt; &lt;code&gt;'|'&lt;/code&gt; . Чтобы соответствовать &lt;code&gt;dog&lt;/code&gt; или &lt;code&gt;cat&lt;/code&gt; , мы формируем регулярное выражение &lt;code&gt;dog|cat&lt;/code&gt; . Как и раньше, Perl будет пытаться сопоставить регулярное выражение в самом раннем возможном месте строки. В каждой позиции символа Perl сначала пытается сопоставить первую альтернативу, &lt;code&gt;dog&lt;/code&gt; . Если &lt;code&gt;dog&lt;/code&gt; не соответствует, Perl попробует следующий вариант - &lt;code&gt;cat&lt;/code&gt; . Если &lt;code&gt;cat&lt;/code&gt; тоже не соответствует, то совпадение не удается, и Perl переходит на следующую позицию в строке. Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="d6a0febb21ee098abccab9c8a03b765fef08617d" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt;. To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt;, we form the regex &lt;code&gt;dog|cat&lt;/code&gt;. As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt;. If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt;. If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea854225fefa1280a29795bb4f271d273dbd77b0" translate="yes" xml:space="preserve">
          <source>We can modify principle 3 above to take into account non-greedy quantifiers:</source>
          <target state="translated">Мы можем изменить приведенный выше принцип 3 с учетом не жадных квантификаторов:</target>
        </trans-unit>
        <trans-unit id="ab79fcd6910e13f271bf0f10b6fac2de440cb105" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;Perl_sv_dump&lt;/code&gt; to investigate the SV:</source>
          <target state="translated">Теперь мы можем использовать &lt;code&gt;Perl_sv_dump&lt;/code&gt; для исследования SV:</target>
        </trans-unit>
        <trans-unit id="9e3ffbb12768a148e4cd9144c59ebb38f57598ff" translate="yes" xml:space="preserve">
          <source>We can override a parent's method in a child class. When we do so, we can still call the parent class's method with the &lt;code&gt;SUPER&lt;/code&gt; pseudo-class.</source>
          <target state="translated">Мы можем переопределить родительский метод в дочернем классе. Когда мы это сделаем, мы все еще можем вызвать метод родительского класса с псевдоклассом &lt;code&gt;SUPER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2754e3aa57380296cb4f092e33ffe2f92fac593d" translate="yes" xml:space="preserve">
          <source>We can put another break point on any line beginning with a colon, we'll use line 17 as that's just as we come out of the subroutine, and we'd like to pause there later on:</source>
          <target state="translated">Мы можем поставить еще одну точку перелома на любой линии,начинающейся с двоеточия,мы будем использовать 17-ю линию,так как это как раз то,что мы выходим из подпрограммы,и мы хотели бы сделать паузу там позже:</target>
        </trans-unit>
        <trans-unit id="8aece3bd543cbe6fe75eaf5ad6965a489841cbb4" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">Мы можем поместить это в тестовый файл, который мы можем запустить, чтобы проверить, какой из подходов самый быстрый, используя глобальную переменную &lt;code&gt;$STR&lt;/code&gt; для присвоения переменной &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; чтобы избежать попыток Perl оптимизировать любую работу, заметив ее. назначается только один раз.</target>
        </trans-unit>
        <trans-unit id="3216d8a5e6dc84b8bbaa513843a9c89d95b551dc" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;my $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192c194669c26df922a17b7997201101414dafec" translate="yes" xml:space="preserve">
          <source>We can reduce some of the looping through slices</source>
          <target state="translated">Мы можем уменьшить некоторые петли через ломтики.</target>
        </trans-unit>
        <trans-unit id="e5d25f7f85d18366ec3d6895017e423d452f3199" translate="yes" xml:space="preserve">
          <source>We can see on line 4 that our token type is &lt;code&gt;ASSIGNOP&lt;/code&gt; (&lt;code&gt;OPERATOR&lt;/code&gt; is a macro, defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1ace8b9cc4168efa6505ff7ef438700e9bd607" translate="yes" xml:space="preserve">
          <source>We cannot predict how long the database ping will take so we use Test::More's like() test to check that the diagnostic string is of the right form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a62faa91fec217313353690ec40805d724e81" translate="yes" xml:space="preserve">
          <source>We check for duplicate entries in the typemap, but do not check for missing &lt;code&gt;TYPEMAP&lt;/code&gt; entries for &lt;code&gt;INPUTMAP&lt;/code&gt; or &lt;code&gt;OUTPUTMAP&lt;/code&gt; entries since these might be hidden in a different typemap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393d2cf123dc0cecdbadd1ca8c26943dc464db54" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">Тем не менее, мы могли бы получить более интересный блок &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; . Вместо того, чтобы сравнивать ключи, мы можем вычислить с ними значение и использовать это значение в качестве сравнения.</target>
        </trans-unit>
        <trans-unit id="1bcc7cd7b768900689b6b050ac1c7aac10dad46e" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;sort()&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373abf531902aa68eac45baf244872a1e2626f66" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt; , but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">Мы могли бы наследовать оба класса от общего родителя, такого как &lt;code&gt;Machine&lt;/code&gt; , но не все машины имеют переключатели включения / выключения. Мы могли бы создать родительский класс под названием &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , но это очень искусственно. Радио и компьютеры не являются специализацией этого родителя. Этот родитель действительно довольно нелепое создание.</target>
        </trans-unit>
        <trans-unit id="859c345eb5fe4bc62f73981c70642999b8e4b03c" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt;, but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt;, but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ce6432aa57322234fa603b7b093664929a40c6" translate="yes" xml:space="preserve">
          <source>We could have used an unpack template &lt;code&gt;'b12'&lt;/code&gt; just as well, since the last 4 bits can be ignored anyway.</source>
          <target state="translated">Мы могли бы использовать шаблон распаковки &lt;code&gt;'b12'&lt;/code&gt; , так как последние 4 бита в любом случае можно игнорировать.</target>
        </trans-unit>
        <trans-unit id="737f5642c49143f79a5e632705526d6d3453018c" translate="yes" xml:space="preserve">
          <source>We do this by using the PPCODE: directive, rather than the CODE: directive. This tells &lt;b&gt;xsubpp&lt;/b&gt; that we will be managing the return values that will be put on the argument stack by ourselves.</source>
          <target state="translated">Мы делаем это с помощью директивы PPCODE:, а не CODE :. Это сообщает &lt;b&gt;xsubpp,&lt;/b&gt; что мы будем сами управлять возвращаемыми значениями, которые будут помещены в стек аргументов.</target>
        </trans-unit>
        <trans-unit id="bbf4d60422d93cc3418f9928672ab7a165e0c448" translate="yes" xml:space="preserve">
          <source>We don't have much experience with this yet, but try the following:</source>
          <target state="translated">У нас пока нет большого опыта,но попробуйте следующее:</target>
        </trans-unit>
        <trans-unit id="3714a8cbbcb3d8e34c4cf78e7eb46446670ccdf4" translate="yes" xml:space="preserve">
          <source>We don't have to hard-code patterns into the match operator (or anything else that works with regular expressions). We can put the pattern in a variable for later use.</source>
          <target state="translated">Нам не нужно жестко кодировать шаблоны в оператор сравнения (или что-то еще,что работает с регулярными выражениями).Мы можем поместить шаблон в переменную для последующего использования.</target>
        </trans-unit>
        <trans-unit id="9b9b047b90e6f20cc1587612f1c7f873786eee50" translate="yes" xml:space="preserve">
          <source>We encourage using this rather than calling print directly.</source>
          <target state="translated">Мы рекомендуем использовать это,а не звонить напрямую в печать.</target>
        </trans-unit>
        <trans-unit id="7ef0cc263f45630948ec977db18c296d89495351" translate="yes" xml:space="preserve">
          <source>We encourage vendors to ship the most recent supported release of Perl at the time of their code freeze.</source>
          <target state="translated">Мы призываем поставщиков поставлять самый последний поддерживаемый релиз Perl на момент замораживания кода.</target>
        </trans-unit>
        <trans-unit id="dd33c6dcc68f66e550d47a04957cd34a37a4f9d0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">Мы рекомендуем вам поиграть и оценить &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny,&lt;/a&gt; чтобы увидеть, какая объектно-ориентированная система подходит вам.</target>
        </trans-unit>
        <trans-unit id="f6dd2243ed823c9d407fa450eaf7b53699b60af0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;, &lt;a href=&quot;Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75ee8e59a59e98ee82483d5a167a8e74430cf9d" translate="yes" xml:space="preserve">
          <source>We fix our quoting: 'tom' =&amp;gt; q(and jerry), and run it again, this time we get our expected output:</source>
          <target state="translated">Мы исправляем наше цитирование: 'tom' =&amp;gt; q (и jerry) и запускаем его снова, на этот раз мы получаем ожидаемый результат:</target>
        </trans-unit>
        <trans-unit id="ad7822a7bc01015524040b6228bd7a714fe0ea5e" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;//s&lt;/code&gt; , multi-line &lt;code&gt;//m&lt;/code&gt; , case-insensitive &lt;code&gt;//i&lt;/code&gt; and extended &lt;code&gt;//x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">Мы уже ввели оператор сопоставления в его значение по умолчанию &lt;code&gt;/regexp/&lt;/code&gt; и произвольный разделитель &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; формы. Мы использовали оператор привязки &lt;code&gt;=~&lt;/code&gt; и его отрицание &lt;code&gt;!~&lt;/code&gt; Для проверки совпадений строк. Связанные с оператором сопоставления, мы обсудили однострочные &lt;code&gt;//s&lt;/code&gt; , многострочные &lt;code&gt;//m&lt;/code&gt; , нечувствительные к регистру &lt;code&gt;//i&lt;/code&gt; и расширенные &lt;code&gt;//x&lt;/code&gt; модификаторы. Есть еще несколько вещей, которые вы, возможно, захотите узнать об операторах сопоставления.</target>
        </trans-unit>
        <trans-unit id="4ec0698febe8baf604343239295eca801edc1950" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;m!regexp!&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;/s&lt;/code&gt;, multi-line &lt;code&gt;/m&lt;/code&gt;, case-insensitive &lt;code&gt;/i&lt;/code&gt; and extended &lt;code&gt;/x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2bfdcf3348ad31286e830869ab5ab9cf57a976" translate="yes" xml:space="preserve">
          <source>We have no nroff on BS2000 POSIX (yet), so we ignored any errors while installing the documentation.</source>
          <target state="translated">У нас нет nroff на BS2000 POSIX (пока),поэтому мы проигнорировали все ошибки во время установки документации.</target>
        </trans-unit>
        <trans-unit id="c5a4c49687cb5b4e725178b1ad770374684a7f19" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt; , and we want to keep the arguments the same.</source>
          <target state="translated">Мы должны использовать раздел &lt;code&gt;CODE&lt;/code&gt; , потому что &lt;code&gt;PerlIO_puts()&lt;/code&gt; имеет обратные аргументы по сравнению с &lt;code&gt;fputs()&lt;/code&gt; , и мы хотим сохранить те же аргументы.</target>
        </trans-unit>
        <trans-unit id="094b6bf4440df57d740fc419f243cfd8a6cfc13d" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt;, and we want to keep the arguments the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a78632eb571a6503bee4006e791fffefd6cf4ab" translate="yes" xml:space="preserve">
          <source>We have tried to make Perl aware of both VMS-style and Unix-style file specifications wherever possible. You may use either style, or both, on the command line and in scripts, but you may not combine the two styles within a single file specification. VMS Perl interprets Unix pathnames in much the same way as the CRTL (</source>
          <target state="translated">Мы постарались по возможности ознакомить Perl со спецификациями файлов как в стиле VMS,так и в стиле Unix.Вы можете использовать как стиль,так и оба в командной строке и в скриптах,но вы не можете комбинировать эти два стиля в пределах одной спецификации файла.VMS Perl интерпретирует патнамы Unix таким же образом,как и CRTL (</target>
        </trans-unit>
        <trans-unit id="78dd390dcc77c45fe1854b3e48358f0f7f0c1ae7" translate="yes" xml:space="preserve">
          <source>We highly discourage this method. It should only be used if you know what you're doing and specifically need the PREFIX behavior. The PREFIX algorithm is complicated and focused on matching the system installation.</source>
          <target state="translated">Мы крайне не одобряем этот метод.Его следует использовать только в том случае,если вы знаете,что делаете,и конкретно нуждаетесь в поведении PREFIX.Алгоритм PREFIX сложный и сфокусирован на соответствии установки системы.</target>
        </trans-unit>
        <trans-unit id="0d078f205cc7733f26f4527b8b9a508a7c925969" translate="yes" xml:space="preserve">
          <source>We highly recommend the install_base method, its the simplest and most closely approximates the expected behavior of an installation prefix.</source>
          <target state="translated">Мы настоятельно рекомендуем метод install_base,который является самым простым и наиболее близким к ожидаемому поведению установочного префикса.</target>
        </trans-unit>
        <trans-unit id="cf829d6773d2acaf89ace4612301d748f71133de" translate="yes" xml:space="preserve">
          <source>We hope these notes will save you from confusion and lost sleep when writing Perl scripts on VMS. If you find we've missed something you think should appear here, please don't hesitate to drop a line to vmsperl@perl.org.</source>
          <target state="translated">Мы надеемся,что эти заметки избавят вас от путаницы и потери сна при написании Perl скриптов на VMS.Если вы обнаружите,что мы пропустили что-то,что,по вашему мнению,должно появиться здесь,пожалуйста,не стесняйтесь бросить строку на vmsperl@perl.org.</target>
        </trans-unit>
        <trans-unit id="c62eabab19d963ec1dc9f96b723cb4b48b7d1ebd" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching for --rules. Here are the supported patterns:</source>
          <target state="translated">Мы используем наш собственный шаблон в стиле глобуса для...правил.Вот поддерживаемые шаблоны:</target>
        </trans-unit>
        <trans-unit id="f3c2a6f9803dfeb38af1055d966366fc67acbab0" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching. Here are the patterns it supports:</source>
          <target state="translated">Мы реализуем наше собственное сопоставление шаблонов в стиле глобуса.Вот шаблоны,которые он поддерживает:</target>
        </trans-unit>
        <trans-unit id="821afd715774631771e27078ffd6e046b44c39d8" translate="yes" xml:space="preserve">
          <source>We know we're going to get &lt;code&gt;6&lt;/code&gt; from this, so let's finish the subroutine:</source>
          <target state="translated">Мы знаем, что получим &lt;code&gt;6&lt;/code&gt; , так что давайте закончим подпрограмму:</target>
        </trans-unit>
        <trans-unit id="56ac7541ed28a7466aa3352e9da342249eeae09f" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt; s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">Мы смотрели на этот бит кода перед, и мы сказали , что &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; устраивает для двух &lt;code&gt;NV&lt;/code&gt; ы должны быть помещены в &lt;code&gt;left&lt;/code&gt; и &lt;code&gt;right&lt;/code&gt; - Давайте немного расширить его:</target>
        </trans-unit>
        <trans-unit id="5ca3334b72be201a6a79c8d27231d9f82fb916a8" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt;s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8f7ecbf0eb0e715d021c51919b36afbf4f3b1d" translate="yes" xml:space="preserve">
          <source>We maintain the binary incompatibility.</source>
          <target state="translated">Мы сохраняем бинарную несовместимость.</target>
        </trans-unit>
        <trans-unit id="0fd132a408c3e7900b7667b28ffdaffdc2cfda3e" translate="yes" xml:space="preserve">
          <source>We manipulate several arrays in this XSUB. Note that an array is represented internally by an AV* pointer. The functions and macros for manipulating arrays are similar to the functions in Perl: &lt;code&gt;av_top_index&lt;/code&gt; returns the highest index in an AV*, much like $#array; &lt;code&gt;av_fetch&lt;/code&gt; fetches a single scalar value from an array, given its index; &lt;code&gt;av_push&lt;/code&gt; pushes a scalar value onto the end of the array, automatically extending the array as necessary.</source>
          <target state="translated">В этом XSUB мы манипулируем несколькими массивами. Обратите внимание, что массив внутри представлен указателем AV *. Функции и макросы для управления массивами аналогичны функциям в Perl: &lt;code&gt;av_top_index&lt;/code&gt; возвращает наивысший индекс в AV *, что очень похоже на массив $ #; &lt;code&gt;av_fetch&lt;/code&gt; извлекает одно скалярное значение из массива по его индексу; &lt;code&gt;av_push&lt;/code&gt; помещает скалярное значение в конец массива, автоматически расширяя массив по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="6201b3e74828151a0b8123986740745576c51a04" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">Мы можем изменить его так, чтобы вещи, которые остаются легальным использованием в обычных классах символов в квадратных скобках, могли стать незаконными в рамках этой экспериментальной конструкции. Одно из предложений, например, - запретить соседнее использование одного и того же символа, как в &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . Мотивация для такого изменения заключается в том, что это использование, вероятно, является опечаткой, поскольку второе &amp;laquo;а&amp;raquo; ничего не добавляет.</target>
        </trans-unit>
        <trans-unit id="6f8e2edefd5e426a509917090b4bcf0d615987a3" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt;. The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8db65a7f163486a998a7bf47269c4123bd2dc9" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that most Perl objects are implemented as hashes under the hood. The principle of encapsulation tells us that we should not rely on this. Instead, we should use accessor methods to access the data in that hash. The object systems that we recommend below all automate the generation of accessor methods. If you use one of them, you should never have to access the object as a hash directly.</source>
          <target state="translated">Ранее мы упоминали,что большинство объектов Perl реализованы в виде хэшей под капотом.Принцип инкапсуляции говорит нам,что мы не должны полагаться на это.Вместо этого мы должны использовать методы доступа к данным в этом хэше.Объектные системы,которые мы рекомендуем ниже,автоматизируют генерацию методов доступа.Если вы используете один из них,вы никогда не должны иметь прямого доступа к объекту в виде хэша.</target>
        </trans-unit>
        <trans-unit id="fd2e3b2237cf2c9ebd6d21ee18dff2f93d4edaee" translate="yes" xml:space="preserve">
          <source>We mentioned multiple inheritance earlier. The main problem with multiple inheritance is that it greatly complicates method resolution. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more details.</source>
          <target state="translated">Мы упоминали множественное наследование ранее. Основная проблема множественного наследования заключается в том, что оно значительно усложняет разрешение метода. См. &lt;a href=&quot;perlobj&quot;&gt;Perlobj&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="05de83678232988de23cc08caee2a559bec4d96c" translate="yes" xml:space="preserve">
          <source>We must know how much to read.</source>
          <target state="translated">Мы должны знать,сколько читать.</target>
        </trans-unit>
        <trans-unit id="786b499d8e7780442a91c12acac79f0bab40bb9c" translate="yes" xml:space="preserve">
          <source>We now compile up Perl, and run it through the test suite. Our new tests pass, hooray!</source>
          <target state="translated">Теперь мы собираем Perl и прогоняем его через тестовый набор.Наши новые тесты проходят,ура!</target>
        </trans-unit>
        <trans-unit id="885cb8f93d773c304687f5c7d8f7995e03fd1f70" translate="yes" xml:space="preserve">
          <source>We now know how to create choices among classes of characters in a regexp. What about choices among words or character strings? Such choices are described in the next section.</source>
          <target state="translated">Теперь мы знаем,как создавать выбор между классами символов в регэкспозиции.А как насчет выбора между словами или строками символов? Такие варианты описаны в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="68e3b46c3317fe81b8a4f43f4375d9dc3eef2342" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass/subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">Мы часто называем отношения наследования отношениями &lt;b&gt;родитель-потомок&lt;/b&gt; или отношения &lt;code&gt;superclass/subclass&lt;/code&gt; . Иногда мы говорим, что у ребенка есть отношения &lt;b&gt;is-a&lt;/b&gt; со своим родительским классом.</target>
        </trans-unit>
        <trans-unit id="99514bb04979cf0a47e2cf2b143ea1390fb7e139" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass&lt;/code&gt;/&lt;code&gt;subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fd14d3b6f6bb386e0f6cc77e29f8b6538c7a73" translate="yes" xml:space="preserve">
          <source>We recognize that the Perl core, defined as the software distributed with the heart of Perl itself, is a joint project on the part of all of us. From time to time, a script, module, or set of modules (hereafter referred to simply as a &quot;module&quot;) will prove so widely useful and/or so integral to the correct functioning of Perl itself that it should be distributed with the Perl core. This should never be done without the author's explicit consent, and a clear recognition on all parts that this means the module is being distributed under the same terms as Perl itself. A module author should realize that inclusion of a module into the Perl core will necessarily mean some loss of control over it, since changes may occasionally have to be made on short notice or for consistency with the rest of Perl.</source>
          <target state="translated">Мы признаем,что ядро Perl,определяемое как программное обеспечение,распространяемое с сердцем самого Perl,является совместным проектом всех нас.Время от времени скрипт,модуль или набор модулей (здесь и далее называемых просто &quot;модулем&quot;)будет доказывать настолько широкую полезность и/или настолько неотъемлемую часть правильного функционирования самого Perl,что он должен распространяться вместе с ядром Perl.Это никогда не должно делаться без явного согласия автора и четкого признания всеми частями того,что это означает,что модуль распространяется на тех же условиях,что и сам Perl.Автор модуля должен понимать,что включение модуля в ядро Perl обязательно будет означать некоторую потерю контроля над ним,так как иногда изменения могут быть сделаны в кратчайшие сроки или для согласования с остальными частями Perl.</target>
        </trans-unit>
        <trans-unit id="adbff354730155d973632a844ddac8001f83317b" translate="yes" xml:space="preserve">
          <source>We recommend InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</source>
          <target state="translated">Мы рекомендуем InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f1a977094921f3a67ec1b5d153f5c0398eec08d" translate="yes" xml:space="preserve">
          <source>We recommend ptar from Archive::Tar not older than 1.66 with '-C' option.</source>
          <target state="translated">Мы рекомендуем использовать ptar из Archive::Tar не старше 1.66 с опцией '-C'.</target>
        </trans-unit>
        <trans-unit id="cbe1fc263dadb40ca151eed92966c9248a04de8d" translate="yes" xml:space="preserve">
          <source>We recommend that you avoid this syntax, for several reasons.</source>
          <target state="translated">Мы рекомендуем избегать этого синтаксиса по нескольким причинам.</target>
        </trans-unit>
        <trans-unit id="579e792fc6edac0deca16c23591b561128b4c15e" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</source>
          <target state="translated">Мы рекомендуем вам обращаться к атрибутам только через методы &lt;b&gt;доступа&lt;/b&gt; . Это методы, которые могут получать или устанавливать значение каждого атрибута. Мы видели это ранее в &lt;code&gt;print_info()&lt;/code&gt; , который вызывает &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c3f8a0812714182851aed9fbbd140faf18d7041" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd090bb786563ac9394aa0d7f58e631fb54d86e" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt; . The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">Мы рекомендуем вам использовать этот метод для доступа к другой версии пакета, а не напрямую смотреть на &lt;code&gt;$Package::VERSION&lt;/code&gt; . Пакет, который вы смотрите, мог переопределить метод &lt;code&gt;VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6418d5ecc21157f156342ad6f603ad1e78f241b1" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt;. The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3584759389d1a5c9463e1916b5f8cba299128724" translate="yes" xml:space="preserve">
          <source>We said that references spring into existence as necessary if they are undefined, but we didn't say what happens if a value used as a reference is already defined, but</source>
          <target state="translated">Мы сказали,что ссылки появляются по мере необходимости,если они не определены,но мы не сказали,что произойдет,если значение,используемое в качестве ссылки,уже определено,но</target>
        </trans-unit>
        <trans-unit id="66792931fda90822c58a9263a870978d6e867c09" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;'\'&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;']'&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;'$'&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;'\'&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e706dab14e9082a067c69407d520e37d14c840" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;\&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;]&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;$&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;\&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">В разделе выше мы видели, что были обычные символы, которые представляли самих себя, и специальные символы, которым для представления самих себя требовалась обратная косая черта &lt;code&gt;\&lt;/code&gt; . То же самое верно и для класса символов, но наборы обычных и специальных символов внутри класса символов отличаются от наборов вне класса символов. Специальными символами для класса символов являются &lt;code&gt;-]\^$&lt;/code&gt; (и разделитель шаблона, какой бы он ни был). &lt;code&gt;]&lt;/code&gt; является особенным, поскольку обозначает конец класса символов. &lt;code&gt;$&lt;/code&gt; особенный, потому что он обозначает скалярную переменную. &lt;code&gt;\&lt;/code&gt; является особенным, потому что он используется в escape-последовательностях, как указано выше. Вот как обрабатываются специальные символы &lt;code&gt;]$\&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="91ab61be245cfbe060001be5799707fcb012f47d" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">Мы видели, что норма &lt;code&gt;z&lt;/code&gt; была обозначена как &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; и определялась как расстояние до начала координат, также известное как:</target>
        </trans-unit>
        <trans-unit id="e2c4be4000d0f7dd961c043239fc9f3b3b2b02bf" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;abs(z)&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08920844359a9b99eec6c4ed6a36e0f532af1cca" translate="yes" xml:space="preserve">
          <source>We show the &quot;put&quot; form of the accessors below (i.e., the syntax you use for setting the accessor to a specific value). But you can also call each method with no parameters to get its current value. For example, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; returns the current value of the contents_file attribute.</source>
          <target state="translated">Ниже мы показываем форму &quot;put&quot; для средств доступа (т. Е. Синтаксис, который вы используете для установки для средства доступа определенного значения). Но вы также можете вызвать каждый метод без параметров, чтобы получить его текущее значение. Например, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; возвращает текущее значение атрибута contents_file.</target>
        </trans-unit>
        <trans-unit id="d711adc8921158fc2754824f56564036d9f3cc37" translate="yes" xml:space="preserve">
          <source>We specify a local port in the &lt;code&gt;LocalPort&lt;/code&gt; argument, which we didn't do for the client. This is service name or port number for which you want to be the server. (Under Unix, ports under 1024 are restricted to the superuser.) In our sample, we'll use port 9000, but you can use any port that's not currently in use on your system. If you try to use one already in used, you'll get an &quot;Address already in use&quot; message. Under Unix, the &lt;code&gt;netstat -a&lt;/code&gt; command will show which services current have servers.</source>
          <target state="translated">Мы указываем локальный порт в аргументе &lt;code&gt;LocalPort&lt;/code&gt; , чего мы не делали для клиента. Это имя службы или номер порта, для которого вы хотите быть сервером. (В Unix порты ниже 1024 доступны только суперпользователю.) В нашем примере мы будем использовать порт 9000, но вы можете использовать любой порт, который в настоящее время не используется в вашей системе. Если вы попытаетесь использовать один из уже используемых, вы получите сообщение &amp;laquo;Адрес уже используется&amp;raquo;. В Unix команда &lt;code&gt;netstat -a&lt;/code&gt; покажет, какие текущие службы имеют серверы.</target>
        </trans-unit>
        <trans-unit id="d2e82c57891dd489170077bbfa6bd5d7eef124d7" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt; . Some of them are the result of using bison. Bison prints</source>
          <target state="translated">У нас все еще есть несколько ошибок во время &lt;code&gt;make test&lt;/code&gt; . Некоторые из них - результат использования зубров. Отпечатки зубров</target>
        </trans-unit>
        <trans-unit id="caf05cb06344b1573e32848467a1dff2088a1df3" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt;. Some of them are the result of using bison. Bison prints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d27fd099f66e666f815d6a063eb846b9d1e750a" translate="yes" xml:space="preserve">
          <source>We still use the normal yacc for a2p.y though!!! We made a softlink called byacc to distinguish between the two versions:</source>
          <target state="translated">Мы все еще используем обычный якк для a2p.y!!! Мы сделали мягкую ссылку,называемую byacc,чтобы различать между двумя версиями:</target>
        </trans-unit>
        <trans-unit id="f7a01cac535c65877c2cb721bb86383129124455" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use git if possible. It will make your life easier, and ours as well.</source>
          <target state="translated">Мы настоятельно рекомендуем по возможности использовать git.Это сделает вашу жизнь легче,и нашу тоже.</target>
        </trans-unit>
        <trans-unit id="c1224f92134a2160e75f8a1e63e0730529cc456d" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use one of these systems. Even the most minimal of them eliminates a lot of repetitive boilerplate. There's really no good reason to write your classes from scratch in Perl.</source>
          <target state="translated">Мы настоятельно рекомендуем использовать одну из этих систем.Даже самая минимальная из них устраняет много повторяющихся шаблонов.На самом деле нет веской причины писать свои классы с нуля на Perl.</target>
        </trans-unit>
        <trans-unit id="5f4fa8e578a8c0a7391c3d072ae8a1a053f0a384" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">Мы стараемся избегать этого термина, потому что он означает очень многое. Это может означать &lt;b&gt;переключатель&lt;/b&gt; командной строки, который сам по себе не принимает аргументов (например, флаги Perl &lt;code&gt;&amp;ndash;n&lt;/code&gt; и &lt;code&gt;&amp;ndash;p&lt;/code&gt; ) или, реже, однобитовый индикатор (например, флаги &lt;code&gt;O_CREAT&lt;/code&gt; и &lt;code&gt;O_EXCL&lt;/code&gt; , используемые в &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ). Иногда неофициально используется для обозначения определенных модификаторов регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="4d3626274dd1f26da66510777516b4ddde9437ec" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;sysopen&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3b4e98c264bb32d9998c5d96e9cb12719e9b31" translate="yes" xml:space="preserve">
          <source>We then do (always a good idea) a syntax check before we try to run it again:</source>
          <target state="translated">Затем мы делаем (всегда хорошая идея)проверку синтаксиса перед тем,как попытаться запустить его снова:</target>
        </trans-unit>
        <trans-unit id="a54d539385035f7d9714e68587e437b9e809a0a4" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;.</source>
          <target state="translated">Мы используем термин &amp;laquo;почти&amp;raquo;, потому что &lt;code&gt;:not_characters&lt;/code&gt; также включает &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; unicode_strings в пределах своей области действия. Эта форма менее полезна в v5.20 и более поздних версиях и полностью описана в &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode и UTF-8&lt;/a&gt; , но вкратце говорит Perl не использовать символьные части определения локали, то есть категории &lt;code&gt;LC_CTYPE&lt;/code&gt; и &lt;code&gt;LC_COLLATE&lt;/code&gt; . Вместо этого он будет использовать собственный набор символов (расширенный Unicode). При использовании этого параметра вы несете ответственность за перевод внешнего набора символов в собственный / Unicode (который уже будет, если это одна из все более популярных локалей UTF-8). Есть удобные способы сделать это, как описано в &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode и UTF-8.&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ff19ea46c35bfebd3ad06b673f58043424fd7951" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72bbd81e111127cc31735e5170b3d3ebdc6c5df" translate="yes" xml:space="preserve">
          <source>We used version 1.2.4, which could be installed out of the box with one failure during 'make check'.</source>
          <target state="translated">Мы использовали версию 1.2.4,которая могла быть установлена вне коробки с одним сбоем во время 'make check'.</target>
        </trans-unit>
        <trans-unit id="aff45f6c939582aab469b75158efc5869d3a2fcf" translate="yes" xml:space="preserve">
          <source>We want to be able to catch the</source>
          <target state="translated">Мы хотим быть в состоянии поймать</target>
        </trans-unit>
        <trans-unit id="da129d4b3f31bc7e0cab0dd659997b6d3ef9282c" translate="yes" xml:space="preserve">
          <source>We want to ensure that Perl continues to grow and flourish in the coming years and decades, but not at the expense of our user community.</source>
          <target state="translated">Мы хотим быть уверенными в том,что Perl будет продолжать расти и процветать в ближайшие годы и десятилетия,но не за счет нашего сообщества пользователей.</target>
        </trans-unit>
        <trans-unit id="7602b11fb920ddd30994aa4313930abda93469a9" translate="yes" xml:space="preserve">
          <source>We wanted list context, so G_ARRAY was used.</source>
          <target state="translated">Нам нужен был контекст списка,поэтому был использован G_ARRAY.</target>
        </trans-unit>
        <trans-unit id="8da0820534457147c458ba35d650b1d2014dcd98" translate="yes" xml:space="preserve">
          <source>We will accept 1.00 and 1.75 but not 0.50 or 2.00.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3134ffe8598077df7a151748c12e387529c7d2bc" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt; &quot;. You should see output that looks something like this:</source>
          <target state="translated">Мы будем вызывать тестовый скрипт через команду &amp;laquo; &lt;code&gt;make test&lt;/code&gt; &amp;raquo;. Вы должны увидеть результат, который выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="bed8e3523336143bfae3d838324a0aad3e70112e" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt;&quot;. You should see output that looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6f3f09fa5bfb41f8f72f761c01531e59969f1d" translate="yes" xml:space="preserve">
          <source>We will not provide security updates or bug fixes for development releases of Perl.</source>
          <target state="translated">Мы не будем предоставлять обновления безопасности или исправления ошибок для разрабатываемых релизов Perl.</target>
        </trans-unit>
        <trans-unit id="788212053c8b040e14cd53eba253eacd9f8cbdce" translate="yes" xml:space="preserve">
          <source>We will now create the main top-level Mytest2 files. Change to the directory above Mytest2 and run the following command:</source>
          <target state="translated">Теперь мы создадим основные файлы верхнего уровня Mytest2.Перейдите в каталог выше Mytest2 и выполните следующую команду:</target>
        </trans-unit>
        <trans-unit id="d22caa360403eba16e21b51e9ea68e688fb5cc28" translate="yes" xml:space="preserve">
          <source>We would all love to unmake some mistakes we've made over the past decades. Living with every design error we've ever made can lead to painful stagnation. Unwinding our mistakes is very, very difficult. Doing so without actively harming our users is nearly impossible.</source>
          <target state="translated">Мы все хотели бы разоблачить некоторые ошибки,которые мы совершили за последние десятилетия.Жизнь с каждой ошибкой дизайна,которую мы когда-либо совершали,может привести к болезненному застою.Раскручивать наши ошибки очень,очень трудно.Делать это,не причиняя активного вреда нашим пользователям,практически невозможно.</target>
        </trans-unit>
        <trans-unit id="461ccef8111ec963260713b6b25723c4d738d9a8" translate="yes" xml:space="preserve">
          <source>We'll come back to this city-country problem later, after we've seen some syntax for managing references.</source>
          <target state="translated">Мы вернемся к проблеме этой городской страны позже,после того,как увидим синтаксис для управления ссылками.</target>
        </trans-unit>
        <trans-unit id="25d0051932de21aa64fc90927fc210fd1faca62f" translate="yes" xml:space="preserve">
          <source>We'll get to testing the contents of lists later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbf9f8ec2dcbf019622a935f28d55742617ea78" translate="yes" xml:space="preserve">
          <source>We'll get to the meaning of those Perlish-looking variables in a little bit.</source>
          <target state="translated">Скоро мы разберемся со значением этих перлийских переменных.</target>
        </trans-unit>
        <trans-unit id="ccbe83524a5012d45f354f697c95fa9a1eb5367f" translate="yes" xml:space="preserve">
          <source>We'll have another string pointer in there:</source>
          <target state="translated">У нас там будет еще один указатель на струну:</target>
        </trans-unit>
        <trans-unit id="5672edbff82e9ae33e95bbfe34109b2db08b3398" translate="yes" xml:space="preserve">
          <source>We'll look at output first. Supposing we already have this structure, how do we print it out?</source>
          <target state="translated">Сначала посмотрим на результат.Предположим,что у нас уже есть эта структура,как мы ее распечатаем?</target>
        </trans-unit>
        <trans-unit id="8801992116fa36a8b481455c1f17fda02ba0a864" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">Мы увидим более сложный пример этого, когда рассмотрим макросы Perl ниже. &lt;code&gt;POPn&lt;/code&gt; дает вам NV (значение с плавающей запятой) верхнего SV в стеке: &lt;code&gt;$x&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt; . Затем мы вычисляем косинус и возвращаем результат в виде NV. &lt;code&gt;X&lt;/code&gt; в &lt;code&gt;XPUSHn&lt;/code&gt; означает , что стек должен быть продлен в случае необходимости - оно не может быть необходимым здесь, потому что мы знаем , что есть место для еще одного элемента в стеке, так как мы только что удалили один! В &lt;code&gt;XPUSH*&lt;/code&gt; макросы по крайней мере гарантируют безопасность.</target>
        </trans-unit>
        <trans-unit id="56f64cd868fbb648df894ffa687bba0fcd06f58c" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;cos($x)&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55bbd57ee31a3c27c5821f6c991f3bb8fbebc65" translate="yes" xml:space="preserve">
          <source>We'll simply continue down to our pre-set breakpoint with a '&lt;b&gt;c&lt;/b&gt;':</source>
          <target state="translated">Мы просто продолжим до нашей предустановленной точки останова с буквой ' &lt;b&gt;c&lt;/b&gt; ':</target>
        </trans-unit>
        <trans-unit id="a9a2d405fbc50682e1a3c2bf95879ebe85538d93" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt; ), but check the manual of the one you're using.</source>
          <target state="translated">Здесь мы будем использовать &lt;code&gt;gdb&lt;/code&gt; для наших примеров; принципы применимы к любому отладчику (многие поставщики называют свой отладчик &lt;code&gt;dbx&lt;/code&gt; ), но проверьте руководство того, который вы используете.</target>
        </trans-unit>
        <trans-unit id="59bfed3e1550313113be0311ae2b9d42ec0cb5e3" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt;), but check the manual of the one you're using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd00180725dcce313c6ef1b86501c9848503c2c0" translate="yes" xml:space="preserve">
          <source>We'll use Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Мы будем использовать Jarkko Hietaniemi &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f54f2656a6244346ba143809ce965c3e152258c1" translate="yes" xml:space="preserve">
          <source>We're Netware in addition to being Windows.</source>
          <target state="translated">Мы-Netware в дополнение к тому,что мы-Windows.</target>
        </trans-unit>
        <trans-unit id="89a6bcd8665abf52d39396f9fea984b5d7d01f5f" translate="yes" xml:space="preserve">
          <source>We're Unix and Cygwin.</source>
          <target state="translated">Мы Юникс и Сигвин.</target>
        </trans-unit>
        <trans-unit id="bae7bf51fd64828a801e9cd04e2c5e1eac38f446" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt; , and the value, the SV &lt;code&gt;val&lt;/code&gt; .</source>
          <target state="translated">Мы собираемся добавить еще два элемента в стек аргументов: когда у вас есть связанный массив, подпрограмма &lt;code&gt;PUSH&lt;/code&gt; получает объект и значение, которое нужно передать, и это именно то, что у нас есть - связанный объект, полученный с помощью &lt;code&gt;SvTIED_obj&lt;/code&gt; , и значение SV &lt;code&gt;val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85ee9a622e2cfbf55a87677c4c0c5ab7baea463" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt;, and the value, the SV &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81984db06bb6ffc7cc8657839e60eed19d2e59d4" translate="yes" xml:space="preserve">
          <source>We're going to be wanting to test a lot of dates here, trying to trick the code with lots of different edge cases. Does it work before 1970? After 2038? Before 1904? Do years after 10,000 give it trouble? Does it get leap years right? We could keep repeating the code above, or we could set up a little try/expect loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982b2dd7e00a50956cc41a996392e78491465b29" translate="yes" xml:space="preserve">
          <source>We're going to primarily concentrate on Perl-only modules here, rather than XS modules. XS modules serve a rather different purpose, and you should consider different things before distributing them - the popularity of the library you are gluing, the portability to other operating systems, and so on. However, the notes on preparing the Perl side of the module and packaging and distributing it will apply equally well to an XS module as a pure-Perl one.</source>
          <target state="translated">Здесь мы в первую очередь сконцентрируемся на модулях только для Perl-,а не на модулях XS.Модули XS служат совсем другому назначению,и перед их распространением следует подумать о разных вещах-о популярности приклеиваемой библиотеки,о переносимости на другие операционные системы и так далее.Однако примечания по подготовке Perl-части модуля,упаковке и распространению его будут одинаково хорошо относиться и к модулю XS,и к чисто Perl-части.</target>
        </trans-unit>
        <trans-unit id="017f7465d1bdb163c7a89743859d67e419fc8784" translate="yes" xml:space="preserve">
          <source>We've added more detail about what we're testing and the ICal string itself we're trying out to the name. So you get results like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34118bf3962978ee960cb834c23b6a7907e48ac6" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">Мы уже видели, как печатать на стандартный вывод с помощью &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; . Однако &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; также может принимать необязательный первый аргумент, определяющий, какой дескриптор файла для печати:</target>
        </trans-unit>
        <trans-unit id="a86cb468eaa36ca78f91ded52784d1ac7c3b8af3" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;print()&lt;/code&gt;. However, &lt;code&gt;print()&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a8063bdaca09993ddd8d252b857fa09a430a49" translate="yes" xml:space="preserve">
          <source>We've also told Perl about the library that we built in the mylib subdirectory. That required only the addition of the &lt;code&gt;MYEXTLIB&lt;/code&gt; variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make. The Makefile.PL for the library is a bit more complicated, but not excessively so. Again we replaced the postamble subroutine to insert our own code. This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it.</source>
          <target state="translated">Мы также рассказали Perl о библиотеке, которую мы создали в подкаталоге mylib. Для этого потребовалось только &lt;code&gt;MYEXTLIB&lt;/code&gt; переменную MYEXTLIB к вызову WriteMakefile и заменить подпрограмму postamble на cd в подкаталог и запустить make. Makefile.PL для библиотеки немного сложнее, но не слишком. Мы снова заменили подпрограмму postamble на вставку собственного кода. В этом коде просто указано, что создаваемая здесь библиотека представляет собой статическую архивную библиотеку (в отличие от динамически загружаемой библиотеки), и предоставлены команды для ее создания.</target>
        </trans-unit>
        <trans-unit id="6afd998315c2c6324bb813d112e9a8f30bf0d582" translate="yes" xml:space="preserve">
          <source>We've covered the workhorse parts of Perl's threading package, and with these tools you should be well on your way to writing threaded code and packages. There are a few useful little pieces that didn't really fit in anyplace else.</source>
          <target state="translated">Мы рассмотрели рабочие лошадки пакета Perl,и с помощью этих инструментов вы должны хорошо подготовиться к написанию потокового кода и пакетов.Есть несколько полезных маленьких кусочков,которые больше нигде не поместились.</target>
        </trans-unit>
        <trans-unit id="b4d69ed91d0829df5cfa125f68b479f5de86f05f" translate="yes" xml:space="preserve">
          <source>We've gone past our check (where 'All OK' was printed) and have stopped just before the meat of our task. We could try to print out a couple of variables to see what is happening:</source>
          <target state="translated">Мы прошли мимо нашей проверки (где было напечатано 'All OK')и остановились прямо перед мясом нашей задачи.Мы могли бы попробовать распечатать пару переменных,чтобы посмотреть,что происходит:</target>
        </trans-unit>
        <trans-unit id="33a66a35950ff295dc8b9c6a23c44bcace53edc3" translate="yes" xml:space="preserve">
          <source>We've had Larry's h2ph translator, which helped, but that only works on cpp symbols, not real C, which was also very much needed. What I offer you is a symbolic way of getting at all the C structures. I've couched them in terms of packages and functions. Consider the following program:</source>
          <target state="translated">У нас был переводчик h2ph Ларри,который помог,но он работает только на символах cpp,а не на настоящей C,которая тоже очень нужна.То,что я предлагаю вам-это символический способ получить все структуры C.Я их разложил по пакетам и функциям.Рассмотрим следующую программу:</target>
        </trans-unit>
        <trans-unit id="f3af9852bf7e4f70a4af9b26111fb8e3956f866b" translate="yes" xml:space="preserve">
          <source>We've made some changes to Makefile.PL. In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case. We'll talk later about how to write XSUBs that can call every routine in a library.</source>
          <target state="translated">Мы внесли некоторые изменения в Makefile.PL.В данном случае мы указали дополнительную библиотеку,которая будет компоноваться в разделяемую библиотеку расширения,в данном случае математическую библиотеку libm.Позже мы поговорим о том,как писать XSUBs,которые могут вызывать каждую рутину в библиотеке.</target>
        </trans-unit>
        <trans-unit id="a904b7cf0e87b370c484aeda4a3fd7921273c345" translate="yes" xml:space="preserve">
          <source>We've seen how to encourage good coding practices with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;-w&lt;/b&gt;. We can run the perl debugger &lt;b&gt;perl -d scriptname&lt;/b&gt; to inspect your data from within the perl debugger with the &lt;b&gt;p&lt;/b&gt; and &lt;b&gt;x&lt;/b&gt; commands. You can walk through your code, set breakpoints with &lt;b&gt;b&lt;/b&gt; and step through that code with &lt;b&gt;s&lt;/b&gt; or &lt;b&gt;n&lt;/b&gt;, continue with &lt;b&gt;c&lt;/b&gt; and return from a sub with &lt;b&gt;r&lt;/b&gt;. Fairly intuitive stuff when you get down to it.</source>
          <target state="translated">Мы видели, как поощрять хорошие методы кодирования с &lt;b&gt;помощью использования strict&lt;/b&gt; и &lt;b&gt;-w&lt;/b&gt; . Мы можем запустить отладчик &lt;b&gt;perl perl -d scriptname,&lt;/b&gt; чтобы проверить ваши данные из отладчика perl с помощью команд &lt;b&gt;p&lt;/b&gt; и &lt;b&gt;x&lt;/b&gt; . Вы можете пройтись по вашему коду, установить точки останова с помощью &lt;b&gt;b&lt;/b&gt; и пройти по этому коду с помощью &lt;b&gt;s&lt;/b&gt; или &lt;b&gt;n&lt;/b&gt; , продолжить с помощью &lt;b&gt;c&lt;/b&gt; и вернуться из подпрограммы с помощью &lt;b&gt;r&lt;/b&gt; . Довольно интуитивно понятный материал, когда вы к нему приступаете.</target>
        </trans-unit>
        <trans-unit id="9f4aba3ac8d090b513bcacbad039797adbe73abe" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; could not unpack all. If &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">Мы приложили некоторые усилия, чтобы создать шаблон, чтобы он соответствовал содержимому нашего буфера кадра. В противном случае мы либо получили бы неопределенные значения, либо &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; не смог бы распаковать все. Если в &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; заканчиваются элементы, он предоставит пустые строки (которые приводятся к нулю всякий раз, когда это указано в коде пакета).</target>
        </trans-unit>
        <trans-unit id="f58946de758298d15363eecb7f69802745a7c62d" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;unpack&lt;/code&gt; could not unpack all. If &lt;code&gt;pack&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc93f698eef77381e152ba1261b27e22014722" translate="yes" xml:space="preserve">
          <source>We've tried to make this also work with the TODO: syntax, but it's not guaranteed and its use is also discouraged:</source>
          <target state="translated">Мы пытались сделать так,чтобы это также работало с синтаксисом TODO:,но это не гарантировано,и его использование также не поощряется:</target>
        </trans-unit>
        <trans-unit id="d057d23b834db4b8d50936a9c8b48cc9bb56ac94" translate="yes" xml:space="preserve">
          <source>We've tried to minimize the dependence of Perl library modules on Unix syntax, but you may find that some of these, as well as some scripts written for Unix systems, will require that you use Unix syntax, since they will assume that '/' is the directory separator,</source>
          <target state="translated">Мы попытались минимизировать зависимость модулей Perl-библиотек от синтаксиса Unix,но вы можете обнаружить,что некоторые из них,а также некоторые скрипты,написанные для Unix-систем,потребуют использования синтаксиса Unix,так как они будут предполагать,что '/'-это разделитель каталогов,</target>
        </trans-unit>
        <trans-unit id="f63c6786d8c83343c69f80cf76418c3681700514" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt; . It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">Мы использовали хеш-срез, чтобы легко обрабатывать поля каждой строки. Хранение ключей в массиве позволяет легко работать с ними как с группой или перебирать их с помощью &lt;code&gt;for&lt;/code&gt; . Это также позволяет избежать загрязнения программы глобальными переменными и использованием символических ссылок.</target>
        </trans-unit>
        <trans-unit id="bf3e9bec5bbd0148b6e7d79050e64cd6c33fa0da" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt;. It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3244b33262d5fd2e0388c2e8910db847842e8800" translate="yes" xml:space="preserve">
          <source>Weak references are not implemented in the version of perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e147d82cb4cdd9e073d031a1a26cd0222dd868d0" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared.</source>
          <target state="translated">Ослабьте ссылку: установите флаг &lt;code&gt;SvWEAKREF&lt;/code&gt; на этом RV; передайте упомянутому SV магию &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; , если она еще не была; и вставьте обратную ссылку на этот RV в массив обратных ссылок, связанных с этой магией. Если RV является магическим, то после очистки RV будет вызываться set magic.</target>
        </trans-unit>
        <trans-unit id="1b546f1ca2e1f3276683dab2157d9406b01bfa5c" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on already-weak references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4b4063ed2668451305a4ea955df5abd08928f3" translate="yes" xml:space="preserve">
          <source>Weakrefs call uvar magic</source>
          <target state="translated">Слабые называют уварную магию</target>
        </trans-unit>
        <trans-unit id="d99719368087fdb5886c0da04e1ec7aa5bb1e097" translate="yes" xml:space="preserve">
          <source>Web::Simple</source>
          <target state="translated">Web::Simple</target>
        </trans-unit>
        <trans-unit id="a87a48da60ac110880ba420c176bfa3b966a1bbc" translate="yes" xml:space="preserve">
          <source>Websites</source>
          <target state="translated">Websites</target>
        </trans-unit>
        <trans-unit id="c46c01995b645fa6ced7ccd3bd695a2325cf2829" translate="yes" xml:space="preserve">
          <source>Weed out arguments that are not supported and warn about them to the user</source>
          <target state="translated">Вычищаем не поддерживаемые аргументы и предупреждаем о них пользователя.</target>
        </trans-unit>
        <trans-unit id="5ff64b425852808bfa9bcc07404d47fe62f5255b" translate="yes" xml:space="preserve">
          <source>Week Number</source>
          <target state="translated">Номер недели</target>
        </trans-unit>
        <trans-unit id="e47cfca7176dccc849b8b9085335ec9965e39788" translate="yes" xml:space="preserve">
          <source>Weighting CJK Unified Ideographs</source>
          <target state="translated">Унифицированные идеографы CJK.</target>
        </trans-unit>
        <trans-unit id="6b33b573e9b7a7f05800470ad22d2691de1ad1d8" translate="yes" xml:space="preserve">
          <source>Weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">Взвешивание Джис Канджи для Юникода::Коллат</target>
        </trans-unit>
        <trans-unit id="b6757ec0e4d4ce4eae1496f199fc7aa0d085efea" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">Вес может варьироваться в зависимости от таблицы элементов сопоставления. Поэтому убедитесь, что веса, определенные в &lt;code&gt;entry&lt;/code&gt; будут согласованы с весами в таблице элементов сопоставления, загруженной через &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="782d47b6879e710497644ef8bf508107805123e1" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bdfd154d71780792f4f6d415a46881c01b84f" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; ), forwards at all the levels.</source>
          <target state="translated">Вес в обратном порядке; напр. уровень 2 (диакритический порядок) во французском языке. Если опущено (или &lt;code&gt;$levelNumber&lt;/code&gt; равно &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;\@levelNumbers&lt;/code&gt; равно &lt;code&gt;[]&lt;/code&gt; ), выполняется пересылка на всех уровнях.</target>
        </trans-unit>
        <trans-unit id="07918c7bf0f5c02def4accb22b2496ee08472e26" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;), forwards at all the levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfee8775f2eb957a8724a08c2efd8dbdd2166cc" translate="yes" xml:space="preserve">
          <source>Well it may seem that way, but it does not. The verify method returns true if the command succeeded. If you pass verify an address which the server would normally have to forward to another machine, the command will succeed with something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ade9c702a20a6384a7a0b9552d289287a18c722" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">Ну, кроме голого &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , особо к ним обращаться не стоит. (Режим bin необходим, потому что в противном случае Perl может преобразовать окончания строк в системах Win32.)</target>
        </trans-unit>
        <trans-unit id="48bbf4d297e0c1ca5f48035948fb4a98aa2511d6" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;binmode $fh&lt;/code&gt;, you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504ec4c7237da89364f87b2aad3291cf833f70a8" translate="yes" xml:space="preserve">
          <source>Well, having several executables dynamically linked to the same huge library has its advantages, but this would not substantiate the additional work to make it compile. The reason is the complicated-to-developers but very quick and convenient-to-users &quot;hard&quot; dynamic linking used by OS/2.</source>
          <target state="translated">Ну,наличие нескольких исполняемых файлов,динамически связанных с одной и той же огромной библиотекой,имеет свои преимущества,но это не обосновывает дополнительную работу по ее компиляции.Причина-сложная для разработчиков,но очень быстрая и удобная для пользователей &quot;жесткая&quot; динамическая компоновка,используемая в OS/2.</target>
        </trans-unit>
        <trans-unit id="b4bf2ee14e4e81fc05f1087aeed820b042b0028b" translate="yes" xml:space="preserve">
          <source>Well, if you can, upgrade to the most recent, but certainly &lt;code&gt;5.8.1&lt;/code&gt; or newer. The tutorial and FAQ assume the latest release.</source>
          <target state="translated">Что ж, если можете, обновитесь до самой последней, но обязательно &lt;code&gt;5.8.1&lt;/code&gt; или новее. В руководстве и FAQ используется последняя версия.</target>
        </trans-unit>
        <trans-unit id="c922bdb3f23d6c5306883fe0bee806df01fe877f" translate="yes" xml:space="preserve">
          <source>Well, maybe not. Anyway, each op contains a function pointer, which stipulates the function which will actually carry out the operation. This function will return the next op in the sequence - this allows for things like &lt;code&gt;if&lt;/code&gt; which choose the next op dynamically at run time. The &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; makes sure that things like signals interrupt execution if required.</source>
          <target state="translated">Ну может и нет. В любом случае, каждая операция содержит указатель на функцию, который определяет функцию, которая фактически будет выполнять операцию. Эта функция вернет следующую операцию в последовательности - это позволяет делать такие вещи, как &lt;code&gt;if&lt;/code&gt; , которые динамически выбирают следующую операцию во время выполнения. &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; убеждается , что такие вещи , как сигналы прерывания выполнения , если требуется.</target>
        </trans-unit>
        <trans-unit id="d89d9b138049ae3cace1b14aa62a037a00f5fd6b" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7d8a35468fea02bd934ea87237f211894a5751" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">Что ж, в настоящее время Perl DLL может использоваться и из другой скомпилированной программы ... Если вы можете запускать код Perl из сценариев REXX (см. &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt; ), то есть еще один аспект взаимодействия, который не учитывается текущим хакерским кодом для поддержки основных программ, скомпилированных по-разному.</target>
        </trans-unit>
        <trans-unit id="61cb10844d83ee77c0e38f0deaf6e76838a94cbb" translate="yes" xml:space="preserve">
          <source>Well, okay, not entirely like C's arrays, actually. C doesn't know how to grow its arrays on demand. Perl does.</source>
          <target state="translated">Ну,ладно,не совсем как массивы Си,на самом деле.Си не знает,как выращивать свои массивы по требованию.Перл знает.</target>
        </trans-unit>
        <trans-unit id="c4f3fa326a3af64f93426bcdac847f46a94f9b1b" translate="yes" xml:space="preserve">
          <source>Well, that's</source>
          <target state="translated">Ну,это</target>
        </trans-unit>
        <trans-unit id="bf3871275db74807de50e10189deb9ba1201d5b4" translate="yes" xml:space="preserve">
          <source>Well, that's all fine if you want to send one command and get one answer, but what about setting up something fully interactive, somewhat like the way</source>
          <target state="translated">Ну,это все прекрасно,если вы хотите отправить одну команду и получить один ответ,но как насчет того,чтобы настроить что-то полностью интерактивное,что-то вроде того.</target>
        </trans-unit>
        <trans-unit id="a4fcece5fae45fd55beac8d83dea4ffc7bb1546c" translate="yes" xml:space="preserve">
          <source>Well, that's because the rule is that on adjacent brackets only (whether square or curly), you are free to omit the pointer dereferencing arrow. But you cannot do so for the very first one if it's a scalar containing a reference, which means that $ref_to_AoA always needs it.</source>
          <target state="translated">Это потому,что правило заключается в том,что на соседних скобках (квадратных или фигурных)вы можете опустить стрелку разыменования указателя.Но нельзя сделать это для самого первого,если это скаляр,содержащий ссылку,что означает,что $ref_to_AoA всегда нуждается в ней.</target>
        </trans-unit>
        <trans-unit id="5937ea9ee293b2d54cd64fb9f3a778625f679e1c" translate="yes" xml:space="preserve">
          <source>Well, this isn't very easy to read, and using the helpful manual (&lt;b&gt;h h&lt;/b&gt;), the '&lt;b&gt;x&lt;/b&gt;' command looks promising:</source>
          <target state="translated">Что ж, это не очень легко читать, и, используя полезное руководство ( &lt;b&gt;чч&lt;/b&gt; ), команда ' &lt;b&gt;x&lt;/b&gt; ' выглядит многообещающей:</target>
        </trans-unit>
        <trans-unit id="81775bcb15e4091e227d731dfdef1462a2bf3f2b" translate="yes" xml:space="preserve">
          <source>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</source>
          <target state="translated">Ну,ты можешь держать их синхронизированными,но нет никакой гарантии,что они всегда будут держаться на уроках,которые написал кто-то другой.Кроме того,в этом мало что можно выиграть:сериализующий крюк мог бы сохранить только один атрибут объекта,что,вероятно,не должно происходить во время глубокого клонирования того же самого объекта.</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="c6c58c114eba15fa1fde6b56057cb927734327d9" translate="yes" xml:space="preserve">
          <source>What *is* Unicode, anyway?</source>
          <target state="translated">Что такое Юникод?</target>
        </trans-unit>
        <trans-unit id="2948ac1effa2d43a9756f45e31fc4dfaf54b428e" translate="yes" xml:space="preserve">
          <source>What &lt;b&gt;is&lt;/b&gt; Unicode, anyway?</source>
          <target state="translated">Что &lt;b&gt;такое&lt;/b&gt; Юникод?</target>
        </trans-unit>
        <trans-unit id="0c27997670ea19d058363ea936f9c5a132d90646" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">Что делает &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="828c569308e99c356a11f905449002a24faaf00f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; , or nothing depending on the file organization and record format. The &lt;code&gt;VMS::Stdio&lt;/code&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">Что представляет собой &lt;code&gt;\n&lt;/code&gt; зависит от типа открытого файла. Обычно он представляет собой &lt;code&gt;\012&lt;/code&gt; но также может быть &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; или ничего, в зависимости от файловой организации и формата записи. Модуль &lt;code&gt;VMS::Stdio&lt;/code&gt; обеспечивает доступ к специальным требованиям &lt;code&gt;fopen()&lt;/code&gt; к файлам с необычными атрибутами в VMS.</target>
        </trans-unit>
        <trans-unit id="87fe5c683c90e3c088c772e3615a1786c72c1f86" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, &lt;code&gt;\015\012&lt;/code&gt;, &lt;code&gt;\000&lt;/code&gt;, &lt;code&gt;\040&lt;/code&gt;, or nothing depending on the file organization and record format. The &lt;a href=&quot;VMS::Stdio&quot;&gt;&lt;code&gt;VMS::Stdio&lt;/code&gt;&lt;/a&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1cc41a80c328b4eb792743f378eba1c9a93d1" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">То , что &lt;code&gt;\p{Digit}&lt;/code&gt; средства (и , следовательно , &lt;code&gt;\d&lt;/code&gt; за исключением того, под &lt;code&gt;/a&lt;/code&gt; модификатором) является &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , или синонимично, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Начиная с версии Unicode 4.1, это тот же набор символов, которому соответствует &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . Но Unicode также имеет другое свойство с похожим именем, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , которое соответствует совершенно другому набору символов. Эти символы представляют собой такие &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; как ОБЪЕДИНЕННАЯ ЦИФРА ОДИН или нижние индексы, или из систем письма, в которых отсутствуют все десять цифр.</target>
        </trans-unit>
        <trans-unit id="7b5cbb478fdd2453286ebc21496037447f26240f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt;, or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt;. Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt;. But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b14251f22912eca5254f7b79c2a9d632504f9a" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;import&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d8154ba31035b162983151d8a78e2e2dc45b35" translate="yes" xml:space="preserve">
          <source>What Compression Types do IO::Compress::Zip &amp;amp; IO::Uncompress::Unzip support?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e45028df29a344ed3d5dcfe47d49eff1e4e5b3d" translate="yes" xml:space="preserve">
          <source>What Is A Thread Anyway?</source>
          <target state="translated">Что такое нить?</target>
        </trans-unit>
        <trans-unit id="9f3aa83a51cae6aa5da8eadacc3922153fc22ffe" translate="yes" xml:space="preserve">
          <source>What Not to Export</source>
          <target state="translated">Что не экспортировать</target>
        </trans-unit>
        <trans-unit id="bcf1ef3ecb402df133384ad31b9f0ab2cd6f6d09" translate="yes" xml:space="preserve">
          <source>What Thread Am I In?</source>
          <target state="translated">В какой я нити?</target>
        </trans-unit>
        <trans-unit id="bdf11c2c3fa2430fc36aec96902da89a7d6631c6" translate="yes" xml:space="preserve">
          <source>What Threads Are Running?</source>
          <target state="translated">Какие нити бегут?</target>
        </trans-unit>
        <trans-unit id="39c91a7f2718b3f82718fcf2f41024f714a5a84f" translate="yes" xml:space="preserve">
          <source>What Unix would call a &quot;character special file&quot;, that is, a device that works on character streams such as a printer port or a console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4628ec6a65c6ef207e94ed239509a432eb2d40b1" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Что вы видите, то и получаете. Обычно используется, когда что-то, что появляется на экране, соответствует тому, как оно будет в конечном итоге выглядеть, например, объявления &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; Perl . Также используется для обозначения противоположности магии, потому что все работает именно так, как кажется, как в форме &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; с тремя аргументами .</target>
        </trans-unit>
        <trans-unit id="ed80ac1751c25893f1267129f7e46c8160dfe9c8" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;format&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fba121999cf66c38da9b22673582805a4f1ef9" translate="yes" xml:space="preserve">
          <source>What a &lt;b&gt;process&lt;/b&gt; does when it has to wait for something: &amp;ldquo;My process blocked waiting for the disk.&amp;rdquo; As an unrelated noun, it refers to a large chunk of data, of a size that the &lt;b&gt;operating system&lt;/b&gt; likes to deal with (normally a power of 2 such as 512 or 8192). Typically refers to a chunk of data that&amp;rsquo;s coming from or going to a disk file.</source>
          <target state="translated">Что делает &lt;b&gt;процесс&lt;/b&gt; , когда ему нужно чего-то ждать: &amp;laquo;Мой процесс заблокирован в ожидании диска&amp;raquo;. Как несвязанное существительное, оно относится к большому фрагменту данных, размер которого нравится &lt;b&gt;операционной системе&lt;/b&gt; (обычно степень двойки, например 512 или 8192). Обычно относится к блоку данных, который поступает из файла на диске или собирается в него.</target>
        </trans-unit>
        <trans-unit id="2467e6e88d448cacf4a87d364e42c63b7d44c7b4" translate="yes" xml:space="preserve">
          <source>What a Unicode property matches is never subject to locale rules, and if locale rules are not otherwise in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0f239768e941abba33a14d0c879853b4c42602" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt; , the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">Что насчет &lt;code&gt;pp_add&lt;/code&gt; , функции, которую мы исследовали ранее для реализации оператора &lt;code&gt;+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f1dc37cecc054d5c9ec7a5642d37fabf7ece164" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt;, the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06b49d955a9223ccdbf114f85c4f46fdc429b37" translate="yes" xml:space="preserve">
          <source>What about binary data, like images?</source>
          <target state="translated">А как насчет бинарных данных,например,изображений?</target>
        </trans-unit>
        <trans-unit id="904b144e4b71718e8b3ada176614f796ad653d66" translate="yes" xml:space="preserve">
          <source>What about read-write mode? You should probably pretend it doesn't exist, because opening text files in read-write mode is unlikely to do what you would like. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for details.</source>
          <target state="translated">А как насчет режима чтения-записи? Вероятно, вам следует сделать вид, что его не существует, потому что открытие текстовых файлов в режиме чтения-записи вряд ли приведет к тому, что вы хотели бы. Подробности смотрите в &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a98ea247bf23a0f2706e40c287b52d50377a4b2f" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</source>
          <target state="translated">А как насчет &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; прагмы байтов ?</target>
        </trans-unit>
        <trans-unit id="b08e1e06d029706420aa4cf6848aa2370810866c" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</source>
          <target state="translated">А как насчет &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; прагмы кодирования ?</target>
        </trans-unit>
        <trans-unit id="7033c56c28fec8ae85e45a62981e3d9e75105d87" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use bytes&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1190a2bf44048aa0cb955f799592720f84eed32" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use encoding&lt;/code&gt; pragma?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3887d9c889fae85aa71ceab4eb1a53b1a8af8aa5" translate="yes" xml:space="preserve">
          <source>What about the use bytes pragma?</source>
          <target state="translated">А как насчет использования байтов прагмы?</target>
        </trans-unit>
        <trans-unit id="77d5d80251afa9ef6da60c5e5fbcd215435339d8" translate="yes" xml:space="preserve">
          <source>What about the use encoding pragma?</source>
          <target state="translated">Как насчет использования кодирующей прагмы?</target>
        </trans-unit>
        <trans-unit id="9087ece8c32ed3f277ff1480139f31375b459572" translate="yes" xml:space="preserve">
          <source>What about v-strings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f362258fa45c702309bd2513e61621aa1951d0" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt; ?</source>
          <target state="translated">Что такое &lt;code&gt;decode_utf8&lt;/code&gt; и &lt;code&gt;encode_utf8&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eb35e14132d10d4b0ffea38066499e7c90c13f72" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cae90cb4f341d083e0d8337510fe30e0b15640" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Perl 6?</source>
          <target state="translated">Что такое Perl 4,Perl 5 или Perl 6?</target>
        </trans-unit>
        <trans-unit id="e6127384bd4c0a0328dc9c0ebe31629d55231702" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01965e32414f80a123a1d37d107d508fa4c75578" translate="yes" xml:space="preserve">
          <source>What are all these $@%&amp;amp;* punctuation signs, and how do I know when to use them?</source>
          <target state="translated">Что это за знаки препинания $ @% &amp;amp; * и как узнать, когда их использовать?</target>
        </trans-unit>
        <trans-unit id="11092e508878fe9b88c670c816521fca7c847f2f" translate="yes" xml:space="preserve">
          <source>What are decode_utf8 and encode_utf8?</source>
          <target state="translated">Что такое decode_utf8 и encode_utf8?</target>
        </trans-unit>
        <trans-unit id="29ffaa3b6cfc90d26e4503a77c7175830b80edb8" translate="yes" xml:space="preserve">
          <source>What are hints?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9717f99f8d2c332a1631b34f3cf973229add73" translate="yes" xml:space="preserve">
          <source>What breaks at what version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2a28ac7fb746402e9baa692599b97fb2da048e" translate="yes" xml:space="preserve">
          <source>What can you do with a reference once you have it? It's a scalar value, and we've seen that you can store it as a scalar and get it back again just like any scalar. There are just two more ways to use it:</source>
          <target state="translated">Что ты можешь сделать со справкой,как только она у тебя есть? Это скалярное значение,и мы видели,что вы можете хранить его как скаляр и получать его обратно,как и любой скаляр.Есть еще два способа использовать его:</target>
        </trans-unit>
        <trans-unit id="36be343f96dfd613d8c5cf587823d859ba4e947b" translate="yes" xml:space="preserve">
          <source>What character encodings does Perl support?</source>
          <target state="translated">Какие кодировки символов поддерживает Perl?</target>
        </trans-unit>
        <trans-unit id="b31fdc311186d7b04a093fc56872b567ad32984f" translate="yes" xml:space="preserve">
          <source>What distribution contains a particular module?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7467059fbc01c8f7e5073d6a60b1174890e226" translate="yes" xml:space="preserve">
          <source>What do you do with unsupported filetypes in an archive?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6aa1873fd68eba0f41fb53a3f8a2033690a4a51" translate="yes" xml:space="preserve">
          <source>What do you really want to know? If you merely want to know if one of your filehandles is connected to a terminal, you can try the &lt;code&gt;-t&lt;/code&gt; file test:</source>
          <target state="translated">Что ты действительно хочешь знать? Если вы просто хотите узнать, подключен ли один из ваших файловых дескрипторов к терминалу, вы можете попробовать &lt;code&gt;-t&lt;/code&gt; file test:</target>
        </trans-unit>
        <trans-unit id="1c337f8d590673be03d6eb277fa1a70849d518ac" translate="yes" xml:space="preserve">
          <source>What do you think &lt;code&gt;$x&lt;/code&gt; will be? The answer, unfortunately, is</source>
          <target state="translated">Как вы думаете, что будет &lt;code&gt;$x&lt;/code&gt; ? К сожалению, ответ</target>
        </trans-unit>
        <trans-unit id="72e224b443b5da69c66ac0a14f3f8175aa612a15" translate="yes" xml:space="preserve">
          <source>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</source>
          <target state="translated">Что означает &quot;Bareword 'DB_File' not allowed&quot;?</target>
        </trans-unit>
        <trans-unit id="d0af16451ebfa2bdedb9044267c2bc5c148972de" translate="yes" xml:space="preserve">
          <source>What does &quot;Invalid Argument&quot; mean?</source>
          <target state="translated">Что значит &quot;Недействительный Аргумент&quot;?</target>
        </trans-unit>
        <trans-unit id="f0a7abc8d37e669509493f3435ed1f9575fda404" translate="yes" xml:space="preserve">
          <source>What does &quot;bad interpreter&quot; mean?</source>
          <target state="translated">Что значит &quot;плохой переводчик&quot;?</target>
        </trans-unit>
        <trans-unit id="128188e5871787fd7e8d0d232b299acadbde54ca" translate="yes" xml:space="preserve">
          <source>What does &quot;wide character in subroutine entry&quot; mean?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e47776a0ddea1129634daa43d411c09b05f88dc" translate="yes" xml:space="preserve">
          <source>What does it mean that regexes are greedy? How can I get around it?</source>
          <target state="translated">Что значит,что регексы жадные? Как я могу обойти это?</target>
        </trans-unit>
        <trans-unit id="fad85491a61b1ab9b17396e45b64b419ab4c8e77" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; are represented using the &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; notation, because \x hex (without curly braces) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</source>
          <target state="translated">Что это означает для регулярных выражений? Ну, пользователям регулярного выражения не нужно много знать о внутреннем представлении строк в Perl. Но им нужно знать, 1) как представлять символы Юникода в регулярном выражении и 2) что операция сопоставления будет обрабатывать строку, подлежащую поиску, как последовательность символов, а не байтов. Ответ на 1) заключается в том, что символы Юникода больше, чем &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; представлены с использованием записи &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; , потому что \ x hex (без фигурных скобок) не идет дальше 255. (Начиная с Perl 5.14, если вы поклонник восьмеричного числа, вы также можете использовать &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="975aae02ca21ed8ec96fd5f4735831339586ec7e" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;chr(255)&lt;/code&gt; are represented using the &lt;code&gt;\x{hex}&lt;/code&gt; notation, because &lt;code&gt;\x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fa5db720a03edc1fcba3370635f4d2d4adabe0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;&quot;PERLIO&quot; in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d60263af797b45d08166a1e2276365e53b9c7d0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">Какие именно слои находятся в этом стеке по умолчанию, зависит от многих вещей: вашей операционной системы, версии Perl, конфигурации времени компиляции Perl и конфигурации среды выполнения Perl. См. &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; , &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO в perlrun&lt;/a&gt; и &lt;a href=&quot;open&quot;&gt;откройте&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="07854a74e069ff620decff4308e92c81d6bd8098" translate="yes" xml:space="preserve">
          <source>What follows are the more advanced, less used, or sometimes esoteric capabilities of Perl regexps. In Part 2, we will assume you are comfortable with the basics and concentrate on the advanced features.</source>
          <target state="translated">Ниже перечислены более продвинутые,менее используемые,а иногда и эзотерические возможности Perl регеxps.Во второй части мы предположим,что вы хорошо разбираетесь в основах и сконцентрируетесь на продвинутых возможностях.</target>
        </trans-unit>
        <trans-unit id="565ee5d3831c954154cf4129999eb2ce193f0752" translate="yes" xml:space="preserve">
          <source>What follows is a detailed guide through these steps.</source>
          <target state="translated">Далее следует подробное руководство по этим этапам.</target>
        </trans-unit>
        <trans-unit id="75d7e12868bcb8f2565578748be73375fac12333" translate="yes" xml:space="preserve">
          <source>What follows is a statement about artistic control, defined as the ability of authors of packages to guide the future of their code and maintain control over their work. It is a recognition that authors should have control over their work, and that it is a responsibility of the rest of the Perl community to ensure that they retain this control. It is an attempt to document the standards to which we, as Perl developers, intend to hold ourselves. It is an attempt to write down rough guidelines about the respect we owe each other as Perl developers.</source>
          <target state="translated">Далее следует утверждение о художественном контроле,определяемом как способность авторов пакетов направлять будущее своего кода и сохранять контроль над своей работой.Это признание того,что авторы должны иметь контроль над своей работой,и что ответственность за сохранение этого контроля лежит на остальных членах сообщества Perl.Это попытка задокументировать стандарты,которые мы,как разработчики Perl,намереваемся удержать.Это попытка записать грубое руководство о том,каким уважением мы обязаны друг другу,как разработчики Perl.</target>
        </trans-unit>
        <trans-unit id="374a8e110bb4c1d9c752734c71a27f6e3e497ea6" translate="yes" xml:space="preserve">
          <source>What follows is subject to change RSN.</source>
          <target state="translated">Следующее может быть изменено в RSN.</target>
        </trans-unit>
        <trans-unit id="24917de591e0d7708ee26a13cd3362afc4f6c7c4" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt; .</source>
          <target state="translated">Какие форматы выводятся как подача формы. По умолчанию &lt;code&gt;\f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f6f4d84ea57e45f2ca17815f8c029206bd9132" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d479059298a571f524af929b6aea396ec65a05e6" translate="yes" xml:space="preserve">
          <source>What gets returned depends on several factors:</source>
          <target state="translated">То,что возвращается,зависит от нескольких факторов:</target>
        </trans-unit>
        <trans-unit id="8722b12ceccd8e92d99a716a04b297746411e5f8" translate="yes" xml:space="preserve">
          <source>What good is &lt;code&gt;\G&lt;/code&gt; in a regular expression?</source>
          <target state="translated">Что хорошего в &lt;code&gt;\G&lt;/code&gt; в регулярном выражении?</target>
        </trans-unit>
        <trans-unit id="2f0a90d9f77866c3233e1aef1cc7a9560c6ec0c3" translate="yes" xml:space="preserve">
          <source>What good is \G in a regular expression?</source>
          <target state="translated">Что хорошего в регулярном выражении \G?</target>
        </trans-unit>
        <trans-unit id="ebf8dc71994cee4560964d904824ac92b27fed19" translate="yes" xml:space="preserve">
          <source>What happens if I add or remove keys from a hash while iterating over it?</source>
          <target state="translated">Что произойдет,если я добавлю или удалю ключи из хэша во время итерации по нему?</target>
        </trans-unit>
        <trans-unit id="ff08f48f056287d25a3dc5672938a653f78c0ce3" translate="yes" xml:space="preserve">
          <source>What happens is that after</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630083c407aaeb1fdb11b2f5b1e425a9f1a5879d" translate="yes" xml:space="preserve">
          <source>What happens when &lt;code&gt;JSON::PP&lt;/code&gt; encounters a Perl object depends on the &lt;code&gt;allow_blessed&lt;/code&gt;, &lt;code&gt;convert_blessed&lt;/code&gt;, &lt;code&gt;allow_tags&lt;/code&gt; and &lt;code&gt;allow_bignum&lt;/code&gt; settings, which are used in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6c83c5563cf3fe722575d6dd30278f0a9d68bc" translate="yes" xml:space="preserve">
          <source>What has gone on?</source>
          <target state="translated">Что случилось?</target>
        </trans-unit>
        <trans-unit id="148ce7ffb164566545434b0feef660c7bee4a489" translate="yes" xml:space="preserve">
          <source>What has happened here?</source>
          <target state="translated">Что здесь произошло?</target>
        </trans-unit>
        <trans-unit id="21eec199e3d296f021d3cdb05af5afb550abb23b" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt; .</source>
          <target state="translated">Что случилось, что &lt;code&gt;fred&lt;/code&gt; обращается к &lt;code&gt;@_&lt;/code&gt; массива , который принадлежит к &lt;code&gt;joe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4495f64a5a5a99cc3a0b71199a99723a37e9ed87" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061def72c9d3f6d8d9699c831f84918bba3a0be" translate="yes" xml:space="preserve">
          <source>What if I don't decode?</source>
          <target state="translated">Что,если я не расшифрую?</target>
        </trans-unit>
        <trans-unit id="edc0c9ac4aa8c7b7a3fb61b68506b87d3c69f4bc" translate="yes" xml:space="preserve">
          <source>What if I don't encode?</source>
          <target state="translated">А если я не кодирую?</target>
        </trans-unit>
        <trans-unit id="0ddebc8779b4a58623bcc03eec19b9fd5bdcc57a" translate="yes" xml:space="preserve">
          <source>What if I don't know which encoding was used?</source>
          <target state="translated">Что,если я не знаю,какая кодировка была использована?</target>
        </trans-unit>
        <trans-unit id="b012d213b447ce5a8b3e4b308232eb1a6c342960" translate="yes" xml:space="preserve">
          <source>What if my question isn't answered in the FAQ?</source>
          <target state="translated">Что если на мой вопрос не ответят в FAQ?</target>
        </trans-unit>
        <trans-unit id="30310a64f6e6f73114ef8ff5955e14d7deb5a4c5" translate="yes" xml:space="preserve">
          <source>What if the interface provided by the C callback doesn't contain a parameter which allows the file handle to Perl subroutine mapping? Say in the asynchronous i/o package, the callback function gets passed only the &lt;code&gt;buffer&lt;/code&gt; parameter like this</source>
          <target state="translated">Что, если интерфейс, предоставляемый обратным вызовом C, не содержит параметра, который позволяет дескриптору файла отображать подпрограмму Perl? Скажем, в пакете асинхронного ввода-вывода функция обратного вызова получает только такой параметр &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9002d28fd7ee52f5e73c33c74a403efd3585ddf" translate="yes" xml:space="preserve">
          <source>What import does</source>
          <target state="translated">Что делает импорт</target>
        </trans-unit>
        <trans-unit id="9281510e66c9b036bf0f2b1f98689d5dbd410309" translate="yes" xml:space="preserve">
          <source>What is &quot;the UTF8 flag&quot;?</source>
          <target state="translated">Что такое &quot;флаг UTF8&quot;?</target>
        </trans-unit>
        <trans-unit id="48776d293c1cf7b50ee10897815e6e1c09782388" translate="yes" xml:space="preserve">
          <source>What is /o really for?</source>
          <target state="translated">Для чего на самом деле?</target>
        </trans-unit>
        <trans-unit id="f799c97279ef39d3426ad309ad7dfc5a7d36fff1" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;/o&lt;/code&gt; really for?</source>
          <target state="translated">Для чего на самом деле &lt;code&gt;/o&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="4da6343eb07811de611e2143a23a9e42def6f17c" translate="yes" xml:space="preserve">
          <source>What is C3?</source>
          <target state="translated">Что такое С3?</target>
        </trans-unit>
        <trans-unit id="3f1ecd4984feb033599a0b8b92a1a9741f5b5e8e" translate="yes" xml:space="preserve">
          <source>What is Module::Build and how does it relate to MakeMaker?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda040c2e08659bcff6001c6dcad6149b2b71af9" translate="yes" xml:space="preserve">
          <source>What is Perl 6?</source>
          <target state="translated">Что такое Perl 6?</target>
        </trans-unit>
        <trans-unit id="90e6903f9207d6b5637de9d9ec259575b1877362" translate="yes" xml:space="preserve">
          <source>What is Perl?</source>
          <target state="translated">Что такое Перл?</target>
        </trans-unit>
        <trans-unit id="79dc15d896921a5be3532940c7478220c26d76f5" translate="yes" xml:space="preserve">
          <source>What is Plack and PSGI?</source>
          <target state="translated">Что такое Plack и PSGI?</target>
        </trans-unit>
        <trans-unit id="234e64d864b7e4e19b7d995b815d4db958366917" translate="yes" xml:space="preserve">
          <source>What is Raku (Perl 6)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c878af8c7031f81a5ddca206fc60a5a12f9ad1d" translate="yes" xml:space="preserve">
          <source>What is Unicode, anyway?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387b2d5d4628ca2a97a160cf17017d26f2363e65" translate="yes" xml:space="preserve">
          <source>What is a &quot;wide character&quot;?</source>
          <target state="translated">Что такое &quot;широкий характер&quot;?</target>
        </trans-unit>
        <trans-unit id="6c07c0817bd40c0602c40f4eb163a577c33eb9e2" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt; , which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">Что такое &amp;laquo;рекорд&amp;raquo;? По умолчанию значение такое же, как для оператора &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; : это строка, оканчивающаяся символом &lt;code&gt;$/&lt;/code&gt; , что, вероятно, является &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Незначительное исключение: в системах DOS и Win32 &amp;laquo;запись&amp;raquo; - это строка, оканчивающаяся &lt;code&gt;recsep&lt;/code&gt; &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) Вы можете изменить определение &amp;laquo;записи&amp;raquo;, указав опцию recsep в вызове &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="046dcad9c1b5d6658ae493e5f69f47ba914f7843" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt;, which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt;. (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;.) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;tie&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a841a9e9e59dbc901dca478a52731689558d70" translate="yes" xml:space="preserve">
          <source>What is a DBM Filter?</source>
          <target state="translated">Что такое DBM-фильтр?</target>
        </trans-unit>
        <trans-unit id="75ea94c254fb7320b80e8d79c658d169412a3588" translate="yes" xml:space="preserve">
          <source>What is a JAPH?</source>
          <target state="translated">Что такое JAPH?</target>
        </trans-unit>
        <trans-unit id="8e7e75800308f6339899e8db69308ae93f0337df" translate="yes" xml:space="preserve">
          <source>What is a regular expression engine?</source>
          <target state="translated">Что такое двигатель регулярного выражения?</target>
        </trans-unit>
        <trans-unit id="e7e08c44504e895661b69ab0d094008da5741e55" translate="yes" xml:space="preserve">
          <source>What is a regular expression? A regular expression is simply a string that describes a pattern. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory, e.g., &lt;code&gt;ls *.txt&lt;/code&gt; or &lt;code&gt;dir *.*&lt;/code&gt;. In Perl, the patterns described by regular expressions are used to search strings, extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">Что такое регулярное выражение? Регулярное выражение - это просто строка, описывающая шаблон. В наши дни паттерны широко используются; примерами являются шаблоны, вводимые поисковой системой для поиска веб-страниц, и шаблоны, используемые для перечисления файлов в каталоге, например, &lt;code&gt;ls *.txt&lt;/code&gt; или &lt;code&gt;dir *.*&lt;/code&gt; . В Perl шаблоны, описываемые регулярными выражениями, используются для поиска строк, извлечения нужных частей строк и выполнения операций поиска и замены.</target>
        </trans-unit>
        <trans-unit id="ad1619062d7422922f56678f7cf58c8d2f19d36b" translate="yes" xml:space="preserve">
          <source>What is a regular expression? At its most basic, a regular expression is a template that is used to determine if a string has certain characteristics. The string is most often some text, such as a line, sentence, web page, or even a whole book, but less commonly it could be some binary data as well. Suppose we want to determine if the text in variable, &lt;code&gt;$var&lt;/code&gt; contains the sequence of characters &lt;code&gt;m u s h r o o m&lt;/code&gt; (blanks added for legibility). We can write in Perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1f1924f0cab71521b063802ea721cd9de2bf43" translate="yes" xml:space="preserve">
          <source>What is an &quot;IV&quot;?</source>
          <target state="translated">Что такое &quot;капельница&quot;?</target>
        </trans-unit>
        <trans-unit id="778b266015494167ffcfb5699798ca074f01e4ed" translate="yes" xml:space="preserve">
          <source>What is libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de138e681884a542d6a632e3d45af8060ecf685" translate="yes" xml:space="preserve">
          <source>What is meant here is unclear, as the &lt;code&gt;\N{...}&lt;/code&gt; escape is a sequence of code points, so this is made an error.</source>
          <target state="translated">Что здесь имеется в виду, неясно, поскольку escape-последовательность &lt;code&gt;\N{...}&lt;/code&gt; представляет собой последовательность кодовых точек, поэтому это является ошибкой.</target>
        </trans-unit>
        <trans-unit id="7e4d744a0a34b3ed6f2bacfcf8917df2728b341f" translate="yes" xml:space="preserve">
          <source>What is much worse, some DLLs change the floating point flags when in _DLLInitTerm() (e.g.,</source>
          <target state="translated">Что гораздо хуже,некоторые DLL изменяют флаги с плавающей точкой,когда в _DLLInitTerm()(например,в _DLLInitTerm()),</target>
        </trans-unit>
        <trans-unit id="b80f71784676643cac72b04d16a86ddd2aad93c3" translate="yes" xml:space="preserve">
          <source>What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</source>
          <target state="translated">Что такое perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</target>
        </trans-unit>
        <trans-unit id="b4511cf9900e620f3e5c53ed90d05dd1b6347288" translate="yes" xml:space="preserve">
          <source>What is socket.ph and where do I get it?</source>
          <target state="translated">Что такое розетка и откуда она у меня?</target>
        </trans-unit>
        <trans-unit id="466ca1293cf697f510f855a869e855e56cd9f9c1" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;state&quot; subs and &quot;my&quot; subs? Each time that execution enters a block when &quot;my&quot; subs are declared, a new copy of each sub is created. &quot;State&quot; subroutines persist from one execution of the containing block to the next.</source>
          <target state="translated">В чем разница между &quot;государственными&quot; и &quot;моими&quot; подлодками? Каждый раз,когда исполнение входит в блок,когда объявляются &quot;мои&quot; подмножества,создается новая копия каждого подмножества.Подпрограммы &quot;Состояние&quot; сохраняются от одного выполнения содержащего блока к следующему.</target>
        </trans-unit>
        <trans-unit id="fc949184376f42b77d53568413143ee5107891ea" translate="yes" xml:space="preserve">
          <source>What is the difference between $array[1] and @array[1]?</source>
          <target state="translated">Какая разница между $array[1]и @array[1]?</target>
        </trans-unit>
        <trans-unit id="e5e94a34863c5b06b0902ba29af6bbdd60a89b26" translate="yes" xml:space="preserve">
          <source>What is the difference between :encoding and :utf8?</source>
          <target state="translated">В чем разница между :кодировкой и :utf8?</target>
        </trans-unit>
        <trans-unit id="87b2e888c908f6842e557ad8d646535f8dd07500" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt; ?</source>
          <target state="translated">В чем разница между &lt;code&gt;:encoding&lt;/code&gt; и &lt;code&gt;:utf8&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="aa686143aeb2276da66fe372809de6163adbd5d8" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd9348a87a0e037c9116062611c030ca4d85da9" translate="yes" xml:space="preserve">
          <source>What is the difference between a list and an array?</source>
          <target state="translated">В чем разница между списком и массивом?</target>
        </trans-unit>
        <trans-unit id="aa2dc660c0cced5d46caea2cf443fe5e368244c8" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">Что это за утверждение Perl? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; - это простая строка в двойных кавычках. &lt;code&gt;World&lt;/code&gt; - это регулярное выражение, и &lt;code&gt;//&lt;/code&gt; включающий &lt;code&gt;/World/&lt;/code&gt; указывает Perl искать совпадение в строке. Оператор &lt;code&gt;=~&lt;/code&gt; связывает строку с совпадением регулярного выражения и выдает истинное значение, если регулярное выражение совпало, или ложь, если регулярное выражение не совпадает. В нашем случае &lt;code&gt;World&lt;/code&gt; соответствует второму слову в &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , поэтому выражение истинно. Подобные выражения полезны в условных выражениях:</target>
        </trans-unit>
        <trans-unit id="8288a589c4caf7bd2276d185a7bd5fbf595dc73f" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;, so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fb4cb8e09b50cfb90602035114712466d59042" translate="yes" xml:space="preserve">
          <source>What is variable suicide and how can I prevent it?</source>
          <target state="translated">Что такое переменное самоубийство и как его предотвратить?</target>
        </trans-unit>
        <trans-unit id="49ac75fc20864efd20e6c484dddbafd73db6a2e3" translate="yes" xml:space="preserve">
          <source>What is your favorite pager program?</source>
          <target state="translated">Какая ваша любимая пейджерная программа?</target>
        </trans-unit>
        <trans-unit id="fd63f60b8b6a48f0264ba03539d262e0388b66e2" translate="yes" xml:space="preserve">
          <source>What is your favorite shell?</source>
          <target state="translated">Какая твоя любимая оболочка?</target>
        </trans-unit>
        <trans-unit id="7a785a8e58c6a9e20c1539582a1a9c97e125374e" translate="yes" xml:space="preserve">
          <source>What kind of stuff is contained in this distribution. Most things on CPAN are &lt;code&gt;module&lt;/code&gt;s (which can also mean a collection of modules), but some things are &lt;code&gt;script&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdeb97ea551b504f3da8bf43202e9fd344363cd" translate="yes" xml:space="preserve">
          <source>What kind of test? Possibilities include, skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41b525bca416a73d68432b879e12cd6ce5cae2d" translate="yes" xml:space="preserve">
          <source>What kind of threads are Perl threads?</source>
          <target state="translated">Что это за нити Perl?</target>
        </trans-unit>
        <trans-unit id="523c42f572591f0bfb9eb624031ecf0ded9f0a2a" translate="yes" xml:space="preserve">
          <source>What library to use?</source>
          <target state="translated">Какой библиотекой пользоваться?</target>
        </trans-unit>
        <trans-unit id="c9dcfd1a76d749e07495e332956ce4a77d52e8a9" translate="yes" xml:space="preserve">
          <source>What machines support Perl? Where do I get it?</source>
          <target state="translated">Какие машины поддерживают Perl? Где мне его взять?</target>
        </trans-unit>
        <trans-unit id="f891fe8a2be3f1ffe86b5a80057ef4ca6da1223d" translate="yes" xml:space="preserve">
          <source>What machines support libnet ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602afa592af7887a3bffb104fc775a95a31125b0" translate="yes" xml:space="preserve">
          <source>What mailing lists are there for Perl?</source>
          <target state="translated">Какие списки рассылки есть для Perl?</target>
        </trans-unit>
        <trans-unit id="4862bb3e93457f890d9e122c5362daa5b89c1284" translate="yes" xml:space="preserve">
          <source>What makes a method special is</source>
          <target state="translated">Особенность метода в том,что</target>
        </trans-unit>
        <trans-unit id="c65301b41224a5b616b4c8a04b46b840cdda0ef5" translate="yes" xml:space="preserve">
          <source>What makes all of this important is that the Exporter module uses glob aliasing as the import/export mechanism. Whether or not you can properly localize a variable that has been exported from a module depends on how it was exported:</source>
          <target state="translated">Все это делает важным то,что в качестве механизма импорта/экспорта в модуле Exporter используется глобусное алиазирование.Можно ли правильно локализовать переменную,которая была экспортирована из модуля,зависит от того,как она была экспортирована:</target>
        </trans-unit>
        <trans-unit id="8fb5a283f17d0d098d1490569f3aaeb90f52254c" translate="yes" xml:space="preserve">
          <source>What makes for a good patch?</source>
          <target state="translated">Что делает хорошую заплатку?</target>
        </trans-unit>
        <trans-unit id="486e1e8fa6072821d31ad344e76845b470464a6d" translate="yes" xml:space="preserve">
          <source>What makes this pass interesting for perl developers is that some optimization may be performed on this pass. This is optimization by so-called &quot;check routines&quot;. The correspondence between node names and corresponding check routines is described in</source>
          <target state="translated">Что делает этот проход интересным для разработчиков perl,так это то,что на этом проходе может быть выполнена некоторая оптимизация.Это оптимизация с помощью так называемых &quot;процедур проверки&quot;.Соответствие между именами узлов и соответствующими контрольными процедурами описано в разделе</target>
        </trans-unit>
        <trans-unit id="7c3d71cb8c06e618edc314c89194f61b595a4c29" translate="yes" xml:space="preserve">
          <source>What modules and extensions are available for Perl? What is CPAN?</source>
          <target state="translated">Какие модули и расширения доступны для Perl? Что такое CPAN?</target>
        </trans-unit>
        <trans-unit id="5eca61ede7bdc9f4a1c178015ba2713ba5ace84a" translate="yes" xml:space="preserve">
          <source>What modules does a particular distribution contain?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709f8e1c07fc1fe28e0f229bb8ce88d468c08c8e" translate="yes" xml:space="preserve">
          <source>What modules shipped with versions of perl</source>
          <target state="translated">Какие модули поставляются с версиями perl</target>
        </trans-unit>
        <trans-unit id="bbb49ac4107bc251bf787f21f8a88fe7e30321ce" translate="yes" xml:space="preserve">
          <source>What most people need to know (superclasses on top.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b01351f5f724ad044096c916ace26f9169184a3" translate="yes" xml:space="preserve">
          <source>What other modules do I need ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f3978619a4438d900606a19c92b7d1f8afc742" translate="yes" xml:space="preserve">
          <source>What regop is next?</source>
          <target state="translated">Какой регоп следующий?</target>
        </trans-unit>
        <trans-unit id="88176d2562c5c584253c31b2148c8703789870d4" translate="yes" xml:space="preserve">
          <source>What seems a successful strategy is the combination of &lt;code&gt;reload
cpan&lt;/code&gt; and the debugging switches. Add a new debug statement while running in the shell and then issue a &lt;code&gt;reload cpan&lt;/code&gt; and see the new debugging messages immediately without losing the current context.</source>
          <target state="translated">Что кажется успешной стратегией, так это комбинация &lt;code&gt;reload cpan&lt;/code&gt; и переключателей отладки. Добавьте новый оператор отладки во время работы в оболочке, а затем выполните &lt;code&gt;reload cpan&lt;/code&gt; и сразу же посмотрите новые сообщения отладки, не теряя текущего контекста.</target>
        </trans-unit>
        <trans-unit id="494e70de221fde56713efc23ab1ca24064c718dc" translate="yes" xml:space="preserve">
          <source>What should I make into a module?</source>
          <target state="translated">Что я должен сделать в модуле?</target>
        </trans-unit>
        <trans-unit id="0e5fb1910c7b0867ac71d8402069e7fbfc90bc05" translate="yes" xml:space="preserve">
          <source>What some helper &lt;b&gt;process&lt;/b&gt; did to transform the incoming data into a form more suitable for the current process. Often done with an incoming &lt;b&gt;pipe&lt;/b&gt;. See also &lt;b&gt;C preprocessor&lt;/b&gt;.</source>
          <target state="translated">Что сделал какой-то вспомогательный &lt;b&gt;процесс&lt;/b&gt; для преобразования входящих данных в форму, более подходящую для текущего процесса. Часто делается с входящей &lt;b&gt;трубой&lt;/b&gt; . Смотрите также &lt;b&gt;C препроцессор&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="05edee69ab0b091485f39a349759f585c24e0340" translate="yes" xml:space="preserve">
          <source>What the program or function returns, if successful. This section can be omitted for programs whose precise exit codes aren't important, provided they return 0 on success and non-zero on failure as is standard. It should always be present for functions. For modules, it may be useful to summarize return values from the module interface here, or it may be more useful to discuss return values separately in the documentation of each function or method the module provides.</source>
          <target state="translated">Что возвращает программа или функция в случае успеха.Этот раздел можно опустить для программ,точные коды выхода которых не важны,при условии,что они возвращают 0 в случае успеха и ненулевой в случае неудачи,как это обычно бывает.Он всегда должен присутствовать для функций.Для модулей здесь может быть полезно суммировать возвращаемые значения из интерфейса модуля,или может быть более полезным обсуждать возвращаемые значения отдельно в документации каждой функции или метода,предоставляемого модулем.</target>
        </trans-unit>
        <trans-unit id="b11685dda194db5e13d9f10a2284151cb724112f" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt; , a function in</source>
          <target state="translated">Это создает новую двоичную операцию и передает ей ряд переменных. Переменные относятся к токенам: &lt;code&gt;$1&lt;/code&gt; - это первый токен во входных данных, &lt;code&gt;$2&lt;/code&gt; - второй и так далее - подумайте об обратных ссылках на регулярные выражения. &lt;code&gt;$$&lt;/code&gt; - это операция, возвращаемая из этого сокращения. Итак, мы вызываем &lt;code&gt;newBINOP&lt;/code&gt; , чтобы создать новый бинарный оператор. Первый параметр &lt;code&gt;newBINOP&lt;/code&gt; , функция в</target>
        </trans-unit>
        <trans-unit id="b67434e808539a7f62532e0f74741a29eeb423fa" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt;, a function in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc8ecd0e95182504b6e5e23619c1654db502160" translate="yes" xml:space="preserve">
          <source>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error</source>
          <target state="translated">Это означает,что если у вас есть данные,записанные в Storable 1.x на perl 5.6.0 или 5.6.1,сконфигурированные с 64-битными целыми числами в Unix или Linux,то по умолчанию этот Storable откажется их читать,выдавая ошибку</target>
        </trans-unit>
        <trans-unit id="c1074e9471d381d1e3fa377b4baeab5a37484773" translate="yes" xml:space="preserve">
          <source>What this means is that unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect &lt;code&gt;\d&lt;/code&gt; not only matches the digits '0' - '9', but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</source>
          <target state="translated">Это означает, что если не &lt;code&gt;/a&lt;/code&gt; модификатор / a , &lt;code&gt;\d&lt;/code&gt; не только соответствует цифрам &amp;laquo;0&amp;raquo; - &amp;laquo;9&amp;raquo;, но также арабским, деванагари и цифрам из других языков. Это может вызвать некоторую путаницу и некоторые проблемы с безопасностью.</target>
        </trans-unit>
        <trans-unit id="024bfa55bc6c90f99bae14081b1ca78d49501b2e" translate="yes" xml:space="preserve">
          <source>What this says is: &lt;code&gt;1..1&lt;/code&gt; &quot;I'm going to run one test.&quot; [1] &lt;code&gt;ok 1&lt;/code&gt; &quot;The first test passed&quot;. And that's about all magic there is to testing. Your basic unit of testing is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90ef1b55a5f8c0ad6415f98413e6a092c07a530" translate="yes" xml:space="preserve">
          <source>What to put after &quot;1/crontab&quot; in the URL. This option is not set by default.</source>
          <target state="translated">Что ставить после &quot;1/crontab&quot; в URL.Эта опция не установлена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="616a4166af25f3f615ff259d316398355eca1fd7" translate="yes" xml:space="preserve">
          <source>What to put after &quot;Foo%3a%3aBar&quot; in the URL. This option is not set by default.</source>
          <target state="translated">Что ставить после &quot;Foo%3a%3aBar&quot; в URL.Эта опция не установлена по умолчанию.</target>
        </trans-unit>
        <trans-unit id="774021bac19bdf5e083a7ddf41b218a869e89eea" translate="yes" xml:space="preserve">
          <source>What to put before and after the title in the head. The values should already be &amp;amp;-escaped.</source>
          <target state="translated">Что ставить до и после заголовка в голове. Значения уже должны быть &amp;amp; -экранированы.</target>
        </trans-unit>
        <trans-unit id="46d727439e117340febafb43135cffaac5ab87fa" translate="yes" xml:space="preserve">
          <source>What utilities shipped with versions of perl</source>
          <target state="translated">Какие утилиты поставляются с версиями perl</target>
        </trans-unit>
        <trans-unit id="41d1f562b44341deaff0802951db706e407b9e33" translate="yes" xml:space="preserve">
          <source>What version of Perl you are running?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f6137e22ba58dcead1d29483955dc880eaf485" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">Что было в этом куске памяти? Цифры, символы или их сочетание? Предположим, что мы находимся на компьютере, где используется кодировка ASCII (или аналогичная): шестнадцатеричные значения в диапазоне &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; указывают на заглавную букву, а &lt;code&gt;0x20&lt;/code&gt; кодирует пробел. Таким образом, мы можем предположить, что это отрывок текста, который некоторые могут читать, как таблоид; но другим придется разжиться таблицей ASCII и пережить это чувство первоклассника. Не слишком заботясь о том, как это читать, отметим, что &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; с кодом шаблона &lt;code&gt;H&lt;/code&gt; преобразует содержимое последовательности байтов в обычную шестнадцатеричную нотацию. Поскольку &amp;laquo;последовательность из&amp;raquo; - довольно расплывчатое указание количества, &lt;code&gt;H&lt;/code&gt; был определен для преобразования только одной шестнадцатеричной цифры, если за ней не следует счетчик повторов. Звездочка для счетчика повторов означает использование того, что осталось.</target>
        </trans-unit>
        <trans-unit id="0db88274915aa193b8762de0b1150e4497a2898f" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;unpack&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a26aa5328e43e90f045fe86149fb674a158916" translate="yes" xml:space="preserve">
          <source>What we actually need to do is expand the width of the fields. The &lt;code&gt;A&lt;/code&gt; format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</source>
          <target state="translated">На самом деле нам нужно увеличить ширину полей. Формат &lt;code&gt;A&lt;/code&gt; дополняет любые несуществующие символы пробелами, поэтому мы можем использовать дополнительные пробелы для выравнивания наших полей, например:</target>
        </trans-unit>
        <trans-unit id="b18ad647190599dbc6f89a0be950252c58677d5e" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script_Extensions=Latin}&lt;/code&gt;, &lt;code&gt;\p{Script_Extensions:Greek}&lt;/code&gt;, &lt;code&gt;\p{script_extensions=katakana}&lt;/code&gt;, and &lt;code&gt;\P{script_extensions=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c37b176ea3009646e0be80ec6a53f25b8ff9dcd" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; , and &lt;code&gt;\P{script=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">То, что мы описали до сих пор, является единственной формой классов символов &lt;code&gt;\p{...}&lt;/code&gt; . Существует также составная форма, с которой вы можете столкнуться. Они выглядят как &lt;code&gt;\p{name=value}&lt;/code&gt; или &lt;code&gt;\p{name:value}&lt;/code&gt; (знак равенства и двоеточие могут использоваться как синонимы). Они более общие, чем одиночная форма, и на самом деле большинство одиночных форм - это просто определенные Perl ярлыки для общих составных форм. Например, примеры сценариев в предыдущем абзаце могут быть записаны эквивалентно как &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; и &lt;code&gt;\P{script=balinese}&lt;/code&gt; (регистр не имеет отношения к &lt;code&gt;{}&lt;/code&gt; подтяжки). Возможно, вам никогда не придется использовать составные формы, но иногда это необходимо, и их использование может облегчить понимание вашего кода.</target>
        </trans-unit>
        <trans-unit id="3384939add5296135f386c16a3d5a3c4d7477676" translate="yes" xml:space="preserve">
          <source>What you are told when someone thinks you should Read The Fine Manual.</source>
          <target state="translated">То,что вам говорят,когда кто-то думает,что вы должны прочитать &quot;Прекрасное руководство&quot;.</target>
        </trans-unit>
        <trans-unit id="5da1aaeac7913632bcb1c91e0e40a9b8f5b306d1" translate="yes" xml:space="preserve">
          <source>What you can do is calculate the MD5 checksum of the UTF-8 representation of such strings. This is achieved by filtering the string through encode_utf8() function:</source>
          <target state="translated">Все,что вы можете сделать,это вычислить MD5 контрольную сумму UTF-8 представления таких строк.Это достигается путем фильтрации строки с помощью функции encode_utf8():</target>
        </trans-unit>
        <trans-unit id="bdac7845b72b0a0aaba866c488e59de83492ce2f" translate="yes" xml:space="preserve">
          <source>What you get from your ancestors, genetically or otherwise. If you happen to be a &lt;b&gt;class&lt;/b&gt;, your ancestors are called &lt;b&gt;base classes&lt;/b&gt; and your descendants are called &lt;b&gt;derived classes&lt;/b&gt;. See &lt;b&gt;single inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.</source>
          <target state="translated">То, что вы получаете от своих предков генетически или иначе. Если вы являетесь &lt;b&gt;классом&lt;/b&gt; , ваши предки называются &lt;b&gt;базовыми классами,&lt;/b&gt; а ваши потомки - &lt;b&gt;производными классами&lt;/b&gt; . См. &lt;b&gt;Отдельное наследование&lt;/b&gt; и &lt;b&gt;множественное наследование&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2c06f68d01c975c0659982cd1d1ea555fe3696b9" translate="yes" xml:space="preserve">
          <source>What you get when you do &lt;code&gt;Perl++&lt;/code&gt; twice. Doing it only once will curl your hair. You have to increment it eight times to shampoo your hair. Lather, rinse, iterate.</source>
          <target state="translated">Что вы получите, если дважды выполните &lt;code&gt;Perl++&lt;/code&gt; . Если вы сделаете это один раз, ваши волосы будут завивать. Чтобы вымыть волосы шампунем, необходимо увеличить его восемь раз. Вспенить, промыть, повторить.</target>
        </trans-unit>
        <trans-unit id="d8dd19339629eae0964d65277b9af39d2d940ac8" translate="yes" xml:space="preserve">
          <source>What you probably want instead is this:</source>
          <target state="translated">Вместо этого ты,наверное,хочешь вот этого:</target>
        </trans-unit>
        <trans-unit id="b04bf6a0eeeb74b4ebb74c0ffdfd7f57764ab34f" translate="yes" xml:space="preserve">
          <source>What you want to use instead is:</source>
          <target state="translated">То,что ты хочешь использовать вместо этого:</target>
        </trans-unit>
        <trans-unit id="f3ca9a26fe44a59f17183be2ef23ecb124cf272f" translate="yes" xml:space="preserve">
          <source>What's MakeMaker?</source>
          <target state="translated">Что такое МакМейкер?</target>
        </trans-unit>
        <trans-unit id="42464d9de4a99557d583081f2fb3c257e19a8cfc" translate="yes" xml:space="preserve">
          <source>What's Really Stored in an SV?</source>
          <target state="translated">Что на самом деле хранится в спецавтомобиле?</target>
        </trans-unit>
        <trans-unit id="8f84a94f1018dae65b2467147ba94f01d14ea50b" translate="yes" xml:space="preserve">
          <source>What's a closure?</source>
          <target state="translated">Что за закрытие?</target>
        </trans-unit>
        <trans-unit id="a80aec1f19639cbbb28c71d9ddfac9f28b371cff" translate="yes" xml:space="preserve">
          <source>What's an extension?</source>
          <target state="translated">Что такое пристройка?</target>
        </trans-unit>
        <trans-unit id="96c69ba1e09918b49d4e34120c9bbb2d0968449e" translate="yes" xml:space="preserve">
          <source>What's in Plan 9 Perl</source>
          <target state="translated">Что в плане 9 Перл</target>
        </trans-unit>
        <trans-unit id="e9c4131b2629bb86dafeed8bcd2c9f6a25583f3a" translate="yes" xml:space="preserve">
          <source>What's in a name?</source>
          <target state="translated">Что в имени?</target>
        </trans-unit>
        <trans-unit id="5131dc0eec6cff59e581098235ddc4625176b69a" translate="yes" xml:space="preserve">
          <source>What's new here?</source>
          <target state="translated">Что тут нового?</target>
        </trans-unit>
        <trans-unit id="22ab29c1c9e23b6be4d152ca0fbe8d1fd5003e73" translate="yes" xml:space="preserve">
          <source>What's not in Plan 9 Perl</source>
          <target state="translated">Чего нет в плане 9 Перл</target>
        </trans-unit>
        <trans-unit id="5d2b08ade1fd6cb20cb499440eecabb1a859edc0" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt; . So &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt; .</source>
          <target state="translated">Что это за &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ? Что ж, аргументы подпрограммы доступны нам в виде специального массива с именем &lt;code&gt;@_&lt;/code&gt; (см. &lt;a href=&quot;perlvar&quot;&gt;Perlvar&lt;/a&gt; для получения дополнительной информации). Аргумент по умолчанию для функции &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; просто &lt;code&gt;@_&lt;/code&gt; . Итак, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; сдвигает первый элемент из списка аргументов и присваивает его &lt;code&gt;$logmessage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f547a820f19e246c5a238efacc444f158add7954" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;shift&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;shift&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt;. So &lt;code&gt;my $logmessage = shift;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46db4fba6102cb384fdb3af284b14f9799d7a634" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;delete&quot; and &quot;undef&quot; with hashes?</source>
          <target state="translated">Какая разница между &quot;удалить&quot; и &quot;не дефинировать&quot; с помощью хэшей?</target>
        </trans-unit>
        <trans-unit id="efcfc0c915c5ced8aa18fe665d7a6bf921317ac3" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</source>
          <target state="translated">Какая разница между &quot;перл&quot; и &quot;перл&quot;?</target>
        </trans-unit>
        <trans-unit id="63f076d778aa21d0e84626f4c5e0c5b8d663503c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt; ?</source>
          <target state="translated">В чем разница между &lt;code&gt;UTF-8&lt;/code&gt; и &lt;code&gt;utf8&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="80de415750b641663470a45e8ab912ba377dfdef" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1cf1781cda10277aefd4a7483c6c07d76809d8" translate="yes" xml:space="preserve">
          <source>What's the difference between UTF-8 and utf8?</source>
          <target state="translated">Какая разница между UTF-8 и UTF-8?</target>
        </trans-unit>
        <trans-unit id="1a32eae97c19fcd8cd7ae50ba5b1fb91847cfda9" translate="yes" xml:space="preserve">
          <source>What's the difference between calling a function as &amp;amp;foo and foo()?</source>
          <target state="translated">В чем разница между вызовом функции как &amp;amp; foo и foo ()?</target>
        </trans-unit>
        <trans-unit id="def2247288e4f5204ba55472b4461e996492e2e7" translate="yes" xml:space="preserve">
          <source>What's the difference between deep and shallow binding?</source>
          <target state="translated">Какая разница между глубоким и неглубоким переплётом?</target>
        </trans-unit>
        <trans-unit id="95fdb9749f45655e65a25dc015c0a84e8ebabe59" translate="yes" xml:space="preserve">
          <source>What's the difference between dynamic and lexical (static) scoping? Between local() and my()?</source>
          <target state="translated">В чем разница между динамическим и лексическим (статическим)обзором? Между local()и my()?</target>
        </trans-unit>
        <trans-unit id="83bcf34d32fd45bb7e4990d1041e30347690cdee" translate="yes" xml:space="preserve">
          <source>What's the difference between require and use?</source>
          <target state="translated">Какая разница между требованием и использованием?</target>
        </trans-unit>
        <trans-unit id="623db2e6cf92d9577f09035416d4d1ab6a554bc6" translate="yes" xml:space="preserve">
          <source>What's the minimum perl version required to run Archive::Tar?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6475c25e2b2e180b098b671e2a15d671e687b92e" translate="yes" xml:space="preserve">
          <source>What's this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cf3a0e365c639b428e364b59520ed78e55a70c" translate="yes" xml:space="preserve">
          <source>What's wrong the with gettext-using code like this...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20e3ec3698a540277cd6005030f3f2eae027cdc" translate="yes" xml:space="preserve">
          <source>What's wrong with *-w* and $^W</source>
          <target state="translated">Что не так с *-w*и $^W.</target>
        </trans-unit>
        <trans-unit id="0d7b30ea762ee4ef5180cde544a82675165a0f09" translate="yes" xml:space="preserve">
          <source>What's wrong with -w and $^W</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8abb891068053380c8e2c57ccfc03bd7f1c3bec" translate="yes" xml:space="preserve">
          <source>What's wrong with &lt;b&gt;-w&lt;/b&gt; and &lt;code&gt;$^W&lt;/code&gt;</source>
          <target state="translated">Что не так с &lt;b&gt;-w&lt;/b&gt; и &lt;code&gt;$^W&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86c8915176784b924b124a7df71bcedbc4d5aeac" translate="yes" xml:space="preserve">
          <source>What's wrong with always quoting &quot;$vars&quot;?</source>
          <target state="translated">Что плохого в том,чтобы всегда цитировать &quot;$vars&quot;?</target>
        </trans-unit>
        <trans-unit id="a6b6f35263a6c409ef4d9ea90bf4d23520808808" translate="yes" xml:space="preserve">
          <source>What's wrong with using backticks in a void context?</source>
          <target state="translated">Что плохого в использовании обратных ссылок в пустом контексте?</target>
        </trans-unit>
        <trans-unit id="15b450eb4383c04ae9890e63ad467617d37b687c" translate="yes" xml:space="preserve">
          <source>What's wrong with using grep in a void context?</source>
          <target state="translated">Что плохого в использовании grep в пустом контексте?</target>
        </trans-unit>
        <trans-unit id="48dabfbbabfdd23fd6a91f1e79b5b5393e8fc727" translate="yes" xml:space="preserve">
          <source>What's wrong?</source>
          <target state="translated">Что случилось?</target>
        </trans-unit>
        <trans-unit id="81f7ea2721e1db165495605d1bf1128fca1fe7a9" translate="yes" xml:space="preserve">
          <source>Whatever a reference refers to, which may or may not have a name. Common types of referents include scalars, arrays, hashes, and subroutines.</source>
          <target state="translated">К чему бы ни относилась ссылка,которая может иметь или не иметь названия.Обычные типы ссылок включают скаляры,массивы,хэши и подпрограммы.</target>
        </trans-unit>
        <trans-unit id="088ce6907b9c85d16edc0ae58b2aca12ddc17aac" translate="yes" xml:space="preserve">
          <source>Whatever happens in the RE engine might be better discussed in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the sake of continuity, we shall do so here.</source>
          <target state="translated">Что бы ни происходило в движке RE, лучше обсудить на &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; , но для непрерывности мы сделаем это здесь.</target>
        </trans-unit>
        <trans-unit id="1858f2d67aca21222e3d2c00cfe67bcfdc61e6f3" translate="yes" xml:space="preserve">
          <source>Whatever the distribution configured with on the releaser's machine at release time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f153d99158c54cb43c1d3fc8596ddbfe423f08fe" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt; . &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">Что бы вы ни хотели сделать со ссылкой, &lt;b&gt;правило использования 1&lt;/b&gt; говорит вам, как это сделать. Вы просто пишете Perl-код, который вы бы написали для того же действия с обычным массивом или хешем, а затем заменяете имя массива или хеш-функции на &lt;code&gt;{$reference}&lt;/code&gt; . &amp;laquo;Как мне перебрать массив, когда все, что у меня есть, - это ссылка?&amp;raquo; Ну, чтобы перебрать массив, вы должны написать</target>
        </trans-unit>
        <trans-unit id="b5090b0a0f33f56f40ebfa24d96ae2ad1f9f57a8" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt;. &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="7ae3880ea71f58f5dbf3834e6e0d70053eb70246" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt; &quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt; &quot; is assumed.</source>
          <target state="translated">Когда &quot; &lt;code&gt;::&lt;/code&gt; &quot; отсутствует в имени, предполагается &quot; &lt;code&gt;Encode::&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="8cc9e35707e78514053d0fbc759ccaa1c9412305" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt;&quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt;&quot; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89c66deca9575739eac57be484648de00b11290" translate="yes" xml:space="preserve">
          <source>When $data is present, sets the instance data to $data and returns the object itself. Otherwise, the current instance data is returned.</source>
          <target state="translated">Когда присутствует $data,устанавливаем данные экземпляра в $data и возвращаем сам объект.В противном случае будут возвращены данные текущего экземпляра.</target>
        </trans-unit>
        <trans-unit id="5ea5db67e72bdcabd78dcc6373fac87d452cfae7" translate="yes" xml:space="preserve">
          <source>When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</source>
          <target state="translated">Если $encoding опущено,по умолчанию он равен utf8,если $data уже находится в utf8 или &quot;&quot;.(пустая строка)иначе.</target>
        </trans-unit>
        <trans-unit id="3a255f10977ad0e9fd4eef99c75ca5b6bedb2369" translate="yes" xml:space="preserve">
          <source>When $encoding is present, sets the instance encoding to $encoding and returns the object itself. Otherwise, the current instance encoding is returned.</source>
          <target state="translated">Когда присутствует $encoding,установите кодировку экземпляра в $encoding и верните сам объект.В противном случае возвращается текущая экземпляровая кодировка.</target>
        </trans-unit>
        <trans-unit id="c1731c29e738a553728a82585755466ae75d0743" translate="yes" xml:space="preserve">
          <source>When $walker is called, it traverses the subroutines supplied when it was created, and renders them using the current style. You can change the style afterwards in several different ways:</source>
          <target state="translated">Когда вызывается $walker,он проходит по подпрограммам,поставленным при его создании,и визуализирует их,используя текущий стиль.После этого вы можете изменить стиль несколькими различными способами:</target>
        </trans-unit>
        <trans-unit id="34501938bea4725e00e5d23af26af9e9de4937a2" translate="yes" xml:space="preserve">
          <source>When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be backed up at this location.</source>
          <target state="translated">При выполнении команды 'make clean' или аналогичной,резервная копия $(FIRST_MAKEFILE)будет создана в этом месте.</target>
        </trans-unit>
        <trans-unit id="0abdf7ca0a208a27b487c4c9ab6758614a97566c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; had a host option, this host will be used. Without &lt;code&gt;$host&lt;/code&gt; argument, all hosts are scanned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e0d783eb05bd44a60d48045d09e1ab76b77d53" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a194e79d9bd84bd7e1d0517e4cb70b910eba34" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (but not &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect, &lt;code&gt;sort LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7a9b507455bc0f46d9bdf6728d0f728b33492c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is set to &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, when &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; subsequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a46234156e6749e9bc38b78f59bb3969925d8bf" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">Когда присутствует &lt;b&gt;--compat-version&lt;/b&gt; ( &lt;b&gt;-b&lt;/b&gt; ), сгенерированные тесты будут использовать &lt;code&gt;Test::More&lt;/code&gt; а не &lt;code&gt;Test&lt;/code&gt; , который используется по умолчанию для версий до 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; будет добавлен в PREREQ_PM в созданном &lt;code&gt;Makefile.PL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c72e13c5aa4ae0a2cebdd6d17deca3e4c332c7a" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d44d0dc017c71b0f6cb1ffd43c417d3ee2ebe5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;S&quot;&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;&quot;T&quot;&lt;/code&gt; can match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98323433c84745d96d2f69c24c5375707e53e818" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">Когда для &lt;code&gt;$/&lt;/code&gt; установлено &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , когда &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; находится в скалярном контексте (то есть в режиме slurp файла), и когда читается пустой файл, он возвращает &lt;code&gt;''&lt;/code&gt; первый раз&amp;raquo;, а затем - &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7865066f4690dc076b5908415bb1b4ea7d2066d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">Когда для &lt;code&gt;$/&lt;/code&gt; установлено &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , когда &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; находится в скалярном контексте (то есть в режиме slurp файла), и когда читается пустой файл, он возвращает &lt;code&gt;''&lt;/code&gt; первый раз&amp;raquo;, а затем - &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a000e25ad164b5a4e8e6e794f33b40196ef9e9c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, any existing callback will be removed and &lt;code&gt;decode&lt;/code&gt; will not change the deserialised hash in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cdec40a0b802970de3c22418f7ef1894e05ac3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is specified, it will be called from &lt;code&gt;decode&lt;/code&gt; each time it decodes a JSON object. The only argument is a reference to the newly-created hash. If the code references returns a single scalar (which need not be a reference), this value (or rather a copy of it) is inserted into the deserialised data structure. If it returns an empty list (NOTE:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75765cbe47d6e2730ecd17d719657c6826993abb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple compressed files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer, after uncompression &lt;code&gt;$output_filename_or_reference&lt;/code&gt; will contain a concatenation of all the uncompressed data from each of the input files/buffers.</source>
          <target state="translated">Когда &lt;code&gt;$input_filename_or_reference&lt;/code&gt; отображается на несколько сжатых файлов / буферов, а &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является одним файлом / буфером, после распаковки &lt;code&gt;$output_filename_or_reference&lt;/code&gt; будет содержать конкатенацию всех несжатых данных из каждого из входных файлов / буферов.</target>
        </trans-unit>
        <trans-unit id="ead5ec1ebcf9002ff366c3f4b5ecf105bcef3b1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a concatenated series of compressed data streams.</source>
          <target state="translated">Когда &lt;code&gt;$input_filename_or_reference&lt;/code&gt; сопоставляется с несколькими файлами / буферами, а &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является одним файлом / буфером, входные файлы / буферы будут храниться в &lt;code&gt;$output_filename_or_reference&lt;/code&gt; как объединенная серия сжатых потоков данных.</target>
        </trans-unit>
        <trans-unit id="42c11e18ef09b7c84100ba9f7d909d637366a78e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will each be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a distinct entry.</source>
          <target state="translated">Когда &lt;code&gt;$input_filename_or_reference&lt;/code&gt; отображается на несколько файлов / буферов, а &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является одним файлом / буфером, каждый входной файл / буфер будет сохранен в &lt;code&gt;$output_filename_or_reference&lt;/code&gt; как отдельная запись.</target>
        </trans-unit>
        <trans-unit id="161359b9eacea931dac1aa6e52278dc1eae64067" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an fileglob string, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; must also be a fileglob string. Anything else is an error.</source>
          <target state="translated">Когда &lt;code&gt;$output_filename_or_reference&lt;/code&gt; является строкой fileglob, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; также должна быть строкой fileglob. Все остальное - ошибка.</target>
        </trans-unit>
        <trans-unit id="d2909a9438238d7274c21eee7293fc99c88b23e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;&lt;code&gt;${^UNICODE}&lt;/code&gt;&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;&lt;code&gt;-C&lt;/code&gt;&quot; in perlrun&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2506bf0aaa0a66933521706c1367d6dcef56da1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">Если &lt;code&gt;${^UNICODE}&lt;/code&gt; (доступно начиная с v5.8.2) существует и не равно нулю, эти параметры будут полностью игнорироваться. Подробности смотрите в &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;$ {^ UNICODE} в perlvar&lt;/a&gt; и &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C в perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7dd1602a2fa020d33fb149e95e48b61aba92e31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; аргументы косвенно выполняются оболочкой, результаты и коды возврата зависят от ее особенностей. Подробнее см. &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` в perlop&lt;/a&gt; и &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce37de4fd1569bb63f53c7c4c16cdb716157400b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (но не &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ), по сути, своего &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; сортирует список в соответствии с текущей сортировки местности. Смотрите &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b89dec84fb05fc282a0e80acf7739b8c5833a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.</source>
          <target state="translated">Когда указано &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; , указанные флаги автоматически добавляются к каждому регулярному выражению до конца лексической области видимости.</target>
        </trans-unit>
        <trans-unit id="826f4d022e4908a4bde930341263c135e67935f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt; -enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; , по сути, Perl излучает отладочные сообщения при компиляции и с использованием регулярных выражений. Выход тот же, что получается, запустив &lt;code&gt;-DDEBUGGING&lt;/code&gt; -Enabled интерпретатор Perl с &lt;b&gt;-dr&lt;/b&gt; переключателем. Он может быть довольно объемным в зависимости от сложности матча. Использование &lt;code&gt;debugcolor&lt;/code&gt; вместо &lt;code&gt;debug&lt;/code&gt; обеспечивает форму вывода, которая может использоваться для получения красочного отображения на терминалах, которые понимают цветовые последовательности termcap. Задайте для &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; список свойств &lt;code&gt;termcap&lt;/code&gt; , разделенных запятыми, которые будут использоваться для включения / выключения выделения строк и включения / выключения предварительной точки. См. Раздел &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Отладка регулярных выражений в perldebug&lt;/a&gt; для дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6c428ad9961e409888285c5019a1884325617653" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(?{ code }) in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(??{ code }) in perlre&lt;/a&gt;.</source>
          <target state="translated">Когда действует &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , регулярное выражение может содержать &lt;code&gt;(?{ ... })&lt;/code&gt; утверждения нулевой ширины и &lt;code&gt;(??{ ... })&lt;/code&gt; отложенные подвыражения, которые получены из интерполяции переменных, а не появляются буквально внутри регулярного выражения. Обычно это не разрешается, так как это потенциальная угроза безопасности. Обратите внимание, что эта прагма игнорируется, когда регулярное выражение получается из испорченных данных, т.е. оценка всегда запрещена для испорченных регулярных выражений. См. &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(? {Code}) в perlre&lt;/a&gt; и &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(?? {code}) в perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c489bf5f6075f7a85a4147bc159e1965fa8ad2cd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">Когда действует &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; , применяются более строгие проверки, чем при компиляции шаблонов регулярных выражений. Это может привести к тому, что будет выдано больше предупреждений, чем в противном случае, и больше вещей будут фатальными, а не просто предупреждениями. Цель этого - найти и сообщить во время компиляции о некоторых вещах, которые могут быть законными, но имеют разумную вероятность того, что они не являются фактическими намерениями программиста. Это автоматически включает категорию предупреждений &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; (если она еще не включена) в пределах своей области действия.</target>
        </trans-unit>
        <trans-unit id="057f6216fa3faf81b159095b26d348ad7b06bd25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">Когда действует &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; и испорченная строка является целью регулярного выражения, память регулярного выражения (или значения, возвращаемые оператором m // в контексте списка) испорчены. Эта функция полезна, когда операции регулярного выражения с испорченными данными предназначены не для извлечения безопасных подстрок, а для выполнения других преобразований.</target>
        </trans-unit>
        <trans-unit id="d35b2d737154679691874d190272f87d34f67d6b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; аргументы косвенно выполняются оболочкой, результаты и коды возврата зависят от ее особенностей. Подробнее см. &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` в perlop&lt;/a&gt; и &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d249161b8d76a85447f9bcf8c19ecaa9c4041708" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">Когда &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (но не &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ), по сути, своего &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; сортирует список в соответствии с текущей сортировки местности. Смотрите &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb0ac41f5c76b7790f54d079dd94b8ce0665510" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Append&lt;/code&gt; is specified, and set to true, it will</source>
          <target state="translated">Если &lt;code&gt;Append&lt;/code&gt; и установлено значение true, оно будет</target>
        </trans-unit>
        <trans-unit id="74620e73df76b9793a4b5915498c084620ae1197" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">Если &lt;code&gt;LimitOutout&lt;/code&gt; не указан, &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; будет использовать столько памяти, сколько требуется для записи всех несжатых данных, которые он создает, распаковывая входной буфер.</target>
        </trans-unit>
        <trans-unit id="476db1003af9ea2b2d5dff0b4d9aae2335796a1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">Если &lt;code&gt;LimitOutout&lt;/code&gt; не указан, &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; будет использовать столько памяти, сколько требуется для записи всех несжатых данных, которые он создает, распаковывая входной буфер.</target>
        </trans-unit>
        <trans-unit id="3a29eb1b7605b447e178aa583e1e3d0b18b3e32a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">Когда используется &lt;code&gt;LimitOutput&lt;/code&gt; , размер используемого выходного буфера будет либо 16k, либо объемом памяти, уже выделенной для &lt;code&gt;$output&lt;/code&gt; , в зависимости от того, что больше. Предсказать доступный выходной размер сложно, поэтому не полагайтесь на получение точного размера выходного буфера.</target>
        </trans-unit>
        <trans-unit id="378bab7c46fb87434a4a31e87bab949c33fee48d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884e67243b247f9f83c1056f56446e2954b8717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">Когда используется &lt;code&gt;LimitOutput&lt;/code&gt; , размер используемого выходного буфера будет либо значением параметра &lt;code&gt;Bufsize&lt;/code&gt; , либо объемом памяти, уже выделенной для &lt;code&gt;$output&lt;/code&gt; , в зависимости от того, что больше. Предсказать доступный выходной размер сложно, поэтому не полагайтесь на получение точного размера выходного буфера.</target>
        </trans-unit>
        <trans-unit id="e109cef898586b284816d1d609f442757d09d9a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3a312e83feddf95b646900a17ece38db487898" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3F&quot;&gt;&quot;$?&quot;&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;die&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4b51758778b88a3620755cd86e2bac9c6c0e5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">Когда &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; активен (см. &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; Ниже), значение исходного статуса выхода VMS будет иметь одно из значений &lt;code&gt;$!&lt;/code&gt; или &lt;code&gt;$?&lt;/code&gt; или &lt;code&gt;$^E&lt;/code&gt; или значение 255 Unix, закодированное в нем таким образом, что эффективное исходное значение может быть декодировано другими программами, написанными на C, включая Perl и пакет GNV. В соответствии с обычным поведением &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , если либо &lt;code&gt;$!&lt;/code&gt; или &lt;code&gt;$?&lt;/code&gt; не равны нулю, одно из этих значений будет закодировано в собственное значение статуса VMS. Если оба значения статуса Unix равны 0, а для значения &lt;code&gt;$^E&lt;/code&gt; задано одно из значений серьезности ERROR или SEVERE_ERROR, тогда &lt;code&gt;$^E&lt;/code&gt; значение будет использоваться как код выхода как есть. Если ничего из вышеперечисленного не применимо, значение 255 Unix будет закодировано в собственное значение статуса выхода VMS.</target>
        </trans-unit>
        <trans-unit id="edf0ae2377a2b22abb92a09c7cbee6dad38f469d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;S&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;T&lt;/code&gt; can match.</source>
          <target state="translated">Когда &lt;code&gt;S&lt;/code&gt; может соответствовать, это лучше, чем когда может соответствовать только &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e7bb6aa4bca28bb16c16381fd1ea0fe317f098c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Strict&lt;/code&gt; is disabled the following behaviour will be policed:</source>
          <target state="translated">Когда &lt;code&gt;Strict&lt;/code&gt; отключено, будет отслеживаться следующее поведение:</target>
        </trans-unit>
        <trans-unit id="db687c97fb2b33423a8768bd320e4711c5ad7257" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Time::Local&lt;/code&gt; was first written, it was a common practice to represent years as a two-digit value like &lt;code&gt;99&lt;/code&gt; for &lt;code&gt;1999&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;2001&lt;/code&gt;. This caused all sorts of problems (google &quot;Y2K problem&quot; if you're very young) and developers eventually realized that this was a terrible idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792e600779793d69f3a4dfa3dfa3dd30d40ce8a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, the weights of out-of-range values can be overridden. Though &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; are available for them, out-of-range values are too many.</source>
          <target state="translated">Когда &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; = 22, веса значений, выходящих за пределы допустимого диапазона, могут быть переопределены. Хотя для них доступны &lt;code&gt;table&lt;/code&gt; или &lt;code&gt;entry&lt;/code&gt; , значений вне диапазона слишком много.</target>
        </trans-unit>
        <trans-unit id="a8376390a3e85be3e6ac52a52161522985c10ab7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;allow_bignum&lt;/code&gt; is enabled, big integer values and any numeric values will be converted into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; and &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects respectively, without becoming string scalars or losing precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88bdc0c0c759d08c6275afc07854842d8f95efa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">Когда &lt;code&gt;base&lt;/code&gt; пытается &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; модуль, она не умрет, если не сможет найти файл модуля, но умрет при любой другой ошибке. После всего этого, если ваш базовый класс будет пустым и не будет содержать символов, &lt;code&gt;base&lt;/code&gt; умрет. Это полезно для наследования от классов в том же файле, что и вы, но где имя файла не соответствует имени базового модуля, например:</target>
        </trans-unit>
        <trans-unit id="7e10e7af3fdfd7341808494145f96d758dfe5848" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;require&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801ac03d31183f16ba294ce4fa7c937f1f41d11" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dynamic_config&lt;/code&gt; is true, it is an error to presume that the prerequisites given in distribution metadata will have any relationship whatsoever to the actual prerequisites of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f15dbf4bfac8ce422e1183a7c97c2a550a0582" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt; . The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</source>
          <target state="translated">Когда &lt;code&gt;follow_fast&lt;/code&gt; &lt;code&gt;follow&lt;/code&gt; или follow_fast , существует также &lt;code&gt;$File::Find::fullname&lt;/code&gt; . Функция может установить &lt;code&gt;$File::Find::prune&lt;/code&gt; для обрезки дерева, если &lt;code&gt;bydepth&lt;/code&gt; была указана bydepth . Если не указано &lt;code&gt;follow&lt;/code&gt; или &lt;code&gt;follow_fast&lt;/code&gt; , по соображениям совместимости (find.pl, find2perl) дополнительно доступны следующие глобальные переменные: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; и &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e21f0f2ae6a786fecac14190bdb286ef45b2801" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt;. The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt;, &lt;code&gt;$File::Find::topdev&lt;/code&gt;, &lt;code&gt;$File::Find::topino&lt;/code&gt;, &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3af0ccfdbd0226b2c1c6a386ea7d1149b898de" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;get_handle&lt;/code&gt; is called with an empty parameter list, magic happens:</source>
          <target state="translated">Когда &lt;code&gt;get_handle&lt;/code&gt; вызывается с пустым списком параметров, происходит волшебство:</target>
        </trans-unit>
        <trans-unit id="0587cd71d3cd406da1e34d9f0121a501c139389a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove_tree&lt;/code&gt; returned from deleting files in a child directory, a check revealed that the parent directory it returned to wasn't the one it started out from. This is considered a sign of malicious activity.</source>
          <target state="translated">Когда &lt;code&gt;remove_tree&lt;/code&gt; вернулся после удаления файлов в дочернем каталоге, проверка показала, что родительский каталог, в который он вернулся, не был тем, из которого он начал. Это считается признаком злонамеренной активности.</target>
        </trans-unit>
        <trans-unit id="0abaa039dcd0b20cc37827ce7e9a425281864469" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;share&lt;/code&gt; is used on arrays, hashes, array refs or hash refs, any data they contain will be lost.</source>
          <target state="translated">Когда &lt;code&gt;share&lt;/code&gt; используется для массивов, хэшей, ссылок на массив или хеш-ссылок, любые данные, которые они содержат, будут потеряны.</target>
        </trans-unit>
        <trans-unit id="f072734b6ff55766546071395774e151a8cea193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;test_test&lt;/code&gt; is called and the output that your tests generate does not match that which you declared, &lt;code&gt;test_test&lt;/code&gt; will print out debug information showing the two conflicting versions. As this output itself is debug information it can be confusing which part of the output is from &lt;code&gt;test_test&lt;/code&gt; and which was the original output from your original tests. Also, it may be hard to spot things like extraneous whitespace at the end of lines that may cause your test to fail even though the output looks similar.</source>
          <target state="translated">Когда &lt;code&gt;test_test&lt;/code&gt; и вывод, который генерируют ваши тесты, не соответствует заявленному вами, &lt;code&gt;test_test&lt;/code&gt; распечатает отладочную информацию, показывающую две конфликтующие версии. Поскольку этот вывод сам по себе является отладочной информацией, может быть непонятно, какая часть вывода &lt;code&gt;test_test&lt;/code&gt; из test_test, а какая была исходным выводом ваших исходных тестов. Кроме того, может быть трудно обнаружить такие вещи, как посторонние пробелы в конце строк, которые могут привести к сбою вашего теста, даже если результат выглядит похожим.</target>
        </trans-unit>
        <trans-unit id="100cf02e094db7d3754b0f2bd62e72f796e0a652" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; is specified, the given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e437612ab773128746c34ed5e2418f0d2432e87" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebug&lt;/a&gt; for additional info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdd2a4a70c97e6482142a6afb44a0c24ab7f2c4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#%28%3F%7B-code-%7D%29&quot;&gt;&quot;(?{ code })&quot; in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#%28%3F%3F%7B-code-%7D%29&quot;&gt;&quot;(??{ code })&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d8ac1a2fdcf9c532880e4f21577de40d0e705a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d597df9736b57e5c279970bfb89c7002422580" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea81caddf6f1e1e3901216d09988417e561f49ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;utf8&lt;/code&gt; is disabled (the default), then &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; generate and expect Unicode strings, that is, characters with high ordinal Unicode values (&amp;gt; 255) will be encoded as such characters, and likewise such characters are decoded as-is, no changes to them will be done, except &quot;(re-)interpreting&quot; them as Unicode codepoints or Unicode characters, respectively (to Perl, these are the same thing in strings unless you do funny/weird/dumb stuff).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8ac650ec538c50bdeb4cf6dbd53747bc753f1f" translate="yes" xml:space="preserve">
          <source>When BE or LE is explicitly stated as the name of encoding, BOM is simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</source>
          <target state="translated">Когда BE или LE явно указаны как имя кодировки,BOM просто обрабатывается как обычный символ (НУЛЕВАЯ ШИРИНА NO-БРЕЙК ПРОСТРАНСТВО).</target>
        </trans-unit>
        <trans-unit id="68ea7ed2b7146d8c990e48756af545235a644f6f" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbaed27da231d1d0f199bebcb75bb30dedc0240" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says. If no BOM is found, the routine dies.</source>
          <target state="translated">Когда BE или LE опускается во время decode(),он проверяет,находится ли BOM в начале строки;если он найден,то эндианность устанавливается на то,что говорит BOM.Если BOM не найдена,рутина умирает.</target>
        </trans-unit>
        <trans-unit id="420dd2e0afe91753dba538ca831997f9f3a56a48" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during encode(), it returns a BE-encoded string with BOM prepended. So when you want to encode a whole text file, make sure you encode() the whole text at once, not line by line or each line, not file, will have a BOM prepended.</source>
          <target state="translated">Когда BE или LE опускается во время функции encode(),она возвращает строку,закодированную в BE с префиксом BOM.Поэтому,когда вы хотите закодировать весь текстовый файл,убедитесь,что вы кодируете()весь текст сразу,а не строку за строкой,или каждая строка,а не файл,будет иметь префикс BOM.</target>
        </trans-unit>
        <trans-unit id="dacba9cd09b7954f0b607de2124d67d55cdeb2ac" translate="yes" xml:space="preserve">
          <source>When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING to the ID of the running process. It also sets PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could happen with older versions of Module::Install.</source>
          <target state="translated">При запуске CPAN она устанавливает переменную окружения PERL5_CPAN_IS_RUNNING в ID запущенного процесса.Также она устанавливает переменную PERL5_CPANPLUS_IS_RUNNING,чтобы предотвратить запуск процессов,которые могут произойти со старыми версиями Module::Install.</target>
        </trans-unit>
        <trans-unit id="652978d2789dfa7c2e88ae3ead48735cc4a8b7e9" translate="yes" xml:space="preserve">
          <source>When CPAN.pm extends @INC via PERL5LIB, it prints a list of directories added (or a summary of how many directories are added). Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">Когда CPAN.pm расширяет @INC через PERL5LIB,он печатает список добавленных каталогов (или сводку о том,сколько каталогов добавлено).Выберите 'v' для получения этого сообщения,'none' для его подавления.</target>
        </trans-unit>
        <trans-unit id="ec2c74f66c6e4b429c5d3bf449f05522f381cd48" translate="yes" xml:space="preserve">
          <source>When CPAN.pm loads a module it needs for some optional feature, it usually reports about module name and version. Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">Когда CPAN.pm загружает модуль,который ему нужен для какой-то дополнительной функции,он обычно сообщает об имени и версии модуля.Выберите 'v',чтобы получить это сообщение,'none',чтобы подавить его.</target>
        </trans-unit>
        <trans-unit id="a6c2efe210167d6d16736590efab450901a5223c" translate="yes" xml:space="preserve">
          <source>When CPAN.pm uses the tar command, which switch for the verbosity shall be used? Choose 'none' for quiet operation, 'v' for file name listing, 'vv' for full listing.</source>
          <target state="translated">Когда CPAN.pm использует команду tar,какой переключатель для глагола должен быть использован? Выберите 'none' для тихой работы,'v' для списка имен файлов,'vv' для полного списка.</target>
        </trans-unit>
        <trans-unit id="09926237f4d026fd4275fa85769eac33da9c9434" translate="yes" xml:space="preserve">
          <source>When Configure asks about the extensions, I suggest IO and Fcntl, and if you want database handling then SDBM_File or GDBM_File (you need to install gdbm for this one). If you want to use the POSIX extension (this is the default), make sure that the stack size of your</source>
          <target state="translated">Когда Configure спрашивает о расширениях,я предлагаю IO и Fcntl,и если вы хотите работать с базой данных,то SDBM_File или GDBM_File (для этого вам нужно установить gdbm).Если вы хотите использовать расширение POSIX (это расширение используется по умолчанию),убедитесь,что размер стека вашего</target>
        </trans-unit>
        <trans-unit id="04e0b7cf71399471be99cb867416364c0df9f40e" translate="yes" xml:space="preserve">
          <source>When Democritus gave the word &amp;ldquo;atom&amp;rdquo; to the indivisible bits of matter, he meant literally something that could not be cut:</source>
          <target state="translated">Когда Демокрит дал слово &amp;laquo;атом&amp;raquo; неделимым частям материи, он имел в виду буквально то, что нельзя разрезать:</target>
        </trans-unit>
        <trans-unit id="bed16fa39ff4d380815a5a95de03029e7764deee" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt; . Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">Когда используется G_KEEPERR, любая ошибка в вызываемом коде завершит вызов, как обычно, и ошибка не будет распространяться за пределы вызова (как обычно для G_EVAL), но не перейдет в &lt;code&gt;$@&lt;/code&gt; . Вместо этого ошибка будет преобразована в предупреждение со строкой &amp;laquo;\ t (in cleanup)&amp;raquo;. Это можно отключить &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . Если ошибки нет, &lt;code&gt;$@&lt;/code&gt; не будет очищен.</target>
        </trans-unit>
        <trans-unit id="bd0879b5780d10481d395ff78c94006ad9de4758" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt;. Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;no warnings 'misc'&lt;/code&gt;. If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cefe86149d167c60485e01ab068ab4acc1c96d" translate="yes" xml:space="preserve">
          <source>When I install bundles or multiple modules with one command there is too much output to keep track of.</source>
          <target state="translated">Когда я устанавливаю пучки или несколько модулей с одной командой,слишком много вывода,чтобы отслеживать.</target>
        </trans-unit>
        <trans-unit id="96aa2dd484c673b89bb47260df9f770fc3e65459" translate="yes" xml:space="preserve">
          <source>When I run CPAN's shell, I get an error message about things in my &lt;code&gt;/etc/inputrc&lt;/code&gt; (or &lt;code&gt;~/.inputrc&lt;/code&gt;) file.</source>
          <target state="translated">Когда я запускаю оболочку CPAN, я получаю сообщение об ошибке в моем &lt;code&gt;/etc/inputrc&lt;/code&gt; (или &lt;code&gt;~/.inputrc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc4c433cebf4d4f4606a91e341dbbd967898b31d" translate="yes" xml:space="preserve">
          <source>When I run my tests TAP::Harness creates a scheduler (TAP::Parser::Scheduler) to work out the running order for the tests, an aggregator (TAP::Parser::Aggregator) to collect and analyse the test results and a formatter (TAP::Formatter::Console) to display those results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712f9e473dcc2ba74a4ec66b73d3e2f5bccede0e" translate="yes" xml:space="preserve">
          <source>When I run prove it processes its arguments, figures out which test scripts to run and then passes control to TAP::Harness to run the tests, parse, analyse and present the results. By subclassing TAP::Harness I can customise many aspects of the test run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1064c03f1fc4073f4165a39d84f0e0127c6dd155" translate="yes" xml:space="preserve">
          <source>When I tell prove to save state it writes a file called '.prove' ('_prove' on Windows) in the current directory. It's a YAML document so it's quite easy to write tools of your own that work on the saved test state - but the format isn't officially documented so it might change without (much) warning in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b21be97219bbbb10df79f70e49405f833c3cad4" translate="yes" xml:space="preserve">
          <source>When I tried to run my script, I got this message. What does it mean?</source>
          <target state="translated">Когда я пытался запустить свой сценарий,я получил это сообщение.Что оно значит?</target>
        </trans-unit>
        <trans-unit id="e4bb48e8ad735dfd3ed959c0444d6089c891d679" translate="yes" xml:space="preserve">
          <source>When I/O, for example &quot;read&quot;, is requested, the request goes from Perl first down the stack using &quot;read&quot; functions of each layer, then at the bottom the input is requested from the operating system services, then the result is returned up the stack, finally being interpreted as Perl data.</source>
          <target state="translated">Когда запрашивается ввод/вывод,например,&quot;чтение&quot;,запрос идет от Perl сначала по стеку,используя функции &quot;чтения&quot; каждого слоя,затем внизу запрашивается вход от служб операционной системы,затем результат возвращается вверх по стеку,и,наконец,интерпретируется как данные Perl.</target>
        </trans-unit>
        <trans-unit id="e5e8467b062c382be485cbe69584b5d02adf0299" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">Когда Memoize нужно проверить, есть ли уже запись в кеше, он вызовет &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; - это нормализованный аргумент функции. MyExpirePolicy :: EXISTS должен возвращать 0, если ключ отсутствует в кеше или срок его действия истек, и 1, если в кеше находится еще не истекшее значение. Должно</target>
        </trans-unit>
        <trans-unit id="de4b7c34cbf176c69c5c8a01cb2f47a2ef49c9de" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt;. &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd887c91b9049b8dfb0bd1e032eea2b43f90690" translate="yes" xml:space="preserve">
          <source>When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt; :</source>
          <target state="translated">Когда Perl 5.12 или более поздней версии встречает оператор с многоточием, он анализирует его без ошибок, но если и когда вы действительно должны попытаться его выполнить, Perl выдает исключение с текстом &lt;code&gt;Unimplemented&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b63aa2881910e0e5509ac7fb04463269b672b02" translate="yes" xml:space="preserve">
          <source>When Perl 5.6.0 was released, the decision was made to provide a transformation between the old-style decimal versions and new-style dotted-decimal versions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4ce43e1ebabd776abd8a74c5e1d002b8bd8ffe" translate="yes" xml:space="preserve">
          <source>When Perl compiles the regular expression, it treats the parenthesis as the start of a memory match. When it doesn't find the closing parenthesis, it complains:</source>
          <target state="translated">Когда Perl компилирует регулярное выражение,он рассматривает скобки как начало совпадения памяти.Когда он не находит закрывающую скобку,он жалуется:</target>
        </trans-unit>
        <trans-unit id="53c411ad4e1523024c43c3f84e8d99bfb2921a55" translate="yes" xml:space="preserve">
          <source>When Perl destroys the object referenced by $netconf it will send the object to the supplied XSUB DESTROY function. Perl cannot determine, and does not care, that this object is a C struct and not a Perl object. In this sense, there is no difference between the object created by the getnetconfigent() XSUB and an object created by a normal Perl subroutine.</source>
          <target state="translated">Когда Perl уничтожает объект,на который ссылается $netconf,он отправляет объект в поставляемую функцию XSUB DESTROY.Perl не может определить и не заботится о том,что этот объект является C-структурой,а не Perl.В этом смысле,нет никакой разницы между объектом,созданным функцией getnetconfigent()XSUB и объектом,созданным обычной подпрограммой Perl.</target>
        </trans-unit>
        <trans-unit id="954a1b48bf7dbf510303237ceeb967daf1def196" translate="yes" xml:space="preserve">
          <source>When Perl encounters a wildcard subpattern, (see &lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot; in perlunicode&lt;/a&gt;), it suspends compilation of the main pattern, compiles the subpattern, and then matches that against all legal possibilities to determine the actual code points the subpattern matches. After that it adds these to the main pattern, and continues its compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e513aa6b4ab015986cab17c857cc3e0082b263e5" translate="yes" xml:space="preserve">
          <source>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</source>
          <target state="translated">Когда Perl обменивается данными с расширением,расширение должно понимать флаг UTF8 и действовать соответственно.Если расширение не распознает этот флаг,скорее всего,расширение вернет неверно проставленные данные.</target>
        </trans-unit>
        <trans-unit id="4850373be99ff07c49bae45c8a4c6f5b91630080" translate="yes" xml:space="preserve">
          <source>When Perl is being run under a Unix shell on OpenVMS, the defaults at a future time may be more appropriate for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f1776d7dcd16bb2da8426867ab48b032eaee97" translate="yes" xml:space="preserve">
          <source>When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any functions in the Perl API will need to pass the initial context argument somehow. The kicker is that you will need to write it in such a way that the extension still compiles when Perl hasn't been built with PERL_IMPLICIT_CONTEXT enabled.</source>
          <target state="translated">Когда Perl собирается с PERL_IMPLICIT_CONTEXT,расширения,вызывающие любые функции в Perl API,должны как-то передать исходный контекстный аргумент.Кикером является то,что его нужно будет записать таким образом,чтобы расширение все равно компилировалось,когда Perl не был собран с включенной переменной PERL_IMPLICIT_CONTEXT.</target>
        </trans-unit>
        <trans-unit id="f6fb72d35777e36edb4c8c03f40429a73f9b258a" translate="yes" xml:space="preserve">
          <source>When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no first argument containing the interpreter's context. The trailing underscore in the pTHX_ macro indicates that the macro expansion needs a comma after the context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to take the extra argument. The form of the macro without the trailing underscore is used when there are no additional explicit arguments.</source>
          <target state="translated">Когда Perl собирается без опций,устанавливающих PERL_IMPLICIT_CONTEXT,первый аргумент,содержащий контекст интерпретатора,отсутствует.Подчёркивание трейлинга в макросе pTHX_указывает на то,что после аргумента контекста требуется запятая,так как за ним следуют другие аргументы.Если переменная PERL_IMPLICIT_CONTEXT не определена,то pTHX_будет проигнорирована,а подпрограмма не прототипирована для принятия дополнительного аргумента.Форма макроса без трейлингового подчеркивания используется при отсутствии дополнительных явных аргументов.</target>
        </trans-unit>
        <trans-unit id="8079f54267f5c6445383e49837ffc5d08d1d7078" translate="yes" xml:space="preserve">
          <source>When Perl is compiled for a platform, it looks at all of these characters to guess which EBCDIC character set the platform uses, and adapts itself accordingly to that platform. If the platform uses a character set that is not one of the three Perl knows about, Perl will either fail to compile, or mistakenly and silently choose one of the three.</source>
          <target state="translated">Когда Perl компилируется для платформы,он смотрит на все эти символы,чтобы угадать,какой EBCDIC набор символов использует платформа,и адаптируется к этой платформе.Если платформа использует набор символов,о котором не знает один из трех Perl,Perl либо не скомпилирует,либо по ошибке и молча выберет один из трех.</target>
        </trans-unit>
        <trans-unit id="80ed2279b39397e0ed205899926800b606fe0a42" translate="yes" xml:space="preserve">
          <source>When Perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is an incompatibility in OpenBSD's &lt;code&gt;getprotobyname_r&lt;/code&gt; and &lt;code&gt;getservbyname_r&lt;/code&gt; function in versions 3.7 and later that will cause a SEGV when called without doing a &lt;code&gt;bzero&lt;/code&gt; on their return structs prior to calling these functions. Current Perl's should handle this problem correctly. Older threaded Perls (5.8.6 or earlier) will run into this problem. If you want to run a threaded Perl on OpenBSD 3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</source>
          <target state="translated">Когда Perl настроен на использование ithreads, он будет использовать вызовы библиотеки с повторным входом вместо нереентрантных версий. Существует несовместимость в &lt;code&gt;getprotobyname_r&lt;/code&gt; OpenBSD getprotobyname_r и &lt;code&gt;getservbyname_r&lt;/code&gt; в версиях 3.7 и более поздних версиях, что приводит к SEGV при вызове без выполнения &lt;code&gt;bzero&lt;/code&gt; в их структурах возврата перед вызовом этих функций. Текущий Perl должен правильно решить эту проблему. Старые многопоточные Perls (5.8.6 или более ранние) столкнутся с этой проблемой. Если вы хотите запустить Perl с многопоточным интерфейсом на OpenBSD 3.7 или выше, вам нужно будет обновить его до Perl не ниже 5.8.7.</target>
        </trans-unit>
        <trans-unit id="df300d221e04eb6da687f72d9bfb0bebe32d3fc0" translate="yes" xml:space="preserve">
          <source>When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl: because a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.</source>
          <target state="translated">Когда Perl обрабатывает &quot;двоичные данные&quot;,программист хочет,чтобы Perl обрабатывал &quot;последовательности байт&quot;.Для Perl это не проблема:поскольку байт имеет 256 возможных значений,он легко умещается в гораздо более крупный &quot;логический символ&quot; Perl.</target>
        </trans-unit>
        <trans-unit id="317f1e48aa507068045f8759d8c8badef1389fb8" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc51149dee007d3915d8fd89443c351da938e4a2" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Когда Perl запущен в режиме отладки, с ключом &lt;b&gt;-d&lt;/b&gt; , этот GV содержит SV, который содержит имя отлаживаемого подпрограммы. Это переменная C, которая соответствует переменной Perl $ DB :: sub. См. &lt;code&gt;PL_DBsingle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a3d6fd090f13b8b7228c62f6dd0eea36d1d1e84" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsub&quot;&gt;&quot;PL_DBsub&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3590f13940a356a00f485512d64c10323ed9ae31" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;PL_DBsub&lt;/code&gt; .</source>
          <target state="translated">Когда Perl запускается в режиме отладки с ключом &lt;b&gt;-d&lt;/b&gt; , этот SV является логическим значением, которое указывает, являются ли подпрограммы одношаговыми. Пошаговый режим автоматически включается после каждого шага. Это переменная C, которая соответствует переменной Perl $ DB :: single. См. &lt;code&gt;PL_DBsub&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="987fa57f3d6e2d1a009a00d587b9bac8f003a80c" translate="yes" xml:space="preserve">
          <source>When Perl is run with the &lt;b&gt;-Do&lt;/b&gt; switch or its equivalent, overloading induces diagnostic messages.</source>
          <target state="translated">Когда Perl запускается с ключом &lt;b&gt;-Do&lt;/b&gt; или его эквивалентом, перегрузка вызывает диагностические сообщения.</target>
        </trans-unit>
        <trans-unit id="0c8a95fea35938379cf32ffa88d674c595c3842a" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system with &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; enabled, a wild card directory name of &lt;code&gt;[...]&lt;/code&gt; cannot be translated to a valid Unix file specification. Also, directory file specifications will have their implied &quot;.dir;1&quot; removed, and a trailing &lt;code&gt;.&lt;/code&gt; character indicating a null extension will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba82f7be76137263de4d2fc5ab0c4a2f7bd88ccf" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is enabled, this implies that the Unix pathname cannot have a version, and that a path consisting of three dots, &lt;code&gt;./.../&lt;/code&gt;, will be converted to &lt;code&gt;[.^.^.^.]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180489f22e9451652052bb264b159682d8729956" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is not enabled, extra dots in the file specification will be converted to underscore characters, and the &lt;code&gt;?&lt;/code&gt; character will be converted to a &lt;code&gt;%&lt;/code&gt; character, if a conversion is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207a022d8cbd197e2ed92d3189e5fa31c10891e3" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, the following &lt;code&gt;DECC$&lt;/code&gt; feature settings will control how the filename is converted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b65aa4a8ccdb59770227d57464bc9d968a6a6c" translate="yes" xml:space="preserve">
          <source>When Perl searches for a method, it caches the lookup so that future calls to the method do not need to search for it again. Changing a class's parent class or adding subroutines to a class will invalidate the cache for that class.</source>
          <target state="translated">Когда Perl ищет метод,он кэширует поиск так,чтобы при последующих обращениях к методу не было необходимости искать его снова.Изменение родительского класса класса или добавление подпрограмм в класс сделает кэш для этого класса недействительным.</target>
        </trans-unit>
        <trans-unit id="dc44d70cd8e2f4c150d9b1a250549091ec350dff" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; , it searches for a file with the same name as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">Когда Perl видит &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; ; , он ищет файл с тем же именем, что и расширение &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 'd, но с суффиксом .pm. Если этот файл не может быть найден, Perl умирает с фатальной ошибкой. Путь поиска по умолчанию содержится в массиве &lt;code&gt;@INC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8000e169764f8e2a593f5f0dac76f4976f5abd8f" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;use extension;&lt;/code&gt;, it searches for a file with the same name as the &lt;code&gt;use&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2733cf2ae6a9ab4b9666de0ca99b049c5b762772" translate="yes" xml:space="preserve">
          <source>When PerlIO receives data from either direction, it fills a buffer (currently with 1024 bytes) and passes the buffer to Encode. Encode tries to convert the valid part and passes it back to PerlIO, leaving invalid parts (usually a partial character) in the buffer. PerlIO then appends more data to the buffer, calls Encode again, and so on until the data stream ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a181d0244e9e1141094875e09095d6414b083" translate="yes" xml:space="preserve">
          <source>When Pod::Simple sees a &quot;=head1 Hi there&quot;, for example, it basically does this:</source>
          <target state="translated">Например,когда Pod::Simple видит &quot;=head1 Hi there&quot;,он,по сути,делает это:</target>
        </trans-unit>
        <trans-unit id="1cd158af5ecd016f5844a2f8d5f52d658dbd56fa" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">Когда STDERR привязан, его метод PRINT будет вызываться для выдачи предупреждений и сообщений об ошибках. Эта функция временно отключена во время вызова, что означает, что вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; внутри PRINT без запуска рекурсивного цикла. И так же, как &lt;code&gt;__WARN__&lt;/code&gt; и &lt;code&gt;__DIE__&lt;/code&gt; , метод PRINT STDERR может быть вызван для сообщения об ошибках анализатора, поэтому применяются предостережения, упомянутые в разделе &lt;a href=&quot;perlvar#%25SIG&quot;&gt;% SIG в perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22d03f9253db06fc5a737726d6333d6b64f0247b" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;warn()&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&quot;%SIG&quot; in perlvar&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776742a8703e38b8c7c180ad1bc1e1f2ea07cf1b" translate="yes" xml:space="preserve">
          <source>When Storable croaks, it tries to report the error via the &lt;code&gt;logcroak()&lt;/code&gt; routine from the &lt;code&gt;Log::Agent&lt;/code&gt; package, if it is available.</source>
          <target state="translated">Когда Storable хрипит, он пытается сообщить об ошибке с помощью процедуры &lt;code&gt;logcroak()&lt;/code&gt; из пакета &lt;code&gt;Log::Agent&lt;/code&gt; , если он доступен.</target>
        </trans-unit>
        <trans-unit id="b63f06de34cfd6fe1d49dc6c54c0e1ae5c2131fc" translate="yes" xml:space="preserve">
          <source>When Storable throws the &quot;Max. recursion depth with nested structures exceeded&quot; error we are already out of stack space. Unfortunately on some earlier perl versions cleaning up a recursive data structure recurses into the free calls, which will lead to stack overflows in the cleanup. This data structure is not properly cleaned up then, it will only be destroyed during global destruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06dc1e20be879a4646c74d93b6d6dde474c28168" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6016e444b9f013774a61df21cb4a60b0edf43d8" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op. For convenience in what follows the term</source>
          <target state="translated">Когда UTF-8 станет стандартным исходным форматом,эта прагма фактически превратится в &quot;нет-нет-нет&quot;.Для удобства в том,что следует за термином</target>
        </trans-unit>
        <trans-unit id="1e26f2f78b2d3c5f0bcbde15044bd5212be0247d" translate="yes" xml:space="preserve">
          <source>When Unicode Does Not Happen</source>
          <target state="translated">Когда Юникод не происходит.</target>
        </trans-unit>
        <trans-unit id="7748cfda1edce223207e83e001d28dffb7bf724f" translate="yes" xml:space="preserve">
          <source>When Unicode rules are in effect:</source>
          <target state="translated">Когда действуют правила Юникода:</target>
        </trans-unit>
        <trans-unit id="a9436974a6cc23829e6eb2bd840fe00c99d5fdc2" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt; . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt; ), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt; . The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">Когда впервые был задуман Unicode, считалось, что все символы мира могут быть представлены с помощью 16-битного слова; то есть &lt;code&gt;0x10000&lt;/code&gt; максимум 0x10000 (или 65 536) символов, от &lt;code&gt;0x0000&lt;/code&gt; до &lt;code&gt;0xFFFF&lt;/code&gt; . Вскоре это оказалось неверным, и начиная с Unicode 2.0 (июль 1996 г.) Unicode был определен вплоть до 21 бита ( &lt;code&gt;0x10FFFF&lt;/code&gt; ), а Unicode 3.1 (март 2001 г.) определял первые символы выше &lt;code&gt;0xFFFF&lt;/code&gt; . Первые символы &lt;code&gt;0x10000&lt;/code&gt; называются</target>
        </trans-unit>
        <trans-unit id="235280477a8ab02cc7856eb55d9945ecaf55e478" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt;. This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt;), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt;. The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31ae8f51bc97ba41c3c0ff630526d3a83b94c44" translate="yes" xml:space="preserve">
          <source>When a &quot;=head1 ...&quot; directive is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824bf2e880285aa9c434d2acac5d910818e02e5d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SelectSaver&lt;/code&gt; is destroyed, it re-selects the file handle that was selected when it was created.</source>
          <target state="translated">Когда &lt;code&gt;SelectSaver&lt;/code&gt; уничтожается, он повторно выбирает дескриптор файла, который был выбран при его создании.</target>
        </trans-unit>
        <trans-unit id="47dccd0143522691a9547f34d1ed5af302d02e22" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;given&lt;/code&gt; statement is also a valid expression (for example, when it's the last statement of a block), it evaluates to:</source>
          <target state="translated">Когда &lt;code&gt;given&lt;/code&gt; оператор также является допустимым выражением (например, когда это последний оператор блока), он оценивается как:</target>
        </trans-unit>
        <trans-unit id="a06437bb92809b351f6a5100b5739a7e2454e5a6" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (&lt;code&gt;CvSLABBED&lt;/code&gt;), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and &lt;code&gt;CvROOT&lt;/code&gt; attached, it has finished its job, so it can forget the slab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af006e8d26663a7078cc20a1292be03a5256d66" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">Когда на плите CV есть ссылка (CvSLABBED),он отвечает за то,чтобы она была освобождена.(Следовательно,ни одно из двух резюме не должно иметь ссылок на одной и той же плите.)CV должно содержать ссылки только на плиту во время компиляции.После того,как оно скомпилировано и прикреплено CvROOT,оно завершило свою работу,так что может забыть о плите.</target>
        </trans-unit>
        <trans-unit id="5c03e144fe4a4613006ecf4b238cfa477e26c49c" translate="yes" xml:space="preserve">
          <source>When a DST change causes a locale clock to skip one hour forward, there will be an hour's worth of local times that don't exist. Again, for the &quot;Europe/Paris&quot; time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25 03:00:00.</source>
          <target state="translated">Когда изменение DST приводит к пропуску часов местного времени на один час вперед,будет час местного времени,которого не существует.Опять же,для часового пояса &quot;Европа/Париж&quot; местные часы перескочили с 2001-03-25 01:59:59 на 2001-03-25 03:00:00.</target>
        </trans-unit>
        <trans-unit id="711842f215653a7ad792c5b86c0dd5c2fc228aee" translate="yes" xml:space="preserve">
          <source>When a L&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34b3c17b138dcee1edbc75a046c702f3a8b9a07" translate="yes" xml:space="preserve">
          <source>When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it produces this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8b5f7b3a10fd426ef30c3ec83c6b8baa679be4" translate="yes" xml:space="preserve">
          <source>When a block is preceded by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;END&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, or &lt;code&gt;UNITCHECK&lt;/code&gt;, then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c769151f41d9f979bbea6aa6d7a29c398587207" translate="yes" xml:space="preserve">
          <source>When a block is preceding by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , or &lt;code&gt;UNITCHECK&lt;/code&gt; , then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">Когда блоку предшествует ключевое слово фазы компиляции, такое как &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; или &lt;code&gt;UNITCHECK&lt;/code&gt; , тогда блок будет выполняться только во время соответствующей фазы выполнения. Смотрите &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="7d61af89d14aac150579ea072baeedb77daecc0a" translate="yes" xml:space="preserve">
          <source>When a class has multiple parents, the method lookup order becomes more complicated.</source>
          <target state="translated">Когда у класса несколько родителей,порядок поиска метода усложняется.</target>
        </trans-unit>
        <trans-unit id="bbfabd64dc538b19e52659b29026ea44adaac5bb" translate="yes" xml:space="preserve">
          <source>When a class inherits from another class, any methods defined in the parent class are available to the child class. If you attempt to call a method on an object that isn't defined in its own class, Perl will also look for that method in any parent classes it may have.</source>
          <target state="translated">Когда класс наследует от другого класса,любые методы,определенные в родительском классе,доступны дочернему классу.Если вы попытаетесь вызвать метод на объекте,который не определен в его собственном классе,Perl также будет искать этот метод в любых классах-родителях,которые у него есть.</target>
        </trans-unit>
        <trans-unit id="3fbe037b656bddc24c2846062762f1fce297b32a" translate="yes" xml:space="preserve">
          <source>When a comma-separated list of subroutine names is given as options, Showlex prints the lexical variables used in those subroutines. Otherwise, it prints the file-scope lexicals in the file.</source>
          <target state="translated">Когда список имен подпрограмм,разделенных запятыми,задан в качестве опций,Showlex печатает лексические переменные,используемые в этих подпрограмм.В противном случае,он распечатывает лексику в файле.</target>
        </trans-unit>
        <trans-unit id="7150e31ab9e9cca66d69c6a47a4d5fc17ee83d01" translate="yes" xml:space="preserve">
          <source>When a constant is used in an expression, Perl replaces it with its value at compile time, and may then optimize the expression further. In particular, any code in an &lt;code&gt;if (CONSTANT)&lt;/code&gt; block will be optimized away if the constant is false.</source>
          <target state="translated">Когда в выражении используется константа, Perl заменяет ее своим значением во время компиляции и может затем оптимизировать выражение. В частности, любой код в блоке &lt;code&gt;if (CONSTANT)&lt;/code&gt; будет оптимизирован, если константа имеет значение false.</target>
        </trans-unit>
        <trans-unit id="ff12ac8ff6a9fb5ab965d82a8adb8da16c238288" translate="yes" xml:space="preserve">
          <source>When a context for a part of compile tree is known, it is propagated down through the tree. At this time the context can have 5 values (instead of 2 for runtime context): void, boolean, scalar, list, and lvalue. In contrast with the pass 1 this pass is processed from top to bottom: a node's context determines the context for its children.</source>
          <target state="translated">Когда известен контекст для части дерева компиляции,он распространяется вниз по дереву.В это время контекст может иметь 5 значений (вместо 2 для контекста исполнения):void,boolean,scalar,list и lvalue.В отличие от передачи 1,эта передача обрабатывается сверху вниз:контекст узла определяет контекст для своих дочерних элементов.</target>
        </trans-unit>
        <trans-unit id="d87717a8777688d74cabbb2304d94b51341cc91d" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt; . It expands into something like this:</source>
          <target state="translated">Когда основная функция вызывает другую, она должна передать контекст. Обычно это скрывается с помощью макросов. Рассмотрим &lt;code&gt;sv_setiv&lt;/code&gt; . Он расширяется примерно так:</target>
        </trans-unit>
        <trans-unit id="89bb7cb6afe2aeb318bc31219fdbcf9684114fa1" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt;. It expands into something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ceceb3dfac228f4dc1ea2316b05b14abb23395" translate="yes" xml:space="preserve">
          <source>When a dictionary is specified</source>
          <target state="translated">Когда указан словарь</target>
        </trans-unit>
        <trans-unit id="d409b69c538e75e300d571031fe6a755a4d085f3" translate="yes" xml:space="preserve">
          <source>When a distribution has already been tested by CPAN::Reporter on this machine, CPAN can skip the test phase and just rely on the test report history instead.</source>
          <target state="translated">Когда дистрибутив уже был протестирован CPAN::Reporter на этой машине,CPAN может пропустить фазу тестирования и вместо этого полагаться на историю тестовых отчетов.</target>
        </trans-unit>
        <trans-unit id="f71acc218a83c770a92fc1a815404b3d3de498a7" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin::is_binmount&lt;/a&gt;(). Perl provides a &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">Когда файл открывается, он находится в текстовом или двоичном режиме. В текстовом режиме файл подлежит переводам CR / LF / Ctrl-Z. В Cygwin режим по умолчанию для &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; определяется режимом монтирования, лежащего в основе файла. См. &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin :: is_binmount&lt;/a&gt; (). Perl предоставляет функцию &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; для установки двоичного режима для файлов, которые в противном случае обрабатывались бы как текст. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; с флагом &lt;code&gt;O_TEXT&lt;/code&gt; устанавливает текстовый режим для файлов, которые в противном случае обрабатывались бы как двоичные:</target>
        </trans-unit>
        <trans-unit id="77b5bb5939b31598184beb720f013a6b65e23bf1" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;open()&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3A%3Ais_binmount&quot;&gt;&quot;Cygwin::is_binmount&quot;&lt;/a&gt;(). Perl provides a &lt;code&gt;binmode()&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;sysopen()&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973bff9414f9daff4e8ac9353de5be029b42eafe" translate="yes" xml:space="preserve">
          <source>When a handle is so opened, then reads get bytes from the string value of</source>
          <target state="translated">Когда дескриптор открыт таким образом,то при чтении получаются байты из строкового значения параметра</target>
        </trans-unit>
        <trans-unit id="17e8d47075484fcb067bf9d5f01cdea7dd0c053a" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt; . The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">Когда обрабатывается ключевое слово, функция плагина должна построить дерево структур &lt;code&gt;OP&lt;/code&gt; , представляющее код, который был проанализирован. Корень дерева должен храниться в &lt;code&gt;*op_ptr&lt;/code&gt; . Затем функция возвращает константу, указывающую синтаксическую роль конструкции, которую она проанализировала: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; , если это полный оператор, или &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; , если это выражение. Обратите внимание, что конструкция оператора не может использоваться внутри выражения (кроме как с помощью &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; и т.п.), а выражение не является полным оператором (требуется как минимум завершающая точка с запятой).</target>
        </trans-unit>
        <trans-unit id="a9174fe1323f2a0785f91a3ab7751748b2c8cde0" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt;. The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;do BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79d667e2ee3be13474d3de61e4494ae38724c2" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt; , define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">Когда обрабатывается ключевое слово, функция плагина также может иметь (во время компиляции) побочные эффекты. Он может изменять &lt;code&gt;%^H&lt;/code&gt; , определять функции и так далее. Обычно, если побочные эффекты являются основной целью обработчика, он не хочет создавать какие-либо операции, которые будут включены в обычную компиляцию. В этом случае все еще требуется предоставить дерево операций, но достаточно сгенерировать одну нулевую операцию.</target>
        </trans-unit>
        <trans-unit id="96150c30b3160f65ac137db96b6444cc4c0b5dee" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt;, define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d37ded835c420c7b9a32e56975a37c7bb1fd7d" translate="yes" xml:space="preserve">
          <source>When a lexical var hasn't yet been introduced, it already exists from the perspective of duplicate declarations, but not for variable lookups, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ad4f96e4d1cfbd5bc9ad7761654ce09c743746" translate="yes" xml:space="preserve">
          <source>When a line is rendered, the correct format-spec is copied and scanned for the following items; data is substituted in, and other manipulations like basic indenting are done, for each opcode rendered.</source>
          <target state="translated">Когда строка отрисовывается,копируется и сканируется правильный формат-spec для следующих элементов;данные подставляются,и для каждого визуализированного опкода выполняются другие манипуляции,такие как основной отступ.</target>
        </trans-unit>
        <trans-unit id="a843fab343a403fdde443c4b37520ec7d2e838fc" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816633f303f39f0cbcf02a62fbc386a09fe865f3" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt;.</source>
          <target state="translated">Если сопоставление не удалось, и если другой глагол не участвовал в сбое сопоставления и не предоставил свое собственное имя для использования, переменная &lt;code&gt;$REGERROR&lt;/code&gt; будет установлена ​​на имя последнего выполненного &lt;code&gt;(*MARK:NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e6f28f32721a0addc83e91cf8c10e71bc456ee" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; that was involved in the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166223375f2bf3db19459da46d44df6881e6c346" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">При успешном &lt;code&gt;$REGMARK&lt;/code&gt; переменной $ REGMARK будет присвоено имя последнего выполненного &lt;code&gt;(*MARK:NAME)&lt;/code&gt; , которое участвовало в сопоставлении.</target>
        </trans-unit>
        <trans-unit id="4580d4e00986eec91e11abd53ea45f7e741116fe" translate="yes" xml:space="preserve">
          <source>When a module declares another one as a 'build_requires' prerequisite this means that the other module is only needed for building or testing the module but need not be installed permanently. In this case you may wish to install that other module nonetheless or just keep it in the 'build_dir' directory to have it available only temporarily. Installing saves time on future installations but makes the perl installation bigger.</source>
          <target state="translated">Когда модуль объявляет другой необходимым условием 'build_requires',это означает,что другой модуль необходим только для сборки или тестирования модуля,но не обязательно должен быть установлен на постоянной основе.В этом случае вы можете установить этот другой модуль или просто оставить его в каталоге 'build_dir',чтобы он был доступен только временно.Установка экономит время на последующих установках,но увеличивает размер установки perl.</target>
        </trans-unit>
        <trans-unit id="1496adc7bcbe4a50d48879cef9be976a3fb2e9c5" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principal, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</source>
          <target state="translated">Когда кодируется новый язык, Unicode обычно выбирает &lt;code&gt;block&lt;/code&gt; из последовательных нераспределенных кодовых точек для своих символов. До сих пор количество кодовых точек в этих блоках всегда делилось на 16. Дополнительные элементы в блоке, которые в настоящее время не нужны, оставались нераспределенными для будущего роста. Но были случаи, когда для более позднего выпуска требовалось больше кодовых точек, чем доступных дополнительных функций, и новый блок приходилось выделять где-то еще, не смежно с исходным, для обработки переполнения. Таким образом, с самого начала стало очевидно, что &amp;laquo;блок&amp;raquo; не является адекватным организующим принципом, и поэтому было создано свойство &lt;code&gt;Script&lt;/code&gt; . (Позже было добавлено улучшенное свойство скрипта, &lt;code&gt;Script_Extensions&lt;/code&gt; свойство.) Те кодовые точки, которые находятся в блоках переполнения, могут по-прежнему иметь тот же сценарий, что и исходные. Концепция письма больше соответствует естественному языку: есть &lt;code&gt;Latin&lt;/code&gt; шрифт, &lt;code&gt;Greek&lt;/code&gt; шрифт и так далее; и есть несколько искусственных сценариев, например &lt;code&gt;Common&lt;/code&gt; для символов, которые используются в нескольких сценариях, например математических символов. Скрипты обычно охватывают различные части нескольких блоков. Дополнительные сведения о сценариях см. В разделе &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Сценарии в perlunicode.&lt;/a&gt;. Разделение на блоки существует, но оно почти полностью случайно - артефакт того, как были и как распределяются персонажи. (Обратите внимание, что этот абзац слишком упрощен для того, чтобы это было введение. Unicode на самом деле не кодирует языки, но системы письма для них - их сценарии; и один сценарий может использоваться многими языками. Unicode также кодирует вещи это не совсем языки, такие как символы вроде &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="f7bd752f648e1f1f371051489dc3b8a7639c7fc7" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principle, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbe3c04751e10d9bc078e9c200bbf898654f3d9" translate="yes" xml:space="preserve">
          <source>When a package is compiled, a line like this</source>
          <target state="translated">Когда пакет скомпилирован,такая строчка</target>
        </trans-unit>
        <trans-unit id="93bffad6a970da997c7854ebcbcae55a405a4802" translate="yes" xml:space="preserve">
          <source>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;PL_origalen&lt;/code&gt; before perl_parse() is called.</source>
          <target state="translated">Когда сценарий perl присваивает значение $ 0, среда выполнения perl попытается отобразить это значение как имя программы, указанное в &amp;laquo;ps&amp;raquo;, обновив память, на которую указывает argv, переданный в perl_parse (), а также вызовя такие функции API, как setproctitle (), если доступно. Такое поведение может быть неприемлемым при внедрении perl и может быть отключено путем присвоения значения &lt;code&gt;1&lt;/code&gt; переменной &lt;code&gt;PL_origalen&lt;/code&gt; перед вызовом perl_parse ().</target>
        </trans-unit>
        <trans-unit id="5dd94d34aa40052479abfe68a7305a1776af1c6b" translate="yes" xml:space="preserve">
          <source>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</source>
          <target state="translated">Когда регеxp может соответствовать строке несколькими различными способами,мы можем использовать принципы,описанные выше,чтобы предсказать,каким способом регеxp будет соответствовать:</target>
        </trans-unit>
        <trans-unit id="5e93e818427f981a20b5cd3c2cdc058e4ee5f4c1" translate="yes" xml:space="preserve">
          <source>When a regexp is compiled, its &lt;code&gt;engine&lt;/code&gt; field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</source>
          <target state="translated">Когда регулярное выражение компилируется, его поле &lt;code&gt;engine&lt;/code&gt; затем устанавливается так, чтобы указывать на соответствующую структуру, так что, когда его нужно использовать, Perl может найти для этого подходящие процедуры.</target>
        </trans-unit>
        <trans-unit id="1ee520116426a3c213440cc6f7664ca3ad684e60" translate="yes" xml:space="preserve">
          <source>When a signal is delivered (e.g., SIGINT from a control-C) the operating system breaks into IO operations like</source>
          <target state="translated">При подаче сигнала (например,SIGINT от контроллера C)операционная система прерывает операции ввода-вывода,такие как</target>
        </trans-unit>
        <trans-unit id="232c6b5f6274d23859408b92a2808f3fc59dd734" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, a plus sign is used to prefix a positive number.</source>
          <target state="translated">Когда в качестве флагов одновременно указаны пробел и знак плюс,знак плюс используется для префиксации положительного числа.</target>
        </trans-unit>
        <trans-unit id="545ab55cd7ca990a06b2c4cf5e80c654c6ee269f" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, the space is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74001a7284f9d1373e15b508cdd1efa8fda60fc2" translate="yes" xml:space="preserve">
          <source>When a user-defined subroutine is wrapped by &lt;code&gt;autodie&lt;/code&gt;, it will use hints if they are available, and otherwise reverts to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3497a2701b51a3e1bca0e706937a383957b3a809" translate="yes" xml:space="preserve">
          <source>When a value is returned from a thread through a &lt;code&gt;join&lt;/code&gt; operation, the value and everything that it references is copied across to the joining thread, in much the same way that values are copied upon thread creation. This works fine for most kinds of value, including arrays, hashes, and subroutines. The copying recurses through array elements, reference scalars, variables closed over by subroutines, and other kinds of reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c0062970171773b2800c4b96cf35e1d153d560" translate="yes" xml:space="preserve">
          <source>When a variable is tied, it is associated with the object which is the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This object normally has only one reference, namely, the implicit reference from the tied variable. When untie() is called, that reference is destroyed. Then, as in the first example above, the object's destructor (DESTROY) is called, which is normal for objects that have no more valid references; and thus the file is closed.</source>
          <target state="translated">Когда переменная связана,она ассоциируется с объектом,который является возвращаемым значением функции TIESCALAR,TIEARRAY или TIEHASH.Обычно этот объект имеет только одну ссылку,а именно,неявную ссылку на связанную переменную.При вызове функции untie()эта ссылка уничтожается.Затем,как и в первом примере выше,вызывается деструктор объекта (DESTROY),что нормально для объектов,не имеющих больше действительных ссылок;таким образом,файл закрывается.</target>
        </trans-unit>
        <trans-unit id="4c087ed039f3d9aacb0c9c7c411e1eafe86f0a03" translate="yes" xml:space="preserve">
          <source>When a weak reference is stored in an &lt;code&gt;SV&lt;/code&gt; that has &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic is called after the reference has gone stale. This hook can be used to trigger further garbage-collection activities associated with the referenced object.</source>
          <target state="translated">Когда слабая ссылка сохраняется в &lt;code&gt;SV&lt;/code&gt; , имеющем &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic вызывается после того, как ссылка устарела. Эту ловушку можно использовать для запуска дальнейших действий по сборке мусора, связанных с указанным объектом.</target>
        </trans-unit>
        <trans-unit id="9a9840147d7f095037a163c370bf370a7676a796" translate="yes" xml:space="preserve">
          <source>When all parsers are exhausted an empty list will be returned.</source>
          <target state="translated">Когда все парсеры будут исчерпаны,будет возвращен пустой список.</target>
        </trans-unit>
        <trans-unit id="4475cbc9efc3f925a7d535afa9908fb989684e90" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a bulleted list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ffe1c99de4f1b7f522c65bdd9eecb591a526c" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a numbered list, it will produce this event structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9420e774841a86eb3869701949ed03c728fe1309" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; enabled function fails, it generates an &lt;code&gt;autodie::exception&lt;/code&gt; object. This can be interrogated to determine further information about the error that occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58a9a2162a7d9db701502c02549ae6467f05b83" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt; , its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">Когда массив или срез массива интерполируются в строку с двойными кавычками или аналогичный контекст, такой как &lt;code&gt;/.../&lt;/code&gt; , его элементы разделяются этим значением. По умолчанию это пробел. Например, это:</target>
        </trans-unit>
        <trans-unit id="1cef7d16c561803c2f66d1c8d9b2d86bf2638f56" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt;, its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ada78738410600725bc97a1fe2d577a540f0ef9" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e576a7aca6fc0d7ad26c29db1ef25b646d312e24" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">Когда список атрибутов присутствует в объявлении, выполняется проверка, присутствует ли обработчик 'изменения' атрибута в соответствующем пакете (или его дереве наследования @ISA). Точно так же, когда &lt;code&gt;attributes::get&lt;/code&gt; вызывается для действительной ссылки, выполняется проверка соответствующего обработчика атрибута 'fetch'. См. &lt;a href=&quot;#EXAMPLES&quot;&gt;ПРИМЕРЫ,&lt;/a&gt; чтобы увидеть, как работает определение &amp;laquo;подходящий пакет&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8cddb5e14177fc6acd8b55e0252f21e912b7951c" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is read, the locations to which</source>
          <target state="translated">Когда элемент &lt;code&gt;%ENV&lt;/code&gt; считывается, местоположения, в которые</target>
        </trans-unit>
        <trans-unit id="0687a40bbb86ac6f75e3c72f51434b562de688d3" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">Когда элемент &lt;code&gt;%ENV&lt;/code&gt; установлен в &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , элемент просматривается, как если бы он читался, и, если он найден, он удаляется. (Пункт &amp;laquo;удален&amp;raquo; из CRTL &lt;code&gt;environ&lt;/code&gt; массив устанавливается в пустую строку.) С помощью &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; , чтобы удалить элемент из &lt;code&gt;%ENV&lt;/code&gt; имеет такой же эффект, но после того , как элемент будет удален, другая попытка искать элемент, поэтому логическое имя внутреннего режима или имя в другом месте заменит только что удаленное логическое имя. В любом случае изменяется только первое значение, найденное при поиске PERL_ENV_TABLES. В настоящее время невозможно определить логическое имя списка поиска через% ENV.</target>
        </trans-unit>
        <trans-unit id="0c072f9ffbeb43d95b6bbc690c50b27ac90e561f" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;undef&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;delete&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d5e830d380d586cadba3ebb3b0b5993def5162" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to a defined string, the corresponding definition is made in the location to which the first translation of</source>
          <target state="translated">Когда элемент &lt;code&gt;%ENV&lt;/code&gt; установлен в определенную строку, соответствующее определение выполняется в том месте, в которое выполняется первый перевод</target>
        </trans-unit>
        <trans-unit id="6e4667405eb0016e589d7ee3b3978551b835b138" translate="yes" xml:space="preserve">
          <source>When an install fails for some reason and then I correct the error condition and retry, CPAN.pm refuses to install the module, saying &lt;code&gt;Already tried without success&lt;/code&gt; .</source>
          <target state="translated">Когда установка по какой-либо причине завершается неудачно, а затем я исправляю состояние ошибки и повторяю попытку, CPAN.pm отказывается устанавливать модуль, сообщая, что &lt;code&gt;Already tried without success&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b449cc559ca252d850238032174c7042fa310e" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">Когда неопределенный слой 'foo' встречается в спецификации &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; уровня, код C выполняет эквивалент:</target>
        </trans-unit>
        <trans-unit id="40fb6d5dfd2c6aa613f88a6e49dba73d8dca4cc3" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;binmode&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05eb98d8070a762d6a7fd65d464d57e96f47f0ef" translate="yes" xml:space="preserve">
          <source>When an updir path like &quot;:::lib::&quot; is passed as argument, the number of directories to climb up is handled correctly, not removing leading or trailing colons when necessary. E.g.</source>
          <target state="translated">Когда в качестве аргумента передается путь обновления типа &quot;:::lib:&quot;,количество каталогов для подъема обрабатывается корректно,не удаляя лидирующие или трейлинговые двоеточия,когда это необходимо.Например</target>
        </trans-unit>
        <trans-unit id="fc030f96c1c92f54f8dacedeb177bdbc127fdac6" translate="yes" xml:space="preserve">
          <source>When an uppercase and lowercase letter both exist in the table, then the uppercase letter is typically used to represent some kind of composite type (a list or a hash), and the lowercase letter is used to represent an element of that composite type. Some internals code makes use of this case relationship. However, 'v' and 'V' (vec and v-string) are in no way related.</source>
          <target state="translated">Если в таблице присутствуют и прописная,и строчная буквы,то прописная буква обычно используется для обозначения составного типа (списка или хэша),а строчная буква используется для обозначения элемента этого составного типа.Некоторые внутренние коды используют это соотношение регистров.Однако,'v' и 'V' (vec и v-строка)никак не связаны между собой.</target>
        </trans-unit>
        <trans-unit id="34009ee0cae148f2a1680a702fb847661476a204" translate="yes" xml:space="preserve">
          <source>When and whether to use small caps is somewhat tricky, and Pod::Man doesn't necessarily get it right.</source>
          <target state="translated">Когда и использовать ли маленькие колпачки-это довольно сложно,и Pod::Man не всегда понимает это правильно.</target>
        </trans-unit>
        <trans-unit id="50a0e6b3c1e9721563cfa37763282c6acaf8fe8f" translate="yes" xml:space="preserve">
          <source>When applied to the following command line:</source>
          <target state="translated">При применении к следующей командной строке:</target>
        </trans-unit>
        <trans-unit id="a01d1e59657f16ebb14cc78dbc769393ad07bd40" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for lzma_alone content using the &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; module.</source>
          <target state="translated">При автоматическом обнаружении сжатого формата попробуйте проверить содержимое lzma_alone с помощью модуля &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3afc2592b2e6769a24dccd537ec52009da2c39f6" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for raw-deflate (RFC 1951) content using the &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; module.</source>
          <target state="translated">При автоматическом обнаружении сжатого формата попробуйте протестировать содержимое raw-deflate (RFC 1951) с помощью модуля &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2cde96752e55bde69311a35423f2dcc59f8d7b" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, this option can be used to turn on verbosity during the selection process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884ba24d0a86a83e3adb2e1fb93cb3394961f06" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, turn on the use of the external ping via Net::Ping::External. This is recommended in the case the local network has a transparent proxy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fe69040aadcae108c71d87a32f8d5b0102ff6a" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c4b6b6311800f4181591dd698a41134ea1ef8b" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string, i.e., the regexp matches the whole string. Consider</source>
          <target state="translated">Когда одновременно используются &lt;code&gt;^&lt;/code&gt; и &lt;code&gt;$&lt;/code&gt; , регулярное выражение должно совпадать как с началом, так и с концом строки, т. Е. Регулярное выражение соответствует всей строке. Рассматривать</target>
        </trans-unit>
        <trans-unit id="0058d0939f56e0836aecac00731cc26dae5c908c" translate="yes" xml:space="preserve">
          <source>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</source>
          <target state="translated">Когда и A,и P не определены,это используется как запасная точность при делении чисел.</target>
        </trans-unit>
        <trans-unit id="060766cfa822ddf97bd7bc65f3fc7e729b274423" translate="yes" xml:space="preserve">
          <source>When building 64-bit modules, it is your responsibility to ensure that linked external libraries and frameworks provide 64-bit support: if they do not, module building may appear to succeed, but attempts to use the module will result in run-time dynamic linking errors, and subsequent test failures. You can use &lt;code&gt;file&lt;/code&gt; to discover the architectures supported by a library:</source>
          <target state="translated">При создании 64-битных модулей вы несете ответственность за обеспечение поддержки 64-битных связанных внешних библиотек и фреймворков: в противном случае сборка модуля может показаться успешной, но попытки использовать модуль приведут к динамическому выполнению. ошибки связывания и последующие сбои тестов. Вы можете использовать &lt;code&gt;file&lt;/code&gt; для определения архитектур, поддерживаемых библиотекой:</target>
        </trans-unit>
        <trans-unit id="d21008e482052b445cfd243ad8bc31adfd3249b5" translate="yes" xml:space="preserve">
          <source>When building Perl it will always return true, as nothing is installed yet.</source>
          <target state="translated">При создании Perl он всегда будет возвращаться к истинному состоянию,так как еще ничего не установлено.</target>
        </trans-unit>
        <trans-unit id="aaf49b07a212f715b8dd8f309b5c78af1bf1e342" translate="yes" xml:space="preserve">
          <source>When built on an ODS-5 volume with symbolic links enabled, Perl by default supports symbolic links when the requisite support is available in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are a number of limitations and caveats to be aware of when working with symbolic links on VMS. Most notably, the target of a valid symbolic link must be expressed as a Unix-style path and it must exist on a volume visible from your POSIX root (see the &lt;code&gt;SHOW ROOT&lt;/code&gt; command in DCL help). For further details on symbolic link capabilities and requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3 or later.</source>
          <target state="translated">При построении на томе ODS-5 с включенными символическими ссылками Perl по умолчанию поддерживает символические ссылки, когда необходимая поддержка доступна в файловой системе и CRTL (обычно 64-битный OpenVMS v8.3 и новее). При работе с символическими ссылками в VMS необходимо учитывать ряд ограничений и предостережений. В частности, цель действительной символической ссылки должна быть выражена как путь в стиле Unix, и она должна существовать на томе, видимом из вашего корня POSIX (см. &lt;code&gt;SHOW ROOT&lt;/code&gt; в справке DCL). Дополнительные сведения о возможностях и требованиях к символическим ссылкам см. В главе 12 руководства CRTL, которое поставляется с OpenVMS v8.3 или новее.</target>
        </trans-unit>
        <trans-unit id="3274ae41eb972b48380cd0be38746ee76dc6d9df" translate="yes" xml:space="preserve">
          <source>When bundling is in effect, case is ignored on single-character options also.</source>
          <target state="translated">Когда пакет действует,регистр игнорируется и на односимвольных опциях.</target>
        </trans-unit>
        <trans-unit id="534230020f5629c55b27da34563c08514a84a5c7" translate="yes" xml:space="preserve">
          <source>When calculating specific times, such as for tests in time or date modules, it may be appropriate to calculate an offset for the epoch.</source>
          <target state="translated">При расчете определенного времени,например,для тестов в модулях времени или даты,может быть целесообразным рассчитать смещение для эпохи.</target>
        </trans-unit>
        <trans-unit id="9da2af35b4e027fcb57324a97e158a9219d7749d" translate="yes" xml:space="preserve">
          <source>When called from a thread, this behaves like &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (i.e., the exit status code is ignored).</source>
          <target state="translated">При вызове из потока это ведет себя как &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (т.е. код состояния выхода игнорируется).</target>
        </trans-unit>
        <trans-unit id="9c8531e379ee34158f961b216941a888acd13144" translate="yes" xml:space="preserve">
          <source>When called from the</source>
          <target state="translated">Когда звонят из</target>
        </trans-unit>
        <trans-unit id="43350391a792d394d51fbfdf3323ff9bf611b150" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtod&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">При вызове в скалярном контексте &lt;code&gt;strtod&lt;/code&gt; возвращает проанализированное число.</target>
        </trans-unit>
        <trans-unit id="da1211ed8e0b63c4bc2cdd7832083442b210dfa8" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtol&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">При вызове в скалярном контексте &lt;code&gt;strtol&lt;/code&gt; возвращает проанализированное число.</target>
        </trans-unit>
        <trans-unit id="cd23c4a922c775b095b3cd879f0e839934775a17" translate="yes" xml:space="preserve">
          <source>When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling mkstemp() after constructing a suitable template.</source>
          <target state="translated">При вызове в контексте списка возвращается ручка к открытому файлу и имя файла.Это достигается путем вызова mkstemp()после построения подходящего шаблона.</target>
        </trans-unit>
        <trans-unit id="c3dee4680a21f3b47b4b6c94d86c7920c11b3ca5" translate="yes" xml:space="preserve">
          <source>When called in scalar context, returns the full name (including path) of a temporary file (uses mktemp()). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.</source>
          <target state="translated">При вызове в скалярном контексте возвращает полное имя (включая путь)временного файла (использует mktemp()).Единственная проверка-это то,что файл еще не существует,но нет гарантии,что это условие будет продолжаться.</target>
        </trans-unit>
        <trans-unit id="a89727e96b1fd47a54daec87adf9ead3599db8aa" translate="yes" xml:space="preserve">
          <source>When called on a hash in list context, returns a 2-element list consisting of the key and value for the next element of a hash. In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. When called in scalar context, returns only the key (not the value) in a hash, or the index in an array.</source>
          <target state="translated">При вызове хэша в контексте списка возвращает 2-элементный список,состоящий из ключа и значения для следующего элемента хэша.Только в Perl 5.12 и более поздних вернётся также индекс и значение для следующего элемента массива,так что вы можете провести по нему итерацию;старые Perls считают это синтаксической ошибкой.При вызове в скалярном контексте возвращается только ключ (не значение)в хэше или индекс в массиве.</target>
        </trans-unit>
        <trans-unit id="a0114581d0437322ee0322acd573e8db3818a675" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to $port_number rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;code&gt;ping()&lt;/code&gt; will connect to.</source>
          <target state="translated">При вызове с номером порта номер порта, используемый для проверки связи, устанавливается на $ port_number вместо использования порта эха. Он также имеет эффект вызова &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; заставляя ping возвращать успешный ответ только в том случае, если этот конкретный порт доступен. Эта функция возвращает значение порта, к которому будет подключаться &lt;code&gt;ping()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb2e5aa5eca539163667dc50950bd9be7faf4a0e" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to &lt;code&gt;$port_number&lt;/code&gt; rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; will connect to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e732b0f6b3939ab5bc51276cb4115c5f3c0e3c" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">При вызове со свойством, которое является расширением Perl, которое не может быть выражено в составной форме, эта функция в настоящее время возвращает &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , так как единственными двумя возможными значениями являются</target>
        </trans-unit>
        <trans-unit id="2e2733df3349090a28007f289ac824ddf07cc93b" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;undef&lt;/code&gt;, as the only two possible values are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f088f6cc700d00236d5621c430de681ccc4d48" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt; , one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">При вызове &lt;code&gt;Mksymlists&lt;/code&gt; всегда нужно указывать атрибут NAME. В большинстве случаев это все, что нужно. Однако в случае необычных расширений другие атрибуты могут использоваться для предоставления дополнительной информации компоновщику.</target>
        </trans-unit>
        <trans-unit id="07b982cff05e80c95f9bd4378e83247343baa2a1" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt;, one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af437b4f9240cadad3ac33b8f68ddc8397121022" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;open&lt;/code&gt; with three or more arguments, the second argument -- labeled MODE here -- defines the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb764d0e74f6cde0aeec88532fcd886bfa4b9853" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">При выборе языка на вас также должны влиять &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;ресурсы&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;культура тестирования&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;сообщество,&lt;/a&gt; которое его окружает.</target>
        </trans-unit>
        <trans-unit id="951b540f9fcad327b03714e446667ac4225ce0b0" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://www.cpan.org/&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://www.perl.org/community.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fc2ee6241766189106d0612895f0d6c35cb4ac" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">При выборе новой соли создайте случайную двухсимвольную строку, символы которой берутся из набора &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (например, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). Этот набор символов является всего лишь рекомендацией; символы, разрешенные в соли, зависят исключительно от библиотеки crypt вашей системы, и Perl не может ограничить то, какие соли принимает &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">При выборе новой соли создайте случайную двухсимвольную строку, символы которой берутся из набора &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (например, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). Этот набор символов является всего лишь рекомендацией; символы, разрешенные в соли, зависят исключительно от библиотеки crypt вашей системы, и Perl не может ограничить то, какие соли принимает &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e49bb7c565d73664ea0f3cf904e4a0b82673adbe" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&lt;/code&gt;). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; accepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45013cd9275f891a2dc688887309ce7d0907108" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple assignment to &lt;code&gt;state&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt;) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of assignment to &lt;code&gt;state&lt;/code&gt; declarations where the left hand side of the assignment involves any parentheses is currently undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">В сочетании с объявлением переменной простое скалярное присвоение переменным &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; (как в &lt;code&gt;state $x = 42&lt;/code&gt; ) выполняется только в первый раз. Когда такие операторы оцениваются последующие раз, присвоение игнорируется. Поведение такого типа присваивания нескалярным переменным не определено.</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">При сравнении &lt;code&gt;$]&lt;/code&gt; &lt;b&gt;настоятельно рекомендуется использовать&lt;/b&gt; операторы сравнения строк . Присущие двоичному представлению с плавающей запятой ограничения иногда могут приводить к неправильным сравнениям некоторых чисел на некоторых архитектурах.</target>
        </trans-unit>
        <trans-unit id="d63ec10981e83d5b4bca0c38c0d5eae2039c39d3" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt;, numeric comparison operators should be used, but the variable should be stringified first to avoid issues where its original numeric value is inaccurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65db1f7efa45a9d6174eb5b40e9d8d8f3e843e34" translate="yes" xml:space="preserve">
          <source>When compiled within the scope of &lt;code&gt;use locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier), this construct assumes that the execution-time locale will be a UTF-8 one, and the generated pattern always uses Unicode rules. What gets matched or not thus isn't dependent on the actual runtime locale, so tainting is not enabled. But a &lt;code&gt;locale&lt;/code&gt; category warning is raised if the runtime locale turns out to not be UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">При компиляции Perl в Tru64 можно (в зависимости от версии компилятора)увидеть два таких предупреждения</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">При компиляции Perl необходимо использовать компилятор ANSI C.AIX не поставляет ANSI совместимый компилятор C с AIX по умолчанию,но бинарные сборки gcc для AIX широко доступны.Версия gcc также включена в AIX Toolbox,который поставляется с AIX.</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">При компиляции Perl необходимо использовать компилятор ANSI C.AIX не поставляет ANSI совместимый C-компилятор с AIX по умолчанию,но бинарные сборки gcc для AIX широко доступны.</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">При компиляции Perl вы должны использовать компилятор ANSI C. Компилятор C, поставляемый со всеми системами HP-UX, является компилятором K&amp;amp;R, который следует использовать только для сборки новых ядер.</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">При компиляции в PASE нет команды &quot;oslevel&quot;.Поэтому вы можете создать скрипт под названием &quot;oslevel&quot;,повторяющий уровень AIX,поддерживаемый вашей версией PASE.Если вы не уверены,обратитесь к документации или используйте &quot;4.3.3.0&quot;.</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">При дополнении строк, если все символы имеют порядковые значения меньше 256, их дополнения также будут. Но если они этого не сделают, все символы будут либо в 32-, либо в 64-битных дополнениях, в зависимости от вашей архитектуры. Так, например, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; - это &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; на 32-битных машинах и &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; на 64-битных машинах.</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">При настройке для комплектации опции с одной символикой чувствительны к регистру,в то время как опции с длинной символикой не чувствительны к регистру.Чтобы односимвольные опции также не чувствительны к регистру,используйте их:</target>
        </trans-unit>
        <trans-unit id="0832ec483e29be38d2d70bb452597a0c3e196f7f" translate="yes" xml:space="preserve">
          <source>When converting POD source from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">При создании и расширении прикладных программных интерфейсов (API)для Symbian или Серии 60 или Серии 80 или Серии 90 рекомендуется не использовать в названиях API товарные знаки,зарегистрированные товарные знаки или торговые наименования.Вместо этого разработчикам следует рассмотреть возможность основывать API-именование на существующем (C++,или,возможно,Java)общедоступном компоненте и API-именование,модифицированное в соответствии с правилами языка программирования,для которого предназначены новые API.</target>
        </trans-unit>
        <trans-unit id="6e1a716be153bacd455cdea13693b585d200816e" translate="yes" xml:space="preserve">
          <source>When data are cleaned and standardized, missing or invalid fields will be replaced with sensible defaults when possible. This may be lossy or imprecise. For example, some badly structured META.yml files on CPAN have prerequisite modules listed as both keys and values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">При работе со структурами C следует выбрать &lt;b&gt;T_PTROBJ&lt;/b&gt; или &lt;b&gt;T_PTRREF&lt;/b&gt; для типа XS. Оба типа предназначены для обработки указателей на сложные объекты. Тип T_PTRREF позволит объекту Perl не иметь благословения, в то время как тип T_PTROBJ требует, чтобы объект был благословлен. Используя T_PTROBJ, можно добиться определенной формы проверки типов, потому что XSUB будет пытаться проверить, что объект Perl имеет ожидаемый тип.</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">При работе с двоичными файлами (или текстовыми файлами в двоичном режиме) не забудьте явно установить $ / на соответствующее значение для вашего формата файла перед использованием &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2eed87ac3725b6497a344941a7436efeb6e56a3" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; to the appropriate value for your file format before using &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">Работая со ссылками, важно обращаться с ними осторожно. Блок &lt;code&gt;INIT:&lt;/code&gt; сначала вызывает SvGETMAGIC (пути), если paths является связанной переменной. Затем он проверяет, что &lt;code&gt;SvROK&lt;/code&gt; возвращает true, что указывает на то, что paths является допустимой ссылкой. (Простая проверка &lt;code&gt;SvROK&lt;/code&gt; не приведет к запуску FETCH для связанной переменной.) Затем он проверяет, что объект, на который ссылаются пути, является массивом, используя &lt;code&gt;SvRV&lt;/code&gt; для разыменования путей и &lt;code&gt;SvTYPE&lt;/code&gt; для определения его типа. В качестве дополнительного теста он проверяет, что массив, на который ссылаются пути, непустой, используя &lt;code&gt;av_top_index&lt;/code&gt; функция (которая возвращает -1, если массив пуст). Макрос XSRETURN_UNDEF используется для прерывания XSUB и возврата неопределенного значения, если все три из этих условий не выполняются.</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">При работе со строками, содержащими символы, которые не могут быть представлены с помощью восьмибитного набора символов, perl использует внутреннее представление, которое является разрешающей версией кодировки Unicode UTF-8 [2]. При этом используются одиночные байты для представления символов из набора символов ASCII и последовательности из двух или более байтов для всех остальных символов. (См. &lt;a href=&quot;perlunitut&quot;&gt;Perlunitut&lt;/a&gt; для получения дополнительной информации о взаимосвязи между UTF-8 и кодировкой perl, utf8. Разница не важна для этого обсуждения.)</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">При отладке скрипта, использующего #! и, таким образом, обычно находится в $ PATH, опция -S заставляет perl искать его в $ PATH, поэтому вам не нужно вводить путь или имя &lt;code&gt;which $scriptname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="defb50e120fb7902c1ad7735f710efb52d461bf8" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c091d3205ab1a4db30cd1f652d642a63585b86ed" translate="yes" xml:space="preserve">
          <source>When defined, remove the legacy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd1aac87a1a4ead57eced3127ad85f26b16823a" translate="yes" xml:space="preserve">
          <source>When defining hints, you can either supply both &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;scalar&lt;/code&gt; keywords,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">При определении нескольких констант нельзя использовать значения других констант,определенных в том же объявлении.Это происходит потому,что вызывающий пакет не знает ни о каких константах внутри этой группы до тех пор,пока</target>
        </trans-unit>
        <trans-unit id="ffb15fb0d6730c3726c9bf86322c62258c95b95a" translate="yes" xml:space="preserve">
          <source>When deleting a definition, this bit causes each &lt;code&gt;$sTargetPath&lt;/code&gt; to be compared to the full-length definition when searching for the most recently added match. If this bit is not set, then &lt;code&gt;$sTargetPath&lt;/code&gt; only needs to match a prefix of the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5777270f296102b587f7b9de510c0b0ddda1bbd9" translate="yes" xml:space="preserve">
          <source>When describing the merge commit, explain the purpose of the branch, and keep in mind that this description will probably be used by the eventual release engineer when reviewing the next perldelta document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9045da0fde8e0464c72a9687c675b21416ee8e" translate="yes" xml:space="preserve">
          <source>When designing Maketext, I chose to plan its main features in terms of &quot;buzzword compliance&quot;. And here are the buzzwords:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">При разработке интерфейса между Perl и библиотекой C часто бывает достаточно прямого перевода с C на XS (например, созданного с помощью &lt;code&gt;h2xs -x&lt;/code&gt; ). Однако иногда интерфейс будет выглядеть очень похожим на C, а иногда и не интуитивно понятным, особенно когда функция C изменяет один из своих параметров или возвращает ошибку внутри диапазона (например, &amp;laquo;отрицательные возвращаемые значения означают отказ&amp;raquo;). В случаях, когда программист желает создать интерфейс, более похожий на Perl, следующая стратегия может помочь определить наиболее важные части интерфейса.</target>
        </trans-unit>
        <trans-unit id="aa2910d5c8edb2a11952d853cabc19faa12f6ab8" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt;) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">При разработке интерактивных и/или потенциально долговременных приложений лучше поддерживать постоянный интерпретатор,чем многократно выделять и конструировать новый интерпретатор.Основной причиной является скорость:так как Perl будет загружаться в память только один раз.</target>
        </trans-unit>
        <trans-unit id="fbc30eeb77b449fcef99048d57b0caf5a9160153" translate="yes" xml:space="preserve">
          <source>When do I use SKIP vs. TODO?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">При программировании на XS/Symbian C++сначала включаются заголовки Symbian,затем любые стандартные заголовки C/POSIX,затем заголовки Perl и,наконец,любые заголовки приложений.</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">При загрузке с CPAN сохраняйте файл с расширением &lt;code&gt;.tgz&lt;/code&gt; вместо &lt;code&gt;.tar.gz&lt;/code&gt; . Все остальные точки в имени файла следует заменить подчеркиванием. Например, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; следует загрузить как &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">Когда Perl вызывает каждый фильтр, локальная копия &lt;code&gt;$_&lt;/code&gt; будет содержать ключ или значение, которое нужно отфильтровать. Фильтрация достигается путем изменения содержимого &lt;code&gt;$_&lt;/code&gt; . Код возврата из фильтра игнорируется.</target>
        </trans-unit>
        <trans-unit id="37bc6f2fee508f42f859a937c741e1314dc47c4d" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt;. The return code from the filter is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">При квантификации встроенного кода,успешные совпадения будут вызывать код один раз для каждой соответствующей итерации квантификатора.Например:</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">При оценке typeglob создает скалярное значение, которое представляет все объекты с этим именем, включая любой дескриптор файла, формат или подпрограмму. При назначении он заставляет указанное имя ссылаться на любое &lt;code&gt;*&lt;/code&gt; значение, которое ему было присвоено. Пример:</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">При вызове функции exec()внутри псевдо-процесса методы DESTROY и блоки END все равно будут вызываться после возврата внешнего процесса.</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">Когда выполнение программы достигает вызова подпрограммы, вызов &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="e34ca66c0a813d790613eb9e5cc3ba8d52f5c3fa" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt;(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">Когда выполнение программы использует &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; для входа в подпрограмму, отличную от XS, и бит 0x80 установлен в &lt;code&gt;$^P&lt;/code&gt; , выполняется вызов &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; , при этом &lt;code&gt;$DB::sub&lt;/code&gt; содержит имя вводимой подпрограммы.</target>
        </trans-unit>
        <trans-unit id="46697cf78f9bb3bd5dc8972ced50ec3e3d6c90ea" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;goto&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt;, a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; set to identify the subroutine being entered. The call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; does not replace the &lt;code&gt;goto&lt;/code&gt;; the requested subroutine will still be entered once &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; has returned. &lt;code&gt;$DB::sub&lt;/code&gt; normally holds the name of the subroutine being entered, if it has one. Failing that, &lt;code&gt;$DB::sub&lt;/code&gt; will hold a reference to the subroutine being entered. Unlike when &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is called, it is not guaranteed that &lt;code&gt;$DB::sub&lt;/code&gt; can be used as a reference to operate on the subroutine being entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">Когда выходной код ненулевой,появляется окно с сообщением,в противном случае консоль закрывается,так что вам,возможно,придется поймать выход со статусом 0 в вашей программе,чтобы увидеть любой выход.</target>
        </trans-unit>
        <trans-unit id="6f3c5ccbe8b2049e627d85f2a9ec69ec19650c45" translate="yes" xml:space="preserve">
          <source>When false the information is not considered critical and may not be rendered in less-verbose modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">Когда используются хэши полей, основная структура остается той же. Каждый лексический хеш будет сделан хешем поля. Вызов &lt;code&gt;refaddr&lt;/code&gt; можно опустить в методах доступа. Методы DESTROY и CLONE не нужны.</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">При нахождении программы для запуска Perl сначала просит ОС искать исполняемые файлы в &lt;code&gt;PATH&lt;/code&gt; (OS / 2 добавляет расширение</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">По завершении &lt;code&gt;$input&lt;/code&gt; будет полностью обработан (при условии, что ошибок не было). Если дефляция прошла успешно, она записывает дефлированные данные в &lt;code&gt;$output&lt;/code&gt; и возвращает значение статуса &lt;code&gt;Z_OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98115fd081a8900c4523336f3adbeaa8265d8ece" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcfed4a8d779393f6607570b9bb7471da1de1d1" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is actually a flow control statement rather than a function. If there is a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt;), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; statement (which is similar to the C &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">Если за ним следует BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; на самом деле является оператором управления потоком, а не функцией. Если к BLOCK прикреплен блок &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; (обычно через &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;foreach&lt;/code&gt; ), он всегда выполняется непосредственно перед тем, как условие будет снова вычислено, как и третья часть цикла &lt;code&gt;for&lt;/code&gt; в C. используется для увеличения переменной цикла, даже если цикл был продолжен с помощью &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператора (который похож на оператор &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; в C ).</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">Если за ним следует BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; на самом деле является оператором управления потоком, а не функцией. Если к BLOCK прикреплен блок &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; (обычно через &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;foreach&lt;/code&gt; ), он всегда выполняется непосредственно перед тем, как условие будет снова вычислено, как и третья часть цикла &lt;code&gt;for&lt;/code&gt; в C. используется для увеличения переменной цикла, даже если цикл был продолжен с помощью &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; оператора (который похож на оператор &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; в C ).</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">Когда функции в исходном файле XS должны быть разделены на пакеты,следует использовать ключевое слово PACKAGE.Это ключевое слово используется с ключевым словом MODULE и должно следовать сразу после его использования.</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">При задании неоднозначного локального времени функция timelocal()должна всегда возвращать эпоху для функции</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">При обработке выходных параметров с помощью секции PPCODE убедитесь, что правильно обработали магию &amp;laquo;set&amp;raquo;. См. Подробности о магии &amp;laquo;установки&amp;raquo; в &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bd61549e044c4efead59e04ed6605311709e2f3" translate="yes" xml:space="preserve">
          <source>When in doubt, before you do anything else, check your status and read it carefully, many questions are answered directly by the git status output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">В случае сомнений заключите в скобки. По крайней мере, это позволит какому-нибудь бедняге прыгнуть по клавише% в &lt;b&gt;vi&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">В случае сомнений запустите конструкцию &lt;b&gt;awk&lt;/b&gt; через &lt;b&gt;a2p&lt;/b&gt; и посмотрите, что она вам даст.</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">Когда сомневаешься,ты можешь использовать</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">При вызове как &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; следующие параметры:</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">При вызове как &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; следующие параметры:</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">При вызове с использованием одной строки &lt;b&gt;parseopts&lt;/b&gt; обрабатывает строку как имя параметра синтаксического анализа и возвращает соответствующее значение, если оно существует (возвращает &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если нет).</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">При вызове с несколькими аргументами &lt;b&gt;parseopts&lt;/b&gt; обрабатывает их как пары ключ / значение, а указанные имена параметров синтаксического анализа устанавливаются на заданные значения. Любые неуказанные параметры синтаксического анализа не затрагиваются.</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">При вызове без дополнительных аргументов &lt;b&gt;parseopts&lt;/b&gt; возвращает хеш- &lt;b&gt;таблицу&lt;/b&gt; всех текущих параметров синтаксического анализа.</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">При вызове с параметрами принимаются следующие и необязательные:</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">Когда шут не шут?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">Когда он появляется по отдельности, он приводит к совпадению последовательностей &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; и классов символов Posix только в диапазоне ASCII. Таким образом, они возвращаются к своим значениям до 5.6 и до Unicode. Под &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; всегда означает именно цифры &lt;code&gt;&quot;0&quot;&lt;/code&gt; до &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; означает пять символов &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , а начиная с Perl v5.18, вертикальная табуляция; &lt;code&gt;\w&lt;/code&gt; означает 63 символа &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; и аналогично, все классы Posix, такие как &lt;code&gt;[[:print:]]&lt;/code&gt; , соответствуют только соответствующим символам диапазона ASCII.</target>
        </trans-unit>
        <trans-unit id="1727801b4e8e5e0fc9f27e13c40d768e93c5839d" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt;; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt;, and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e96b083a5b2fe4b1dd3f7bbb3653cb24d7adf0" translate="yes" xml:space="preserve">
          <source>When it comes to altering the behaviour of the test harness there's more than one way to do it. Which way is best depends on my requirements. In general if I only want to observe test execution without changing the harness' behaviour (for example to log test results to a database) I choose callbacks. If I want to make the harness behave differently subclassing gives me more control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">Когда дело доходит до компромиссов во времени,Perl почти всегда предпочитает бросать память в проблему.Скаляры в Perl используют больше памяти,чем строки в C,массивы берут больше,а хэши используют еще больше.Хотя еще многое предстоит сделать,в последних релизах эти проблемы были решены.Например,начиная с версии 5.004,дубликаты хэш-ключей разделяются между всеми хэшами,использующими их,поэтому не требуют перераспределения.</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">Когда дело доходит до неопределенных переменных, которые вызывают предупреждение при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , вы можете преобразовать предупреждение в ошибку.</target>
        </trans-unit>
        <trans-unit id="f4053c4973cee39e429495f57f5734c7c3b59da1" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;use warnings&lt;/code&gt;, you can promote the warning to an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">Когда он сходится,вы получаете функциональный вариант</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">Когда он запускается,отладчик читает ваш rc-файл (</target>
        </trans-unit>
        <trans-unit id="ab2f1658320564cc0ad685bee8d4cc13fa19d54b" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;&quot;PERL_PERTURB_KEYS&quot; in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">Когда элементы сталкиваются в заданном хеш-ведре, порядок, в котором они хранятся в цепочке, больше не предсказуем в Perl 5.18. Это сделано для того, чтобы усложнить наблюдение за столкновением. Это поведение можно переопределить с помощью переменной среды PERL_PERTURB_KEYS, см. &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS в perlrun&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">При загрузке &lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt; вы должны &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; перед тем, как &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . ( &lt;code&gt;threads&lt;/code&gt; выдадут предупреждение, если вы сделаете это наоборот.)</target>
        </trans-unit>
        <trans-unit id="ad743799b7c94d4ac0b3c71cf0ab2ce52219a004" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;use threads&lt;/code&gt; before you &lt;code&gt;use threads::shared&lt;/code&gt;. (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541e2da58c9337557a4530af689d0206150a39ea" translate="yes" xml:space="preserve">
          <source>When local patches are applied with smoke testing, the test driver will automatically request regeneration of certain tables after the patches are applied. The Synology supplied Perl 5.8.6 (at least on the DS413) &lt;b&gt;is NOT capable&lt;/b&gt; of generating these tables. It will generate opcodes with bogus values, causing the build to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">При поиске &lt;code&gt;DBD::Oracle&lt;/code&gt; относительно пути поиска мы должны найти</target>
        </trans-unit>
        <trans-unit id="e429da2f9f9d1870d8a34d9bf7c8fc15e19b17ad" translate="yes" xml:space="preserve">
          <source>When matching files are extracted, ignore the directory path from the archive and write to the current directory using the basename of the file from the archive. Beware: if two matching files in the archive have the same basename, the second file extracted will overwrite the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeb796371e192f654f19b82f3385e933e7f2600" translate="yes" xml:space="preserve">
          <source>When moving backward it will not move before &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3206ee6854b0880fdd3279a57398bcb52c78786" translate="yes" xml:space="preserve">
          <source>When moving forward it will not move beyond &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">При присвоении имени вашему модулю учитывайте следующее:</target>
        </trans-unit>
        <trans-unit id="52dec4ed188cfa5b52a02969dbe527c5dc433e3b" translate="yes" xml:space="preserve">
          <source>When no BOM is found, Encode 2.76 and blow croaked. Since Encode 2.77, it falls back to BE accordingly to RFC2781 and the Unicode Standard version 8.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">Если для параметра не указано место назначения, GetOptions сохранит результирующее значение в глобальной переменной с именем &lt;code&gt;opt_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">Если не &lt;code&gt;NULL&lt;/code&gt; , функция, на которую указывает эта переменная, будет вызываться каждый раз, когда OP освобождается с соответствующим OP в качестве аргумента. Это позволяет расширениям освобождать любые дополнительные атрибуты, которые они локально прикрепили к OP. Также гарантируется, что сначала сработает родительский OP, а затем его дочерние элементы.</target>
        </trans-unit>
        <trans-unit id="ff599e171f439dd0c6a6547247e21662b9941e75" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt;, the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">Когда ненулевое значение этого параметра заставит bzip2 использовать алгоритм декомпрессии,который использует меньше памяти за счет увеличения времени,затрачиваемого на декомпрессию.</target>
        </trans-unit>
        <trans-unit id="0ddf8b539ea05fcfe6aec1dc58d559038d4a8742" translate="yes" xml:space="preserve">
          <source>When not using &lt;code&gt;\o{...}&lt;/code&gt;, you wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. The resolution is as indicated, with all but the last digit treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">Когда open () получает явный список слоев (с синтаксисом с тремя аргументами), они переопределяют список, объявленный с помощью этой прагмы. open () также можно дать одно двоеточие (:) для имени слоя, чтобы переопределить эту прагму и использовать значение по умолчанию ( &lt;code&gt;:raw&lt;/code&gt; в Unix &lt;code&gt;:crlf&lt;/code&gt; в Windows).</target>
        </trans-unit>
        <trans-unit id="c34ab00add652f226c09c30c65ec7e49ad76d8a0" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default as detailed in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">При открытии для записи в пустые части файла будут записаны NULL (0x00)байт.</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">При открытии файла редко бывает хорошей идеей продолжить, если запрос не удался, поэтому &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; часто используется с &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Даже если &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; не будет делать то, что вы хотите (скажем, в сценарии CGI, где вы хотите отформатировать подходящее сообщение об ошибке (но есть модули, которые могут помочь с этой проблемой)), всегда проверяйте возвращаемое значение при открытии файла.</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">При открытии файла редко бывает хорошей идеей продолжить, если запрос не удался, поэтому &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; часто используется с &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Даже если &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; не будет делать то, что вы хотите (скажем, в сценарии CGI, где вы хотите отформатировать подходящее сообщение об ошибке (но есть модули, которые могут помочь с этой проблемой)), всегда проверяйте возвращаемое значение при открытии файла.</target>
        </trans-unit>
        <trans-unit id="162aabd310aabb9968a3811cefafecae90daf2da" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;open&lt;/code&gt; is frequently used with &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. Even if you want your code to do something other than &lt;code&gt;die&lt;/code&gt; on a failed open, you should still always check the return value from opening a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892216513454a34d10fa999d477dbcc5ddbab374" translate="yes" xml:space="preserve">
          <source>When opening a handle, it will be opened with any layers specified explicitly in the open() call (or the platform defaults, if specified as a colon with no following layers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">Когда передается одна ссылка на хэш, &lt;b&gt;parseopts&lt;/b&gt; использует этот хеш для полного сброса существующих параметров синтаксического анализа, все предыдущие значения параметров синтаксического анализа теряются.</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">Когда Perl начинает синтаксический анализ любой блочной конструкции, которая обеспечивает лексическую область видимости (например, тело eval, требуемый файл, тело подпрограммы, тело цикла или условный блок), существующее значение &lt;code&gt;$^H&lt;/code&gt; сохраняется, но его значение остается неизменным. Когда компиляция блока завершена, он восстанавливает сохраненное значение. Между точками , где сохраняется его значение и восстановленными, код , который выполняется в пределах НАЧАТЬ блоков может свободно изменять значение &lt;code&gt;$^H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae5f7f62c62b7d34f56ec3574375a08840be5dee" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">Когда perl выполняет что-то вроде &lt;code&gt;addop&lt;/code&gt; , как он передает свои результаты следующей операции? Ответ заключается в использовании стеков. Perl имеет несколько стеков для хранения вещей, над которыми он сейчас работает, и мы рассмотрим три наиболее важных из них.</target>
        </trans-unit>
        <trans-unit id="0ad42676f2cea160c10d6e67d7270b962893b05d" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt;, how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">Когда Perl выполняет выражение &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; , он транслирует вызовы &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; в библиотеке времени выполнения C и оттуда в ядро ​​операционной системы. perl устанавливает &lt;code&gt;$!&lt;/code&gt; для библиотеки C в &lt;code&gt;errno&lt;/code&gt; , если один из этих вызовов не удается.</target>
        </trans-unit>
        <trans-unit id="36c7954ee59f65366eedb8f27e4e9a6ca8de87ae" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;eval()&lt;/code&gt; expression, it translates the &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt;, and &lt;code&gt;close&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ce54f632d505238352e1c6b81e21cf7c3c75f1" translate="yes" xml:space="preserve">
          <source>When perl is built with debugging enabled, there is a second part to this stack storing human-readable string names describing the type of stack context. Each push operation saves the name as well as the height of the save stack, and each pop operation checks the topmost name with what is expected, causing an assertion failure if the name does not match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">Когда perl скомпилирован с поддержкой отладки отпечатков памяти (по умолчанию с Perl's malloc()),Devel::Peek предоставляет доступ к этому API.</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">Когда perl настроен на использование ithreads, он будет использовать вызовы библиотеки с повторным входом вместо нереентрантных версий. В функции &lt;code&gt;readdir_r&lt;/code&gt; FreeBSD в версиях 4.5 и более ранних есть ошибка, которая может вызывать SEGV при чтении больших каталогов. Доступен патч для FreeBSD libc (см. &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;Http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ), интегрированный во FreeBSD 4.6.</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">Если этот параметр присутствует, то количество сжатых байтов, считываемых из входного файла / буфера, ограничивается &lt;code&gt;$size&lt;/code&gt; . Эту опцию можно использовать в ситуации, когда полезные данные находятся непосредственно после потока сжатых данных, и вы заранее знаете точную длину потока сжатых данных.</target>
        </trans-unit>
        <trans-unit id="000c8ae4987a475c6136e4e54de88628f059caa6" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt;. This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">Когда предлагается что-то, что может иметь несколько различных интерпретаций, Perl использует &lt;b&gt;принцип DWIM&lt;/b&gt; (то есть &amp;laquo;Делай то, что я имею в виду&amp;raquo;), чтобы выбрать наиболее вероятную интерпретацию. Эта стратегия настолько успешна, что программисты Perl часто не подозревают об амбивалентности того, что они пишут. Но время от времени представления Perl существенно отличаются от того, что искренне имел в виду автор.</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">При печати сложное число обычно отображается под его картезианским стилем.</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">Когда появится запрос,выберите тему,в которой резюмируются ваши изменения.</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">При помещении элементов в &lt;code&gt;%^H&lt;/code&gt; , чтобы избежать конфликта с другими пользователями хеша, существует соглашение о том, какие ключи использовать. Модуль должен использовать только ключи, которые начинаются с имени модуля (имени его основного пакета) и символа &amp;laquo;/&amp;raquo;. Например, модуль &lt;code&gt;Foo::Bar&lt;/code&gt; должен использовать такие ключи, как &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9430143108ce24dc19010d3dec0a88276a16a9" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt;, in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">При чтении из файла или дескриптора &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; перед чтением установите режим bin .</target>
        </trans-unit>
        <trans-unit id="0711f567d0b9b4a99904ebf4ffdf5f0a6e3dd27c" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;\n&lt;/code&gt;, but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">При чтении из сокета помните, что разделителем входных записей по умолчанию &lt;code&gt;$/&lt;/code&gt; является &lt;code&gt;\n&lt;/code&gt; , но надежный код сокета распознает либо &lt;code&gt;\012&lt;/code&gt; либо &lt;code&gt;\015\012&lt;/code&gt; как конец строки:</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: AnyInflate будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: AnyUncompress будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Bunzip2 будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Gunzip будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Inflate будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: RawInflate будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">При чтении сжатых входных данных IO :: Uncompress :: Unzip будет читать их блоками по &lt;code&gt;$num&lt;/code&gt; байтов.</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">При ссылке &lt;code&gt;$!&lt;/code&gt; извлекает текущее значение целочисленной переменной C &lt;code&gt;errno&lt;/code&gt; . Если &lt;code&gt;$!&lt;/code&gt; присваивается числовое значение, это значение сохраняется в &lt;code&gt;errno&lt;/code&gt; . При ссылке на строку &lt;code&gt;$!&lt;/code&gt; выдает строку системной ошибки, соответствующую &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a6f2c4dbed65f11dd2dadedd0a40b92fb0de8b" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt;. When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">При обращении к символам с использованием числового кода E &amp;lt;n&amp;gt; числа в диапазоне 32-126 относятся к тем хорошо известным символам US-ASCII (также определенным там с помощью Unicode с тем же значением), которые все средства форматирования Pod должны точно отображать . Символы, числа E &amp;lt;&amp;gt; которых находятся в диапазонах 0-31 и 127-159, не должны использоваться (ни как литералы, ни как коды E &amp;lt;number&amp;gt;), за исключением буквенных байтовых последовательностей для новой строки (ASCII 13, ASCII 13 10 или ASCII 10) и табуляции (ASCII 9).</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">При регистрации новых категорий предупреждений можно задавать больше имён для предупреждений::register подобным образом:</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">При удалении деревьев каталогов,если вы хотите просмотреть каждый файл,чтобы решить,следует ли его удалить (и,возможно,оставить большие мазки в покое),</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">При рендеринге Pod в формат,допускающий комментарии (т.е.практически в любой формат,отличный от простого текста),шаблон Pod должен вставить текст комментария с указанием его названия и номера версии,а также названия и номера версии любых модулей,которые он может использовать для обработки Pod.Минимальные примеры:</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">При переводе Pod в формат с двумя типами дефисов (-),один из которых является неразрывным дефисом,а другой-ломающимся дефисом (как в случае с &quot;объектно-ориентированным&quot;,который может быть разделен на линии как &quot;объектно-&quot;,newline,&quot;oriented&quot;),форматировщикам рекомендуется обычно переводить &quot;-&quot; в неразрывный дефис,но они могут применять эвристику для преобразования некоторых из них в ломающиеся дефисы.</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">При сообщении об ошибке,пожалуйста,пробегитесь по этому списку:</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">При сообщении об ошибках/проблемах указывайте как можно больше информации.Мне может быть трудно воспроизвести проблему,так как почти каждая установка отличается.</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">При разрешении запроса на глобальную DLL таблица уже загруженных конкретных DLL (фактически)игнорируется;кроме того,специфическими DLL являются</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">При возврате массива C в Perl &lt;code&gt;size_$var&lt;/code&gt; XS должен предоставить целочисленную переменную с именем size_ $ var, содержащую количество элементов в массиве. Это используется для определения того, сколько элементов следует поместить в стек возвращаемых аргументов. Это не требуется при вводе, поскольку Perl знает, сколько аргументов находится в стеке при вызове подпрограммы. Обычно эта переменная называется &lt;code&gt;size_RETVAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="977e07d16b270182693f540dd1711d684d80c08a" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">При возврате результата,отличного от нулевого,тип возврата является релевантным.Если это АВ,то элементами АВ являются слабые эталонные АВ,которые указывают на данный пункт.Если речь идет о любом другом типе,то элемент сам по себе является слабой опорной точкой.</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">При округлении числа возможны различные &quot;стили&quot; или &quot;виды&quot; округления.(Обратите внимание,что случайное округление,как в математике::Round,не реализовано).</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">Когда он работает,он производит этот выход</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">При запуске скрипт выдаст это сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">При запуске &lt;code&gt;perl Makefile.PL&lt;/code&gt; в переменной среды &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; устанавливается полный путь к исполняемому &lt;code&gt;Makefile.PL&lt;/code&gt; . Это предотвращает неконтролируемые процессы в более новых версиях Module :: Install.</target>
        </trans-unit>
        <trans-unit id="89350694f65316ce98eae1ce7d3a0891e9c042c8" translate="yes" xml:space="preserve">
          <source>When running as the superuser, don't attempt drop privileges for security. This option is implied with &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04666da2a46dba8c376f71b404386c5bd13c8146" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt; or &lt;a href=&quot;#-t&quot;&gt;&quot;-t&quot;&lt;/a&gt; switch was specified, neither PERL5LIB nor &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is consulted. The program should instead say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">При выполнении проверок на наличие заражений, либо из-за того, что программа выполняла setuid или setgid, либо был указан переключатель &lt;b&gt;-T&lt;/b&gt; или &lt;b&gt;-t&lt;/b&gt; , ни PERL5LIB, ни PERLLIB не запрашиваются. Вместо этого программа должна сказать:</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">При запуске этой программы перенаправьте &lt;code&gt;STDOUT&lt;/code&gt; , чтобы можно было проверить правильность вывода при следующих тестовых запусках, и используйте служебную программу системного &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; для проверки общего времени выполнения.</target>
        </trans-unit>
        <trans-unit id="206d7f06e0a05581fe8e0f140b59c4f2ebd75b9b" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;time&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">При запуске под Eunice эта переменная содержит команду,которая преобразует скрипт оболочки в нужную форму текстового файла,чтобы он мог быть исполнен оболочкой.На других системах она не работает.</target>
        </trans-unit>
        <trans-unit id="e969971baf41c84189fecb4a510a18aaa7b43b6a" translate="yes" xml:space="preserve">
          <source>When running with taint checks enabled, indicates via &lt;code&gt;maybe_tainted&lt;/code&gt; if results are untrustworthy (often due to the use of locales).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6a46b32d19b77f807e82e4b0a5dbfd16227ea7" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;&quot;Unsafe signals&quot;&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">Когда действуют безопасные сигналы (поведение по умолчанию - см. &amp;laquo; &lt;a href=&quot;#Unsafe-signals&quot;&gt;Небезопасные сигналы&amp;raquo;&lt;/a&gt; для получения дополнительной информации), тогда сигналы могут отправляться и обрабатываться отдельными потоками.</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">Если результаты вас устраивают, повторно запустите цель &lt;code&gt;installcmd&lt;/code&gt; . Теперь вы можете скопировать &lt;code&gt;perl5.8.2.exe&lt;/code&gt; в &lt;code&gt;perl.exe&lt;/code&gt; и установить другие исполняемые файлы сборки OMF: &lt;code&gt;perl__.exe&lt;/code&gt; и т . Д. Они готовы к использованию.</target>
        </trans-unit>
        <trans-unit id="f3274597eb7d5805f670851614bcfbd7d2f840a5" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt;, and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">При сохранении источника включайте исправления,которые не генерируют подпрограмм.</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">При сохранении исходного текста включайте исходный текст,который не компилировался.</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">При поиске односимвольных разделителей экранированные разделители и &lt;code&gt;\\&lt;/code&gt; пропускаются. Например, при поиске завершающего &lt;code&gt;/&lt;/code&gt; пропускаются комбинации &lt;code&gt;\\&lt;/code&gt; и &lt;code&gt;\/&lt;/code&gt; . Если разделители заключены в скобки, вложенные пары также пропускаются. Например, при поиске закрытия &lt;code&gt;]&lt;/code&gt; в паре с открывающим &lt;code&gt;[&lt;/code&gt; , все комбинации &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt; и &lt;code&gt;\[&lt;/code&gt; пропускаются, а также пропущены вложенные &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; . Однако, когда в качестве разделителей используются обратные косые черты (например, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; ) ничего не пропускается. Во время поиска конца удаляются обратные косые черты, избегающие разделителей или другие обратные косые черты (точнее говоря, они не копируются в безопасное место).</target>
        </trans-unit>
        <trans-unit id="15bd46317800c6a271d171bbf86328e23d6c92d4" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;qq\\&lt;/code&gt; and &lt;code&gt;tr\\\&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680861791c99e55f56913fa6b0dc2bd7ba150950" translate="yes" xml:space="preserve">
          <source>When sending an initial request to the security email address, please don't Cc any other parties, because if they reply to all, the reply will generate yet another new ticket. Once you have received an initial reply with a &lt;code&gt;[perl #NNNNNN]&lt;/code&gt; ticket number in the headline, it's okay to Cc subsequent replies to third parties: all emails to the perl5-security-report address with the ticket number in the subject line will be added to the ticket; without it, a new ticket will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">Если установлено значение &lt;code&gt;&quot;1&quot;&lt;/code&gt; или &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; ключи обхода будут рандомизированы. Каждый раз, когда в него вставляется хеш, порядок ключей будет изменяться случайным образом. Порядок может не повторяться при следующем запуске программы, даже если был указан PERL_HASH_SEED. Это режим по умолчанию для Perl.</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">Если установлено значение &lt;code&gt;&quot;2&quot;&lt;/code&gt; или &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; то вставка ключей в хэш приведет к изменению порядка клавиш, но таким образом, который будет повторяться от запуска программы к запуску программы.</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;remove_tree&lt;/code&gt; будет пропускать файлы, для которых процессу не хватает требуемых привилегий, необходимых для удаления файлов, таких как привилегии удаления в VMS. Другими словами, код не будет пытаться изменить права доступа к файлам. Таким образом, если процесс будет прерван, ни один объект файловой системы не останется в более разрешительном режиме.</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">При установке значения true,будут удалены все файлы и подкаталоги,за исключением изначально указанных каталогов.Это пригодится при очистке каталога приложений для удаления царапин.</target>
        </trans-unit>
        <trans-unit id="a98ff16a4db26e40074379a02c1ac4736cef2e29" translate="yes" xml:space="preserve">
          <source>When set to true (default is false) this will reject any facets where a facet class cannot be found. Normally facets without classes are assumed to be custom and are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">Если установлено, Data :: Dumper будет выдавать одиночные, несамо-ссылочные значения в виде атомов / терминов, а не операторов. Это означает, что &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">Когда установлено,управляет тайм-аутом сети (отсчитывается в секундах).</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">Если установлено, позволяет использовать двойные кавычки для представления строковых значений. Пробелы, отличные от пробела, будут представлены как &lt;code&gt;[\n\t\r]&lt;/code&gt; , &amp;laquo;небезопасные&amp;raquo; символы будут иметь обратную косую черту, а непечатаемые символы будут выводиться как восьмеричные целые числа в кавычках. По умолчанию - 0.</target>
        </trans-unit>
        <trans-unit id="9d1d9ef1336068db5d1ba9928d2591d51c52c62c" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt;, &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">Когда я должен декодировать или кодировать?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">Когда я не должен программировать на Перле?</target>
        </trans-unit>
        <trans-unit id="ab11b33195a0de9ef0d3f4bb14477223addc7e28" translate="yes" xml:space="preserve">
          <source>When some mandatory fields are missing or invalid, the conversion will attempt to provide a sensible default or will fill them with a value of 'unknown'. For example a missing or unrecognized &lt;code&gt;license&lt;/code&gt; field will result in a &lt;code&gt;license&lt;/code&gt; field of 'unknown'. Fields that may get an 'unknown' include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">Когда что-то содержится в чем-то другом, особенно когда это может показаться неожиданным: &amp;laquo;Я встроил в свой редактор полный интерпретатор Perl!&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">Говоря о регексуалах,необходимо различать их исходную и внутреннюю форму.В этом документе мы будем использовать термин &quot;образец&quot;,когда говорим об их текстовой,исходной форме,и термин &quot;программа&quot;,когда говорим об их внутреннем представлении.Они соответствуют терминам</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">Когда указано (локализовано)в модуле</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">При непосредственном запуске сценариев Perl использует тот же алгоритм, что и для поиска сценария, заданного параметром командной строки &lt;b&gt;-S&lt;/b&gt; : он будет искать в текущем каталоге, затем в компонентах &lt;code&gt;$ENV{PATH}&lt;/code&gt; используя следующий порядок добавления расширений : без расширения,</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">При хранении дубликатов в сетевом порядке их значение сохраняется в виде текста.Однако,не следует ожидать,что нечисловые значения с плавающей точкой,такие как бесконечность и &quot;не число&quot;,успешно пройдут через пару nstore()/retrieve().</target>
        </trans-unit>
        <trans-unit id="4e11b655699381504305f7887609ab8d634e504a" translate="yes" xml:space="preserve">
          <source>When stringified, &lt;code&gt;autodie::exception::system&lt;/code&gt; objects currently use the message generated by &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85058aaefb4d2e0a77cba44540a9a1fa5a2d7ef7" translate="yes" xml:space="preserve">
          <source>When submitting a bug or request, please include a test-file or a patch to an existing test-file that illustrates the bug or desired feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">При тестировании приложений часто возникает необходимость предоставить в тестовой среде функциональные возможности, которые обычно предоставляются внешними модулями. Вместо того, чтобы вручную настраивать &lt;code&gt;%INC&lt;/code&gt; , чтобы пометить эти внешние модули как загруженные, чтобы они не загружались Perl, этот модуль предлагает вам очень простой способ пометить модули как загруженные и / или выгруженные.</target>
        </trans-unit>
        <trans-unit id="2ecf844cc9f858984bae81698225ab3522c9600d" translate="yes" xml:space="preserve">
          <source>When that is parsed and events are about to be called on it, it may actually seem to be four different text events, one right after another: one event for &quot;I just LOVE &quot;, one for &quot;hot&quot;, one for &quot; &quot;, and one for &quot;apple pie!&quot;. But if you have merge_text on, then you're guaranteed that it will be fired as one text event: &quot;I just LOVE hot apple pie!&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">Когда эта строка компилируется из нотации в скобках в реальный Perl подуровень,она,по сути,превращается в:</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">Когда при преобразовании в %o задаются флаг#и точность,точность увеличивается,если это необходимо для ведущего &quot;0&quot;.</target>
        </trans-unit>
        <trans-unit id="aa880a320400827152fdc9bea63191360399d514" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CVf_SLABBED&lt;/code&gt; flag is set, the CV takes responsibility for freeing the slab. If &lt;code&gt;CvROOT&lt;/code&gt; is not set when the CV is freed or undeffed, it is assumed that a compilation error has occurred, so the op slab is traversed and all the ops are freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">Если параметр &lt;code&gt;all&lt;/code&gt; опущен или равен false, то связанные хеш-элементы будут содержимым крайнего левого определенного буфера с именем связанного хеш-ключа. Другими словами, связанный хеш будет вести себя как &lt;code&gt;%+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b92065de5607bb0c7a77a48e1cfce97eed7a26ac" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;all&lt;/code&gt; параметр all , то связанные элементы хэша будут ссылками на массив, перечисляющими содержимое каждого буфера захвата, имя которого совпадает с именем связанного хеш-ключа. Если ни один из этих буферов не участвовал в сопоставлении, содержимое этого массива ref будет содержать столько значений &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , сколько имеется буферов захвата с таким именем. Другими словами, связанный хеш будет вести себя как &lt;code&gt;%-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2197c6d3b3d6c61f6564ab44ac2b44c0344d23" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;undef&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">Когда &lt;code&gt;exUnix2&lt;/code&gt; опция exUnix2, она инициирует создание дополнительного поля Unix2 (ID - &amp;laquo;Ux&amp;raquo;) в локальном zip-заголовке. Это будет заполнено &lt;code&gt;$uid&lt;/code&gt; и &lt;code&gt;$gid&lt;/code&gt; . Пустое дополнительное поле Unix2 также будет создано в центральном заголовке zip-архива.</target>
        </trans-unit>
        <trans-unit id="0db2965770fe8514e3fb9dd21cb17bd93496e99e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">Когда &lt;code&gt;exUnixN&lt;/code&gt; опция exUnixN, она инициирует создание дополнительного поля UnixN (ID - &amp;laquo;ux&amp;raquo;) как в локальном, так и в центральном zip-заголовках. Это будет заполнено &lt;code&gt;$uid&lt;/code&gt; и &lt;code&gt;$gid&lt;/code&gt; . UID и GID хранятся как 32-битные целые числа.</target>
        </trans-unit>
        <trans-unit id="f94a510aaa8dc7a162e9738895fa3812cc690de5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">Когда опция &lt;code&gt;frame&lt;/code&gt; установлена, отладчик будет печатать введенные (и, возможно, завершенные) подпрограммы в разных стилях. Смотрите на &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; невероятно длинные примеры таких.</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">Когда модуль CPAN используется в первый раз, диалог конфигурации пытается определить несколько специфичных для сайта опций. Результат диалога сохраняется в хеш-ссылке &lt;code&gt; $CPAN::Config &lt;/code&gt; в файле CPAN / Config.pm.</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">Когда оболочка CPAN входит в подоболочку с помощью команды look,она устанавливает окружение CPAN_SHELL_LEVEL в 1,или увеличивает эту переменную,если она уже установлена.</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">При запуске CPAN оболочки обычно отображается приветственное сообщение,содержащее запущенную версию и статус поддержки readline.</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">Когда SV читается или записывается в, &lt;code&gt;uf_val&lt;/code&gt; или &lt;code&gt;uf_set&lt;/code&gt; будет вызываться с &lt;code&gt;uf_index&lt;/code&gt; в качестве первого аргумента и указателем на SV в качестве второго. Ниже показан простой пример того, как добавить магию &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; . Обратите внимание, что структура ufuncs копируется sv_magic, поэтому вы можете безопасно разместить ее в стеке.</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">Когда механизм Storable не находит никакой &lt;code&gt;STORABLE_thaw&lt;/code&gt; ловушки STORABLE_thaw , он пытается загрузить класс, динамически запрашивая пакет (используя благословенное имя пакета), а затем повторно пытается выполнить поиск. Если в это время не удается определить местонахождение крюка, двигатель каркает. Обратите внимание, что этот механизм не сработает, если вы определите несколько классов в одном файле, но &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; вас предупредил.</target>
        </trans-unit>
        <trans-unit id="d71b47dffe6d13e95919a44f8b1aab3c74c9a2ad" translate="yes" xml:space="preserve">
          <source>When the Windows and Arm DLLs are built do not be scared by a very long messages whizzing by: it is the &quot;export freeze&quot; phase where the whole (rather large) API of Perl is listed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">Когда фактический статус завершения VMS дочернего элемента является ошибкой, внутри &lt;code&gt;$!&lt;/code&gt; будет установлено значение Errno Unix, ближайшее к этой ошибке, так что сценарии Perl, которые проверяют сообщения об ошибках, будут видеть ожидаемое сообщение об ошибке в стиле Unix вместо сообщения VMS.</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Когда аргументы выполняются через системную оболочку, результаты зависят от ее особенностей и возможностей. См. &quot; &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;STRING&quot; в perlop&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="ca28137b7d4a24f80f2a308158da006f7dc35dce" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Когда аргументы выполняются через системную оболочку, результаты зависят от ее особенностей и возможностей. См. &quot; &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;STRING&quot; в perlop&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="7a639b80ea13083bb656ad3ace22f1641521ba99" translate="yes" xml:space="preserve">
          <source>When the base greater than 36, and no collation sequence is given, the default collation sequence contains both uppercase and lowercase letters, so the letter case in the input is not ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569274b14b45a92ddaed7462d32bdd3f4354e2b9" translate="yes" xml:space="preserve">
          <source>When the base is less than or equal to 36, and no collation sequence is given, the letter case is ignored, so both of these also return 250:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ba3a0afa8ccd6c06c8d4acfe9a1d04b1ddc937" translate="yes" xml:space="preserve">
          <source>When the build environment has been set up, building and testing Perl is straightforward. The only thing you need to do is download the sources as usual, and add a file Policy.sh as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ca0edd57c85a2b69cd25fb457d6653721de135" translate="yes" xml:space="preserve">
          <source>When the class is inverted (&lt;code&gt;[^...]&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">Если класс должен соответствовать без учета регистра в соответствии с правилами сопоставления &lt;code&gt;/i&lt;/code&gt; , а символ, который явно упоминается внутри класса, соответствует многосимвольной последовательности без учета регистра в соответствии с правилами Unicode, класс также будет соответствовать этой последовательности. Например, Unicode говорит, что буква &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; должна соответствовать последовательности &lt;code&gt;ss&lt;/code&gt; согласно правилам &lt;code&gt;/i&lt;/code&gt; . Таким образом,</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">Когда код будет работать только на двух или трех операционных системах,может потребоваться учитывать только различия этих систем.Важно решить,где будет выполняться код,и быть взвешенным в своем решении.</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">При установке конфигурационной переменной ftp_passive все загрузки будут выполняться с установленным значением переменной окружения FTP_PASSIVE.В целом,это хорошая идея,так как она влияет на соединения,основанные на Net::FTP и LWP.Тот же эффект можно получить,запустив оболочку cpan с этим значением переменной окружения.Только для Net::FTP всегда можно установить пассивный режим,запустив libnetcfg.</target>
        </trans-unit>
        <trans-unit id="b1c69bf3ddadf947bad50c1663c482207ed7bb54" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;dbi&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">Когда база данных содержит только UTF-8, функция или метод-оболочка - удобный способ заменить все ваши вызовы &lt;code&gt;fetchrow_array&lt;/code&gt; и &lt;code&gt;fetchrow_hashref&lt;/code&gt; . Функция оболочки также упростит адаптацию к будущим улучшениям в драйвере базы данных. Обратите внимание, что на момент написания этой статьи (январь 2012 г.) в DBI не было стандартизированного способа работы с данными UTF-8. Пожалуйста, проверьте &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;документацию DBI,&lt;/a&gt; чтобы убедиться, что это все еще правда.</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">Когда выполнение вашей программы достигает точки, которая может удерживать точку останова, вызывается подпрограмма &lt;code&gt;DB::DB()&lt;/code&gt; если любая из переменных &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; или &lt;code&gt;$DB::signal&lt;/code&gt; истинна. . Эти переменные не являются &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; izable. Эта функция отключена при выполнении внутри &lt;code&gt;DB::DB()&lt;/code&gt; , включая функции, вызываемые из него, если &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; не истинно.</target>
        </trans-unit>
        <trans-unit id="203a255f166a15d5d314005ac0db0ee5bd633f84" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt;, &lt;code&gt;$DB::single&lt;/code&gt;, or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;local&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt;, including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">Когда файл</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">Когда файлы,которые вы обрабатываете,маленькие,не имеет большого значения,как вы это делаете,но это имеет огромное значение,когда они начинают становиться больше.</target>
        </trans-unit>
        <trans-unit id="d42ad95e8f7eb1ea8f7a7febcc136ac0e51ac7e9" translate="yes" xml:space="preserve">
          <source>When the first bad commit is isolated, &lt;code&gt;git bisect&lt;/code&gt; will tell you so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc397f7438e86b99c564236153e8faa95f5c6e3" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbrlen&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f6d7004331625d3362cc91973ffa26e2885b63" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar, the code point contained in the scalar second parameter is converted into a multi-byte string and stored into the first parameter scalar. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. The return value is the number of bytes stored; or negative if the code point isn't representable in the current locale. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;wctomb&lt;/code&gt; and &lt;code&gt;wcrtomb&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67993cdc0054c70b8cf1f3b164eab66d68fabca" translate="yes" xml:space="preserve">
          <source>When the hash is tied dispatches through to the SCALAR method, otherwise returns a mortal SV containing the number of keys in the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">Когда вызывается внутренняя подпрограмма,она будет видеть значение лексической подпрограммы внешней подпрограммы,как это было до и во время *первого*вызова внешней подпрограммы;в этом случае,после завершения первого вызова внешней подпрограммы,внутренняя и внешняя подпрограммы больше не будут иметь общего значения для лексической подпрограммы.Другими словами,она больше не будет общей.Это особенно важно,если лексическая подпрограмма обращается к лексическим переменным,объявленным в окружающем ее пространстве.</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">Когда вызывается внутренняя подпрограмма,она будет видеть значение переменной внешней подпрограммы,как это было до и во время *первого*вызова внешней подпрограммы;в этом случае,после завершения первого вызова внешней подпрограммы,внутренняя и внешняя подпрограммы больше не будут иметь общего значения для переменной.Другими словами,переменная больше не будет общей.</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">Когда последняя ссылка на объект исчезает,объект уничтожается.Если у вас есть только одна ссылка на объект,хранящийся в лексическом скаляре,то объект уничтожается,когда этот скаляр выходит за пределы области видимости.Если объект хранится в глобальном пакете,то этот объект не может выйти за пределы области видимости до тех пор,пока программа не выйдет из программы.</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">Когда уровень &lt;code&gt;PUSHED&lt;/code&gt; как часть &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; вызова, будет вызываться PUSHED.</target>
        </trans-unit>
        <trans-unit id="01a59251b1866e239efdc75d52f126badadf6773" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;open&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">При &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; уровня текущее значение $ PerlIO :: encoding :: fallback сохраняется и используется как аргумент CHECK при вызове методов Encode encode () и decode ().</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">Когда модуль lib загружается впервые, он записывает текущее значение @INC в массив &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . Чтобы восстановить @INC до этого значения, вы можете сказать</target>
        </trans-unit>
        <trans-unit id="e9f47c78a4b7c6bf48658f90ad7bb90a6f2c2f03" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt;. To restore @INC to that value you can say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">Когда выполняется сопоставление, первая часть регулярного выражения ( &lt;code&gt;\b(foo)&lt;/code&gt; ) находит возможное совпадение прямо в начале строки и загружает $ 1 с &amp;laquo;Foo&amp;raquo;. Однако, как только механизм сопоставления видит, что после &amp;laquo;Foo&amp;raquo;, сохраненного в $ 1, нет пробелов, он понимает свою ошибку и начинает заново через один символ после того, где было предварительное совпадение. На этот раз это продолжается до следующего появления &amp;laquo;foo&amp;raquo;. Полное регулярное выражение совпадает на этот раз, и вы получите ожидаемый результат &amp;laquo;таблица следует за foo&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="59438c31be63ed00a2828de2f2dbb82ccfc7a3c2" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt;) finds a possible match right at the beginning of the string, and loads up &lt;code&gt;$1&lt;/code&gt; with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in &lt;code&gt;$1&lt;/code&gt;, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a3d6c13049ca137ffa9c8c06a835f3079e4b4a" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using &lt;a href=&quot;#unlink1&quot;&gt;unlink1&lt;/a&gt;) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">Когда объект выходит из-под действия,вызывается деструктор.Деструктор попытается развязать файл (используя L</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">Когда критерии оптимизации удовлетворены, &lt;code&gt;reg_try()&lt;/code&gt; для выполнения сопоставления.</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">Когда на выходе есть имя файла,он усекает содержимое файла перед записью любых сжатых данных.Если выходной файл является файлообработчиком,его положение не будет изменено.Если выходной файл является буфером,он будет уничтожен перед записью любых сжатых данных.</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">Когда на выходе есть имя файла,он усекает содержимое файла перед записью любых несжатых данных.Если выходной файл является файлообработчиком,его положение не будет изменено.Если выходной файл является буфером,он будет уничтожен перед записью любых несжатых данных.</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">После завершения работы программы вывод можно просмотреть и отсортировать с помощью любых стандартных утилит фильтрации текста.Достаточным может быть что-то вроде следующего:</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">Когда сценарий закончится,и вы захотите изменить некоторые значения в сгенерированном</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">Когда сценарий завершает работу, профилировщик создаст базу данных с информацией профиля, которую вы можете превратить в отчеты с помощью инструментов профилировщика. Подробнее см. &amp;lt;perlperf&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="bd423c011519f7f605565c27b285e9b7433164a6" translate="yes" xml:space="preserve">
          <source>When the second parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mbtowc&lt;/code&gt; and &lt;code&gt;mbrtowc&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">Если строка содержит именованную кодовую точку Unicode &lt;code&gt;\N{...}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">Когда строка содержит кодовую точку только для Юникода</target>
        </trans-unit>
        <trans-unit id="dff4dc2cfa7ab4f3143ca1c8cea9659a2fba0df1" translate="yes" xml:space="preserve">
          <source>When the string has been upgraded to UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">Когда строка поступает из внешнего источника,помеченного как Unicode</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">Когда действует режим заражения ( &lt;code&gt;-T&lt;/code&gt; ), значок &quot;.&quot; каталог удаляется из &lt;code&gt;@INC&lt;/code&gt; , а переменные среды &lt;code&gt;PERL5LIB&lt;/code&gt; и &lt;code&gt;PERLLIB&lt;/code&gt; игнорируются Perl. Вы по-прежнему можете настроить &lt;code&gt;@INC&lt;/code&gt; вне программы, используя параметр командной строки &lt;code&gt;-I&lt;/code&gt; , как описано в &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; . Две переменные среды игнорируются, потому что они скрыты, и пользователь, запускающий программу, может не знать, что они установлены, в то время как параметр &lt;code&gt;-I&lt;/code&gt; четко виден и поэтому разрешен.</target>
        </trans-unit>
        <trans-unit id="e34514e5e3372fed96ae586191867c70ca14aae4" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt;) is in effect, the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun#-Idirectory&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">По окончании тестового файла выводится сводка вместе.</target>
        </trans-unit>
        <trans-unit id="5d3ce74817cdede8942c8b771dd9c729dbff5404" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; was only available when the &lt;a href=&quot;feature#The-%27switch%27-feature&quot;&gt;&lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature&lt;/a&gt; was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">Когда нет BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; - это функция, которая проходит через текущий блок &lt;code&gt;when&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt; вместо повторения динамически включающего &lt;code&gt;foreach&lt;/code&gt; или выхода из лексически включающего &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; . В Perl 5.14 и ранее эта форма &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; была доступна только тогда, когда была включена функция &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Операторы &lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;функций&amp;raquo;&lt;/a&gt; и &amp;laquo; Switch&amp;raquo; в perlsyn .</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">Когда нет BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; - это функция, которая проходит через текущий блок &lt;code&gt;when&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt; вместо повторения динамически включающего &lt;code&gt;foreach&lt;/code&gt; или выхода из лексически включающего &lt;code&gt;given&lt;/code&gt; . В Perl 5.14 и ранее эта форма &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; была доступна только тогда, когда была включена функция &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Операторы &lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;функций&amp;raquo;&lt;/a&gt; и &amp;laquo; Switch&amp;raquo; в perlsyn .</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">Когда нет метода,он берет имя метода в качестве имени кодировки и кодирует экземпляр</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">Когда они встроены в другой шаблон,то,что они совпадают,не меняется,независимо от скобок или от того,какие модификаторы действуют в этом внешнем шаблоне.</target>
        </trans-unit>
        <trans-unit id="dc5872b9a322af5576c1ac03e71331c1716252c8" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern. If you fail to compile the subcomponents, you can get some nasty surprises. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1810832e010e811c7366d9b862298011ff2e0aa6" translate="yes" xml:space="preserve">
          <source>When this bit is set, &lt;code&gt;$sNewName&lt;/code&gt; can be &lt;code&gt;[]&lt;/code&gt; [for &lt;code&gt;NULL&lt;/code&gt;] to indicate that &lt;code&gt;$sOldName&lt;/code&gt; should be deleted during the next boot rather than renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">Когда этот код выполняется,выводиться не будет.Вот почему:</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">Когда этот код запускается, только &lt;code&gt;Derived&lt;/code&gt; объект &lt;code&gt;$b&lt;/code&gt; выдаст предупреждение.</target>
        </trans-unit>
        <trans-unit id="9309453554803d7d3570d025f7e35cec80cda5d1" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt;, will generate a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">Когда этот код запускается с флагом &lt;b&gt;-w&lt;/b&gt; , для строки &lt;code&gt;$a&lt;/code&gt; будет &lt;b&gt;выдано&lt;/b&gt; предупреждение : &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2388e2ced3b75ec3bd369e3152eae13dfe498282" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">Когда используется эта форма прагмы, Perl использует только несимвольные части локалей, например &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl предполагает, что вы перевели все символы, с которыми он должен работать, в Unicode (фактически, собственный набор символов платформы (ASCII или EBCDIC) плюс Unicode). Для данных в файлах это удобно сделать, также указав</target>
        </trans-unit>
        <trans-unit id="db1567ebb35e094978d64dee42e25f3b2f3257aa" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt;. Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">При вызове этой функции,функция,на которую делается ссылка,называется</target>
        </trans-unit>
        <trans-unit id="e9e65ea3d452091e9942f0f5039cb9a617322586" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_checker&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_checker_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_checker&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_checker_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_checker&lt;/code&gt; is called. If &lt;code&gt;new_checker&lt;/code&gt; decides not to do anything special with an op that it is given (which is the usual case for most uses of op check hooking), it must chain the check function referenced by &lt;code&gt;*old_checker_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc4ee6516decf05e05dd9bd8fd17984cd79424b" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_plugin&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_plugin_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_plugin&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_plugin_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_plugin&lt;/code&gt; is called. If &lt;code&gt;new_plugin&lt;/code&gt; decides not to do anything special with the identifier that it is given (which is the usual case for most calls to a keyword plugin), it must chain the plugin function referenced by &lt;code&gt;*old_plugin_p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa02f2fe554bd2a9b6a103fe9beb89d9b4e4476" translate="yes" xml:space="preserve">
          <source>When this happens, you can just</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">Если установлено значение &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; будет автоматически получен из &lt;code&gt;O_FILES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="447329d526fb82114543e70fb22d4772337fe346" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4611cd8d92449087862ca322a574ebe794802885" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, multiple XS files may be placed under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">Когда это значение равно true,CPAN установит значение PERL_MM_USE_DEFAULT равным true.Это приводит к тому,что ExtUtils::MakeMaker (и совместимый)предлагает использовать значения по умолчанию вместо того,чтобы останавливаться и просить вас ответить на вопросы.Он также устанавливает значение NONINTERACTIVE_TESTING равным true,чтобы сигнализировать в общем случае,что дистрибутивы не должны пытаться взаимодействовать с Вами.</target>
        </trans-unit>
        <trans-unit id="e48ad08805e823db4cab572ed48a495b3413c960" translate="yes" xml:space="preserve">
          <source>When this option is set to true AND the zip archive being read has the &quot;Language Encoding Flag&quot; (EFS) set, the member name is assumed to be encoded in UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">When to Still Use local()</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">Когда использовать OO</target>
        </trans-unit>
        <trans-unit id="7fe9c30c4e2d69806274da4a183bd0637abe22d6" translate="yes" xml:space="preserve">
          <source>When true the entire test should be skipped. This is usually paired with an explanation in the &lt;code&gt;details&lt;/code&gt; field, and a &lt;code&gt;control&lt;/code&gt; facet that has &lt;code&gt;terminate&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">При значении true этот параметр устанавливает бит FLG.FHCRC в 1 в заголовке gzip и устанавливает поле заголовка CRC16 в значение CRC всего заголовка gzip,за исключением самого поля CRC16.</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">Если это так,выполните генерацию и добавление в MANIFEST файла SIGNATURE в дистрибутиве во время 'make distdir',через 'cpansign -s'.</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">Если &lt;code&gt;perllocal&lt;/code&gt; значение true, запрещает добавление установок в perllocal .</target>
        </trans-unit>
        <trans-unit id="ff5bff80188d068a00e6b218733a6d5345f2c3a2" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">Если это так,подавляет генерацию и добавление в MANIFEST мета-файлов модуля META.yml и META.json во время 'make distdir'.</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">Когда это так,подавляет генерацию мета-файлов модуля MYMETA.yml и MYMETA.json во время 'perl Makefile.PL'.</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">Если &lt;code&gt;packlist&lt;/code&gt; true, запрещает запись файлов списка пакетов для установки.</target>
        </trans-unit>
        <trans-unit id="72af2071def396f7be81fd1ce806195fb7b786b5" translate="yes" xml:space="preserve">
          <source>When true, the tempdir used by the IPC driver will not be deleted when the test is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">Пытаясь объяснить стеки,большинство учебников по информатике бормочут что-то о подпружиненных столбах столовых тарелок:последнее,что вы нажимаете на стеки-это первое,что вы выскакиваете.Это делается для наших целей:ваша программа на Си будет нажимать на &quot;стек Perl&quot; некоторые аргументы,закрывать глаза,пока происходит какое-то волшебство,а затем выкладывать результаты-возвращаемое значение вашей подпрограммной панели Perl-снимает стек.</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">При вязании ручки, первый аргумент &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; должен начинаться со звездочкой. Итак, если вы привязываете STDOUT, используйте &lt;code&gt;*STDOUT&lt;/code&gt; . Если вы присвоили его скалярной переменной, скажем, &lt;code&gt;$handle&lt;/code&gt; , используйте &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; связывает скалярную переменную &lt;code&gt;$handle&lt;/code&gt; , а не дескриптор внутри нее.</target>
        </trans-unit>
        <trans-unit id="db73b1d8c34ba44728cad3d2b1f319f02e5b59fc" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;tie&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt;. If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt;, use &lt;code&gt;*$handle&lt;/code&gt;. &lt;code&gt;tie $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt;, not the handle inside it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3ae376ab632badfb7a32a894228e134f3e11c" translate="yes" xml:space="preserve">
          <source>When uncompressing with &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt;, it will automatically detect if the zip file is zip64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">При использовании в качестве метода класса ( &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , иногда называемого статическим методом) &lt;code&gt;isa&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="1f0c66833fbe6e1b03af60ec0fe15b9334c1979b" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt;, sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75a54bcbf3526f0df59166b3d1ecbeabab7eb5" translate="yes" xml:space="preserve">
          <source>When used as a class method the &lt;code&gt;\%facet_data&lt;/code&gt; argument is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">При использовании в качестве фильтра мы хотим использовать его вот так:</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">При использовании в качестве метода экземпляра или класса ( &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ) &lt;code&gt;isa&lt;/code&gt; возвращает</target>
        </trans-unit>
        <trans-unit id="0c835a1bdea740af7b69e93efd47e9739cc62c50" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt;), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee80d9e31f7273254ea3de17e8c9cb461c0c08a0" translate="yes" xml:space="preserve">
          <source>When used as an object method the &lt;code&gt;\%facet_data&lt;/code&gt; argument may be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dac020145ba791bbcde686e21207104ab4efac0" translate="yes" xml:space="preserve">
          <source>When used as methods, all these subroutines call &lt;code&gt;$e-&amp;gt;facet_data()&lt;/code&gt;. The default &lt;code&gt;facet_data()&lt;/code&gt; method in &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; relies on the legacy methods this module emulates in order to work. As a result of this it is very easy to create infinite recursion bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">При таком использовании параметры и их возможные значения удаляются из &lt;code&gt;@myopts&lt;/code&gt; , глобальный &lt;code&gt;@ARGV&lt;/code&gt; вообще не затрагивается.</target>
        </trans-unit>
        <trans-unit id="80c8f7c123cd2630d333f7d9131c53ccb92cec1a" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">При таком использовании:</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">При использовании в элементе хэша он сообщает вам, определено ли значение, а не существует ли ключ в хеше. Использование &lt;a href=&quot;#exists&quot;&gt;существует&lt;/a&gt; для последней цели.</target>
        </trans-unit>
        <trans-unit id="3ea5744253b0aebebea0a675efdda097478c50c9" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; for the latter purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">При использовании в элементе хэша он сообщает вам, определено ли значение, а не существует ли ключ в хеше. Использование &lt;a href=&quot;exists&quot;&gt;существует&lt;/a&gt; для последней цели.</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">При использовании с элементом массива или хэша &lt;code&gt;is_shared&lt;/code&gt; проверяет, принадлежит ли указанный элемент общему массиву или хешу. (Он не проверяет содержимое этого элемента.)</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">При использовании для передачи списка perl в C модуль записи XS должен предоставить функцию (названную в честь типа массива, но с &amp;laquo;Ptr&amp;raquo;, замененным на &amp;laquo;*&amp;raquo;) для выделения памяти, необходимой для хранения списка. Должен быть возвращен указатель. Писатель XS должен освободить память при выходе из функции. Переменная &lt;code&gt;ix_$var&lt;/code&gt; устанавливается равной количеству элементов в новом массиве.</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">При использовании с &lt;code&gt;.&lt;/code&gt; , счетчик повторов определяет начальную позицию для вычисления смещения значения следующим образом:</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">При использовании с &lt;code&gt;@&lt;/code&gt; счетчик повторов представляет собой смещение от начала самой внутренней &lt;code&gt;()&lt;/code&gt; группы.</target>
        </trans-unit>
        <trans-unit id="452ac7244192f1d1049652316194fb25f11bd124" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt;, the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">При использовании с &lt;code&gt;Z&lt;/code&gt; , A &lt;code&gt;*&lt;/code&gt; в качестве счетчика повторов гарантированно добавить завершающий нулевой байт, так что результирующая строка всегда один байт длиннее , чем длина байта самого элемента.</target>
        </trans-unit>
        <trans-unit id="3e309ae810b7ba69caf1b083747a6f0e33a6ad11" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt;, a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">При использовании с методами класса проблема еще хуже. Поскольку Perl позволяет записывать имена подпрограмм как голые слова, Perl должен угадывать, является ли голое слово после метода именем класса или именем подпрограммы. Другими словами, Perl может разрешить синтаксис как &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;или как &lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f8a19419e9cae531fd00a5faf3b4b95c08f01c" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">При использовании с опциями командной строки:</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">Если userelocatableinc правда,эта переменная содержит место,куда должна быть скопирована программа установки,в которую должны быть скопированы бинарные файлы perl,а также все пути,которые могут быть перемещены во время выполнения программы,вычисленные из них во время установки.При использовании она инициализируется до исходного значения binexp,а затем binexp устанавливается в следующее состояние</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">При использовании &lt;code&gt;&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;lt;&lt;/code&gt; в группе &lt;code&gt;()&lt;/code&gt; это влияет на все типы внутри группы, которые принимают модификаторы порядка байтов, включая все подгруппы. Для всех остальных типов он молча игнорируется. Вам не разрешено переопределять порядок байтов в группе, которая уже имеет суффикс модификатора порядка байтов.</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">При использовании &lt;code&gt;Exporter&lt;/code&gt; со стандартными &lt;code&gt;strict&lt;/code&gt; и &lt;code&gt;warnings&lt;/code&gt; прагмах, то &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; ключевое слово необходимо , чтобы объявить переменные пакета &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; и т.д.</target>
        </trans-unit>
        <trans-unit id="ff82b6a088bd3949701c2e9690b32b71bbe25933" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;our&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt;, &lt;code&gt;@EXPORT&lt;/code&gt;, &lt;code&gt;@ISA&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">При использовании &lt;code&gt;IPC::Open3&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , если вы указываете строку в качестве аргумента &lt;code&gt;command&lt;/code&gt; , предполагается, что она соответствующим образом экранирована. Вы можете использовать константу &lt;code&gt;QUOTE&lt;/code&gt; в качестве переносимого символа кавычек (см. Выше). Однако, если вы предоставляете ссылку на массив, применяются особые правила:</target>
        </trans-unit>
        <trans-unit id="d2f0399c3e8df8b441dc7a3e6752ac0ac539b907" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">При использовании &lt;code&gt;IPC::Run&lt;/code&gt; , если вы указываете строку в качестве аргумента &lt;code&gt;command&lt;/code&gt; , строка будет разделена на пробелы, чтобы определить отдельные элементы вашей команды. Хотя обычно это просто &amp;laquo;Делай то, что ты имеешь в виду&amp;raquo;, это может сломаться, если у вас есть файлы или команды с пробелами в них.</target>
        </trans-unit>
        <trans-unit id="cb299ab15bb95a67fd9da59509a66d398c459654" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd114611c2ad871f0c8eb7b6bb0b00563bb8b3c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Perl_langinfo&lt;/code&gt; on systems that don't have a native &lt;code&gt;nl_langinfo()&lt;/code&gt;, you must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">При использовании &lt;code&gt;autodie&lt;/code&gt; или &lt;code&gt;Fatal&lt;/code&gt; с пользовательскими подпрограммами объявление этих подпрограмм должно появиться перед первым использованием &lt;code&gt;Fatal&lt;/code&gt; или &lt;code&gt;autodie&lt;/code&gt; , либо они были экспортированы из модуля. Попытка использовать &lt;code&gt;Fatal&lt;/code&gt; или &lt;code&gt;autodie&lt;/code&gt; для других пользовательских подпрограмм приведет к ошибке времени компиляции.</target>
        </trans-unit>
        <trans-unit id="d38b1b6fe53eaefb297f9d879236a334c99468e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt;, or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">При использовании &lt;code&gt;fd_retrieve&lt;/code&gt; объекты извлекаются последовательно, один объект (т.е. одно рекурсивное дерево) на связанный &lt;code&gt;store_fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12e3df8bd541ba3c998025aaa4430e3500847d06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt;, objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">При использовании GCC эта запись указывает, что MakeMaker должен сначала искать &lt;code&gt;libgl.a&lt;/code&gt; (а затем &lt;code&gt;gl.a&lt;/code&gt; ) во всех местах, указанных в &lt;code&gt;$Config{libpth}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c8cc8b7dc989aa2e0c54fa773dd36d96d318229" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt;) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">При использовании Module::Build это обычно так и будет:</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">При использовании PUSHCOLOR,POPCOLOR и LOCALCOLOR особенно важно не ставить запятую между константами.</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">При использовании Term::ReadLine,вы можете включить орнаменты так,чтобы ваш вход выделялся на фоне выхода из CPAN.pm.</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">При использовании синтаксиса Unix или MSDOS это имитирует функцию оболочки &lt;code&gt;dirname(1)&lt;/code&gt; которая немного отличается от того, как работает &lt;code&gt;fileparse()&lt;/code&gt; . Он возвращает все, кроме последнего уровня пути к файлу, даже если последний уровень явно является каталогом. Фактически, он возвращает не часть каталога, а просто путь на один уровень выше, действуя как &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; для путей к файлам.</target>
        </trans-unit>
        <trans-unit id="83acdc7454980247f70cca18686669a6056893a4" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;chop()&lt;/code&gt; for file paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">При использовании компилятора, отличного от GCC, в указанной выше записи будет выполняться поиск &lt;code&gt;gl.lib&lt;/code&gt; (за которым следует &lt;code&gt;libgl.lib&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c33d34fd00e0ffeecdde05351cb8111bf653102c" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">При использовании пользовательского движка, который не поддерживает конструкцию &lt;code&gt;(?:)&lt;/code&gt; для встроенных модификаторов, вероятно, лучше всего использовать &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify для предоставленного шаблона, обратите внимание, что это создаст нежелательные шаблоны в таких случаях, как:</target>
        </trans-unit>
        <trans-unit id="5336937191442d7debf67f5b96f41e967c4d55af" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;qr//&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">При использовании подписи аргументы по-прежнему доступны в специальной переменной массива &lt;code&gt;@_&lt;/code&gt; в дополнение к лексическим переменным подписи. Есть разница между двумя способами доступа к аргументам: &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e523513d7b0658b27eb8124687617b728e5c9ac2" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt;, in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">При использовании любой из этих подпрограмм (кроме &lt;code&gt;call_argv&lt;/code&gt; ) программист должен управлять стеком Perl. К ним относятся следующие макросы и функции:</target>
        </trans-unit>
        <trans-unit id="b91da188fa3782ad027e51e622e75b65bd3a446d" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt;), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">При использовании обманчивых утверждений и отрицаний,все это может стать еще более хитрым.Представьте,что вам хотелось бы найти последовательность нецифр,за которой не следует &quot;123&quot;.Вы можете попробовать написать это как</target>
        </trans-unit>
        <trans-unit id="8056637c2c9cbcfa303f8f1dbc6790e418dcb403" translate="yes" xml:space="preserve">
          <source>When using lookahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f069b81fc03a5abd7bd819f6288faad34de8014e" translate="yes" xml:space="preserve">
          <source>When using non-blocking mode, the caller must repeatedly check for writeability on the filehandle (for instance using &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;IO::Poll&lt;/code&gt;). Each time the filehandle is ready to write, the &lt;code&gt;connect&lt;/code&gt; method must be called, with no arguments. Note that some operating systems, most notably &lt;code&gt;MSWin32&lt;/code&gt; do not report a &lt;code&gt;connect()&lt;/code&gt; failure using write-ready; so you must also &lt;code&gt;select()&lt;/code&gt; for exceptional status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">При использовании perl на OS/390,пожалуйста,имейте в виду,что наборы символов EBCDIC и ASCII отличаются.Подробнее о таких проблемах с наборами символов смотрите perlebcdic.pod.Встроенные функции Perl,которые могут вести себя по-разному в EBCDIC,также упомянуты в документе perlport.pod.</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">При использовании perldoc в режиме &lt;code&gt;-m&lt;/code&gt; (исходный код модуля отображения) &lt;code&gt;perldoc&lt;/code&gt; попытается использовать пейджер, установленный в &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . Полезной настройкой для этой команды является ваш любимый редактор, например &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Не судите меня.)</target>
        </trans-unit>
        <trans-unit id="ca44e9fc9c83d8e97acbec5970188d530099b61d" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt;. A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt;. (Don't judge me.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">При использовании протокола &quot;syn&quot; используйте этот метод для определения доступности удаленного хоста.Предполагается,что этот метод будет вызываться столько раз,сколько было вызвано функцией ping().Каждый вызов возвращает хост (как передается в ping()),который вернулся с TCP ACK.Порядок,в котором возвращаются хосты,может не совпадать с порядком,в котором они были поставлены в очередь SYN с помощью метода ping().Если таймаут достигнут до получения TCP ACK,или если удаленный хост не прослушивает порт,на котором была сделана попытка,то TCP-соединение не будет установлено и ack()вернётся undef.В контексте списка будет возвращен хост,время ack и пунктирная ip-строка,а не только хост.Если указан необязательный аргумент $host,то возвращаемое значение будет относиться только к этому хосту.Этот вызов просто ничего не делает,если вы используете какой-либо протокол,кроме syn.</target>
        </trans-unit>
        <trans-unit id="420afa8aef5868ada909527b4d0cf95eed4c31dc" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, the dotted ip string, and the port number will be returned instead of just the host. If the optional &lt;code&gt;$host&lt;/code&gt; argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than &quot;syn&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">При использовании прототипа &lt;code&gt;+&lt;/code&gt; ваша функция должна проверить, имеет ли аргумент допустимый тип.</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">При использовании компилятора Borland второй элемент возвращается как &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; , а MakeMaker заботится о перемещении &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; в нужное место в командной строке компоновщика.</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">При использовании GUI-версии SAM нажмите на значок &quot;Конфигурация ядра&quot;,затем на значок &quot;Настраиваемые параметры&quot;.Прокрутите вниз и выберите строку Maxdsiz.В меню Actions (Действия)выберите пункт Modify Configurable Parameter (Изменить конфигурируемые параметры).Вставьте новую формулу в поле Формула/Ценность.Затем следуйте инструкциям по перестройке ядра и перезагрузке системы.</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">При использовании компилятора Visual C второй элемент возвращается как &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">При использовании констант, если вы не хотите помнить о добавлении &lt;code&gt;, RESET&lt;/code&gt; в конце каждой строки печати, вы можете установить для $ Term :: ANSIColor :: AUTORESET истинное значение. Затем режим отображения будет автоматически сброшен, если после константы нет запятой. Другими словами, с этим набором переменных:</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">При использовании данного компилятора для сборки Perl необходимо убедиться,что в файле config.sh в переменные cpprun и cppstdin добавлен флаг -Aa (хотя смотрите ниже раздел о 64-битном perl).Если вы используете последнюю версию дистрибутива Perl,то эти флаги устанавливаются автоматически.</target>
        </trans-unit>
        <trans-unit id="a190d4d20525775f69d139675c3dc51cef5fb8f2" translate="yes" xml:space="preserve">
          <source>When using tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; that can generate the &lt;code&gt;provides&lt;/code&gt; mapping for your distribution automatically, make sure you examine what it generates to make sure it makes sense - indexers will usually trust the &lt;code&gt;provides&lt;/code&gt; field if it's present, rather than scanning through the distribution files themselves to figure out packages and versions. This is a good thing, because it means you can use the &lt;code&gt;provides&lt;/code&gt; field to tell the indexers precisely what you want indexed about your distribution, rather than relying on them to essentially guess what you want indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">При проверке существующей строки дайджеста вы должны использовать дайджест в качестве соли (например, &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). СОЛЬ, использованная для создания дайджеста, отображается как часть дайджеста. Это гарантирует, что crypt () будет хешировать новую строку с той же солью, что и дайджест. Это позволяет вашему коду работать со стандартной &lt;a href=&quot;crypt&quot;&gt;криптой&lt;/a&gt; и с более экзотическими реализациями. Другими словами, ничего не предполагайте ни о самой возвращаемой строке, ни о том, сколько байтов SALT может иметь значение.</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">При проверке существующей строки дайджеста вы должны использовать дайджест в качестве соли (например, &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). СОЛЬ, использованная для создания дайджеста, отображается как часть дайджеста. Это гарантирует, что crypt () будет хешировать новую строку с той же солью, что и дайджест. Это позволяет вашему коду работать со стандартной &lt;a href=&quot;#crypt&quot;&gt;криптой&lt;/a&gt; и с более экзотическими реализациями. Другими словами, ничего не предполагайте ни о самой возвращаемой строке, ни о том, сколько байтов SALT может иметь значение.</target>
        </trans-unit>
        <trans-unit id="213bdf210d4174fda29ca99ffa2edc52c2a2b3fb" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt;). The SALT used to create the digest is visible as part of the digest. This ensures &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">Когда мы что-то благословляем,мы не благословляем переменную,содержащую ссылку на эту вещь,и не благословляем ссылку,которую эта переменная хранит;мы благословляем вещь,на которую эта переменная ссылается (иногда известную как</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">Когда мы вызываем &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; для переменной, мы фактически благословляем базовую структуру данных, на которую ссылается переменная. Мы не благословляем ни саму ссылку, ни переменную, содержащую эту ссылку. Вот почему второй вызов &lt;code&gt;blessed( $bar )&lt;/code&gt; возвращает false. В этот момент &lt;code&gt;$bar&lt;/code&gt; больше не хранит ссылку на объект.</target>
        </trans-unit>
        <trans-unit id="6555170698fd78a17d09b080573745f1fb3e931d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;bless&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">Когда мы вызываем метод, Perl &lt;b&gt;принимает меры&lt;/b&gt; для &lt;b&gt;передачи вызывающего&lt;/b&gt; метода в качестве первого аргумента. &lt;b&gt;Invocant&lt;/b&gt; - это причудливое название для предмета слева от стрелки. Вызывающим может быть имя класса или объект. Мы также можем передать методу дополнительные аргументы:</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">Когда мы говорим &quot;Mac OS&quot; ниже,мы имеем в виду Mac OS 7,8 и 9,и</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">Когда мы хотим поместить возвращаемые вызывающему абоненту значения в стек,мы используем серию макросов,которые начинаются с &quot;XPUSH&quot;.Существует пять различных версий,для размещения целых чисел,беззнаковых целых чисел,дубликатов,строк и Perl-скаляров на стеке.В нашем примере мы поместили Perl-скаляр на стек.(На самом деле это единственный макрос,который может быть использован для возврата множественных значений).</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">Когда встречаются слова, длина которых превышает &lt;code&gt;$columns&lt;/code&gt; , они разбиваются. &lt;code&gt;wrap()&lt;/code&gt; добавляет &lt;code&gt;&quot;\n&quot;&lt;/code&gt; в столбец &lt;code&gt;$columns&lt;/code&gt; . Это поведение можно изменить, установив для &lt;code&gt;$huge&lt;/code&gt; значение 'die' или 'overflow'. Если установлено значение 'die', большие слова будут вызывать вызов &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . Если установлено значение &amp;laquo;переполнение&amp;raquo;, большие слова останутся нетронутыми.</target>
        </trans-unit>
        <trans-unit id="5ebaaddfa0e00536f0f1b77f056696aff48f065e" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt;. This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;die()&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">При написании DBM-фильтра это</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">При написании расширения Perl для общего потребления следует ожидать,что это расширение будет использоваться с версиями Perl,отличными от версии,доступной на вашей машине.Поскольку вы читаете этот документ,версия Perl на вашей машине,вероятно,5.005 или более поздняя,но у пользователей вашего расширения могут быть более древние версии.</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">При записи символа UV в строку UTF-8 &lt;b&gt;всегда&lt;/b&gt; используйте &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , если только &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; в этом случае вы можете использовать &lt;code&gt;*s = uv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ffec04c54d59e59616907c7e9e4db0144cb75f4" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt;, unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">При записи gzip-файла этот интерфейс будет</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">При записи в файл или дескриптор файла установите &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; перед записью в файл.</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">Когда ты</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">Когда вы довольны списком подозреваемых,вы можете теперь</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">Когда вы закончите,процесс установки XS-модуля добавит в вашу &quot;perllocal&quot; информацию о том,что бинарник perl был заменён,и какой модуль был установлен.Вы можете просмотреть эту информацию в любое время с помощью команды:</target>
        </trans-unit>
        <trans-unit id="b326342faabbb3f551d027918413fb764e7ae496" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">Если вы собираетесь использовать компилятор GNU C (gcc), но у вас еще нет gcc, вы можете либо собрать его самостоятельно из источников (доступных, например, по &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;адресу http://gcc.gnu.org/mirrors.html&lt;/a&gt; ) или загрузите предварительно созданный двоичный файл из центра портирования HP по адресу &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; или из DSPP (вы должны быть участником) по адресу &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http : //h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801? ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD &amp;amp; jumpid = reg_r100_r1002_usen&lt;/a&gt; , так как часто доступны несколько версий пакета, так как список пакетов от.</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">Когда вы вручную создаете UCM файл,вы должны скопировать ascii.ucm или существующую кодировку,которая близка к вашей,вместо того,чтобы писать свою собственную с нуля.</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">Когда вы будете удовлетворены результатами тестов,установите библиотеки сборки C для расширений:</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">Если вы уверены , что только несколько подкаталогов привести к сбоям, вы можете добавить &lt;code&gt;-j4&lt;/code&gt; вариант &lt;code&gt;make&lt;/code&gt; , чтобы ускорить пропуск подкаталогов с уже готовой сборкой.</target>
        </trans-unit>
        <trans-unit id="7b2f8e90d6f4d4294f6e2dcda859cd96193b4ae7" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;icmp&quot; protocol, this call permit to change the message type to 'echo' or 'timestamp' (only for IPv4, see RFC 792).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">Когда вы используете &amp;laquo;потоковый&amp;raquo; протокол, этот вызов предварительно открывает TCP-сокет. Это необходимо только в том случае, если вы хотите указать другой тайм-аут при создании соединения или удалить накладные расходы на установление соединения из первого эхо-запроса. Если вы не вызываете &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , соединение автоматически открывается при первом вызове &lt;code&gt;ping()&lt;/code&gt; . Этот вызов просто ничего не делает, если вы используете какой-либо протокол, кроме потока.</target>
        </trans-unit>
        <trans-unit id="53d7ace59a255ce0dee603a0e82c9350ed60c845" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;open()&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19030bdd1652e63fb5fe9a91af20f3234d06d23f" translate="yes" xml:space="preserve">
          <source>When you assign a list of scalars to an array, all previous values in that array are wiped out and the number of elements in the array will now be equal to the number of elements in the right-hand list -- the list from which assignment was made. The array will automatically resize itself to precisely accommodate each element in the right-hand list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">Когда вы собираете модули,скажите Perl,где установить модули.</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">Когда вы вызываете &lt;code&gt;bar&lt;/code&gt; с аргументами, вы видите, что &lt;code&gt;foo&lt;/code&gt; имеет то же &lt;code&gt;@_&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c91152667ee3ebf07dbc40066530c9ec19f3697d" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835f87385a105654b52b3b81d31156a333d91b09" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;open&lt;/code&gt; this way, Perl invokes the given command directly, bypassing the shell. As such, the shell won't try to interpret any special characters within the command's argument list, which might overwise have unwanted effects. This can make for safer, less error-prone &lt;code&gt;open&lt;/code&gt; calls, useful in cases such as passing in variables as arguments, or even just referring to filenames with spaces in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685020a1713f908c5ec69a7f573fc741004b77c1" translate="yes" xml:space="preserve">
          <source>When you call Perl's &lt;code&gt;open&lt;/code&gt; to set a Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;], Perl calls C's &lt;code&gt;fopen&lt;/code&gt; to set a stdio &lt;code&gt;FILE *&lt;/code&gt;. C's &lt;code&gt;fopen&lt;/code&gt; calls something like Unix's &lt;code&gt;open&lt;/code&gt;, that is, Win32's &lt;code&gt;_sopen&lt;/code&gt;, to get an integer file descriptor [where 0 is for &lt;code&gt;STDIN&lt;/code&gt;, 1 for &lt;code&gt;STDOUT&lt;/code&gt;, etc.]. Win32's &lt;code&gt;_sopen&lt;/code&gt; calls &lt;code&gt;CreateFile&lt;/code&gt; to set a &lt;code&gt;HANDLE&lt;/code&gt;, a Win32 native file handle. So every Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;] has an integer file descriptor associated with it that you can get via &lt;code&gt;fileno&lt;/code&gt;. And, under Win32, every file descriptor has a Win32 native file handle associated with it. &lt;code&gt;FdGetOsFHandle&lt;/code&gt; lets you get access to that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e313737a6b3963a3bf8908006a0a820d6e4555f" translate="yes" xml:space="preserve">
          <source>When you call a fully qualified method name like &lt;code&gt;File::save&lt;/code&gt;, the method resolution search for the &lt;code&gt;save&lt;/code&gt; method starts in the &lt;code&gt;File&lt;/code&gt; class, skipping any &lt;code&gt;save&lt;/code&gt; method the &lt;code&gt;File::MP3&lt;/code&gt; class may have defined. It still searches the &lt;code&gt;File&lt;/code&gt; class's parents if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">Когда вы вызываете метод, то, что находится слева от стрелки, передается в качестве первого аргумента метода. Это означает, что когда мы вызываем &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , метод &lt;code&gt;new()&lt;/code&gt; получает строку &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; качестве своего первого аргумента. Когда мы вызываем &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , переменная &lt;code&gt;$fred&lt;/code&gt; передается как первый аргумент для &lt;code&gt;speak()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fae81431a82ed2b7245ab26b577216b20acfee24" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt;, the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt;, the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210c4bda966e8ba5f3d3dd89593f4b86c57dc0ef" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;tie&lt;/code&gt; function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">Когда вы изменяете &lt;b&gt;значение&lt;/b&gt; в процессе его копирования. [От французского &amp;laquo;попутно&amp;raquo;, как в экзотическом маневре с захватом пешки в шахматах.]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">При chop()математическом объекте он переходит в строку и его математические свойства теряются.То же самое может произойти и с другими операциями.</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">При объединении устаревших данных и Юникода,устаревшие данные необходимо обновить до Юникода.Обычно считается,что устаревшие данные соответствуют стандарту ISO 8859-1 (или EBCDIC,если применимо).</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">Когда вы создаете карту, вы ДОЛЖНЫ сделать ваши сопоставления безопасными. То есть &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; обозначает все символы, помеченные как &lt;code&gt;|0&lt;/code&gt; . Вот как в этом убедиться:</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">Когда вы объявляете константу, такую ​​как &lt;code&gt;PI&lt;/code&gt; , используя метод, показанный выше, каждая машина, на которой запускается ваш скрипт, может иметь столько цифр точности, сколько она может использовать. Кроме того, вашу программу будет легче читать, с большей вероятностью будет поддерживаться (и правильно обслуживаться) и гораздо меньше шансов отправить космический зонд не на ту планету, потому что никто не заметил одно уравнение, в котором вы написали &lt;code&gt;3.14195&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e2b5a1dcab630574856b807ba52f00dea975f20" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">Когда вы декодируете(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">Когда вы декодируете, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; вставляется для искаженного символа, где</target>
        </trans-unit>
        <trans-unit id="3c3e41e00e97aaa41946f9404604a3e16daeabbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8903ce8817b2306a386e9e7bf122e6808d15508e" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b2a9b37643890f116ac0184e9ac142f63cbe26" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для объекта &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы можете получить объект этого класса.</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы можете получить объект этого класса.</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">Когда вы выполняете $ parser-&amp;gt; get_token для &lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt; , вы должны получить объект подкласса Pod :: Simple :: PullParserToken.</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">Когда вы делаете open()и указываете дополнительные слои PerlIO,которые должны быть развернуты,слои,которые вы указываете,&quot;толкаются&quot; поверх уже существующего стека по умолчанию.Один из способов увидеть это-&quot;операционная система слева&quot; и &quot;Perl справа&quot;.</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">Когда вы это сделаете, убедитесь, что вы оставили по крайней мере от &lt;b&gt;U0000&lt;/b&gt; до &lt;b&gt;U0020&lt;/b&gt; как есть, если ваша среда не EBCDIC.</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">Когда вы это делаете, вы заменяете обычные &lt;code&gt;OP_CUSTOM&lt;/code&gt; &lt;code&gt;op_ppaddr&lt;/code&gt; на собственные операции, создавая операции с типом OP_CUSTOM и op_ppaddr вашей собственной функции PP. Это должно быть определено в XS код, и должен выглядеть ПП опы &lt;code&gt;pp_*.c&lt;/code&gt; . Вы несете ответственность за то, чтобы ваш оператор взял соответствующее количество значений из стека, и вы несете ответственность за добавление меток стека, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">Когда вы кодируете,он просто кодирует UTF-8 строку с помощью</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">При выполнении этого скрипта Perl создает исходный поток для файла.Перед тем,как синтаксический анализатор обработает какую-либо строку из файла,исходный поток выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c978bab6e05df288a1696970dbd630fd132c029f" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">Когда вам надоест писать нестандартную печать для ваших структур данных, вы можете взглянуть на стандартные &lt;a href=&quot;dumpvalue&quot;&gt;модули Dumpvalue&lt;/a&gt; или &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; . Первый - это то, что использует отладчик Perl, а второй генерирует анализируемый код Perl. Например:</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Когда у вас установлен Module::Build и модуль поставляется как с Makefile.PL,так и с Build.PL,что должно иметь приоритет?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Когда у вас установлен Term::ANSIColor,вы можете включить цветной вывод,чтобы иметь некоторые визуальные различия между обычным выводом CPAN.pm,предупреждениями,отладочным выводом и выводом устанавливаемых модулей.Установите ваши любимые цвета после некоторых экспериментов с модулем Term::ANSIColor.</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">Когда у вас есть &lt;code&gt;$normalized&lt;/code&gt; строка &lt;code&gt;$unnormalized&lt;/code&gt; следующая за ней ненормализованная строка, простое объединение неверно:</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">Когда у вас есть дубликат записи,отметьте его '|1' или '|3'.</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">Когда вы перечисляете аргументы для XSUB в файле .xs, это сообщает &lt;b&gt;xsubpp,&lt;/b&gt; какой аргумент соответствует какому из стека аргументов (т. &lt;b&gt;Е.&lt;/b&gt; Первый из перечисленных аргументов является первым аргументом и т. Д.). Вы приглашаете к катастрофе, если не перечисляете их в том же порядке, в каком их ожидает функция.</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">Когда вы создаете исполняемый файл сценария, чтобы его можно было использовать в качестве команды, система передаст переключатели на perl из сценария #! линия. Perl проверяет, что любые параметры командной строки, заданные для сценария setuid (или setgid), действительно соответствуют параметрам, установленным в #! линия. Некоторые Unix и Unix-подобные среды накладывают ограничение в один переключатель на #! строка, поэтому вам может потребоваться использовать что-то вроде &lt;code&gt;-wU&lt;/code&gt; вместо &lt;code&gt;-w -U&lt;/code&gt; в таких системах. (Эта проблема должна возникать только в Unix или Unix-подобных средах, которые поддерживают сценарии #! И setuid или setgid.)</target>
        </trans-unit>
        <trans-unit id="66b392aea5e0dde426270cd749894810ea22ea80" translate="yes" xml:space="preserve">
          <source>When you obtain a context object it is made specifically for your tool and any tools nested within. If you pass a context around you run the risk of polluting other tools with incorrect context information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">Когда вы переопределяете встроенный, ваша замена должна согласовываться (если возможно) со встроенным собственным синтаксисом. Добиться этого можно с помощью подходящего прототипа. Чтобы получить прототип переопределяемого встроенного модуля, используйте функцию &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; с аргументом &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (см. &lt;a href=&quot;functions/prototype&quot;&gt;Прототип&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="403deb8cf132584282b80991028fcc8f4fae8ae6" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;prototype&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;perlfunc#prototype&quot;&gt;&quot;prototype&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">Когда вы заменяете эту переменную,считается хорошей практикой хранить,возможно,ранее установленный крюк,и что вы помните его внутри своего собственного.</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Когда вы запускаете Makefile.PL,он делает Makefile.В этом весь смысл MakeMaker.Makefile.PL-это простая программа,которая загружает ExtUtils::MakeMaker и запускает функцию WriteMakefile()для генерации Makefile.</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Когда вы запускаете Perl скрипт,что-то другое запускает скрипт для вас,и что-то другое может выдать сообщения об ошибках.Сценарий может выдавать свои собственные предупреждения и сообщения об ошибках.В большинстве случаев вы не можете сказать,кто что сказал.</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">Когда вы запустите эту программу,вы должны получить что-то,что выглядит так:</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">Когда вы говорите &quot;сделать тест&quot;,Перл использует</target>
        </trans-unit>
        <trans-unit id="76a6e68fd11c4b70b5a87d525381faf69633be4b" translate="yes" xml:space="preserve">
          <source>When you say &lt;code&gt;make test&lt;/code&gt; it will run with taint mode on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">Когда вы видите &lt;code&gt;charset=gb2312&lt;/code&gt; в сообщениях электронной почты и на веб-страницах, они действительно имеют в виду &lt;code&gt;euc-cn&lt;/code&gt; . Чтобы исправить это, &lt;code&gt;gb2312&lt;/code&gt; имеет псевдоним &lt;code&gt;euc-cn&lt;/code&gt; . Используйте &lt;code&gt;gb2312-raw&lt;/code&gt; , когда действительно имеете в виду.</target>
        </trans-unit>
        <trans-unit id="8c4e1c3fce7decd6f02607f653534397608ae09a" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt;. Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">Когда вы видите &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; в сообщениях электронной почты и на веб-страницах, они действительно имеют в виду кодировки &quot;cp949&quot;. Чтобы исправить это, устанавливаются следующие псевдонимы;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
