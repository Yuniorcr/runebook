<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8ae5f938ab7a5d83a52240928c9fc8f756451386" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit decimal numbers (format &lt;code&gt;i&lt;/code&gt; ) for output.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования 64-битных десятичных чисел (формат &lt;code&gt;i&lt;/code&gt; ) для вывода.</target>
        </trans-unit>
        <trans-unit id="67f3f82cc82b4b966bf37a7650e599f3caebbae2" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit decimal numbers (format &lt;code&gt;i&lt;/code&gt;) for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81a10e07e19ecd9ea940b8094c09118247d9976" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hExADECimAl numbers (format &lt;code&gt;X&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIx64 so that even case-blind systems can see the difference.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования 64-битных чисел hExADECimAl (формат &lt;code&gt;X&lt;/code&gt; ) для вывода. &lt;code&gt;U&lt;/code&gt; в названии, чтобы отделить это от sPRIx64 , так что даже случай слепые системы могут увидеть разницу.</target>
        </trans-unit>
        <trans-unit id="83b9dfdbe65dffb2c54b38449f43e2b100be9ab9" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hExADECimAl numbers (format &lt;code&gt;X&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIx64 so that even case-blind systems can see the difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec40980af277a53203a731f456671009736e566" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hexadecimal numbers (format &lt;code&gt;x&lt;/code&gt; ) for output.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования 64-битных шестнадцатеричных чисел (формат &lt;code&gt;x&lt;/code&gt; ) для вывода.</target>
        </trans-unit>
        <trans-unit id="3dc36ab3b201ba898512f271cd471ea7023cc0a8" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit hexadecimal numbers (format &lt;code&gt;x&lt;/code&gt;) for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b88a2a561747708142859b385e21cffab2ae43" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit octal numbers (format &lt;code&gt;o&lt;/code&gt; ) for output.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования 64-битных восьмеричных чисел (формат &lt;code&gt;o&lt;/code&gt; ) для вывода.</target>
        </trans-unit>
        <trans-unit id="cd3924c1c084cb44315833891ddcd4a7eebd0e67" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit octal numbers (format &lt;code&gt;o&lt;/code&gt;) for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6ccb1849bdac1320c428c08feac83669cad758" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit unsigned decimal numbers (format &lt;code&gt;u&lt;/code&gt; ) for output.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования 64-битных десятичных чисел без знака (формат &lt;code&gt;u&lt;/code&gt; ) для вывода.</target>
        </trans-unit>
        <trans-unit id="36f35afe2c30bd98009a97f65964123423bdd4d4" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format 64-bit unsigned decimal numbers (format &lt;code&gt;u&lt;/code&gt;) for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222bb5647e9123694b13cf58d9917c77bccc21a6" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;E&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIeldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования длинных двойников (формат &lt;code&gt;E&lt;/code&gt; ) для вывода. &lt;code&gt;U&lt;/code&gt; в названии, чтобы отделить это от sPRIeldbl , так что даже случай слепые системы могут увидеть разницу.</target>
        </trans-unit>
        <trans-unit id="2050a0f7b3a9a23a52125e530e11a02bf8c893d1" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;E&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIeldbl so that even case-blind systems can see the difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19eff6d51cf0aa4f54340246c25b4fe22c0a7043" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;F&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIfldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования длинных двойников (формат &lt;code&gt;F&lt;/code&gt; ) для вывода. &lt;code&gt;U&lt;/code&gt; в названии, чтобы отделить это от sPRIfldbl , так что даже случай слепые системы могут увидеть разницу.</target>
        </trans-unit>
        <trans-unit id="efe80f269f9289b061bd7dbb22f37e51a19b5e35" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;F&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIfldbl so that even case-blind systems can see the difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d81738452d04eab1f933bf7232ed90f2df15fa" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;G&lt;/code&gt; ) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIgldbl so that even case-blind systems can see the difference.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования длинных двойников (формат &lt;code&gt;G&lt;/code&gt; ) для вывода. &lt;code&gt;U&lt;/code&gt; в названии, чтобы отделить это от sPRIgldbl , так что даже случай слепые системы могут увидеть разницу.</target>
        </trans-unit>
        <trans-unit id="2a784bda71777bc6e4d31dd43bc4e461c72e418f" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;G&lt;/code&gt;) for output. The &lt;code&gt;U&lt;/code&gt; in the name is to separate this from sPRIgldbl so that even case-blind systems can see the difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4115d1a6f75fdc4020d61ac608e2060b9c155a10" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;e&lt;/code&gt; ) for output.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования длинных двойников (формат &lt;code&gt;e&lt;/code&gt; ) для вывода.</target>
        </trans-unit>
        <trans-unit id="700f8e67e02a598e0e54376271db9e1c0a5b8ecb" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;e&lt;/code&gt;) for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01930f22e76b74b59d1c31877d972228ff93ba53" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt; ) for input.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования длинных двойников (формат &lt;code&gt;f&lt;/code&gt; ) для ввода.</target>
        </trans-unit>
        <trans-unit id="9cb55332554b23f3aa4a22de66b9e7bcac1d0693" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt; ) for output.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования длинных двойников (формат &lt;code&gt;f&lt;/code&gt; ) для вывода.</target>
        </trans-unit>
        <trans-unit id="b26dd7a188b2c3657a7c1ed02e3716865b21c9d7" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt;) for input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5544508c61f44a54d0e120abd80b36263a180a3a" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;f&lt;/code&gt;) for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b45d6978a0a0f110d2a827f50454d233b58449" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;g&lt;/code&gt; ) for output.</source>
          <target state="translated">Эта переменная, если она определена, содержит строку, используемую stdio для форматирования длинных двойников (формат &lt;code&gt;g&lt;/code&gt; ) для вывода.</target>
        </trans-unit>
        <trans-unit id="98a82044bd7f333e6bd3f7829751724488d9d452" translate="yes" xml:space="preserve">
          <source>This variable, if defined, contains the string used by stdio to format long doubles (format &lt;code&gt;g&lt;/code&gt;) for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4b2499caf3daffc937f7d1cd2b93bf83f7b0ec" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a double: 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit big little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit big big endian, 3 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big little endian, 4 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big big endian, 5 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big little endian, 6 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big big endian, 7 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big mixed endian le-be, 8 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big mixed endian be-le, -1 = unknown format.</source>
          <target state="translated">Эта переменная, если она определена, кодирует тип двойного байта : 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-битный big little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-битный big big endian, 3 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-битный big little endian, 4 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-битный большой обратный порядок байтов, 5 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-битный большой обратный порядок байтов, 6 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-битный большой обратный порядок байтов, 7 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-битный большой смешанный порядок байтов le-be, 8 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-бит большой смешанный порядок байтов, -1 = неизвестный формат.</target>
        </trans-unit>
        <trans-unit id="c5d4ec9109bfc7e2c8658277ab4e1e7f6b540afd" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a double: 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 32-bit big endian, 3 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit little endian, 4 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit big endian, 5 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit little endian, 6 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big endian, 7 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit mixed endian le-be, 8 = &lt;code&gt;IEEE&lt;/code&gt; 754 64-bit mixed endian be-le, 9 = &lt;code&gt;VAX&lt;/code&gt; 32bit little endian F float format 10 = &lt;code&gt;VAX&lt;/code&gt; 64bit little endian D float format 11 = &lt;code&gt;VAX&lt;/code&gt; 64bit little endian G float format 12 = &lt;code&gt;IBM&lt;/code&gt; 32bit format 13 = &lt;code&gt;IBM&lt;/code&gt; 64bit format 14 = Cray 64bit format -1 = unknown format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1304e84a7f4ed50e62aa480c26a3922856d446" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a long double: 0 = double, 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big big endian, 3 = x86 80-bit little endian, 4 = x86 80-bit big endian, 5 = double-double 128-bit little endian, 6 = double-double 128-bit big endian, -1 = unknown format.</source>
          <target state="translated">Эта переменная, если она определена, кодирует тип long double: 0 = double, 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-битный big little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-битный big big endian, 3 = x86 80-bit little endian, 4 = x86 80-битный прямой порядок байтов, 5 = двойной-двойной 128-битный прямой порядок байтов, 6 = двойной-двойной 128-битный прямой порядок байтов, -1 = неизвестный формат.</target>
        </trans-unit>
        <trans-unit id="cd6a413ce253159d4a0401b9ac379c35750b0045" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a long double: 0 = double, 1 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit little endian, 2 = &lt;code&gt;IEEE&lt;/code&gt; 754 128-bit big endian, 3 = x86 80-bit little endian, 4 = x86 80-bit big endian, 5 = double-double 128-bit little endian, 6 = double-double 128-bit big endian, 7 = 128-bit mixed-endian double-double (64-bit LEs in &lt;code&gt;BE&lt;/code&gt;), 8 = 128-bit mixed-endian double-double (64-bit BEs in &lt;code&gt;LE&lt;/code&gt;), 9 = 128-bit &lt;code&gt;PDP&lt;/code&gt;-style mixed-endian long doubles, -1 = unknown format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a280f8227b0adcb74f96bd4a84586fde60a2c87" translate="yes" xml:space="preserve">
          <source>This variable, if defined, encodes the type of a quad: 1 = int, 2 = long, 3 = long long, 4 = int64_t.</source>
          <target state="translated">Эта переменная,если она определена,кодирует тип квадранта:1=int,2=long,3=long long,4=int64_t.</target>
        </trans-unit>
        <trans-unit id="9d4d7d23fb68dfb0e56a5dbb549631b71c22498b" translate="yes" xml:space="preserve">
          <source>This variable, if defined, tells that there's a 64-bit integer type, quadtype.</source>
          <target state="translated">Эта переменная,если она определена,говорит о том,что существует 64-битный целочисленный тип,квадратип.</target>
        </trans-unit>
        <trans-unit id="2ec4246dee0f43c0b7b758a9ec91d6ccc69de145" translate="yes" xml:space="preserve">
          <source>This variable, indicates that we can use sysctl with &lt;code&gt;KERN_PROC_PATHNAME&lt;/code&gt; to get a full path for the executable, and hence convert $^X to an absolute path.</source>
          <target state="translated">Эта переменная указывает, что мы можем использовать sysctl с &lt;code&gt;KERN_PROC_PATHNAME&lt;/code&gt; , чтобы получить полный путь к исполняемому файлу и, следовательно, преобразовать $ ^ X в абсолютный путь.</target>
        </trans-unit>
        <trans-unit id="4d1ab2f45c88a294e86812741f36b5040a0f8962" translate="yes" xml:space="preserve">
          <source>This venerable module has been the de-facto standard for Perl code profiling for more than a decade, but has been replaced by a number of other modules which have brought us back to the 21st century. Although you're recommended to evaluate your tool from the several mentioned here and from the CPAN list at the base of this document, (and currently &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; seems to be the weapon of choice - see below), we'll take a quick look at the output from &lt;a href=&quot;Devel::DProf&quot;&gt;Devel::DProf&lt;/a&gt; first, to set a baseline for Perl profiling tools. Run the above program under the control of &lt;code&gt;Devel::DProf&lt;/code&gt; by using the &lt;code&gt;-d&lt;/code&gt; switch on the command-line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa78f147d9884daa116a5882818c1ec5ea0dcb5e" translate="yes" xml:space="preserve">
          <source>This venerable module has been the de-facto standard for Perl code profiling for more than a decade, but has been replaced by a number of other modules which have brought us back to the 21st century. Although you're recommended to evaluate your tool from the several mentioned here and from the CPAN list at the base of this document, (and currently &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; seems to be the weapon of choice - see below), we'll take a quick look at the output from &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::DProf&quot;&gt;Devel::DProf&lt;/a&gt; first, to set a baseline for Perl profiling tools. Run the above program under the control of &lt;code&gt;Devel::DProf&lt;/code&gt; by using the &lt;code&gt;-d&lt;/code&gt; switch on the command-line.</source>
          <target state="translated">Этот почтенный модуль был де-факто стандартом для профилирования кода Perl более десяти лет, но был заменен рядом других модулей, которые вернули нас в 21 век. Хотя вам рекомендуется оценить свой инструмент из нескольких упомянутых здесь и из списка CPAN в основе этого документа (и в настоящее время &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf,&lt;/a&gt; кажется, является предпочтительным оружием - см. Ниже), мы возьмем сначала быстро взгляните на вывод &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::DProf&quot;&gt;Devel :: DProf&lt;/a&gt; , чтобы установить базовый уровень для инструментов профилирования Perl. Запустите &lt;code&gt;Devel::DProf&lt;/code&gt; выше программу под управлением Devel :: DProf , используя переключатель &lt;code&gt;-d&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="d8b7da5503989109939012afef8ef4e8d0e19732" translate="yes" xml:space="preserve">
          <source>This version of &lt;b&gt;DB_File&lt;/b&gt; will work with either version 1.x, 2.x or 3.x of Berkeley DB, but is limited to the functionality provided by version 1.</source>
          <target state="translated">Эта версия &lt;b&gt;DB_File&lt;/b&gt; будет работать с версией 1.x, 2.x или 3.x Berkeley DB, но ограничена функциональностью, предоставляемой версией 1.</target>
        </trans-unit>
        <trans-unit id="b0eb508fb3be052a99ae33f92711f88add33b71f" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;Win32API::File&lt;/code&gt; can be used like an &lt;code&gt;IO::File&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abd4acddb66e31e5e1fcc2efdb9ba17579b4d60" translate="yes" xml:space="preserve">
          <source>This version of B::Terse is really just a wrapper that calls &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt; with the &lt;b&gt;-terse&lt;/b&gt; option. It is provided for compatibility with old scripts (and habits) but using B::Concise directly is now recommended instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a150a56d3915850d7ba6874be9e5ac297420d19" translate="yes" xml:space="preserve">
          <source>This version of B::Terse is really just a wrapper that calls &lt;a href=&quot;concise&quot;&gt;B::Concise&lt;/a&gt; with the &lt;b&gt;-terse&lt;/b&gt; option. It is provided for compatibility with old scripts (and habits) but using B::Concise directly is now recommended instead.</source>
          <target state="translated">Эта версия B :: Terse на самом деле просто оболочка, которая вызывает &lt;a href=&quot;concise&quot;&gt;B :: Concise&lt;/a&gt; с опцией &lt;b&gt;-terse&lt;/b&gt; . Он предоставляется для совместимости со старыми скриптами (и привычками), но вместо этого теперь рекомендуется напрямую использовать B :: Concise.</target>
        </trans-unit>
        <trans-unit id="f7beea27edd37499cd6d29dd522284d798300531" translate="yes" xml:space="preserve">
          <source>This version of Storable will defer croaking until it encounters a data type in the file that it does not recognize. This means that it will continue to read files generated by newer Storable modules which are careful in what they write out, making it easier to upgrade Storable modules in a mixed environment.</source>
          <target state="translated">Эта версия Storable отложит перехват до тех пор,пока не столкнется с типом данных в файле,который он не распознает.Это означает,что она будет продолжать читать файлы,сгенерированные новыми модулями Storable,которые осторожны в том,что они записывают,что облегчает обновление модулей Storable в смешанной среде.</target>
        </trans-unit>
        <trans-unit id="5eaf48998d3dac5c6c583e6c7a41844ecc68cbdc" translate="yes" xml:space="preserve">
          <source>This version of Tie::Handle is neither related to nor compatible with the Tie::Handle (3.0) module available on CPAN. It was due to an accident that two modules with the same name appeared. The namespace clash has been cleared in favor of this module that comes with the perl core in September 2000 and accordingly the version number has been bumped up to 4.0.</source>
          <target state="translated">Эта версия Tie::Handle не связана и не совместима с модулем Tie::Handle (3.0),доступным на CPAN.Это произошло в результате несчастного случая,когда появились два модуля с одним и тем же именем.В сентябре 2000 года в пользу этого модуля,который поставляется с ядром perl,было очищено пространство имён и,соответственно,номер версии был увеличен до 4.0.</target>
        </trans-unit>
        <trans-unit id="90d5427fd8fb6285ef2a8069dc284898c742f957" translate="yes" xml:space="preserve">
          <source>This version of Tie::RefHash seems to no longer work with 5.004. This has not been throughly investigated. Patches welcome ;-)</source>
          <target state="translated">Эта версия Tie::RefHash,кажется,больше не работает с 5.004.Это не было тщательно исследовано.Патчи приветствуются ;-)</target>
        </trans-unit>
        <trans-unit id="01f1b71892670e34f133ad330dd4b67c49baabc8" translate="yes" xml:space="preserve">
          <source>This version of libnet requires Perl 5.8.1 or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba74e67d43f1dcfdfea27ea433084f1ae0841f7" translate="yes" xml:space="preserve">
          <source>This version promises absolutely nothing about the internals, which may change without notice. A future version of the module will have a well-defined and stable subclassing API.</source>
          <target state="translated">Эта версия абсолютно ничего не обещает о внутреннем устройстве,которое может измениться без предварительного уведомления.Будущая версия модуля будет иметь четко определенное и стабильное API подклассов.</target>
        </trans-unit>
        <trans-unit id="2c33d1e6335776e46321c7802e91226cd357ca23" translate="yes" xml:space="preserve">
          <source>This very simple command line example demonstrates the streaming capabilities of the module. The code reads data from STDIN, compresses it, and writes the compressed data to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd942caf754c58fe17da1e32e8323477ac4ba5d" translate="yes" xml:space="preserve">
          <source>This warning category was added in the specified Perl version (a development release). Without the &lt;code&gt;'if'&lt;/code&gt; , trying to use it in an earlier release would generate an unknown warning category error.</source>
          <target state="translated">Эта категория предупреждений была добавлена ​​в указанную версию Perl (находящуюся в стадии разработки). Без &lt;code&gt;'if'&lt;/code&gt; попытка использовать его в более ранней версии приведет к возникновению ошибки неизвестной категории предупреждения.</target>
        </trans-unit>
        <trans-unit id="1e633ddd1e5bf36f7ac48a03da45d1264ed96ee5" translate="yes" xml:space="preserve">
          <source>This warning is emitted when you try to store a key or a value that is too long. It means that the change was not recorded in the database. See BUGS AND WARNINGS below.</source>
          <target state="translated">Это предупреждение выдается при попытке сохранить ключ или слишком длинное значение.Это означает,что изменение не было записано в базу данных.См.раздел &quot;БУГГИ И ПРЕДУПРЕЖДЕНИЯ&quot; ниже.</target>
        </trans-unit>
        <trans-unit id="e8cff43243ebcf6f3dd6cc489bc961145ec38b74" translate="yes" xml:space="preserve">
          <source>This warning will not be issued for numerical constants equal to 0 or 1 since they are often used in statements like</source>
          <target state="translated">Это предупреждение не будет выдано для числовых констант,равных 0 или 1,так как они часто используются в таких выражениях,как</target>
        </trans-unit>
        <trans-unit id="fb25267b9628f5c34293586036ece5f10f559c4e" translate="yes" xml:space="preserve">
          <source>This warning will only be issued if the module was loaded from a core library directory, which allows the &lt;code&gt;use deprecate&lt;/code&gt; line to be included in the CPAN version of the module. Because the pragma remains silent when the module is run from a non-core library directory, the pragma call does not need to be patched into or out of either the core or CPAN version of the module. The exact same code can be shipped for either purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88527b08bd7fd0eb304080fa0991400d2de28f89" translate="yes" xml:space="preserve">
          <source>This was a badly misnamed method. It indicates which TODO tests unexpectedly succeeded. Will now issue a warning and call &lt;code&gt;todo_passed&lt;/code&gt; .</source>
          <target state="translated">Это был неправильно названный метод. Он указывает, какие тесты TODO неожиданно завершились успешно. Теперь выдаст предупреждение и вызовет &lt;code&gt;todo_passed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4dc1c03b748cd0f54a6e36b58cd790f7b37d93" translate="yes" xml:space="preserve">
          <source>This was a badly misnamed method. It indicates which TODO tests unexpectedly succeeded. Will now issue a warning and call &lt;code&gt;todo_passed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45cf862902bfae8835d878b4e23a6c4625a4b39" translate="yes" xml:space="preserve">
          <source>This was a long-standing bug that was removed in Perl 5.16, as there was no way to tie the scalar itself when it held a typeglob, and no way to untie a scalar that had had a typeglob assigned to it. If you see this message, you must be using an older version.</source>
          <target state="translated">Это была давняя ошибка,которая была удалена в Perl 5.16,так как не было возможности связать сам скаляр,когда он держал печатный шрифт,и не было возможности развязать скаляр,которому был назначен печатный шрифт.Если вы видите это сообщение,вы должны использовать более старую версию.</target>
        </trans-unit>
        <trans-unit id="aa5539ec182325e9d71ebb4572a22404618af670" translate="yes" xml:space="preserve">
          <source>This was added in 5.18.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73547d5e4f49176fd82dee316a69c227bee73684" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.10.0 and removed in perl 5.23.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6fa0871ce6ad13e934257fa7ce3533e8952e03" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.10.0, but it should be noted there are significant incompatibilities between 5.10.0 and 5.10.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ee83050383416b7e389e9af0ba79674a7563d4" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.10.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0752bb9783d2b9a1a7e76fb203ea820e0ca870c" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.14.0 and removed in perl 5.23.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40fb4feaa26bd467071cbae21a4a30c404f85d3" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.18.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe97e5b827f96bf118c9316e0567cd6e381cc7d" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.20.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80207a7acd3de0a1ba18af490ae7493a04473d7" translate="yes" xml:space="preserve">
          <source>This was added in perl 5.22.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f87b1ac06bc83c2319790f42b388bd0ccadfcd8" translate="yes" xml:space="preserve">
          <source>This was added on perl 5.22.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f651ba658ca750c49bd019c617379c7670ef2f" translate="yes" xml:space="preserve">
          <source>This was admittedly a rather silly example, because you're using string literals whose content is perfectly safe. There is therefore no cause to resort to the harder-to-read, multi-argument form of pipe open(). However, whenever you cannot be assured that the program arguments are free of shell metacharacters, the fancier form of open() should be used. For example:</source>
          <target state="translated">Это был довольно глупый пример,потому что вы используете строковые литералы,содержимое которых совершенно безопасно.Поэтому нет причин прибегать к более трудночитаемой,мульти-аргументной форме функции pipe open().Однако всякий раз,когда вы не можете быть уверены в том,что аргументы программы не содержат мета-символов оболочки,следует использовать более причудливую форму функции open().Например:</target>
        </trans-unit>
        <trans-unit id="52842d3db3182ba8489c9fe305ea59c070b90b44" translate="yes" xml:space="preserve">
          <source>This was broken by a bugfix to how planning is done. The test was updated after the bugfix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adc8016fae975d63e5781a7a173583fad74e2a2" translate="yes" xml:space="preserve">
          <source>This was deprecated in Perl 5.004, and was made fatal in Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad1f59b92c11293a099928bce1ad73cdf53620e" translate="yes" xml:space="preserve">
          <source>This was deprecated in Perl 5.12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8277d13b7b088fe35066777a82bd8877dc5ddaf" translate="yes" xml:space="preserve">
          <source>This was deprecated in Perl 5.14, and the bug was fixed in Perl 5.16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d7dc7d321351f8bc93d1d89d80efcb1109c89d" translate="yes" xml:space="preserve">
          <source>This was needed to compile &lt;code&gt;Perl/Tk&lt;/code&gt; for XFree86-OS/2 out-of-the-box, and link with DLLs for other useful libraries, which typically are compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt; .</source>
          <target state="translated">Это было необходимо для компиляции &lt;code&gt;Perl/Tk&lt;/code&gt; для XFree86-OS / 2 из коробки и компоновки с DLL для других полезных библиотек, которые обычно компилируются с помощью &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba0132f62d3c0837a8cbce3b6e8ada9ff6d8da3a" translate="yes" xml:space="preserve">
          <source>This was needed to compile &lt;code&gt;Perl/Tk&lt;/code&gt; for XFree86-OS/2 out-of-the-box, and link with DLLs for other useful libraries, which typically are compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90e7352745273d9d5fc329cd7b135def60740ad" translate="yes" xml:space="preserve">
          <source>This was once handled by &lt;a href=&quot;Encode::Bytes&quot;&gt;Encode::Bytes&lt;/a&gt; but because of all those unusual specifications, Encode 2.20 has relocated the support to &lt;a href=&quot;Encode::GSM0338&quot;&gt;Encode::GSM0338&lt;/a&gt;. See &lt;a href=&quot;Encode::GSM0338&quot;&gt;Encode::GSM0338&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cfb3fd6b00c8dfb20e9b633295719ddfb3bcde" translate="yes" xml:space="preserve">
          <source>This was once handled by &lt;a href=&quot;Encode::Bytes&quot;&gt;Encode::Bytes&lt;/a&gt; but because of all those unusual specifications, Encode 2.20 has relocated the support to this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833ec61263166849d2a9c2ebdf6cb1d3f6ab0212" translate="yes" xml:space="preserve">
          <source>This was once handled by &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Bytes&quot;&gt;Encode::Bytes&lt;/a&gt; but because of all those unusual specifications, Encode 2.20 has relocated the support to this module.</source>
          <target state="translated">Когда-то это обрабатывалось &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Bytes&quot;&gt;Encode :: Bytes,&lt;/a&gt; но из-за всех этих необычных спецификаций Encode 2.20 переместил поддержку в этот модуль.</target>
        </trans-unit>
        <trans-unit id="673c10b2478f050683d1e4c485023459285fac78" translate="yes" xml:space="preserve">
          <source>This was released in Test::More 0.88 and first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">Он был выпущен в Test::More 0.88 и впервые отправлен с Perl в 5.10.1 в рамках Test::More 0.92.</target>
        </trans-unit>
        <trans-unit id="07e05c78f2530dcd101f922dcc9a65641fe08796" translate="yes" xml:space="preserve">
          <source>This was the method that version.pm adopted as well. Some examples may be helpful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a133adb902d85c6cf121910a483b79ef0cf0ad5" translate="yes" xml:space="preserve">
          <source>This way you ensure that your library really works 100% within Math::BigInt.</source>
          <target state="translated">Таким образом,вы гарантируете,что ваша библиотека действительно работает на 100% в Math::BigInt.</target>
        </trans-unit>
        <trans-unit id="ce6198ece9bfb71059f3d726e5c12d16f2b9fa36" translate="yes" xml:space="preserve">
          <source>This way, we avoid namespace pollution by not creating global variables and we've simplified our code as well.</source>
          <target state="translated">Таким образом,мы избегаем загрязнения пространства имен,не создавая глобальных переменных,а также упростили наш код.</target>
        </trans-unit>
        <trans-unit id="8dbee524f7a0db93b950c3c6b304adf98088982f" translate="yes" xml:space="preserve">
          <source>This way, you can filter on any attribute of the files in the archive. Consult the &lt;code&gt;Archive::Tar::File&lt;/code&gt; documentation on how to use these objects.</source>
          <target state="translated">Таким образом, вы можете фильтровать файлы в архиве по любому атрибуту. Обратитесь к документации &lt;code&gt;Archive::Tar::File&lt;/code&gt; о том, как использовать эти объекты.</target>
        </trans-unit>
        <trans-unit id="035be350abab307537bd4a5157d94ede32ad2db2" translate="yes" xml:space="preserve">
          <source>This way, you'll be forced to declare all your variables with my() and also disallow accidental &quot;symbolic dereferencing&quot;. Therefore if you'd done this:</source>
          <target state="translated">Таким образом,вы будете вынуждены объявить все свои переменные с помощью my(),а также запретить случайные &quot;символические разыменования&quot;.Поэтому,если бы вы сделали это:</target>
        </trans-unit>
        <trans-unit id="4eea9ab96b86c2e70b488d8aa5e8991a1b8d5b3c" translate="yes" xml:space="preserve">
          <source>This where the firewall machine runs an ftp server. This kind of firewall will only let you access ftp servers outside the firewall. This is usually done by connecting to the firewall with ftp, then entering a username like &quot;user@outside.host.com&quot;.</source>
          <target state="translated">Здесь на машине с брандмауэром работает ftp-сервер.Такой брандмауэр позволяет получить доступ только к ftp-серверам за пределами брандмауэра.Обычно это делается путем соединения с брандмауэром с помощью ftp,затем вводится имя пользователя типа &quot;user@outside.host.com&quot;.</target>
        </trans-unit>
        <trans-unit id="35c834ce9b69362e3fd6f7146051fbf20c1d653c" translate="yes" xml:space="preserve">
          <source>This whole affair is quite dangerous, as you may block forever. It assumes it's going to talk to something like &lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc(1)&lt;/a&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc(1)&lt;/a&gt; will read a line at a time and output a line at a time. Programs like &lt;a href=&quot;http://man.he.net/man1/sort&quot;&gt;sort(1)&lt;/a&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b36c3523eae51f237d9a16581fa97335171ca3" translate="yes" xml:space="preserve">
          <source>This whole affair is quite dangerous, as you may block forever. It assumes it's going to talk to something like &lt;b&gt;bc&lt;/b&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;b&gt;bc&lt;/b&gt; will read a line at a time and output a line at a time. Programs like &lt;b&gt;sort&lt;/b&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="translated">Вся эта история довольно опасна, так как вы можете заблокировать ее навсегда. Предполагается, что он будет разговаривать с чем-то вроде &lt;b&gt;bc&lt;/b&gt; , как писать, так и читать из него. Это предположительно безопасно, потому что вы &amp;laquo;знаете&amp;raquo;, что такие команды, как &lt;b&gt;bc,&lt;/b&gt; будут читать строку за раз и выводить строку за раз. Однако такие программы, как &lt;b&gt;sort,&lt;/b&gt; которые сначала читают весь свой входной поток, весьма склонны вызывать тупик.</target>
        </trans-unit>
        <trans-unit id="0f0b5462a666458a41aebef2f79e13773386a813" translate="yes" xml:space="preserve">
          <source>This will arrange to have &lt;code&gt;my_start_hook&lt;/code&gt; called at the start of compiling every lexical scope. The available hooks are:</source>
          <target state="translated">Это позволит вызвать &lt;code&gt;my_start_hook&lt;/code&gt; в начале компиляции каждой лексической области видимости. Доступные крючки:</target>
        </trans-unit>
        <trans-unit id="5676c2e017cdc717b4c080a4e42c0c92fc23cd0b" translate="yes" xml:space="preserve">
          <source>This will be adequate if you ever need to have only one callback registered at any time. An example could be an error handler like the code sketched out above. Remember though, repeated calls to &lt;code&gt;register_fatal&lt;/code&gt; will replace the previously registered callback function with the new one.</source>
          <target state="translated">Этого будет достаточно, если вам когда-либо понадобится зарегистрировать только один обратный вызов в любое время. Примером может служить обработчик ошибок, подобный приведенному выше коду. Помните, однако, что повторные вызовы &lt;code&gt;register_fatal&lt;/code&gt; заменят ранее зарегистрированную функцию обратного вызова новой.</target>
        </trans-unit>
        <trans-unit id="e49ef6980bc11da9126cc73cebced07915750bd4" translate="yes" xml:space="preserve">
          <source>This will be hopefully fixed soon ;)</source>
          <target state="translated">Надеюсь,что вскоре это будет исправлено ;)</target>
        </trans-unit>
        <trans-unit id="84c8586018e16cc8bdba71e80abd032027928904" translate="yes" xml:space="preserve">
          <source>This will be true if the amnesty was granted to a parent event and inherited by this event, which is a child, such as an assertion within a subtest that is marked todo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e10c44561f52b9bb33ad9f3f6e795b031a63516" translate="yes" xml:space="preserve">
          <source>This will be used by Perl to see what flags the regexp was compiled with, this will normally be set to the value of the flags parameter by the &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; callback. See the &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; documentation for valid flags.</source>
          <target state="translated">Это будет использоваться Perl, чтобы увидеть, с какими флагами было скомпилировано регулярное выражение, обычно это значение будет установлено в значение параметра flags с помощью обратного вызова &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; . См. &lt;a href=&quot;#comp&quot;&gt;Действующие&lt;/a&gt; флаги в документации comp .</target>
        </trans-unit>
        <trans-unit id="2bc84788b27f3c38d36164bfbf7f627ab2751e51" translate="yes" xml:space="preserve">
          <source>This will build the default setup that installs under SDK:local/newlib/lib/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930a43d21f4f78037b3a8cd53a181a8ce40027bf" translate="yes" xml:space="preserve">
          <source>This will call &lt;code&gt;$hub-&amp;gt;cull&lt;/code&gt; on all hubs in the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f01a7800d3c6ae7f1d36562ddb036bcb0f3fef" translate="yes" xml:space="preserve">
          <source>This will call &lt;code&gt;process(&quot;arg1&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;80&lt;/code&gt; , &lt;code&gt;process(&quot;arg2&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;72&lt;/code&gt; , and &lt;code&gt;process(&quot;arg3&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;60&lt;/code&gt; .</source>
          <target state="translated">Это вызовет &lt;code&gt;process(&quot;arg1&quot;)&lt;/code&gt; пока &lt;code&gt;$width&lt;/code&gt; равен &lt;code&gt;80&lt;/code&gt; , &lt;code&gt;process(&quot;arg2&quot;)&lt;/code&gt; пока &lt;code&gt;$width&lt;/code&gt; равен &lt;code&gt;72&lt;/code&gt; , и &lt;code&gt;process(&quot;arg3&quot;)&lt;/code&gt; пока &lt;code&gt;$width&lt;/code&gt; равен &lt;code&gt;60&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef8eafab6fdf00c54629025842f72d762c6ae1ee" translate="yes" xml:space="preserve">
          <source>This will call &lt;code&gt;process(&quot;arg1&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;80&lt;/code&gt;, &lt;code&gt;process(&quot;arg2&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;72&lt;/code&gt;, and &lt;code&gt;process(&quot;arg3&quot;)&lt;/code&gt; while &lt;code&gt;$width&lt;/code&gt; is &lt;code&gt;60&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9f81bd2d1f19a3ddd018a3abad8eeb66f3f8eb" translate="yes" xml:space="preserve">
          <source>This will call the callback routine for arg1 and arg2, and then terminate GetOptions() leaving &lt;code&gt;&quot;arg3&quot;&lt;/code&gt; in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">Это вызовет процедуру обратного вызова для arg1 и arg2, а затем завершит GetOptions (), оставив &lt;code&gt;&quot;arg3&quot;&lt;/code&gt; в &lt;code&gt;@ARGV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4cce8e23b1baa9b13a48148de7b04ff8e11c05a" translate="yes" xml:space="preserve">
          <source>This will call the callback routine for arg1 and arg2, and then terminate GetOptions() leaving &lt;code&gt;&quot;arg3&quot;&lt;/code&gt; in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58ac8fe1aff61494f576cce3683a76df1d61d32" translate="yes" xml:space="preserve">
          <source>This will cause &lt;code&gt;TAP::Parser&lt;/code&gt; to pass custom configuration to two of the built- in source handlers - &lt;a href=&quot;TAP::Parser::SourceHandler::Perl&quot;&gt;TAP::Parser::SourceHandler::Perl&lt;/a&gt;, &lt;a href=&quot;TAP::Parser::SourceHandler::File&quot;&gt;TAP::Parser::SourceHandler::File&lt;/a&gt; - and attempt to load the &lt;code&gt;MyCustom&lt;/code&gt; class. See &lt;a href=&quot;TAP::Parser::IteratorFactory#load_handlers&quot;&gt;&quot;load_handlers&quot; in TAP::Parser::IteratorFactory&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1923af4c70dd0486d19861010f7f67dda0840b" translate="yes" xml:space="preserve">
          <source>This will cause &lt;code&gt;TAP::Parser&lt;/code&gt; to pass custom configuration to two of the built- in source handlers - &lt;a href=&quot;parser/sourcehandler/perl&quot;&gt;TAP::Parser::SourceHandler::Perl&lt;/a&gt;, &lt;a href=&quot;parser/sourcehandler/file&quot;&gt;TAP::Parser::SourceHandler::File&lt;/a&gt; - and attempt to load the &lt;code&gt;MyCustom&lt;/code&gt; class. See &lt;a href=&quot;parser/iteratorfactory#load_handlers&quot;&gt;load_handlers in TAP::Parser::IteratorFactory&lt;/a&gt; for more detail.</source>
          <target state="translated">Это заставит &lt;code&gt;TAP::Parser&lt;/code&gt; передать пользовательскую конфигурацию двум встроенным обработчикам исходного кода - &lt;a href=&quot;parser/sourcehandler/perl&quot;&gt;TAP :: Parser :: SourceHandler :: Perl&lt;/a&gt; , &lt;a href=&quot;parser/sourcehandler/file&quot;&gt;TAP :: Parser :: SourceHandler :: File&lt;/a&gt; - и попытаться загрузить класс &lt;code&gt;MyCustom&lt;/code&gt; . . См. &lt;a href=&quot;parser/iteratorfactory#load_handlers&quot;&gt;Load_handlers в TAP :: Parser :: IteratorFactory&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="0b1f393b5aa15620c16e7dffc32aa8ea367c1f0a" translate="yes" xml:space="preserve">
          <source>This will cause Perl with the prebuilt @INC of</source>
          <target state="translated">Это приведет к тому,что Perl со встроенным @INC из</target>
        </trans-unit>
        <trans-unit id="76fec5adda9b5970b64c5f42a2c8bf602e1ee608" translate="yes" xml:space="preserve">
          <source>This will cause the data array ref to be removed, allowing normal garbage collection to clean it up. With AnyEvent, that will cause $data-&amp;gt;[0] to be cleaned up, and AnyEvent will automatically cancel the watcher at that time. If another loop requires more than that to clean up a file watcher, that will be up to the caller to handle.</source>
          <target state="translated">Это приведет к удалению ссылки на массив данных, что позволит обычной сборке мусора очистить его. С AnyEvent это приведет к очистке $ data -&amp;gt; [0], и AnyEvent автоматически отменит наблюдателя в это время. Если другой цикл требует большего, чем это, чтобы очистить наблюдателя за файлами, это будет зависеть от вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="a4504afe5839985c9ade0a7b670cc6581df005e9" translate="yes" xml:space="preserve">
          <source>This will completely remove all hubs from the stack. Normally you do not want to do this, but there are a few valid reasons for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ac58793459c7b76692726a54173eedfed44523" translate="yes" xml:space="preserve">
          <source>This will copy the newly compiled perl and libraries into your DJGPP directory structure. Perl.exe and the utilities go into &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , and the library goes under &lt;code&gt;($DJDIR)/lib/perl5&lt;/code&gt; . The pod documentation goes under &lt;code&gt;($DJDIR)/lib/perl5/pod&lt;/code&gt; .</source>
          <target state="translated">Это скопирует недавно скомпилированный perl и библиотеки в вашу структуру каталогов DJGPP. Perl.exe и утилиты &lt;code&gt;($DJDIR)/bin&lt;/code&gt; в ($ DJDIR) / bin , а библиотека находится в &lt;code&gt;($DJDIR)/lib/perl5&lt;/code&gt; . Документация модуля находится в &lt;code&gt;($DJDIR)/lib/perl5/pod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49d297ec8066b67d0ab35aa053302ca08ef1299d" translate="yes" xml:space="preserve">
          <source>This will copy the newly compiled perl and libraries into your DJGPP directory structure. Perl.exe and the utilities go into &lt;code&gt;($DJDIR)/bin&lt;/code&gt;, and the library goes under &lt;code&gt;($DJDIR)/lib/perl5&lt;/code&gt;. The pod documentation goes under &lt;code&gt;($DJDIR)/lib/perl5/pod&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064ccc6e75634bb34bbc9459a4eee07115444768" translate="yes" xml:space="preserve">
          <source>This will create a new empty stack instance. All arguments are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ded09f0f6527aa84cb6b52847b25c42890b11fc" translate="yes" xml:space="preserve">
          <source>This will create a new thread that will begin execution with the specified entry point function, and give it the</source>
          <target state="translated">При этом создается новый поток,который начнет выполняться с помощью функции указанной точки входа,и присваивает ему параметр</target>
        </trans-unit>
        <trans-unit id="5da6c9768fadd258537254d703795cd0330cf3a4" translate="yes" xml:space="preserve">
          <source>This will create an &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt; object for you. If &lt;code&gt;$bool&lt;/code&gt; is false then an &lt;a href=&quot;Test2::Event::Diag&quot;&gt;Test2::Event::Diag&lt;/a&gt; event will be sent as well with details about the failure. If you do not want automatic diagnostics you should use the &lt;code&gt;send_event()&lt;/code&gt; method directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7feae50769e88d3667c6e843c8c3f60be4ca7ae4" translate="yes" xml:space="preserve">
          <source>This will create objects with numbers stored in two different backend libraries, and &lt;b&gt;VERY BAD THINGS&lt;/b&gt; will happen when you use these together:</source>
          <target state="translated">Это приведет к созданию объектов с номерами, хранящимися в двух разных внутренних библиотеках, и когда вы будете использовать их вместе, произойдет &lt;b&gt;ОЧЕНЬ ПЛОХИЕ ВЕЩИ&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="3b0d8d3754e191837d6089eefe1c10fd8b43be6c" translate="yes" xml:space="preserve">
          <source>This will create the new directory &lt;code&gt;($DJDIR)/Text-CSV-0.01&lt;/code&gt; , filling it with the source for this module.</source>
          <target state="translated">Это создаст новый каталог &lt;code&gt;($DJDIR)/Text-CSV-0.01&lt;/code&gt; , в котором будет помещен исходный код этого модуля.</target>
        </trans-unit>
        <trans-unit id="bbe19c29c1fd71ec20d33df3c3d7fcbef3a7ea1a" translate="yes" xml:space="preserve">
          <source>This will create the new directory &lt;code&gt;($DJDIR)/Text-CSV-0.01&lt;/code&gt;, filling it with the source for this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc361eb19a041a374d3eb78b53745450afadf9b1" translate="yes" xml:space="preserve">
          <source>This will decode the command line arguments to perl (the &lt;code&gt;@ARGV&lt;/code&gt; array) in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0492d7e2f7ae4ff241ecd4e3581f4b8beed997ff" translate="yes" xml:space="preserve">
          <source>This will display a line like this:</source>
          <target state="translated">Здесь будет показана такая строка:</target>
        </trans-unit>
        <trans-unit id="179f02e4ac0dea4bbf8e34372089742f745f888c" translate="yes" xml:space="preserve">
          <source>This will do some preprocessing then run the Configure script for you. The Configure script is interactive, but in most cases you just need to press ENTER. The &quot;set&quot; command ensures that DJGPP preserves the letter case of file names when reading directories. If you already issued this set command when unpacking the archive, and you are in the same DOS session as when you unpacked the archive, you don't have to issue the set command again. This command is necessary *before* you start to (re)configure or (re)build perl in order to ensure both that perl builds correctly and that building XS-type modules can succeed. See the DJGPP info entry for &quot;_preserve_fncase&quot; for more information:</source>
          <target state="translated">Это сделает некоторую препроцессию,а затем запустит для вас скрипт Configure.Сценарий Configure является интерактивным,но в большинстве случаев вам нужно просто нажать ENTER.Команда &quot;set&quot; гарантирует,что DJGPP сохранит буквенный регистр имён файлов при чтении каталогов.Если вы уже выпустили эту команду set при распаковке архива,и вы находитесь в том же самом сеансе DOS,что и при распаковке архива,вам не нужно выпускать команду set снова.Эта команда необходима *перед*началом (re)configure или (re)build perl для того,чтобы убедиться,что perl собирается правильно и сборка модулей типа XS может быть успешной.За более подробной информацией обратитесь к элементу информации DJGPP &quot;_preserve_fncase&quot;:</target>
        </trans-unit>
        <trans-unit id="675c6b6318fd0296508995ff2fb40f1a73999db5" translate="yes" xml:space="preserve">
          <source>This will do the same as the above example, along with printing additional arguments for linking with the &lt;code&gt;Socket&lt;/code&gt; extension.</source>
          <target state="translated">Это будет делать то же, что и в приведенном выше примере, вместе с выводом дополнительных аргументов для связывания с расширением &lt;code&gt;Socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a2b2e485b64f8289df8501ad4445804a71f181" translate="yes" xml:space="preserve">
          <source>This will export the symbols one level 'above' the current package - ie: to the program or module that used package A.</source>
          <target state="translated">При этом будут экспортированы символы одного уровня &quot;выше&quot; текущего пакета-т.е.в программу или модуль,в котором использовался пакет А.</target>
        </trans-unit>
        <trans-unit id="8ac204334b95f4e740c8716e51afe8da1ef03360" translate="yes" xml:space="preserve">
          <source>This will generate a make fragment which runs the @cmds in the given $dir. The rough equivalent to this, except cross platform.</source>
          <target state="translated">Это сгенерирует фрагмент make,который запустит @cmds в данном $dir.Примерный эквивалент,за исключением кросс-платформенности.</target>
        </trans-unit>
        <trans-unit id="c676e0a391005b05f49486f88f52e026b3ba6394" translate="yes" xml:space="preserve">
          <source>This will generate a new hub and push it to the top of the stack. Optionally you can provide arguments that will be passed into the constructor for the &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8e38bf0f1124ee8cd2f4c246969afdbdca1fd0" translate="yes" xml:space="preserve">
          <source>This will generate a perl one-liner safe for the particular platform you're on based on the given $perl_code and @switches (a -e is assumed) suitable for using in a make target. It will use the proper shell quoting and escapes.</source>
          <target state="translated">Это сгенерирует perl однослойный сейф для конкретной платформы,на основе заданного кода $perl_code и @switches (a -e предполагается),подходящих для использования в make target.Он будет использовать правильное цитирование оболочки и экранирования.</target>
        </trans-unit>
        <trans-unit id="2fe60433bffca1c65e9d3e8cf9d5d49faaafa689" translate="yes" xml:space="preserve">
          <source>This will generate code for linking with &lt;code&gt;DynaLoader&lt;/code&gt; and each static extension found in &lt;code&gt;$Config{static_ext}&lt;/code&gt; . The code is written to the default file name</source>
          <target state="translated">Это сгенерирует код для связывания с &lt;code&gt;DynaLoader&lt;/code&gt; и каждым статическим расширением, найденным в &lt;code&gt;$Config{static_ext}&lt;/code&gt; . Код записывается в имя файла по умолчанию</target>
        </trans-unit>
        <trans-unit id="eec7c4e4f5fe3b6790a50a383deab47852630299" translate="yes" xml:space="preserve">
          <source>This will generate code for linking with &lt;code&gt;DynaLoader&lt;/code&gt; and each static extension found in &lt;code&gt;$Config{static_ext}&lt;/code&gt;. The code is written to the default file name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f2639aaf13d9987fd657edd9bdf38a6bb02bde" translate="yes" xml:space="preserve">
          <source>This will generate code with an &lt;code&gt;xs_init&lt;/code&gt; function that glues the perl &lt;code&gt;Socket::bootstrap&lt;/code&gt; function to the C &lt;code&gt;boot_Socket&lt;/code&gt; function and writes it to a file named</source>
          <target state="translated">Это сгенерирует код с функцией &lt;code&gt;xs_init&lt;/code&gt; , которая склеивает функцию perl &lt;code&gt;Socket::bootstrap&lt;/code&gt; функцией C &lt;code&gt;boot_Socket&lt;/code&gt; и записывает ее в файл с именем</target>
        </trans-unit>
        <trans-unit id="44086860d79949a66a99005bb2fd2981ff4af4db" translate="yes" xml:space="preserve">
          <source>This will generate the following subs in your namespace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ad1387b149a78d9ba1b3b7e1d8beb42457553a" translate="yes" xml:space="preserve">
          <source>This will get the value for a specified meta &lt;code&gt;$key&lt;/code&gt;. Normally this will return &lt;code&gt;undef&lt;/code&gt; when there is no value for the &lt;code&gt;$key&lt;/code&gt;, however you can specify a &lt;code&gt;$default&lt;/code&gt; value to set when no value is already set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eea9f6a9a0cddb272db87ac62953e746207d48b" translate="yes" xml:space="preserve">
          <source>This will get the value for a specified meta &lt;code&gt;$key&lt;/code&gt;. This does not have the &lt;code&gt;$default&lt;/code&gt; overhead that &lt;code&gt;meta()&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22691f1210ffc5ff46fde23f10fccdf3bbe7104" translate="yes" xml:space="preserve">
          <source>This will get/set the &lt;code&gt;terminate&lt;/code&gt; attribute. This defaults to undef in scalar context, or an empty list in list context. Setting this to undef will clear it completely. This must be set to a positive integer (0 or larger).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd63235e2a6d84a12c5f4085006a244e21d9d51" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;build_requires&lt;/code&gt; field of your</source>
          <target state="translated">Это войдет в поле &lt;code&gt;build_requires&lt;/code&gt; вашего</target>
        </trans-unit>
        <trans-unit id="b69aab99f02e831fdaf85f1e3ecb658a4bca7288" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;configure_requires&lt;/code&gt; field of your</source>
          <target state="translated">Это войдет в поле &lt;code&gt;configure_requires&lt;/code&gt; вашего</target>
        </trans-unit>
        <trans-unit id="044f8f7fc28b6f913f2eb7261e1be2cd16a84799" translate="yes" xml:space="preserve">
          <source>This will go into the &lt;code&gt;requires&lt;/code&gt; field of your</source>
          <target state="translated">Это будет идти в &lt;code&gt;requires&lt;/code&gt; поле вашего</target>
        </trans-unit>
        <trans-unit id="7b80864e93830ef0ed83edd0adbf1c600a67743b" translate="yes" xml:space="preserve">
          <source>This will hold all the output of a command. It needs to be a reference to a scalar. Note that this will hold both the STDOUT and STDERR messages, and you have no way of telling which is which. If you require this distinction, run the &lt;code&gt;run&lt;/code&gt; command in list context and inspect the individual buffers.</source>
          <target state="translated">Это будет содержать весь вывод команды. Это должна быть ссылка на скаляр. Обратите внимание, что это будет содержать как сообщения STDOUT, так и STDERR, и вы не можете сказать, что есть что. Если вам требуется это различие, запустите команду &lt;code&gt;run&lt;/code&gt; в контексте списка и проверьте отдельные буферы.</target>
        </trans-unit>
        <trans-unit id="02c623985a1a7dc417e0a406fc6886bed2478d0f" translate="yes" xml:space="preserve">
          <source>This will indeed make the value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if you try to modify the value of &lt;code&gt;key&lt;/code&gt; , you'll get the following error:</source>
          <target state="translated">Это действительно сделает значение &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , но если вы попытаетесь изменить значение &lt;code&gt;key&lt;/code&gt; , вы получите следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="32d093230d8afd4dfa30e5b675bc05f84dd94d65" translate="yes" xml:space="preserve">
          <source>This will indeed make the value &lt;code&gt;undef&lt;/code&gt;, but if you try to modify the value of &lt;code&gt;key&lt;/code&gt;, you'll get the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c59ff5ece51fef3713b13fdc203a334520a2680" translate="yes" xml:space="preserve">
          <source>This will indeed remove all references to destroyed objects, but the remaining references to objects will be strong, causing the remaining objects to never be destroyed because there is now always a strong reference to them in the @object array.</source>
          <target state="translated">Это действительно удалит все ссылки на уничтоженные объекты,но оставшиеся ссылки на объекты будут сильными,в результате чего оставшиеся объекты никогда не будут уничтожены,потому что теперь в массиве @object всегда есть сильная ссылка на них.</target>
        </trans-unit>
        <trans-unit id="502a4e7b5c19c4f943e0927f97d4e589d92242b6" translate="yes" xml:space="preserve">
          <source>This will install Perl, including</source>
          <target state="translated">При этом будет установлен Perl,в том числе</target>
        </trans-unit>
        <trans-unit id="5360f0733d6fa5a59167722a15beb5e5d0628299" translate="yes" xml:space="preserve">
          <source>This will install all files in the module under your home directory, with man pages and libraries going into an appropriate place (usually ~/man and ~/lib). How the exact location is determined is complicated and depends on how your Perl was configured. INSTALL_BASE works more like what other build systems call &quot;prefix&quot; than PREFIX and we recommend you use that instead.</source>
          <target state="translated">При этом будут установлены все файлы в модуле под вашим домашним каталогом,а страницы man и библиотеки займут соответствующее место (обычно ~/man и ~/lib).Как будет определено точное местоположение,это сложно и зависит от того,как был настроен ваш Perl.INSTALL_BASE работает больше похоже на то,что другие системы сборки называют &quot;префиксом&quot;,чем PREFIX,и мы рекомендуем использовать его вместо этого.</target>
        </trans-unit>
        <trans-unit id="c93de459956112e67c32897f139a786020e9ae92" translate="yes" xml:space="preserve">
          <source>This will install the module's architecture-independent files into ~/lib, the architecture-dependent files into ~/lib/$archname.</source>
          <target state="translated">Это позволит установить архитектурно-независимые файлы модуля в ~/lib,архитектурно-независимые файлы в ~/lib/$archname.</target>
        </trans-unit>
        <trans-unit id="037930b84c250a860d75497404c0fa5cd777c91f" translate="yes" xml:space="preserve">
          <source>This will invoke &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; . MyExpirePolicy::TIEHASH should do whatever is appropriate to set up the cache, and it should return the cache object to the caller.</source>
          <target state="translated">Это вызовет &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt; . MyExpirePolicy :: TIEHASH должен делать все, что необходимо для настройки кеша, и должен возвращать объект кеша вызывающей стороне.</target>
        </trans-unit>
        <trans-unit id="a5a59c7a890c0f22a657cb40bc1da8408c4952ff" translate="yes" xml:space="preserve">
          <source>This will invoke &lt;code&gt;MyExpirePolicy-&amp;gt;TIEHASH(args)&lt;/code&gt;. MyExpirePolicy::TIEHASH should do whatever is appropriate to set up the cache, and it should return the cache object to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7f85cc213a9528b5fae8654b1de379039b58cd" translate="yes" xml:space="preserve">
          <source>This will invoke the Perl script</source>
          <target state="translated">Это вызовет сценарий на Perl</target>
        </trans-unit>
        <trans-unit id="2d3ad41335ec2699e64793b18bdc830c93f34fd9" translate="yes" xml:space="preserve">
          <source>This will issue a warning from the file and line number of the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7846c6fc3f33f521fafde1ba9db4c27782855d" translate="yes" xml:space="preserve">
          <source>This will likely require many formatters to have tables mapping from treatable Unicode codepoints (such as the &quot;\xE9&quot; for the e-acute character) to the escape sequences or codes necessary for conveying such sequences in the target output format. A converter to *roff would, for example know that &quot;\xE9&quot; (whether conveyed literally, or via a E&amp;lt;...&amp;gt; sequence) is to be conveyed as &quot;e\\*'&quot;. Similarly, a program rendering Pod in a Mac OS application window, would presumably need to know that &quot;\xE9&quot; maps to codepoint 142 in MacRoman encoding that (at time of writing) is native for Mac OS. Such Unicode2whatever mappings are presumably already widely available for common output formats. (Such mappings may be incomplete! Implementers are not expected to bend over backwards in an attempt to render Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any of the other weird things that Unicode can encode.) And if a Pod document uses a character not found in such a mapping, the formatter should consider it an unrenderable character.</source>
          <target state="translated">Это, вероятно, потребует от многих средств форматирования отображения таблиц из обрабатываемых кодовых точек Unicode (таких как &amp;laquo;\ xE9&amp;raquo; для символа e-острого) в управляющие последовательности или коды, необходимые для передачи таких последовательностей в целевом формате вывода. Преобразователь в * roff, например, будет знать, что &quot;\ xE9&quot; (передается буквально или через последовательность E &amp;lt;...&amp;gt;) должен передаваться как &quot;e \\ * '&quot;. Точно так же программе рендеринга Pod в окне приложения Mac OS, по-видимому, необходимо знать, что &amp;laquo;\ xE9&amp;raquo; отображается на кодовую точку 142 в кодировке MacRoman, которая (на момент написания) является родной для Mac OS. Такие отображения Unicode2whatever, по-видимому, уже широко доступны для распространенных выходных форматов. (Такие сопоставления могут быть неполными!От разработчиков не ожидается, что они будут отклоняться назад, пытаясь воспроизвести слоговые символы чероки, этрусские руны, византийские музыкальные символы или любые другие странные вещи, которые может кодировать Unicode.) И если в документе Pod используется символ, не найденный в таком сопоставлении. , форматтер должен рассматривать его как неподдающийся воспроизведению символ.</target>
        </trans-unit>
        <trans-unit id="b9af5931254814b66f0bff8fcce1663d48d23196" translate="yes" xml:space="preserve">
          <source>This will load the core of the Getopt::Long module and prepare your program for using it. Most of the actual Getopt::Long code is not loaded until you really call one of its functions.</source>
          <target state="translated">Это загрузит ядро модуля Getopt::Long и подготовит вашу программу к использованию.Большая часть реального кода Getopt::Long не загружается до тех пор,пока вы действительно не вызовете одну из его функций.</target>
        </trans-unit>
        <trans-unit id="84613dc13583c880545edeaa7309fbaf7d904405" translate="yes" xml:space="preserve">
          <source>This will load the necessary things (like BigInt) when they are needed, and automatically.</source>
          <target state="translated">Это загрузит необходимые вещи (например,BigInt),когда они необходимы,и автоматически.</target>
        </trans-unit>
        <trans-unit id="7a6931f78851cb973cc9d65880d16fc9ed754cce" translate="yes" xml:space="preserve">
          <source>This will make a shallow clone of the facet. You may specify fields to override as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8f3b44f04663247b0f9e8a7dffb832852e0f5e" translate="yes" xml:space="preserve">
          <source>This will match all non-Unicode code points, since every one of them is not in Kana. You can use intersection to exclude these, if desired, as this modified example shows:</source>
          <target state="translated">Это будет соответствовать всем пунктам,не относящимся к коду Юникода,так как каждый из них не находится в Кана.При желании вы можете использовать пересечение,чтобы исключить их,как показывает этот измененный пример:</target>
        </trans-unit>
        <trans-unit id="944f02167d664ef9e70480a5d72868212b398166" translate="yes" xml:space="preserve">
          <source>This will match all the digit characters that are in the Thai script.</source>
          <target state="translated">Это будет соответствовать всем цифровым символам,которые есть в тайском сценарии.</target>
        </trans-unit>
        <trans-unit id="99b2cac7ea367f44702a2a2abb89101d039ec9d6" translate="yes" xml:space="preserve">
          <source>This will normally hide the current context for the top hub. If you need to hide the context for a different hub you can pass in the optional &lt;code&gt;$hid&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6273e23b6c541cdfeea4c27da4fef2152f6377e8" translate="yes" xml:space="preserve">
          <source>This will only show up under use strict (another good reason to run under use strict).</source>
          <target state="translated">Это будет отображаться только при использовании строгой (еще одна веская причина,чтобы работать при использовании строгой).</target>
        </trans-unit>
        <trans-unit id="c65fa159bab1e30bba712c2c1e9c30d9ac5133d7" translate="yes" xml:space="preserve">
          <source>This will optimize down to &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , so &lt;code&gt;&quot;bar&quot;&lt;/code&gt; will never be considered (even though the rules say to use a smartmatch on &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ). For an alternation like this, an array ref will work, because this will instigate smartmatching:</source>
          <target state="translated">Это будет оптимизировано до &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , поэтому &lt;code&gt;&quot;bar&quot;&lt;/code&gt; никогда не будет учитываться (даже если правила говорят об использовании смарт-совпадения для &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ). Для подобного изменения будет работать ссылка на массив, потому что это вызовет интеллектуальное сопоставление:</target>
        </trans-unit>
        <trans-unit id="33deb2e289bee882cbf3028d1fec9799baf70dd3" translate="yes" xml:space="preserve">
          <source>This will optimize down to &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, so &lt;code&gt;&quot;bar&quot;&lt;/code&gt; will never be considered (even though the rules say to use a smartmatch on &lt;code&gt;&quot;foo&quot;&lt;/code&gt;). For an alternation like this, an array ref will work, because this will instigate smartmatching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8134855a16c717eaa6422187d170260e57cb1b" translate="yes" xml:space="preserve">
          <source>This will output only the &lt;code&gt;=head2 Algorithm&lt;/code&gt; heading and content within the &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; section. The regexp binding is stronger than the section separator, such that e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53b7fc46cab28aa51967ea901426700557399bc" translate="yes" xml:space="preserve">
          <source>This will pop a hub from the stack, if the hub at the top of the stack does not match the hub you expect (passed in as an argument) it will throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cbe9fcb0b43d3c677dc5305458ee2e62e4a31f" translate="yes" xml:space="preserve">
          <source>This will predeclare all the subroutine whose names are in the list, allowing you to use them without parentheses even before they're declared.</source>
          <target state="translated">Это предопределит все подпрограммы,чьи имена находятся в списке,позволяя вам использовать их без скобок еще до того,как они будут объявлены.</target>
        </trans-unit>
        <trans-unit id="d6c5fdfb9dbf5dd576a4fe59626b53e05f4e7d63" translate="yes" xml:space="preserve">
          <source>This will predeclare all the subroutines whose names are in the list, allowing you to use them without parentheses (as list operators) even before they're declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0485931e797f0d3157ea50aac95b26b852bb2c34" translate="yes" xml:space="preserve">
          <source>This will predeclare all the variables whose names are in the list, allowing you to use them under &quot;use strict&quot;, and disabling any typo warnings.</source>
          <target state="translated">Это предвосхитит все переменные,чьи имена находятся в списке,позволяя использовать их в разделе &quot;use strict&quot;,и отключая любые предупреждения об опечатках.</target>
        </trans-unit>
        <trans-unit id="2ed7ee1155828d2b2b40b29d755792b670ff1874" translate="yes" xml:space="preserve">
          <source>This will print</source>
          <target state="translated">Это будет напечатано</target>
        </trans-unit>
        <trans-unit id="0c513de1733ecd2b8ffce2a2e048c7fdbe91583f" translate="yes" xml:space="preserve">
          <source>This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the result).</source>
          <target state="translated">При этом будет выведено -3,а не -2 (как при делении -5 на 2 и усечении результата).</target>
        </trans-unit>
        <trans-unit id="e88a5abf01aa2eb9eaafc62c5178572c3f0dcb93" translate="yes" xml:space="preserve">
          <source>This will print a grouped list of Perl's functions, like the &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;Perl Functions by Category in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">Это напечатает сгруппированный список функций Perl, таких как &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;функции Perl по категориям в&lt;/a&gt; разделе perlfunc .</target>
        </trans-unit>
        <trans-unit id="e41583327bc9cc32aaa0b02aa5d9186e43155f80" translate="yes" xml:space="preserve">
          <source>This will print a grouped list of Perl's functions, like the &lt;a href=&quot;perlfunc#Perl-Functions-by-Category&quot;&gt;&quot;Perl Functions by Category&quot; in perlfunc&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f3c28ca20ac2a91e7b3a25f9cd8948580e5a8c" translate="yes" xml:space="preserve">
          <source>This will print arguments for linking with &lt;code&gt;libperl&lt;/code&gt; and extensions found in &lt;code&gt;$Config{static_ext}&lt;/code&gt; . This includes libraries found in &lt;code&gt;$Config{libs}&lt;/code&gt; and the first ModuleName.a library for each extension that is found by searching &lt;code&gt;@INC&lt;/code&gt; or the path specified by the &lt;b&gt;-I&lt;/b&gt; option. In addition, when ModuleName.a is found, additional linker arguments are picked up from the</source>
          <target state="translated">Это напечатает аргументы для связывания с &lt;code&gt;libperl&lt;/code&gt; и расширениями, найденными в &lt;code&gt;$Config{static_ext}&lt;/code&gt; . Это включает библиотеки, найденные в &lt;code&gt;$Config{libs}&lt;/code&gt; и первую библиотеку ModuleName.a для каждого расширения, которое можно найти с помощью поиска &lt;code&gt;@INC&lt;/code&gt; или пути, указанного параметром &lt;b&gt;-I&lt;/b&gt; . Кроме того, при обнаружении ModuleName.a дополнительные аргументы компоновщика выбираются из</target>
        </trans-unit>
        <trans-unit id="e1a6cfe75b96e0fdc730bad6aa31b403693c30dc" translate="yes" xml:space="preserve">
          <source>This will print arguments for linking with &lt;code&gt;libperl&lt;/code&gt; and extensions found in &lt;code&gt;$Config{static_ext}&lt;/code&gt;. This includes libraries found in &lt;code&gt;$Config{libs}&lt;/code&gt; and the first ModuleName.a library for each extension that is found by searching &lt;code&gt;@INC&lt;/code&gt; or the path specified by the &lt;b&gt;-I&lt;/b&gt; option. In addition, when ModuleName.a is found, additional linker arguments are picked up from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f60443610a43a49d5ead9ee72728dd61dc61c29" translate="yes" xml:space="preserve">
          <source>This will print only the content of &lt;code&gt;=head1 DESCRIPTION&lt;/code&gt; and the &lt;code&gt;=head2 Introduction&lt;/code&gt; sections, but no other &lt;code&gt;=head2&lt;/code&gt;, and no other &lt;code&gt;=head1&lt;/code&gt; either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672df04456226246b8abe50d62f0bbee0ad0889a" translate="yes" xml:space="preserve">
          <source>This will print out</source>
          <target state="translated">Это будет распечатано</target>
        </trans-unit>
        <trans-unit id="0a53fd47cfa0cb2aa29facae441d5e18a6061c7b" translate="yes" xml:space="preserve">
          <source>This will print out a warning about overwriting Mytest2, but that's okay. Our files are stored in Mytest2/mylib, and will be untouched.</source>
          <target state="translated">Это распечатает предупреждение о перезаписи Mytest2,но ничего страшного.Наши файлы хранятся в Mytest2/mylib и будут нетронуты.</target>
        </trans-unit>
        <trans-unit id="7bed74d2734f7ca79e0f367ce5a29d3b84e44af2" translate="yes" xml:space="preserve">
          <source>This will print...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">Это напечатает:</target>
        </trans-unit>
        <trans-unit id="899924678036d32490097cf13a3010a6c2e916cc" translate="yes" xml:space="preserve">
          <source>This will produce: &quot;&lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &quot;</source>
          <target state="translated">Это даст: &quot; &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="40197f89d9552ed2ed618b0a94d0da9bdd7f768c" translate="yes" xml:space="preserve">
          <source>This will produce: &quot;&lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d8f131a0962cd0151f9af4c7b366b97852fe0c" translate="yes" xml:space="preserve">
          <source>This will push the new hub onto the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e190e6e848eda316c1f8903ac738aaf6f899b4" translate="yes" xml:space="preserve">
          <source>This will put modules into</source>
          <target state="translated">Это позволит вставлять модули в</target>
        </trans-unit>
        <trans-unit id="7f52025f3fd591756e387158d1cd6ccc53bfb3a5" translate="yes" xml:space="preserve">
          <source>This will quote $text so it is interpreted literally in the shell.</source>
          <target state="translated">При этом будет процитирован текст $,так что он интерпретируется буквально в оболочке.</target>
        </trans-unit>
        <trans-unit id="41f7aa0266df2687cdc027e0895ee05c3a8cf995" translate="yes" xml:space="preserve">
          <source>This will release the context. This runs cleanup tasks, and several important hooks. It will also restore &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$@&lt;/code&gt; to what they were when the context was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec316130454262fb9a931304c0dde874c470f8c" translate="yes" xml:space="preserve">
          <source>This will remove the value of a specified meta &lt;code&gt;$key&lt;/code&gt;. The old &lt;code&gt;$val&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07824cc0b4d23c3d3bb1cfda8a48de7d53df4bf2" translate="yes" xml:space="preserve">
          <source>This will reset the state of the incremental parser and will remove the parsed text from the input buffer so far. This is useful after &lt;code&gt;incr_parse&lt;/code&gt; died, in which case the input buffer and incremental parser state is left unchanged, to skip the text parsed so far and to reset the parse state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f61ad8e0b3eb41c5891bbe5a0d386a76431ba8" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;undef&lt;/code&gt; if the relationship cannot be checked, which happens if either event has an incomplete or missing trace. This will return &lt;code&gt;0&lt;/code&gt; if the traces are complete, but do not match. &lt;code&gt;1&lt;/code&gt; will be returned if there is a match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd2b879f129714bea8a682b5294c7417238be95" translate="yes" xml:space="preserve">
          <source>This will return a hashref of facet data. Each facet hash will be a shallow copy of the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59d5228b102dd5cbad2d2e6da168ec6245e7a05" translate="yes" xml:space="preserve">
          <source>This will return a shallow clone of the context. The shallow clone is safe to store for later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe211d3e5a7b27ac06f1bfed9d79529a0b4e0811" translate="yes" xml:space="preserve">
          <source>This will return all the hubs in the stack as a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fa038bab0a35a1278c1028a76b1b599ab2f3c7" translate="yes" xml:space="preserve">
          <source>This will return the</source>
          <target state="translated">Это вернет</target>
        </trans-unit>
        <trans-unit id="3012b886e66f0d66b1233e77e03322a89d9ca8d0" translate="yes" xml:space="preserve">
          <source>This will return the 'about' facet hashref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3892ab0e68676392aba5a3deb55d6e5f3a7a00" translate="yes" xml:space="preserve">
          <source>This will return the 'trace' facet, normally blessed (but this is not enforced when the trace is set using &lt;code&gt;set_trace()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c947246a8100b62a64074ea3ea27340d97e5c57" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2::API::Stack&lt;/a&gt; instance the context used to find the current hub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071d70de3cfed7ceb62bef529de3f7a12de2cf57" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::EventFacet::Trace&quot;&gt;Test2::EventFacet::Trace&lt;/a&gt; instance used by the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1e2a334411bcce7d3ed6759e85d7774c7db84a" translate="yes" xml:space="preserve">
          <source>This will return the &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; instance the context recognizes as the current one to which all events should be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2912d0daea2e211af97d7e1a3ea98a0298d18c0b" translate="yes" xml:space="preserve">
          <source>This will return the filename based on the template but will not open this file. Cannot be used in conjunction with UNLINK set to true. Default is to always open the file to protect from possible race conditions. A warning is issued if warnings are turned on. Consider using the tmpnam() and mktemp() functions described elsewhere in this document if opening the file is not required.</source>
          <target state="translated">Это вернет имя файла,основанное на шаблоне,но не откроет этот файл.Не может использоваться в сочетании с установкой UNLINK в true.По умолчанию всегда открывать файл для защиты от возможных условий гонки.Предупреждение выдается,если оно включено.Рассмотрим возможность использования функций tmpnam()и mktemp(),описанных в другом месте этого документа,если открытие файла не требуется.</target>
        </trans-unit>
        <trans-unit id="5166921abcf19f440f3497ae7dcd12be03f7bc28" translate="yes" xml:space="preserve">
          <source>This will return the global &lt;a href=&quot;Test2::API::Stack&quot;&gt;Test2::API::Stack&lt;/a&gt; instance. If this has not yet been initialized it will be initialized now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a995f385670c66d0da520343be6badafb9165a59" translate="yes" xml:space="preserve">
          <source>This will return the global &lt;a href=&quot;Test2::IPC::Driver&quot;&gt;Test2::IPC::Driver&lt;/a&gt; instance. If this has not yet been initialized it will be initialized now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d642486b0fdba840f586862b0632bdfe7b784cf3" translate="yes" xml:space="preserve">
          <source>This will return the global formatter class. This is not an instance. By default the formatter is set to &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43701025bcaaa97f4c20a7fae8b7f58307dc924" translate="yes" xml:space="preserve">
          <source>This will return the id of the current thread when threads are enabled, otherwise it returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95636615c967951a75f0745e419202e8c181663" translate="yes" xml:space="preserve">
          <source>This will return the key for the facet in the facet data hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82f0a6881fcf3d362a2caae5716b353b8c09bb4" translate="yes" xml:space="preserve">
          <source>This will return the top hub from the stack. If there is no top hub yet this will create it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d0e21b9306afe027cffc8be7eb5a1ef6fdaafd" translate="yes" xml:space="preserve">
          <source>This will return the top hub from the stack. If there is no top hub yet this will return undef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626d4c923543f739ced5a5a4133e42da29976f88" translate="yes" xml:space="preserve">
          <source>This will return true if testing is complete and no other events should be sent. This is useful in things like warning handlers where you might want to turn warnings into events, but need them to start acting like normal warnings when testing is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9e1cf54480f23b5df8c08401a8eff218ed9c89" translate="yes" xml:space="preserve">
          <source>This will return true if the facet should be in a list instead of a single item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058b4ba4b9036eb7bc1ad3260ce86f253167e2de" translate="yes" xml:space="preserve">
          <source>This will return true if the stack and IPC instances have already been initialized. It will return false if they have not. Init happens as late as possible. It happens as soon as a tool requests the IPC instance, the formatter, or the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb834590329aede62a7b1a0c021d221b2c6d004" translate="yes" xml:space="preserve">
          <source>This will run Configure and keep a record:</source>
          <target state="translated">Это запустит &quot;Настройка&quot; и сохранит запись:</target>
        </trans-unit>
        <trans-unit id="af9c0543615ac7cf90353b4a24138697b5df455b" translate="yes" xml:space="preserve">
          <source>This will run the provided codeblock with the args in &lt;code&gt;@args&lt;/code&gt;. This codeblock will be run as a subtest. A subtest is an isolated test state that is condensed into a single &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event, which contains all events generated inside the subtest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec88525a1d6ccafa3d30457de14d7bad4de11c0" translate="yes" xml:space="preserve">
          <source>This will search for a module named &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; , or failing that, &lt;code&gt;MyPlugin&lt;/code&gt; . If the plugin can't be found, &lt;code&gt;prove&lt;/code&gt; will complain &amp;amp; exit.</source>
          <target state="translated">Это будет искать модуль с именем &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt; или, если это не &lt;code&gt;MyPlugin&lt;/code&gt; , MyPlugin . Если плагин не может быть найден, &lt;code&gt;prove&lt;/code&gt; пожалуется и выйдет.</target>
        </trans-unit>
        <trans-unit id="5e687f1f0bf9f59f044484eb486936cdf9e849ac" translate="yes" xml:space="preserve">
          <source>This will search for a module named &lt;code&gt;App::Prove::Plugin::MyPlugin&lt;/code&gt;, or failing that, &lt;code&gt;MyPlugin&lt;/code&gt;. If the plugin can't be found, &lt;code&gt;prove&lt;/code&gt; will complain &amp;amp; exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30c710e3d8112c1044077c8cf0f284dc043fe97" translate="yes" xml:space="preserve">
          <source>This will send and return an &lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2::Event::Pass&lt;/a&gt; event. You may optionally provide a &lt;code&gt;$name&lt;/code&gt; for the assertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6032dd11dd54e4e97302369ddf59357d7575753c" translate="yes" xml:space="preserve">
          <source>This will set &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$@&lt;/code&gt; to what they were when the context was created. There is no localization or anything done here, calling this method will actually set these vars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53857214badcaa71270373a4350b085fd3be23d6" translate="yes" xml:space="preserve">
          <source>This will set the value, but it will also warn you that the method is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2435be0f1ad6eda0969960399156643c76c7a4" translate="yes" xml:space="preserve">
          <source>This will silence warnings from this module, as shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca31d9fb831c9a9410b0952a2719e1cdb223f34f" translate="yes" xml:space="preserve">
          <source>This will simply return the boolean value of the loaded flag. If Test2 has finished loading this will be true, otherwise false. Loading is considered complete the first time a tool requests a context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d8c906bb8ef849bacade7aef9b4a5b44d353f1" translate="yes" xml:space="preserve">
          <source>This will still print 10, not 20. Remember that local() affects package variables, which are all &quot;global&quot; to the package.</source>
          <target state="translated">Это все равно напечатает 10,а не 20.Помните,что функция local()влияет на переменные пакета,которые все являются &quot;глобальными&quot; для пакета.</target>
        </trans-unit>
        <trans-unit id="2a6fcacb9fbe4a51fd646facf84bbf9e55589d63" translate="yes" xml:space="preserve">
          <source>This will terminate if the file is undeletable for some reason (protected, not there, and so on).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feff36db777feae7b7039051928fb49050eaab4e" translate="yes" xml:space="preserve">
          <source>This will terminate if the file is undeleteable for some reason (protected, not there, and so on).</source>
          <target state="translated">Это прекратится,если файл по какой-то причине недоступен для использования (защищен,не там и т.д.).</target>
        </trans-unit>
        <trans-unit id="7ffb822c298702a56540cec9f5d17292e8f99429" translate="yes" xml:space="preserve">
          <source>This will throw an exception reporting to the file and line number of the context. This will also release the context for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d039d7ba20b83e75e45e1330e7ddf21cf6828e15" translate="yes" xml:space="preserve">
          <source>This will try to load a module &lt;code&gt;ExtUtils::Typemaps::Excommunicated&lt;/code&gt; and use it as an &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; subclass. If that fails, it'll try loading &lt;code&gt;Excommunicated&lt;/code&gt; as a module, if that fails, it'll try to read a file called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd914f7804d4417b7bb5813b67988d44deeaf55" translate="yes" xml:space="preserve">
          <source>This will try to read &lt;code&gt;&quot;unicore/pro_alias.pl&quot;&lt;/code&gt; from the &lt;code&gt;@INC&lt;/code&gt; path. This file should return a list in plain perl:</source>
          <target state="translated">Это попытается прочитать &lt;code&gt;&quot;unicore/pro_alias.pl&quot;&lt;/code&gt; из пути &lt;code&gt;@INC&lt;/code&gt; . Этот файл должен возвращать список на простом языке Perl:</target>
        </trans-unit>
        <trans-unit id="77f2b91fc53461e4232392b6bf05a6cab13fc62c" translate="yes" xml:space="preserve">
          <source>This will turn off result long-term storage. Calling this method will make &lt;code&gt;details&lt;/code&gt; and &lt;code&gt;summary&lt;/code&gt; useless. You may want to use this if you are running enough tests to fill up all available memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ef65510ce174baa0db67a974cf806364df6c54" translate="yes" xml:space="preserve">
          <source>This will unblock any thread that is blocked trying to &lt;code&gt;down&lt;/code&gt; the semaphore if the &lt;code&gt;up&lt;/code&gt; raises the semaphore's count above the amount that the &lt;code&gt;down&lt;/code&gt; is trying to decrement it by. For example, if three threads are blocked trying to &lt;code&gt;down&lt;/code&gt; a semaphore by one, and another thread &lt;code&gt;up&lt;/code&gt; s the semaphore by two, then two of the blocked threads (which two is indeterminate) will become unblocked.</source>
          <target state="translated">Это разблокирует любой поток, который заблокирован, пытаясь &lt;code&gt;down&lt;/code&gt; семафор, если &lt;code&gt;up&lt;/code&gt; увеличивает счетчик семафора выше суммы, на которую &lt;code&gt;down&lt;/code&gt; пытается уменьшить его. Например, если три потока заблокированы, пытаясь &lt;code&gt;down&lt;/code&gt; семафор на один, а другой поток &lt;code&gt;up&lt;/code&gt; семафор на два, то два из заблокированных потоков (два из которых являются неопределенными) станут разблокированными.</target>
        </trans-unit>
        <trans-unit id="2291862c9d641fb23bcd9328e8bf9135209ce8c7" translate="yes" xml:space="preserve">
          <source>This will unblock any thread that is blocked trying to &lt;code&gt;down&lt;/code&gt; the semaphore if the &lt;code&gt;up&lt;/code&gt; raises the semaphore's count above the amount that the &lt;code&gt;down&lt;/code&gt; is trying to decrement it by. For example, if three threads are blocked trying to &lt;code&gt;down&lt;/code&gt; a semaphore by one, and another thread &lt;code&gt;up&lt;/code&gt;s the semaphore by two, then two of the blocked threads (which two is indeterminate) will become unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f351c4b6aca96e53a16da8efca1e61fe6247c18" translate="yes" xml:space="preserve">
          <source>This will use miniperl to complete the rest of the build.</source>
          <target state="translated">При этом будет использоваться miniperl для завершения остальной части строительства.</target>
        </trans-unit>
        <trans-unit id="c16d64a3c76763b9210f27c1d7475ba78b790318" translate="yes" xml:space="preserve">
          <source>This will wait for the corresponding thread to complete its execution. When the thread finishes, &lt;code&gt;-&amp;gt;join()&lt;/code&gt; will return the return value(s) of the entry point function.</source>
          <target state="translated">Это будет ждать, пока соответствующий поток завершит свое выполнение. Когда поток завершится, &lt;code&gt;-&amp;gt;join()&lt;/code&gt; вернет возвращаемое значение (значения) функции точки входа.</target>
        </trans-unit>
        <trans-unit id="2af730ddaf4e289f57edfe5d0943ccf22cf812f6" translate="yes" xml:space="preserve">
          <source>This won't expand &lt;code&gt;&quot;\n&quot;&lt;/code&gt; or &lt;code&gt;&quot;\t&quot;&lt;/code&gt; or any other special escapes.</source>
          <target state="translated">Это не будет расширять &lt;code&gt;&quot;\n&quot;&lt;/code&gt; или &lt;code&gt;&quot;\t&quot;&lt;/code&gt; или любые другие специальные escape-последовательности.</target>
        </trans-unit>
        <trans-unit id="f64d878770a911b3e3aee44ed6986ddc7e345565" translate="yes" xml:space="preserve">
          <source>This work is published from Taiwan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34159428b026fd2a257dac5cc4d16c93aa663f8" translate="yes" xml:space="preserve">
          <source>This workaround is unnecessary since Unicode 6.3.0.</source>
          <target state="translated">Этот обходной путь не нужен,поскольку Юникод 6.3.0.</target>
        </trans-unit>
        <trans-unit id="8c1458dfe63303a12ab8e9dcbe389526ca2f043c" translate="yes" xml:space="preserve">
          <source>This works</source>
          <target state="translated">Это работает</target>
        </trans-unit>
        <trans-unit id="881dcb6cd52e1e6c1fe3d0de8f69b6f16afcd3ed" translate="yes" xml:space="preserve">
          <source>This works because field hashes respond to keys that are not references like a normal hash would and use the string offered as the hash key. Thus, if a method is called as a class method, the field hash is presented with the class name instead of an object and blithely uses it as a key. Since the keys of real objects are decimal numbers, there is no conflict and the slot in the field hash can be used like any other. The &lt;code&gt;id()&lt;/code&gt; function behaves correspondingly with respect to non-reference arguments.</source>
          <target state="translated">Это работает, потому что хэши полей реагируют на ключи, которые не являются ссылками, как обычный хеш, и используют строку, предлагаемую в качестве хеш-ключа. Таким образом, если метод вызывается как метод класса, хэш поля представляется с именем класса вместо объекта и беспечно использует его в качестве ключа. Поскольку ключи реальных объектов являются десятичными числами, конфликта нет, и слот в поле hash можно использовать как любой другой. Функция &lt;code&gt;id()&lt;/code&gt; ведет себя соответствующим образом по отношению к не ссылочным аргументам.</target>
        </trans-unit>
        <trans-unit id="37aaa803ee7c99ec4174d78cf82dc91b9204b890" translate="yes" xml:space="preserve">
          <source>This works by doing overriding methods on the singleton, and directly accessing hash values on the singleton. A new version has been released that uses the Test2 API to accomplish the same result in a saner way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fd9a4f981e792862c2c1c34299d3c036119504" translate="yes" xml:space="preserve">
          <source>This works by invoking the &lt;code&gt;FREEZE&lt;/code&gt; method on the object, with the first argument being the object to serialise, and the second argument being the constant string &lt;code&gt;JSON&lt;/code&gt; to distinguish it from other serialisers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee37bc8498bec33db688cccd48192a7818024c7e" translate="yes" xml:space="preserve">
          <source>This works even if the package variable has not been used before, as package variables spring into existence when first used.</source>
          <target state="translated">Это работает,даже если переменная пакета ранее не использовалась,так как переменные пакета появляются при первом использовании.</target>
        </trans-unit>
        <trans-unit id="2dd7e5f2596a2fbf8c9fd904eb776f4f1a29ce3e" translate="yes" xml:space="preserve">
          <source>This works exactly like calling &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; . This can be very useful for writing dynamic code. For example, it allows you to pass a method name to be called as a parameter to another method.</source>
          <target state="translated">Это работает точно так же, как вызов &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt; . Это может быть очень полезно для написания динамического кода. Например, он позволяет передавать имя вызываемого метода в качестве параметра другому методу.</target>
        </trans-unit>
        <trans-unit id="c16f7da148af11cbf671d895e51f5a7793076850" translate="yes" xml:space="preserve">
          <source>This works exactly like calling &lt;code&gt;$file-&amp;gt;save()&lt;/code&gt;. This can be very useful for writing dynamic code. For example, it allows you to pass a method name to be called as a parameter to another method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5594cfec5e61454de66a12e73e2e1b179cf923ba" translate="yes" xml:space="preserve">
          <source>This works if the dereference produces a string</source>
          <target state="translated">Это работает,если разыменование производит строку</target>
        </trans-unit>
        <trans-unit id="38266e487c0f4fb0b669611ed55fd5e57c3bf09c" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;/bin/tar&lt;/code&gt;'s &lt;code&gt;-h&lt;/code&gt; option.</source>
          <target state="translated">Это работает так же , как &lt;code&gt;/bin/tar&lt;/code&gt; &amp;laquo;s &lt;code&gt;-h&lt;/code&gt; вариант.</target>
        </trans-unit>
        <trans-unit id="f4db4f1dcef0abf193caecabc91b1d8ec192b619" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;new_from_file&lt;/code&gt;, except that a handle can be provided as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219577552fb5335aa48c2b04bb85269685e4f05b" translate="yes" xml:space="preserve">
          <source>This works just like &lt;code&gt;parse_file&lt;/code&gt; except that it reads the Pod content not from a file, but from a string that you have already in memory.</source>
          <target state="translated">Это работает так же, как &lt;code&gt;parse_file&lt;/code&gt; , за исключением того, что он читает содержимое Pod не из файла, а из строки, которая у вас уже есть в памяти.</target>
        </trans-unit>
        <trans-unit id="97ee63f99fe6452186fce78a0713bcb1bd8591fa" translate="yes" xml:space="preserve">
          <source>This works just like patching anything else, with one extra consideration.</source>
          <target state="translated">Это работает так же,как и латание всего остального,с одним дополнительным соображением.</target>
        </trans-unit>
        <trans-unit id="038f2b08f3729bf9e55b6c7536286beb304119b2" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; described in &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00aef65607bdbfd4bbca8fcf5fc5917d56249a8" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; described in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line.</source>
          <target state="translated">Это работает так же, как &amp;lt;$ fh&amp;gt;, описанное в &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;разделе &amp;laquo;Операторы ввода-вывода в perlop&amp;raquo;,&lt;/a&gt; за исключением того, что он более читабелен и может быть безопасно вызван в контексте списка, но по-прежнему возвращает только одну строку.</target>
        </trans-unit>
        <trans-unit id="dcebba3c0143d6834639907ecbbcce5227295c40" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$fh&amp;gt; when called in a list context to read all the remaining lines in a file, except that it's more readable. It will also croak() if accidentally called in a scalar context.</source>
          <target state="translated">Это работает как &amp;lt;$ fh&amp;gt; при вызове в контексте списка для чтения всех оставшихся строк в файле, за исключением того, что это более читабельно. Он также будет croak () при случайном вызове в скалярном контексте.</target>
        </trans-unit>
        <trans-unit id="7450c62face5ca7b9e02c283184e4738197040fb" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; described in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line. If used as the conditional +within a &lt;code&gt;while&lt;/code&gt; or C-style &lt;code&gt;for&lt;/code&gt; loop, however, you will need to +emulate the functionality of &amp;lt;$io&amp;gt; with &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;($_ = $io-&amp;gt;getline)&lt;/code&gt; .</source>
          <target state="translated">Это работает так же, как &amp;lt;$ io&amp;gt;, описанное в &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;разделе &amp;laquo;Операторы ввода-вывода в perlop&amp;raquo;,&lt;/a&gt; за исключением того, что он более читабелен и может безопасно вызываться в контексте списка, но по-прежнему возвращает только одну строку. Однако, если используется в качестве условного + внутри цикла &lt;code&gt;while&lt;/code&gt; или &lt;code&gt;for&lt;/code&gt; в стиле C , вам необходимо + эмулировать функциональность &amp;lt;$ io&amp;gt; с помощью &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;($_ = $io-&amp;gt;getline)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3495f3db5c4d1d0c89019c28aef54ca3210b08f0" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; described in &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt; except that it's more readable and can be safely called in a list context but still returns just one line. If used as the conditional within a &lt;code&gt;while&lt;/code&gt; or C-style &lt;code&gt;for&lt;/code&gt; loop, however, you will need to emulate the functionality of &amp;lt;$io&amp;gt; with &lt;code&gt;defined($_ = $io-&amp;gt;getline)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8787e54def79a3f32ab71769162cbf50a0d2256" translate="yes" xml:space="preserve">
          <source>This works like &amp;lt;$io&amp;gt; when called in a list context to read all the remaining lines in a file, except that it's more readable. It will also croak() if accidentally called in a scalar context.</source>
          <target state="translated">Это работает как &amp;lt;$ io&amp;gt; при вызове в контексте списка для чтения всех оставшихся строк в файле, за исключением того, что он более читабелен. Он также будет croak () при случайном вызове в скалярном контексте.</target>
        </trans-unit>
        <trans-unit id="2bc655ffdbbb7b5de088685237be5925d7bbe434" translate="yes" xml:space="preserve">
          <source>This works like &lt;code&gt;implicate_supers&lt;/code&gt; except that the implicated forms are added to the end of the return list.</source>
          <target state="translated">Это работает как &lt;code&gt;implicate_supers&lt;/code&gt; за исключением того, что подразумеваемые формы добавляются в конец списка возврата.</target>
        </trans-unit>
        <trans-unit id="86cdc5ca018e3bf7bd5f95614dd661c8b598198f" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 AUTHOR\n\nParagraph...\n&quot; section, assuming that that section isn't terribly long. To recognize a &quot;=head1 Author\n\nParagraph\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">Это работает как get_title, за исключением того, что возвращает содержимое раздела &quot;= head1 AUTHOR \ n \ nParagraph ... \ n&quot;, если предположить, что этот раздел не очень длинный. Чтобы распознать раздел &quot;= head1 Author \ n \ nParagraph \ n&quot;, передайте параметр &lt;code&gt;nocase&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="64a77cc5fc2dfee3e1cafa417d88e53b294176fe" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 DESCRIPTION\n\nParagraph...\n&quot; section, assuming that that section isn't terribly long. To recognize a &quot;=head1 Description\n\nParagraph\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">Это работает как get_title, за исключением того, что возвращает содержимое раздела &quot;= head1 DESCRIPTION \ n \ nParagraph ... \ n&quot;, при условии, что этот раздел не слишком длинный. Чтобы распознать раздел &quot;= head1 Description \ n \ nParagraph \ n&quot;, передайте параметр &lt;code&gt;nocase&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="26df8521ce0593af395e7709eafe289696c2f1f5" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 VERSION\n\n[BIG BLOCK]\n&quot; block. Note that this does NOT return the module's &lt;code&gt;$VERSION&lt;/code&gt; !! To recognize a &quot;=head1 Version\n\n[BIG BLOCK]\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="translated">Это работает как get_title, за исключением того, что возвращает содержимое блока &quot;= head1 VERSION \ n \ n [BIG BLOCK] \ n&quot;. Обратите внимание, что это НЕ возвращает &lt;code&gt;$VERSION&lt;/code&gt; модуля !! Чтобы распознать раздел &quot;= head1 Version \ n \ n [BIG BLOCK] \ n&quot;, передайте параметр &lt;code&gt;nocase&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8a823c0684b5208934f648973411ba95381fb432" translate="yes" xml:space="preserve">
          <source>This works like get_title except that it returns the contents of the &quot;=head1 VERSION\n\n[BIG BLOCK]\n&quot; block. Note that this does NOT return the module's &lt;code&gt;$VERSION&lt;/code&gt;!! To recognize a &quot;=head1 Version\n\n[BIG BLOCK]\n&quot; section, pass the &lt;code&gt;nocase&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5587967553798e28442ad51621f624abf3a3ff5" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;decode&lt;/code&gt; method, but instead of raising an exception when there is trailing garbage after the first JSON object, it will silently stop parsing there and return the number of characters consumed so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0009c0f22b1f9b3091524f0133e652a04ae0337e" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;strict_type&lt;/code&gt; option you can pass to &lt;code&gt;check&lt;/code&gt; , which will turn on &lt;code&gt;strict_type&lt;/code&gt; globally for all calls to &lt;code&gt;check&lt;/code&gt; .</source>
          <target state="translated">Это работает как опция &lt;code&gt;strict_type&lt;/code&gt; ,которую вы можете передать для &lt;code&gt;check&lt;/code&gt; , которая включит &lt;code&gt;strict_type&lt;/code&gt; глобально для всех вызовов для &lt;code&gt;check&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58a60db99fd5287a02afd89bdfd44fadadefdf30" translate="yes" xml:space="preserve">
          <source>This works like the &lt;code&gt;strict_type&lt;/code&gt; option you can pass to &lt;code&gt;check&lt;/code&gt;, which will turn on &lt;code&gt;strict_type&lt;/code&gt; globally for all calls to &lt;code&gt;check&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362f494acfae36c73643784bd959c4c06fb6c5c4" translate="yes" xml:space="preserve">
          <source>This works most like other language's behavior when you specify a prefix. We recommend this method.</source>
          <target state="translated">Это больше всего похоже на поведение другого языка,когда вы указываете префикс.Мы рекомендуем этот метод.</target>
        </trans-unit>
        <trans-unit id="915aba858aed251bdf66e2831b7666e6978faed3" translate="yes" xml:space="preserve">
          <source>This works only on 5.10+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b95f28c493942c265a9070f59ae310c120e01c" translate="yes" xml:space="preserve">
          <source>This works under Unix and Windows, and the current version doesn't look half as bad under Windows as it used to. Some of the gui elements still don't 'feel' quite right, though. The interface is very natural and 'perlish', making it easy to use in small scripts that just need a simple gui. It hasn't been updated in a while.</source>
          <target state="translated">Это работает под Unix и Windows,и текущая версия не выглядит наполовину хуже под Windows,чем раньше.Однако некоторые элементы gui все еще не 'чувствуют' себя вполне правильно.Интерфейс очень естественный и &quot;перлиш&quot;,что делает его простым в использовании в небольших скриптах,которым просто нужен простой gui.Давно он не обновлялся.</target>
        </trans-unit>
        <trans-unit id="455be4bb715491d8c40b42c1f8dcc680c608eb5f" translate="yes" xml:space="preserve">
          <source>This works well, and means that XS authors can gleefully write:</source>
          <target state="translated">Это хорошо работает и означает,что авторы XS могут с радостью писать:</target>
        </trans-unit>
        <trans-unit id="b707b9d283df75f490a344769164044f8e4c5af9" translate="yes" xml:space="preserve">
          <source>This works with leading special strings, dynamically determined:</source>
          <target state="translated">Это работает с ведущими специальными струнами,динамически определяемыми:</target>
        </trans-unit>
        <trans-unit id="ff04426d22726a3d4a81073dac982b940cab46f5" translate="yes" xml:space="preserve">
          <source>This would install the complete distribution file (say BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would like to install version 1.23_90, you need to know where the distribution file resides on CPAN relative to the authors/id/ directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz; so you would have to say</source>
          <target state="translated">При этом будет установлен полный дистрибутивный файл (скажем,BAR/Foo-1.23.tar.gz)со всеми сопроводительными материалами.Но если вы хотите установить версию 1.23_90,вам нужно знать,где находится файл дистрибутива на CPAN относительно каталога авторов/id/.Если автор BAR,то это может быть BAR/Foo-1.23_90.tar.gz;так что вы должны будете сказать</target>
        </trans-unit>
        <trans-unit id="56ee25d704c11c02d7362a5e6635fcc0e634817b" translate="yes" xml:space="preserve">
          <source>This would make &lt;code&gt;Carp&lt;/code&gt; report the error as coming from a caller not in &lt;code&gt;My::Carping::Package&lt;/code&gt; , nor from &lt;code&gt;My::Friendly::Caller&lt;/code&gt; .</source>
          <target state="translated">Это заставит &lt;code&gt;Carp&lt;/code&gt; сообщить об ошибке как от вызывающей стороны не из &lt;code&gt;My::Carping::Package&lt;/code&gt; , ни от &lt;code&gt;My::Friendly::Caller&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019ec406a64daebd498d30d29f05ac3a5a5def69" translate="yes" xml:space="preserve">
          <source>This would make &lt;code&gt;Carp&lt;/code&gt; report the error as coming from a caller not in &lt;code&gt;My::Carping::Package&lt;/code&gt;, nor from &lt;code&gt;My::Friendly::Caller&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891cab2fd452efda8a6a8bb2376fc567d9984ca2" translate="yes" xml:space="preserve">
          <source>This would match a line of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1a277e3dce80fb2a8014b20af5fd4775d02c21" translate="yes" xml:space="preserve">
          <source>This would produce.</source>
          <target state="translated">Это бы произвело.</target>
        </trans-unit>
        <trans-unit id="d3b8e94b68c600a8d4a422c5367048147e22fdaf" translate="yes" xml:space="preserve">
          <source>This would signal to the parser that paragraphs in this begin...end region are subject to normal handling as ordinary/verbatim paragraphs (while still tagged as meant only for processors that understand the &quot;biblio&quot; identifier). The same effect could be had with:</source>
          <target state="translated">Это послужит сигналом парсеру о том,что параграфы в этой начальной...конечной области подлежат нормальной обработке как обычные/вербатичные параграфы (хотя они все еще помечены как предназначенные только для процессоров,которые понимают идентификатор &quot;библиографии&quot;).То же самое можно было бы сделать и с:</target>
        </trans-unit>
        <trans-unit id="15fd697862c8639869e1e78b476a5aeed8efb2ef" translate="yes" xml:space="preserve">
          <source>This would start</source>
          <target state="translated">Это началось бы</target>
        </trans-unit>
        <trans-unit id="00bebdd1c33f014f6c6f83be97cd8f7afa9c4c0a" translate="yes" xml:space="preserve">
          <source>This wrapping happens always when compiling Perl core source (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined). When compiling XS code outside of Perl core the wrapping does not take place. Note, however, that intermixing the _r-forms (as Perl compiled for multithreaded operation will do) and the _r-less forms is neither well-defined (inconsistent results, data corruption, or even crashes become more likely), nor is it very portable.</source>
          <target state="translated">Эта обёртка всегда происходит при компиляции исходного ядра Perl (определяется PERL_CORE)или расширений ядра Perl (определяется PERL_EXT).При компиляции XS кода вне ядра Perl обертка не происходит.Обратите внимание,однако,что перемешивание _r-форм (как это делает Perl,скомпилированный для многопоточной работы)и _r-бесплатных форм не является ни четко определенным (противоречивые результаты,повреждение данных или даже падения становятся более вероятными),ни очень переносимым.</target>
        </trans-unit>
        <trans-unit id="d0e68ab8f02ae3faa0396a3a11b0f81dcf6b0685" translate="yes" xml:space="preserve">
          <source>This wrapping happens always when compiling Perl core source (PERL_CORE is defined) or the Perl core extensions (PERL_EXT is defined). When compiling XS code outside of the Perl core, the wrapping does not take place before Perl 5.28. Starting in that release you can</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e5fcab8c4178b44f80118d0d0e8c790e5ed2e6" translate="yes" xml:space="preserve">
          <source>This zero-width assertion executes any embedded Perl code. It always succeeds, and its return value is set as &lt;code&gt;$^R&lt;/code&gt; .</source>
          <target state="translated">Это утверждение нулевой ширины выполняет любой встроенный код Perl. Он всегда добивается успеха, и его возвращаемое значение устанавливается как &lt;code&gt;$^R&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="037ab5d7d658f9f73dced777295d92918612ab07" translate="yes" xml:space="preserve">
          <source>This zero-width assertion executes any embedded Perl code. It always succeeds, and its return value is set as &lt;code&gt;$^R&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3986864eb1cd79d2d3acbfd270bc8eeed78bdddc" translate="yes" xml:space="preserve">
          <source>This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later &lt;code&gt;(*SKIP)&lt;/code&gt; pattern will then skip forward to that point if backtracked into on failure. Any number of &lt;code&gt;(*MARK)&lt;/code&gt; patterns are allowed, and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018c0e68c94f9f979bcddcd227e8ad92dfe5e9c0" translate="yes" xml:space="preserve">
          <source>This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later &lt;code&gt;(*SKIP)&lt;/code&gt; pattern will then skip forward to that point if backtracked into on failure. Any number of &lt;code&gt;(*MARK)&lt;/code&gt; patterns are allowed, and the NAME portion may be duplicated.</source>
          <target state="translated">Этот шаблон нулевой ширины можно использовать для отметки точки, достигнутой в строке, когда определенная часть шаблона была успешно сопоставлена. Этому знаку можно дать имя. Более поздний шаблон &lt;code&gt;(*SKIP)&lt;/code&gt; затем перейдет к этой точке, если будет выполнен возврат в случае ошибки. Допускается любое количество шаблонов &lt;code&gt;(*MARK)&lt;/code&gt; , а часть NAME может дублироваться.</target>
        </trans-unit>
        <trans-unit id="3e845add8e49d7a0ebfe26e6329051032e10440f" translate="yes" xml:space="preserve">
          <source>This zero-width pattern is similar to &lt;code&gt;(*PRUNE)&lt;/code&gt; , except that on failure it also signifies that whatever text that was matched leading up to the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern being executed cannot be part of</source>
          <target state="translated">Этот шаблон нулевой ширины похож на &lt;code&gt;(*PRUNE)&lt;/code&gt; , за исключением того, что в случае сбоя он также означает, что любой текст, который был сопоставлен до выполнения шаблона &lt;code&gt;(*SKIP)&lt;/code&gt; , не может быть частью</target>
        </trans-unit>
        <trans-unit id="51e4c7fda54787bcde2f76a35e31d235c61d7234" translate="yes" xml:space="preserve">
          <source>This zero-width pattern is similar to &lt;code&gt;(*PRUNE)&lt;/code&gt;, except that on failure it also signifies that whatever text that was matched leading up to the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern being executed cannot be part of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14d48589d384cf0a42c2d25bee216599d01f868" translate="yes" xml:space="preserve">
          <source>This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern &lt;code&gt;/&lt;i&gt;A&lt;/i&gt; (*PRUNE) &lt;i&gt;B&lt;/i&gt;/&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4b9623686b3758cfd382a28c93e0707ac9367e" translate="yes" xml:space="preserve">
          <source>This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern &lt;code&gt;A (*PRUNE) B&lt;/code&gt;, where A and B are complex patterns. Until the &lt;code&gt;(*PRUNE)&lt;/code&gt; verb is reached, A may backtrack as necessary to match. Once it is reached, matching continues in B, which may also backtrack as necessary; however, should B not match, then no further backtracking will take place, and the pattern will fail outright at the current starting position.</source>
          <target state="translated">Этот шаблон нулевой ширины обрезает дерево возврата в текущей точке при возврате в случае ошибки. Рассмотрим шаблон &lt;code&gt;A (*PRUNE) B&lt;/code&gt; , где A и B - сложные шаблоны. До тех &lt;code&gt;(*PRUNE)&lt;/code&gt; пока не будет достигнут глагол (* PRUNE) , A может вернуться назад по мере необходимости для сопоставления. Как только он достигнут, сопоставление продолжается в B, который также может возвращаться при необходимости; однако, если B не совпадает, то дальнейший возврат не будет происходить, и шаблон полностью не сработает в текущей начальной позиции.</target>
        </trans-unit>
        <trans-unit id="6ab6320cf6b57ad1eb41183660b9a012d0721d64" translate="yes" xml:space="preserve">
          <source>Thomas Dorner</source>
          <target state="translated">Томас Дорнер</target>
        </trans-unit>
        <trans-unit id="81e4e8d1869fa873203b699ef2f7c28f0d0f204c" translate="yes" xml:space="preserve">
          <source>Those can be rather inefficient though. If they aren't fast enough for you, you might just read chunks of data and count the number of newlines:</source>
          <target state="translated">Но они могут быть довольно неэффективными.Если они недостаточно быстры для вас,вы можете просто читать куски данных и подсчитывать количество новых строк:</target>
        </trans-unit>
        <trans-unit id="1fd34bde8d27f4db80e364187fff01e57e24dcf5" translate="yes" xml:space="preserve">
          <source>Those debugging perl with the DDD frontend over gdb may find the following useful:</source>
          <target state="translated">Отладочный перл с фронтендом DDD через gdb может оказаться полезным следующим образом:</target>
        </trans-unit>
        <trans-unit id="d8de155d193899f771792e739cfd779f42445bfd" translate="yes" xml:space="preserve">
          <source>Those discouraged forms are accepted as input to &lt;code&gt;prop_aliases&lt;/code&gt; , but are not returned in the lists. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; and &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; , which are old synonyms for &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; and should not be used in new code, are examples of this. These both return &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . Thus this function allows you to take a discouraged form, and find its acceptable alternatives. The same goes with single-form Block property equivalences. Only the forms that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; are not discouraged; if you pass &lt;code&gt;prop_aliases&lt;/code&gt; a discouraged form, you will get back the equivalent ones that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; . It will otherwise look like a new-style block name (see. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">Эти нежелательные формы принимаются в качестве входных данных для &lt;code&gt;prop_aliases&lt;/code&gt; , но не возвращаются в списках. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; и &lt;code&gt;prop_aliases('isL_')&lt;/code&gt; , которые являются старыми синонимами для &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; и не должны использоваться в новом коде, являются примерами этого. Оба они возвращают &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . Таким образом, эта функция позволяет вам принять разочарованную форму и найти приемлемые альтернативы. То же самое и с эквивалентностями свойств блоков в одной форме. Не обескураживают только формы, начинающиеся с &lt;code&gt;&quot;In_&quot;&lt;/code&gt; ; если вы передадите &lt;code&gt;prop_aliases&lt;/code&gt; обескураженную форму, вы получите обратно эквивалентные формы, начинающиеся с &lt;code&gt;&quot;In_&quot;&lt;/code&gt; . В противном случае оно будет выглядеть как имя блока в новом стиле (см. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Сравнение имен блоков в старом и новом стиле&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e7315b6f7527f6cad5c0696c36731171292e6d3" translate="yes" xml:space="preserve">
          <source>Those discouraged forms are accepted as input to &lt;code&gt;prop_aliases&lt;/code&gt;, but are not returned in the lists. &lt;code&gt;prop_aliases('isL&amp;amp;')&lt;/code&gt; and &lt;code&gt;prop_aliases('isL_')&lt;/code&gt;, which are old synonyms for &lt;code&gt;&quot;Is_LC&quot;&lt;/code&gt; and should not be used in new code, are examples of this. These both return &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt;. Thus this function allows you to take a discouraged form, and find its acceptable alternatives. The same goes with single-form Block property equivalences. Only the forms that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt; are not discouraged; if you pass &lt;code&gt;prop_aliases&lt;/code&gt; a discouraged form, you will get back the equivalent ones that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt;. It will otherwise look like a new-style block name (see. &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da17d9bf3cc6c170baa5678aa93a096d0f37e23" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; as a substitute for the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da32d7b6dfc1f76299003b85142b3301014ca18" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; as a substitute for the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">Эти примеры также показывают, что вам не следует пытаться использовать &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; вместо модуля &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a75c1c6107c9c80616709d9370ed7d64d72897ff" translate="yes" xml:space="preserve">
          <source>Those examples also illustrate that you should not try to use &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; as a substitute for the &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; module.</source>
          <target state="translated">Эти примеры также показывают, что вам не следует пытаться использовать &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; вместо модуля &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b7bc94e0db621087dac583856d0104fb7d8c89b" translate="yes" xml:space="preserve">
          <source>Those letters could all be Latin (as in the example just above), or they could be all Cyrillic (except for the dot), or they could be a mixture of the two. In the case of an internet address the &lt;code&gt;.com&lt;/code&gt; would be in Latin, And any Cyrillic ones would cause it to be a mixture, not a script run. Someone clicking on such a link would not be directed to the real Paypal website, but an attacker would craft a look-alike one to attempt to gather sensitive information from the person.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09bb82492fe1deca424636c6f8f129828507429d" translate="yes" xml:space="preserve">
          <source>Those methods which override default MM_Unix methods are marked &quot;(override)&quot;, while methods unique to MM_VMS are marked &quot;(specific)&quot;. For overridden methods, documentation is limited to an explanation of why this method overrides the MM_Unix method; see the &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt; documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956b46dcd2869bcc1ce846f30fe79b6d32253a71" translate="yes" xml:space="preserve">
          <source>Those methods which override default MM_Unix methods are marked &quot;(override)&quot;, while methods unique to MM_VMS are marked &quot;(specific)&quot;. For overridden methods, documentation is limited to an explanation of why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix documentation for more details.</source>
          <target state="translated">Методы,которые переопределяют методы MM_Unix по умолчанию,помечены &quot;(переопределяют)&quot;,в то время как методы,уникальные для MM_VMS,помечены &quot;(специфические)&quot;.Для переопределения методов,документация ограничивается объяснением того,почему этот метод переопределяет метод MM_Unix;подробнее смотрите документацию ExtUtils::MM_Unix.</target>
        </trans-unit>
        <trans-unit id="89694826230f33ec41f3391ad1e9d0ae75075e89" translate="yes" xml:space="preserve">
          <source>Those not usable within a bracketed character class (like &lt;code&gt;[\da-z]&lt;/code&gt; ) are marked as &lt;code&gt;Not in [].&lt;/code&gt;</source>
          <target state="translated">Те, которые нельзя использовать в классах символов в квадратных скобках (например, &lt;code&gt;[\da-z]&lt;/code&gt; ), помечаются как &lt;code&gt;Not in [].&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed08d333f4d7b0ebed9f1e47a113b306b6da0b17" translate="yes" xml:space="preserve">
          <source>Those not usable within a bracketed character class (like &lt;code&gt;[\da-z]&lt;/code&gt;) are marked as &lt;code&gt;Not in [].&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c59400870fdcf39cd37f7130db3cbffeeca3151" translate="yes" xml:space="preserve">
          <source>Those options are explained in &lt;a href=&quot;../man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="translated">Эти параметры описаны в &lt;a href=&quot;../man&quot;&gt;Pod :: Man&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7014dea585b921e6969f68f00359599742e4a3" translate="yes" xml:space="preserve">
          <source>Those options are explained in &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2b5b8ade9f04ee810e0602b2c63da979876bd5" translate="yes" xml:space="preserve">
          <source>Though ISO-8859 does have ISO-8859-5, the KOI8 series is far more popular in the Net. &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; comes with the following KOI charsets. For gory details, see &lt;a href=&quot;http://czyborra.com/charsets/cyrillic.html&quot;&gt;http://czyborra.com/charsets/cyrillic.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d164817730248c36fd41c3d7e8fb0afe7ee263" translate="yes" xml:space="preserve">
          <source>Though Jungshik Shin has reported that Mozilla supports this encoding, it was too late before 5.8.0 for us to add it. In the future, it may be available via a separate module. See &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt; and &lt;a href=&quot;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt; if you are interested in helping us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cc14e3886ee7120dc696463085595dfcc5771f" translate="yes" xml:space="preserve">
          <source>Though Jungshik Shin has reported that Mozilla supports this encoding, it was too late before 5.8.0 for us to add it. In the future, it may be available via a separate module. See &lt;a href=&quot;https://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.uf&lt;/a&gt; and &lt;a href=&quot;https://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&quot;&gt;http://lxr.mozilla.org/seamonkey/source/intl/uconv/ucvlatin/vps.ut&lt;/a&gt; if you are interested in helping us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d24de1d761cc58def056c26e4fb86b5492f71e" translate="yes" xml:space="preserve">
          <source>Though a much better way is to use the &lt;a href=&quot;Test2::Plugin::UTF8&quot;&gt;Test2::Plugin::UTF8&lt;/a&gt; plugin, which is part of &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a06e11acd02f600ac3a6ff09284942503ee656" translate="yes" xml:space="preserve">
          <source>Though forcing an argument into a particular form does not change the stored number, Perl remembers the result of such conversions. In particular, though the first such conversion may be time-consuming, repeated operations will not need to redo the conversion.</source>
          <target state="translated">Хотя принуждение аргумента в определенную форму не изменяет хранимый номер,Perl запоминает результат таких преобразований.В частности,несмотря на то,что первое такое преобразование может занять много времени,повторные операции не потребуют повторного преобразования.</target>
        </trans-unit>
        <trans-unit id="f3be83a9aceb8b170431d7d56170a63bf06c2048" translate="yes" xml:space="preserve">
          <source>Though much can be written about the inconsistency and coverage problems of gcc warnings (like &lt;code&gt;-Wall&lt;/code&gt; not meaning &quot;all the warnings&quot;, or some common portability problems not being covered by &lt;code&gt;-Wall&lt;/code&gt; , or &lt;code&gt;-ansi&lt;/code&gt; and &lt;code&gt;-pedantic&lt;/code&gt; both being a poorly defined collection of warnings, and so forth), gcc is still a useful tool in keeping our coding nose clean.</source>
          <target state="translated">Хотя можно многое написать о проблемах несогласованности и покрытия предупреждений gcc (например, &lt;code&gt;-Wall&lt;/code&gt; не означает &amp;laquo;все предупреждения&amp;raquo;, или некоторые общие проблемы переносимости, не охватываемые &lt;code&gt;-Wall&lt;/code&gt; , либо &lt;code&gt;-ansi&lt;/code&gt; и &lt;code&gt;-pedantic&lt;/code&gt; , оба являются плохо определенной коллекцией предупреждений и т. д.), gcc по-прежнему является полезным инструментом для поддержания чистоты кода.</target>
        </trans-unit>
        <trans-unit id="4faaa6fa5354d5373d44ec1d57892b26bbdbc5ff" translate="yes" xml:space="preserve">
          <source>Though much can be written about the inconsistency and coverage problems of gcc warnings (like &lt;code&gt;-Wall&lt;/code&gt; not meaning &quot;all the warnings&quot;, or some common portability problems not being covered by &lt;code&gt;-Wall&lt;/code&gt;, or &lt;code&gt;-ansi&lt;/code&gt; and &lt;code&gt;-pedantic&lt;/code&gt; both being a poorly defined collection of warnings, and so forth), gcc is still a useful tool in keeping our coding nose clean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419ade92c2c3a75f745587c25bed6b20ff3a2dd8" translate="yes" xml:space="preserve">
          <source>Though this module can be used without any &lt;code&gt;table&lt;/code&gt; file, to use this module easily, it is recommended to install a table file in the UCA format, by copying it under the directory &amp;lt;a place in @INC&amp;gt;/Unicode/Collate.</source>
          <target state="translated">Хотя этот модуль можно использовать без какого-либо файла &lt;code&gt;table&lt;/code&gt; , для упрощения использования этого модуля рекомендуется установить файл таблицы в формате UCA, скопировав его в каталог &amp;lt;a place in @INC&amp;gt; / Unicode / Collate.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="998ceaaad06364c8b6eb7bb906fdf278086c1d9b" translate="yes" xml:space="preserve">
          <source>Thread # terminated abnormally: ...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8bdcbf638d7eb68b070735be885cf9e96d329d" translate="yes" xml:space="preserve">
          <source>Thread - Manipulate threads in Perl (for old code only)</source>
          <target state="translated">Thread-Манипулировать потоками на Perl (только для старого кода)</target>
        </trans-unit>
        <trans-unit id="c918ac60574a68bba66c3da27f233195a15f2b9b" translate="yes" xml:space="preserve">
          <source>Thread Basics</source>
          <target state="translated">Нити Основы</target>
        </trans-unit>
        <trans-unit id="a78e21be0817d13d864f0b6be8854cdfa543bd85" translate="yes" xml:space="preserve">
          <source>Thread ID of this instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe1f739c1cdedc327a9eae1c397ab14c9d64437" translate="yes" xml:space="preserve">
          <source>Thread IDs</source>
          <target state="translated">Резьбовые идентификаторы</target>
        </trans-unit>
        <trans-unit id="898f39e0ee67463e37091c0ab76e5df497814e8b" translate="yes" xml:space="preserve">
          <source>Thread Pitfalls: Races</source>
          <target state="translated">Нитевидные питфоллы:Гонки</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">Безопасность резьбы</target>
        </trans-unit>
        <trans-unit id="d3dbf16992ead48a52867791a62d8b164c67fd1f" translate="yes" xml:space="preserve">
          <source>Thread creation failed: pthread_attr_setstacksize(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe544dd150b465313579f9a917937793103ac16" translate="yes" xml:space="preserve">
          <source>Thread creation failed: pthread_create returned #</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4066c9a805adec4e9141cb77efe0020bace9560" translate="yes" xml:space="preserve">
          <source>Thread objects also have an overloaded &lt;code&gt;==&lt;/code&gt; comparison so that you can do comparison on them as you would with normal objects.</source>
          <target state="translated">Объекты потока также имеют перегруженное сравнение &lt;code&gt;==&lt;/code&gt; , так что вы можете сравнивать их, как и обычные объекты.</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549ccddc66fc92574e2a5d76a4615e0548e5e609" translate="yes" xml:space="preserve">
          <source>Thread support is a Perl compile-time option. It's something that's turned on or off when Perl is built at your site, rather than when your programs are compiled. If your Perl wasn't compiled with thread support enabled, then any attempt to use threads will fail.</source>
          <target state="translated">Поддержка потоков-это опция времени компиляции на Perl.Это то,что включается или выключается,когда Perl собирается на вашем сайте,а не когда ваши программы компилируются.Если ваш Perl не был скомпилирован с включенной поддержкой потоков,то любая попытка использования потоков будет безуспешной.</target>
        </trans-unit>
        <trans-unit id="46bddf5c24ca2d6a4d9042e8357ff7786b5311d0" translate="yes" xml:space="preserve">
          <source>Thread support is not tested in this version of the djgpp perl.</source>
          <target state="translated">Поддержка потоков не тестировалась в этой версии djgpp perl.</target>
        </trans-unit>
        <trans-unit id="c46da741d2999f303803e3f917e3740fdda50340" translate="yes" xml:space="preserve">
          <source>Thread support is not very reliable before 5.10.1, but that's because threads are not very reliable before 5.10.1.</source>
          <target state="translated">Поддержка потоков не очень надежна до 5.10.1,но это потому,что потоки не очень надежны до 5.10.1.</target>
        </trans-unit>
        <trans-unit id="11feb4cfa0751bbfde7a5acce22a835701e10a09" translate="yes" xml:space="preserve">
          <source>Thread-&amp;gt;list</source>
          <target state="translated">Thread-&amp;gt;list</target>
        </trans-unit>
        <trans-unit id="c33ecb12695532db82054d26a0b666a4c71b167c" translate="yes" xml:space="preserve">
          <source>Thread-&amp;gt;self</source>
          <target state="translated">Thread-&amp;gt;self</target>
        </trans-unit>
        <trans-unit id="8fed753691ece692a240fff0998afe0f2ace9f0d" translate="yes" xml:space="preserve">
          <source>Thread-Safe Modules</source>
          <target state="translated">Резьбонадежные модули</target>
        </trans-unit>
        <trans-unit id="7481655dbaa92f6baf98738070e27520e97d079c" translate="yes" xml:space="preserve">
          <source>Thread-Safety of System Libraries</source>
          <target state="translated">Тематическая безопасность системных библиотек</target>
        </trans-unit>
        <trans-unit id="932b17e3a913e7164b20d08cedb16d8eee3d76fc" translate="yes" xml:space="preserve">
          <source>Thread-aware system interfaces</source>
          <target state="translated">Системные интерфейсы с поддержкой технологии Thread-aware</target>
        </trans-unit>
        <trans-unit id="3f487c5ede1faaacb7af8d62cbc07904f78f97b1" translate="yes" xml:space="preserve">
          <source>Thread-safe modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5d3327153c08a2630824ad42fbb1c6c94a74e6" translate="yes" xml:space="preserve">
          <source>Thread-safe operations are supported in Windows starting in Visual Studio 2005, and in systems compatible with POSIX 2008. Some platforms claim to support POSIX 2008, but have buggy implementations, so that the hints files for compiling to run on them turn off attempting to use thread-safety. &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt; will be 0 on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04c2c8f868b7f546d5c03554daa6de042ed3f5f" translate="yes" xml:space="preserve">
          <source>Thread-safe queues</source>
          <target state="translated">Нитробезопасные очереди</target>
        </trans-unit>
        <trans-unit id="6ec24d7d376e4c8018f31c516a824eaf616af734" translate="yes" xml:space="preserve">
          <source>Thread-safe semaphores</source>
          <target state="translated">Нитробезопасные семафоры</target>
        </trans-unit>
        <trans-unit id="1a5d305757aae906720c104f8cc9b46cfea47a9a" translate="yes" xml:space="preserve">
          <source>Thread-safety of extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396f10461adcaf1d700d25868c55c05cc6b1f668" translate="yes" xml:space="preserve">
          <source>Thread::Queue</source>
          <target state="translated">Thread::Queue</target>
        </trans-unit>
        <trans-unit id="a99444903cfd04a299ea92dd5417034d9b8ba995" translate="yes" xml:space="preserve">
          <source>Thread::Queue - Thread-safe queues</source>
          <target state="translated">Очередь::Очередь-Очередь,безопасная для нитей.</target>
        </trans-unit>
        <trans-unit id="762634ef60addc5dc2601bb4e594eccb63b09b78" translate="yes" xml:space="preserve">
          <source>Thread::Queue Discussion Forum on CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Queue&quot;&gt;http://www.cpanforum.com/dist/Thread-Queue&lt;/a&gt;</source>
          <target state="translated">Thread :: Форум обсуждения очередей на CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Queue&quot;&gt;http://www.cpanforum.com/dist/Thread-Queue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e095a6673757f69a6701a64b890923c021a33f37" translate="yes" xml:space="preserve">
          <source>Thread::Queue on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/Thread-Queue&quot;&gt;https://metacpan.org/release/Thread-Queue&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0074185a9ba92a372e711b37e0503d776af40535" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore</source>
          <target state="translated">Thread::Semaphore</target>
        </trans-unit>
        <trans-unit id="5153c71809c73fa56e9f450e40e65e39c3a75a98" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore - Thread-safe semaphores</source>
          <target state="translated">Нитка::Семафор-Нитка-безопасные семафоры</target>
        </trans-unit>
        <trans-unit id="b671103ebdb4e0b4d2ecc230ad75192d06191f6c" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore Discussion Forum on CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Semaphore&quot;&gt;http://www.cpanforum.com/dist/Thread-Semaphore&lt;/a&gt;</source>
          <target state="translated">Тема :: Дискуссионный форум семафоров на CPAN: &lt;a href=&quot;http://www.cpanforum.com/dist/Thread-Semaphore&quot;&gt;http://www.cpanforum.com/dist/Thread-Semaphore&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78e4d100100edaa775feea0a8c72907079d2f6c0" translate="yes" xml:space="preserve">
          <source>Thread::Semaphore on MetaCPAN: &lt;a href=&quot;https://metacpan.org/release/Thread-Semaphore&quot;&gt;https://metacpan.org/release/Thread-Semaphore&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01c8841eeee1a585b966adef58341ccb26f6e3f" translate="yes" xml:space="preserve">
          <source>Threaded Perl</source>
          <target state="translated">Резьбовой перл</target>
        </trans-unit>
        <trans-unit id="b3c18742ec345b212b0e3561e0712bc0736d2fd7" translate="yes" xml:space="preserve">
          <source>Threaded Perl &amp;lt; 5L</source>
          <target state="translated">Резьбовой Perl &amp;lt;5L</target>
        </trans-unit>
        <trans-unit id="896b80373adefd94b0d4d1ca953da0068f3de675" translate="yes" xml:space="preserve">
          <source>Threaded Perl on HP-UX</source>
          <target state="translated">Перл с резьбой на HP-UX</target>
        </trans-unit>
        <trans-unit id="278ce1d68672d63d7d64a6301d587c6d418cdd49" translate="yes" xml:space="preserve">
          <source>Threaded Perl on Tru64</source>
          <target state="translated">Резьбовой Perl на Tru64</target>
        </trans-unit>
        <trans-unit id="3e5a5f323fc4b225e8b871ec76ea2983f10ebd12" translate="yes" xml:space="preserve">
          <source>Threaded Program Models</source>
          <target state="translated">Модели резьбовых программ</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="6596a15b769c831a3f0b4a20d6206e9aaff0ff18" translate="yes" xml:space="preserve">
          <source>Threads And Data</source>
          <target state="translated">Потоки и данные</target>
        </trans-unit>
        <trans-unit id="ce6a15cf18170dad63898b28647ad599c148d2e2" translate="yes" xml:space="preserve">
          <source>Threads and PERL_NO_GET_CONTEXT</source>
          <target state="translated">Нитки и PERL_NO_GET_CONTEXT</target>
        </trans-unit>
        <trans-unit id="f29a9672c8b3e91f034cbb02629e17bf739af74a" translate="yes" xml:space="preserve">
          <source>Threads are executed in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; context. This method will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the thread terminates</source>
          <target state="translated">Потоки выполняются в контексте &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Этот метод вернет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если поток завершится</target>
        </trans-unit>
        <trans-unit id="4f937508b206813fc7fc617e2e68bc09cd2fe07a" translate="yes" xml:space="preserve">
          <source>Threads are executed in an &lt;code&gt;eval&lt;/code&gt; context. This method will return &lt;code&gt;undef&lt;/code&gt; if the thread terminates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b839f3a9a828ffa9cf5380fd081f2abe973e818b" translate="yes" xml:space="preserve">
          <source>Threads created after the stack size is set will then either call &lt;code&gt;pthread_attr_setstacksize()&lt;/code&gt;</source>
          <target state="translated">Потоки, созданные после установки размера стека, затем будут вызывать &lt;code&gt;pthread_attr_setstacksize()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94467b457a28016ce826b824829b4d6d15c2d05d" translate="yes" xml:space="preserve">
          <source>Threads in perl on Solaris.</source>
          <target state="translated">Нитки на перле на Солярисе.</target>
        </trans-unit>
        <trans-unit id="9bf016cf50be3949ad3553a7f6154f5ec7b5a4bd" translate="yes" xml:space="preserve">
          <source>Threads seem to work OK, though at the moment not all tests pass when threads are used in combination with 64-bit configurations.</source>
          <target state="translated">Потоки вроде бы работают нормально,хотя на данный момент не все тесты проходят при использовании потоков в сочетании с 64-битными конфигурациями.</target>
        </trans-unit>
        <trans-unit id="4cfcad8da4f4097a771977a006ace86ca57e64ee" translate="yes" xml:space="preserve">
          <source>Three additional functions allow access to this statistic from Perl. First, use &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; to get the information contained in the output of mstat() into %hash. The field of this hash are</source>
          <target state="translated">Три дополнительных функции позволяют получить доступ к этой статистике из Perl. Во-первых, используйте &lt;code&gt;mstats_fillhash(%hash)&lt;/code&gt; чтобы получить информацию, содержащуюся в выводе mstat (), в% hash. Поле этого хеша</target>
        </trans-unit>
        <trans-unit id="26e5837be2de4b1aebd256f3b85dedb9966c5789" translate="yes" xml:space="preserve">
          <source>Three arguments are passed to all subroutines specified in the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive (with exceptions - see below, particularly &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;).</source>
          <target state="translated">Всем подпрограммам, указанным в директиве &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , передаются три аргумента (с исключениями - см. Ниже, особенно &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eda363e39741d5cd78c03eff4a6d63f761929ec3" translate="yes" xml:space="preserve">
          <source>Three arguments are passed to all subroutines specified in the &lt;code&gt;use overload&lt;/code&gt; directive (with exceptions - see below, particularly &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd6b1128d59a894465f4f165820b4021adc3e92" translate="yes" xml:space="preserve">
          <source>Three basic types of firewalls</source>
          <target state="translated">Три основных типа брандмауэров</target>
        </trans-unit>
        <trans-unit id="0cfd5fb11aff1629d8a4d5d5d19e3a7e21cf359a" translate="yes" xml:space="preserve">
          <source>Three callback methods must be supplied by a class extending &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; to receive the corresponding event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ffe47253803edde038382d85662a60a52eedba" translate="yes" xml:space="preserve">
          <source>Three examples illustrate locale-dependent tainting. The first program, which ignores its locale, won't run: a value taken directly from the command line may not be used to name an output file when taint checks are enabled.</source>
          <target state="translated">Три примера иллюстрируют местное осквернение.Первая программа,которая игнорирует свою локаль,не будет запущена:значение,взятое непосредственно из командной строки,не может быть использовано для имени выходного файла,когда включена taint-проверка.</target>
        </trans-unit>
        <trans-unit id="6141ac98876a4853f17c73073300c31f8ef5f853" translate="yes" xml:space="preserve">
          <source>Three kinds of values are supported: integer numbers, floating point numbers, and strings.</source>
          <target state="translated">Поддерживаются три вида значений:целочисленные числа,числа с плавающей точкой и строки.</target>
        </trans-unit>
        <trans-unit id="1e762c22c180faab240d71e43cfef464b083afa9" translate="yes" xml:space="preserve">
          <source>Three techniques can make regular expressions maintainable and understandable.</source>
          <target state="translated">Три метода могут сделать регулярные выражения поддерживаемыми и понятными.</target>
        </trans-unit>
        <trans-unit id="1e024ca38a0a0e2a4280224604ff002f7a982d0a" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;ignoreChar&lt;/code&gt; , any character matching &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreChar/&lt;/a&gt;&lt;/code&gt; will be ignored. Through &lt;code&gt;ignoreName&lt;/code&gt; , any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreName/&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">Через &lt;code&gt;ignoreChar&lt;/code&gt; любой символ, соответствующий &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreChar/&lt;/a&gt;&lt;/code&gt; будет проигнорирован. Через &lt;code&gt;ignoreName&lt;/code&gt; любой символ, имя которого (указанное в файле &lt;code&gt;table&lt;/code&gt; как комментарий) соответствует &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$ignoreName/&lt;/a&gt;&lt;/code&gt; будет проигнорирован.</target>
        </trans-unit>
        <trans-unit id="6982b043a594faf7eee60f7d8781076841a7bed8" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;ignoreChar&lt;/code&gt;, any character matching &lt;code&gt;qr/$ignoreChar/&lt;/code&gt; will be ignored. Through &lt;code&gt;ignoreName&lt;/code&gt;, any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;qr/$ignoreName/&lt;/code&gt; will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2656f0fc85c8406c01f3e25365ba08b9847d1444" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;overrideCJK&lt;/code&gt; , ordering of CJK unified ideographs (including extensions) can be overridden.</source>
          <target state="translated">С помощью &lt;code&gt;overrideCJK&lt;/code&gt; можно изменить порядок унифицированных идеографов CJK (включая расширения).</target>
        </trans-unit>
        <trans-unit id="a4812f3fb25100135533513adb0cedc6268f243c" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;overrideCJK&lt;/code&gt;, ordering of CJK unified ideographs (including extensions) can be overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41b6131470dc9be4067c613ceb5bce948ecfe0f" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;undefChar&lt;/code&gt; , any character matching &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefChar/&lt;/a&gt;&lt;/code&gt; will be undefined. Through &lt;code&gt;undefName&lt;/code&gt; , any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefName/&lt;/a&gt;&lt;/code&gt; will be undefined.</source>
          <target state="translated">Через &lt;code&gt;undefChar&lt;/code&gt; любой символ, соответствующий &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefChar/&lt;/a&gt;&lt;/code&gt; будет неопределенным. Через &lt;code&gt;undefName&lt;/code&gt; любой символ, имя которого (указанное в файле &lt;code&gt;table&lt;/code&gt; как комментарий) совпадает с &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/$undefName/&lt;/a&gt;&lt;/code&gt; будет неопределенным.</target>
        </trans-unit>
        <trans-unit id="06a20d5faae40c1690e4ca328ce25858d383557b" translate="yes" xml:space="preserve">
          <source>Through &lt;code&gt;undefChar&lt;/code&gt;, any character matching &lt;code&gt;qr/$undefChar/&lt;/code&gt; will be undefined. Through &lt;code&gt;undefName&lt;/code&gt;, any character whose name (given in the &lt;code&gt;table&lt;/code&gt; file as a comment) matches &lt;code&gt;qr/$undefName/&lt;/code&gt; will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d077a4a651b19b1e4364e9f887336a0ac7a1fd1b" translate="yes" xml:space="preserve">
          <source>Throughout Perl's documentation, you'll find numerous examples intended to help explain the discussed features. Please keep in mind that many of them are code fragments rather than complete programs.</source>
          <target state="translated">В документации Perl вы найдете множество примеров,призванных помочь объяснить обсуждаемые возможности.Пожалуйста,имейте в виду,что многие из них являются фрагментами кода,а не полными программами.</target>
        </trans-unit>
        <trans-unit id="c8b395c4fc736d7a1ffa585c8b907d633728a128" translate="yes" xml:space="preserve">
          <source>Throughout the previous section all the examples have used the syntax:</source>
          <target state="translated">На протяжении всего предыдущего раздела все примеры использовали синтаксис:</target>
        </trans-unit>
        <trans-unit id="04ea385bf46d02438c73b811e0575313e27e41c8" translate="yes" xml:space="preserve">
          <source>Throughout this document a variety of interfaces to the rpcb_gettime() XSUB will be explored. The XSUBs will take their parameters in different orders or will take different numbers of parameters. In each case the XSUB is an abstraction between Perl and the real C rpcb_gettime() function, and the XSUB must always ensure that the real rpcb_gettime() function is called with the correct parameters. This abstraction will allow the programmer to create a more Perl-like interface to the C function.</source>
          <target state="translated">В этом документе будут рассмотрены различные интерфейсы к rpcb_gettime()XSUB.XSUB будут принимать свои параметры в разных ордерах или брать разное количество параметров.В каждом случае XSUB является абстракцией между Perl и реальной функцией C rpcb_gettime(),и XSUB всегда должен гарантировать,что реальная функция rpcb_gettime()вызывается с правильными параметрами.Такая абстракция позволит программисту создать более Perl-подобный интерфейс к функции на языке Си.</target>
        </trans-unit>
        <trans-unit id="b15b9c197ac6c931d6850ebe19f2134cab6a760f" translate="yes" xml:space="preserve">
          <source>Throughout this document you'll see references to other parts of the Perl documentation. You can read that documentation using the &lt;code&gt;perldoc&lt;/code&gt; command or whatever method you're using to read this document.</source>
          <target state="translated">В этом документе вы увидите ссылки на другие части документации Perl. Вы можете прочитать эту документацию с помощью команды &lt;code&gt;perldoc&lt;/code&gt; или любого другого метода, который вы используете для чтения этого документа.</target>
        </trans-unit>
        <trans-unit id="d384b2c788b5330a252672c9c0d9ed4dcefe6cd2" translate="yes" xml:space="preserve">
          <source>Throughout this document, &quot;Pod&quot; has been the preferred spelling for the name of the documentation format. One may also use &quot;POD&quot; or &quot;pod&quot;. For the documentation that is (typically) in the Pod format, you may use &quot;pod&quot;, or &quot;Pod&quot;, or &quot;POD&quot;. Understanding these distinctions is useful; but obsessing over how to spell them, usually is not.</source>
          <target state="translated">На протяжении всего документа в названии формата документации предпочтение отдавалось букве &quot;Pod&quot;.Можно также использовать &quot;POD&quot; или &quot;pod&quot;.Для документации,которая (обычно)представлена в формате Pod,можно использовать &quot;pod&quot;,или &quot;Pod&quot;,или &quot;POD&quot;.Понимание этих отличий полезно;но навязчивая идея о том,как они пишутся,обычно это не так.</target>
        </trans-unit>
        <trans-unit id="6a4f24f440cbc4008a46d5ea71d57cb32fa115ff" translate="yes" xml:space="preserve">
          <source>Throw in some dubious extra macros for Makefile args.</source>
          <target state="translated">Добавь немного сомнительных лишних макросов для &quot;Makefile args&quot;.</target>
        </trans-unit>
        <trans-unit id="76751470c1dde2f50d7d809c9a5f8b163f6ce43e" translate="yes" xml:space="preserve">
          <source>Throws an error if any of the signals supplied cannot be added to the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b73cafd4faf1fefd5169b12127f2bdff667740" translate="yes" xml:space="preserve">
          <source>Throws an exception telling you the attribute is read-only. This is exported to override any active setters for the attribute in a parent class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f7b26cf9b0b9d2fcaec187b02a47e2ac8cf9d0" translate="yes" xml:space="preserve">
          <source>Thus Perl allows such constructs, by</source>
          <target state="translated">Таким образом,Perl допускает такие конструкции,по</target>
        </trans-unit>
        <trans-unit id="ab203f90d156d52e2f73ed76c1de89f7fea26e7e" translate="yes" xml:space="preserve">
          <source>Thus Perl returns true on success and false on failure, yet you can still easily determine the actual value returned by the operating system:</source>
          <target state="translated">Таким образом,Perl возвращает правду об успехе и ложь о неудаче,но при этом вы можете легко определить фактическое значение,возвращаемое операционной системой:</target>
        </trans-unit>
        <trans-unit id="68e6804dcc6b004791c6943dada1f9eeda86eed7" translate="yes" xml:space="preserve">
          <source>Thus means that you need to get some copy of a</source>
          <target state="translated">Это значит,что тебе нужно получить какую-то копию</target>
        </trans-unit>
        <trans-unit id="cced270ffb5295be4933e701f4fb59adf650f013" translate="yes" xml:space="preserve">
          <source>Thus the following lines are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4d332fae9a917754e083395b2e8d74491bb6fd" translate="yes" xml:space="preserve">
          <source>Thus the pattern &lt;code&gt;/foo(?:\w+|\d+|\s+)bar/&lt;/code&gt; can be thought of as the following chart:</source>
          <target state="translated">Таким образом, шаблон &lt;code&gt;/foo(?:\w+|\d+|\s+)bar/&lt;/code&gt; можно рассматривать как следующий график:</target>
        </trans-unit>
        <trans-unit id="f633037050d154781c387ade59e7e2912691ab20" translate="yes" xml:space="preserve">
          <source>Thus the warning is raised for many fewer cases than in earlier Perls, and only when what the result is could be arguable. It turns out that none of the optimizations made by Perl (or are ever likely to be made) cause the warning to be skipped, so it solves both problems of Perl's earlier approach. The most commonly used property that is affected by this change is &lt;code&gt;\p{Unassigned}&lt;/code&gt; which is a short form for &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; . Starting in v5.20, all non-Unicode code points are considered &lt;code&gt;Unassigned&lt;/code&gt; . In earlier releases the matches failed because the result was considered undefined.</source>
          <target state="translated">Таким образом, предупреждение возникает в гораздо меньшем количестве случаев, чем в более ранних Perls, и только тогда, когда результат может быть спорным. Оказывается, ни одна из оптимизаций, сделанных Perl (или вероятных когда-либо сделанных), не приводит к пропуску предупреждения, поэтому это решает обе проблемы более раннего подхода Perl. Наиболее часто используемым свойством, на которое влияет это изменение, является &lt;code&gt;\p{Unassigned}&lt;/code&gt; что является сокращенной формой для &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt; . Начиная с версии 5.20, все кодовые точки, отличные от Unicode, считаются &lt;code&gt;Unassigned&lt;/code&gt; . В более ранних выпусках совпадения не удавались, потому что результат считался неопределенным.</target>
        </trans-unit>
        <trans-unit id="61e13a16949757dfa1e1583008faeb5e63993d67" translate="yes" xml:space="preserve">
          <source>Thus the warning is raised for many fewer cases than in earlier Perls, and only when what the result is could be arguable. It turns out that none of the optimizations made by Perl (or are ever likely to be made) cause the warning to be skipped, so it solves both problems of Perl's earlier approach. The most commonly used property that is affected by this change is &lt;code&gt;\p{Unassigned}&lt;/code&gt; which is a short form for &lt;code&gt;\p{General_Category=Unassigned}&lt;/code&gt;. Starting in v5.20, all non-Unicode code points are considered &lt;code&gt;Unassigned&lt;/code&gt;. In earlier releases the matches failed because the result was considered undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198082eebbb223fde4a47c55ef1e44319568487c" translate="yes" xml:space="preserve">
          <source>Thus you can say</source>
          <target state="translated">Таким образом,можно сказать.</target>
        </trans-unit>
        <trans-unit id="61d7278739eb25e7e5958e1c5b254402dd825eb3" translate="yes" xml:space="preserve">
          <source>Thus, after a match against &lt;code&gt;$_&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; coincides with &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[0],
$+[0] - $-[0]&lt;/code&gt; . Similarly, $</source>
          <target state="translated">Таким образом, после совпадения с &lt;code&gt;$_&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; совпадает с &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; $_, $-[0], $+[0] - $-[0]&lt;/code&gt; . Аналогично $</target>
        </trans-unit>
        <trans-unit id="41169299ed066a28115e5870cc4da4575fd56075" translate="yes" xml:space="preserve">
          <source>Thus, after a match against &lt;code&gt;$_&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; coincides with &lt;code&gt;substr $_, $-[0], $+[0] - $-[0]&lt;/code&gt;. Similarly, $</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9649f9466e2d92d8678d66258528b39110e1a08" translate="yes" xml:space="preserve">
          <source>Thus, techniques are of interest that store object data</source>
          <target state="translated">Таким образом,представляют интерес методики,которые хранят данные об объекте.</target>
        </trans-unit>
        <trans-unit id="69514cb2285daf6fa2a75d85f6f93569b1ec1fbe" translate="yes" xml:space="preserve">
          <source>Thus, the following code:</source>
          <target state="translated">Таким образом,следующий код:</target>
        </trans-unit>
        <trans-unit id="fdfd242e087e9b16796271aa3a036f7d0bbc20a8" translate="yes" xml:space="preserve">
          <source>Thus, when an SV is determined to be magical and of type &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; , if a get operation is being performed, the routine &lt;code&gt;magic_get&lt;/code&gt; is called. All the various routines for the various magical types begin with &lt;code&gt;magic_&lt;/code&gt; . NOTE: the magic routines are not considered part of the Perl API, and may not be exported by the Perl library.</source>
          <target state="translated">Таким образом, когда определено, что SV является волшебным и имеет тип &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; , если выполняется операция получения, &lt;code&gt;magic_get&lt;/code&gt; подпрограмма magic_get . Все различные процедуры для различных типов &lt;code&gt;magic_&lt;/code&gt; начинаются с magic_ . ПРИМЕЧАНИЕ: магические процедуры не считаются частью Perl API и не могут быть экспортированы библиотекой Perl.</target>
        </trans-unit>
        <trans-unit id="0549c98abe5f2c41103ad967e9de7400fdf53796" translate="yes" xml:space="preserve">
          <source>Thus, when an SV is determined to be magical and of type &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt;, if a get operation is being performed, the routine &lt;code&gt;magic_get&lt;/code&gt; is called. All the various routines for the various magical types begin with &lt;code&gt;magic_&lt;/code&gt;. NOTE: the magic routines are not considered part of the Perl API, and may not be exported by the Perl library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792b045fd76c8a8e326c6a926aab95f7dc272599" translate="yes" xml:space="preserve">
          <source>Tidies a pod file. It's a good idea to run this on a pod file you've patched.</source>
          <target state="translated">Прибирает файл стручки.Хорошая идея запустить это в файле стручки,который вы залатали.</target>
        </trans-unit>
        <trans-unit id="b6cf02234ec17d26dce972804e5d1459de07ad2c" translate="yes" xml:space="preserve">
          <source>Tidy up a pad at the end of compilation of the code to which it belongs. Jobs performed here are: remove most stuff from the pads of anonsub prototypes; give it a &lt;code&gt;@_&lt;/code&gt;; mark temporaries as such. &lt;code&gt;type&lt;/code&gt; indicates the kind of subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296860fe60dd454f0fedbc6ccca9835dfde819d9" translate="yes" xml:space="preserve">
          <source>Tidy up a pad at the end of compilation of the code to which it belongs. Jobs performed here are: remove most stuff from the pads of anonsub prototypes; give it a @_; mark temporaries as such.</source>
          <target state="translated">Приведите в порядок блокнот в конце компиляции кода,которому он принадлежит.Здесь выполняются следующие задания:удалить большинство вещей из колодок прототипов анонсубов;дать ему @_;пометить временные ряды как таковые.</target>
        </trans-unit>
        <trans-unit id="7d075f169d648523eaa03bb2a98984e48aa65769" translate="yes" xml:space="preserve">
          <source>Tie</source>
          <target state="translated">Tie</target>
        </trans-unit>
        <trans-unit id="5e1d6d92861c9421bba19d24d93aa2e9bfe58ad7" translate="yes" xml:space="preserve">
          <source>Tie large variables to disk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb65db42104858e7d9b646133b08eaaeba3381c" translate="yes" xml:space="preserve">
          <source>Tie::Array</source>
          <target state="translated">Tie::Array</target>
        </trans-unit>
        <trans-unit id="75e3c18c1d17d4f15800c858036a1510e1e1f0e6" translate="yes" xml:space="preserve">
          <source>Tie::Array - base class for tied arrays</source>
          <target state="translated">Связь::Массив-базовый класс для привязанных массивов</target>
        </trans-unit>
        <trans-unit id="3315a464fcfacdc6f9533f0ecfd375368fedb11d" translate="yes" xml:space="preserve">
          <source>Tie::File</source>
          <target state="translated">Tie::File</target>
        </trans-unit>
        <trans-unit id="a8bb1e5ad4fcbd12edf8be28ae56bee14e6f545c" translate="yes" xml:space="preserve">
          <source>Tie::File - Access the lines of a disk file via a Perl array</source>
          <target state="translated">Связь::Файл-доступ к строкам дискового файла через массив Perl</target>
        </trans-unit>
        <trans-unit id="dc17380e1c5c0cb9aaf50a1f92e76e8ea993f448" translate="yes" xml:space="preserve">
          <source>Tie::File calls &lt;code&gt;binmode&lt;/code&gt; on filehandles that it opens internally, but not on filehandles passed in by the user. For consistency, especially if using the tied files cross-platform, you may wish to call &lt;code&gt;binmode&lt;/code&gt; on the filehandle prior to tying the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6319e96a453cce98221083d4f3fd8db235526699" translate="yes" xml:space="preserve">
          <source>Tie::Handle</source>
          <target state="translated">Tie::Handle</target>
        </trans-unit>
        <trans-unit id="0a548ea9945566563847425cd86bcbb7a0d010cc" translate="yes" xml:space="preserve">
          <source>Tie::Handle - base class definitions for tied handles</source>
          <target state="translated">Галстук::Ручка-определения базового класса для ручек с завязанными ручками</target>
        </trans-unit>
        <trans-unit id="cd52c37918e2c0b25f36b5f416810f9f4f61d1e1" translate="yes" xml:space="preserve">
          <source>Tie::Hash</source>
          <target state="translated">Tie::Hash</target>
        </trans-unit>
        <trans-unit id="b1f9afc2a333da12fb6b6ad2b6d5e266f06e1fc4" translate="yes" xml:space="preserve">
          <source>Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes</source>
          <target state="translated">Галстук::Хэш,Галстук::StdHash,Галстук::ExtraHash-определения базового класса для завязанных хэшей</target>
        </trans-unit>
        <trans-unit id="c8d3a75ba1b0a3910318dc42acaa46468a63fedd" translate="yes" xml:space="preserve">
          <source>Tie::Hash::NamedCapture</source>
          <target state="translated">Tie::Hash::NamedCapture</target>
        </trans-unit>
        <trans-unit id="fe35d5fd9c32e90217b32911caa7181fd20d6a89" translate="yes" xml:space="preserve">
          <source>Tie::Hash::NamedCapture - Named regexp capture buffers</source>
          <target state="translated">Галстук::Hash::NamedCapture-Named regexp буферы захвата.</target>
        </trans-unit>
        <trans-unit id="703b368dc238bcde88f5095c837de68b527d723e" translate="yes" xml:space="preserve">
          <source>Tie::Memoize</source>
          <target state="translated">Tie::Memoize</target>
        </trans-unit>
        <trans-unit id="7b3289a8b6604631463790d9f588d4dd69111f3a" translate="yes" xml:space="preserve">
          <source>Tie::Memoize - add data to hash when needed</source>
          <target state="translated">Tie::Запомнить-добавлять данные в хэш,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="aeeb15286d4bc809144814ad40c79ee05c416c3a" translate="yes" xml:space="preserve">
          <source>Tie::RefHash</source>
          <target state="translated">Tie::RefHash</target>
        </trans-unit>
        <trans-unit id="4bb364c89cbd37ee3daa5c39771c2605b0633761" translate="yes" xml:space="preserve">
          <source>Tie::RefHash - use references as hash keys</source>
          <target state="translated">Tie::RefHash-использовать ссылки в качестве хэш-ключей</target>
        </trans-unit>
        <trans-unit id="fb9e6a1ad57553eb30c0b9f049adcbf5c6d8c3ed" translate="yes" xml:space="preserve">
          <source>Tie::Scalar</source>
          <target state="translated">Tie::Scalar</target>
        </trans-unit>
        <trans-unit id="14241eaa440004f0f7b17e76185eebd008e2584c" translate="yes" xml:space="preserve">
          <source>Tie::Scalar vs Tie::StdScalar</source>
          <target state="translated">Галстук::Скалар против Галстука::СтдСкалар</target>
        </trans-unit>
        <trans-unit id="9c8072ce734013166993c6f0143dd7123d88fcc5" translate="yes" xml:space="preserve">
          <source>Tie::Scalar, Tie::StdScalar - base class definitions for tied scalars</source>
          <target state="translated">Галстук::Скаляр,Галстук::StdScalar-определения базового класса для связанных скаляров.</target>
        </trans-unit>
        <trans-unit id="24703e371c3e7f945d3b78d21edd36185f76ca6e" translate="yes" xml:space="preserve">
          <source>Tie::StdHandle</source>
          <target state="translated">Tie::StdHandle</target>
        </trans-unit>
        <trans-unit id="a6e6391cf784418a4b559abce054165c18d48250" translate="yes" xml:space="preserve">
          <source>Tie::StdHandle - base class definitions for tied handles</source>
          <target state="translated">Связь::StdHandle-определения базового класса для связанных ручек</target>
        </trans-unit>
        <trans-unit id="2f3439068e890141de6922d6924a5c42144d9aab" translate="yes" xml:space="preserve">
          <source>Tie::SubstrHash</source>
          <target state="translated">Tie::SubstrHash</target>
        </trans-unit>
        <trans-unit id="6980b3892c06ab7d2c795b8a0449ed68a3aed6bd" translate="yes" xml:space="preserve">
          <source>Tie::SubstrHash - Fixed-table-size, fixed-key-length hashing</source>
          <target state="translated">Галстук::SubstrHash-Хеширование с фиксированным размером стола,фиксированной длиной ключа</target>
        </trans-unit>
        <trans-unit id="464ee826aae53453c130a0c1497f3c4ca331982d" translate="yes" xml:space="preserve">
          <source>Tied access to ndbm files</source>
          <target state="translated">Связанный доступ к файлам ndbm</target>
        </trans-unit>
        <trans-unit id="8a33955c62ec97774e8693644b322775bd7663ae" translate="yes" xml:space="preserve">
          <source>Tied access to odbm files</source>
          <target state="translated">Связанный доступ к файлам odbm</target>
        </trans-unit>
        <trans-unit id="1588828c9e5b2bd88f7d08cd7f3e57f7ec8ffbf5" translate="yes" xml:space="preserve">
          <source>Tied access to sdbm files</source>
          <target state="translated">Связанный доступ к файлам sdbm</target>
        </trans-unit>
        <trans-unit id="1720e98baff7940aea5456c5ab89cbd8f4faa4be" translate="yes" xml:space="preserve">
          <source>Tied filehandles are still incomplete. sysopen(), truncate(), flock(), fcntl(), stat() and -X can't currently be trapped.</source>
          <target state="translated">Связанные файловые дескрипторы все еще незакончены.sysopen(),truncate(),flock(),fcntl(),stat()и -X в настоящее время не могут быть пойманы в ловушку.</target>
        </trans-unit>
        <trans-unit id="4b7baf020a5c394ffec94a6c51412ee34b96cd55" translate="yes" xml:space="preserve">
          <source>Tied hash interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a90cde1e783db9283275e5312c014bb1cb705f" translate="yes" xml:space="preserve">
          <source>Tied hash/array slices cause multiple FETCH/STORE pairs, there are no tie methods for slice operations.</source>
          <target state="translated">Связанные кусочки хэша/массива приводят к появлению нескольких пар FETCH/STORE,для операций с кусочками не существует методов привязки.</target>
        </trans-unit>
        <trans-unit id="44a21f1b3d2e469d8d4dbb6af794f7ad93c019a6" translate="yes" xml:space="preserve">
          <source>Tied hashes and arrays are magical beasts of the &lt;code&gt;PERL_MAGIC_tied&lt;/code&gt; magic type.</source>
          <target state="translated">Связанные хэши и массивы - это волшебные &lt;code&gt;PERL_MAGIC_tied&lt;/code&gt; магического типа PERL_MAGIC_tied .</target>
        </trans-unit>
        <trans-unit id="83884faf685c9098ec150488288e4d48b3ce8cb8" translate="yes" xml:space="preserve">
          <source>Tied hashes may have a different ordering behaviour to perl's hash implementation.</source>
          <target state="translated">Связанные хэши могут отличаться по порядку от хэшей perl.</target>
        </trans-unit>
        <trans-unit id="d3d1d3d65efd2c22754237fd41c0e585f040ec15" translate="yes" xml:space="preserve">
          <source>Tied hashes may have their own ordering and algorithmic complexity attacks.</source>
          <target state="translated">Связанные хэши могут иметь свои собственные атаки по порядку и алгоритмической сложности.</target>
        </trans-unit>
        <trans-unit id="24b5ed066516a43ed14f22509aac06d08e585ed9" translate="yes" xml:space="preserve">
          <source>Ties are handled by choosing the first handler.</source>
          <target state="translated">Галстуки обрабатываются путем выбора первого обработчика.</target>
        </trans-unit>
        <trans-unit id="64d5dd10fdcd493eede6caa7c5fa5f02730895e8" translate="yes" xml:space="preserve">
          <source>Tim Bunce and Charles Bailey. Currently maintained by David Landgren &amp;lt;</source>
          <target state="translated">Тим Банс и Чарльз Бейли. В настоящее время поддерживается Дэвидом Ландгреном &amp;lt;</target>
        </trans-unit>
        <trans-unit id="3ddc0a76c09f699fa94ee0a72995b7039d633486" translate="yes" xml:space="preserve">
          <source>Tim Bunce, 11 August 1994.</source>
          <target state="translated">Тим Банс,11 августа 1994 года.</target>
        </trans-unit>
        <trans-unit id="8cf374401e16921c8b9927b27c7d0a5e707f664a" translate="yes" xml:space="preserve">
          <source>Tim Bunce, 2nd June 1995.</source>
          <target state="translated">Тим Банс,2 июня 1995 года.</target>
        </trans-unit>
        <trans-unit id="3175b9a598f6f77b48765e43cfb7cd7d7b509655" translate="yes" xml:space="preserve">
          <source>Tim Jenness</source>
          <target state="translated">Тим Дженнесс</target>
        </trans-unit>
        <trans-unit id="99e549517dd29d09a287dd50b24a5bc08370dba4" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba097d23c99b23a50efd8f2fea03c845fd6c6c33" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;t.jenness@jach.hawaii.edu&amp;gt; provided &lt;code&gt;pod_where&lt;/code&gt; and &lt;code&gt;contains_pod&lt;/code&gt; .</source>
          <target state="translated">Тим Дженнесс &amp;lt;t.jenness@jach.hawaii.edu&amp;gt; предоставил &lt;code&gt;pod_where&lt;/code&gt; и &lt;code&gt;contains_pod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b514fb185ee4318cecaed2812ba7869208c66528" translate="yes" xml:space="preserve">
          <source>Tim Jenness &amp;lt;tjenness@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1869a3cb31c7d1aee298b5966f09e01ff91380af" translate="yes" xml:space="preserve">
          <source>Tim Jenness, &amp;lt;t.jenness@jach.hawaii.edu&amp;gt;, Christian Soeller, &amp;lt;csoelle@mph.auckland.ac.nz&amp;gt;, Hugo van der Sanden &amp;lt;hv@crypt.compulink.co.uk&amp;gt;, Andrew Main (Zefram) &amp;lt;zefram@fysh.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e2988b00d7b32dc16eda9dda1443c70d8e538b" translate="yes" xml:space="preserve">
          <source>Tim.Bunce (at) ig.co.uk</source>
          <target state="translated">Тим Банс (на)ig.co.uk</target>
        </trans-unit>
        <trans-unit id="d077aa36842cc868f42990d7049841ea88af7d34" translate="yes" xml:space="preserve">
          <source>Tim.Bunce@ig.co.uk</source>
          <target state="translated">Tim.Bunce@ig.co.uk</target>
        </trans-unit>
        <trans-unit id="e4179a3f25309044bcb58d588fe8e8bd90fd67c9" translate="yes" xml:space="preserve">
          <source>Time COUNT iterations of CODE. CODE may be a string to eval or a code reference; either way the CODE will run in the caller's package. Results will be printed to STDOUT as TITLE followed by the times. TITLE defaults to &quot;timethis COUNT&quot; if none is provided. STYLE determines the format of the output, as described for timestr() below.</source>
          <target state="translated">Итерации КОДА по времени.КОД может быть как строкой для оценки,так и кодовой ссылкой;в любом случае КОД будет выполняться в пакете вызывающего абонента.Результаты будут распечатаны в STDOUT в виде ТИТУЛА с последующим указанием времени.По умолчанию TITLE имеет значение &quot;timethis COUNT&quot;,если оно отсутствует.STYLE определяет формат вывода,как описано ниже для функции timestr().</target>
        </trans-unit>
        <trans-unit id="3b32a6d9639a8d4119ec2ee525234d95d8857ca9" translate="yes" xml:space="preserve">
          <source>Time and Date</source>
          <target state="translated">Время и дата</target>
        </trans-unit>
        <trans-unit id="ba899f435a04612971ed3cd90f1a2814efd01889" translate="yes" xml:space="preserve">
          <source>Time and daytime network client interface</source>
          <target state="translated">Сетевой клиентский интерфейс в дневное и вечернее время</target>
        </trans-unit>
        <trans-unit id="91258f8a07507a00e4da6f106ca4198c6edce78f" translate="yes" xml:space="preserve">
          <source>Time-related functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac91bba7fcbd91c8d367a4f56e1aba373023bebd" translate="yes" xml:space="preserve">
          <source>Time::HiRes</source>
          <target state="translated">Time::HiRes</target>
        </trans-unit>
        <trans-unit id="e7a9e6eb81fae6fdb1dc6f6133fdfcde6d6d2e8f" translate="yes" xml:space="preserve">
          <source>Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers</source>
          <target state="translated">Время::HiRes-Высокое разрешение тревоги,сна,gettimeofday,интервалы таймеры</target>
        </trans-unit>
        <trans-unit id="94df31ba192f82c8d905bfd5f68e42a860c364a4" translate="yes" xml:space="preserve">
          <source>Time::Local</source>
          <target state="translated">Time::Local</target>
        </trans-unit>
        <trans-unit id="f389186d9b9640e798d2c3270420ee058c982a8f" translate="yes" xml:space="preserve">
          <source>Time::Local - Efficiently compute time from local and GMT time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068e2f4f422dc17d00b1dbbf4d66d078ee8c1c17" translate="yes" xml:space="preserve">
          <source>Time::Local - efficiently compute time from local and GMT time</source>
          <target state="translated">Время::Местное-эффективно вычислять время по местному и GMT времени.</target>
        </trans-unit>
        <trans-unit id="0a2a9a0e5d10ea8cd730c55ab8fbc21a6da6bc46" translate="yes" xml:space="preserve">
          <source>Time::Piece</source>
          <target state="translated">Time::Piece</target>
        </trans-unit>
        <trans-unit id="3b1c89f6e740fb1373ec42ee463919eaf109abbc" translate="yes" xml:space="preserve">
          <source>Time::Piece - Object Oriented time objects</source>
          <target state="translated">Объекты времени::Объект-Объектно-ориентированные объекты времени</target>
        </trans-unit>
        <trans-unit id="ac2e609ce173a3276a7464b9debe21218246f96d" translate="yes" xml:space="preserve">
          <source>Time::Piece has a built-in strptime() function (from FreeBSD), allowing you incredibly flexible date parsing routines. For example:</source>
          <target state="translated">Time::Piece имеет встроенную функцию strptime()(из FreeBSD),позволяющую невероятно гибко разобрать дату.Например:</target>
        </trans-unit>
        <trans-unit id="6fb89f7a383c83046c2d6e7aeb455a015e9f82bc" translate="yes" xml:space="preserve">
          <source>Time::Piece::strptime by default can only parse American English date names. Meanwhile, Time::Piece-&amp;gt;strftime() will return date names that use the current configured system locale. This means dates returned by strftime might not be able to be parsed by strptime. This is the default behavior and can be overridden by calling Time::Piece-&amp;gt;use_locale(). This builds a list of the current locale's day and month names which strptime will use to parse with. Note this is a global override and will affect all Time::Piece instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40344d994e23d7372c530bbf0bbd03eeb00a6dc" translate="yes" xml:space="preserve">
          <source>Time::Seconds</source>
          <target state="translated">Time::Seconds</target>
        </trans-unit>
        <trans-unit id="39f6129fd39e3df4fcacf60c5d99f5c6192c805d" translate="yes" xml:space="preserve">
          <source>Time::Seconds - a simple API to convert seconds to other date values</source>
          <target state="translated">Время::Секунды-простой API для преобразования секунд в другие значения даты.</target>
        </trans-unit>
        <trans-unit id="cbf1ec1195a651fc24927b61f20ae1c2b1743372" translate="yes" xml:space="preserve">
          <source>Time::Seconds also exports the following constants:</source>
          <target state="translated">Время::Секунды также экспортируют следующие константы:</target>
        </trans-unit>
        <trans-unit id="16d75647463ccb98ccc9ac22ce0d58439164ffe1" translate="yes" xml:space="preserve">
          <source>Time::gmtime</source>
          <target state="translated">Time::gmtime</target>
        </trans-unit>
        <trans-unit id="ca443191990262bcf077810f460d0cd5da0a2497" translate="yes" xml:space="preserve">
          <source>Time::gmtime - by-name interface to Perl's built-in gmtime() function</source>
          <target state="translated">Time::gmtime-интерфейс с именем для встроенной в Perl функции gmtime().</target>
        </trans-unit>
        <trans-unit id="1e32398fc4863ae4d240a706fe6661194fea16dc" translate="yes" xml:space="preserve">
          <source>Time::localtime</source>
          <target state="translated">Time::localtime</target>
        </trans-unit>
        <trans-unit id="1c04f7003a511410fc2dc340400d8f81416e8250" translate="yes" xml:space="preserve">
          <source>Time::localtime - by-name interface to Perl's built-in localtime() function</source>
          <target state="translated">Time::localtime-интерфейс с именем для встроенной функции Perl localtime().</target>
        </trans-unit>
        <trans-unit id="de41baa484e46c7cf981eab70afe99b8805cc8b2" translate="yes" xml:space="preserve">
          <source>Time::tm</source>
          <target state="translated">Time::tm</target>
        </trans-unit>
        <trans-unit id="21f72c1b3c5d75c7e3444254a7622f9392f93a3d" translate="yes" xml:space="preserve">
          <source>Time::tm - internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time::tm-внутренний объект,используемый Time::gmtime и Time::localtime.</target>
        </trans-unit>
        <trans-unit id="e368ab9a5fbb03e74a7f8b310c3fe08ae2271a05" translate="yes" xml:space="preserve">
          <source>TimeOut</source>
          <target state="translated">TimeOut</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="bf885321e4853536c53ad9a2c9930e27e148e561" translate="yes" xml:space="preserve">
          <source>Timeout =&amp;gt; NUM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46821e5334d7cbbbeb412cbbc4fae07b635b35c" translate="yes" xml:space="preserve">
          <source>Timeout I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2b6328d392947cda8eed37cd6fd0fce114f5ab" translate="yes" xml:space="preserve">
          <source>Timeout for inactivity during {Makefile,Build}.PL?</source>
          <target state="translated">Тайм-аут на бездействие во время {Makefile,Build}.PL?</target>
        </trans-unit>
        <trans-unit id="6202f67c7c444f6f4c73b3c31ad99a53b9159e1b" translate="yes" xml:space="preserve">
          <source>Timeout for parsing module versions?</source>
          <target state="translated">Тайм-аут для версий модулей разбора?</target>
        </trans-unit>
        <trans-unit id="7b97ea2213b8941cebfb4eaa8bbbb9bd0bba9f0a" translate="yes" xml:space="preserve">
          <source>Tiny set of tools for unfortunate souls who cannot use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3cc8be33f220718da61643e6e0bc1c501663fd" translate="yes" xml:space="preserve">
          <source>Tips and Techniques</source>
          <target state="translated">Советы и техника</target>
        </trans-unit>
        <trans-unit id="092da30065f07adb4a08c52dc1aaf646aa06aee4" translate="yes" xml:space="preserve">
          <source>Tips and Tricks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fb128ab2b2b606667607db6ec0f87259f7a1e5" translate="yes" xml:space="preserve">
          <source>Titlecase</source>
          <target state="translated">Titlecase</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="767ea1b5d1e2d80e5699c6649ded795c6b5cad19" translate="yes" xml:space="preserve">
          <source>To (en|de)code encodings marked by &lt;code&gt;(**)&lt;/code&gt;, you need &lt;code&gt;Encode::HanExtra&lt;/code&gt;, available from CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e9f1113dd228531b5734915ff74dd66ea601f0" translate="yes" xml:space="preserve">
          <source>To (re)open &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; as an in-memory file, close it first:</source>
          <target state="translated">Чтобы (повторно) открыть &lt;code&gt;STDOUT&lt;/code&gt; или &lt;code&gt;STDERR&lt;/code&gt; как файл в памяти, сначала закройте его:</target>
        </trans-unit>
        <trans-unit id="7a790472031c710be009a7b4a42a45592085ee5d" translate="yes" xml:space="preserve">
          <source>To OO or not to OO?</source>
          <target state="translated">Для OO или не для OO?</target>
        </trans-unit>
        <trans-unit id="2e5fb83e42913577879316262366950ec7aec439" translate="yes" xml:space="preserve">
          <source>To access servers outside these type of firewalls with perl, you need Net::FTP.</source>
          <target state="translated">Для доступа к серверам за пределами таких брандмауэров с помощью perl,вам потребуется Net::FTP.</target>
        </trans-unit>
        <trans-unit id="9715ff5bc3ceda6802c5265803ef21d4705c83eb" translate="yes" xml:space="preserve">
          <source>To access servers outside these types of firewalls with perl (even for ftp), you need LWP or HTTP::Tiny.</source>
          <target state="translated">Для доступа к серверам вне этих типов брандмауэров с помощью perl (даже для ftp),вам понадобится LWP или HTTP::Tiny.</target>
        </trans-unit>
        <trans-unit id="75353a5a7f7320bec3542821474a8dbab7c8c12c" translate="yes" xml:space="preserve">
          <source>To access the actual value that an SV points to, you can use the macros:</source>
          <target state="translated">Для доступа к фактическому значению,на которое указывает SV,можно использовать макросы:</target>
        </trans-unit>
        <trans-unit id="18ca46dd427588f094e1ba9ca5a38e797fcd2ac7" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. On the other hand, the built-ins are still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">Чтобы получить доступ к этой функции без переопределения ядра, передайте &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; пустого списка импорта, а затем получите доступ к функциям функций с их полными квалифицированными именами. С другой стороны, встроенные модули по-прежнему доступны через псевдо-пакет &lt;code&gt;CORE::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca3331d12806630976595e1bbb7790e715a99c2" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. The built-ins are always still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="translated">Чтобы получить доступ к этой функции без переопределения ядра, передайте &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; пустого списка импорта, а затем обращайтесь к функциям с их полными квалифицированными именами. Встроенные модули всегда доступны через псевдопакет &lt;code&gt;CORE::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00d7f9df22362a2f3c85b921564fc19258d8388c" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;use&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. On the other hand, the built-ins are still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8104695610bb754f8e946466b35dfbf1827c0fd9" translate="yes" xml:space="preserve">
          <source>To access this functionality without the core overrides, pass the &lt;code&gt;use&lt;/code&gt; an empty import list, and then access function functions with their full qualified names. The built-ins are always still available via the &lt;code&gt;CORE::&lt;/code&gt; pseudo-package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce78b43e2a908e0a4f8a1b6833f38009e23883a3" translate="yes" xml:space="preserve">
          <source>To accomplish this behaviour, simply specify an array reference as the destination for the option:</source>
          <target state="translated">Чтобы добиться такого поведения,просто укажите ссылку на массив в качестве места назначения для опции:</target>
        </trans-unit>
        <trans-unit id="f61067f007c7ba160effec3a91d355b4f290080e" translate="yes" xml:space="preserve">
          <source>To actually alter the visible command line, you can assign to the variable $0 as documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. This won't work on all operating systems, though. Daemon programs like sendmail place their state there, as in:</source>
          <target state="translated">Чтобы фактически изменить видимую командную строку, вы можете присвоить переменной $ 0, как &lt;a href=&quot;perlvar&quot;&gt;описано&lt;/a&gt; в perlvar . Однако это работает не во всех операционных системах. Программы-демоны, такие как sendmail, помещают туда свое состояние, например:</target>
        </trans-unit>
        <trans-unit id="e6257d01bcff432617bc3aaafa5362a537c023ed" translate="yes" xml:space="preserve">
          <source>To actually do the magic method call, we have to call a subroutine in Perl space: &lt;code&gt;call_method&lt;/code&gt; takes care of that, and it's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. We call the &lt;code&gt;PUSH&lt;/code&gt; method in scalar context, and we're going to discard its return value. The call_method() function removes the top element of the mark stack, so there is nothing for the caller to clean up.</source>
          <target state="translated">Чтобы действительно выполнить вызов магического метода, мы должны вызвать подпрограмму в пространстве Perl: &lt;code&gt;call_method&lt;/code&gt; позаботится об этом, и он описан в &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; . Мы вызываем метод &lt;code&gt;PUSH&lt;/code&gt; в скалярном контексте и собираемся отбросить его возвращаемое значение. Функция call_method () удаляет верхний элемент стека меток, поэтому вызывающей стороне нечего очищать.</target>
        </trans-unit>
        <trans-unit id="6122d22a4decb5ce34478a60d87283b09ca23b69" translate="yes" xml:space="preserve">
          <source>To actually run a script set-id, if you don't have the safe version of set-id scripts, you'll need to put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5d4ebd8ab0875fd7f6df0d61ffd7b676158145" translate="yes" xml:space="preserve">
          <source>To add a new alias to a given encoding, use:</source>
          <target state="translated">Чтобы добавить новый псевдоним к заданной кодировке,используйте его:</target>
        </trans-unit>
        <trans-unit id="504c5fdbd3b3208314b10451eb998ac1dfbb6a34" translate="yes" xml:space="preserve">
          <source>To add lines before a certain line, you can add a line (or lines!) before Perl prints &lt;code&gt;$_&lt;/code&gt; :</source>
          <target state="translated">Чтобы добавить строки перед определенной строкой, вы можете добавить строку (или строки!) До того, как Perl напечатает &lt;code&gt;$_&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="664ca3b18fd212ce34e3ecc1b835f5946d711935" translate="yes" xml:space="preserve">
          <source>To add lines before a certain line, you can add a line (or lines!) before Perl prints &lt;code&gt;$_&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c5424e693984510192a96a5bd33b04a6c7bcb7" translate="yes" xml:space="preserve">
          <source>To add one to something automatically, hence the name of the &lt;code&gt;++&lt;/code&gt; operator. To instead subtract one from something automatically is known as an &amp;ldquo;autodecrement&amp;rdquo;.</source>
          <target state="translated">Чтобы добавить единицу к чему-либо автоматически, отсюда и название оператора &lt;code&gt;++&lt;/code&gt; . Вместо этого автоматическое вычитание единицы из чего-либо известно как &amp;laquo;автодекремент&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="62767b0d851017800baeabeacc96e05ce69f9c80" translate="yes" xml:space="preserve">
          <source>To add to user-friendliness, our server prompts the user for commands. Most servers don't do this. Because of the prompt without a newline, you'll have to use the &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; variant of the interactive client above.</source>
          <target state="translated">Для удобства пользователя наш сервер запрашивает у пользователя команды. Большинство серверов этого не делают. Из-за приглашения без новой строки вам придется использовать вариант &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; интерактивного клиента выше.</target>
        </trans-unit>
        <trans-unit id="2982163185a13aaba90c2350554d80613d204e6d" translate="yes" xml:space="preserve">
          <source>To add to user-friendliness, our server prompts the user for commands. Most servers don't do this. Because of the prompt without a newline, you'll have to use the &lt;code&gt;sysread&lt;/code&gt; variant of the interactive client above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2508ff4f655eadc6c615c0836ceada22445901" translate="yes" xml:space="preserve">
          <source>To address these deficiencies, the concept of locales was invented (formally the ISO C, XPG4, POSIX 1.c &quot;locale system&quot;). And applications were and are being written that use the locale mechanism. The process of making such an application take account of its users' preferences in these kinds of matters is called &lt;b&gt;internationalization&lt;/b&gt; (often abbreviated as &lt;b&gt;i18n&lt;/b&gt;); telling such an application about a particular set of preferences is known as &lt;b&gt;localization&lt;/b&gt; (&lt;b&gt;l10n&lt;/b&gt;).</source>
          <target state="translated">Для устранения этих недостатков была изобретена концепция локалей (формально &amp;laquo;система локалей&amp;raquo; ISO C, XPG4, POSIX 1.c). И приложения были и пишутся, которые используют механизм локали. Процесс создания такого приложения с учетом предпочтений пользователей в подобных вопросах называется &lt;b&gt;интернационализацией&lt;/b&gt; (часто сокращенно &lt;b&gt;i18n&lt;/b&gt; ); сообщение такому приложению о конкретном наборе предпочтений называется &lt;b&gt;локализацией&lt;/b&gt; ( &lt;b&gt;l10n&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="38480288701c4661e4a26dcbd6037e4ac31c3101" translate="yes" xml:space="preserve">
          <source>To aid debugging, the source file</source>
          <target state="translated">Для облегчения отладки,исходный файл</target>
        </trans-unit>
        <trans-unit id="b056ef758d989b19b1755b858981a3d1c4ee3ad4" translate="yes" xml:space="preserve">
          <source>To alleviate the second problem (partially) it is advised to write your scripts like this:</source>
          <target state="translated">Чтобы облегчить вторую проблему (частично),рекомендуется писать свои скрипты таким образом:</target>
        </trans-unit>
        <trans-unit id="033bf41b49c5ad8519d831cfcfc92f95acf893c1" translate="yes" xml:space="preserve">
          <source>To allow programs to process arguments that look like switches, but aren't, both functions will stop processing switches when they see the argument &lt;code&gt;--&lt;/code&gt; . The &lt;code&gt;--&lt;/code&gt; will be removed from @ARGV.</source>
          <target state="translated">Чтобы позволить программам обрабатывать аргументы, которые выглядят как переключатели, но не являются, обе функции прекратят обработку переключателей, когда они увидят аргумент &lt;code&gt;--&lt;/code&gt; . Знак &lt;code&gt;--&lt;/code&gt; будет удален из @ARGV.</target>
        </trans-unit>
        <trans-unit id="26d2f668076a8bd4840d99c6ca84eae07eb71067" translate="yes" xml:space="preserve">
          <source>To allow programs to process arguments that look like switches, but aren't, both functions will stop processing switches when they see the argument &lt;code&gt;--&lt;/code&gt;. The &lt;code&gt;--&lt;/code&gt; will be removed from @ARGV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2288a81816c59a1de87c3ad78e6617983dda9fd7" translate="yes" xml:space="preserve">
          <source>To allow the XSUB for rpcb_gettime() to have a default host value the parameters to the XSUB could be rearranged. The XSUB will then call the real rpcb_gettime() function with the parameters in the correct order. This XSUB can be called from Perl with either of the following statements:</source>
          <target state="translated">Чтобы XSUB для rpcb_gettime()мог иметь значение хоста по умолчанию,параметры XSUB можно было бы переупорядочить.Затем XSUB будет вызывать реальную функцию rpcb_gettime()с параметрами в правильном порядке.Этот XSUB может быть вызван из Perl с помощью любого из следующих утверждений:</target>
        </trans-unit>
        <trans-unit id="4bdd80dbd948c58cb0887db4e2666aa7ba8a1b77" translate="yes" xml:space="preserve">
          <source>To ask for the next layer down use PerlIONext(PerlIO *f).</source>
          <target state="translated">Для запроса следующего слоя вниз используйте PerlIONext(PerlIO *f).</target>
        </trans-unit>
        <trans-unit id="5e82b72795636964d66437770c692b7d03ceb23b" translate="yes" xml:space="preserve">
          <source>To assign a specific &lt;b&gt;network address&lt;/b&gt; to a &lt;b&gt;socket&lt;/b&gt;.</source>
          <target state="translated">Чтобы назначить конкретный &lt;b&gt;сетевой адрес&lt;/b&gt; к &lt;b&gt;розетке&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c2805d5269d7141c86f56aaf1c2c2a76a26622" translate="yes" xml:space="preserve">
          <source>To assist you &lt;code&gt;test_test&lt;/code&gt; can colour the background of the debug information to disambiguate the different types of output. The debug output will have its background coloured green and red. The green part represents the text which is the same between the executed and actual output, the red shows which part differs.</source>
          <target state="translated">Чтобы помочь вам, &lt;code&gt;test_test&lt;/code&gt; может раскрасить фон отладочной информации, чтобы устранить неоднозначность различных типов вывода. Фон вывода отладки будет зеленым и красным. Зеленая часть представляет текст, который одинаков для выполненного и фактического вывода, красный показывает, какая часть отличается.</target>
        </trans-unit>
        <trans-unit id="e8e1cbea5e7824434cdf9fc699c75f29c54b93f0" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</source>
          <target state="translated">Чтобы автоматически определять и распаковывать поток данных RFC 1950 или RFC 1952 (например, gzip), установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da07f070c84b91e83551c266e4da3f67a05bb198" translate="yes" xml:space="preserve">
          <source>To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP_OR_ZLIB&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b525fdc47ff53e260dc0931cfbc7865b5eae8d3" translate="yes" xml:space="preserve">
          <source>To avoid ambiguity, when signatures are enabled the special syntax for prototypes is disabled. There is no attempt to guess whether a parenthesised group was intended to be a prototype or a signature. To give a subroutine a prototype under these circumstances, use a &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;prototype attribute&lt;/a&gt;. For example,</source>
          <target state="translated">Во избежание двусмысленности, когда подписи включены, специальный синтаксис для прототипов отключен. Нет попытки угадать, была ли заключенная в скобки группа задумана как прототип или подпись. Чтобы дать подпрограмме прототип в этих обстоятельствах, используйте &lt;a href=&quot;attributes#Built-in-Attributes&quot;&gt;атрибут prototype&lt;/a&gt; . Например,</target>
        </trans-unit>
        <trans-unit id="409b9ee9e716af7051876e4ad525c073a4badea1" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious failures, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">Чтобы избежать путаницы потенциальных пользователей вашего кода,которые работают с более ранними версиями Perl,с загадочными сбоями,поместите такие вещи в верхнюю часть файла,чтобы показать,что ваш код будет работать.</target>
        </trans-unit>
        <trans-unit id="cdb270b498c0b4af5dad93d34e6e87c778aa6616" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code who are running earlier versions of Perl with mysterious syntax errors, put this sort of thing at the top of your file to signal that your code will work</source>
          <target state="translated">Чтобы избежать путаницы потенциальных пользователей вашего кода,которые работают с более ранними версиями Perl,с загадочными синтаксическими ошибками,поместите такие вещи в верхнюю часть файла,чтобы показать,что ваш код будет работать.</target>
        </trans-unit>
        <trans-unit id="010f767fa3f7758e437e81843e72a2beb1516ec0" translate="yes" xml:space="preserve">
          <source>To avoid confusing would-be users of your code with mysterious syntax errors, put something like this at the top of your script:</source>
          <target state="translated">Чтобы избежать путаницы потенциальных пользователей вашего кода с загадочными синтаксическими ошибками,поместите что-то подобное в верхнюю часть вашего скрипта:</target>
        </trans-unit>
        <trans-unit id="92c9a11d8c00dc701cc8cb47a28dac284fb7ca76" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt; . Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt; , is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt; .</source>
          <target state="translated">Чтобы избежать создания нового SV каждый раз, &lt;code&gt;SaveSub2&lt;/code&gt; вызывается SaveSub2 , функция сначала проверяет, вызывалась ли она раньше. Если нет, то выделяется место для нового SV, и ссылка на &lt;code&gt;name&lt;/code&gt; подпрограммы Perl копируется в переменную &lt;code&gt;keepSub&lt;/code&gt; за одну операцию с использованием &lt;code&gt;newSVsv&lt;/code&gt; . После этого при каждом &lt;code&gt;SaveSub2&lt;/code&gt; существующий SV, &lt;code&gt;keepSub&lt;/code&gt; , перезаписывается новым значением с использованием &lt;code&gt;SvSetSV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb5249a309596988b57e0fd6c4b6cf1306fbd076" translate="yes" xml:space="preserve">
          <source>To avoid creating a new SV every time &lt;code&gt;SaveSub2&lt;/code&gt; is called, the function first checks to see if it has been called before. If not, then space for a new SV is allocated and the reference to the Perl subroutine &lt;code&gt;name&lt;/code&gt; is copied to the variable &lt;code&gt;keepSub&lt;/code&gt; in one operation using &lt;code&gt;newSVsv&lt;/code&gt;. Thereafter, whenever &lt;code&gt;SaveSub2&lt;/code&gt; is called, the existing SV, &lt;code&gt;keepSub&lt;/code&gt;, is overwritten with the new value using &lt;code&gt;SvSetSV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1c469efc6b2f6bb3fb09ea0c807689f209337a" translate="yes" xml:space="preserve">
          <source>To avoid memory leaks, all trailing duplicate entries in @INC are removed.</source>
          <target state="translated">Чтобы избежать утечки памяти,все дубликаты в @INC удаляются.</target>
        </trans-unit>
        <trans-unit id="fe0f91423917e2fcf830eb3362231efceaad6437" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt; , it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object
breaks encapsulation&lt;/code&gt; &quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="translated">Чтобы не полагаться на базовое представление объекта, если правый операнд smartmatch является объектом, который не перегружает &lt;code&gt;~~&lt;/code&gt; , он вызывает исключение &amp;laquo; &lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt; &amp;raquo;. Это потому, что никому не нужно копаться, чтобы увидеть, есть ли что-то &amp;laquo;внутри&amp;raquo; объекта. Все это недопустимо для объектов без &lt;code&gt;~~&lt;/code&gt; перегрузки:</target>
        </trans-unit>
        <trans-unit id="c22d05674967c3bc15cf7ec7d92f09d20cda4ca5" translate="yes" xml:space="preserve">
          <source>To avoid relying on an object's underlying representation, if the smartmatch's right operand is an object that doesn't overload &lt;code&gt;~~&lt;/code&gt;, it raises the exception &quot;&lt;code&gt;Smartmatching a non-overloaded object breaks encapsulation&lt;/code&gt;&quot;. That's because one has no business digging around to see whether something is &quot;in&quot; an object. These are all illegal on objects without a &lt;code&gt;~~&lt;/code&gt; overload:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a1998bc2a5a4986f2bb06eff8015bbc211cdc8" translate="yes" xml:space="preserve">
          <source>To avoid slab fragmentation, freed ops are marked as freed and attached to the slab's freed chain (an idea stolen from DBM::Deep). Those freed ops are reused when possible. Not reusing freed ops would be simpler, but it would result in significantly higher memory usage for programs with large &lt;code&gt;if (DEBUG) {...}&lt;/code&gt; blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c10393ba7ca423ef6dd3c94a2b581675efc33a8" translate="yes" xml:space="preserve">
          <source>To avoid the possibility of miscoordination, Perl now flushes FILEHANDLE before locking or unlocking it.</source>
          <target state="translated">Чтобы избежать возможности неправильной координации,Perl теперь промывает FILEHANDLE перед блокировкой или разблокировкой.</target>
        </trans-unit>
        <trans-unit id="3c85a34364c95e0f00f8b4537e9fe9720d82fa1b" translate="yes" xml:space="preserve">
          <source>To avoid this blocking behaviour, the caller should pass in the result of such a lookup using the &lt;code&gt;PeerAddrInfo&lt;/code&gt; or &lt;code&gt;LocalAddrInfo&lt;/code&gt; arguments. This can be achieved by using &lt;a href=&quot;Net::LibAsyncNS&quot;&gt;Net::LibAsyncNS&lt;/a&gt;, or the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function can be called in a child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5d75934a6f7e951fd9357cb74cb7683ab1e280" translate="yes" xml:space="preserve">
          <source>To avoid this problem, either put in extra parentheses or use the super low precedence &lt;code&gt;or&lt;/code&gt; operator:</source>
          <target state="translated">Чтобы избежать этой проблемы, либо заключите дополнительные скобки, либо используйте сверхнизкий приоритет &lt;code&gt;or&lt;/code&gt; оператор:</target>
        </trans-unit>
        <trans-unit id="766d42f164385b7f29a7e92b44d6d78b6d17a595" translate="yes" xml:space="preserve">
          <source>To avoid this problem, when it encounters a here document whilst extracting from a modifiable string, &lt;code&gt;extract_quotelike&lt;/code&gt; silently rearranges the string to an equivalent piece of Perl:</source>
          <target state="translated">Чтобы избежать этой проблемы, когда он встречает здесь документ при извлечении из изменяемой строки, &lt;code&gt;extract_quotelike&lt;/code&gt; незаметно переупорядочивает строку на эквивалентную часть Perl:</target>
        </trans-unit>
        <trans-unit id="da9ceee7d2a6a8bd92bf59b8dd4824301848ef6c" translate="yes" xml:space="preserve">
          <source>To avoid this warning and to avoid having different output encodings in a single stream, always specify an encoding explicitly, for example with a PerlIO layer:</source>
          <target state="translated">Чтобы избежать этого предупреждения и не иметь различных выходных кодировок в одном потоке,всегда указывайте кодировку явно,например,со слоем PerlIO:</target>
        </trans-unit>
        <trans-unit id="35af978891563db2721278dcfd7e8de9b9ef61ce" translate="yes" xml:space="preserve">
          <source>To avoid this, whenever a CV and its associated pad is freed, any &lt;code&gt;&amp;amp;&lt;/code&gt; entries in the pad are explicitly removed from the pad, and if the refcount of the pointed-to anon sub is still positive, then that child's &lt;code&gt;CvOUTSIDE&lt;/code&gt; is set to point to its grandparent. This will only occur in the single specific case of a non-closure anon prototype having one or more active references (such as &lt;code&gt;$a&lt;/code&gt; above).</source>
          <target state="translated">Чтобы избежать этого, всякий раз, когда CV и связанный с ним контактный блок освобождаются, любые записи &lt;code&gt;&amp;amp;&lt;/code&gt; в блоке явно удаляются из контактной площадки, и если счетчик ссылок указанной подпрограммы anon по-прежнему положительный, то &lt;code&gt;CvOUTSIDE&lt;/code&gt; этого дочернего элемента устанавливается на точку его бабушке и дедушке. Это произойдет только в единственном конкретном случае, когда прототип без закрытия анон имеет одну или несколько активных ссылок (например, &lt;code&gt;$a&lt;/code&gt; выше).</target>
        </trans-unit>
        <trans-unit id="892f516de74c75c59b1eb990ddf92d3f52eefdaf" translate="yes" xml:space="preserve">
          <source>To avoid this, you can force the Makefile to be rebuilt whenever you change the module containing the version number by adding this to your WriteMakefile() arguments.</source>
          <target state="translated">Чтобы избежать этого,вы можете заставить Makefile перестраиваться всякий раз,когда вы изменяете модуль,содержащий номер версии,добавив это в аргументы WriteMakefile().</target>
        </trans-unit>
        <trans-unit id="79bc3cfb105613cbe5f2c89b6ab087189a45bded" translate="yes" xml:space="preserve">
          <source>To avoid wasted work when a restart is needed, the sizing pass is abandoned - &lt;code&gt;regatom()&lt;/code&gt; immediately returns NULL, setting the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (This action is encapsulated using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</source>
          <target state="translated">Чтобы избежать ненужной работы, когда необходим перезапуск, &lt;code&gt;regatom()&lt;/code&gt; определения размера прекращается - regatom () немедленно возвращает NULL, устанавливая флаг &lt;code&gt;RESTART_UTF8&lt;/code&gt; . (Это действие инкапсулируется с помощью макроса &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; .) Этот запрос на перезапуск распространяется вверх по цепочке вызовов аналогичным образом, пока он не будет &amp;laquo;пойман&amp;raquo; в &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , который помечает шаблон как содержащий Unicode и перезапускает этап изменения размера. Также возможно, что конструкции внутри блоков кода времени выполнения нуждаются в представлении Unicode., О чем сигнализирует &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; возвращающий false в &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09e124c75c7cbe80f3e4228168f11f802fe412a9" translate="yes" xml:space="preserve">
          <source>To be able to access the two parameters that were pushed onto the stack after they return from</source>
          <target state="translated">Чтобы иметь доступ к двум параметрам,которые были затолканы в стек после их возвращения из</target>
        </trans-unit>
        <trans-unit id="6e3a208559e7fc6775f8912d077235f17cca0135" translate="yes" xml:space="preserve">
          <source>To be announced.</source>
          <target state="translated">Будет объявлено.</target>
        </trans-unit>
        <trans-unit id="161647c06ada22688c122c82ae94e4258d4b89c7" translate="yes" xml:space="preserve">
          <source>To be announced. Or deleted.</source>
          <target state="translated">Будет объявлено.Или удалить.</target>
        </trans-unit>
        <trans-unit id="1942f94bc444abb1b89482bc04403e0f7a2e9a63" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="translated">Для совместимости с регулярными выражениями .Net &lt;code&gt;\g{name}&lt;/code&gt; также может быть записано как &lt;code&gt;\k{name}&lt;/code&gt; , &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; или &lt;code&gt;\k'name'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f26c77c319cb6291a616300d3aa5bcb9b742805" translate="yes" xml:space="preserve">
          <source>To be compatible with .Net regular expressions, &lt;code&gt;\g{name}&lt;/code&gt; may also be written as &lt;code&gt;\k{name}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda9b7c28c9197f9e2d7b4ff8ca73ca58bad94f4" translate="yes" xml:space="preserve">
          <source>To be even more flexible, use &lt;code&gt;done_testing&lt;/code&gt;. This means we're just running some tests, don't know how many. [6]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3bab69ee4c24015f181f505f714806f55a6a5d" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="translated">Чтобы быть полностью совместимым с модулями Exporter и MakeMaker, вы должны сохранить номер версии вашего модуля в переменной пакета, отличной от моего, с именем $ VERSION. Это должно быть положительное число с плавающей запятой, по крайней мере, с двумя цифрами после десятичной дроби (т. Е. Сотые, например, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt; ). Не используйте версию в стиле &amp;laquo;1.3.2&amp;raquo;. Подробнее см. &lt;a href=&quot;exporter&quot;&gt;Экспортер&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aca5a42cae80e068514dd5dee0bc31352df05942" translate="yes" xml:space="preserve">
          <source>To be fully compatible with the Exporter and MakeMaker modules you should store your module's version number in a non-my package variable called $VERSION. This should be a positive floating point number with at least two digits after the decimal (i.e., hundredths, e.g, &lt;code&gt;$VERSION = &quot;0.01&quot;&lt;/code&gt;). Don't use a &quot;1.3.2&quot; style version. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781abe7cd10e483cb21c7189d334aa3e4eaca732" translate="yes" xml:space="preserve">
          <source>To be more precise, we will say that a regex program is an encoding of a graph. Each node in the graph corresponds to part of the original regex pattern, such as a literal string or a branch, and has a pointer to the nodes representing the next component to be matched. Since &quot;node&quot; and &quot;opcode&quot; already have other meanings in the perl source, we will call the nodes in a regex program &quot;regops&quot;.</source>
          <target state="translated">Точнее,мы скажем,что регекс-программа-это кодировка графа.Каждый узел графа соответствует части исходного регрессионного паттерна,например,буквенной строке или ветке,и имеет указатель на узлы,представляющие следующую компоненту,которая должна быть сопоставлена.Так как &quot;узел&quot; и &quot;опкод&quot; уже имеют другие значения в источнике perl,мы будем называть узлы в регрессионной программе &quot;regops&quot;.</target>
        </trans-unit>
        <trans-unit id="a03a7a550b2afe3393fb820749da17491cf98371" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="translated">Чтобы быть педантичным, на самом деле это сравнение &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR)&lt;/code&gt; , но это проблема, только если вы используете выражение с плавающей запятой; при неявном использовании &lt;code&gt;$.&lt;/code&gt; как описано в предыдущем абзаце, сравнение выполняется по типу &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;(EXPR) == &lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;($.)&lt;/code&gt; что возникает только тогда, когда &lt;code&gt;$.&lt;/code&gt; установлено значение с плавающей запятой, и вы не читаете из файла. Более того, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; или &lt;code&gt;2.18 .. 3.14&lt;/code&gt; не будет делать то, что вы хотите в скалярном контексте, потому что каждый из операндов оценивается с использованием своего целочисленного представления.</target>
        </trans-unit>
        <trans-unit id="7a2cc51866f8f7fa513bdcb0e655d22cd247b768" translate="yes" xml:space="preserve">
          <source>To be pedantic, the comparison is actually &lt;code&gt;int(EXPR) == int(EXPR)&lt;/code&gt;, but that is only an issue if you use a floating point expression; when implicitly using &lt;code&gt;$.&lt;/code&gt; as described in the previous paragraph, the comparison is &lt;code&gt;int(EXPR) == int($.)&lt;/code&gt; which is only an issue when &lt;code&gt;$.&lt;/code&gt; is set to a floating point value and you are not reading from a file. Furthermore, &lt;code&gt;&quot;span&quot; .. &quot;spat&quot;&lt;/code&gt; or &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed53a49e46f6db6479ffd9a906bbff37f48f8995" translate="yes" xml:space="preserve">
          <source>To be polite to other functions wrapping your own you usually want to increment &lt;code&gt;$Level&lt;/code&gt; rather than set it to a constant.</source>
          <target state="translated">Чтобы быть вежливым по отношению к другим функциям, обертывающим ваши собственные, вы обычно хотите увеличивать &lt;code&gt;$Level&lt;/code&gt; а не устанавливать его на константу.</target>
        </trans-unit>
        <trans-unit id="377966b7899d2c6cc0617addc0bc388cc67a68ae" translate="yes" xml:space="preserve">
          <source>To be portable each component of a module name should be limited to 11 characters. If it might be used on MS-DOS then try to ensure each is unique in the first 8 characters. Nested modules make this easier.</source>
          <target state="translated">Чтобы быть переносимым,каждый компонент названия модуля должен быть ограничен до 11 символов.Если он может быть использован в MS-DOS,то постарайтесь,чтобы каждый из них был уникальным в первых 8 символов.Вложенные модули облегчают эту задачу.</target>
        </trans-unit>
        <trans-unit id="82fd649ae548631dbfdff32da1fa30eb76335c87" translate="yes" xml:space="preserve">
          <source>To be safe, we should have anchored the above example, to prevent matches for something like &lt;code&gt;Hebrew_Braille&lt;/code&gt;, but there aren't any script names like that, so far. A warning is issued if none of the legal values for a property are matched by your pattern. It's likely that a future release will raise a warning if your pattern ends up causing every possible code point to match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b076f38e81902902b25d1f17b1608ab8be160484" translate="yes" xml:space="preserve">
          <source>To begin your reading, start with:</source>
          <target state="translated">Чтобы начать читать,начни с:</target>
        </trans-unit>
        <trans-unit id="a61e1eb5d11062cb9036bb12d10d76fe348be7c1" translate="yes" xml:space="preserve">
          <source>To browse existing Perl bugs and patches, you can use the web interface at &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt;.</source>
          <target state="translated">Чтобы просмотреть существующие ошибки и исправления Perl, вы можете использовать веб-интерфейс по адресу &lt;a href=&quot;http://rt.perl.org/&quot;&gt;http://rt.perl.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b19b13b7eebea3b4a95edad33fffc49ec225b2e5" translate="yes" xml:space="preserve">
          <source>To build a non-XS module, you can use the standard module-building instructions distributed with perl modules.</source>
          <target state="translated">Для создания модуля,отличного от XS,можно использовать стандартные инструкции по созданию модулей,распространяемые с модулями perl.</target>
        </trans-unit>
        <trans-unit id="6c2705e01ac97996d808db8effeb88881961867f" translate="yes" xml:space="preserve">
          <source>To build an XS module, you must use the standard module-building instructions distributed with perl modules *PLUS* three extra instructions specific to the DJGPP &quot;static link&quot; build environment.</source>
          <target state="translated">Для сборки модуля XS необходимо использовать стандартные инструкции по сборке модулей,распространяемые с модулями perl *PLUS*,три дополнительные инструкции,специфичные для среды сборки &quot;статической связи&quot; DJGPP.</target>
        </trans-unit>
        <trans-unit id="d5c2765f0199128d509d1897ee86d4417f4dd8a3" translate="yes" xml:space="preserve">
          <source>To build extensions other than standard extensions, NetWare Perl has to be installed on Windows along with Windows Perl. The Perl for Windows can be either downloaded from the CPAN site and built using the sources, or the binaries can be directly downloaded from the ActiveState site. Installation can be done by invoking</source>
          <target state="translated">Для создания расширений,отличных от стандартных,NetWare Perl должен быть установлен на Windows вместе с Windows Perl.Perl для Windows может быть либо загружен с сайта CPAN и построен с использованием исходных текстов,либо исполняемые файлы могут быть непосредственно загружены с сайта ActiveState.Установка может быть выполнена путем вызова</target>
        </trans-unit>
        <trans-unit id="787c86241856156cd077a05b7bdc7004761044c1" translate="yes" xml:space="preserve">
          <source>To build perl from its source code on the Stratus V Series platform you must have OpenVOS Release 17.1.0 or later, GNU Tools Release 3.5 or later, and the C/POSIX Runtime Libraries.</source>
          <target state="translated">Для сборки perl из его исходных текстов на платформе серии Stratus V вы должны иметь OpenVOS версии 17.1.0 или более поздней,GNU Tools версии 3.5 или более поздней,а также библиотеки времени исполнения C/POSIX Runtime Libraries.</target>
        </trans-unit>
        <trans-unit id="b8374368118e0a9e9250156402520f453adca786" translate="yes" xml:space="preserve">
          <source>To build perl under AmigaOS from the patched sources you will need to have a recent version of the SDK. Version 53.29 is recommended, earlier versions will probably work too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d9cfbafe7af9c12fb5ae5d7307a03b50f8bc3e" translate="yes" xml:space="preserve">
          <source>To build perl with AddressSanitizer, your Configure invocation should look like:</source>
          <target state="translated">Для построения perl с помощью AddressSanitizer,ваше обращение Configure должно выглядеть как:</target>
        </trans-unit>
        <trans-unit id="b12975798f70dc1cb8c9fb59b7af2b4445d07d6d" translate="yes" xml:space="preserve">
          <source>To calculate the digest of an n-bit message where</source>
          <target state="translated">Для вычисления дайджеста n-битного сообщения,где</target>
        </trans-unit>
        <trans-unit id="0df1e5f84b4694c53717b89d6fb8b89ff7d44718" translate="yes" xml:space="preserve">
          <source>To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N 139.8E) in kilometers:</source>
          <target state="translated">Рассчитать расстояние между Лондоном (51,3N 0,5W)и Токио (35,7N 139,8E)в километрах:</target>
        </trans-unit>
        <trans-unit id="4cea3ec7425389162d89934663cf2df355daf6af" translate="yes" xml:space="preserve">
          <source>To call a function on each element in an array, and collect the results, use:</source>
          <target state="translated">Для вызова функции по каждому элементу массива и сбора результатов,используйте:</target>
        </trans-unit>
        <trans-unit id="dbe4aebe356ab30727111304ed5066c2800f1b44" translate="yes" xml:space="preserve">
          <source>To call a function on each element of an array, but ignore the results:</source>
          <target state="translated">Вызвать функцию по каждому элементу массива,но игнорировать результаты:</target>
        </trans-unit>
        <trans-unit id="710b700709beaae3a0d7fb3e17148d99cdb1ee11" translate="yes" xml:space="preserve">
          <source>To call a function on each integer in a (small) range, you &lt;b&gt;can&lt;/b&gt; use:</source>
          <target state="translated">Чтобы вызвать функцию для каждого целого числа в (небольшом) диапазоне, вы &lt;b&gt;можете&lt;/b&gt; использовать:</target>
        </trans-unit>
        <trans-unit id="b0c03ca703f3d70571e4ed1a5f4b95eb2f4f7eac" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt; .</source>
          <target state="translated">Для вызова отдельных подпрограмм Perl вы можете использовать любую из функций &lt;b&gt;call_ *,&lt;/b&gt; задокументированных в &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; . В этом примере мы будем использовать &lt;code&gt;call_argv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0356115da72e97143cd3fb75c87b7ab25d47c5" translate="yes" xml:space="preserve">
          <source>To call individual Perl subroutines, you can use any of the &lt;b&gt;call_*&lt;/b&gt; functions documented in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;. In this example we'll use &lt;code&gt;call_argv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49f3d19c459317781abadc37d2ae6f14022eac3" translate="yes" xml:space="preserve">
          <source>To call subroutines:</source>
          <target state="translated">Чтобы вызвать подпрограммы:</target>
        </trans-unit>
        <trans-unit id="5abcacc2499f97bcbde0588fdd4401b44cc6c01a" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT (ordering is important here):</source>
          <target state="translated">Чтобы захватить STDERR команды,но отбросить ее STDOUT (здесь важен заказ):</target>
        </trans-unit>
        <trans-unit id="891b8754dd37bb2c3dc54aab3a1185e0fd372170" translate="yes" xml:space="preserve">
          <source>To capture a command's STDERR but discard its STDOUT:</source>
          <target state="translated">Чтобы захватить STDERR команды,но отбросить ее STDOUT:</target>
        </trans-unit>
        <trans-unit id="7ddfc050c95c3b76b8561d8851899b023835e01c" translate="yes" xml:space="preserve">
          <source>To capture a command's STDOUT but discard its STDERR:</source>
          <target state="translated">Захватить СТДУАТ команды,но отбросить СТДЕРР:</target>
        </trans-unit>
        <trans-unit id="459bfbbfb62f196ec5bdfb8f616f754fb8b81d04" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, and let its STDOUT go to our own STDERR:</source>
          <target state="translated">Захватить СТДЕРР программы и отпустить ее СТДУТ в наш собственный СТДЕРР:</target>
        </trans-unit>
        <trans-unit id="5bd52eb04283645c047b422b0b8e0a7d88ad61c6" translate="yes" xml:space="preserve">
          <source>To capture a program's STDERR, but discard its STDOUT:</source>
          <target state="translated">Захватить СТДЕРР программы,но отбросить ее СТДАУТ:</target>
        </trans-unit>
        <trans-unit id="8a448a300769cb48dfafecf642b7105f4ae83d7b" translate="yes" xml:space="preserve">
          <source>To capture a program's STDOUT, but discard its STDERR:</source>
          <target state="translated">Захватить СТДУАТ программы,но отбросить СТДУЭРР:</target>
        </trans-unit>
        <trans-unit id="48535a0ea84ddf99c0ff0191b2ebc7ac2d2965e6" translate="yes" xml:space="preserve">
          <source>To catch this kind of problem, we can force each variable to be declared before use by pulling in the strict module, by putting 'use strict;' after the first line of the script.</source>
          <target state="translated">Чтобы поймать такую проблему,мы можем заставить каждую переменную быть объявленной перед использованием,потянув в строгий модуль,поставив 'use strict;' после первой строки скрипта.</target>
        </trans-unit>
        <trans-unit id="ee4539dea7c8d87e83fb7b99fbcea7146f28bf41" translate="yes" xml:space="preserve">
          <source>To center a whole line of text, do something like this:</source>
          <target state="translated">Чтобы отцентрировать целую строку текста,сделай что-нибудь вроде этого:</target>
        </trans-unit>
        <trans-unit id="cb50b80c4012bf8864c9070a8feaf64a654c0893" translate="yes" xml:space="preserve">
          <source>To change existing lines, insert the code to modify the lines inside the &lt;code&gt;while&lt;/code&gt; loop. In this case, the code finds all lowercased versions of &quot;perl&quot; and uppercases them. The happens for every line, so be sure that you're supposed to do that on every line!</source>
          <target state="translated">Для изменения существующих строк, вставьте код для изменения строк внутри в &lt;code&gt;while&lt;/code&gt; цикла. В этом случае код находит все версии &amp;laquo;perl&amp;raquo; в нижнем регистре и в верхнем регистре. Это происходит для каждой строки, поэтому убедитесь, что вы должны делать это на каждой строке!</target>
        </trans-unit>
        <trans-unit id="3014ba02f0b23a5077d149c5a55186e1b0210812" translate="yes" xml:space="preserve">
          <source>To change one of these elements, just assign to it like this:</source>
          <target state="translated">Чтобы изменить один из этих элементов,просто назначьте его так:</target>
        </trans-unit>
        <trans-unit id="0bc26e290e338fd9cb7ec178f79c71f3fe32327a" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt; , is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="translated">Чтобы изменить только конкретную строку, введите номер строки ввода, &lt;code&gt;$.&lt;/code&gt; , является полезным. Сначала прочтите и распечатайте строки до той, которую вы хотите изменить. Затем прочтите единственную строку, которую вы хотите изменить, измените ее и распечатайте. После этого прочтите остальные строки и распечатайте их:</target>
        </trans-unit>
        <trans-unit id="8261e5499a7ae4c48592a1983635f3df7192d7cc" translate="yes" xml:space="preserve">
          <source>To change only a particular line, the input line number, &lt;code&gt;$.&lt;/code&gt;, is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b3b581f75dc5b407edfb21187704d85ccc3337" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt; , the input line number, then only perform the operation when the test passes:</source>
          <target state="translated">Чтобы изменить только пятую строку, вы можете добавить тестовую проверку &lt;code&gt;$.&lt;/code&gt; , номер строки ввода, затем выполнить операцию только после успешного прохождения теста:</target>
        </trans-unit>
        <trans-unit id="833e5f56fff3dfac3d9eb1d5cb139919fbf68571" translate="yes" xml:space="preserve">
          <source>To change only the fifth line, you can add a test checking &lt;code&gt;$.&lt;/code&gt;, the input line number, then only perform the operation when the test passes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac56000e9557456388facc9434e99b2f25c68f2" translate="yes" xml:space="preserve">
          <source>To change part of a string, you can use the optional fourth argument which is the replacement string.</source>
          <target state="translated">Для изменения части строки можно использовать необязательный четвертый аргумент-строку замены.</target>
        </trans-unit>
        <trans-unit id="159bf1e2399227a81a68240fcbc4a8d0c4d4386e" translate="yes" xml:space="preserve">
          <source>To change the configuration you will need to use either the &lt;code&gt;-c&lt;/code&gt; or the &lt;code&gt;-d&lt;/code&gt; options.</source>
          <target state="translated">Чтобы изменить конфигурацию, вам нужно будет использовать параметры &lt;code&gt;-c&lt;/code&gt; или &lt;code&gt;-d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82b774af2b2d757667a119fdffcb3a39066bffc5" translate="yes" xml:space="preserve">
          <source>To change the value of an</source>
          <target state="translated">Чтобы изменить значение</target>
        </trans-unit>
        <trans-unit id="c3243d9e5f9c11b853cdbfbdad7815af406db7ec" translate="yes" xml:space="preserve">
          <source>To check if you've got an object derived from a specific class you have to write:</source>
          <target state="translated">Чтобы проверить,есть ли у вас объект,производный от определенного класса,вам нужно написать:</target>
        </trans-unit>
        <trans-unit id="b5f0280c18244571ee821966259aa01905eea140" translate="yes" xml:space="preserve">
          <source>To check that a PerlIO* is valid use PerlIOValid(PerlIO *f). (All this does is really just to check that the pointer is non-NULL and that the pointer behind that is non-NULL.)</source>
          <target state="translated">Чтобы проверить,что PerlIO*является действительным,используйте PerlIOValid(PerlIO *f).(На самом деле это делается только для того,чтобы проверить,что указатель не является NULL и что указатель,находящийся за ним,не является NULL).</target>
        </trans-unit>
        <trans-unit id="6efc33cfc9910a60ea4ef9bf5110b124df74dec6" translate="yes" xml:space="preserve">
          <source>To circumvent this, Perl uses two hacks. They help against</source>
          <target state="translated">Чтобы обойти это,Перл использует два взлома.Они помогают против</target>
        </trans-unit>
        <trans-unit id="fc16356cccf83cfc4cbdd42d7b6c6a4bf9f4c7cd" translate="yes" xml:space="preserve">
          <source>To clean up after compilation you can use either of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b687155f88b0a0c7f0b7a50cd6c0fc2a98e0825" translate="yes" xml:space="preserve">
          <source>To clear the screen, you just have to print the special sequence that tells the terminal to clear the screen. Once you have that sequence, output it when you want to clear the screen.</source>
          <target state="translated">Чтобы очистить экран,достаточно распечатать специальную последовательность,которая говорит терминалу очистить экран.Как только вы получите эту последовательность,выводите ее,когда захотите очистить экран.</target>
        </trans-unit>
        <trans-unit id="aeb7d489151127988ed87013a2d0db094b3d4f08" translate="yes" xml:space="preserve">
          <source>To commit to a maintenance version of perl, you need to create a local tracking branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45964cfffa3b2dbc072504434f04f57c4932a60" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;&lt;code&gt;foldEQ_utf8()&lt;/code&gt;&lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5339fbdb482ebe20149617c58a946c9025ec4bd2" translate="yes" xml:space="preserve">
          <source>To compare two strings case-insensitively, use &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;foldEQ_utf8() &lt;/a&gt; (the strings don't have to have the same UTF-8ness).</source>
          <target state="translated">Чтобы сравнить две строки без &lt;a href=&quot;perlapi#foldEQ_utf8&quot;&gt;учета&lt;/a&gt; регистра, используйте foldEQ_utf8 () (строки не обязательно должны иметь одинаковую кодировку UTF-8).</target>
        </trans-unit>
        <trans-unit id="9ef4437f2da5ad50f0107615b5cd7fb7937669db" translate="yes" xml:space="preserve">
          <source>To compile Perl with threads, add -Dusethreads to the arguments of Configure. Verify that the -D_POSIX_C_SOURCE=199506L compiler flag is automatically added to the list of flags. Also make sure that -lpthread is listed before -lc in the list of libraries to link Perl with. The hints provided for HP-UX during Configure will try very hard to get this right for you.</source>
          <target state="translated">Чтобы скомпилировать Perl с потоками,добавьте -Dusethreads к аргументам Configure.Убедитесь,что флаг компилятора -D_POSIX_C_SOURCE=199506L автоматически добавлен в список флагов.Также убедитесь,что -lpthread указан перед -lc в списке библиотек для линковки Perl.Подсказки,предоставляемые для HP-UX во время конфигурирования,очень постараются сделать это правильно.</target>
        </trans-unit>
        <trans-unit id="dca1f2d388460992485bc83958326b4fabbe3a89" translate="yes" xml:space="preserve">
          <source>To compile a 64-bit application on an UltraSparc with a recent Sun Compiler, you need to use the flag &quot;-xarch=v9&quot;. getconf(1) will tell you this, e.g.</source>
          <target state="translated">Для компиляции 64-битного приложения на UltraSparc с недавним компилятором Sun необходимо использовать флаг &quot;-xarch=v9&quot;.getconf(1)скажет об этом,например.</target>
        </trans-unit>
        <trans-unit id="aafe5bf2c4343a0e3d4371c91d0581b8bfb71744" translate="yes" xml:space="preserve">
          <source>To compile the demonstration application PerlApp you need first to install the Perl headers under the SDK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a608f7610a06343062c0a4f15a78987866b679" translate="yes" xml:space="preserve">
          <source>To compress all files in the directory &quot;/my/home&quot; that match &quot;*.txt&quot; and store the compressed data in the same directory</source>
          <target state="translated">Сжимать все файлы в директории &quot;/my/home&quot;,соответствующие &quot;*.txt&quot; и хранить сжатые данные в той же директории.</target>
        </trans-unit>
        <trans-unit id="e79c6c77e53867aede1a00267dc0d36f666b7950" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number between 8 and 15.</source>
          <target state="translated">Чтобы сжать поток данных RFC 1950, установите &lt;code&gt;WindowBits&lt;/code&gt; на положительное число от 8 до 15.</target>
        </trans-unit>
        <trans-unit id="7421981a167883ab2bc4949efb716b7db4314b6b" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">Чтобы сжать поток данных RFC 1951, установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7349fcec84071676b172827e1a49b634a1fdb7" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0992d170df6f988844c94c5a16d02581fe60f0" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt; .</source>
          <target state="translated">Чтобы сжать поток данных RFC 1952 (например, gzip), установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;WANT_GZIP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3745f78ab286dd7d4193d09748c3eef61c61724d" translate="yes" xml:space="preserve">
          <source>To compress an RFC 1952 data stream (i.e. gzip), set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;WANT_GZIP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0a5b03c1713572aa7618df4ce2ea31c5f8ea2a" translate="yes" xml:space="preserve">
          <source>To concatenate</source>
          <target state="translated">Конкатенат</target>
        </trans-unit>
        <trans-unit id="6e6c0c8d29557c5cf786e08230a13bcf9f5a031b" translate="yes" xml:space="preserve">
          <source>To configure the</source>
          <target state="translated">Чтобы настроить</target>
        </trans-unit>
        <trans-unit id="27b8a31fcae13694057ef8e5270215d578e3caf3" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8324e82632846a0ff4c29dfcce46aaf6bb8f9fb" translate="yes" xml:space="preserve">
          <source>To connect one filehandle to several output filehandles, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO::Tee&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie::FileHandle::Multiplex&lt;/a&gt; modules.</source>
          <target state="translated">Чтобы подключить один дескриптор файла к нескольким дескрипторам вывода, вы можете использовать модули &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Tee&quot;&gt;IO :: Tee&lt;/a&gt; или &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::FileHandle::Multiplex&quot;&gt;Tie :: FileHandle :: Multiplex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d6cbc660d600cd1c4583162826d97d790f4bf63" translate="yes" xml:space="preserve">
          <source>To conserve memory you should have your compiler modules loaded into the Link Pack Area (LPA/ELPA) rather than in a link list or step lib.</source>
          <target state="translated">Для экономии памяти вам следует загружать модули компилятора в Link Pack Area (LPA/ELPA),а не в список ссылок или step lib.</target>
        </trans-unit>
        <trans-unit id="968a823fad5813dfb21cd46750147776a5611926" translate="yes" xml:space="preserve">
          <source>To considerably speed up the initial CPAN shell startup, it is possible to use Storable to create a cache of metadata. If Storable is not available, the normal index mechanism will be used.</source>
          <target state="translated">Чтобы значительно ускорить начальный запуск CPAN оболочки,можно использовать Storable для создания кэша метаданных.Если Storable недоступен,будет использован обычный механизм индексации.</target>
        </trans-unit>
        <trans-unit id="20a4b2b8d77aba12d02e264b26db5b4fc2052c4a" translate="yes" xml:space="preserve">
          <source>To contact the author, send email to: &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt;</source>
          <target state="translated">Чтобы связаться с автором, отправьте электронное письмо по &lt;code&gt;mjd-perl-tiefile+@plover.com&lt;/code&gt; : mjd-perl-tiefile+@plover.com</target>
        </trans-unit>
        <trans-unit id="d4e7d2faeb717445863f554610fdabbf94c812cb" translate="yes" xml:space="preserve">
          <source>To control what text is used for display, you use &quot;&lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt;&quot;, as in:</source>
          <target state="translated">Чтобы контролировать, какой текст используется для отображения, вы используете &amp;laquo; &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; &amp;raquo;, например:</target>
        </trans-unit>
        <trans-unit id="7f787791e1e7cbfd6f94bf52b9685495ede53680" translate="yes" xml:space="preserve">
          <source>To convert &lt;a href=&quot;config#perlpath&quot;&gt;&lt;code&gt;$Config{perlpath}&lt;/code&gt;&lt;/a&gt; to a file pathname, say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07c15697f1959a79e3e58a6af11dd7e45671417" translate="yes" xml:space="preserve">
          <source>To convert &lt;a href=&quot;perlvar#%24%5EX&quot;&gt;&lt;code&gt;$^X&lt;/code&gt;&lt;/a&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2616580d4b758d8bc7475f582ba3ef32958144" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$Config{perlpath}&lt;/code&gt; to a file pathname, say:</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;$Config{perlpath}&lt;/code&gt; в путь к файлу, скажите:</target>
        </trans-unit>
        <trans-unit id="445d48b4e3ded0561c8b941a914e856d01c116d2" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;$^X&lt;/code&gt; to a file pathname, taking account of the requirements of the various operating system possibilities, say:</source>
          <target state="translated">Чтобы преобразовать &lt;code&gt;$^X&lt;/code&gt; в путь к файлу с учетом требований различных возможностей операционной системы, скажите:</target>
        </trans-unit>
        <trans-unit id="c00d24e73fce2df83990c0f155f2d36a18a08fc4" translate="yes" xml:space="preserve">
          <source>To convert an octal number, use from_oct();</source>
          <target state="translated">Для преобразования восьмеричного числа используйте функцию from_oct();</target>
        </trans-unit>
        <trans-unit id="7d95d35a7d9c8de57b1e556f0a9920a9c8320986" translate="yes" xml:space="preserve">
          <source>To convert from EBCDIC 037 to ASCII just reverse the order of the tr/// arguments like so:</source>
          <target state="translated">Для преобразования из EBCDIC 037 в ASCII просто переверните порядок аргументов tr///так:</target>
        </trans-unit>
        <trans-unit id="e95102da8c741e9ba252adcb490152dec1b8623d" translate="yes" xml:space="preserve">
          <source>To convert from new-style to old-style, follow this recipe:</source>
          <target state="translated">Чтобы перейти от нового стиля к старому,следуйте этому рецепту:</target>
        </trans-unit>
        <trans-unit id="b7383321848919d955ca5bfae7880346b845b2ba" translate="yes" xml:space="preserve">
          <source>To convert strings that might start with any of &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0x&lt;/code&gt;, or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt;. To present something as hex, look into &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa39707ee5532360879dd87b7e44a99cff8fee0" translate="yes" xml:space="preserve">
          <source>To copy all your .c file to a backup directory</source>
          <target state="translated">Чтобы скопировать все ваши .c-файлы в каталог резервного копирования.</target>
        </trans-unit>
        <trans-unit id="5ab2f997dcaa14c701c81b93174b6bfe66ee6931" translate="yes" xml:space="preserve">
          <source>To copy the array, use</source>
          <target state="translated">Чтобы скопировать массив,используйте</target>
        </trans-unit>
        <trans-unit id="49c50a429b3a772bc583381f94d7fd07c2224e83" translate="yes" xml:space="preserve">
          <source>To correctly maintain reference counts, it is essential to keep track of what references the XS code is manipulating. The programmer should always know where a reference has come from and who owns it, and be aware of any creation or destruction of references, and any transfers of ownership. Because ownership isn't represented explicitly in the xV data structures, only the reference count need be actually maintained by the code, and that means that this understanding of ownership is not actually evident in the code. For example, transferring ownership of a reference from one owner to another doesn't change the reference count at all, so may be achieved with no actual code. (The transferring code doesn't touch the referenced object, but does need to ensure that the former owner knows that it no longer owns the reference, and that the new owner knows that it now does.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86582412ddc1c4958ec10cc1409f68b2a052f72a" translate="yes" xml:space="preserve">
          <source>To cover such cases, you can redispatch methods via:</source>
          <target state="translated">Чтобы охватить такие случаи,можно использовать методы повторного исправления:</target>
        </trans-unit>
        <trans-unit id="816db1c262f755f697320a74d5b828dbd17231a2" translate="yes" xml:space="preserve">
          <source>To create Unicode characters in literals, use the &lt;code&gt;\N{...}&lt;/code&gt; notation in double-quoted strings:</source>
          <target state="translated">Чтобы создать символы Юникода в литералах, используйте нотацию &lt;code&gt;\N{...}&lt;/code&gt; в строках , заключенных в двойные кавычки:</target>
        </trans-unit>
        <trans-unit id="c36e175a2f7ac1c4707a3b48724437b649be4b2b" translate="yes" xml:space="preserve">
          <source>To create a POD filter for translating POD documentation into some other format, you create a subclass of &lt;b&gt;Pod::Parser&lt;/b&gt; which typically overrides just the base class implementation for the following methods:</source>
          <target state="translated">Чтобы создать фильтр POD для перевода документации POD в какой-либо другой формат, вы создаете подкласс &lt;b&gt;Pod :: Parser,&lt;/b&gt; который обычно переопределяет только реализацию базового класса для следующих методов:</target>
        </trans-unit>
        <trans-unit id="3376aadc06d935bc6556cf078e6fff6d6ceed1e6" translate="yes" xml:space="preserve">
          <source>To create a Perl module that implements a PerlIO layer in Perl (as opposed to in C using XS as the interface to Perl), you need to supply some of the following subroutines. It is recommended to create these Perl modules in the PerlIO::via:: namespace, so that they can easily be located on CPAN and use the default namespace feature of the PerlIO::via module itself.</source>
          <target state="translated">Для создания модуля Perl,реализующего слой PerlIO на Perl (в отличие от модуля на C,использующего XS в качестве интерфейса к Perl),необходимо ввести некоторые из следующих подпрограмм.Рекомендуется создавать эти Perl-модули в пространстве имён PerlIO::via:,чтобы их можно было легко разместить на CPAN и использовать функцию пространства имён по умолчанию PerlIO::via самого модуля.</target>
        </trans-unit>
        <trans-unit id="cea82dcc2341d67ceae28cb7f8dd640de30d8fab" translate="yes" xml:space="preserve">
          <source>To create a child &lt;b&gt;process&lt;/b&gt; identical to the parent process at its moment of conception, at least until it gets ideas of its own. A thread with protected memory.</source>
          <target state="translated">Создать дочерний &lt;b&gt;процесс,&lt;/b&gt; идентичный родительскому процессу в момент его зачатия, по крайней мере, до тех пор, пока у него не появятся собственные идеи. Поток с защищенной памятью.</target>
        </trans-unit>
        <trans-unit id="973c5f5d0d37e9d577d7def77212ab83a77d00d7" translate="yes" xml:space="preserve">
          <source>To create a complex number, use either:</source>
          <target state="translated">Чтобы создать комплексное число,используйте либо то,либо другое:</target>
        </trans-unit>
        <trans-unit id="2ba00f13d11568a68eea0b9363c1c701b94f3530" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt; . For example:</source>
          <target state="translated">Чтобы создать обработчик, определите его как подпрограмму с тем же именем, что и желаемый атрибут, и объявите саму подпрограмму с атрибутом &lt;code&gt;:ATTR&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="7be1f84ddb058aa59042284e3c774355eb9bd0e7" translate="yes" xml:space="preserve">
          <source>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute &lt;code&gt;:ATTR&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8c75fd66b25e79071f909e18cf1703b677444d" translate="yes" xml:space="preserve">
          <source>To create a mortal reference, use the functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f301595bc4c387e143da9231296df032806e83c" translate="yes" xml:space="preserve">
          <source>To create a mortal variable, use the functions:</source>
          <target state="translated">Для создания смертельной переменной используйте функции:</target>
        </trans-unit>
        <trans-unit id="168d2bd52151b2f88de55aa6a46a9bc34a213502" translate="yes" xml:space="preserve">
          <source>To create a named pipe, use the &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; function.</source>
          <target state="translated">Чтобы создать именованный канал, используйте функцию &lt;code&gt;POSIX::mkfifo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4519b518bb57bb6e760a3915cac3cb53c117b7" translate="yes" xml:space="preserve">
          <source>To create a new Perl variable with an undef value which can be accessed from your Perl script, use the following routines, depending on the variable type.</source>
          <target state="translated">Чтобы создать новую переменную Perl со значением undef,к которой можно получить доступ из вашего Perl скрипта,используйте следующие процедуры,в зависимости от типа переменной.</target>
        </trans-unit>
        <trans-unit id="c5e6c240b7113609dabfe56dd41076e1c64fdaed" translate="yes" xml:space="preserve">
          <source>To create a new compartment, use</source>
          <target state="translated">Для создания нового отсека используйте</target>
        </trans-unit>
        <trans-unit id="5e69f259d43b2f65fc36274b2ebe4426a448a0c1" translate="yes" xml:space="preserve">
          <source>To create a patch file for all your local changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f8f5de503a593a35d422a3d1a1da701a2bb15e" translate="yes" xml:space="preserve">
          <source>To create a reference, use either of the following functions:</source>
          <target state="translated">Для создания ссылки используйте одну из следующих функций:</target>
        </trans-unit>
        <trans-unit id="3b14234e60346a5da75e272e4ecdc1bcef627a2f" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt; ).</source>
          <target state="translated">Для создания ссылки мы используем функцию &lt;code&gt;newRV&lt;/code&gt; . Обратите внимание, что в этом случае (и во многих других) вы можете преобразовать AV * или HV * в тип SV *. Это позволяет вам использовать ссылки на массивы, хэши и скаляры с одной и той же функцией. И наоборот, функция &lt;code&gt;SvRV&lt;/code&gt; всегда возвращает SV *, который может потребоваться привести к соответствующему типу, если это нечто иное, чем скаляр (проверьте с помощью &lt;code&gt;SvTYPE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="76c3711b1f4442657fc38b46f51a53e19c63e499" translate="yes" xml:space="preserve">
          <source>To create a reference, we use the &lt;code&gt;newRV_inc&lt;/code&gt; function. Note that you can cast an AV* or an HV* to type SV* in this case (and many others). This allows you to take references to arrays, hashes and scalars with the same function. Conversely, the &lt;code&gt;SvRV&lt;/code&gt; function always returns an SV*, which may need to be cast to the appropriate type if it is something other than a scalar (check with &lt;code&gt;SvTYPE&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f750d278ece92b690ce083757a8b99d17e4a1cc6" translate="yes" xml:space="preserve">
          <source>To create a shared library, the following steps must be performed:</source>
          <target state="translated">Для создания общей библиотеки необходимо выполнить следующие шаги:</target>
        </trans-unit>
        <trans-unit id="3c6eb343e88be36bc92d3d97f3219df475d3ded3" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt; , that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="translated">Чтобы создать zip-файл &lt;code&gt;output.zip&lt;/code&gt; , содержащий сжатое содержимое файлов &lt;code&gt;alpha.txt&lt;/code&gt; и &lt;code&gt;beta.txt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b6ff2c8131533c1aec284cd279aab620b4a7896" translate="yes" xml:space="preserve">
          <source>To create a zip file, &lt;code&gt;output.zip&lt;/code&gt;, that contains the compressed contents of the files &lt;code&gt;alpha.txt&lt;/code&gt; and &lt;code&gt;beta.txt&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a9c4100fca7c9df2f642138fcef0fc96929592" translate="yes" xml:space="preserve">
          <source>To create an HV, you use the following routine:</source>
          <target state="translated">Чтобы создать HV,вы используете следующую процедуру:</target>
        </trans-unit>
        <trans-unit id="0094ef6c2580e3be5fb982924088c9990a9a669b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1950 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to a positive number.</source>
          <target state="translated">Чтобы создать поток данных RFC 1950, установите &lt;code&gt;WindowBits&lt;/code&gt; на положительное число.</target>
        </trans-unit>
        <trans-unit id="c43fa53c9a4af41c4362a70dd0d3da19011de429" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</source>
          <target state="translated">Чтобы создать поток данных RFC 1951, установите &lt;code&gt;WindowBits&lt;/code&gt; на &lt;code&gt;-MAX_WBITS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04500f8f7e1689707f89183f5977f70d07b39e1b" translate="yes" xml:space="preserve">
          <source>To create an RFC 1951 data stream, set &lt;code&gt;WindowBits&lt;/code&gt; to &lt;code&gt;-MAX_WBITS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb0b362cb67cdcf254362d24dcd3489205dd8b1" translate="yes" xml:space="preserve">
          <source>To create your own result types you have two options:</source>
          <target state="translated">Для создания собственных типов результатов у вас есть два варианта:</target>
        </trans-unit>
        <trans-unit id="948e86a50124d6c16a2bb795d3ad5dd4ba16fd66" translate="yes" xml:space="preserve">
          <source>To deallocate the memory of a &lt;b&gt;referent&lt;/b&gt; (first triggering its &lt;code&gt;DESTROY&lt;/code&gt; method, if it has one).</source>
          <target state="translated">Чтобы освободить память &lt;b&gt;референта&lt;/b&gt; (сначала запустив его метод &lt;code&gt;DESTROY&lt;/code&gt; , если он есть).</target>
        </trans-unit>
        <trans-unit id="684b7eba474ceeeee203e03efc4972ceab5f4011" translate="yes" xml:space="preserve">
          <source>To declare a file-private variable, you still use a lexical variable. A file is also a scope, so a lexical variable defined in the file cannot be seen from any other file.</source>
          <target state="translated">Чтобы объявить файл-частную переменную,вы все равно используете лексическую переменную.Файл также является областью видимости,поэтому лексическая переменная,определенная в файле,не может быть видна ни из какого другого файла.</target>
        </trans-unit>
        <trans-unit id="26f359ab42151643a554fcca60e916cbc3b8c6c1" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</source>
          <target state="translated">Чтобы объявить несколько родителей, вам просто нужно передать несколько имен классов для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; parent&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4bb1aac304b6e2bad9b2c8e30ae0f6a69783e20b" translate="yes" xml:space="preserve">
          <source>To declare multiple parents, you simply need to pass multiple class names to &lt;code&gt;use parent&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195f600c4f130988d6cb960024f570abb452421b" translate="yes" xml:space="preserve">
          <source>To declare subroutines:</source>
          <target state="translated">Объявить подпрограммы:</target>
        </trans-unit>
        <trans-unit id="d689355c5c4c25b69703a4f888325a4f315e40d5" translate="yes" xml:space="preserve">
          <source>To decode the string, use the &lt;code&gt;uri_unescape&lt;/code&gt; function:</source>
          <target state="translated">Чтобы декодировать строку, используйте функцию &lt;code&gt;uri_unescape&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c00b1b3082eeba042c1321adab39b3572b77ab5f" translate="yes" xml:space="preserve">
          <source>To define a new encoding, use:</source>
          <target state="translated">Чтобы определить новую кодировку,используйте:</target>
        </trans-unit>
        <trans-unit id="90539d229e0f3e1882d607e70d036357967dd42b" translate="yes" xml:space="preserve">
          <source>To define an anonymous subroutine at runtime:</source>
          <target state="translated">Определить анонимную подпрограмму во время выполнения:</target>
        </trans-unit>
        <trans-unit id="c9cdf944c5644c128ca4890eae1d815775404ea8" translate="yes" xml:space="preserve">
          <source>To define your own variables, simply add them to the hash, or change existing values if you need to. The level and format are passed in as references to scalars, but it is unlikely that they will need to be changed or even used.</source>
          <target state="translated">Чтобы определить свои собственные переменные,просто добавьте их в хэш или измените существующие значения,если это необходимо.Уровень и формат передаются в виде ссылок на скаляры,но вряд ли их придется менять или даже использовать.</target>
        </trans-unit>
        <trans-unit id="663c37fcccd4eb9d16f3753290874adfe0a38adc" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to it.</source>
          <target state="translated">Чтобы удалить фильтр, передайте ему &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13cdb92e706e9bc2ee9e805b13be6097ddaf3e74" translate="yes" xml:space="preserve">
          <source>To delete a filter pass &lt;code&gt;undef&lt;/code&gt; to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6700a8c11e3d4c6c50392505cb5fdaeda8fab3d" translate="yes" xml:space="preserve">
          <source>To delete a partition, zero out all fields except for &lt;code&gt;$bToRewrite&lt;/code&gt; which should be set to &lt;code&gt;1&lt;/code&gt;. To add a partition, increment &lt;code&gt;$cPartitions&lt;/code&gt; and add the information for the new partition into the arrays, making sure that you insert &lt;code&gt;1&lt;/code&gt; into @bToRewrite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7282a69c7ceaa80a01f9176cf957edc11cea4de" translate="yes" xml:space="preserve">
          <source>To delete lines, only print the ones that you want.</source>
          <target state="translated">Чтобы удалить строки,печатайте только те,которые вам нужны.</target>
        </trans-unit>
        <trans-unit id="c1469f4d29b40fb0b7ab86c2c4e92578f7c6eb9f" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</source>
          <target state="translated">Чтобы определить во время выполнения, была ли эта возможность скомпилирована в вашем Perl, вы можете проверить значение &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e519c90ecace9cdd9ef4f4b53067e00b66728320" translate="yes" xml:space="preserve">
          <source>To determine at runtime if this capability has been compiled in your perl, you can check the value of &lt;code&gt;$Config{usesitecustomize}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ac9c1626cb28585a5803d5d3d2ce1edde74347f" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce033ec9e41969bd8c16961760514dcb521d365" translate="yes" xml:space="preserve">
          <source>To determine if a module came with your version of Perl, you can install and use the &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt; module. It has the information about the modules (with their versions) included with each release of Perl.</source>
          <target state="translated">Чтобы определить, поставляется ли модуль с вашей версией Perl, вы можете установить и использовать &lt;a href=&quot;module/corelist&quot;&gt;модуль Module :: CoreList&lt;/a&gt; . В нем есть информация о модулях (с их версиями), включенных в каждый выпуск Perl.</target>
        </trans-unit>
        <trans-unit id="a3640814314afd9f7ac9d11a68cf889d6f47fec5" translate="yes" xml:space="preserve">
          <source>To determine if a string is in Unicode, use:</source>
          <target state="translated">Чтобы определить,есть ли строка в Юникоде,используйте:</target>
        </trans-unit>
        <trans-unit id="bca0ec2b6522f981d9c11831a03f1f68a8800f50" translate="yes" xml:space="preserve">
          <source>To determine if an SV is a reference, you can use the following macro:</source>
          <target state="translated">Чтобы определить,является ли SV эталоном,можно использовать следующий макрос:</target>
        </trans-unit>
        <trans-unit id="c9936c817f7d3f0a431d8c4cc266d4265437482c" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="translated">Чтобы определить, работаете ли вы в ASCII или EBCDIC, вы можете использовать возвращаемое значение &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; для проверки одного или нескольких символьных значений. Например:</target>
        </trans-unit>
        <trans-unit id="c4d19f268a46b2039ad626d07491613ba196e3ba" translate="yes" xml:space="preserve">
          <source>To determine if you are running under ASCII or EBCDIC, you can use the return value of &lt;code&gt;ord()&lt;/code&gt; or &lt;code&gt;chr()&lt;/code&gt; to test one or more character values. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e75dff4a5cb692b3db4e186257a30b993c598a" translate="yes" xml:space="preserve">
          <source>To determine whether or not perl was built under an EBCDIC code page you can use the Config module like so:</source>
          <target state="translated">Чтобы определить,был ли perl собран под кодовой страницей EBCDIC или нет,можно воспользоваться модулем Config:</target>
        </trans-unit>
        <trans-unit id="c7ca989a561cc6bb21cb242f3f9a4867fcc2a0a2" translate="yes" xml:space="preserve">
          <source>To determine which category a specific warning has been assigned to see &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;.</source>
          <target state="translated">Чтобы определить, какой категории было назначено конкретное предупреждение, необходимо просмотреть &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a93e35e1721136bbf3e35a386749266ad37800e0" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt; function may be more convenient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2650be423c3da22a5978107c38e624c70d0e420" translate="yes" xml:space="preserve">
          <source>To die with a simple string message, the &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; function may be more convenient.</source>
          <target state="translated">Чтобы умереть с простым строковым сообщением, функция &lt;a href=&quot;#croak&quot;&gt;кваканья&lt;/a&gt; может быть более удобной.</target>
        </trans-unit>
        <trans-unit id="1dfd486790a39158f4a7ca56ddcfea76a7b570b2" translate="yes" xml:space="preserve">
          <source>To disable blessing objects while thawing/retrieving remove the flag &lt;code&gt;BLESS_OK&lt;/code&gt; = 2 from &lt;code&gt;$Storable::flags&lt;/code&gt; or set the 2nd argument for thaw/retrieve to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347758299b3b52a08c513c37128e636634230c65" translate="yes" xml:space="preserve">
          <source>To disable prototypes:</source>
          <target state="translated">Чтобы отключить прототипы:</target>
        </trans-unit>
        <trans-unit id="5d0844b4d1a693267fe5fcf752c200ff27d0a20a" translate="yes" xml:space="preserve">
          <source>To disable scoping:</source>
          <target state="translated">Чтобы отключить сканирование:</target>
        </trans-unit>
        <trans-unit id="49438a7c7aac56a61be90484df5f68db7923a254" translate="yes" xml:space="preserve">
          <source>To disable the feature and, if applicable, re-enable any warnings, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2e4cf0ee9b26b39ec068b4b4c9bcaa2ebda9e0" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">Чтобы отключить эту проверку, установите для этой переменной значение &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff637f529a61890918adfda94de235cbe32273b" translate="yes" xml:space="preserve">
          <source>To disable this check, set this variable to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80cbb6c9445e33c66e64e8bbc664c2dc7cb143d" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; strings or from any kind of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="translated">Чтобы отключить этот безопасный режим по умолчанию, установите для этих значений значение выше 0. На уровне 1 вы получаете обратные трассировки при получении любого вида предупреждения (это часто раздражает) или исключения (это часто полезно). К сожалению, отладчик не может отличить фатальные исключения от нефатальных. Если &lt;code&gt;dieLevel&lt;/code&gt; равно 1, тогда ваши нефатальные исключения также отслеживаются и бесцеремонно изменяются, если они &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval'ed&lt;/a&gt;&lt;/code&gt; из eval'ed строк или из любого вида &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; в модулях, которые вы пытаетесь загрузить. Если &lt;code&gt;dieLevel&lt;/code&gt; равно 2, отладчику все равно, откуда они пришли: он узурпирует ваш обработчик исключений и распечатывает трассировку, а затем модифицирует все исключения, добавляя собственные украшения. Это может быть полезно для некоторых целей трассировки, но имеет тенденцию безнадежно уничтожить любую программу, серьезно относящуюся к обработке исключений.</target>
        </trans-unit>
        <trans-unit id="cb4293ab3018dc6b8d0d5076e39654c8c02af5e2" translate="yes" xml:space="preserve">
          <source>To disable this default safe mode, set these values to something higher than 0. At a level of 1, you get backtraces upon receiving any kind of warning (this is often annoying) or exception (this is often valuable). Unfortunately, the debugger cannot discern fatal exceptions from non-fatal ones. If &lt;code&gt;dieLevel&lt;/code&gt; is even 1, then your non-fatal exceptions are also traced and unceremoniously altered if they came from &lt;code&gt;eval'ed&lt;/code&gt; strings or from any kind of &lt;code&gt;eval&lt;/code&gt; within modules you're attempting to load. If &lt;code&gt;dieLevel&lt;/code&gt; is 2, the debugger doesn't care where they came from: It usurps your exception handler and prints out a trace, then modifies all exceptions with its own embellishments. This may perhaps be useful for some tracing purposes, but tends to hopelessly destroy any program that takes its exception handling seriously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775ac8e4b166c7efdd67d5a474126369cafcedff" translate="yes" xml:space="preserve">
          <source>To disable tieing data while thawing/retrieving remove the flag &lt;code&gt;TIE_OK&lt;/code&gt; = 4 from &lt;code&gt;$Storable::flags&lt;/code&gt; or set the 2nd argument for thaw/retrieve to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d156c08336acd4fd9a2800ec24f479a8112dea4" translate="yes" xml:space="preserve">
          <source>To disable version checking:</source>
          <target state="translated">Чтобы отключить проверку версии:</target>
        </trans-unit>
        <trans-unit id="738a71c259ac0a8afb90292476b05521cb3a2b41" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt; , you could set $File::Fetch::BLACKLIST to:</source>
          <target state="translated">Чтобы запретить использование, например, &lt;code&gt;LWP&lt;/code&gt; и &lt;code&gt;Net::FTP&lt;/code&gt; , вы можете установить для $ File :: Fetch :: BLACKLIST значение:</target>
        </trans-unit>
        <trans-unit id="8c3ea5cb60afc12efc66dbc5590a051167db7a27" translate="yes" xml:space="preserve">
          <source>To disallow the use of, for example, &lt;code&gt;LWP&lt;/code&gt; and &lt;code&gt;Net::FTP&lt;/code&gt;, you could set $File::Fetch::BLACKLIST to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80dd5fada40953f3424fd8a183a453e068557bb1" translate="yes" xml:space="preserve">
          <source>To discover what type of value the reference refers to, use the following macro and then check the return value.</source>
          <target state="translated">Чтобы узнать,к какому типу значений относится ссылка,используйте следующий макрос,а затем проверьте возвращаемое значение.</target>
        </trans-unit>
        <trans-unit id="8fc94d5f52eb1139b287df828008badfb6c3e089" translate="yes" xml:space="preserve">
          <source>To display and change the libnet configuration run the libnetcfg command.</source>
          <target state="translated">Для отображения и изменения конфигурации libnet выполните команду libnetcfg.</target>
        </trans-unit>
        <trans-unit id="60ed656a96349b78cdba5a83471f5324d8dd1e87" translate="yes" xml:space="preserve">
          <source>To display the results you use the</source>
          <target state="translated">Для отображения результатов вы используете</target>
        </trans-unit>
        <trans-unit id="2ac49a31f43cbe10ed9c501335f1421ecc6af0bb" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad781551179d37e74d6f0377992b51ea7bdaace0" translate="yes" xml:space="preserve">
          <source>To do it correctly, you can use one of the &lt;code&gt;Date&lt;/code&gt; modules since they work with calendars instead of times. The &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module makes it simple, and give you the same time of day, only the day before, despite daylight saving time changes:</source>
          <target state="translated">Чтобы сделать это правильно, вы можете использовать один из модулей &lt;code&gt;Date&lt;/code&gt; , поскольку они работают с календарями, а не с временем. Модуль &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; упрощает задачу и дает вам то же время суток, только накануне, несмотря на переход на летнее время:</target>
        </trans-unit>
        <trans-unit id="9370a32c5a26795ae66ed04fd1bbf4641dcb50f3" translate="yes" xml:space="preserve">
          <source>To do so, PerlIO always calls (de|en)code methods with CHECK set to 1. This ensures that the method stops at the right place when it encounters partial character. The following is what happens when PerlIO and Encode tries to encode (from utf8) more than 1024 bytes and the buffer boundary happens to be in the middle of a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e288609d3f494ae8be47d7fabedf138f3b357269" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d6265a7b40372fb699b2b2f27a1df7b8f80a66" translate="yes" xml:space="preserve">
          <source>To do the equivalent of &lt;code&gt;cp -R&lt;/code&gt; (i.e. copy an entire directory tree recursively) in portable Perl, you'll either need to write something yourself or find a good CPAN module such as &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File::Copy::Recursive&lt;/a&gt;.</source>
          <target state="translated">Чтобы выполнить аналог &lt;code&gt;cp -R&lt;/code&gt; (т.е. рекурсивно скопировать все дерево каталогов) в переносимом Perl, вам нужно либо написать что-нибудь самостоятельно, либо найти хороший модуль CPAN, такой как &lt;a href=&quot;http://search.cpan.org/perldoc/File::Copy::Recursive&quot;&gt;File :: Copy :: Recursive&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="800198c8e77892b2ea37f8a62c33fb5be9843971" translate="yes" xml:space="preserve">
          <source>To do this we need to produce a program by parsing the text. We then need to execute the program to find the point in the string that matches. And we need to do the whole thing efficiently.</source>
          <target state="translated">Для этого нужно создать программу,разобрав текст.Затем нам нужно выполнить программу,чтобы найти точку в строке,которая совпадает.И нам нужно сделать все это эффективно.</target>
        </trans-unit>
        <trans-unit id="b3b368d6bf057c7196323316138f2bb623cf857e" translate="yes" xml:space="preserve">
          <source>To do this you need to store a copy of the object returned from the tie.</source>
          <target state="translated">Для этого необходимо сохранить копию объекта,возвращенного с галстука.</target>
        </trans-unit>
        <trans-unit id="16944f02408f01608a70adc6c00bddd6a6f21c5d" translate="yes" xml:space="preserve">
          <source>To do this, declare the XSUB as</source>
          <target state="translated">Для этого объявите XSUB как</target>
        </trans-unit>
        <trans-unit id="9ba25feb906f9144f135e56832aaff07eb5da168" translate="yes" xml:space="preserve">
          <source>To do this, simple invoke the redispatch as:</source>
          <target state="translated">Чтобы сделать это,просто вызовите redispatch как:</target>
        </trans-unit>
        <trans-unit id="c76098aac2b117e4e74346d50713bf96ac98a839" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab21cf4aaf0dd1470c7bbbf3e1fd1618a699e4e" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b963497fc0bd80a2ad6cd72e920bb19d3acf535" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP::Formatter&lt;/a&gt;, or write your own. Writing formatters are a bit more involved than writing a</source>
          <target state="translated">Для этого вы можете расширить существующий &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Formatter&quot;&gt;TAP :: Formatter&lt;/a&gt; или написать свой собственный. Написание средств форматирования немного сложнее, чем написание</target>
        </trans-unit>
        <trans-unit id="4d922248445626035fad600ec3b500e3d07eeccb" translate="yes" xml:space="preserve">
          <source>To do this, you can either extend an existing &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, or write your own. It's a pretty simple API, and they can be loaded and configured using the &lt;code&gt;sources&lt;/code&gt; parameter to &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">Для этого вы можете либо расширить существующий &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt; , либо написать свой собственный. Это довольно простой API, и их можно загрузить и настроить с помощью параметра &lt;code&gt;sources&lt;/code&gt; в &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9af8e6fc2b2d44ed39a720480b5eca952598206" translate="yes" xml:space="preserve">
          <source>To do this, you have to parse out each word in the input stream. We'll pretend that by word you mean chunk of alphabetics, hyphens, or apostrophes, rather than the non-whitespace chunk idea of a word given in the previous question:</source>
          <target state="translated">Для этого необходимо разобрать каждое слово во входном потоке.Мы притворимся,что под словом вы подразумеваете кусок алфавита,дефисы или апострофы,а не небелую кусок идеи слова,приведенную в предыдущем вопросе:</target>
        </trans-unit>
        <trans-unit id="6deb2232b7d100aa506f8d7a9be0b44c33bb7cba" translate="yes" xml:space="preserve">
          <source>To do this, you need to inform &lt;code&gt;WriteMakeFile()&lt;/code&gt; in your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a594dc0644909bfef7173f1f8eb29922809128db" translate="yes" xml:space="preserve">
          <source>To do what you meant properly, you must write:</source>
          <target state="translated">Чтобы сделать то,что вы имели в виду,вы должны написать:</target>
        </trans-unit>
        <trans-unit id="da74a36079576adc88b6c00e82f57a05912e49d0" translate="yes" xml:space="preserve">
          <source>To do your own error handling, call this function with the &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag to suppress any warnings, and then examine the &lt;code&gt;*errors&lt;/code&gt; return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e2fbf11b8c81738d92b26c858673a8798bed9d" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt; , &lt;code&gt;isDIGIT_A&lt;/code&gt; , and so on.</source>
          <target state="translated">Чтобы подчеркнуть, что вы работаете только с символами ASCII, вы можете добавить &lt;code&gt;_A&lt;/code&gt; к каждому &lt;code&gt;isALPHA_A&lt;/code&gt; столбце ASCII: isALPHA_A , &lt;code&gt;isDIGIT_A&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="a0a83e62e85a9a106da5ff1e3e3b0371178b7026" translate="yes" xml:space="preserve">
          <source>To emphasize that you are operating only on ASCII characters, you can append &lt;code&gt;_A&lt;/code&gt; to each of the macros in the ASCII column: &lt;code&gt;isALPHA_A&lt;/code&gt;, &lt;code&gt;isDIGIT_A&lt;/code&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d42b2af4b68e58610fc5bf7b2aa1e720d762bd6" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f50143516f5760cd1414be18dcb711d9b307dd" translate="yes" xml:space="preserve">
          <source>To enable colouring from the command line, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text::Builder::Tester::Color&lt;/a&gt; module like so:</source>
          <target state="translated">Чтобы включить раскраску из командной строки, вы можете использовать модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Builder::Tester::Color&quot;&gt;Text :: Builder :: Tester :: Color&lt;/a&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="9c570da316518400b84383905afc3b038138342e" translate="yes" xml:space="preserve">
          <source>To enable multiline matching one should use the &lt;code&gt;/m&lt;/code&gt; regexp modifier (possibly in combination with &lt;code&gt;/s&lt;/code&gt;). This can be set on a per match bases, or can be enabled per lexical scope (including a whole file) with &lt;code&gt;use re '/m'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01967f773567b844b2b023b2a86bde4df70fc34" translate="yes" xml:space="preserve">
          <source>To enable prototypes:</source>
          <target state="translated">Чтобы включить прототипы:</target>
        </trans-unit>
        <trans-unit id="5ccde66aca7ada9c8fed76ada1d4a0446a4f8743" translate="yes" xml:space="preserve">
          <source>To enable scoping:</source>
          <target state="translated">Чтобы включить обзор:</target>
        </trans-unit>
        <trans-unit id="767b2e0f754eeebe201f5f18e618f6b053217aac" translate="yes" xml:space="preserve">
          <source>To enable this seamless support, you should &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;use 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1484f429016f98a746a3ab26c198f24bb67adaaa" translate="yes" xml:space="preserve">
          <source>To enable version checking:</source>
          <target state="translated">Чтобы включить проверку версии:</target>
        </trans-unit>
        <trans-unit id="a7615d4326dc246eeb4adafc5aa5d8082bb1cd6e" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270b403e8cadfb40d1d97c0de3bf7642f9c98fb6" translate="yes" xml:space="preserve">
          <source>To encode a string yourself, use the &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI::Escape&lt;/a&gt; module. The &lt;code&gt;uri_escape&lt;/code&gt; function returns the escaped string:</source>
          <target state="translated">Чтобы самостоятельно закодировать строку, используйте модуль &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Escape&quot;&gt;URI :: Escape&lt;/a&gt; . Функция &lt;code&gt;uri_escape&lt;/code&gt; возвращает экранированную строку:</target>
        </trans-unit>
        <trans-unit id="197383dea9cb9c2b7e4139f047ab7802bc1168de" translate="yes" xml:space="preserve">
          <source>To end a Pod block, use a blank line, then a line beginning with &quot;=cut&quot;, and a blank line after it. This lets Perl (and the Pod formatter) know that this is where Perl code is resuming. (The blank line before the &quot;=cut&quot; is not technically necessary, but many older Pod processors require it.)</source>
          <target state="translated">Чтобы закончить блок Pod,используйте пустую строку,затем строку,начинающуюся с &quot;=cut&quot;,и пустую строку после нее.Это позволяет Perl (и форматировщику Pod)знать,что именно здесь возобновляется Perl-код.(Пустая строка перед &quot;=cut&quot; технически не нужна,но многие старые процессоры Pod требуют этого).</target>
        </trans-unit>
        <trans-unit id="0ae4a1a4ec134ed8922ee208a028b2c3245ebe13" translate="yes" xml:space="preserve">
          <source>To enforce scalar context in this particular case, however, you need merely omit the parentheses:</source>
          <target state="translated">Однако,чтобы обеспечить соблюдение скалярного контекста в данном конкретном случае,вам нужно просто опустить круглые скобки:</target>
        </trans-unit>
        <trans-unit id="5528aa31607b22ee5ba7b25dc9ad20fd957a80a3" translate="yes" xml:space="preserve">
          <source>To ensure your Perl programs can see these newly installed modules, set your &lt;code&gt;PERL5LIB&lt;/code&gt; environment variable to</source>
          <target state="translated">Чтобы ваши программы Perl могли видеть эти недавно установленные модули, установите для переменной среды &lt;code&gt;PERL5LIB&lt;/code&gt; значение</target>
        </trans-unit>
        <trans-unit id="7aa8a6d9b5359d93562881107c4eb01ac8b79421" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt; :</source>
          <target state="translated">Чтобы избежать особого значения &lt;code&gt;.&lt;/code&gt; , мы используем &lt;code&gt;\Q&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="23c0119f090722ce349ecc5009302976b6a64631" translate="yes" xml:space="preserve">
          <source>To escape the special meaning of &lt;code&gt;.&lt;/code&gt;, we use &lt;code&gt;\Q&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f8b13457bc503e2905034bca18967c492e5be31" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out our old STDERR:</source>
          <target state="translated">Обменяться командами STDOUT и STDERR,чтобы захватить STDERR,но оставить его STDOUT,чтобы выйти из нашего старого STDERR:</target>
        </trans-unit>
        <trans-unit id="f19cbea3f43d914ef5dccac2f20ddb20b0a670bb" translate="yes" xml:space="preserve">
          <source>To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out the old STDERR:</source>
          <target state="translated">Обменяться командами STDOUT и STDERR,чтобы захватить STDERR,но оставить его STDOUT,чтобы выйти из старого STDERR:</target>
        </trans-unit>
        <trans-unit id="1e299ba0ecd4337d918ed97321e55b553fe7e0a0" translate="yes" xml:space="preserve">
          <source>To exercise the various implementations the script &lt;a href=&quot;#Example-2&quot;&gt;below&lt;/a&gt; can be used.</source>
          <target state="translated">Для проверки различных реализаций можно использовать &lt;a href=&quot;#Example-2&quot;&gt;приведенный ниже&lt;/a&gt; сценарий .</target>
        </trans-unit>
        <trans-unit id="746a283f2992b56a8070a48ac33ef2cb2b8ab7fb" translate="yes" xml:space="preserve">
          <source>To explain them each in detail:</source>
          <target state="translated">Чтобы объяснить им каждую деталь:</target>
        </trans-unit>
        <trans-unit id="337ab3fc6e23ee2083bb48006f6530a512cb7265" translate="yes" xml:space="preserve">
          <source>To explicitly turn off a &quot;FATAL&quot; warning you just disable the warning it is associated with. So, for example, to disable the &quot;void&quot; warning in the example above, either of these will do the trick:</source>
          <target state="translated">Чтобы явно отключить предупреждение &quot;FATAL&quot;,просто отключите предупреждение,с которым оно связано.Так,например,чтобы отключить предупреждение &quot;void&quot; в приведенном выше примере,любой из них выполнит свою задачу:</target>
        </trans-unit>
        <trans-unit id="d8cfaf574ce10955d44800ed1fb485165bb12d03" translate="yes" xml:space="preserve">
          <source>To extract a comma-delimited list of numbers, use</source>
          <target state="translated">Чтобы извлечь список номеров,разделенных запятыми,воспользуйтесь функцией</target>
        </trans-unit>
        <trans-unit id="d086f02213d0494d6662b67a4783c59065f8a170" translate="yes" xml:space="preserve">
          <source>To extract an ASCII tar archive on BS2000 POSIX you need an ASCII filesystem (we used the mountpoint /usr/local/ascii for this). Now you extract the archive in the ASCII filesystem without I/O-conversion:</source>
          <target state="translated">Для извлечения архива ASCII tar на POSIX BS2000 вам понадобится файловая система ASCII (для этого мы использовали точку монтирования /usr/local/ascii).Теперь вы распаковываете архив в файловой системе ASCII без преобразования ввода/вывода:</target>
        </trans-unit>
        <trans-unit id="25ec0794844bd37f005928c43a00d6da3d3e457e" translate="yes" xml:space="preserve">
          <source>To find how (UCS-2|UTF-(16|32))(LE|BE)? differ from one another, see &lt;a href=&quot;Encode::Unicode&quot;&gt;Encode::Unicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c062b7c2a495ae2a5b72a1379e8b1a41239ea1d2" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как использовать этот модуль, см. &lt;a href=&quot;../encode&quot;&gt;Кодирование&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ee7c07a6985c2bc43ddeeba4f6a14f8a3da6596" translate="yes" xml:space="preserve">
          <source>To find how to use this module in detail, see &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3930f92a272e8f2e02166feb6d52740dba8a2a7" translate="yes" xml:space="preserve">
          <source>To find out</source>
          <target state="translated">Чтобы узнать</target>
        </trans-unit>
        <trans-unit id="8b9ad1d9bf5e88e70343c9bc73bc8f95e823175e" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как использовать этот модуль подробно, см. &lt;a href=&quot;../encode&quot;&gt;Кодирование&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2adbea2c685a6abde137a3a64635b621e1971a84" translate="yes" xml:space="preserve">
          <source>To find out how to use this module in detail, see &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73fb3d1fc5746c2536b396c0845c316c4d80215" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;Encode::Supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8814e60c44afe937889a748a7dc5d647bd329617" translate="yes" xml:space="preserve">
          <source>To find out in detail which encodings are supported by this package, see &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать подробно, какие кодировки поддерживаются этим пакетом, см. &lt;a href=&quot;encode/supported&quot;&gt;Encode :: Supported&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7957585a16fb8e9f58abff4512426bfd62b9e660" translate="yes" xml:space="preserve">
          <source>To find out where a module's source code is located, use</source>
          <target state="translated">Для того чтобы узнать,где находится исходный код модуля,используйте</target>
        </trans-unit>
        <trans-unit id="714fa5ade47f6c038c4e5047b338fbf758e5ccc9" translate="yes" xml:space="preserve">
          <source>To find out whether a given string is a valid non-zero number, it's sometimes enough to test it against both numeric 0 and also lexical &quot;0&quot; (although this will cause noises if warnings are on). That's because strings that aren't numbers count as 0, just as they do in &lt;b&gt;awk&lt;/b&gt;:</source>
          <target state="translated">Чтобы определить, является ли данная строка допустимым ненулевым числом, иногда достаточно проверить ее как на числовой 0, так и на лексический &amp;laquo;0&amp;raquo; (хотя это вызовет шумы, если включены предупреждения). Это потому, что строки, не являющиеся числами, считаются за 0, как и в &lt;b&gt;awk&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="b365160bfd575c380666252714a7e2191298f003" translate="yes" xml:space="preserve">
          <source>To find out which character encodings your Perl supports, run:</source>
          <target state="translated">Чтобы узнать,какие кодировки символов поддерживает Perl,запустите:</target>
        </trans-unit>
        <trans-unit id="1e6f34bd3a736ed4112e8f178b09aac2a9e39ab4" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0d1d4b42258f044bb86db954a57628e8eecd09" translate="yes" xml:space="preserve">
          <source>To find something between two single characters, a pattern like &lt;code&gt;/x([^x]*)x/&lt;/code&gt; will get the intervening bits in $1. For multiple ones, then something more like &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; would be needed. For nested patterns and/or balanced expressions, see the so-called &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt; construct (available since perl 5.10). The CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; can help to build such regular expressions (see in particular &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp::Common::balanced&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;Regexp::Common::delimited&lt;/a&gt;).</source>
          <target state="translated">Чтобы найти что-то между двумя одиночными символами, шаблон вроде &lt;code&gt;/x([^x]*)x/&lt;/code&gt; получит промежуточные биты в $ 1. Для нескольких &lt;code&gt;/alpha(.*?)omega/&lt;/code&gt; что- то вроде /alpha(.*?)omega/ . Для вложенных шаблонов и / или сбалансированных выражений см. Так называемую конструкцию &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)&lt;/a&gt; (доступную с perl 5.10). Модуль CPAN &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt; может помочь в построении таких регулярных выражений (см., В частности, &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::balanced&quot;&gt;Regexp :: Common :: &lt;/a&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common::delimited&quot;&gt;balance&lt;/a&gt; и Regexp :: Common :: delimited ).</target>
        </trans-unit>
        <trans-unit id="462c225b3ec5f7ec0eb1907b83b31298442e3ef8" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8886406693c43465a74828d32fde569bd987324" translate="yes" xml:space="preserve">
          <source>To find the first array element which satisfies a condition, you can use the &lt;code&gt;first()&lt;/code&gt; function in the &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; module, which comes with Perl 5.8. This example finds the first element that contains &quot;Perl&quot;.</source>
          <target state="translated">Чтобы найти первый элемент массива, который удовлетворяет условию, вы можете использовать функцию &lt;code&gt;first()&lt;/code&gt; в модуле &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; , который поставляется с Perl 5.8. В этом примере выполняется поиск первого элемента, содержащего &amp;laquo;Perl&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f1ca27f7c9ffaf0873146b4d5569bf1f7dd85f24" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt; , as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="translated">Чтобы найти пакет, в котором вы сейчас находитесь, используйте специальный литерал &lt;code&gt;__PACKAGE__&lt;/code&gt; , как &lt;a href=&quot;perldata&quot;&gt;описано&lt;/a&gt; в perldata . Вы можете использовать специальные литералы только как отдельные токены, поэтому вы не можете интерполировать их в строки, как вы можете с переменными:</target>
        </trans-unit>
        <trans-unit id="f89e6a14f2ee6c8a6aa9c17296db02bef0f9a5ee" translate="yes" xml:space="preserve">
          <source>To find the package you are currently in, use the special literal &lt;code&gt;__PACKAGE__&lt;/code&gt;, as documented in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;. You can only use the special literals as separate tokens, so you can't interpolate them into strings like you can with variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffcf6d33c52e5caff06e5888e1b1afff8c79cd9" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt; , use &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt; instead.</source>
          <target state="translated">Чтобы найти синонимы для одиночных форм, таких как &lt;code&gt;\p{Any}&lt;/code&gt; , используйте вместо них &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb89d412def16cc37609c904cc14b810aa0fb5df" translate="yes" xml:space="preserve">
          <source>To find the synonyms for single-forms, such as &lt;code&gt;\p{Any}&lt;/code&gt;, use &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4474f5909a02cbe785465728ea131216f023c4" translate="yes" xml:space="preserve">
          <source>To find your local Perl Mongers (or PM as they're commonly abbreviated) group check the international Perl Mongers directory at &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt;.</source>
          <target state="translated">Чтобы найти свою местную группу Perl Mongers (или PM, как их обычно называют), загляните в международный каталог Perl Mongers по адресу &lt;a href=&quot;http://www.pm.org/&quot;&gt;http://www.pm.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51fa9c8218dc025937f10203b9150ec3a3d4872c" translate="yes" xml:space="preserve">
          <source>To fire up the debugger, type</source>
          <target state="translated">Чтобы запустить отладчик,напечатайте</target>
        </trans-unit>
        <trans-unit id="5061c6729e5e674eb297e87fb65b6e686195258a" translate="yes" xml:space="preserve">
          <source>To fix by applying one, as it were. In the realm of hackerdom, a listing of the differences between two versions of a program as might be applied by the &lt;b&gt;patch&lt;/b&gt;(1) program when you want to fix a bug or upgrade your old version.</source>
          <target state="translated">Исправить, применив как бы одну. В сфере хакерства - список различий между двумя версиями программы, который может быть применен программой &lt;b&gt;patch&lt;/b&gt; (1), когда вы хотите исправить ошибку или обновить старую версию.</target>
        </trans-unit>
        <trans-unit id="baa8da9e4b55dce6e5a8c524e072f785277c31e7" translate="yes" xml:space="preserve">
          <source>To fix this, some people formed Unicode, Inc. and produced a new character set containing all the characters you can possibly think of and more. There are several ways of representing these characters, and the one Perl uses is called UTF-8. UTF-8 uses a variable number of bytes to represent a character. You can learn more about Unicode and Perl's Unicode model in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">Чтобы исправить это, некоторые люди создали Unicode, Inc. и создали новый набор символов, содержащий все символы, которые вы только можете придумать, и многое другое. Есть несколько способов представления этих символов, и тот, который использует Perl, называется UTF-8. UTF-8 использует переменное количество байтов для представления символа. Вы можете узнать больше о Unicode и модели Unicode Perl в &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4f76f5a03185d9e714674242e64dfcf1b7f20c4" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), specify the &quot;a&quot; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt; . (The first occurrence of &quot;a&quot; restricts the &lt;code&gt;\d&lt;/code&gt; , etc., and the second occurrence adds the &lt;code&gt;/i&lt;/code&gt; restrictions.) But, note that code points outside the ASCII range will use Unicode rules for &lt;code&gt;/i&lt;/code&gt; matching, so the modifier doesn't really restrict things to just ASCII; it just forbids the intermixing of ASCII and non-ASCII.</source>
          <target state="translated">Чтобы запретить совпадения ASCII / не-ASCII (например, &amp;laquo;k&amp;raquo; с &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt; ), укажите &amp;laquo;a&amp;raquo; дважды, например &lt;code&gt;/aai&lt;/code&gt; или &lt;code&gt;/aia&lt;/code&gt; . (Первое вхождение &quot;a&quot; ограничивает &lt;code&gt;\d&lt;/code&gt; и т. Д., А второе вхождение добавляет ограничения &lt;code&gt;/i&lt;/code&gt; .) Но обратите внимание, что кодовые точки вне диапазона ASCII будут использовать правила Unicode для сопоставления &lt;code&gt;/i&lt;/code&gt; , поэтому модификатор не на самом деле не ограничиваются только ASCII; он просто запрещает смешивание ASCII и не-ASCII.</target>
        </trans-unit>
        <trans-unit id="7747b215397466c348d54e9b8de2e0e6dbbf3fa6" translate="yes" xml:space="preserve">
          <source>To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &lt;code&gt;\N{KELVIN SIGN}&lt;/code&gt;), specify the &lt;code&gt;&quot;a&quot;&lt;/code&gt; twice, for example &lt;code&gt;/aai&lt;/code&gt; or &lt;code&gt;/aia&lt;/code&gt;. (The first occurrence of &lt;code&gt;&quot;a&quot;&lt;/code&gt; restricts the &lt;code&gt;\d&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce87ca60a35ae769cbfeb60038a35828e8b052b1" translate="yes" xml:space="preserve">
          <source>To force &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; to uncompress all the bzip2 data streams, include the &lt;code&gt;MultiStream&lt;/code&gt; option, as shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d738795a19cd0b9eeeb60570db56c2f44fad5488" translate="yes" xml:space="preserve">
          <source>To force &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; to uncompress all the gzip data streams, include the &lt;code&gt;MultiStream&lt;/code&gt; option, as shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2a4c58af25cd402ee36a19ab3abed7cc44071e" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; pragma).</source>
          <target state="translated">Чтобы заставить интерпретацию как вызов подпрограммы, либо поставьте амперсанд перед именем подпрограммы, либо уточните имя с ее пакетом. В качестве альтернативы вы можете импортировать подпрограмму (или сделать вид, что она импортирована с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d2cf84ed24d58ace958b85882dc11163745c65be" translate="yes" xml:space="preserve">
          <source>To force interpretation as a subroutine call, either put an ampersand before the subroutine name, or qualify the name with its package. Alternatively, you can import the subroutine (or pretend that it's imported with the &lt;code&gt;use subs&lt;/code&gt; pragma).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457433c503b0c64ab575af65985486ef91bd670a" translate="yes" xml:space="preserve">
          <source>To force multiple data values into an SV, you must do two things: use the &lt;code&gt;sv_set*v&lt;/code&gt; routines to add the additional scalar type, then set a flag so that Perl will believe it contains more than one type of data. The four macros to set the flags are:</source>
          <target state="translated">Чтобы принудительно &lt;code&gt;sv_set*v&lt;/code&gt; несколько значений данных в SV, вы должны сделать две вещи: использовать процедуры sv_set * v для добавления дополнительного скалярного типа, а затем установить флаг, чтобы Perl считал, что он содержит более одного типа данных. Четыре макроса для установки флагов:</target>
        </trans-unit>
        <trans-unit id="b603c7813804b39f069cc444400779dd5f80774c" translate="yes" xml:space="preserve">
          <source>To force unicode semantics in code portable to perl 5.8 and 5.10, call &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; unconditionally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e794c449edc7f65a40ec8153981b15f3f2a9b550" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; . Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;).</source>
          <target state="translated">Чтобы освободить созданный &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt; , вызовите SvREFCNT_dec (SV *) . Обычно в этом вызове нет необходимости (см. &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Подсчет ссылок и смертность&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3e7390df1746c54f2c60ceb3e38eab54ee218d5" translate="yes" xml:space="preserve">
          <source>To free an SV that you've created, call &lt;code&gt;SvREFCNT_dec(SV*)&lt;/code&gt;. Normally this call is not necessary (see &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&quot;Reference Counts and Mortality&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1737256e6e8a51ce74a94d85a078c8dd0ab640" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">Чтобы получить доступ к символам, которые экспортируются из другого модуля. См. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; Camel в главе 27, &amp;laquo;Функции&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ff21df3d4f7e1323bcb14d219834d5b523bb12a8" translate="yes" xml:space="preserve">
          <source>To gain access to symbols that are exported from another module. See &lt;code&gt;use&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f02cb11f0716e30aa4d5cf8185ab8c7897bdf67" translate="yes" xml:space="preserve">
          <source>To generate accessors you list them when using the module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb6076af26c9d87b4c92a15d546b5cbbac01e84" translate="yes" xml:space="preserve">
          <source>To generate just the stubs:</source>
          <target state="translated">Генерировать только шлейфы:</target>
        </trans-unit>
        <trans-unit id="535754fb5bff8ed1b444cf7b15654e6f3c7d7a5c" translate="yes" xml:space="preserve">
          <source>To get a Math::BigFloat you either need to call the operation manually, make sure the operands are already of the proper type or casted to that type via Math::BigFloat-&amp;gt;new():</source>
          <target state="translated">Чтобы получить Math :: BigFloat, вам нужно либо вызвать операцию вручную, убедитесь, что операнды уже имеют правильный тип, либо преобразованы в этот тип с помощью Math :: BigFloat-&amp;gt; new ():</target>
        </trans-unit>
        <trans-unit id="482a14b92894717900240dda3533f7f04de8b428" translate="yes" xml:space="preserve">
          <source>To get a binary stream an alternate method is to use:</source>
          <target state="translated">Для получения бинарного потока необходимо использовать альтернативный метод:</target>
        </trans-unit>
        <trans-unit id="342926328b3f4e6b863f62ddbfc63ea7184c5807" translate="yes" xml:space="preserve">
          <source>To get a full list of the available sync points:</source>
          <target state="translated">Получить полный список доступных точек синхронизации:</target>
        </trans-unit>
        <trans-unit id="4a7e3e5cefb00444495078948120515244d3f977" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="translated">Чтобы получить случайное число между двумя значениями, вы можете использовать встроенную функцию &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; чтобы получить случайное число от 0 до 1. Оттуда вы перемещаете это в нужный диапазон.</target>
        </trans-unit>
        <trans-unit id="07bedc590c0c2707d4838577cb4e73d5ee21573c" translate="yes" xml:space="preserve">
          <source>To get a random number between two values, you can use the &lt;code&gt;rand()&lt;/code&gt; built-in to get a random number between 0 and 1. From there, you shift that into the range that you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503a91db6b0ee3a6aaf3799cd04cbf8c2160ee5a" translate="yes" xml:space="preserve">
          <source>To get a real at or caret into the field, do this:</source>
          <target state="translated">Для того,чтобы получить реальную или заботу в поле,сделай это:</target>
        </trans-unit>
        <trans-unit id="6546b16387b88ec0ca99336cb1d0e013e452d98c" translate="yes" xml:space="preserve">
          <source>To get all the output from your error log, and not miss any messages via helpful operating system buffering, insert a line like this, at the start of your script:</source>
          <target state="translated">Чтобы получить весь вывод из вашего журнала ошибок и не пропустить ни одного сообщения через полезную буферизацию операционной системы,вставьте в начале вашего скрипта строку вроде этой:</target>
        </trans-unit>
        <trans-unit id="2baf587b399a3c62f41dfcb4f6a76fcf67a09c4b" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt; , the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt; .</source>
          <target state="translated">Чтобы получить &lt;code&gt;HMQ&lt;/code&gt; , расширение должно вызвать &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; в C. После выполнения этого вызова &lt;code&gt;hmq&lt;/code&gt; может быть доступен как &lt;code&gt;Perl_hmq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eacbf75f11af85a991f44461b926b7c934f62f4" translate="yes" xml:space="preserve">
          <source>To get an &lt;code&gt;HMQ&lt;/code&gt;, the extension should call &lt;code&gt;hmq = perl_hmq_GET(serve)&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hmq&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hmq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4fbf979e25bdf63e3a72510bfcc0bebacbf8c90" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt; ) in the open call:</source>
          <target state="translated">Чтобы получить небуферизованный поток, укажите небуферизованный уровень (например, &lt;code&gt;:unix&lt;/code&gt; ) в вызове open:</target>
        </trans-unit>
        <trans-unit id="e43bb9c5d530c176cdc88e98a6d34bb2bcea788a" translate="yes" xml:space="preserve">
          <source>To get an unbuffered stream specify an unbuffered layer (e.g. &lt;code&gt;:unix&lt;/code&gt;) in the open call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f25553ad923c6b2f304e605c8fcb2af6b398a17" translate="yes" xml:space="preserve">
          <source>To get around the error, place the word &lt;code&gt;DB_File&lt;/code&gt; in either single or double quotes, like this:</source>
          <target state="translated">Чтобы обойти ошибку, поместите слово &lt;code&gt;DB_File&lt;/code&gt; в одинарные или двойные кавычки, например:</target>
        </trans-unit>
        <trans-unit id="e7cc39162825d124202c37827aea79596926f995" translate="yes" xml:space="preserve">
          <source>To get around the security problem, I could also pull the values from a hash instead of evaluating variable names. Using a single &lt;code&gt;/e&lt;/code&gt;, I can check the hash to ensure the value exists, and if it doesn't, I can replace the missing value with a marker, in this case &lt;code&gt;???&lt;/code&gt; to signal that I missed something:</source>
          <target state="translated">Чтобы обойти проблему безопасности, я мог бы также извлечь значения из хэша вместо оценки имен переменных. Используя одиночный &lt;code&gt;/e&lt;/code&gt; , я могу проверить хэш, чтобы убедиться, что значение существует, и если это не так, я могу заменить отсутствующее значение маркером, в этом случае &lt;code&gt;???&lt;/code&gt; чтобы сигнализировать о том, что я что-то упустил:</target>
        </trans-unit>
        <trans-unit id="7daccee0149b6b5c023c3105df2756ca16d7041c" translate="yes" xml:space="preserve">
          <source>To get around these problems it is necessary to take a full copy of the SV. The code below shows &lt;code&gt;SaveSub2&lt;/code&gt; modified to do that.</source>
          <target state="translated">Чтобы обойти эти проблемы, необходимо взять полную копию SV. В приведенном ниже коде показано изменение &lt;code&gt;SaveSub2&lt;/code&gt; для этого.</target>
        </trans-unit>
        <trans-unit id="f3981d8032c1c97862aa0ee6d17a5d52da82d00a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;File::Glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e782973aff491dec9c851f1733c85508f6c14a" translate="yes" xml:space="preserve">
          <source>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt;, one that doesn't use the shell to do globbing.</source>
          <target state="translated">Чтобы обойти это, либо обновитесь до Perl v5.6.0 или новее, сделайте глобус самостоятельно с помощью readdir () и шаблонов, либо используйте такой модуль, как &lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt; , который не использует оболочку для выполнения глобусов.</target>
        </trans-unit>
        <trans-unit id="f6d7c7ba0c3680f1bdd16d6aa20e16ef63f21df2" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt; . You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="translated">Чтобы обойти это, вам нужно разблокировать дескриптор выходного файла, в данном случае &lt;code&gt;STDOUT&lt;/code&gt; . Вы можете установить специальную переменную &lt;code&gt;$|&lt;/code&gt; к истинному значению (мнемоника: делая ваши файловые дескрипторы &quot;горячими&quot;):</target>
        </trans-unit>
        <trans-unit id="5f530554d003756c8f58481299f2771b8fc63a8d" translate="yes" xml:space="preserve">
          <source>To get around this, you have to unbuffer the output filehandle, in this case, &lt;code&gt;STDOUT&lt;/code&gt;. You can set the special variable &lt;code&gt;$|&lt;/code&gt; to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f34a68c60751e410691b9ae6ddd9f980469ba3" translate="yes" xml:space="preserve">
          <source>To get at hash elements:</source>
          <target state="translated">Чтобы добраться до гашиша:</target>
        </trans-unit>
        <trans-unit id="7f878bb059ecb8cc0e6a947e6d0564b810589ae6" translate="yes" xml:space="preserve">
          <source>To get even more recent perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="translated">Чтобы получить еще более свежие хранилища Perl для всего диапазона HP-UX, посетите сайт бренда H.Merijn по адресу &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt; . Внимательно прочтите примечания, чтобы узнать, подходят ли доступные версии вашим потребностям.</target>
        </trans-unit>
        <trans-unit id="76a1d18d8c0d8e0ec36c61f2ab6bce082fca6308" translate="yes" xml:space="preserve">
          <source>To get finer test reports, call</source>
          <target state="translated">Чтобы получить более точные отчеты о тестах,позвоните</target>
        </trans-unit>
        <trans-unit id="93d274f25d53139f7087deba04a14a18e5484351" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt; , turn on the F register, as in:</source>
          <target state="translated">Чтобы получить записи указателя на &lt;code&gt;STDERR&lt;/code&gt; , включите регистр F, как в:</target>
        </trans-unit>
        <trans-unit id="4794a765fde524229c427466a3a2da3c2272b297" translate="yes" xml:space="preserve">
          <source>To get index entries on &lt;code&gt;STDERR&lt;/code&gt;, turn on the F register, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89e5c359123efe3e2b8df35515e166a3190f60d" translate="yes" xml:space="preserve">
          <source>To get more perl depots for the whole range of HP-UX, visit H.Merijn Brand's site at &lt;a href=&quot;http://mirrors.develooper.com/hpux/#Perl&quot;&gt;http://mirrors.develooper.com/hpux/#Perl&lt;/a&gt;. Carefully read the notes to see if the available versions suit your needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6b89efcdec932089c6c9c0f91cf90b0d1e52b9" translate="yes" xml:space="preserve">
          <source>To get multiple values from an array:</source>
          <target state="translated">Получить несколько значений из массива:</target>
        </trans-unit>
        <trans-unit id="c67d46d6312179612215d6ef23eb3f6db1321700" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt; .</source>
          <target state="translated">Чтобы получить независимые от платформы элементы управления, вы можете использовать &lt;code&gt;\N{...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b8ad9382504b98c42922faf4d1b352db68cbdde" translate="yes" xml:space="preserve">
          <source>To get platform independent controls, you can use &lt;code&gt;\N{...}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a965832b8b2f81c82888b8327d5081a21e8081aa" translate="yes" xml:space="preserve">
          <source>To get some interesting statistics, it is recommended that &lt;code&gt;randomize_urllist&lt;/code&gt; be set; this introduces some amount of randomness into the URL selection.</source>
          <target state="translated">Чтобы получить интересную статистику, рекомендуется установить &lt;code&gt;randomize_urllist&lt;/code&gt; ; это вносит некоторую случайность в выбор URL.</target>
        </trans-unit>
        <trans-unit id="42f32ff5f8a54ed95afefa260a5241934e3c3cb8" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">Чтобы получить несколько похожие, но зависящие от локали строки даты, соответствующим образом настройте переменные среды вашей локали (см. &lt;a href=&quot;../perllocale&quot;&gt;Perllocale&lt;/a&gt; ) и попробуйте, например:</target>
        </trans-unit>
        <trans-unit id="ab2c259ec21b8fdc7591d4aa060782af6913d852" translate="yes" xml:space="preserve">
          <source>To get somewhat similar but locale-dependent date strings, set up your locale environment variables appropriately (please see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;) and try for example:</source>
          <target state="translated">Чтобы получить несколько похожие, но зависящие от локали строки даты, соответствующим образом настройте переменные среды вашей локали (см. &lt;a href=&quot;perllocale&quot;&gt;Perllocale&lt;/a&gt; ) и попробуйте, например:</target>
        </trans-unit>
        <trans-unit id="c33d002d66788db30ed6cc7efa61fd7b3021f5f2" translate="yes" xml:space="preserve">
          <source>To get the 25 traditional lowercase Greek letters, including both sigmas, you could use this instead:</source>
          <target state="translated">Чтобы получить 25 традиционных строчных греческих букв,включая оба сигмы,вы могли бы использовать это вместо них:</target>
        </trans-unit>
        <trans-unit id="6e85259394ca22644c2c269f73c9d0468d9813a0" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt; . There is no need to release the HAB after it is used.</source>
          <target state="translated">Чтобы получить HAB, расширение должно вызвать &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; в C. После выполнения этого вызова &lt;code&gt;hab&lt;/code&gt; может быть доступен как &lt;code&gt;Perl_hab&lt;/code&gt; . Нет необходимости освобождать HAB после его использования.</target>
        </trans-unit>
        <trans-unit id="a4090f094b0b5e7e1c333253056aa1e10c2b3006" translate="yes" xml:space="preserve">
          <source>To get the HAB, the extension should call &lt;code&gt;hab = perl_hab_GET()&lt;/code&gt; in C. After this call is performed, &lt;code&gt;hab&lt;/code&gt; may be accessed as &lt;code&gt;Perl_hab&lt;/code&gt;. There is no need to release the HAB after it is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35604b07a393cc3fdbf315f40abc25e64114d031" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="translated">Чтобы получить IP-адрес, вы можете использовать встроенную функцию &lt;code&gt;&lt;a href=&quot;functions/gethostbyname&quot;&gt;gethostbyname&lt;/a&gt;&lt;/code&gt; , чтобы преобразовать имя в число. Чтобы превратить это число в форму октета с точками (abcd), которую ожидает большинство людей, используйте функцию &lt;code&gt;inet_ntoa&lt;/code&gt; из модуля &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; , который также поставляется с perl.</target>
        </trans-unit>
        <trans-unit id="6f5ae18e2f134e19fbd9a1950117e9b15bbc93df" translate="yes" xml:space="preserve">
          <source>To get the IP address, you can use the &lt;code&gt;gethostbyname&lt;/code&gt; built-in function to turn the name into a number. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the &lt;code&gt;inet_ntoa&lt;/code&gt; function from the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which also comes with perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2fdb082ba52bcf7b3e152cd572fe7df01166a8" translate="yes" xml:space="preserve">
          <source>To get the actual events you need to get them from the parent event directly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0526e650783189d8454499d3396cf899e8f521" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Для того, чтобы получить день года на любую дату, используйте &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; &amp;laquo;s &lt;code&gt;mktime&lt;/code&gt; , чтобы получить время в эпоху секунд для аргумента &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75db1fc5bb4504ae3cfd425396fb9b0ab5948972" translate="yes" xml:space="preserve">
          <source>To get the day of year for any date, use &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;'s &lt;code&gt;mktime&lt;/code&gt; to get a time in epoch seconds for the argument to &lt;code&gt;localtime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffadb121be361a5885303dda8c46c6cf80b68bb1" translate="yes" xml:space="preserve">
          <source>To get the last two digits of the year (e.g., &quot;01&quot; in 2001) do:</source>
          <target state="translated">Чтобы получить последние две цифры года (например,&quot;01&quot; в 2001 году),сделайте:</target>
        </trans-unit>
        <trans-unit id="65e2eefe742ea63873b699fb966b09a893a8daaa" translate="yes" xml:space="preserve">
          <source>To get the most performance benefit I want to have the test scripts that take the longest to run start first - otherwise I'll be waiting for the one test that takes nearly a minute to complete after all the others are done. I can use the --state switch to run the tests in slowest to fastest order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22228c8d3b8e275582e9f34035469fcccc1c47a6" translate="yes" xml:space="preserve">
          <source>To get the script to work properly and silence the warning make sure there are no valid references to the tied object</source>
          <target state="translated">Чтобы заставить скрипт работать корректно и заглушить предупреждение,убедитесь,что нет корректных ссылок на связанный объект</target>
        </trans-unit>
        <trans-unit id="3d2c84cce621656fbbd6db23ecc45f9cb65b75f8" translate="yes" xml:space="preserve">
          <source>To get the stash pointer for a particular package, use the function:</source>
          <target state="translated">Чтобы получить указатель на тайник для определенного пакета,используйте функцию:</target>
        </trans-unit>
        <trans-unit id="2990698bc29bbd13b737294b202675b151d03401" translate="yes" xml:space="preserve">
          <source>To get the version number from a Perl module, consumers should use the &lt;code&gt;MM-&amp;gt;parse_version($file)&lt;/code&gt; method provided by &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or &lt;a href=&quot;Module::Metadata&quot;&gt;Module::Metadata&lt;/a&gt;. For example, for the module given by &lt;code&gt;$mod&lt;/code&gt;, the version may be retrieved in one of the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1496f65198c7ac994d7422ae9ced83ce54781e58" translate="yes" xml:space="preserve">
          <source>To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is compatible with ancient perls and that File::Temp is listed as a prerequisite but CPAN has reasonable workarounds if it is missing.</source>
          <target state="translated">Для начала,обратите внимание,что GBARR/Scalar-List-Utils-1.18.tar.gz совместим с древними perls и что File::Temp указан в качестве предварительного условия,но CPAN имеет разумные обходные пути,если он отсутствует.</target>
        </trans-unit>
        <trans-unit id="0258f9df35378eac84877d3f62eff75269ae164c" translate="yes" xml:space="preserve">
          <source>To get valgrind and for more information see</source>
          <target state="translated">Чтобы получить valgrind и для получения дополнительной информации см.</target>
        </trans-unit>
        <trans-unit id="969efaa9efa953c87797414000140cc60d6a47f5" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="translated">Чтобы пройти по всем клавишам, используйте функцию &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; . Это извлекает все ключи хэша и возвращает их вам в виде списка. Затем вы можете получить значение через конкретный ключ, который вы обрабатываете:</target>
        </trans-unit>
        <trans-unit id="0bb8b0be0f6dbf55ac7483ea415db4f8150fbafd" translate="yes" xml:space="preserve">
          <source>To go through all of the keys, use the &lt;code&gt;keys&lt;/code&gt; function. This extracts all of the keys of the hash and gives them back to you as a list. You can then get the value through the particular key you're processing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7117148549139674b757cf18ceb49ea4e3b714" translate="yes" xml:space="preserve">
          <source>To hack on the Perl guts, you'll need to read the following things:</source>
          <target state="translated">Чтобы взломать кишки Перла,тебе нужно прочитать следующие вещи:</target>
        </trans-unit>
        <trans-unit id="bf182f7a67e6a5ec57b171f14e7d3fa5c6ddc216" translate="yes" xml:space="preserve">
          <source>To handle this situation, Perl uses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adcd3970934fc11a2c18b9c7c3e26524958accfd" translate="yes" xml:space="preserve">
          <source>To handle this situation, the PPCODE directive is used and the stack is extended using the macro:</source>
          <target state="translated">Для обработки этой ситуации используется директива PPCODE,а стек расширяется с помощью макроса:</target>
        </trans-unit>
        <trans-unit id="f2c53c3c3d7de6d2315fba06d0366c539cf64b63" translate="yes" xml:space="preserve">
          <source>To have everything installed in your home directory, do the following.</source>
          <target state="translated">Чтобы все было установлено в вашем домашнем каталоге,сделайте следующее.</target>
        </trans-unit>
        <trans-unit id="ebc28ed79805f971814bf2f23886e1860e904a26" translate="yes" xml:space="preserve">
          <source>To help explain what &lt;code&gt;File::GlobMapper&lt;/code&gt; does, consider what code you would write if you wanted to rename all files in the current directory that ended in &lt;code&gt;.tar.gz&lt;/code&gt; to &lt;code&gt;.tgz&lt;/code&gt;. So say these files are in the current directory</source>
          <target state="translated">Чтобы помочь объяснить, что делает &lt;code&gt;File::GlobMapper&lt;/code&gt; , подумайте, какой код вы бы написали, если бы вы хотели переименовать все файлы в текущем каталоге, оканчивающиеся на &lt;code&gt;.tar.gz&lt;/code&gt; , в &lt;code&gt;.tgz&lt;/code&gt; . Скажем, эти файлы находятся в текущем каталоге</target>
        </trans-unit>
        <trans-unit id="2009b3db85976237ffec01f5a479f250593bd279" translate="yes" xml:space="preserve">
          <source>To help understand how to write a Perl source filter we need an example to study. Here is a complete source filter that performs rot13 decoding. (Rot13 is a very simple encryption scheme used in Usenet postings to hide the contents of offensive posts. It moves every letter forward thirteen places, so that A becomes N, B becomes O, and Z becomes M.)</source>
          <target state="translated">Чтобы помочь понять,как написать фильтр исходников на Perl,нам нужен пример для изучения.Вот полный фильтр исходных текстов,выполняющий декодирование по технологии rot13.(Rot13-очень простая схема шифрования,используемая в сообщениях Usenet для сокрытия содержимого оскорбительных сообщений.Он перемещает каждую букву вперед на тринадцать мест,так что A становится N,B становится O,а Z становится M).</target>
        </trans-unit>
        <trans-unit id="b67c3276fc328ee702718e80d3624e6e736f9072" translate="yes" xml:space="preserve">
          <source>To help understand why this can be a real problem first consider how a callback is set up in an all C environment. Typically a C API will provide a function to register a callback. This will expect a pointer to a function as one of its parameters. Below is a call to a hypothetical function &lt;code&gt;register_fatal&lt;/code&gt; which registers the C function to get called when a fatal error occurs.</source>
          <target state="translated">Чтобы понять, почему это может быть реальной проблемой, сначала рассмотрим, как выполняется обратный вызов во всей среде C. Обычно API C предоставляет функцию для регистрации обратного вызова. Это будет ожидать указатель на функцию в качестве одного из ее параметров. Ниже приведен вызов гипотетической функции &lt;code&gt;register_fatal&lt;/code&gt; , которая регистрирует функцию C для вызова при возникновении фатальной ошибки.</target>
        </trans-unit>
        <trans-unit id="6caa11e5f28551bc8c9f71be4abd8c87215d7f26" translate="yes" xml:space="preserve">
          <source>To help you convert legacy programs to more modern Perl, the &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; utility will help you convert old-style Perl 4 libraries to new-style Perl5 modules.</source>
          <target state="translated">Чтобы помочь вам преобразовать устаревшие программы в более современный Perl, утилита &lt;a href=&quot;pl2pm&quot;&gt;pl2pm&lt;/a&gt; поможет вам преобразовать библиотеки Perl 4 старого стиля в модули Perl5 нового стиля.</target>
        </trans-unit>
        <trans-unit id="c501d022d8a0fffa65c230084aad7354f866cab9" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="translated">Чтобы помочь вам выяснить, что было неопределенным, perl попытается сообщить вам имя переменной (если есть), которая не была определена. В некоторых случаях он не может этого сделать, поэтому он также сообщает вам, в какой операции вы использовали неопределенное значение. Обратите внимание, однако, что perl оптимизирует вашу программу, и операция, отображаемая в предупреждении, не обязательно может буквально отображаться в вашей программе. Например, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; обычно оптимизируется в &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt; , и предупреждение будет относиться к оператору &lt;code&gt;concatenation (.)&lt;/code&gt; , даже если его нет &lt;code&gt;.&lt;/code&gt; в вашей программе.</target>
        </trans-unit>
        <trans-unit id="a5f43865bbac7f1f33a9c88f0ac1c82c9566920f" translate="yes" xml:space="preserve">
          <source>To help you figure out what was undefined, perl will try to tell you the name of the variable (if any) that was undefined. In some cases it cannot do this, so it also tells you what operation you used the undefined value in. Note, however, that perl optimizes your program and the operation displayed in the warning may not necessarily appear literally in your program. For example, &lt;code&gt;&quot;that $foo&quot;&lt;/code&gt; is usually optimized into &lt;code&gt;&quot;that &quot; . $foo&lt;/code&gt;, and the warning will refer to the &lt;code&gt;concatenation (.)&lt;/code&gt; operator, even though there is no &lt;code&gt;.&lt;/code&gt; in your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d1efff4e4ad59e580cc05099536ea5f027ae77" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt; . Add methods</source>
          <target state="translated">Чтобы скрыть острые углы под капотом, предоставьте интерфейс tie () d для пакета &lt;code&gt;symbolic&lt;/code&gt; . Добавить методы</target>
        </trans-unit>
        <trans-unit id="58c28f318aa4f864e9846446b68afedbfe1de577" translate="yes" xml:space="preserve">
          <source>To hide the rough edges under the hood, provide a tie()d interface to the package &lt;code&gt;symbolic&lt;/code&gt;. Add methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b357009cc7277d51ef692d8123b4f3841c85837" translate="yes" xml:space="preserve">
          <source>To illustrate how to use &lt;code&gt;InputLength&lt;/code&gt; here is a script that walks a zip file and prints out how many lines are in each compressed file (if you intend write code to walking through a zip file for real see &lt;a href=&quot;IO::Uncompress::Unzip#Walking-through-a-zip-file&quot;&gt;&quot;Walking through a zip file&quot; in IO::Uncompress::Unzip&lt;/a&gt; ). Also, although this example uses the zlib-based compression, the technique can be used by the other &lt;code&gt;IO::Uncompress::*&lt;/code&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb09986ebdb919a3ce53d54257037e7652baac8f" translate="yes" xml:space="preserve">
          <source>To illustrate the differences between these variables, consider the following Perl expression, which uses a single-quoted string. After execution of this statement, perl may have set all four special error variables:</source>
          <target state="translated">Чтобы проиллюстрировать различия между этими переменными,рассмотрим следующее выражение Perl,в котором используется строка в одной кавычке.После выполнения этого выражения Perl может установить все четыре специальные переменные ошибки:</target>
        </trans-unit>
        <trans-unit id="f0157186b912ecd3453913b9ba18ef7c370be226" translate="yes" xml:space="preserve">
          <source>To illustrate this feature, we'll design a pattern that matches if a string contains a palindrome. (This is a word or a sentence that, while ignoring spaces, interpunctuation and case, reads the same backwards as forwards. We begin by observing that the empty string or a string containing just one word character is a palindrome. Otherwise it must have a word character up front and the same at its end, with another palindrome in between.</source>
          <target state="translated">Чтобы проиллюстрировать эту возможность,мы создадим шаблон,который будет совпадать,если строка содержит палиндром.(Это слово или предложение,которое,игнорируя пробелы,интерполяцию и регистр,читается как задом наперёд,так и вперёд.Начнем с того,что пустая строка или строка,содержащая только одно слово,является палиндромом.В противном случае он должен иметь перед собой символ слова,а в его конце-такой же,а между ними должен находиться другой палиндром.</target>
        </trans-unit>
        <trans-unit id="983dc7293d2e1cce05648cd63638e4f7e22fc331" translate="yes" xml:space="preserve">
          <source>To illustrate unpacking for bit strings, we'll decompose a simple status register (a &quot;-&quot; stands for a &quot;reserved&quot; bit):</source>
          <target state="translated">Для иллюстрации распаковки для битовых строк разобьем простой регистр состояний (буква &quot;-&quot; означает &quot;зарезервированный&quot; бит):</target>
        </trans-unit>
        <trans-unit id="0eeac6bf1837c3892fad2067238a40143aea5c3f" translate="yes" xml:space="preserve">
          <source>To illustrate,</source>
          <target state="translated">Чтобы проиллюстрировать,</target>
        </trans-unit>
        <trans-unit id="3f180de5f2359e1c5045cf60151ad16271ecfbd0" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="translated">Чтобы реализовать конструктор копирования, добавьте &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; строки перегрузки и кода (в этом коде предполагается, что мутаторы изменяют вещи только на один уровень, поэтому рекурсивное копирование не требуется):</target>
        </trans-unit>
        <trans-unit id="1ef1c60a444763ee513ae1faa2574b43d63f6e12" translate="yes" xml:space="preserve">
          <source>To implement a copy constructor, add &lt;code&gt;'=' =&amp;gt; \&amp;amp;cpy&lt;/code&gt; to &lt;code&gt;use overload&lt;/code&gt; line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8240260917b1a03cdad7c5747565fe071f2719a2" translate="yes" xml:space="preserve">
          <source>To implement most arithmetic operations is easy; one should just use the tables of operations, and change the code which fills %subr to</source>
          <target state="translated">Реализовать большинство арифметических операций очень просто,достаточно воспользоваться таблицами операций и изменить код,который заполняет %subr на</target>
        </trans-unit>
        <trans-unit id="81c4d513cec75ad639c29820e8f6fc040826df1f" translate="yes" xml:space="preserve">
          <source>To import subroutines:</source>
          <target state="translated">Импортировать подпрограммы:</target>
        </trans-unit>
        <trans-unit id="97177a061d7ff62a243885c9bd4e1efe9ede32f2" translate="yes" xml:space="preserve">
          <source>To increase the value of something by 1 (or by some other number, if so specified).</source>
          <target state="translated">Увеличить значение чего-либо на 1 (или на какое-либо другое число,если оно указано).</target>
        </trans-unit>
        <trans-unit id="72b80e806b1c83aea2a8c7cd737f1e4bbb0943c8" translate="yes" xml:space="preserve">
          <source>To indicate to rather use commandline tools than modules</source>
          <target state="translated">Указывать на использование инструментов командной строки,а не модулей.</target>
        </trans-unit>
        <trans-unit id="75120c587d6fba4a38cc9dc45cf5606751546e6f" translate="yes" xml:space="preserve">
          <source>To insert a line after one already in the file, use the &lt;code&gt;-n&lt;/code&gt; switch. It's just like &lt;code&gt;-p&lt;/code&gt; except that it doesn't print &lt;code&gt;$_&lt;/code&gt; at the end of the loop, so you have to do that yourself. In this case, print &lt;code&gt;$_&lt;/code&gt; first, then print the line that you want to add.</source>
          <target state="translated">Чтобы вставить строку после той, которая уже есть в файле, используйте переключатель &lt;code&gt;-n&lt;/code&gt; . Это похоже на &lt;code&gt;-p&lt;/code&gt; , за исключением того, что он не печатает &lt;code&gt;$_&lt;/code&gt; в конце цикла, поэтому вам придется делать это самостоятельно. В этом случае сначала напечатайте &lt;code&gt;$_&lt;/code&gt; , а затем напечатайте строку, которую вы хотите добавить.</target>
        </trans-unit>
        <trans-unit id="574f86f03c88819ff70bca34830f6be35a8bf5f1" translate="yes" xml:space="preserve">
          <source>To install NetWare Perl onto a NetWare server, first map the Sys volume of a NetWare server to</source>
          <target state="translated">Чтобы установить NetWare Perl на сервер NetWare,сначала сопоставьте Sys том сервера NetWare с</target>
        </trans-unit>
        <trans-unit id="ee9638bdc9d8a0c759ba97d86bfdc7724a758ac8" translate="yes" xml:space="preserve">
          <source>To install a callback I pass the name of the callback and a subroutine reference to TAP::Harness or TAP::Parser's callback method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c3d18a60e95dd185226e349523858601f99df9" translate="yes" xml:space="preserve">
          <source>To install the Perl headers and the class CPerlBase documentation so that you no more need the Perl sources around to compile Perl applications using the SDK:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a520bfb7587900e1cbb96bf573db69af079c5b" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array)
{}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="translated">Чтобы перебрать индексы массива, используйте &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $i (0 .. $#array) {}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $v (@array) {}&lt;/code&gt; перебирает значения.</target>
        </trans-unit>
        <trans-unit id="bb6bf360110a80a4c3eb61df0aff99d211da1c11" translate="yes" xml:space="preserve">
          <source>To iterate over the indices of an array, use &lt;code&gt;foreach my $i (0 .. $#array) {}&lt;/code&gt;. &lt;code&gt;foreach my $v (@array) {}&lt;/code&gt; iterates over the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0a51f73b6311fa2b970169a1f0134f7c61aef8" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="translated">Чтобы присоединиться к списку рассылки объявлений о &lt;code&gt;Memoize&lt;/code&gt; , отправьте пустое сообщение по &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; . Этот список рассылки предназначен только для объявлений и имеет чрезвычайно низкий трафик - менее двух сообщений в год.</target>
        </trans-unit>
        <trans-unit id="45a6289801496005295f094536fc8ecc4c1c8e83" translate="yes" xml:space="preserve">
          <source>To join a mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt;, send an empty message to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt;. This mailing list is for announcements only and has extremely low traffic---fewer than two messages per year.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7770af2e023d19bb1b24c66498040c02b4d820" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt; , send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</source>
          <target state="translated">Чтобы присоединиться к списку рассылки с очень низким трафиком для объявлений о &lt;code&gt;Memoize&lt;/code&gt; , отправьте пустую заметку по &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed725c5a7b13b5f14db9ddb8b3bae580a82d496b" translate="yes" xml:space="preserve">
          <source>To join a very low-traffic mailing list for announcements about &lt;code&gt;Memoize&lt;/code&gt;, send an empty note to &lt;code&gt;mjd-perl-memoize-request@plover.com&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23905cfc18d99e713280156ef1eb62fd65833ce9" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;&lt;code&gt;memEQ()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;&lt;code&gt;memNE()&lt;/code&gt;&lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30da17ba518ee8896f295021c334b446312ba2d0" translate="yes" xml:space="preserve">
          <source>To just compare two strings for equality/non-equality, you can just use &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ() &lt;/a&gt; and &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE() &lt;/a&gt; as usual, except the strings must be both UTF-8 or not UTF-8 encoded.</source>
          <target state="translated">Чтобы просто сравнить две строки на равенство / неравенство, вы можете просто использовать &lt;a href=&quot;perlapi#memEQ&quot;&gt;memEQ ()&lt;/a&gt; и &lt;a href=&quot;perlapi#memEQ&quot;&gt;memNE ()&lt;/a&gt; как обычно, за исключением того, что строки должны быть как в кодировке UTF-8, так и без кодировки UTF-8.</target>
        </trans-unit>
        <trans-unit id="bfd1d911fc5d8c1a13ece46d4a41278866b326f9" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Finally, in the .xs file, edit the #include line to read:</source>
          <target state="translated">Чтобы наше пространство имен &lt;code&gt;@EXPORT&lt;/code&gt; красивым и незагрязненным, отредактируйте файл .pm и измените переменную @EXPORT на &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Наконец, в файле .xs отредактируйте строку #include, чтобы она гласила:</target>
        </trans-unit>
        <trans-unit id="66c523aae45e20a099aa6d752ca36a4c5fad3933" translate="yes" xml:space="preserve">
          <source>To keep our namespace nice and unpolluted, edit the .pm file and change the variable &lt;code&gt;@EXPORT&lt;/code&gt; to &lt;code&gt;@EXPORT_OK&lt;/code&gt;. Finally, in the .xs file, edit the #include line to read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03272788bb4c31073d76ce4d5e5b7d43fa610bff" translate="yes" xml:space="preserve">
          <source>To learn how to install modules you download from CPAN, read &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать, как установить модули, загруженные с CPAN, прочтите &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a06d2306514b40b8ba1c92a7641c86fc2fa15b9" translate="yes" xml:space="preserve">
          <source>To learn how to use a particular module, use &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;. Typically you will want to &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt;, which will then give you access to exported functions or an OO interface to the module.</source>
          <target state="translated">Чтобы узнать, как использовать конкретный модуль, используйте &lt;code&gt;perldoc &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; . Обычно вам нужно &lt;code&gt;use &lt;i&gt;Module::Name&lt;/i&gt;&lt;/code&gt; , который затем предоставит вам доступ к экспортированным функциям или объектно-ориентированному интерфейсу для модуля.</target>
        </trans-unit>
        <trans-unit id="085a503b5041562d55123a7fc6e92076974024bc" translate="yes" xml:space="preserve">
          <source>To learn more, just type a bogus option, like &lt;b&gt;-\?&lt;/b&gt;, and a long usage message will be provided. There are a fair number of possibilities.</source>
          <target state="translated">Чтобы узнать больше, просто введите фиктивный вариант, например &lt;b&gt;- \? &lt;/b&gt;, и будет предоставлено длинное сообщение об использовании. Есть изрядное количество возможностей.</target>
        </trans-unit>
        <trans-unit id="7513ca0f7dee98a8be8a3dca79c36e371b5b2223" translate="yes" xml:space="preserve">
          <source>To limit the allowed bracked notation methods to a specific list, use the whitelist() method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b660f64338ea03a5a1e256309c3e2566abdfdf76" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Floating-point Arithmetic in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">Чтобы ограничить количество десятичных знаков в числах, вы можете использовать функцию &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; . Подробнее см. &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;Арифметика с плавающей запятой в perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0835636a7544b690a78e5a06870d277ecb58681d" translate="yes" xml:space="preserve">
          <source>To limit the number of decimal places in your numbers, you can use the &lt;code&gt;printf&lt;/code&gt; or &lt;code&gt;sprintf&lt;/code&gt; function. See &lt;a href=&quot;perlop#Floating-point-Arithmetic&quot;&gt;&quot;Floating-point Arithmetic&quot; in perlop&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08be93803c5f2a1dab3670911ed75d37f74ad6a" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt; , typically from your &lt;code&gt;Build.PL&lt;/code&gt; . For example:</source>
          <target state="translated">Чтобы загрузить плагины &lt;code&gt;TAP::Harness&lt;/code&gt; , вам нужно использовать параметр &lt;code&gt;tap_harness_args&lt;/code&gt; для &lt;code&gt;new&lt;/code&gt; , обычно из вашего &lt;code&gt;Build.PL&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="189a273951294ca8e561bbd38119a481f3bcdeb3" translate="yes" xml:space="preserve">
          <source>To load &lt;code&gt;TAP::Harness&lt;/code&gt; plugins, you'll need to use the &lt;code&gt;tap_harness_args&lt;/code&gt; parameter to &lt;code&gt;new&lt;/code&gt;, typically from your &lt;code&gt;Build.PL&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1281377e392724ce754ea5fba63ddbdb0e3e3b86" translate="yes" xml:space="preserve">
          <source>To load on demand. (Also called &amp;ldquo;lazy&amp;rdquo; loading.) Specifically, to call an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine on behalf of an undefined subroutine.</source>
          <target state="translated">Загрузить по запросу. (Также называется &amp;laquo;ленивой&amp;raquo; загрузкой.) В частности, для вызова подпрограммы &lt;code&gt;AUTOLOAD&lt;/code&gt; от имени неопределенной подпрограммы.</target>
        </trans-unit>
        <trans-unit id="793c105080b4d15bf59a358db204c3e7d2658f2d" translate="yes" xml:space="preserve">
          <source>To load packages while adding them to &lt;code&gt;@ISA&lt;/code&gt;, see the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma. The discouraged &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma does this as well, but should not be used except when compatibility with the discouraged &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23756075d8a23d3d03df135a356f7c210c8debd" translate="yes" xml:space="preserve">
          <source>To maintain backward compatibility with version 1.x of this module &lt;code&gt;gzreadline&lt;/code&gt; ignores the &lt;code&gt;$/&lt;/code&gt; variable - it</source>
          <target state="translated">Для обеспечения обратной совместимости с версией 1.x этого модуля &lt;code&gt;gzreadline&lt;/code&gt; игнорирует переменную &lt;code&gt;$/&lt;/code&gt; - она</target>
        </trans-unit>
        <trans-unit id="abc4743aa98a734da932da278854d69561d0cbfb" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt; . We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt; , thus add</source>
          <target state="translated">Чтобы заставить &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; работать, нам нужно реализовать настоящие мутаторы либо напрямую, либо через &lt;code&gt;nomethod&lt;/code&gt; либо метод . Мы продолжаем делать что-то внутри &lt;code&gt;nomethod&lt;/code&gt; , поэтому добавляем</target>
        </trans-unit>
        <trans-unit id="6a057782113c7191c271c05bf3e4a07cba925f05" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; work, we need to implement actual mutators, either directly, or in &lt;code&gt;nomethod&lt;/code&gt;. We continue to do things inside &lt;code&gt;nomethod&lt;/code&gt;, thus add</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a1c6beb7c38d494fe7c7d801b2befdd4173ffc" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; work, there were two changes to</source>
          <target state="translated">Чтобы &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; работал, в</target>
        </trans-unit>
        <trans-unit id="b87c350e6119d6693a7cb04a8612a5e26f6e647d" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt; , give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="translated">Чтобы сделать резервную копию &lt;code&gt;inFile.txt&lt;/code&gt; , дайте &lt;code&gt;-i&lt;/code&gt; добавляемое расширение файла:</target>
        </trans-unit>
        <trans-unit id="6d55112a0a5725689f79da10048f1a7a2263eebb" translate="yes" xml:space="preserve">
          <source>To make a backup of &lt;code&gt;inFile.txt&lt;/code&gt;, give &lt;code&gt;-i&lt;/code&gt; a file extension to add:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e23de5e44e6d05a87a65143f53c7e5d6f21dc61" translate="yes" xml:space="preserve">
          <source>To make a local branch of a remote branch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8414b77ccfd34c712fab8c626931679fd71f5d22" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="translated">Короче говоря, вы можете использовать специальные переменные &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; и &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; с AV и HV, но вы должны быть уверены, что знаете, что делаете.</target>
        </trans-unit>
        <trans-unit id="da79e317ac8a925a940d2422dac9d23c152e3b6d" translate="yes" xml:space="preserve">
          <source>To make a long story short, you can use the special variables &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;, &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; with AVs and HVs, but you have to make sure you know what you're doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0463c040e841ec603e099982e8abee57b683e9" translate="yes" xml:space="preserve">
          <source>To make life easier when dealing with duplicate keys, &lt;b&gt;DB_File&lt;/b&gt; comes with a few utility methods.</source>
          <target state="translated">Чтобы облегчить жизнь при работе с повторяющимися ключами, &lt;b&gt;DB_File&lt;/b&gt; поставляется с несколькими служебными методами.</target>
        </trans-unit>
        <trans-unit id="5ae2d3fa0128e67ff0e0a2c8bcd480511ed4d982" translate="yes" xml:space="preserve">
          <source>To make proper use of the</source>
          <target state="translated">Для правильного использования</target>
        </trans-unit>
        <trans-unit id="c44a199ec9bf1193e7c67a06e66e66c5a73ebf54" translate="yes" xml:space="preserve">
          <source>To make sure we're talking about the same thing when we discuss the removal of features or functionality from the Perl core, we have specific definitions for a few words and phrases.</source>
          <target state="translated">Чтобы убедиться в том,что мы говорим об одном и том же,когда обсуждаем удаление функций или функциональности из ядра Perl,у нас есть специальные определения для нескольких слов и фраз.</target>
        </trans-unit>
        <trans-unit id="5942273fcaa449896c9e37c66cd4e802e9c0964a" translate="yes" xml:space="preserve">
          <source>To make symbols from a &lt;b&gt;module&lt;/b&gt; available for &lt;b&gt;import&lt;/b&gt; by other modules.</source>
          <target state="translated">Сделать символы из &lt;b&gt;модуля&lt;/b&gt; доступными для &lt;b&gt;импорта&lt;/b&gt; другими модулями.</target>
        </trans-unit>
        <trans-unit id="dcd61647f554ce66ac28cd2d49ac0cbdb07ed537" translate="yes" xml:space="preserve">
          <source>To make the field hashes kick in, it is easiest to redefine &lt;code&gt;refaddr&lt;/code&gt; as</source>
          <target state="translated">Чтобы использовать хэши полей, проще всего переопределить &lt;code&gt;refaddr&lt;/code&gt; как</target>
        </trans-unit>
        <trans-unit id="ffcdcbe9b2ae0d61ba055686a39957aa53dc38e5" translate="yes" xml:space="preserve">
          <source>To make the interface more useful for older versions of Perl, a number of methods are supplied with &lt;b&gt;DB_File&lt;/b&gt; to simulate the missing array operations. All these methods are accessed via the object returned from the tie call.</source>
          <target state="translated">Чтобы сделать интерфейс более полезным для старых версий Perl, с &lt;b&gt;DB_File&lt;/b&gt; поставляется ряд методов для имитации операций с отсутствующими массивами. Доступ ко всем этим методам осуществляется через объект, возвращаемый при вызове связи.</target>
        </trans-unit>
        <trans-unit id="1e1af3e6c47d65824073836d9be72328a9d2a810" translate="yes" xml:space="preserve">
          <source>To make these calls fail</source>
          <target state="translated">Чтобы сделать эти звонки неудачными.</target>
        </trans-unit>
        <trans-unit id="5100ca13c61421986a8b595f7f48745403cf86c2" translate="yes" xml:space="preserve">
          <source>To make things more complicated, the hash may contain references to the actual destinations, for example:</source>
          <target state="translated">Чтобы все усложнить,хэш может содержать,например,ссылки на фактические места назначения:</target>
        </trans-unit>
        <trans-unit id="23271da81593c086fb9f97e8eda36eed5fe8ab37" translate="yes" xml:space="preserve">
          <source>To make use of either of the two filter modules above, place the line below in a Perl source file.</source>
          <target state="translated">Чтобы использовать любой из двух модулей фильтров выше,поместите строку внизу в исходном файле Perl.</target>
        </trans-unit>
        <trans-unit id="546b84e64be1bb2630d4087e9c7e0aa2ec07fbeb" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="translated">Однако для использования потоковой передачи обычно требуется, чтобы потоки обменивались хотя бы некоторыми данными между собой. Это делается с помощью модуля &lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt; и атрибута: &lt;code&gt;:shared&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a04c440174950d35de1ff03f07736720e16d8ea1" translate="yes" xml:space="preserve">
          <source>To make use of threading, however, one usually wants the threads to share at least some data between themselves. This is done with the &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; module and the &lt;code&gt;:shared&lt;/code&gt; attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482a24cc09ed210b4be1c7fca66ab517d60e1e62" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">Чтобы пометить FILEHANDLE как UTF-8, используйте &lt;code&gt;:utf8&lt;/code&gt; или &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; просто помечает данные как UTF-8 без дополнительной проверки, а &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; проверяет, действительно ли данные являются действительными UTF-8. Более подробную информацию можно найти в &lt;a href=&quot;../perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5274ade94ad24fbd8e1e1d8904bba9bc30f6d6c0" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="translated">Чтобы пометить FILEHANDLE как UTF-8, используйте &lt;code&gt;:utf8&lt;/code&gt; или &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; . &lt;code&gt;:utf8&lt;/code&gt; просто помечает данные как UTF-8 без дополнительной проверки, а &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; проверяет, действительно ли данные являются действительными UTF-8. Более подробную информацию можно найти в &lt;a href=&quot;perlio/encoding&quot;&gt;PerlIO :: encoding&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5abdd218835bb6eb6001f3cd74ea29d6653d76a4" translate="yes" xml:space="preserve">
          <source>To mark FILEHANDLE as UTF-8, use &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;. &lt;code&gt;:utf8&lt;/code&gt; just marks the data as UTF-8 without further checking, while &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; checks the data for actually being valid UTF-8. More details can be found in &lt;a href=&quot;PerlIO::encoding&quot;&gt;PerlIO::encoding&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e2df2dd87486f202e752cbd1bc2453ac926173" translate="yes" xml:space="preserve">
          <source>To minimize the number of sbrk(2)s, malloc() asks for more memory. This field gives the size of the yet unused part, which is sbrk(2)ed, but never touched.</source>
          <target state="translated">Чтобы минимизировать количество sbrk(2)s,функция malloc()запрашивает больше памяти.Это поле задает размер еще неиспользуемой части,которая является sbrk(2)ed,но никогда не затрагивалась.</target>
        </trans-unit>
        <trans-unit id="c7e29496ccd957aa4492216e45f2282e137e2591" translate="yes" xml:space="preserve">
          <source>To obtain this, a reference to a hash must be passed</source>
          <target state="translated">Чтобы получить это,необходимо передать ссылку на хэш.</target>
        </trans-unit>
        <trans-unit id="76c61aa559d88fae477b92a372d192b3b51d4c5b" translate="yes" xml:space="preserve">
          <source>To open a file without blocking, creating if necessary:</source>
          <target state="translated">Чтобы открыть файл без блокировки,создайте при необходимости:</target>
        </trans-unit>
        <trans-unit id="354facfe42bf4e55b171df83905f745324ebd0c9" translate="yes" xml:space="preserve">
          <source>To open file for appending, create if necessary:</source>
          <target state="translated">Чтобы открыть файл для добавления,создайте его при необходимости:</target>
        </trans-unit>
        <trans-unit id="1702818d3f57a9131b4035ed033f063e2b07cebf" translate="yes" xml:space="preserve">
          <source>To open file for appending, file must exist:</source>
          <target state="translated">Чтобы открыть файл для добавления,он должен существовать:</target>
        </trans-unit>
        <trans-unit id="4967760590c67e61373186454a8e4a1135dcb6d9" translate="yes" xml:space="preserve">
          <source>To open file for reading:</source>
          <target state="translated">Открыть файл для чтения:</target>
        </trans-unit>
        <trans-unit id="cee1bc0ab3a065feee926895157fb947a422ff0d" translate="yes" xml:space="preserve">
          <source>To open file for update, create file if necessary:</source>
          <target state="translated">Чтобы открыть файл для обновления,при необходимости создайте файл:</target>
        </trans-unit>
        <trans-unit id="7c8a25c4e2b2e915deaf352a915d4e6583e2f962" translate="yes" xml:space="preserve">
          <source>To open file for update, file must exist:</source>
          <target state="translated">Чтобы открыть файл для обновления,он должен существовать:</target>
        </trans-unit>
        <trans-unit id="b8d1b7a21cb716decbfe05cd44f437ced848a3ac" translate="yes" xml:space="preserve">
          <source>To open file for update, file must not exist:</source>
          <target state="translated">Чтобы открыть файл для обновления,файл не должен существовать:</target>
        </trans-unit>
        <trans-unit id="e09916f7ec3e12864e36849354a4ebf1fbb19361" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file if needed or else truncate old file:</source>
          <target state="translated">Чтобы открыть файл для записи,при необходимости создайте новый файл или укоротите старый:</target>
        </trans-unit>
        <trans-unit id="290398a666a114bce8d99caa62b27b49c84e4b59" translate="yes" xml:space="preserve">
          <source>To open file for writing, create new file, file must not exist:</source>
          <target state="translated">Чтобы открыть файл для записи,создать новый файл,файл не должен существовать:</target>
        </trans-unit>
        <trans-unit id="d996476f79882a20a27ba1e93bb75ca52cdeca1e" translate="yes" xml:space="preserve">
          <source>To open the temporary filehandle with O_EXLOCK (open with exclusive file lock) use &lt;code&gt;EXLOCK=&amp;gt;1&lt;/code&gt;. This is supported only by some operating systems (most notably BSD derived systems). By default EXLOCK will be false. Former &lt;code&gt;File::Temp&lt;/code&gt; versions set EXLOCK to true, so to be sure to get an unlocked filehandle also with older versions, explicitly set &lt;code&gt;EXLOCK=&amp;gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6007d31a54fba5ebc4520f06ed8627e89a0d4a2c" translate="yes" xml:space="preserve">
          <source>To output UTF-8, use the &lt;code&gt;:encoding&lt;/code&gt; or &lt;code&gt;:utf8&lt;/code&gt; output layer. Prepending</source>
          <target state="translated">Для вывода UTF-8 используйте выходной слой &lt;code&gt;:encoding&lt;/code&gt; или &lt;code&gt;:utf8&lt;/code&gt; . Подготовка</target>
        </trans-unit>
        <trans-unit id="3b36e6dcece917ee92e199616190bf7ab5b56187" translate="yes" xml:space="preserve">
          <source>To overcome this limitation, you need to turn on /s matching within the prefix pattern, using the &lt;code&gt;(?s)&lt;/code&gt; directive: '(?s).*?(?=&amp;lt;H1&amp;gt;)'</source>
          <target state="translated">Чтобы преодолеть это ограничение, вам необходимо включить / s сопоставление в шаблоне префикса с помощью директивы &lt;code&gt;(?s)&lt;/code&gt; : '(? S). *? (? = &amp;lt;H1&amp;gt;)'</target>
        </trans-unit>
        <trans-unit id="062f2ac749842e1dd1762ff59d78e1eb660fe9b7" translate="yes" xml:space="preserve">
          <source>To override a Perl built-in routine with your own version, you need to import it at compile-time. This can be conveniently achieved with the &lt;code&gt;subs&lt;/code&gt; pragma. This will affect only the package in which you've imported the said subroutine:</source>
          <target state="translated">Чтобы заменить встроенную процедуру Perl вашей собственной версией, вам необходимо импортировать ее во время компиляции. Этого удобно достичь с помощью &lt;code&gt;subs&lt;/code&gt; . Это повлияет только на пакет, в который вы импортировали указанную подпрограмму:</target>
        </trans-unit>
        <trans-unit id="1aa3f784c17082d78c7fbfe639d471e8c69f8458" translate="yes" xml:space="preserve">
          <source>To override a built-in globally (that is, in all namespaces), you need to import your function into the &lt;code&gt;CORE::GLOBAL&lt;/code&gt; pseudo-namespace at compile time:</source>
          <target state="translated">Чтобы переопределить встроенное глобально (то есть во всех пространствах имен), вам необходимо импортировать свою функцию в псевдо-пространство имен &lt;code&gt;CORE::GLOBAL&lt;/code&gt; во время компиляции:</target>
        </trans-unit>
        <trans-unit id="675c69919880e76e4b55ea1a685db1213f2914e2" translate="yes" xml:space="preserve">
          <source>To override the standard utime():</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605fcd402b7e1fdc810b4ff2c0f6a15f906ca915" translate="yes" xml:space="preserve">
          <source>To pack dates stored as triplets ( day, month, year ) in an array &lt;code&gt;@dates&lt;/code&gt; into a sequence of byte, byte, short integer we can write</source>
          <target state="translated">Чтобы упаковать даты, хранящиеся в виде троек (день, месяц, год) в массиве &lt;code&gt;@dates&lt;/code&gt; , в последовательность байтов, байтов, коротких целых чисел, мы можем написать</target>
        </trans-unit>
        <trans-unit id="1d0cde2eb7df8017d255040c9f5af9796899dd92" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a floating point number use</source>
          <target state="translated">Чтобы проанализировать строку &lt;code&gt;$str&lt;/code&gt; как число с плавающей запятой, используйте</target>
        </trans-unit>
        <trans-unit id="61571c195afbee84b0b85796b78595db86b7183b" translate="yes" xml:space="preserve">
          <source>To parse a string &lt;code&gt;$str&lt;/code&gt; as a number in some base &lt;code&gt;$base&lt;/code&gt; use</source>
          <target state="translated">Чтобы проанализировать строку &lt;code&gt;$str&lt;/code&gt; как число в некоторой базовой &lt;code&gt;$base&lt;/code&gt; используйте</target>
        </trans-unit>
        <trans-unit id="8c0b000078df0842ed41dd6cf17b93c225c65646" translate="yes" xml:space="preserve">
          <source>To parse this code, Perl uses a heuristic based on what package names it has seen, what subroutines exist in the current package, what barewords it has previously seen, and other input. Needless to say, heuristics can produce very surprising results!</source>
          <target state="translated">Для разбора этого кода Perl использует эвристический подход,основанный на том,какие имена пакетов он видел,какие подпрограммы существуют в текущем пакете,какие пустые слова он видел ранее,и другие вводимые данные.Нет необходимости говорить,что эвристика может дать очень удивительные результаты!</target>
        </trans-unit>
        <trans-unit id="fbca7774c8df9c1e7fff186e61962bc8047a5ac6" translate="yes" xml:space="preserve">
          <source>To pass an object method into a subroutine, you can do this:</source>
          <target state="translated">Для передачи метода объекта в подпрограмму можно это сделать:</target>
        </trans-unit>
        <trans-unit id="767a526ac8d0e957a93b83324d4f56d1ac303c9b" translate="yes" xml:space="preserve">
          <source>To pass in &lt;code&gt;NULL&lt;/code&gt; as the pointer to an optional buffer, pass in an empty list reference, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249caf0f11ba46a1737a888a2cd12f841c024b93" translate="yes" xml:space="preserve">
          <source>To pass supplemental arguments to a program opened with &lt;code&gt; '|-' &lt;/code&gt; or &lt;code&gt; '-|' &lt;/code&gt; append them to the command string as you would system EXPR.</source>
          <target state="translated">Для передачи дополнительных аргументов программе, открытой с помощью &lt;code&gt; '|-' &lt;/code&gt; или &lt;code&gt; '-|' &lt;/code&gt; добавьте их в командную строку, как если бы вы использовали системный EXPR.</target>
        </trans-unit>
        <trans-unit id="9bb3f23b2e2cd47ffa049a4b5b8e3297a48bd649" translate="yes" xml:space="preserve">
          <source>To prepare distribution you need to do following:</source>
          <target state="translated">Для подготовки дистрибуции вам необходимо сделать следующее:</target>
        </trans-unit>
        <trans-unit id="47e04bab26a33f27d49843c62d8c3b7400695e70" translate="yes" xml:space="preserve">
          <source>To prepend lines to the beginning, print those lines before you enter the loop that prints the existing lines.</source>
          <target state="translated">Чтобы подготовить строки к началу,распечатайте эти строки перед входом в петлю,которая печатает существующие строки.</target>
        </trans-unit>
        <trans-unit id="453d8a60ef1b8720b3eb21b0a6becefda886f512" translate="yes" xml:space="preserve">
          <source>To prevent &amp;lt;extract_quotelike&amp;gt; from mucking about with the input in this way (this is the only case where a list-context &lt;code&gt;extract_quotelike&lt;/code&gt; does so), you can pass the input variable as an interpolated literal:</source>
          <target state="translated">Чтобы &amp;lt;extract_quotelike&amp;gt; не возился с вводом таким образом (это единственный случай, когда это происходит с помощью list-context &lt;code&gt;extract_quotelike&lt;/code&gt; ), вы можете передать входную переменную как интерполированный литерал:</target>
        </trans-unit>
        <trans-unit id="743105860f25b02f06770315902de6783c423895" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">Для предотвращения &lt;code&gt;memoize&lt;/code&gt; от установки memoized версии в любом месте, используйте &lt;code&gt;INSTALL =&amp;gt; &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0ceea23486fb8fa0dd3f37c46296eb6503b2487" translate="yes" xml:space="preserve">
          <source>To prevent &lt;code&gt;memoize&lt;/code&gt; from installing the memoized version anywhere, use &lt;code&gt;INSTALL =&amp;gt; undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9de321857a95078722502ca43a0201a5f6a4b12" translate="yes" xml:space="preserve">
          <source>To prevent any ambiguity,</source>
          <target state="translated">Чтобы предотвратить любую двусмысленность,</target>
        </trans-unit>
        <trans-unit id="fb87adecfac8f5df4ab3fe938fde55af46ebf1a3" translate="yes" xml:space="preserve">
          <source>To prevent specific methods from being called in bracket notation, use the blacklist() method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d04ca12ba631be1e6e856ee05396b933016cf93" translate="yes" xml:space="preserve">
          <source>To prevent the &lt;code&gt;qv()&lt;/code&gt; function from being exported to the caller's namespace, either use version with a null parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0fc603c0e20ee050f6b1167e08040f2086e70a" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="translated">Чтобы предотвратить изменение содержимого очереди другим потоком во время его проверки и / или изменения, &lt;a href=&quot;../threads/shared#lock-VARIABLE&quot;&gt;заблокируйте&lt;/a&gt; очередь внутри локального блока:</target>
        </trans-unit>
        <trans-unit id="b8427301b03347200dffe8c8bd3a067e2726323d" translate="yes" xml:space="preserve">
          <source>To prevent the contents of a queue from being modified by another thread while it is being examined and/or changed, &lt;a href=&quot;threads::shared#lock-VARIABLE&quot;&gt;lock&lt;/a&gt; the queue inside a local block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521d225cb8b8267bdc9221af420cb3102374b4c5" translate="yes" xml:space="preserve">
          <source>To prevent this, supply a &lt;code&gt;NORMALIZER&lt;/code&gt; function that turns the program arguments into a string in a way that equivalent arguments turn into the same string. A &lt;code&gt;NORMALIZER&lt;/code&gt; function for &lt;code&gt;f&lt;/code&gt; above might look like this:</source>
          <target state="translated">Чтобы предотвратить это, предоставьте функцию &lt;code&gt;NORMALIZER&lt;/code&gt; , которая превращает аргументы программы в строку таким образом, чтобы эквивалентные аргументы превращались в ту же строку. Функция &lt;code&gt;NORMALIZER&lt;/code&gt; для приведенного выше &lt;code&gt;f&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="6fa84f786f1f2e361ba53d7582050f707e69605c" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt; , either say</source>
          <target state="translated">Чтобы создать двоичный файл perl с именем, отличным от имени &lt;code&gt;perl&lt;/code&gt; , либо скажите</target>
        </trans-unit>
        <trans-unit id="76b5e8be4f2c5ad1ba3d72bdd1d3c182b64412ef" translate="yes" xml:space="preserve">
          <source>To produce a perl binary with a different name than &lt;code&gt;perl&lt;/code&gt;, either say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deeb5ed64d8b8726d03c2a35d8b9a4f9932501dd" translate="yes" xml:space="preserve">
          <source>To prove success on the host machine, run &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; from the win32/ folder and look for &quot;machine (ARM)&quot; in the FILE HEADER VALUES and &quot;subsystem (Windows CE GUI)&quot; in the OPTIONAL HEADER VALUES.</source>
          <target state="translated">Чтобы доказать успех на главной машине,запустите &quot;dumpbin /headers wince-arm-pocket-wce400\perl.exe&quot; из папки win32/и ищите &quot;machine (ARM)&quot; в &quot;FILE HEADER VALUES&quot; и &quot;subsystem (Windows CE GUI)&quot; в ОПТИЦИОНАЛЬНЫХ ЦЕНАХ ГЕНЕРАЛЬНОГО ЗАВОДА.</target>
        </trans-unit>
        <trans-unit id="e3f95db7629c92dc13df17dee2376ecae6bd28b4" translate="yes" xml:space="preserve">
          <source>To provide a Perl interface to this library we need to be able to map between the &lt;code&gt;fh&lt;/code&gt; parameter and the Perl subroutine we want called. A hash is a convenient mechanism for storing this mapping. The code below shows a possible implementation</source>
          <target state="translated">Чтобы предоставить Perl-интерфейс для этой библиотеки, нам нужно иметь возможность отображать между параметром &lt;code&gt;fh&lt;/code&gt; и подпрограммой Perl, которую мы хотим вызвать . Хеш - удобный механизм для хранения этого сопоставления. В приведенном ниже коде показана возможная реализация</target>
        </trans-unit>
        <trans-unit id="56afd5e1c9ab39b7d24b6a35fc7523124fb4a154" translate="yes" xml:space="preserve">
          <source>To provide an example, let's say the popular &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; function doesn't deal with Unicode data yet. The wrapper function would convert the argument to raw UTF-8 and convert the result back to Perl's internal representation like so:</source>
          <target state="translated">В качестве примера предположим, что популярная функция &lt;code&gt;Foo::Bar::escape_html&lt;/code&gt; еще не работает с данными Unicode. Функция-оболочка преобразует аргумент в необработанный UTF-8 и преобразует результат обратно во внутреннее представление Perl следующим образом:</target>
        </trans-unit>
        <trans-unit id="67eb0c577eae9b827927188aaf0fb3c3cf029b5e" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of &lt;a href=&quot;Net::Ping&quot;&gt;Net::Ping&lt;/a&gt;, a &lt;code&gt;pingecho()&lt;/code&gt; subroutine is available with the same functionality as before. &lt;code&gt;pingecho()&lt;/code&gt; uses the tcp protocol. The return values and parameters are the same as described for the &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method. This subroutine is obsolete and may be removed in a future version of &lt;a href=&quot;Net::Ping&quot;&gt;Net::Ping&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe539191c8112058d164cdbdc07c4a313e2ceb71" translate="yes" xml:space="preserve">
          <source>To provide backward compatibility with the previous version of Net::Ping, a pingecho() subroutine is available with the same functionality as before. pingecho() uses the tcp protocol. The return values and parameters are the same as described for the ping() method. This subroutine is obsolete and may be removed in a future version of Net::Ping.</source>
          <target state="translated">Для обеспечения обратной совместимости с предыдущей версией Net::Ping доступна подпрограмма pingecho()с той же функциональностью,что и раньше.pingecho()использует протокол tcp.Возвращаемые значения и параметры такие же,как и в методе ping().Эта подпрограмма устарела и может быть удалена в будущей версии Net::Ping.</target>
        </trans-unit>
        <trans-unit id="ece610257b3402f7eea4d17dbc76eda55d9cbb02" translate="yes" xml:space="preserve">
          <source>To provide the capability to set/get class-wide settings, it is best instead to provide accessors as subroutines or class methods instead.</source>
          <target state="translated">Для предоставления возможности устанавливать/запоминать настройки всего класса,лучше всего вместо этого предоставить аксессуары в виде подпрограмм или методов класса.</target>
        </trans-unit>
        <trans-unit id="c22d13aed3a39a35ea13dd4bc32c2e899b497afb" translate="yes" xml:space="preserve">
          <source>To purchase this book, visit &lt;a href=&quot;http://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt; or your favourite bookstore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ea3ee26188231fd563bb14e2dd6e7f583ebf9d" translate="yes" xml:space="preserve">
          <source>To purchase this book, visit &lt;a href=&quot;https://oreilly.com/catalog/9780596514471/&quot;&gt;http://oreilly.com/catalog/9780596514471/&lt;/a&gt; or your favourite bookstore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ad3c75e2a9658073e3c75677575371b7b2154a" translate="yes" xml:space="preserve">
          <source>To put the output from any parse method into a string instead of a file handle, call the output_string() method instead of output_fh().</source>
          <target state="translated">Чтобы поместить вывод из любого метода разбора в строку вместо файлового дескриптора,вызовите метод output_string()вместо output_fh().</target>
        </trans-unit>
        <trans-unit id="8d3d8f79e5bb23da5237f2bc4f067b582af08744" translate="yes" xml:space="preserve">
          <source>To quickly check the type of a &lt;code&gt;Archive::Tar::File&lt;/code&gt; object, you can use the following methods:</source>
          <target state="translated">Чтобы быстро проверить тип объекта &lt;code&gt;Archive::Tar::File&lt;/code&gt; , вы можете использовать следующие методы:</target>
        </trans-unit>
        <trans-unit id="ffb74a402d25037ed756434b89268f8c6c0f487e" translate="yes" xml:space="preserve">
          <source>To quote the bzip2 documentation</source>
          <target state="translated">Для цитирования документации bzip2</target>
        </trans-unit>
        <trans-unit id="2e030dd198e6e120e9f1df9a82e7575806595a2d" translate="yes" xml:space="preserve">
          <source>To read an entire &lt;b&gt;file&lt;/b&gt; into a &lt;b&gt;string&lt;/b&gt; in one operation.</source>
          <target state="translated">Считать весь &lt;b&gt;файл&lt;/b&gt; в &lt;b&gt;строку&lt;/b&gt; за одну операцию.</target>
        </trans-unit>
        <trans-unit id="d6676802f298dda33ea89ee297e7a4c3b7e4e2ac" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately to files, and then read from those files when the program is done:</source>
          <target state="translated">Для чтения как STDOUT команды,так и ее STDERR отдельно,проще всего перенаправить их отдельно в файлы,а затем читать из этих файлов по окончании работы программы:</target>
        </trans-unit>
        <trans-unit id="441b0a3f043e9d675f24f50e1a3845049a78b701" translate="yes" xml:space="preserve">
          <source>To read both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let the command run, then read the temp files:</source>
          <target state="translated">Чтобы прочитать как STDOUT,так и STDERR команды по отдельности,можно перенаправить их в temp-файлы,дать команде выполниться,а затем прочитать временные файлы:</target>
        </trans-unit>
        <trans-unit id="5540d6192acd70f39a8ef597e449669bc8ae5ddb" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">Для чтения из существующего дескриптора файла Perl, &lt;code&gt;$input&lt;/code&gt; , и записи сжатых данных в буфер, &lt;code&gt;$buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c349b729382da049ab850b286913e925d6fe3968" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt; , and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">Для чтения из существующего дескриптора файла Perl, &lt;code&gt;$input&lt;/code&gt; , и записи несжатых данных в буфер, &lt;code&gt;$buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b6c4a10d71392deb29372c2a92475955d692a6e" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt;, and write the compressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4ba76e5ff4a01f16e01bd7d5a780beec6519c3" translate="yes" xml:space="preserve">
          <source>To read from an existing Perl filehandle, &lt;code&gt;$input&lt;/code&gt;, and write the uncompressed data to a buffer, &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7482ebcf137b958140c12465f2671a82fcf986b9" translate="yes" xml:space="preserve">
          <source>To read the</source>
          <target state="translated">Чтобы прочитать</target>
        </trans-unit>
        <trans-unit id="87df4beb52a8613330401231fb10bf4839a044e4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.1950&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcdf55eeb6470c2b3d7fd6cf75243e9a7e9d3240" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1950&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3af95cfb979c68a078d4244b348eca50284cce" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.1951&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4698f091bc1fdd774cb393f877e7282bc2a1c3c5" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.1951&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe87604cf51141fe67b4d7c05185428541881932" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.Compressed&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f301dbf129331d08eb2d42bb04443bcca2c06d9c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.Compressed&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd74724ed743479732074df76791b8e4375f0ba" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.bz2&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="263ebe5d94b7d39489ca2895d917dbacbfcc41fc" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0224a4a1040095275155b56f5f7207fca1c2ad1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt.gz&lt;/code&gt; и записать несжатые данные в файл &lt;code&gt;file1.txt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="328756a43a9eee1db660f9353e2936fa148261c1" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt.gz&lt;/code&gt; and write the uncompressed data to the file &lt;code&gt;file1.txt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b61bd1daa8a6cb2d7eb96d3ece7209a79b5aec" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.1950&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58f6252b156248cb5d164937a716b657f41d643b" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1950&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e429b7a25235b582c4b383620392f1a750a3bdd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.1951&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fef40be75516f086b04d71827ac5f116bf2718cd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.1951&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c406d8acaac2a742d676187babe70fbc63a189bd" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.bz2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33aeb771cd352fb39ce6d9be074532d17039ae52" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.bz2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa350228ff2721777414a685ddb5c4e3af10826c" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.gz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a2635502bb2923dab4d82f7333e4b41da9484a4" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.gz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1253348a31fd66554a6efd5d56c0e22a2ff1b137" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt; .</source>
          <target state="translated">Прочитать содержимое файла &lt;code&gt;file1.txt&lt;/code&gt; и записать сжатые данные в файл &lt;code&gt;file1.txt.zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae6686db2a7eebd5b91805c9b0d9008be2e94d9e" translate="yes" xml:space="preserve">
          <source>To read the contents of the file &lt;code&gt;file1.txt&lt;/code&gt; and write the compressed data to the file &lt;code&gt;file1.txt.zip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb0378e48901dddc588a6225fe4a4196884f056" translate="yes" xml:space="preserve">
          <source>To really poke around with Perl, you'll probably want to build Perl for debugging, like this:</source>
          <target state="translated">Чтобы по-настоящему пообщаться с Перлом,вам,наверное,захочется построить Perl для отладки,вот так:</target>
        </trans-unit>
        <trans-unit id="224b47d42836cf02b0538bc7324878629aa47a30" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</source>
          <target state="translated">Чтобы получать уведомление о выпуске новой версии этого модуля, отправьте пустое сообщение электронной почты на &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c2c718f1481d7a23bdb92c3c65c5d23a83c26f" translate="yes" xml:space="preserve">
          <source>To receive an announcement whenever a new version of this module is released, send a blank email message to &lt;code&gt;mjd-perl-tiefile-subscribe@plover.com&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bd9384e894fc19ae43b0a3a96f9c688fce9ba8" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;a href=&quot;File::Path#make_path%28-%24dir1%2C-%24dir2%2C-....-%29&quot;&gt;&lt;code&gt;make_path&lt;/code&gt;&lt;/a&gt; function of the &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e33fd8f77a0950334d95b2b753813796d2bf20" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы рекурсивно создать структуру каталогов, посмотрите на функцию &lt;code&gt;make_path&lt;/code&gt; модуля &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d93ce0279ba5e733f28599be83e53944021fc924" translate="yes" xml:space="preserve">
          <source>To recursively create a directory structure, look at the &lt;code&gt;make_path&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы рекурсивно создать структуру каталогов, посмотрите на функцию &lt;code&gt;make_path&lt;/code&gt; модуля &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5946d1b5adc8bf79e8d8691892a42663cd834d2" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt; , which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="translated">Чтобы максимально снизить накладные расходы, проверяется только одно возможное местоположение для поиска DLL расширения (это место, куда &lt;code&gt;make install&lt;/code&gt; поместит DLL). Если он не найден, поиск DLL прозрачно делегируется &lt;code&gt;DynaLoader&lt;/code&gt; , который ищет DLL в списке &lt;code&gt;@INC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a76f398b95d1961552e49490d4d377316e986e8" translate="yes" xml:space="preserve">
          <source>To reduce the overhead as much as possible, only one possible location is checked to find the extension DLL (this location is where &lt;code&gt;make install&lt;/code&gt; would put the DLL). If not found, the search for the DLL is transparently delegated to &lt;code&gt;DynaLoader&lt;/code&gt;, which looks for the DLL along the &lt;code&gt;@INC&lt;/code&gt; list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c3094c723d121eb0bf078e8289c66d4fdd4a9a" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;a href=&quot;File::Path#rmtree%28-%24dir-%29&quot;&gt;&lt;code&gt;rmtree&lt;/code&gt;&lt;/a&gt; function of the &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bed95392f2bd5c21b8012e731bec1f2530889e" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;../file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы удалить дерево каталогов рекурсивно ( &lt;code&gt;rm -rf&lt;/code&gt; в Unix), посмотрите на функцию &lt;code&gt;rmtree&lt;/code&gt; модуля &lt;a href=&quot;../file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5b819764f7105a80a7d510f2a867ba675bddec" translate="yes" xml:space="preserve">
          <source>To remove a directory tree recursively (&lt;code&gt;rm -rf&lt;/code&gt; on Unix) look at the &lt;code&gt;rmtree&lt;/code&gt; function of the &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module.</source>
          <target state="translated">Чтобы удалить дерево каталогов рекурсивно ( &lt;code&gt;rm -rf&lt;/code&gt; в Unix), посмотрите на функцию &lt;code&gt;rmtree&lt;/code&gt; модуля &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e56141f1ebe96f14282b26d571378c274b2244ed" translate="yes" xml:space="preserve">
          <source>To remove a tied environment variable from the environment, assign it the undefined value</source>
          <target state="translated">Для удаления связанной переменной окружения из окружения присвойте ей неопределённое значение</target>
        </trans-unit>
        <trans-unit id="06b0ac63c637336d9c539fb315b8373179470836" translate="yes" xml:space="preserve">
          <source>To remove creation of the tied hash on each access, one may an extra level of indirection which allows a non-circular structure of references:</source>
          <target state="translated">Для удаления создания привязанного хэша на каждом доступе может быть установлен дополнительный уровень индеррекции,позволяющий создать нециркулярную структуру ссылок:</target>
        </trans-unit>
        <trans-unit id="385dafb73da7d1789642356fd78d8d3446310a3d" translate="yes" xml:space="preserve">
          <source>To remove the magic from an SV, call the function sv_unmagic:</source>
          <target state="translated">Чтобы удалить магию из SV,вызовите функцию sv_unmagic:</target>
        </trans-unit>
        <trans-unit id="1244516061f404f040587b4bb0bc9e4acce762e7" translate="yes" xml:space="preserve">
          <source>To replace any of these components I call one of these harness methods with the name of the replacement class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee81225f636096e269a365626b3e0c2212110758" translate="yes" xml:space="preserve">
          <source>To report a new bug, visit:</source>
          <target state="translated">Чтобы сообщить о новой ошибке,посетите:</target>
        </trans-unit>
        <trans-unit id="e2d5ab4989d41c738d1504f8f7e7186c29958e2b" translate="yes" xml:space="preserve">
          <source>To reset your working directory to a pristine condition you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935323786b12419a7345fc07129055605bd12b91" translate="yes" xml:space="preserve">
          <source>To retrieve data stored to disk, use &lt;code&gt;retrieve&lt;/code&gt; with a file name. The objects stored into that file are recreated into memory for you, and a</source>
          <target state="translated">Для извлечения данных, хранящихся на диске, используйте &lt;code&gt;retrieve&lt;/code&gt; с именем файла. Объекты, хранящиеся в этом файле, воссоздаются в памяти для вас, и</target>
        </trans-unit>
        <trans-unit id="7f6b972558cf783871ca862e09f183ae72cbdc43" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;&quot;REGEXP Functions&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f95fbea27e1a9b8ba09786147eb856c1d1f83f4" translate="yes" xml:space="preserve">
          <source>To retrieve the &lt;code&gt;REGEXP&lt;/code&gt; object from the scalar in an XS function use the &lt;code&gt;SvRX&lt;/code&gt; macro, see &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;REGEXP Functions in perlapi&lt;/a&gt;.</source>
          <target state="translated">Чтобы получить объект &lt;code&gt;REGEXP&lt;/code&gt; из скаляра в функции XS, используйте макрос &lt;code&gt;SvRX&lt;/code&gt; , см. &lt;a href=&quot;perlapi#REGEXP-Functions&quot;&gt;Функции REGEXP в perlapi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1231633ff6452d875f890a43a2ae8ede0790e949" translate="yes" xml:space="preserve">
          <source>To return an empty list one must use a PPCODE: block and then not push return values on the stack.</source>
          <target state="translated">Для возврата пустого списка необходимо использовать PPCODE:блок,а затем не нажимать на возвращаемые значения в стеке.</target>
        </trans-unit>
        <trans-unit id="c0fa2ebc492606f9abfba27c95d0995af195e45c" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;&quot;Other OSes&quot;&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52a15c8b572dc0999ddd7a3d452b4f9cfbf130a" translate="yes" xml:space="preserve">
          <source>To run Perl on DPMI platforms one needs RSX runtime. This is needed under DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT (see &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;). RSX would not work with VCPI only, as EMX would, it requires DMPI.</source>
          <target state="translated">Для запуска Perl на платформах DPMI требуется среда выполнения RSX. Это необходимо в DOS-inside-OS / 2, Win0.3 *, Win0.95 и WinNT (см. &lt;a href=&quot;#Other-OSes&quot;&gt;Другие ОС&lt;/a&gt; ). RSX не будет работать только с VCPI, как EMX, он требует DMPI.</target>
        </trans-unit>
        <trans-unit id="f4988afc10b11011c01fd1dc8e2d9efa2ca35527" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="translated">Для запуска &lt;b&gt;программы&lt;/b&gt; или &lt;b&gt;подпрограммы&lt;/b&gt; . (Не имеет ничего общего со встроенным &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; , если вы не пытаетесь запустить &lt;b&gt;обработчик сигнала&lt;/b&gt; .)</target>
        </trans-unit>
        <trans-unit id="97a854ddf9aaf9c69e7b95eed2386df587b2d5c0" translate="yes" xml:space="preserve">
          <source>To run a &lt;b&gt;program&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt;. (Has nothing to do with the &lt;code&gt;kill&lt;/code&gt; built-in, unless you&amp;rsquo;re trying to run a &lt;b&gt;signal handler&lt;/b&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf4ac8bbb41685c2ce7804ccdb1791a6e3ce985" translate="yes" xml:space="preserve">
          <source>To run a Perl program from the Unix command line:</source>
          <target state="translated">Для запуска программы на Perl из командной строки Unix:</target>
        </trans-unit>
        <trans-unit id="69d193d311b7fdb3c43e19bb64a6bebcfed27d39" translate="yes" xml:space="preserve">
          <source>To run this code, &lt;code&gt;perl_run&lt;/code&gt; is called, which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; then enters a runops loop. This loop executes the eval and tie ops on line 1, with the eval pushing a &lt;code&gt;CxEVAL&lt;/code&gt; onto the context stack.</source>
          <target state="translated">Для запуска этого кода &lt;code&gt;perl_run&lt;/code&gt; , который выполняет &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ,а затем входит в цикл runops. Этот цикл выполняет eval и связующие операции в строке 1, при этом eval &lt;code&gt;CxEVAL&lt;/code&gt; в стек контекста.</target>
        </trans-unit>
        <trans-unit id="46ec5458708076d609a6883cd1bd780e161cc64e" translate="yes" xml:space="preserve">
          <source>To say the least, surrogate pairs were the biggest mistake of the Unicode Consortium. But according to the late Douglas Adams in</source>
          <target state="translated">По крайней мере,суррогатные пары были самой большой ошибкой консорциума &quot;Юникод&quot;.Но по словам покойного Дугласа Адамса.</target>
        </trans-unit>
        <trans-unit id="48af12ca119bf709d476507ec2e3aea7bdcd0d97" translate="yes" xml:space="preserve">
          <source>To search the perlfaq question headings:</source>
          <target state="translated">Для поиска по заголовкам вопросов perlfaq:</target>
        </trans-unit>
        <trans-unit id="518862144f077b9ba7e98c4f411c046f6e96affb" translate="yes" xml:space="preserve">
          <source>To see all about your machine, type</source>
          <target state="translated">Чтобы увидеть все о вашей машине,введите</target>
        </trans-unit>
        <trans-unit id="5d0d28f6946dedb31c299d2d78aa9802594a8195" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="translated">Чтобы увидеть, как работает (раз) упаковка, мы начнем с простого кода шаблона, в котором преобразование происходит на низком уровне: между содержимым последовательности байтов и строкой шестнадцатеричных цифр. Давайте использовать &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , так как это может напомнить вам о программе дампа или о каком-то отчаянном последнем сообщении, которое неудачные программы обычно бросают вам, прежде чем они исчезнут в дикой синеве. Предполагая, что переменная &lt;code&gt;$mem&lt;/code&gt; содержит последовательность байтов, которую мы хотели бы проверить, не предполагая ничего о ее значении, мы можем написать</target>
        </trans-unit>
        <trans-unit id="02e337f8ffa5587c60ddae1e61c27bc0cb20b9a1" translate="yes" xml:space="preserve">
          <source>To see how (un)packing works, we'll start with a simple template code where the conversion is in low gear: between the contents of a byte sequence and a string of hexadecimal digits. Let's use &lt;code&gt;unpack&lt;/code&gt;, since this is likely to remind you of a dump program, or some desperate last message unfortunate programs are wont to throw at you before they expire into the wild blue yonder. Assuming that the variable &lt;code&gt;$mem&lt;/code&gt; holds a sequence of bytes that we'd like to inspect without assuming anything about its meaning, we can write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526ccfeab3729429cc060187cce1bbaba5ac3037" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="translated">Чтобы увидеть, как это влияет на &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; , мы сравним эти две структуры C:</target>
        </trans-unit>
        <trans-unit id="9053b5511eec27497eeb92618a57db0e9ef4499d" translate="yes" xml:space="preserve">
          <source>To see how this affects &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt;, we'll compare these two C structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c245de21e3816d09a578f5e1c5f63c7d4c6210" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;a href=&quot;perlfunc#ref-EXPR&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fa402c0f19d397a266c609792e7a721baa908f" translate="yes" xml:space="preserve">
          <source>To see if a variable contains a reference, use the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function. It returns true if its argument is a reference. Actually it's a little better than that: It returns &lt;code&gt;HASH&lt;/code&gt; for hash references and &lt;code&gt;ARRAY&lt;/code&gt; for array references.</source>
          <target state="translated">Чтобы узнать, содержит ли переменная ссылку, используйте функцию &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; . Он возвращает истину, если его аргумент является ссылкой. На самом деле это немного лучше: он возвращает &lt;code&gt;HASH&lt;/code&gt; для ссылок на хеш и &lt;code&gt;ARRAY&lt;/code&gt; для ссылок на массив.</target>
        </trans-unit>
        <trans-unit id="960bf2c563408fba71fe24086af2e53cbf0767bd" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="translated">Чтобы узнать, влияет ли это несоответствие на вашу систему, проверьте, если &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | &lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt; -q NPTL&lt;/code&gt; возвращает ложное значение. Потоки NTPL сохраняют семантику POSIX.</target>
        </trans-unit>
        <trans-unit id="6370b1130305216b6c4037876a31e89ca9fbcd86" translate="yes" xml:space="preserve">
          <source>To see if your system is affected by this discrepancy check if &lt;code&gt;getconf GNU_LIBPTHREAD_VERSION | grep -q NPTL&lt;/code&gt; returns a false value. NTPL threads preserve the POSIX semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d211374e5db97da1828e5f0a6f84c0b749ec44e8" translate="yes" xml:space="preserve">
          <source>To see it in action, add a method</source>
          <target state="translated">Чтобы увидеть это в действии,добавьте метод</target>
        </trans-unit>
        <trans-unit id="fddb2e3b0651d7cee6f1eddfc0db7c585ec33e9f" translate="yes" xml:space="preserve">
          <source>To see the output of specific failing tests run the harness from the t directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8654d4f5f9129c9cab32750ab5566521abf2dc" translate="yes" xml:space="preserve">
          <source>To see what a state description looks like, just run the following:</source>
          <target state="translated">Чтобы увидеть,как выглядит описание состояния,просто запустите следующее:</target>
        </trans-unit>
        <trans-unit id="1afd16a9742f3bb00f5d52a4bea0944a04f89bb4" translate="yes" xml:space="preserve">
          <source>To see what is installed on your system:</source>
          <target state="translated">Чтобы увидеть,что установлено в вашей системе:</target>
        </trans-unit>
        <trans-unit id="759c7cca5357567d905de52c1b1b6b667aaa23a6" translate="yes" xml:space="preserve">
          <source>To see what version is included on the DVD (assumed here to be mounted on /cdrom), issue this command:</source>
          <target state="translated">Чтобы посмотреть,какая версия включена в DVD (предполагается,что она будет смонтирована на /cdrom),выпустите эту команду:</target>
        </trans-unit>
        <trans-unit id="7ad61eadcf1dbdb7c99f44756b97def548456147" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt; :</source>
          <target state="translated">Чтобы узнать, есть ли у вас неконстантные данные, вы можете использовать совместимый с BSD (или GNU) &lt;code&gt;nm&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1349f12e189a41ade68fc4f2a3b99132d4421e66" translate="yes" xml:space="preserve">
          <source>To see whether you have non-const data you can use a BSD (or GNU) compatible &lt;code&gt;nm&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceecb8953e41093c57b8581763c4bd993092c9bf" translate="yes" xml:space="preserve">
          <source>To see why this is a problem, consider what can happen when two processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same &lt;b&gt;DB_File&lt;/b&gt; database using the locking steps outlined above. Assume process &quot;A&quot; has already opened the database and has a write lock, but it hasn't actually updated the database yet (it has finished step 2, but not started step 3 yet). Now process &quot;B&quot; tries to open the same database - step 1 will succeed, but it will block on step 2 until process &quot;A&quot; releases the lock. The important thing to notice here is that at this point in time both processes will have cached identical initial blocks from the database.</source>
          <target state="translated">Чтобы понять, почему это проблема, подумайте, что может произойти, когда два процесса, скажем &amp;laquo;A&amp;raquo; и &amp;laquo;B&amp;raquo;, оба захотят обновить одну и &lt;b&gt;ту&lt;/b&gt; же &lt;b&gt;базу&lt;/b&gt; данных &lt;b&gt;DB_File,&lt;/b&gt; используя шаги блокировки, описанные выше. Предположим, что процесс &amp;laquo;A&amp;raquo; уже открыл базу данных и имеет блокировку записи, но на самом деле он еще не обновил базу данных (он завершил шаг 2, но еще не начал шаг 3). Теперь процесс &amp;laquo;B&amp;raquo; пытается открыть ту же базу данных - шаг 1 будет успешным, но он будет блокироваться на шаге 2, пока процесс &amp;laquo;A&amp;raquo; не снимет блокировку. Здесь важно отметить, что в этот момент оба процесса будут кэшировать идентичные начальные блоки из базы данных.</target>
        </trans-unit>
        <trans-unit id="887591ebb547202a2fbb02bece1d9984e9bcdec7" translate="yes" xml:space="preserve">
          <source>To see why, notice how you'll still have an issue on half-way-point alternation:</source>
          <target state="translated">Чтобы понять,почему,обратите внимание,что у вас все еще будет проблема с чередованием точек на полпути:</target>
        </trans-unit>
        <trans-unit id="0cddf3be7ebfd9389288691711afdcfed8edf9c1" translate="yes" xml:space="preserve">
          <source>To send a &lt;b&gt;datagram&lt;/b&gt; to multiple destinations simultaneously.</source>
          <target state="translated">Для одновременной отправки &lt;b&gt;дейтаграммы&lt;/b&gt; нескольким получателям.</target>
        </trans-unit>
        <trans-unit id="8617ca70598e41eabf7c915af7a92af825a55fcd" translate="yes" xml:space="preserve">
          <source>To send something to its correct destination. Often used metaphorically to indicate a transfer of programmatic control to a destination selected algorithmically, often by lookup in a table of function &lt;b&gt;references&lt;/b&gt; or, in the case of object &lt;b&gt;methods&lt;/b&gt;, by traversing the inheritance tree looking for the most specific definition for the method.</source>
          <target state="translated">Чтобы отправить что-то по назначению. Часто используется метафорически для обозначения передачи программного управления адресату, выбранному алгоритмически, часто путем поиска в таблице &lt;b&gt;ссылок&lt;/b&gt; на функции или, в случае объектных &lt;b&gt;методов&lt;/b&gt; , путем обхода дерева наследования в поисках наиболее конкретного определения метода.</target>
        </trans-unit>
        <trans-unit id="67e016f9948cc1473ec98e12bd274f9eaa7682bd" translate="yes" xml:space="preserve">
          <source>To set the state of a pragma:</source>
          <target state="translated">Чтобы установить состояние прагмы:</target>
        </trans-unit>
        <trans-unit id="4d0f638abe1cc26ab6bbeb03cebb08b40820c287" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</source>
          <target state="translated">Чтобы установить личное значение, вызовите &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16aae45044289a718089765d242152d067d315d5" translate="yes" xml:space="preserve">
          <source>To set your private value, call &lt;code&gt;Perl_mro_set_private_data()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b42d6c90a6c04419bddc3aa56e776f03e6d4b1" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt; .</source>
          <target state="translated">Чтобы отключить его генерацию, &lt;code&gt;NO_META&lt;/code&gt; флаг &lt;code&gt;WriteMakefile()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eacb74b08b83ca5e29c7e01a124f0c6492dc5d47" translate="yes" xml:space="preserve">
          <source>To shut off its generation, pass the &lt;code&gt;NO_META&lt;/code&gt; flag to &lt;code&gt;WriteMakefile()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cf8244407c213f6cbced635b585a8f402b31ff" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">Чтобы сигнализировать семафор, замените &lt;code&gt;-1&lt;/code&gt; на &lt;code&gt;1&lt;/code&gt; . См. Также документацию &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d782cb39a280e66911e6595a3826686b674e633e" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; . See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , and &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">Чтобы сигнализировать семафор, замените &lt;code&gt;-1&lt;/code&gt; на &lt;code&gt;1&lt;/code&gt; . См. Также документацию &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC в perlipc&lt;/a&gt; , &lt;code&gt;IPC::SysV&lt;/code&gt; и &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49cc3c1b8c165959fade8c0cdac2c114f0c70649" translate="yes" xml:space="preserve">
          <source>To signal the semaphore, replace &lt;code&gt;-1&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt;. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;&quot;SysV IPC&quot; in perlipc&lt;/a&gt; and the documentation for &lt;a href=&quot;IPC::SysV&quot;&gt;&lt;code&gt;IPC::SysV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;IPC::Semaphore&quot;&gt;&lt;code&gt;IPC::Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e199b8e074ec6e1896ea95f9bad604e453a779" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="translated">Чтобы сообщить Perl, что HMQ больше не нужен, вызовите &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt; . Процесс Perl автоматически трансформируется / реформируется в / из процесса PM, если HMQ нужен / не нужен. Perl автоматически включает / отключает сообщение &lt;code&gt;WM_QUIT&lt;/code&gt; во время выключения, если очередь сообщений обслуживается / не обслуживается.</target>
        </trans-unit>
        <trans-unit id="76395c3ce12a1fd4356ad20f5dad8a9f32df5165" translate="yes" xml:space="preserve">
          <source>To signal to Perl that HMQ is not needed any more, call &lt;code&gt;perl_hmq_UNSET(serve)&lt;/code&gt;. Perl process will automatically morph/unmorph itself into/from a PM process if HMQ is needed/not-needed. Perl will automatically enable/disable &lt;code&gt;WM_QUIT&lt;/code&gt; message during shutdown if the message queue is served/not-served.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3868e3b616a54cb1bab8634fd841ed657adc2c50" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt; ) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Subroutine Attributes in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="translated">Чтобы молча интерпретировать его как оператор Perl, используйте префикс &lt;code&gt;CORE::&lt;/code&gt; в операторе (например, &lt;code&gt;CORE::log($x)&lt;/code&gt; ) или объявите подпрограмму как объектный метод (см. &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;Атрибуты подпрограммы в perlsub&lt;/a&gt; или &lt;a href=&quot;attributes&quot;&gt;атрибуты&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="77f74a1e8ed985d91bce77589cc0e8ad84a337cc" translate="yes" xml:space="preserve">
          <source>To silently interpret it as the Perl operator, use the &lt;code&gt;CORE::&lt;/code&gt; prefix on the operator (e.g. &lt;code&gt;CORE::log($x)&lt;/code&gt;) or declare the subroutine to be an object method (see &lt;a href=&quot;perlsub#Subroutine-Attributes&quot;&gt;&quot;Subroutine Attributes&quot; in perlsub&lt;/a&gt; or &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea26257b4903cfdcc4f9b51c3c53cf94dc5f1003" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &quot;.&quot; character never matches a newline unless you use the &lt;code&gt;/s&lt;/code&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="translated">Чтобы упростить многострочные замены, символ &quot;.&quot; символ никогда не соответствует новой строке, если вы не используете модификатор &lt;code&gt;/s&lt;/code&gt; , который, по сути, сообщает Perl, что строка представляет собой единственную строку, даже если это не так.</target>
        </trans-unit>
        <trans-unit id="8a2c6b3c9e2b9a0960e93d5d6acb36d8aa948a45" translate="yes" xml:space="preserve">
          <source>To simplify multi-line substitutions, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; character never matches a newline unless you use the &lt;a href=&quot;#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt;&lt;/a&gt; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcc0c984ac1c1f3aa01cd10ae020a1e23d2e144" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; .</source>
          <target state="translated">Чтобы пропустить строки, используйте элементы управления зацикливанием. &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; в этом примере Пропускает строку комментариев, и &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; останавливает всю обработку , когда он встречает либо &lt;code&gt;__END__&lt;/code&gt; или &lt;code&gt;__DATA__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa5fe915c274707436eefaadbe2f71ad0bad5d61" translate="yes" xml:space="preserve">
          <source>To skip lines, use the looping controls. The &lt;code&gt;next&lt;/code&gt; in this example skips comment lines, and the &lt;code&gt;last&lt;/code&gt; stops all processing once it encounters either &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb7cc3fb6917e0db56d0ceef1f6b092afc65ddb" translate="yes" xml:space="preserve">
          <source>To solve this, you must manually use pipe(), fork(), and the form of open() which sets one file descriptor to another, as shown below:</source>
          <target state="translated">Для решения этой проблемы вы должны вручную использовать функции pipe(),fork()и форму open(),которая устанавливает дескриптор одного файла в другой,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="4f249829a932dbf9b88abd3f71ccd6d576666559" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f205d5425879968b7952a3fb61c2ff97a391a194" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">Чтобы отсортировать хэш по значению, вам понадобится функция &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Вот числовой вид хеша по убыванию по его значениям:</target>
        </trans-unit>
        <trans-unit id="e22346e7b0a650eb196d705609c50726a647e816" translate="yes" xml:space="preserve">
          <source>To sort a hash by value, you'll need to use a &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function. Here's a descending numeric sort of a hash by its values:</source>
          <target state="translated">Чтобы отсортировать хэш по значению, вам понадобится функция &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Вот числовой вид хеша по убыванию по его значениям:</target>
        </trans-unit>
        <trans-unit id="035b2f73f3e8b156397dc2189e758b10b01a049f" translate="yes" xml:space="preserve">
          <source>To sort a hash, start with the keys. In this example, we give the list of keys to the sort function which then compares them ASCIIbetically (which might be affected by your locale settings). The output list has the keys in ASCIIbetical order. Once we have the keys, we can go through them to create a report which lists the keys in ASCIIbetical order.</source>
          <target state="translated">Чтобы отсортировать хэш,начни с клавиш.В этом примере мы предоставляем список ключей функции сортировки,которая затем сравнивает их ASCIIbetically (на которые могут повлиять настройки вашей локали).В списке вывода ключи находятся в ASCIIbetical порядке.После того,как у нас есть ключи,мы можем просмотреть их и создать отчёт,который перечислит ключи в ASCIIbetical порядке.</target>
        </trans-unit>
        <trans-unit id="bd567593644cab945269478fa56978a3d2bc8799" translate="yes" xml:space="preserve">
          <source>To specify a character by Unicode code point, use the form &lt;code&gt;\N{U+&lt;i&gt;code
point&lt;/i&gt;}&lt;/code&gt;, where</source>
          <target state="translated">Чтобы указать символ по кодовой точке Unicode, используйте форму &lt;code&gt;\N{U+&lt;i&gt;code point&lt;/i&gt;}&lt;/code&gt; , где</target>
        </trans-unit>
        <trans-unit id="97bdead994a8b1301604dc655e33bb83cb6a1547" translate="yes" xml:space="preserve">
          <source>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</source>
          <target state="translated">Чтобы указать уровень сжатия при записи,добавьте цифру между 0 и 9 в строку режима --0 означает отсутствие сжатия,а 9-максимальное сжатие.Если уровень сжатия не указан,используется Z_DEFAULT_COMPRESSION.</target>
        </trans-unit>
        <trans-unit id="679c6d53c6265b7e7972b50aa21c407989720f3b" translate="yes" xml:space="preserve">
          <source>To specify a literal SPACE character, you can escape it with a backslash, like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edce8429b2a3fa7edc3e49d4ca87a0b2294c60e2" translate="yes" xml:space="preserve">
          <source>To specify a particular stack size for any individual thread, call &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">Чтобы указать конкретный размер стека для любого отдельного потока, вызовите &lt;code&gt;-&amp;gt;create()&lt;/code&gt; с хеш-ссылкой в ​​качестве первого аргумента:</target>
        </trans-unit>
        <trans-unit id="5a3b28c1d56d62a0c685010a78c8616b6f249aaf" translate="yes" xml:space="preserve">
          <source>To specify a real-time timeout, supply the &lt;code&gt;LIFETIME&lt;/code&gt; option with a numeric value. Cached data will expire after this many seconds, and will be looked up afresh when it expires. When a data item is looked up afresh, its lifetime is reset.</source>
          <target state="translated">Чтобы указать тайм-аут в реальном времени, укажите для параметра &lt;code&gt;LIFETIME&lt;/code&gt; числовое значение. Срок действия кэшированных данных истечет по истечении этого количества секунд, и по истечении этого срока они будут просматриваться заново. Когда элемент данных просматривается заново, его время жизни сбрасывается.</target>
        </trans-unit>
        <trans-unit id="75872cec7b7dae2ec30afbe5f15f62f2ed47906e" translate="yes" xml:space="preserve">
          <source>To specify by name, the name of the character or character sequence goes between the curly braces.</source>
          <target state="translated">Для указания по имени имя символа или последовательность символов проходит между фигурными скобками.</target>
        </trans-unit>
        <trans-unit id="dde9b4df6bfb5d9f21839e498fe1e3acf75a91a1" translate="yes" xml:space="preserve">
          <source>To specify how numbers are formatted when printed, one is advised to use &lt;code&gt;printf&lt;/code&gt; or &lt;code&gt;sprintf&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22be0e52c335b1ce8908cd9371ba0e4b96e3022" translate="yes" xml:space="preserve">
          <source>To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</source>
          <target state="translated">Чтобы указать стратегию сжатия при записи,добавьте 'f' для отфильтрованных данных,'h' для сжатия только Huffman,или 'R' для кодирования длины выполнения.Если стратегия не указана,то используется Z_DEFAULT_STRATEGY.</target>
        </trans-unit>
        <trans-unit id="cb8a391550e8914db81270f773f4523451df8b90" translate="yes" xml:space="preserve">
          <source>To speed things up in complex installation scenarios, CPAN.pm keeps track of what it has already done and refuses to do some things a second time. A &lt;code&gt;get&lt;/code&gt; , a &lt;code&gt;make&lt;/code&gt; , and an &lt;code&gt;install&lt;/code&gt; are not repeated. A &lt;code&gt;test&lt;/code&gt; is repeated only if the previous test was unsuccessful. The diagnostic message when CPAN.pm refuses to do something a second time is one of</source>
          <target state="translated">Чтобы ускорить процесс в сложных сценариях установки, CPAN.pm отслеживает, что уже было сделано, и отказывается делать некоторые вещи во второй раз. &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , и &lt;code&gt;install&lt;/code&gt; не повторяются. &lt;code&gt;test&lt;/code&gt; повторяется , только если предыдущий тест был неудачным. Диагностическое сообщение, когда CPAN.pm отказывается делать что-либо во второй раз, является одним из</target>
        </trans-unit>
        <trans-unit id="ee745e8e1ccd43545cce5d6e1098128c6d2cb42b" translate="yes" xml:space="preserve">
          <source>To split a string automatically, as the</source>
          <target state="translated">Чтобы разделить строку автоматически,как</target>
        </trans-unit>
        <trans-unit id="1c43b020de2fd47f4f4fe689a93a4f681f980968" translate="yes" xml:space="preserve">
          <source>To start exploring some of the features of Test::Harness I need to switch from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a587334bce3d780e4ef5607b4eb7989a44b338" translate="yes" xml:space="preserve">
          <source>To start external programs with complicated command lines (like with pipes in between, and/or quoting of arguments), Perl uses an external shell. With EMX port such shell should be named</source>
          <target state="translated">Для запуска внешних программ со сложными командными строками (например,с трубками между ними и/или цитированием аргументов)Perl использует внешнюю оболочку.При использовании EMX-порта такая оболочка должна иметь имя</target>
        </trans-unit>
        <trans-unit id="4496b7043de2731c625ff5d9cbb9bfec5778dc82" translate="yes" xml:space="preserve">
          <source>To start perl by clicking on a perl source file, you have to make the according entries in HKCR (see</source>
          <target state="translated">Чтобы запустить perl,щелкнув по файлу с исходным кодом perl,вы должны сделать соответствующие записи в HKCR (смотрите раздел</target>
        </trans-unit>
        <trans-unit id="ed415ca8982026bad9b823bf326a650e9d0848ae" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; &amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="translated">Чтобы вычесть значение из переменной, например, &amp;laquo;уменьшить &lt;code&gt;$x&lt;/code&gt; &amp;raquo; (то есть удалить 1 из его значения) или &amp;laquo;уменьшить &lt;code&gt;$x&lt;/code&gt; на 3&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b3834a44244c88392770a12aebccbba7a107bc50" translate="yes" xml:space="preserve">
          <source>To subtract a value from a variable, as in &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt;&amp;rdquo; (meaning to remove 1 from its value) or &amp;ldquo;decrement &lt;code&gt;$x&lt;/code&gt; by 3&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34bd44153421ecb4ee7a84a5cf2f9e94314d16d" translate="yes" xml:space="preserve">
          <source>To summarise:</source>
          <target state="translated">Подводя итог:</target>
        </trans-unit>
        <trans-unit id="1ec17769e0302f168a8a4f3337a21d3e87e35b66" translate="yes" xml:space="preserve">
          <source>To summarize,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdefe539f6f30e5536e03e0dcfcbf06113e55e75" translate="yes" xml:space="preserve">
          <source>To summarize, here are a number of possible methods for you to consider for storing the mapping between C and the Perl callback</source>
          <target state="translated">Подводя итог,вот несколько возможных методов,которые вы можете рассмотреть для хранения отображения между C и обратным вызовом на Perl</target>
        </trans-unit>
        <trans-unit id="87770a145a86a8f01c504f30ba378126d36ae639" translate="yes" xml:space="preserve">
          <source>To summarize, here's what to expect and how to handle locales in XS code:</source>
          <target state="translated">Подводя итог,скажу,чего ожидать и как работать с локалями в коде XS:</target>
        </trans-unit>
        <trans-unit id="9eda1d19cb3d66414653545444049318272d3717" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;\o{}&lt;/code&gt; form is always safe to use, and the other form is safe to use for code points through \077 when you use exactly three digits to specify them.</source>
          <target state="translated">Подводя итог, можно сказать, что форма &lt;code&gt;\o{}&lt;/code&gt; всегда безопасна в использовании, а другая форма безопасна для использования для кодовых точек до \ 077, когда вы используете ровно три цифры для их указания.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
