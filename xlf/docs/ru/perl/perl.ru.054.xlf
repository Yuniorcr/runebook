<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="944edb7108bfdb534265951ea7b5a33f9f4b73e0" translate="yes" xml:space="preserve">
          <source>Share =&amp;gt; $uShare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bf62db0a202cfe8b527778be027079163e0d35" translate="yes" xml:space="preserve">
          <source>Share what you did with the other people. Relax. Enjoy fruits of your work.</source>
          <target state="translated">Поделитесь тем,что вы сделали с другими людьми.Расслабься.Наслаждайся плодами своей работы.</target>
        </trans-unit>
        <trans-unit id="df3c637adb69abac13b29419d0cfa8b766ae4adc" translate="yes" xml:space="preserve">
          <source>Shared And Unshared Data</source>
          <target state="translated">Общие и неохраняемые данные</target>
        </trans-unit>
        <trans-unit id="2ad8427c8c9758999d3e74a7bdd5fb7162a57750" translate="yes" xml:space="preserve">
          <source>Shared libraries created on a platform using a particular PA-RISC version are not usable on platforms using an earlier PA-RISC version by default. However, this backwards compatibility may be enabled using the same +DAportable compiler flag (with the same PA-RISC 1.0 caveat mentioned above).</source>
          <target state="translated">Общие библиотеки,созданные на платформе с использованием определенной версии PA-RISC,по умолчанию не могут быть использованы на платформах,использующих более раннюю версию PA-RISC.Однако эта обратная совместимость может быть включена с помощью того же флага компилятора +DAportable (с тем же самым предостережением PA-RISC 1.0,упомянутым выше).</target>
        </trans-unit>
        <trans-unit id="193a001ab941319380e15850d6f5c791732088df" translate="yes" xml:space="preserve">
          <source>Shared libraries created on an Itanium platform cannot be loaded on a PA-RISC platform. Shared libraries created on a PA-RISC platform can only be loaded on an Itanium platform if it is a PA-RISC executable that is attempting to load the PA-RISC library. A PA-RISC shared library cannot be loaded into an Itanium executable nor vice-versa.</source>
          <target state="translated">Общие библиотеки,созданные на платформе Itanium,не могут быть загружены на платформе PA-RISC.Общие библиотеки,созданные на платформе PA-RISC,могут быть загружены на Itanium-платформу только в том случае,если это исполняемый файл PA-RISC,который пытается загрузить библиотеку PA-RISC.Общая библиотека PA-RISC не может быть загружена в исполняемый файл Itanium или наоборот.</target>
        </trans-unit>
        <trans-unit id="6953ee78fc5edeec2d6a50098821da893b0458f7" translate="yes" xml:space="preserve">
          <source>Shared references among objects will not stay shared: if we're serializing the list of object [A, C] where both object A and C refer to the SAME object B, and if there is a serializing hook in A that says freeze(B), then when deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D, a deep clone of B'. The topology was not preserved.</source>
          <target state="translated">Общие ссылки между объектами не останутся общими:если мы сериализуем список объектов [A,C],где оба объекта A и C ссылаются на SAME объект B,и если в A есть сериализующий крюк с надписью freeze(B),то при десериализации мы получим [A',C'],где A' ссылается на B',а C' ссылается на D,глубокий клон B'.Топология не сохранилась.</target>
        </trans-unit>
        <trans-unit id="f728eba8dfb3236f1667f74466840c95e5a7b8ee" translate="yes" xml:space="preserve">
          <source>Shared variables can only store scalars, refs of shared variables, or refs of shared data (discussed in next section):</source>
          <target state="translated">Общие переменные могут хранить только скаляры,ссылки на общие переменные или ссылки на общие данные (обсуждается в следующем разделе):</target>
        </trans-unit>
        <trans-unit id="001c163e34c30bd422c6c0b180836b52f1afdb17" translate="yes" xml:space="preserve">
          <source>Sharing Databases With C Applications</source>
          <target state="translated">Совместное использование баз данных с приложениями на C</target>
        </trans-unit>
        <trans-unit id="bd8715c47f235864c2ceb04d785a7b7ec14fa56b" translate="yes" xml:space="preserve">
          <source>Sharing typemaps Between CPAN Distributions</source>
          <target state="translated">Совместное использование типовых карт между распределениями CPAN</target>
        </trans-unit>
        <trans-unit id="0a07afc00eaa14a561ef50fb9dc88822e22b041a" translate="yes" xml:space="preserve">
          <source>Sharp shell programmers should take note of the following:</source>
          <target state="translated">Остроумные программисты оболочки должны обратить внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="f78065b15d0af880ad317e4f961cef2d5893c97c" translate="yes" xml:space="preserve">
          <source>Shawn H Corey &lt;code&gt;SHCOREY at cpan.org&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa79f294b4ff3f2bd0e6980c0d9d3429325e3b2" translate="yes" xml:space="preserve">
          <source>Shawn M Moore &lt;code&gt;sartak@gmail.com&lt;/code&gt;</source>
          <target state="translated">Шон М Мур &lt;code&gt;sartak@gmail.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14cc09b3426b2766b9650c676895c8481a40916" translate="yes" xml:space="preserve">
          <source>Shebang Race Condition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc1fd5d3c0f3dcfd55d010426e61bf9451e680d" translate="yes" xml:space="preserve">
          <source>Shell</source>
          <target state="translated">Shell</target>
        </trans-unit>
        <trans-unit id="46f2fc676064cd202c006928e29b43973667f22c" translate="yes" xml:space="preserve">
          <source>Shell Traps</source>
          <target state="translated">Шелл-лавливатели</target>
        </trans-unit>
        <trans-unit id="05e1aa29dff23edb2a5976ffe3e3f5926084ec96" translate="yes" xml:space="preserve">
          <source>Shell escapes newlines in $text.</source>
          <target state="translated">Шелл сбегает с новостей в текстовом виде.</target>
        </trans-unit>
        <trans-unit id="411430d5faea18a48223083d430d03ec02723be9" translate="yes" xml:space="preserve">
          <source>Shell mode</source>
          <target state="translated">режим оболочки</target>
        </trans-unit>
        <trans-unit id="ae8110256e73e2d29bfd2b0361c6084818dcf5fb" translate="yes" xml:space="preserve">
          <source>Shell variables from the</source>
          <target state="translated">Переменные оболочки из</target>
        </trans-unit>
        <trans-unit id="a5efec93b7817b727267bf3e97356065022021aa" translate="yes" xml:space="preserve">
          <source>Shell::Command which is these same functions but take arguments normally.</source>
          <target state="translated">Shell::Команда,которая выполняет те же функции,но нормально принимает аргументы.</target>
        </trans-unit>
        <trans-unit id="5597033de9e3a9ee3ab28b086225929f8384f842" translate="yes" xml:space="preserve">
          <source>Shells (especially &lt;b&gt;csh&lt;/b&gt;) do several levels of substitution on each command line. Perl does substitution in only certain constructs such as double quotes, backticks, angle brackets, and search patterns.</source>
          <target state="translated">Оболочки (особенно &lt;b&gt;csh&lt;/b&gt; ) выполняют несколько уровней подстановки в каждой командной строке. Perl выполняет подстановку только в определенных конструкциях, таких как двойные кавычки, обратные кавычки, угловые скобки и шаблоны поиска.</target>
        </trans-unit>
        <trans-unit id="c3085316e59739c3d0881dec21da7ebe8e1387d1" translate="yes" xml:space="preserve">
          <source>Shells interpret scripts a little bit at a time. Perl compiles the entire program before executing it (except for &lt;code&gt;BEGIN&lt;/code&gt; blocks, which execute at compile time).</source>
          <target state="translated">Оболочки интерпретируют скрипты понемногу. Perl компилирует всю программу перед ее выполнением (за исключением блоков &lt;code&gt;BEGIN&lt;/code&gt; , которые выполняются во время компиляции).</target>
        </trans-unit>
        <trans-unit id="d740f71b4c0205327f8285c81beee6b58843073b" translate="yes" xml:space="preserve">
          <source>Shift Operators</source>
          <target state="translated">Сменные операторы</target>
        </trans-unit>
        <trans-unit id="53ffaf0e7e7ca17703b35ea2272d3800a2b8789e" translate="yes" xml:space="preserve">
          <source>Shift object N digits right in base B and return the resulting object. This is equivalent to performing integer division by B**N and discarding the remainder, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">Сдвиньте объект N цифр прямо в базу B и верните результирующий объект.Это эквивалентно выполнению целочисленного деления на B**N и отбрасыванию остатка,за исключением того,что это может быть намного быстрее,в зависимости от того,как число представлено внутренне.</target>
        </trans-unit>
        <trans-unit id="816ba91c6c549fed8497fc4ed9fd5be93db7467c" translate="yes" xml:space="preserve">
          <source>Shift the object N digits left in base B. This is equivalent to multiplying by B**N, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">Сдвинуть объект N цифр,оставшихся в базе B.Это эквивалентно умножению на B**N,за исключением того,что это может быть намного быстрее,в зависимости от того,как внутренне представлено число.</target>
        </trans-unit>
        <trans-unit id="34ca9f2e9bedec059779353756117cfa0cd23d9b" translate="yes" xml:space="preserve">
          <source>Shift_JIS</source>
          <target state="translated">Shift_JIS</target>
        </trans-unit>
        <trans-unit id="c96929f71a3c235121f63b63fb9116d40dbf5a0d" translate="yes" xml:space="preserve">
          <source>Shifting by more bits than the size of the integers means most of the time zero (all bits fall off), except that under &lt;code&gt;use integer&lt;/code&gt; right overshifting a negative shiftee results in -1. This is unlike in C, where shifting by too many bits is undefined. A common C behavior is &quot;shift by modulo wordbits&quot;, so that for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c36060459ec37e9c46c5b4c7db69b11b3eb70" translate="yes" xml:space="preserve">
          <source>Shifting by negative number of bits means the reverse shift: left shift becomes right shift, right shift becomes left shift. This is unlike in C, where negative shift is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbd5485928f42790ecd61230b448ed394726e75" translate="yes" xml:space="preserve">
          <source>Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and 2, but others work, too.</source>
          <target state="translated">Сдвигает $x вправо на $y в базовых $n.По умолчанию используется база 2,обычно используется 10 и 2,но работают и другие.</target>
        </trans-unit>
        <trans-unit id="84e5b666ca83223606a44c0968ce869e11125987" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; array within the lexical scope of subroutines and formats, and the &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;eval STRING&lt;/code&gt;, &lt;code&gt;BEGIN {}&lt;/code&gt;, &lt;code&gt;INIT {}&lt;/code&gt;, &lt;code&gt;CHECK {}&lt;/code&gt;, &lt;code&gt;UNITCHECK {}&lt;/code&gt;, and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab6779d1c4d586e5a686816d2490a5a885e59ca" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">Сдвигает первое значение массива и возвращает его, сокращая массив на 1 и перемещая все вниз. Если в массиве нет элементов, возвращает неопределенное значение. Если ARRAY опущен, сдвигает массив &lt;code&gt;@_&lt;/code&gt; в лексической области подпрограмм и форматов, а массив &lt;code&gt;@ARGV&lt;/code&gt; за пределы подпрограммы, а также в лексические области, установленные &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; и &lt;code&gt;END {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb6ece5170a4ff335501d527cf25219b25ce8af" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">Сдвигает первое значение массива и возвращает его, сокращая массив на 1 и перемещая все вниз. Если в массиве нет элементов, возвращает неопределенное значение. Если ARRAY опущен, сдвигает массив &lt;code&gt;@_&lt;/code&gt; в лексической области подпрограмм и форматов, а массив &lt;code&gt;@ARGV&lt;/code&gt; за пределы подпрограммы, а также в лексические области, установленные &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; и &lt;code&gt;END {}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9246a967ab694917a93818e0c2f25b9c02d69c1" translate="yes" xml:space="preserve">
          <source>Shlomi Fish</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531ae3a2e613d67a406a1e927931cfe1052049c5" translate="yes" xml:space="preserve">
          <source>Shoichi Kaji &amp;lt;skaji@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dece67ae205fea215adef783e8ddedd9ee8cd234" translate="yes" xml:space="preserve">
          <source>Short for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e560762a5e85f4245145df0a3d5f14955ebfbe7e" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;an instance of a class&amp;rdquo;, meaning an &lt;b&gt;object&lt;/b&gt; of that &lt;b&gt;class&lt;/b&gt;.</source>
          <target state="translated">Сокращенно от &amp;laquo;экземпляр класса&amp;raquo;, что означает &lt;b&gt;объект&lt;/b&gt; этого &lt;b&gt;класса&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bf0f9ba179007d01df18b67571c95890eacf53a2" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;array value&amp;rdquo;, which refers to one of Perl&amp;rsquo;s internal data types that holds an &lt;b&gt;array&lt;/b&gt;. The &lt;code&gt;AV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">Сокращение от &amp;laquo;значение массива&amp;raquo;, которое относится к одному из внутренних типов данных Perl, которые содержат &lt;b&gt;массив&lt;/b&gt; . Тип &lt;code&gt;AV&lt;/code&gt; является подклассом &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="daa4e28096f49e40bca183e69c8dbf8fb7d81587" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;scalar value&amp;rdquo;. But within the Perl interpreter, every &lt;b&gt;referent&lt;/b&gt; is treated as a member of a class derived from SV, in an object-oriented sort of way. Every &lt;b&gt;value&lt;/b&gt; inside Perl is passed around as a C language &lt;code&gt;SV*&lt;/code&gt; pointer. The SV &lt;b&gt;struct&lt;/b&gt; knows its own &amp;ldquo;referent type&amp;rdquo;, and the code is smart enough (we hope) not to try to call a &lt;b&gt;hash&lt;/b&gt; function on a &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="translated">Сокращение от &amp;laquo;скалярное значение&amp;raquo;. Но в интерпретаторе Perl каждый &lt;b&gt;референт&lt;/b&gt; рассматривается как член класса, производного от SV, объектно-ориентированным способом. Каждое &lt;b&gt;значение&lt;/b&gt; внутри Perl передается как указатель &lt;code&gt;SV*&lt;/code&gt; языка C. SV &lt;b&gt;структура&lt;/b&gt; знает свой &amp;laquo;тип референт&amp;raquo;, а код достаточно умны (мы надеемся) не пытаться вызвать &lt;b&gt;хэш&lt;/b&gt; - функцию на &lt;b&gt;подпрограмму&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5d19c4596f6bfea39cf19abcb0120dd79077a176" translate="yes" xml:space="preserve">
          <source>Short for &lt;b&gt;scratchpad&lt;/b&gt;.</source>
          <target state="translated">Сокращение от &lt;b&gt;блокнота&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="11be5993935a64f6ec9ea9395f4cafbeb6afecc6" translate="yes" xml:space="preserve">
          <source>Short for Nevada, no part of which will ever be confused with civilization. NV also means an internal floating- point Numeric Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;IV&lt;/b&gt;.</source>
          <target state="translated">Сокращенно от Невады, ни одну часть которой никогда не спутаешь с цивилизацией. NV также означает внутреннее числовое значение с плавающей запятой того типа, который может содержать &lt;b&gt;скаляр&lt;/b&gt; , не путать с &lt;b&gt;IV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="753c68d3ba41db74e4df8914f2ce920431708ec4" translate="yes" xml:space="preserve">
          <source>Short for Transmission Control Protocol. A protocol wrapped around the Internet Protocol to make an unreliable packet transmission mechanism appear to the application program to be a reliable &lt;b&gt;stream&lt;/b&gt; of bytes. (Usually.)</source>
          <target state="translated">Сокращение от Transmission Control Protocol. Протокол, обернутый вокруг Интернет-протокола, чтобы ненадежный механизм передачи пакетов казался прикладной программе надежным &lt;b&gt;потоком&lt;/b&gt; байтов. (Обычно.)</target>
        </trans-unit>
        <trans-unit id="dc5ee68c69bf44299748c4c256b80c120fb271e9" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;hash value&amp;rdquo; typedef, which holds Perl&amp;rsquo;s internal representation of a hash. The &lt;code&gt;HV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">Сокращение от typedef &amp;laquo;значение хэша&amp;raquo;, которое содержит внутреннее представление хэша Perl. Тип &lt;code&gt;HV&lt;/code&gt; является подклассом &lt;b&gt;SV&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="641d12dc5680debd9252f30257e835d77f2b58b5" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;terminal&amp;rdquo;&amp;mdash;that is, a leaf node of a &lt;b&gt;syntax tree&lt;/b&gt;. A thing that functions grammatically as an &lt;b&gt;operand&lt;/b&gt; for the operators in an expression.</source>
          <target state="translated">Сокращение от термина &amp;laquo;терминал&amp;raquo;, то есть листовой узел &lt;b&gt;синтаксического дерева&lt;/b&gt; . Вещь, которая грамматически функционирует как &lt;b&gt;операнд&lt;/b&gt; для операторов в выражении.</target>
        </trans-unit>
        <trans-unit id="2a34ff2be32b26b7b9b0b3b4f346552a9899d102" translate="yes" xml:space="preserve">
          <source>Short for one member of &lt;b&gt;Perl mongers&lt;/b&gt;, a purveyor of Perl.</source>
          <target state="translated">Сокращение от одного из представителей &lt;b&gt;Perl mongers&lt;/b&gt; , поставщика Perl.</target>
        </trans-unit>
        <trans-unit id="215e423928369d110ed59f1768219b3b38101a83" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt; . The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="translated">Короткие целые числа. Это эквивалентно T_IV, но явно приводит возврат к типу &lt;code&gt;short&lt;/code&gt; . Карта типов по умолчанию для &lt;code&gt;short&lt;/code&gt; - T_IV.</target>
        </trans-unit>
        <trans-unit id="12e34708f98b55fcfa0df10d0541bdc76b04003d" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt;. The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e173f44ce033e23615a07008598ed98e0724ec82" translate="yes" xml:space="preserve">
          <source>Short of loading the file into a database or pre-indexing the lines in the file, there are a couple of things that you can do.</source>
          <target state="translated">Незадолго до загрузки файла в базу данных или предварительной индексации строк в файле,есть пара вещей,которые вы можете сделать.</target>
        </trans-unit>
        <trans-unit id="84208312087b060594b7b3ab194603ca9b48cd14" translate="yes" xml:space="preserve">
          <source>Short string (usually 10 characters or less, not enforced, but may be truncated by renderers) categorizing the amnesty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342f19ffca54484d831bc22d60422377cb72128f" translate="yes" xml:space="preserve">
          <source>Short summary: You need to create a package that defines four methods:</source>
          <target state="translated">Краткое резюме:Вам необходимо создать пакет,определяющий четыре метода:</target>
        </trans-unit>
        <trans-unit id="7d0c4499cb9c122a7211725e510477fa79e82bb6" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the error. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5092f6331f83cfc30c23eb79579783db3e8793f1" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the info. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b21662873145e63208c0c220c63eecf3382545" translate="yes" xml:space="preserve">
          <source>Short tests may produce negative figures because perl can appear to take longer to execute the empty loop than a short test; try:</source>
          <target state="translated">Короткие тесты могут давать отрицательные значения,так как perl может занять больше времени для выполнения пустого цикла,чем короткий тест;попробуйте:</target>
        </trans-unit>
        <trans-unit id="3c291d239a5572586d5800f8940e243040b2c7b5" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under AmigaOS</source>
          <target state="translated">Недостатки Perl под AmigaOS</target>
        </trans-unit>
        <trans-unit id="fa78e77c849e3197f1c80d2dbbfe4db374f3b001" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under DOS</source>
          <target state="translated">Недостатки Perl под DOS</target>
        </trans-unit>
        <trans-unit id="a84b9d9cc1ba4235d4b9a38a4443bc225f0a9d86" translate="yes" xml:space="preserve">
          <source>Should I do anything special if I call perl from multiple threads?</source>
          <target state="translated">Должен ли я делать что-нибудь особенное,если я звоню perl из нескольких потоков?</target>
        </trans-unit>
        <trans-unit id="41623a0ef32a13c7058b74719f5d1256441b7302" translate="yes" xml:space="preserve">
          <source>Should I use a web framework?</source>
          <target state="translated">Должен ли я использовать веб-фреймворк?</target>
        </trans-unit>
        <trans-unit id="706821549d14c573be320aadd1615ad49253a11a" translate="yes" xml:space="preserve">
          <source>Should a user have the need for compiling Perl in the LP64 environment, use the -Duse64bitall flag to Configure. This will force Perl to be compiled in a pure LP64 environment (with the +DD64 flag for HP C-ANSI-C, with no additional options for GNU gcc 64-bit on PA-RISC, and with -mlp64 for GNU gcc on Itanium). If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations.)</source>
          <target state="translated">Если у пользователя возникла необходимость скомпилировать Perl в среде LP64,используйте флаг -Duse64bitall для Configure.Это заставит скомпилировать Perl в чистом окружении LP64 (с флагом +DD64 для HP C-ANSI-C,без дополнительных опций для GNU gcc 64-bit на PA-RISC,и с -mlp64 для GNU gcc на Itanium).Если вы хотите скомпилировать Perl с помощью gcc,то вам потребуется версия компилятора,поддерживающая 64-битные операции)).</target>
        </trans-unit>
        <trans-unit id="efca6f20e60abb6462f2115cc6f4f778b3e904aa" translate="yes" xml:space="preserve">
          <source>Should an &lt;code&gt;ok()&lt;/code&gt; fail, it will produce some diagnostics:</source>
          <target state="translated">В случае сбоя &lt;code&gt;ok()&lt;/code&gt; будет произведена диагностика:</target>
        </trans-unit>
        <trans-unit id="6ed2a6a9606e8c4524e86ab5840b45b4bc37bfbb" translate="yes" xml:space="preserve">
          <source>Should be true if this event should result in a test count increment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa2401927f1002b79d1cf0dcfbafc98b85b5c42" translate="yes" xml:space="preserve">
          <source>Should be used if the perl library is moved from the default location in preference to &lt;code&gt;PERL(5)LIB&lt;/code&gt;, since this would not leave wrong entries in @INC. For example, if the compiled version of perl looks for @INC in</source>
          <target state="translated">Следует использовать, если библиотека perl перемещена из расположения по умолчанию в предпочтение к &lt;code&gt;PERL(5)LIB&lt;/code&gt; , так как это не оставит неправильных записей в @INC. Например, если скомпилированная версия perl ищет @INC в</target>
        </trans-unit>
        <trans-unit id="56e9538fa48dc5397d7704d11be1b316f1409e45" translate="yes" xml:space="preserve">
          <source>Should make stream's state consistent with layers below. That is, any buffered write data should be written, and file position of lower layers adjusted for data read from below but not actually consumed. (Should perhaps &lt;code&gt;Unread()&lt;/code&gt; such data to the lower layer.)</source>
          <target state="translated">Должно привести состояние потока в соответствие со слоями ниже. То есть любые буферизованные данные записи должны быть записаны, а положение файла нижних уровней скорректировано для данных, считываемых снизу, но фактически не потребляемых. (Возможно, следует &lt;code&gt;Unread()&lt;/code&gt; такие данные на нижний уровень.)</target>
        </trans-unit>
        <trans-unit id="1c3d2c3d146bd37267ff2248c2cd5e844253f599" translate="yes" xml:space="preserve">
          <source>Should not be set with newer Perls, since this may hide some</source>
          <target state="translated">Не следует устанавливать более новые Perls,так как это может скрыть некоторые</target>
        </trans-unit>
        <trans-unit id="ed8ff1c4976aa7b4301ba319829b15d5951b2c6e" translate="yes" xml:space="preserve">
          <source>Should probably be built into the core, and needs to stop pandering to DOS habits. Needs a dose of optimization too.</source>
          <target state="translated">Вероятно,это должно быть встроено в ядро и должно прекратить сводничество к привычкам DOS.Нужна еще и доза оптимизации.</target>
        </trans-unit>
        <trans-unit id="fbde5e966385ab1512ea67e3f35d08dd24d83ceb" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional.</source>
          <target state="translated">Должен возвращать 0 на успех,-1 на ошибку.Необязательно.</target>
        </trans-unit>
        <trans-unit id="f8c399f86acf033efef1e2751ef404b5ddaa2865" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional. Default is to fail, but that is likely to be changed in future.</source>
          <target state="translated">Должен возвращать 0 на успех,-1 на ошибку.Необязательно.По умолчанию это неудача,но это,скорее всего,будет изменено в будущем.</target>
        </trans-unit>
        <trans-unit id="246758221cfd3e60868d6718c892fa1bb87177ab" translate="yes" xml:space="preserve">
          <source>Should return a string to be placed in the buffer. Optional. If not provided, must provide READ or reject handles open for reading in PUSHED.</source>
          <target state="translated">Должна возвращать строку,которая будет помещена в буфер.Необязательно.Если не предусмотрено,должны быть открыты ручки READ или отклонения для чтения в PUSHED.</target>
        </trans-unit>
        <trans-unit id="d3cbfd0fcf4f24975313de4df8de49164d7ee2fd" translate="yes" xml:space="preserve">
          <source>Should return an object or the class, or -1 on failure. (Compare TIEHANDLE.) The arguments are an optional mode string (&quot;r&quot;, &quot;w&quot;, &quot;w+&quot;, ...) and a filehandle for the PerlIO layer below. Mandatory.</source>
          <target state="translated">Должен возвращать объект или класс,или -1 при отказе.(Сравните TIEHANDLE.)Аргументами являются необязательная строка режима (&quot;r&quot;,&quot;w&quot;,&quot;w+&quot;,...)и файл-хэндл для слоя PerlIO ниже.Обязательно.</target>
        </trans-unit>
        <trans-unit id="5642f34ce9dcd1c3ffa2dfc0c58640c6cb31044d" translate="yes" xml:space="preserve">
          <source>Should the $prefix fail to match</source>
          <target state="translated">Если $префикс не совпадает</target>
        </trans-unit>
        <trans-unit id="1690346ded0caeaa5dcdd766cbbfd423effb3884" translate="yes" xml:space="preserve">
          <source>Should yield no problems with AIX 5.1 / 5.2 / 5.3 / 6.1 / 7.1.</source>
          <target state="translated">Не должно вызывать проблем с AIX 5.1/5.2/5.3/6.1/7.1.</target>
        </trans-unit>
        <trans-unit id="377f03a2a4c9b170d5d73c84fdd0fa6c29b00142" translate="yes" xml:space="preserve">
          <source>Should yield no problems.</source>
          <target state="translated">Это не должно вызывать проблем.</target>
        </trans-unit>
        <trans-unit id="35f86593f3a7cab63ebec9bff3335371662e4b80" translate="yes" xml:space="preserve">
          <source>Should you be stuck with an ancient version of git (prior to 1.7), then &lt;code&gt;git push&lt;/code&gt; will not have the &lt;code&gt;-u&lt;/code&gt; switch, and you have to replace the last step with the following sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b16df946245605727ff1e16d4791f2bf174400d" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt; &quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt; &quot; instead.</source>
          <target state="translated">Если вы хотите создать статически связанный исполняемый файл в системе, которая может динамически загружать библиотеки, вы можете во всех следующих примерах, где выполняется команда &amp;laquo; &lt;code&gt;make&lt;/code&gt; &amp;raquo; без аргументов, вместо этого выполнить команду &amp;laquo; &lt;code&gt;make perl&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="398654e660729596cb8454b7f800d571ef53f379" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt;&quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt;&quot; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad198af5ed254b36c0129bab30cb66de4af9306" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have a $VERSION of zero?</source>
          <target state="translated">Показать все отдельные модули,у которых ВЕРСИЯ НУЛЯ?</target>
        </trans-unit>
        <trans-unit id="5886e6a19b112ccca7d7e5c6a420d33f7dc320f4" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have no $VERSION?</source>
          <target state="translated">Показать все отдельные модули,которые не имеют $VERSION?</target>
        </trans-unit>
        <trans-unit id="432657faf9897211c68f4ccc299c680506ae0f85" translate="yes" xml:space="preserve">
          <source>Show lexical variables used in functions or files</source>
          <target state="translated">Показывать лексические переменные,используемые в функциях или файлах</target>
        </trans-unit>
        <trans-unit id="15563729135e9ba264fbcba30a709d66c8a1dd93" translate="yes" xml:space="preserve">
          <source>Show test comments (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">Показать тестовые комментарии (не работает, если выбран &lt;code&gt;verbose&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="453672f22864e2ecabd52010a0251f21457a02b2" translate="yes" xml:space="preserve">
          <source>Show test failures (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">Показать сбои теста (не работает, если выбран &lt;code&gt;verbose&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="25af3a88c3b3773349dd8ac90b045308d5492ec5" translate="yes" xml:space="preserve">
          <source>Show the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ccbb891469b1a972be7b689b1ec1c7304ecb2a" translate="yes" xml:space="preserve">
          <source>Show the module details. This prints one line for each out-of-date module (meaning, modules locally installed but have newer versions on CPAN). Each line has three columns: module name, local version, and CPAN version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad96a4d0e92d1a92a25032d1a69981cb8c4094d" translate="yes" xml:space="preserve">
          <source>Show the out-of-date modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3deb58d49160799c00454338107f604ea794ed5" translate="yes" xml:space="preserve">
          <source>Show usage.</source>
          <target state="translated">Показать использование.</target>
        </trans-unit>
        <trans-unit id="7222550b5b66397acb151415418533c6a8f6f5fe" translate="yes" xml:space="preserve">
          <source>ShowMode</source>
          <target state="translated">ShowMode</target>
        </trans-unit>
        <trans-unit id="66970db782112b1077801cd655daa3c67c2cdecf" translate="yes" xml:space="preserve">
          <source>Shows if the given module is primarily maintained in perl core or on CPAN and bug tracker URL.</source>
          <target state="translated">Показывает,поддерживается ли данный модуль в первую очередь в ядре perl или на CPAN и URL багтрекера.</target>
        </trans-unit>
        <trans-unit id="ab7d18eafb7bcc2a74ee000087e57646aecc2b0d" translate="yes" xml:space="preserve">
          <source>Shows the primary maintainers for the specified modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a820735e69e06ccea6cc9de4ba8697b78a4549" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac75e459283e311c2d85839794c7648cec7df9c2" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Выключает интерпретатор Perl. См. &lt;a href=&quot;perlembed&quot;&gt;Perlembed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90e62e13ea37ff3f7a2ddce5609c724fd7e64daf" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by HOW, which has the same interpretation as in the syscall of the same name.</source>
          <target state="translated">Выключает гнездовое соединение способом,указанным в HOW,которое имеет такое же толкование,как и в одноименном syscall.</target>
        </trans-unit>
        <trans-unit id="7187637d0f34c57d8bea4681c13bb60273e1f7d1" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by the value passed in, which has the same interpretation as in the syscall of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de95fa319fad54d4fda1efff03c4320b4f1bbba0" translate="yes" xml:space="preserve">
          <source>Shutsdown the specified MACHINE, notifying users with the supplied MESSAGE, within the specified TIMEOUT interval. Forces closing of all documents without prompting the user if FORCECLOSE is true, and reboots the machine if REBOOT is true. This function works only on WinNT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="27bed13a88c60350c3de92ec3820e1cc4f7d6ec3" translate="yes" xml:space="preserve">
          <source>Signal</source>
          <target state="translated">Signal</target>
        </trans-unit>
        <trans-unit id="76e3a47c3cea2b4bc39210e8f1a7a4f458325f46" translate="yes" xml:space="preserve">
          <source>Signal flag. Will be set to a true value if a signal was caught. Clients may check for this flag to abort time-consuming operations.</source>
          <target state="translated">Сигнальный флаг.Будет установлен в истинное значение,если сигнал был пойман.Клиенты могут проверять этот флаг на прерывание трудоемких операций.</target>
        </trans-unit>
        <trans-unit id="47e8409eab6e54647df4cb7cecc41ee28c30a02b" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; to find their names on your system.</source>
          <target state="translated">Обработчики сигналов имеют дело с именами сигналов, а не с числами. Используйте &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; , чтобы найти их имена в вашей системе.</target>
        </trans-unit>
        <trans-unit id="f793004ac2bfb867d7b8c1fed8ccaa1370121adc" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;kill -l&lt;/code&gt; to find their names on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89722759e06611996072c09d8d893f78366be03" translate="yes" xml:space="preserve">
          <source>Signal handlers need to be set up in the threads for the signals they are expected to act upon. Here's an example for</source>
          <target state="translated">Обработчики сигналов должны быть настроены в потоках для сигналов,на которые они должны реагировать.Вот пример для</target>
        </trans-unit>
        <trans-unit id="4c81c67cfc40c99d8beeb124cd5a299ed53f7fa3" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="translated">Обработка сигналов также используется для таймаутов в Unix. Несмотря на надежную защиту в блоке &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; , вы устанавливаете обработчик сигналов для перехвата сигналов тревоги, а затем планируете, чтобы он был доставлен вам через некоторое количество секунд. Затем попробуйте операцию блокировки, сбросив сигнал тревоги, когда это будет сделано, но не раньше, чем вы выйдете из блока &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; . Если он сработает, вы воспользуетесь die (), чтобы выпрыгнуть из блока.</target>
        </trans-unit>
        <trans-unit id="d4984dbb18bb8f6d69231c1c5402b289b6cae3fd" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;eval{}&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;eval{}&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cd055a7cd87b137130bb8b93c1c2e53904764f" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="translated">Обработка сигналов может вести себя не так, как на платформах Unix (где она тоже не совсем &quot;ведет себя&quot; :). Например, вызов &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; из обработчиков сигналов вызовет исключение, поскольку большинство реализаций &lt;code&gt;signal()&lt;/code&gt; в Windows сильно повреждены. Таким образом, сигналы могут работать только для простых вещей, таких как установка флаговой переменной в обработчике. Использование сигналов через этот порт в настоящее время считается неподдерживаемым.</target>
        </trans-unit>
        <trans-unit id="a87648f8ff8510d519181cee20c22a292d601e89" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;die()&lt;/code&gt; or &lt;code&gt;exit()&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6c417fd537a17b001daa7dbea3a3b50cef51ef" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt; .</source>
          <target state="translated">Сигнал с нулевым номером может завершиться ошибкой, потому что у вас нет разрешения на отправку сигнала, когда он направлен процессу, чей реальный или сохраненный UID не совпадает с реальным или эффективным UID отправляющего процесса, даже если процесс активен. Вы можете определить причину сбоя, используя &lt;code&gt;$!&lt;/code&gt; или &lt;code&gt;%!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2252f0feffa6900d113f918d18d91c133bf55365" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="fec07adfbf089fdf5b54412a5f3085422a9dd0ae" translate="yes" xml:space="preserve">
          <source>Signals are</source>
          <target state="translated">Сигналы</target>
        </trans-unit>
        <trans-unit id="fe837ae8c05b966bdccbee31fe8ed0fe5d881059" translate="yes" xml:space="preserve">
          <source>Signals as &quot;faults&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43861fb85280c34c4b0e58573e896842254a1d10" translate="yes" xml:space="preserve">
          <source>Signals in Plan 9 Perl</source>
          <target state="translated">Сигналы в плане 9 Перл</target>
        </trans-unit>
        <trans-unit id="259b4915ff9abfbb2a728a264509dffb23aed5c4" translate="yes" xml:space="preserve">
          <source>Signals that are intercepted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2f061cd789264d5433118e03b134a8734af9d2" translate="yes" xml:space="preserve">
          <source>Signals triggered by operating system state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4cf0392296064579858651f856889aadbc2805e" translate="yes" xml:space="preserve">
          <source>Signatures</source>
          <target state="translated">Signatures</target>
        </trans-unit>
        <trans-unit id="d9d7c542958055b1904998cdb447122ec36a75ab" translate="yes" xml:space="preserve">
          <source>Signed bitwise operators.</source>
          <target state="translated">Подписанные битовые операторы.</target>
        </trans-unit>
        <trans-unit id="2622f509b356185fe6a42f6313ddbc8e57057af2" translate="yes" xml:space="preserve">
          <source>Significant performance improvements</source>
          <target state="translated">Значительное улучшение производительности</target>
        </trans-unit>
        <trans-unit id="ae6207f79c10c58b3e0ef4c08bbf6c86acc82fd9" translate="yes" xml:space="preserve">
          <source>Signum function. Set the number to -1, 0, or 1, depending on whether the number is negative, zero, or positive, respectively. Does not modify NaNs.</source>
          <target state="translated">Функция сигнализации.Установите число -1,0 или 1,в зависимости от того,является ли число отрицательным,нулевым или положительным соответственно.Не изменять NaN.</target>
        </trans-unit>
        <trans-unit id="31506097adfa948440134c0119e5a52038393445" translate="yes" xml:space="preserve">
          <source>Silberschatz, Abraham, and Peter B. Galvin. Operating System Concepts, 4th ed. Addison-Wesley, 1995, ISBN 0-201-59292-4</source>
          <target state="translated">Сильбершац,Авраам и Питер Б.Гальвин.Концепции операционной системы,4-е изд.Эддисон-Уэсли,1995,ISBN 0-201-59292-4.</target>
        </trans-unit>
        <trans-unit id="c1200bf449b67efb756e3194a25dcba2a224c7bd" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#recv&quot;&gt;&quot;recv&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf91ecf8b9db2d36c3c4af1dda8c5294da5403f" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#send&quot;&gt;&quot;send&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4b469b48eb970781d347cff775a6eb6ed07b9c" translate="yes" xml:space="preserve">
          <source>Similar problems can occur when storing &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in HVs:</source>
          <target state="translated">Подобные проблемы могут возникнуть при сохранении &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; в HV:</target>
        </trans-unit>
        <trans-unit id="0939c3fe5c0d5d2bff40d1b5db20a06321bba976" translate="yes" xml:space="preserve">
          <source>Similar to</source>
          <target state="translated">Подобно</target>
        </trans-unit>
        <trans-unit id="ca29a7deeeb800f3b647ae8e447ace2495bd48e6" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt; -blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">Аналогично &quot;CHECK&quot;, но для блоков &lt;code&gt;INIT&lt;/code&gt; , а не для блоков &lt;code&gt;CHECK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ec53f333f04a2995b3e086134767c778243eaa" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt;-blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02dc2c9e4fd99225658784381bc57431376c4f2" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="translated">Подобно $ io-&amp;gt; seek, но устанавливает позицию IO :: File напрямую с помощью системного вызова lseek (2), поэтому это запутает большинство операторов ввода-вывода Perl, кроме sysread и syswrite (подробности см. В &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="68c4347f8fea5b416312257ca34ba342de4d10b9" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a39eaf579340710bf4bd0f530bd675ee9e7a95" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;&quot;all&quot;&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48998732d2d944be662f876c6215817f6203f325" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeabee18f75813e1d32d468eb7ba172bf546eaed" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;all&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="translated">Подобно &lt;a href=&quot;#any&quot;&gt;любому&lt;/a&gt; и &lt;a href=&quot;#all&quot;&gt;все&lt;/a&gt; , но с чувством возвращения перевернутым. &lt;code&gt;none&lt;/code&gt; возвращает истину только в том случае, если в &lt;code&gt;@list&lt;/code&gt; нет значения, заставляющего &lt;code&gt;BLOCK&lt;/code&gt; вернуть истину, а &lt;code&gt;notall&lt;/code&gt; возвращает истину, только если не все значения возвращают.</target>
        </trans-unit>
        <trans-unit id="e0b3d2d208d62b5b40ff53db1e72a57e69459f20" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="translated">Подобно &lt;a href=&quot;#any&quot;&gt;любому&lt;/a&gt; , за исключением того, что он требует, чтобы все элементы &lt;code&gt;@list&lt;/code&gt; сделали возврат &lt;code&gt;BLOCK&lt;/code&gt; истинным. Если какой-либо элемент возвращает false, он возвращает false. Если &lt;code&gt;BLOCK&lt;/code&gt; никогда не возвращает false или &lt;code&gt;@list&lt;/code&gt; был пуст, он возвращает true.</target>
        </trans-unit>
        <trans-unit id="4be8eb83dc7372a8ceafe2d398607db21cbd0df8" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcb2ef3c4104f74e02c3a234af9ace81a7ab965" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9665cd00110ac2a060c12898dd3b9d89a35f309" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Аналогичен &lt;a href=&quot;#max&quot;&gt;max,&lt;/a&gt; но возвращает запись в списке с наименьшим числовым значением. Если список пуст , возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1acc3d00496e9a8972d2b21602c04ac03da5cacb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Подобно &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt; , но обрабатывает все записи в списке как строки и возвращает строку с наибольшим значением, как определено оператором &lt;code&gt;gt&lt;/code&gt; . Если список пуст , возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfb0f506a775b443c104de0b0c91306a78f551b3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;&quot;min&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a68b93abd1f3ba4015d6e167facf857ecad51b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;min&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Подобно &lt;a href=&quot;#min&quot;&gt;min&lt;/a&gt; , но обрабатывает все записи в списке как строки и возвращает самую низкую строку, как определено оператором &lt;code&gt;lt&lt;/code&gt; . Если список пуст , возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ecb07a28c8b871910322942b1bd79e2ea6e867f" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;&quot;sum&quot;&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720744a95bf0e839c040c184fab6270aac42881d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;sum&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;a href=&quot;#sum&quot;&gt;сумме&lt;/a&gt; , за исключением того, что она возвращает 0, когда задан пустой список, а не &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0c5d81a8f59f78025d72fb656f559ed47e0b02" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt; , this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="translated">Подобно &lt;code&gt;%+&lt;/code&gt; , эта переменная разрешает доступ к названным группам захвата в последнем успешном совпадении в текущей активной динамической области. С каждым именем группы захвата, найденным в регулярном выражении, оно связывает ссылку на массив, содержащий список значений, захваченных всеми буферами с этим именем (если их несколько), в том порядке, в котором они появляются.</target>
        </trans-unit>
        <trans-unit id="fc5cb74e6a15c2726021f737c1b80fe548fe2cc2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt;, this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc471f756f7e6a826fb6380627738dab038925d3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; recursive patterns have access to their caller's match state, so one can use backreferences safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85d1cf5a45c378c11b14a61c254003e40f86d06" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ code })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ code })&lt;/code&gt; recursive patterns have access to their callers match state, so one can use backreferences safely.</source>
          <target state="translated">Подобно &lt;code&gt;(??{ code })&lt;/code&gt; за исключением того, что не требует выполнения какого-либо кода или потенциальной компиляции возвращаемой строки шаблона; вместо этого он обрабатывает часть текущего шаблона, содержащегося в указанной группе захвата, как независимый шаблон, который должен совпадать в текущей позиции. Также отличается обработка буферов захвата, в отличие от &lt;code&gt;(??{ code })&lt;/code&gt; рекурсивные шаблоны имеют доступ к состоянию соответствия вызывающих их вызывающих объектов, поэтому можно безопасно использовать обратные ссылки.</target>
        </trans-unit>
        <trans-unit id="7b5e1028f59af1e35880841b72d98eb83a4ac03c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt; , this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion.</source>
          <target state="translated">Подобно &lt;code&gt;(R1)&lt;/code&gt; , этот предикат проверяет, выполняем ли мы непосредственно внутри самой левой группы с заданным именем (это та же логика, которую использует &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; для устранения неоднозначности). Он не проверяет полный стек, а только имя самой внутренней активной рекурсии.</target>
        </trans-unit>
        <trans-unit id="a58b4285d54a7974cddfaf2830c81dd7d35f40eb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt;, this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion. Full syntax: &lt;code&gt;(?(R&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d819c8539b4d29d94e8d4689944b0f7272e6c433" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="translated">Подобно &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; в том, что он по очереди оценивает параметр &lt;code&gt;BLOCK&lt;/code&gt; &lt;code&gt;$_&lt;/code&gt; для каждого элемента &lt;code&gt;@list&lt;/code&gt; . &lt;code&gt;any&lt;/code&gt; возвращает истину, если какой-либо элемент заставляет &lt;code&gt;BLOCK&lt;/code&gt; вернуть истинное значение. Если &lt;code&gt;BLOCK&lt;/code&gt; никогда не возвращает true или &lt;code&gt;@list&lt;/code&gt; был пуст, он возвращает false.</target>
        </trans-unit>
        <trans-unit id="309f2e4aced8f70bc86983e34f644c5eeda43d60" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Подобно &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; в том, что он по очереди оценивает параметр &lt;code&gt;BLOCK&lt;/code&gt; &lt;code&gt;$_&lt;/code&gt; для каждого элемента &lt;code&gt;@list&lt;/code&gt; . &lt;code&gt;first&lt;/code&gt; возвращает первый элемент, в котором результатом &lt;code&gt;BLOCK&lt;/code&gt; является истинное значение. Если &lt;code&gt;BLOCK&lt;/code&gt; никогда не возвращает true или &lt;code&gt;@list&lt;/code&gt; был пуст , возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e075f217be25d05567036ad66b6856b5e68b562" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt; , the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="translated">Подобно &lt;code&gt;@+&lt;/code&gt; , хэш &lt;code&gt;%+&lt;/code&gt; разрешает доступ к именованным буферам захвата, если они существуют, в последнем успешном совпадении в текущей активной динамической области.</target>
        </trans-unit>
        <trans-unit id="c20f7b2090b36afe2f8cc1a28252ce82895a9532" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt;, the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d5383c2abb4219427283869f7f92149d2a972c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt; , returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">Подобно &lt;code&gt;Open&lt;/code&gt; , возвращает PerlIO * в случае успеха, &lt;code&gt;NULL&lt;/code&gt; в случае неудачи.</target>
        </trans-unit>
        <trans-unit id="1de2fbefa7ee02f134e1d332ea00e119a6f12731" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt;, returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9b990cdb77a226953210e003d5b8ec28f7e6d4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt; , except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="translated">Подобно &lt;code&gt;eq_array()&lt;/code&gt; , за исключением того, что порядок элементов &lt;b&gt;не&lt;/b&gt; важен. Это тщательная проверка, но несоответствие порядка относится только к верхнему уровню.</target>
        </trans-unit>
        <trans-unit id="c6f86f2d94dbcc71aafb977b9cc5434713d6b331" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt;, except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3701740d1ad6bfc649e15fd040627ffd1f305bbb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbfbf42053ee4ef8969a4fa2ee7faff4e2fb6ee2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799cf1cf4afc49012909146223bfe3d0985a8027" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt; , but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="translated">Подобно &lt;code&gt;htmlify()&lt;/code&gt; , но превращает не буквенно-цифровые символы в символы подчеркивания. Обратите внимание, что &lt;code&gt;anchorify()&lt;/code&gt; по умолчанию не экспортируется.</target>
        </trans-unit>
        <trans-unit id="c853c707bee9ff3b2aad37853128e372734e9e4d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt;, but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12c5c9a9a0658e780b40222b20b1585f58ad997" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt; , except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="translated">Подобно &lt;code&gt;is()&lt;/code&gt; , за исключением того, что если $ got и $ expected являются ссылками, он выполняет глубокое сравнение, просматривая каждую структуру данных, чтобы увидеть, эквивалентны ли они. Если две структуры различаются, отобразится место, где они начинаются.</target>
        </trans-unit>
        <trans-unit id="5856aeb59fd6e40eddb32ad4b83e28afc3331a2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt;, except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a60ea110d9d9e2f388b25322faf3b4d38a6a8c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;list&lt;/code&gt; but only active groups that match the pattern are returned. &lt;code&gt;PATTERN&lt;/code&gt; can be a group pattern.</source>
          <target state="translated">Аналогично &lt;code&gt;list&lt;/code&gt; но возвращаются только активные группы, соответствующие шаблону. &lt;code&gt;PATTERN&lt;/code&gt; может быть групповым шаблоном.</target>
        </trans-unit>
        <trans-unit id="8394e4ee5f103a1c48fa6ce025d057e64f7170cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt; , with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="translated">Подобно &lt;code&gt;lock_keys()&lt;/code&gt; , с той разницей, что в дополнительном списке ключей указываются ключи, которые могут быть или не быть уже в хэше. По сути, это более простой способ сказать</target>
        </trans-unit>
        <trans-unit id="fd28c174d303c48db24df8e8b11ae9ae4d26bc24" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt;, with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb0fd1c6610a16c5e7d118e0a5ba89092c8069d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt; , but creates an UNOP_AUX struct instead, with op_aux initialised to aux</source>
          <target state="translated">Подобно &lt;code&gt;newUNOP&lt;/code&gt; , но вместо этого создает структуру UNOP_AUX, при этом op_aux инициализируется как aux</target>
        </trans-unit>
        <trans-unit id="5e858708a27caba519590b6fdb8853664bd94dce" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt;, but creates an &lt;code&gt;UNOP_AUX&lt;/code&gt; struct instead, with &lt;code&gt;op_aux&lt;/code&gt; initialised to &lt;code&gt;aux&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc376b4266acbbeb8358039fda2afe78067b9523" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="translated">Подобно &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;is()&lt;/code&gt; и &lt;code&gt;isnt()&lt;/code&gt; сравнивают свои два аргумента с &lt;code&gt;eq&lt;/code&gt; и &lt;code&gt;ne&lt;/code&gt; соответственно и используют результат этого, чтобы определить, был ли тест успешным или неудачным. Итак, эти:</target>
        </trans-unit>
        <trans-unit id="2d613f276bedf9458ff8ce32e8990c5576137f0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;like()&lt;/code&gt; сопоставляет $ got с регулярным выражением &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d80b81dd55578d43ab2dc56b52c4c8c56c375c2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38f30f4277690cf45428e116cea438e779a9819" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;qr/expected/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f443cdf5d4202dff7105c24c5a2b89e3df5ba0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;reduce&lt;/code&gt; except that it also returns the intermediate values along with the final result. As before, &lt;code&gt;$a&lt;/code&gt; is set to the first element of the given list, and the &lt;code&gt;BLOCK&lt;/code&gt; is then called once for remaining item in the list set into &lt;code&gt;$b&lt;/code&gt;, with the result being captured for return as well as becoming the new value for &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050d8bfd9d6dd81a6f8789b0e8d9cd7b8f6780b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt; .</source>
          <target state="translated">Подобно &lt;code&gt;save_scalar&lt;/code&gt; , но локализует &lt;code&gt;@gv&lt;/code&gt; и &lt;code&gt;%gv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07501a6bba290a81025a9cc58f969fd7da78b384" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but will reinstate an &lt;code&gt;SV *&lt;/code&gt; .</source>
          <target state="translated">Аналогично &lt;code&gt;save_scalar&lt;/code&gt; , но восстановит &lt;code&gt;SV *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="657ba45f71ac8c697cb507869c08178c868c5018" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd7eb38494553782c4863edc348cc1335774a8b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but will reinstate an &lt;code&gt;SV *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1390e677f6a0ebeb104aa1d188d2523b30d8bc4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt; , but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt; .</source>
          <target state="translated">Подобно &lt;code&gt;save_svref&lt;/code&gt; , но локализует &lt;code&gt;AV *&lt;/code&gt; и &lt;code&gt;HV *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f3780c5e475fc5db102e3fd087d1848086a6f08" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt;, but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdee7e1885c1d2ec3f4e4850b44e46e9ebce62cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;unlink0&lt;/code&gt; except after file comparison using cmpstat, the filehandle is closed prior to attempting to unlink the file. This allows the file to be removed without using an END block, but does mean that the post-unlink comparison of the filehandle state provided by &lt;code&gt;unlink0&lt;/code&gt; is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf1c2a19f0b0ee74a54bd214a8ec4d84f8e3cf9" translate="yes" xml:space="preserve">
          <source>Similar to C</source>
          <target state="translated">Аналогично С</target>
        </trans-unit>
        <trans-unit id="a64ea60affb2a9690ec81f413108d64202543e9b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTR except that the pointer is stored in a scalar and the reference to that scalar is returned to the caller. This can be used to hide the actual pointer value from the programmer since it is usually not required directly from within perl.</source>
          <target state="translated">Аналогично T_PTR за исключением того,что указатель хранится в скаляре,а ссылка на этот скаляр возвращается вызывающему абоненту.Это может быть использовано для сокрытия от программиста действительного значения указателя,так как обычно оно не требуется непосредственно изнутри perl.</target>
        </trans-unit>
        <trans-unit id="4ed1b14b67aa9193491a3dd6d65f8409d185456b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTROBJ in that the pointer is blessed into a scalar object. The difference is that when the object is passed back into XS it must be of the correct type (inheritance is not supported) while T_PTROBJ supports inheritance.</source>
          <target state="translated">Аналогично T_PTROBJ в том,что указатель благословляется в скалярный объект.Разница в том,что при обратной передаче объекта в XS он должен быть правильного типа (наследование не поддерживается),в то время как T_PTROBJ поддерживает наследование.</target>
        </trans-unit>
        <trans-unit id="98345bece5539f546d5a8e96d6aece125a75354c" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF except that the reference is blessed into a class. This allows the pointer to be used as an object. Most commonly used to deal with C structs. The typemap checks that the perl object passed into the XS routine is of the correct class (or part of a subclass).</source>
          <target state="translated">Аналогично T_PTRREF за исключением того,что ссылка благословляется в классе.Это позволяет использовать указатель как объект.Наиболее часто используется для работы со структурами на C.Типовая карта проверяет,что объект perl,переданный в рутину XS,является правильным классом (или частью подкласса).</target>
        </trans-unit>
        <trans-unit id="a0e3f786e5320b6b926d5843480fabad22b49df4" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF, except the pointer stored in the referenced scalar is dereferenced and copied to the output variable. This means that T_REFREF is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR. All clear?</source>
          <target state="translated">Аналогично T_PTRREF,за исключением того,что указатель,хранящийся в привязанном скаляре,разыменовывается и копируется в выходную переменную.Это означает,что T_REFREF равно T_PTRREF,так как T_OPAQUE равно T_OPAQUEPTR.Все понятно?</target>
        </trans-unit>
        <trans-unit id="316a66a038c9003e3588353dd7b06b4570041574" translate="yes" xml:space="preserve">
          <source>Similar to key/value hash slices (and also introduced in Perl 5.20), the % array slice syntax returns a list of index/value pairs:</source>
          <target state="translated">Подобно хэшу ключей/значений (а также введенному в Perl 5.20),синтаксис хэша массива % возвращает список пар ключ/значение:</target>
        </trans-unit>
        <trans-unit id="fcdb3335ff45dd421a45fea8e6567734b9ec0cac" translate="yes" xml:space="preserve">
          <source>Similar to mkstemp(), except that an extra argument can be supplied with a suffix to be appended to the template.</source>
          <target state="translated">Аналогично mkstemp(),за исключением того,что дополнительный аргумент может поставляться с суффиксом,который будет добавлен в шаблон.</target>
        </trans-unit>
        <trans-unit id="4cf9bfb3c81fe1275534c974c84d67c5db310bda" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">Подобно ключевому слову &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; в perl , но интерпретирует данный список как список пар одинакового размера. Он вызывает &lt;code&gt;BLOCK&lt;/code&gt; несколько раз в скалярном контексте, при этом &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; устанавливаются на последовательные пары значений из &lt;code&gt;@kvlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20605e6412e378f2426dfa2ecf790a73c30912ee" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">Подобно ключевому слову perl &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; , но интерпретирует данный список как список пар одинакового размера. Он вызывает &lt;code&gt;BLOCK&lt;/code&gt; несколько раз в контексте списка, при этом &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; устанавливают последовательные пары значений из &lt;code&gt;@kvlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8dc38a4899c208d20a94f1397e679f06553d540" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;grep&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6971d89c696879a9eeb673adbf4f23a22af252ce" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;map&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e0979e74abc467bf78f9a39fbc983727e9baaf" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="translated">Подобно строкам, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; действует как апостроф в регулярном выражении; все остальные разделители &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; действуют как кавычки. Если регулярное выражение оценивается как пустая строка, регулярное выражение в</target>
        </trans-unit>
        <trans-unit id="19b88f89de77da98af72b4163220db2f0a7c8ecd" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;m''&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;'m'&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82cc003c44f0253412b5190a2e4c975c854a684" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;&quot;first&quot;&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ef33d2521670adf2f6b3cf61cae1999ab3778c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;first&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">Подобна &lt;a href=&quot;#first&quot;&gt;первой&lt;/a&gt; функции, но интерпретирует данный список как список пар одинакового размера. Он вызывает &lt;code&gt;BLOCK&lt;/code&gt; несколько раз в скалярном контексте, при этом &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; устанавливаются на последовательные пары значений из &lt;code&gt;@kvlist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f852487d7b194c670f738b8370d3735ea507b49e" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in braces, where the first character is a caret. The next character is any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;, followed by ASCII word characters. An example is &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0747626402d2dd7f7c45b97cc24e9304db46b6d7" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in brackets, where the first character is either a caret followed by an uppercase letter, like &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; or a non-&lt;code&gt;NUL&lt;/code&gt; , non-space literal control like &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; . Like the above, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; , the characters in &lt;code&gt;[0x80-0xFF]&lt;/code&gt; are considered controls, but as of v5.22, the use of any that are non-graphical are deprecated, and as of v5.20 the use of any ASCII-range literal control is deprecated. Support for these will be removed in a future version of perl.</source>
          <target state="translated">Подобно приведенному выше, сигил, за которым следует текст в скобках, где первый символ - это либо каретка, за которой следует заглавная буква, например &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; либо не- &lt;code&gt;NUL&lt;/code&gt; , не пробел буквальный элемент управления, например &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; . Как и в &lt;code&gt;[0x80-0xFF]&lt;/code&gt; , когда символы в [0x80-0xFF] не указаны в разделе &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; , они считаются элементами управления, но начиная с версии 5.22 использование любых неграфических символов не рекомендуется, а с версии 5.20 символы использование любых буквальных элементов управления диапазоном ASCII устарело. Их поддержка будет удалена в будущей версии perl.</target>
        </trans-unit>
        <trans-unit id="668df669d9efbd5ecee333d1f8978a303dbbc797" translate="yes" xml:space="preserve">
          <source>Similar to try, except that it does not catch exceptions. The idea here is to protect $@ and $! from changes. $@ and $! will be restored to whatever they were before the run so long as it is successful. If the run fails $! will still be restored, but $@ will contain the exception being thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21000b274c1010d95d46737a373e917805b17d88" translate="yes" xml:space="preserve">
          <source>Similar to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2112c220c2b71523b70f673d7ec4dcde3c15e0" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="translated">Аналогичным образом, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; производит вывод отладки, с той лишь разницей, что он позволяет точно настроить, какой вывод отладки будет выдаваться. Параметры разделены на три группы: те, которые связаны с компиляцией, те, которые связаны с выполнением, и те, которые связаны с особыми целями. Возможны следующие варианты:</target>
        </trans-unit>
        <trans-unit id="c569ec67d5806423bac1b597854e2fd9a9cd8f16" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;use re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d106c3869ea4929caecddf63406cc3cb977903" translate="yes" xml:space="preserve">
          <source>Similarly all warnings are disabled in a block by either of these:</source>
          <target state="translated">Точно так же все предупреждения отключаются одним блоком:</target>
        </trans-unit>
        <trans-unit id="55dea1c41dc940323d881fe12ebce9ec69c591cf" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, you may use:</source>
          <target state="translated">Точно так же, если вы открыли этот дескриптор &lt;code&gt;FH&lt;/code&gt; с помощью обычного &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="64831f5e93834f6bf428903e01c563e7e7bece53" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;sysopen&lt;/code&gt;, you may use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53be67a31768325e220272f535bb98f85e3fcddf" translate="yes" xml:space="preserve">
          <source>Similarly one could take the output of the third numbers column from recipe 2 to obtain a &lt;code&gt;$cp_1047&lt;/code&gt; table. The fourth numbers column of the output from recipe 2 could provide a &lt;code&gt;$cp_posix_bc&lt;/code&gt; table suitable for transcoding as well.</source>
          <target state="translated">Аналогичным образом можно было бы взять вывод третьего столбца чисел из рецепта 2, чтобы получить таблицу &lt;code&gt;$cp_1047&lt;/code&gt; . Четвертый столбец чисел выходных данных рецепта 2 может содержать таблицу &lt;code&gt;$cp_posix_bc&lt;/code&gt; подходящую также для перекодирования.</target>
        </trans-unit>
        <trans-unit id="d0f4815a422eaba46c3d84f219793b24d2375a6b" translate="yes" xml:space="preserve">
          <source>Similarly the NULL needs to be taken into account when you are considering the length of existing keys/values.</source>
          <target state="translated">Аналогичным образом NULL необходимо учитывать при рассмотрении длины существующих ключей/значений.</target>
        </trans-unit>
        <trans-unit id="15d5ffcdd52f893f6f74efb6a4803895765d4c4b" translate="yes" xml:space="preserve">
          <source>Similarly the name &quot;WinWin32s&quot; should have been &quot;Win32s&quot; but has been kept as-is for backwards compatibility reasons too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b052290a572fb153a5a7598b50b12efdb7ef549e" translate="yes" xml:space="preserve">
          <source>Similarly unclear is what should be generated when the &lt;code&gt;\N{...}&lt;/code&gt; is used as one of the end points of the range, such as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04230c63a76d30ed5b83266e25e001a24b4eb855" translate="yes" xml:space="preserve">
          <source>Similarly with the one-shot interface, if the input is a buffer larger than 4 Gig, a zip64 complaint zip file will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4baed99da5d9cf308161bde5e8cc00af2ab9d79" translate="yes" xml:space="preserve">
          <source>Similarly you can build in parallel with GNU make, type &quot;gmake -j2&quot; to build with two parallel jobs, or higher for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4fb6a726563143c1c04086d201d673d7729dd3" translate="yes" xml:space="preserve">
          <source>Similarly,</source>
          <target state="translated">Similarly,</target>
        </trans-unit>
        <trans-unit id="90864fd67d3db4c105028d84006c631220f52597" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt; , perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt; , and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="translated">Точно так же &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; является частью хэша, на который ссылается скалярная переменная &lt;code&gt;$href&lt;/code&gt; , возможно, даже без имени. &lt;code&gt;$href{'red'}&lt;/code&gt; является частью хэша &lt;code&gt;%href&lt;/code&gt; с ошибочным названием . Легко забыть опустить &lt;code&gt;-&amp;gt;&lt;/code&gt; , и если вы это сделаете, вы получите странные результаты, когда ваша программа получит массив и хеш-элементы из совершенно неожиданных хэшей и массивов, которые не были теми, которые вы хотели использовать.</target>
        </trans-unit>
        <trans-unit id="b70d4728a23b61603feac7dca92ea80423288fd3" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt;, perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt;, and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9f2629494d34ddc3413b1763638df2e3855408" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; re-enables autodeferment, and &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; recovers the current value of the autodefer setting.</source>
          <target state="translated">Точно так же &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; повторно включает автоотложку, а &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; восстанавливает текущее значение параметра autodefer.</target>
        </trans-unit>
        <trans-unit id="ed0a74921b522c90d239c941839d98f9f544df9e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;x=&lt;/code&gt; operators lose their mathemagical properties if the string conversion substitution is applied.</source>
          <target state="translated">Аналогично, операторы &lt;code&gt;.=&lt;/code&gt; И &lt;code&gt;x=&lt;/code&gt; теряют свои математические свойства, если применяется подстановка преобразования строки.</target>
        </trans-unit>
        <trans-unit id="98381cd292cecc23499c5a97dc7663476a411916" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt; 's &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="translated">Точно так же магию &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; можно использовать так же, как tie () для вызова функции C каждый раз, когда используется или изменяется значение скаляра. The &lt;code&gt;MAGIC&lt;/code&gt; &amp;laquo;сек &lt;code&gt;mg_ptr&lt;/code&gt; точки поля к &lt;code&gt;ufuncs&lt;/code&gt; структуры:</target>
        </trans-unit>
        <trans-unit id="dd56bf6157ee2e5e27ea1785ce7250db948cb17e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt;'s &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084028b0095b78ad708b249b88f8a8326808bba4" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;\x&lt;i&gt;nn&lt;/i&gt;&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1434bb43847966624ccbd7c82a8d888d8931593" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="translated">Точно так же встроенная в Perl функция &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; специально обрабатывает ссылку на благословенный объект. Если вы вызываете &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; а &lt;code&gt;$thing&lt;/code&gt; содержит ссылку на объект, она вернет имя класса, в который был добавлен объект.</target>
        </trans-unit>
        <trans-unit id="3c79bdba87881c1ec05393b4d27a2c965c79a1a5" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;ref&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;ref($thing)&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed57441510534192d07967fc62d33e33379b4e80" translate="yes" xml:space="preserve">
          <source>Similarly, a list assignment in list context produces the list of lvalues assigned to, and a list assignment in scalar context returns the number of elements produced by the expression on the right hand side of the assignment.</source>
          <target state="translated">Аналогично,назначение списка в контексте списка производит список назначенных значений,а назначение списка в скалярном контексте возвращает количество элементов,произведенных выражением,находящимся справа от назначения.</target>
        </trans-unit>
        <trans-unit id="105351b9ff1ce0c3b0da126c3158372b6f241c09" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt; . To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt; , just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; .</source>
          <target state="translated">Точно так же значение, присвоенное &lt;code&gt;$)&lt;/code&gt; , также должно быть списком чисел, разделенных пробелами. Первое число устанавливает эффективный gid, а остальные (если есть) передаются в &lt;code&gt;setgroups()&lt;/code&gt; . Чтобы получить эффект пустого списка для &lt;code&gt;setgroups()&lt;/code&gt; , просто повторите новый эффективный gid; то есть, чтобы установить эффективный gid &lt;code&gt;setgroups()&lt;/code&gt; 5 и эффективно пустой список setgroups () , скажем, &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9bfb808fae3d4ef85e01abecf018c96a424092b" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt;. To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt;, just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f830d9f2bf12f89de4edd3497ea1af8e153890fe" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt; . Thus, the above expression may be written as:</source>
          <target state="translated">Точно так же выражение, которое возвращает ссылку на скаляр, может быть разыменовано с помощью &lt;code&gt;${...}&lt;/code&gt; . Таким образом, приведенное выше выражение можно записать как:</target>
        </trans-unit>
        <trans-unit id="6c0225a1fecb24141de2c67cfa637dd7b4544c6f" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt;. Thus, the above expression may be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1370fc5b87a4deef9433fab962c63dda2bb0891" translate="yes" xml:space="preserve">
          <source>Similarly, autogeneration for keys &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'++'&lt;/code&gt; is analogous to &lt;code&gt;'-='&lt;/code&gt; and &lt;code&gt;'--'&lt;/code&gt; above:</source>
          <target state="translated">Точно так же автогенерация ключей &lt;code&gt;'+='&lt;/code&gt; и &lt;code&gt;'++'&lt;/code&gt; аналогична &lt;code&gt;'-='&lt;/code&gt; и &lt;code&gt;'--'&lt;/code&gt; выше:</target>
        </trans-unit>
        <trans-unit id="22f4fe3ff0b7318ce2f9a1f22a4a30c916f48517" translate="yes" xml:space="preserve">
          <source>Similarly, because of all the subscripting that is done using single words, the same rule applies to any bareword that is used for subscripting a hash. So now, instead of writing</source>
          <target state="translated">Аналогично,из-за того,что все подскрипты выполняются с использованием одних слов,одно и то же правило применяется к любому пустому слову,которое используется для подскриптовки хэша.Так что теперь,вместо того,чтобы писать</target>
        </trans-unit>
        <trans-unit id="1ef17c2e729b74afc14b925795781df60a813811" translate="yes" xml:space="preserve">
          <source>Similarly, decimal strings can represent only those numbers which have a finite decimal expansion. Being strings, and thus of arbitrary length, there is no practical limit for the exponent or number of decimal digits for these numbers. (But realize that what we are discussing the rules for just the</source>
          <target state="translated">Аналогичным образом,десятичные строки могут представлять только те числа,которые имеют конечное десятичное разложение.Являясь строками,а значит,произвольной длины,для этих чисел не существует практического ограничения по показателю или количеству десятичных цифр.(Но имейте в виду,что то,что мы обсуждаем правила только для</target>
        </trans-unit>
        <trans-unit id="d345f5b26d91c2f90c4bf682659d17c36e269cb0" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="translated">Точно так же для повторяющегося &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; второе наилучшее совпадение - это совпадение в позиции на одну ступеньку дальше в строке.</target>
        </trans-unit>
        <trans-unit id="120bba2aa7dfcc858de2e7ae463e7151de6901e1" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;m/()/g&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee2c36ef0fdac4abda9dcad28ab4aed983df538" translate="yes" xml:space="preserve">
          <source>Similarly, functions that return text data--such as a function that fetches a web page--should sometimes translate newlines before returning the data, if they've not yet been translated to the local newline representation. A single line of code will often suffice:</source>
          <target state="translated">Аналогичным образом,функции,возвращающие текстовые данные-например,функция,которая получает веб-страницу-должны иногда переводить новые строки перед возвращением данных,если они еще не были переведены в локальное представление новой строки.Часто достаточно одной строки кода:</target>
        </trans-unit>
        <trans-unit id="6397152c0c35f4b75972d06222dcea4b97f1756f" translate="yes" xml:space="preserve">
          <source>Similarly, if the &lt;code&gt;compress&lt;/code&gt; program is available, you can use this to write a &lt;code&gt;.tar.Z&lt;/code&gt; file</source>
          <target state="translated">Точно так же, если доступна программа &lt;code&gt;compress&lt;/code&gt; , вы можете использовать ее для записи файла &lt;code&gt;.tar.Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e75a2bb501471358d82a9998e95b65710f45b03" translate="yes" xml:space="preserve">
          <source>Similarly, if you need the threads object, but your thread will not be returning a value (i.e.,</source>
          <target state="translated">Аналогично,если вам нужен объект threads,но ваш поток не будет возвращать значение (т.е,</target>
        </trans-unit>
        <trans-unit id="5871ebe0fa13ed14449c1f6ca87d126616162345" translate="yes" xml:space="preserve">
          <source>Similarly, in the failure branch we could use &lt;code&gt;PUSHs&lt;/code&gt;</source>
          <target state="translated">Точно так же в ветви отказа мы могли бы использовать &lt;code&gt;PUSHs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9077bdc5741605a4137fa6215e60fd225b8f3e44" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="translated">Точно так же было бы лучше &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; вместо,</target>
        </trans-unit>
        <trans-unit id="14a6593d35c0dd5a226aba97a86d554f0e84ed18" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46d4cfe15f7f292996d268d497a4ca8dd6bd83c" translate="yes" xml:space="preserve">
          <source>Similarly, just because an operator lets you assume default arguments doesn't mean that you have to make use of the defaults. The defaults are there for lazy systems programmers writing one-shot programs. If you want your program to be readable, consider supplying the argument.</source>
          <target state="translated">Точно так же то,что оператор позволяет принимать аргументы по умолчанию,не означает,что вы должны использовать значения по умолчанию.Значения по умолчанию есть для ленивых системных программистов,пишущих одноразовые программы.Если вы хотите,чтобы ваша программа была читабельной,подумайте о предоставлении аргумента.</target>
        </trans-unit>
        <trans-unit id="65a3c4117ed70cbe8d3af699e5cf5e22b4df58b4" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;&quot;THREAD SIGNALLING&quot; in threads&lt;/a&gt; for more details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab81862aa9c1688c2206840c0db77adfc7697fb" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING in threads&lt;/a&gt; for more details.)</source>
          <target state="translated">Точно так же смешивание сигналов и потоков может быть проблематичным. Реализации зависят от платформы, и даже семантика POSIX может не соответствовать вашим ожиданиям (а Perl даже не предоставляет вам полный API POSIX). Например, нет способа гарантировать, что сигнал, отправленный в многопоточное приложение Perl, будет перехвачен каким-либо конкретным потоком. (Однако недавно добавленная функция предоставляет возможность посылать сигналы между потоками. Подробнее см. &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;СИГНАЛИЗАЦИЯ ПОТОКА в потоках&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="cd7a72bba4a729c17beea354c31212e7918a1056" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() use only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both write the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b7335ed3c7d05707d8547cd24aeb6b264218d7" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() used only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both wrote the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9312c4a2cb541668748a3ea749dc0d9f12c2cf9" translate="yes" xml:space="preserve">
          <source>Similarly, the &lt;code&gt;UNICODE_WARN_NONCHAR&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_NONCHAR&lt;/code&gt; flags affect how the function handles a Unicode non-character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa030e076fa248a433f0f83ee4a1aceaeee249f" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt; .</source>
          <target state="translated">Точно так же параметр &lt;code&gt;inc_override&lt;/code&gt; может быть ссылкой на массив, который используется вместо путей поиска модулей по умолчанию из &lt;code&gt;@INC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c747d6cbaa1a9a827f93122d97bf098849b7485" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1497da8abe3ed6eca13bd6302e3d281ea65007d7" translate="yes" xml:space="preserve">
          <source>Similarly, the resultant filespec will contain the file version only if one was present in the input filespec.</source>
          <target state="translated">Аналогично,результирующий файл filepec будет содержать версию файла только в том случае,если она присутствовала во входном файле filespec.</target>
        </trans-unit>
        <trans-unit id="0dacead88183b1e9c6304a4ceec665b6c24796d7" translate="yes" xml:space="preserve">
          <source>Similarly, they can be used in regular expression literals</source>
          <target state="translated">Аналогичным образом,они могут быть использованы в регулярных выражениях букв.</target>
        </trans-unit>
        <trans-unit id="395326d4967b38aae5eb742109108213c899c254" translate="yes" xml:space="preserve">
          <source>Similarly, this is invalid:</source>
          <target state="translated">Точно так же,это недействительно:</target>
        </trans-unit>
        <trans-unit id="6c8f54b856913d21b69f361a1a90203715ac01de" translate="yes" xml:space="preserve">
          <source>Similarly, this recipe can be used for properties that do require adjustments:</source>
          <target state="translated">Аналогичным образом,этот рецепт может быть использован для свойств,которые требуют корректировки:</target>
        </trans-unit>
        <trans-unit id="838e649b773f393ab1e3e6ec2fd3f5756cf00ea3" translate="yes" xml:space="preserve">
          <source>Similarly, this will silence warnings from this module, and preserve the default behaviour:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b2e4fdd23d41dfea9d8225a12a424a715230bb" translate="yes" xml:space="preserve">
          <source>Similarly, this:</source>
          <target state="translated">Точно так же:</target>
        </trans-unit>
        <trans-unit id="d1bdda2be136926ef9a893301ff91d18747c507f" translate="yes" xml:space="preserve">
          <source>Similarly, to copy an anonymous hash, you can use</source>
          <target state="translated">Точно так же,чтобы скопировать анонимный хэш,ты можешь использовать</target>
        </trans-unit>
        <trans-unit id="7850beac28db723d025cfad11fb93ce97e2ced9b" translate="yes" xml:space="preserve">
          <source>Similarly, using &lt;code&gt;$^W&lt;/code&gt; to either disable or enable blocks of code is fundamentally flawed. For a start, say you want to disable warnings in a block of code. You might expect this to be enough to do the trick:</source>
          <target state="translated">Точно так же использование &lt;code&gt;$^W&lt;/code&gt; для отключения или включения блоков кода в корне ошибочно. Для начала предположим, что вы хотите отключить предупреждения в блоке кода. Вы можете ожидать, что этого будет достаточно, чтобы добиться цели:</target>
        </trans-unit>
        <trans-unit id="2664530a7df4eabf1ac2e9d54c9f06c6deee6b41" translate="yes" xml:space="preserve">
          <source>Similarly, with this code</source>
          <target state="translated">Аналогично,с этим кодом</target>
        </trans-unit>
        <trans-unit id="b0293d771b0de8656e1c85bf1faad486bf545599" translate="yes" xml:space="preserve">
          <source>Similarly, you may use these I/O layers on output streams to automatically convert Unicode to the specified encoding when it is written to the stream. For example, the following snippet copies the contents of the file &quot;text.jis&quot; (encoded as ISO-2022-JP, aka JIS) to the file &quot;text.utf8&quot;, encoded as UTF-8:</source>
          <target state="translated">Аналогичным образом,вы можете использовать эти слои ввода/вывода в выходных потоках для автоматического преобразования Юникода в указанную кодировку при его записи в поток.Например,следующий фрагмент копирует содержимое файла &quot;text.jis&quot; (в кодировке ISO-2022-JP,он же JIS)в файл &quot;text.utf8&quot;,в кодировке UTF-8:</target>
        </trans-unit>
        <trans-unit id="a9548affa7e4acbe2593b885978a8755658bc00f" translate="yes" xml:space="preserve">
          <source>Similary to</source>
          <target state="translated">Симиларию</target>
        </trans-unit>
        <trans-unit id="d038c3b0b4f25db2b86d3e73c906bad029553a54" translate="yes" xml:space="preserve">
          <source>Simon Cozens &amp;lt;simon AT brecon DOT co DOT uk&amp;gt; - Being there to answer zillions of annoying questions</source>
          <target state="translated">Саймон Козенс &amp;lt;simon AT brecon DOT co DOT uk&amp;gt; - быть там, чтобы ответить на бесчисленное количество раздражающих вопросов</target>
        </trans-unit>
        <trans-unit id="db6a8ce8a7b56a60b15a1e81509c2149cf995dfb" translate="yes" xml:space="preserve">
          <source>Simon Cozens and Wolfgang Laun.</source>
          <target state="translated">Саймон Козенс и Вольфганг Лаун.</target>
        </trans-unit>
        <trans-unit id="911ebed02457e684e0b32e14a35ae78fa21f67e0" translate="yes" xml:space="preserve">
          <source>Simon Cozens, &lt;code&gt;simon@cpan.org&lt;/code&gt;</source>
          <target state="translated">Саймон Козенс, &lt;code&gt;simon@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c339f709f7b43634c7fbcb9cbd9eccd0f9cc3ac2" translate="yes" xml:space="preserve">
          <source>Simple Mail Transfer Protocol Client</source>
          <target state="translated">Простой клиент протокола почтовой передачи</target>
        </trans-unit>
        <trans-unit id="0b80f19dce22ed4ff1ea0703ed5ec7dc2f2434d5" translate="yes" xml:space="preserve">
          <source>Simple Perl scalars (any scalar that is not a reference) are the most difficult objects to encode: JSON::PP will encode undefined scalars as JSON &lt;code&gt;null&lt;/code&gt; values, scalars that have last been used in a string context before encoding as JSON strings, and anything else as number value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee009eadcb45691f1eecbe3d87057665862d1bd" translate="yes" xml:space="preserve">
          <source>Simple Scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f59937d173df040577971290f0e1cacd671a9c" translate="yes" xml:space="preserve">
          <source>Simple Statements</source>
          <target state="translated">Простые утверждения</target>
        </trans-unit>
        <trans-unit id="84ffc80b7ca3fcee70bdb32bddd613a718e0b12c" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;perlfunc#tie&quot;&gt;&quot;tie&quot; in perlfunc&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;&quot;COOKBOOK&quot;&lt;/a&gt; examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd89bedbaeb791041cff4fe148dbfde653b95d00" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;COOKBOOK&lt;/a&gt; examples below.</source>
          <target state="translated">Простое присваивание не является перегруженным ( для &lt;a href=&quot;#Copy-Constructor&quot;&gt;конструктора копирования&lt;/a&gt; используется клавиша &lt;code&gt;'='&lt;/code&gt; ). В Perl есть способ &lt;a href=&quot;#COOKBOOK&quot;&gt;назначать&lt;/a&gt; объекту все, что вы хотите, но для этого нужно использовать функцию tie (), а не перегрузку - см. Ниже примеры &lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; и COOKBOOK .</target>
        </trans-unit>
        <trans-unit id="8605c0b660faa7b5703ee9847774a8d43e86ed05" translate="yes" xml:space="preserve">
          <source>Simple delegatees for misc parameters derived from distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94eac8882772ef72bea55863ece1200dedf301b7" translate="yes" xml:space="preserve">
          <source>Simple enough. Now compile and run:</source>
          <target state="translated">Достаточно просто.Теперь компилируй и запускай:</target>
        </trans-unit>
        <trans-unit id="ba971c7177cc7a0849b0167e7f954b49b5a4aaf2" translate="yes" xml:space="preserve">
          <source>Simple examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764eff41a5149cfadde2c6b72cdd2e21368ca43b" translate="yes" xml:space="preserve">
          <source>Simple examples to open a file for reading:</source>
          <target state="translated">Простые примеры для открытия файла для чтения:</target>
        </trans-unit>
        <trans-unit id="8bbdbbffdc1d0c057f0470ba8573e7773f1d085a" translate="yes" xml:space="preserve">
          <source>Simple interface to Locale::Maketext::Lexicon</source>
          <target state="translated">Простой интерфейс к Местоположение::Макетакст::Лексикон</target>
        </trans-unit>
        <trans-unit id="7b8b7240c656011159c28f4357d2c8a844877df6" translate="yes" xml:space="preserve">
          <source>Simple matching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a65de4566d838633c7cfe8d2f3954d6165e02e" translate="yes" xml:space="preserve">
          <source>Simple methods for simple tasks</source>
          <target state="translated">Простые методы для простых задач</target>
        </trans-unit>
        <trans-unit id="107deb5b12e566d319794bc7ce2d8bcc70c508d0" translate="yes" xml:space="preserve">
          <source>Simple options</source>
          <target state="translated">Простые опции</target>
        </trans-unit>
        <trans-unit id="b3c11d00394d5efd68e3089882ea99ef88db2b49" translate="yes" xml:space="preserve">
          <source>Simple subroutine to insert the macros defined by the macro attribute into the Makefile.</source>
          <target state="translated">Простая подпрограмма для вставки макросов,определенных атрибутом макроса,в Makefile.</target>
        </trans-unit>
        <trans-unit id="adadcc42c8be98750be33acd4bfac36bd737f651" translate="yes" xml:space="preserve">
          <source>Simple substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f78d32b59c097fb10ad26d36f2e74fdbebe4e64" translate="yes" xml:space="preserve">
          <source>Simple word matching</source>
          <target state="translated">Простое совпадение слов</target>
        </trans-unit>
        <trans-unit id="f7b02d0f94f21913ddb8d295324658b8720d69e0" translate="yes" xml:space="preserve">
          <source>Simple, eh?</source>
          <target state="translated">Просто,да?</target>
        </trans-unit>
        <trans-unit id="5ab4a74caba11b1370fe119fe34f9f5db826dbbf" translate="yes" xml:space="preserve">
          <source>Simple, one-off commits pushed to the 'blead' branch should be simple commits that apply cleanly. In other words, you should make sure your work is committed against the current position of blead, so that you can push back to the master repository without merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee1790ba48c5c5f5aec6b6de12f218c366e78db" translate="yes" xml:space="preserve">
          <source>Simple... Now look:</source>
          <target state="translated">Просто...А теперь смотрите:</target>
        </trans-unit>
        <trans-unit id="6c9330b7a2ff965f7db6cafb9f575b4d58374515" translate="yes" xml:space="preserve">
          <source>Simpler definition of attribute handlers</source>
          <target state="translated">Простое определение обработчиков атрибутов</target>
        </trans-unit>
        <trans-unit id="50c361747016ee3aff5355a6c96f0c2b139551ef" translate="yes" xml:space="preserve">
          <source>Simplest way to do it automatically is to use your version control system's revision number (you are using version control, right?).</source>
          <target state="translated">Самый простой способ сделать это автоматически-использовать номер версии вашей системы контроля версий (вы используете контроль версий,верно?).</target>
        </trans-unit>
        <trans-unit id="68be18029150583164f9438753e32a72fd3e4c87" translate="yes" xml:space="preserve">
          <source>Simplified source filtering</source>
          <target state="translated">Упрощенная фильтрация источников</target>
        </trans-unit>
        <trans-unit id="66f7f6fe24549ec54694a312ab799bde4d89b2f3" translate="yes" xml:space="preserve">
          <source>Simply not portable. Get your lvalue to be of the right type, or maybe use temporary variables, or dirty tricks with unions.</source>
          <target state="translated">Просто не портативный.Получите ваше значение,чтобы быть правильным типом,или,может быть,использовать временные переменные,или грязные трюки с союзами.</target>
        </trans-unit>
        <trans-unit id="20084b93a5f754ce0ccd01de74eb0172d18babfc" translate="yes" xml:space="preserve">
          <source>Simply put:</source>
          <target state="translated">Проще говоря:</target>
        </trans-unit>
        <trans-unit id="991f810db6d12637f2fd5bbddcb5e86f7ab43bb2" translate="yes" xml:space="preserve">
          <source>Simply put: for each extension linked with your Perl executable (determined during its initial configuration on your computer or when adding a new extension), a Perl subroutine is created to incorporate the extension's routines. Normally, that subroutine is named</source>
          <target state="translated">Проще говоря:для каждого расширения,связанного с исполняемым файлом Perl (определяемого во время его первоначальной конфигурации на вашем компьютере или при добавлении нового расширения),создается подпрограмма Perl,включающая процедуры расширения.Обычно,эта подпрограмма имеет имя</target>
        </trans-unit>
        <trans-unit id="86b802f817d8db47f98e358e0df4e43c122569da" translate="yes" xml:space="preserve">
          <source>Simply run</source>
          <target state="translated">Просто бегите</target>
        </trans-unit>
        <trans-unit id="14c3e2e53d9dfb6b8072093e8b927f77f6a76d42" translate="yes" xml:space="preserve">
          <source>Simply says that we're Unix.</source>
          <target state="translated">Просто говорит,что мы Unix.</target>
        </trans-unit>
        <trans-unit id="22a4ed66c623d273a571652cc9ae1a89577a837f" translate="yes" xml:space="preserve">
          <source>Since</source>
          <target state="translated">Since</target>
        </trans-unit>
        <trans-unit id="60dbe9f3bc2001b2c722387a7d49aaabb3da33d1" translate="yes" xml:space="preserve">
          <source>Since # can be used for comments, # must be escaped.</source>
          <target state="translated">Так как#может быть использован для комментариев,#должен быть экранирован.</target>
        </trans-unit>
        <trans-unit id="7f16eb993aa5b4126dadedc6b4f7941b4f104c6b" translate="yes" xml:space="preserve">
          <source>Since 3.26, using &lt;code&gt;-F&lt;/code&gt; as the superuser also implies &lt;code&gt;-U&lt;/code&gt; as opening most files and traversing directories requires privileges that are above the nobody/nogroup level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18dd63133c168a4767fcb87b71a43b938682e1a" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; does a &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ded02f76d7e8f2623d74fdc5f26a66cd0a132c8" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af160de91abb536123124eac1ecabfc37de02e74" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; выполняет &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; это может повлиять на обработчик &lt;code&gt;SIGCHLD&lt;/code&gt; . Подробности смотрите в &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aba59b2cf00e40d21bac4c0a192544510ddcbae0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will also call the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; cannot load files by name, although &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; can:</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; также вызовет метод &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; , фактическое значение для &lt;code&gt;MODULE&lt;/code&gt; должно быть голым словом. То есть, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; не может загружать файлы по имени, хотя &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; может:</target>
        </trans-unit>
        <trans-unit id="73d2921b742823e6f578c98791a72739f4a21337" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">Поскольку &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; выполняет &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; это может повлиять на обработчик &lt;code&gt;SIGCHLD&lt;/code&gt; . Подробности смотрите в &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53cc6266d93eb2a78be0857ad5ecd43af7e2b644" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;Archive::Tar&lt;/code&gt; doesn't change the current directory internally while it is extracting the items in a tarball, all calls to &lt;code&gt;Cwd::cwd()&lt;/code&gt; can be avoided if we can guarantee that the current directory doesn't get changed externally.</source>
          <target state="translated">Поскольку &lt;code&gt;Archive::Tar&lt;/code&gt; не изменяет текущий каталог внутри во время извлечения элементов из архива, всех вызовов &lt;code&gt;Cwd::cwd()&lt;/code&gt; можно избежать, если мы можем гарантировать, что текущий каталог не будет изменен извне.</target>
        </trans-unit>
        <trans-unit id="42aa5efcb3e75000fce11592bd84e59ec314928e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3c7a53144e6a3302e2a2f9e7b6229b194fa174" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">Поскольку &lt;code&gt;SIGINT&lt;/code&gt; и &lt;code&gt;SIGQUIT&lt;/code&gt; игнорируются во время выполнения &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , если вы ожидаете, что ваша программа завершится после получения этих сигналов, вам нужно будет организовать это самостоятельно на основе возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="e4f45d5c1543b43feed600201b8df9285b671829" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">Поскольку &lt;code&gt;SIGINT&lt;/code&gt; и &lt;code&gt;SIGQUIT&lt;/code&gt; игнорируются во время выполнения &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; , если вы ожидаете, что ваша программа завершится после получения этих сигналов, вам нужно будет организовать это самостоятельно на основе возвращаемого значения.</target>
        </trans-unit>
        <trans-unit id="c78eaa920d9b2c6c4c17bb6231c81108ebdc9ea7" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;XSRETURN_*&lt;/code&gt; macros can be used with CODE blocks as well, one can rewrite this example as:</source>
          <target state="translated">Поскольку макросы &lt;code&gt;XSRETURN_*&lt;/code&gt; также могут использоваться с блоками CODE, этот пример можно переписать как:</target>
        </trans-unit>
        <trans-unit id="ddeb2559b4a933dbff6f6bd50711c077c5250a4a" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;use&lt;/code&gt; will also call the &lt;code&gt;import&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;use&lt;/code&gt; cannot load files by name, although &lt;code&gt;require&lt;/code&gt; can:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae1fb90f2e2a999e504c7cb0f71e0777fa542ca" translate="yes" xml:space="preserve">
          <source>Since CPAN.pm version 1.88_51 modules declared as &lt;code&gt;build_requires&lt;/code&gt; by a distribution are treated differently depending on the config variable &lt;code&gt;build_requires_install_policy&lt;/code&gt; . By setting &lt;code&gt;build_requires_install_policy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, such a module is not installed. It is only built and tested, and then kept in the list of tested but uninstalled modules. As such, it is available during the build of the dependent module by integrating the path to the &lt;code&gt;blib/arch&lt;/code&gt; and &lt;code&gt;blib/lib&lt;/code&gt; directories in the environment variable PERL5LIB. If &lt;code&gt;build_requires_install_policy&lt;/code&gt; is set ti &lt;code&gt;yes&lt;/code&gt; , then both modules declared as &lt;code&gt;requires&lt;/code&gt; and those declared as &lt;code&gt;build_requires&lt;/code&gt; are treated alike. By setting to &lt;code&gt;ask/yes&lt;/code&gt; or &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; , CPAN.pm asks the user and sets the default accordingly.</source>
          <target state="translated">Начиная с версии 1.88_51 CPAN.pm модули, объявленные &lt;code&gt;build_requires&lt;/code&gt; как build_requires , обрабатываются по-разному в зависимости от переменной конфигурации &lt;code&gt;build_requires_install_policy&lt;/code&gt; . Если установить для &lt;code&gt;build_requires_install_policy&lt;/code&gt; значение &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; , такой модуль не будет установлен. Он только собирается и тестируется, а затем сохраняется в списке протестированных, но не установленных модулей. Таким образом, он доступен во время сборки зависимого модуля путем интеграции пути к &lt;code&gt;blib/arch&lt;/code&gt; и &lt;code&gt;blib/lib&lt;/code&gt; в переменной среды PERL5LIB. Если &lt;code&gt;build_requires_install_policy&lt;/code&gt; установлен ти &lt;code&gt;yes&lt;/code&gt; , то оба модуля объявлены как &lt;code&gt;requires&lt;/code&gt; и те, что объявлены как &lt;code&gt;build_requires&lt;/code&gt; , обрабатываются одинаково. Установив &lt;code&gt;ask/yes&lt;/code&gt; или &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; , CPAN.pm спрашивает пользователя и соответственно устанавливает значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="92bd94b93ba7aa98da9b694cc55416c0183aa164" translate="yes" xml:space="preserve">
          <source>Since DLLs may be loaded at run time, to have the same mechanism for DLLs one needs to have the address range of</source>
          <target state="translated">Поскольку DLL могут загружаться во время выполнения,для того чтобы иметь тот же механизм для DLL,необходимо иметь диапазон адресов в диапазоне</target>
        </trans-unit>
        <trans-unit id="b8d7eab0940cbd19c7e5c0a0410f1af9f2b70a97" translate="yes" xml:space="preserve">
          <source>Since Emacs version 19 patchlevel 22 or so, there have been both a perl-mode.el and support for the Perl debugger built in. These should come with the standard Emacs 19 distribution.</source>
          <target state="translated">Начиная с версии Emacs 19 patchlevel 22 или около того,существует как perl-mode.el,так и поддержка встроенного отладчика Perl.Они должны поставляться со стандартным дистрибутивом Emacs 19.</target>
        </trans-unit>
        <trans-unit id="ae992899a872766d28cfb8b692b2e7f7ecf24212" translate="yes" xml:space="preserve">
          <source>Since File::Spec is object oriented, subroutines should not be called directly, as in:</source>
          <target state="translated">Так как File::Spec является объектно-ориентированным,то подпрограммы не должны вызываться напрямую,как в случае с File::Spec:</target>
        </trans-unit>
        <trans-unit id="58330cb00aafa72e888d41a23aef159c39b70e0c" translate="yes" xml:space="preserve">
          <source>Since INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine, this may be shortened to:</source>
          <target state="translated">Поскольку секции INPUT позволяют объявлять переменные C,которые не появляются в списке параметров подпрограммы,это может быть сокращено до:</target>
        </trans-unit>
        <trans-unit id="45546e69c804ad74560b03b1bfa0ada21545dbab" translate="yes" xml:space="preserve">
          <source>Since Math::BigInt and BigFloat also overload the normal math operations, the following line will still work:</source>
          <target state="translated">Так как математика::BigInt и BigFloat также перегружают обычные математические операции,следующая строка все равно будет работать:</target>
        </trans-unit>
        <trans-unit id="1a22aa5b5825f973b9ba76849397ffcf019b0d3e" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;&quot;&lt;i&gt;perl_.exe&lt;/i&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdb84eddf5f43124818a551b78d4d19bef89ac6" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt;.</source>
          <target state="translated">Поскольку порт Perl для OS / 2 использует замечательную среду EMX, он может запускаться (и создавать расширения и, возможно, создаваться сам) в любой среде, в которой может работать EMX. Текущий список - это DOS, DOS-inside-OS / 2, Win0.3 *, Win0.95 и WinNT. Из многих разновидностей perl работает только один, см. &lt;a href=&quot;#perl_.exe&quot;&gt;Perl_.exe&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6084ebce66f9d95008fbd76add0c4721f5880c4b" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt; , it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="translated">Поскольку PERL_SYS_INIT3 () может изменять &lt;code&gt;env&lt;/code&gt; , может быть более подходящим предоставить &lt;code&gt;env&lt;/code&gt; в качестве аргумента для perl_parse ().</target>
        </trans-unit>
        <trans-unit id="f7f8af64efb04a46b462c34b5604a1102a5d4309" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt;, it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908c64d54ba36fa8efadd65bbb91e193ec071dc5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.004, however, this situation is a special case and Perl creates the hash key only when you make the assignment:</source>
          <target state="translated">Однако,поскольку Perl 5.004 является особым случаем,Perl создает хэш-ключ только при выполнении задания:</target>
        </trans-unit>
        <trans-unit id="a9ff67b0f4d57746c4f60694c82d05a6c7b9009b" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token is available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'current_sub'&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; . It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="translated">Начиная с Perl 5.16.0, токен &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; доступен при &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'current_sub'&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; . Он будет оценивать ссылку на выполняющуюся в данный момент подпрограмму, что позволяет выполнять рекурсивные вызовы без знания имени вашей подпрограммы.</target>
        </trans-unit>
        <trans-unit id="d1a3d1fb600646bfa2800199a2796c986b7ed30e" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;__SUB__&lt;/code&gt; token is available under &lt;code&gt;use feature 'current_sub'&lt;/code&gt; and &lt;code&gt;use 5.16.0&lt;/code&gt;. It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fae0c1bd1740225eb42eb57769894f0dc25fdf8" translate="yes" xml:space="preserve">
          <source>Since Perl 5.18, the option &lt;code&gt;--libpods&lt;/code&gt; has been deprecated, and using this option did not do anything other than producing a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd0c9118f331aebc3c70bcab476c8b369f379f5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.26, this functionality with the extra parameter has been available by using a corresponding macro to each one of these, and whose name is formed by appending &lt;code&gt;_safe&lt;/code&gt; to the base name. There is no change to the functionality of those. For example, &lt;code&gt;isDIGIT_utf8_safe&lt;/code&gt; corresponds to &lt;code&gt;isDIGIT_utf8&lt;/code&gt;, and both now behave identically. All are documented in &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd1865b1bb90979ee802c45310e91e7b7152674" translate="yes" xml:space="preserve">
          <source>Since Perl 5.6.1 the special variables @- and @+ can functionally replace $`, $&amp;amp; and $'. These arrays contain pointers to the beginning and end of each match (see perlvar for the full story), so they give you essentially the same information, but without the risk of excessive string copying.</source>
          <target state="translated">Начиная с Perl 5.6.1 специальные переменные @ - и @ + могут функционально заменять $ `, $ &amp;amp; и $ '. Эти массивы содержат указатели на начало и конец каждого совпадения (см. Perlvar для полной истории), поэтому они дают вам практически ту же информацию, но без риска чрезмерного копирования строк.</target>
        </trans-unit>
        <trans-unit id="0c3b5811fc581b714a97d98184d154d442e77a68" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8, thread programming has been available using a model called</source>
          <target state="translated">Начиная с версии Perl 5.8,потоковое программирование доступно с использованием модели,называемой</target>
        </trans-unit>
        <trans-unit id="8b1528960c7f653f3987ab48deb0e1d4226f3c72" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0 a file handle referring to a string can be created by calling open with a reference to that string instead of the filename. This file handle can then be used to read from or write to the string:</source>
          <target state="translated">Начиная с версии Perl 5.8.0,файловый менеджер,ссылающийся на строку,может быть создан путем вызова open со ссылкой на эту строку,а не с именем файла.Этот файл-обработчик может быть использован для чтения или записи в строку:</target>
        </trans-unit>
        <trans-unit id="e4d8eb9b8b02c94511ca94b8a0081bc372e591a2" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;http://man.he.net/man2/utime&quot;&gt;utime(2)&lt;/a&gt; syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9a4f3a496c7e0b6fbb6d2a333860ae199a0774" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">Начиная с Perl 5.8.0, если первые два элемента списка являются &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , системный вызов utime (2) из ​​вашей библиотеки C вызывается с нулевым вторым аргументом. В большинстве систем это установит время доступа и модификации файла к текущему времени (т. Е. Эквивалентно приведенному выше примеру) и будет работать даже с файлами, которые вам не принадлежат, при условии, что у вас есть разрешение на запись:</target>
        </trans-unit>
        <trans-unit id="82732a952fbe092bd928ea5f2a3dfaabc967f5cd" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">Начиная с Perl 5.8.0, если первые два элемента списка являются &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , системный вызов utime (2) из ​​вашей библиотеки C вызывается с нулевым вторым аргументом. В большинстве систем это установит время доступа и модификации файла к текущему времени (т. Е. Эквивалентно приведенному выше примеру) и будет работать даже с файлами, которые вам не принадлежат, при условии, что у вас есть разрешение на запись:</target>
        </trans-unit>
        <trans-unit id="e51f3522d03a5b3a232bf4033ea382564508f931" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, signals have been made safer in Perl by postponing their handling until the interpreter is in a</source>
          <target state="translated">Начиная с версии Perl 5.8.0,сигналы в Perl стали более безопасными,отложив их обработку до тех пор,пока интерпретатор не будет находиться в режиме</target>
        </trans-unit>
        <trans-unit id="f2d46e3f9d2d01548c43a50c625a8e637b891700" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="translated">Начиная с Perl 5.8.0, вы также можете использовать &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; для каналов форму списка . Это предпочтительнее, если вы не хотите, чтобы оболочка интерпретировала метасимволы, которые могут быть в вашей командной строке.</target>
        </trans-unit>
        <trans-unit id="718a678663da5c7f9393577cff7fa0dc58227371" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;open&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3480b6dbc008fbf05d437030616ffbd60db1a205" translate="yes" xml:space="preserve">
          <source>Since Perl 5.9.5</source>
          <target state="translated">Начиная с Perl 5.9.5</target>
        </trans-unit>
        <trans-unit id="ce3c317911640225ca1493860827b3b6d9d6a56f" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER&lt;/code&gt;, but Perl also doesn't do anything with them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83749785256b2bd98e45a0b0907ae739a924facc" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; , but Perl also doesn't know anything about them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="translated">Поскольку Perl в настоящее время ничего не делает с категорией &lt;code&gt;LC_MONETARY&lt;/code&gt; , указание &lt;code&gt;:monetary&lt;/code&gt; практически ничего не делает. В некоторых системах есть другие категории, такие как &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; , но Perl также ничего о них не знает, и нет способа указать их в аргументах этой прагмы.</target>
        </trans-unit>
        <trans-unit id="7873f3b494192ca12067337abef4df445eb77998" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; operator, using &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; is used standalone:</source>
          <target state="translated">Поскольку Perl может компилировать шаблон в момент выполнения оператора &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; , использование &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; может иметь преимущества в скорости в некоторых ситуациях, особенно если результат &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; используется автономно:</target>
        </trans-unit>
        <trans-unit id="7ee8fc05b2f265e0275f90b02e962f3d6fb61694" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;qr()&lt;/code&gt; operator, using &lt;code&gt;qr()&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;qr()&lt;/code&gt; is used standalone:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a306c8d466811a3ef5f554b084c63b5f925fc7a3" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt; -line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;No Perl script found in input in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="translated">Поскольку Perl обрабатывает символы &lt;code&gt;#!&lt;/code&gt; -line (см. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;ОПИСАНИЕ в perlrun&lt;/a&gt; , &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;переключатели команд в perlrun&lt;/a&gt; , &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;сценарий Perl не найден во вводе в perldiag&lt;/a&gt; ), он должен знать, когда программа</target>
        </trans-unit>
        <trans-unit id="15eed331802dca8328c200227a6895f19cb9da5d" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt;-line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;&quot;No Perl script found in input&quot; in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7890be1aa1eaa7cb9334a73bda7962f1d481f1" translate="yes" xml:space="preserve">
          <source>Since Perl recognizes a Unicode Byte Order Mark at the start of files as signaling that the file is Unicode encoded as in UTF-16 (whether big-endian or little-endian) or UTF-8, Pod parsers should do the same. Otherwise, the character encoding should be understood as being UTF-8 if the first highbit byte sequence in the file seems valid as a UTF-8 sequence, or otherwise as CP-1252 (earlier versions of this specification used Latin-1 instead of CP-1252).</source>
          <target state="translated">Так как Perl распознает Unicode Byte Order Mark в начале файлов как сигнал о том,что файл закодирован в кодировке Unicode как в UTF-16 (big-endian или little-endian)или UTF-8,парсеры Pod должны делать то же самое.Иначе под кодировкой символов следует понимать UTF-8,если первая стартовая байтовая последовательность в файле кажется действительной как последовательность UTF-8,или иначе-как CP-1252 (в более ранних версиях этой спецификации вместо CP-1252 использовалась латиница-1).</target>
        </trans-unit>
        <trans-unit id="ca8e547d2675a51d87227fd5471e1262dc702174" translate="yes" xml:space="preserve">
          <source>Since Perl v5.10.0 includes the version.pm comparison logic anyways, you don't need to do anything at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b73dcb8330d72308d60b51669745466fec012ac" translate="yes" xml:space="preserve">
          <source>Since Perl v5.22.0, calls to this function are optimized out on ASCII platforms, so there is no performance hit in using it there.</source>
          <target state="translated">Начиная с версии Perl v5.22.0,вызовы этой функции оптимизированы на ASCII-платформах,поэтому при ее использовании не наблюдается падения производительности.</target>
        </trans-unit>
        <trans-unit id="3b795b95acb54fe26d52c3d9e0c84f28d54d781c" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may also be alphanumeric strings preceded by a caret. These must all be written in the form &lt;code&gt;${^Foo}&lt;/code&gt;; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is considered to be a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt;'s. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (caret-underscore). No name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9077183204414786a18b0b5b41280a8b58d8fe93" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may be alphanumeric strings that begin with a caret (or a control character, but this form is deprecated). These variables must be written in the form &lt;code&gt;${^Foo}&lt;/code&gt; ; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt; 's. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (control-underscore or caret-underscore). No control-character name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="translated">Начиная с Perl v5.6.0, имена переменных Perl могут быть буквенно-цифровыми строками, которые начинаются с символа вставки (или управляющего символа, но эта форма устарела). Эти переменные должны быть записаны в виде &lt;code&gt;${^Foo}&lt;/code&gt; ; фигурные скобки не являются обязательными. &lt;code&gt;${^Foo}&lt;/code&gt; обозначает скалярную переменную, имя которой - control- &lt;code&gt;F&lt;/code&gt; , за которым следуют два &lt;code&gt;o&lt;/code&gt; . Эти переменные зарезервированы Perl для будущих специальных применений, за исключением тех, которые начинаются с &lt;code&gt;^_&lt;/code&gt; (элемент управления-подчеркивание или знак подчеркивания-вставки). Имя управляющего символа, начинающееся с &lt;code&gt;^_&lt;/code&gt; не получит особого значения в любой будущей версии Perl; поэтому такие имена можно безопасно использовать в программах. Сам &lt;code&gt;$^_&lt;/code&gt; , однако,</target>
        </trans-unit>
        <trans-unit id="33f810cef075561e9d829f100d7d5982e746f4f2" translate="yes" xml:space="preserve">
          <source>Since PodParser-1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="translated">Начиная с PodParser-1.24 модуль &lt;b&gt;Pod :: Checker&lt;/b&gt; использует только метод &lt;b&gt;poderror&lt;/b&gt; для вывода ошибок и предупреждений. Итоговый вывод (например, &amp;laquo;Синтаксис Pod OK&amp;raquo;) был удален из модуля и включен в &lt;b&gt;podchecker&lt;/b&gt; (сценарий). Это позволяет пользователям &lt;b&gt;Pod :: Checker&lt;/b&gt; полностью контролировать поведение вывода. Пользователи &lt;b&gt;podchecker&lt;/b&gt; (скрипта) получают известное поведение.</target>
        </trans-unit>
        <trans-unit id="25c4aa2f7c7ea22cd03f6256eb0cf383feb5378c" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;B::Deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;eval&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;eval&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62ae1b79550d7e8d8b071446dadbd144fa9a44a" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="translated">Начиная с версии Storable 2.05, ссылки CODE могут быть сериализованы с помощью &lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt; . Чтобы включить эту функцию, установите для &lt;code&gt;$Storable::Deparse&lt;/code&gt; истинное значение. Чтобы включить десериализацию, &lt;code&gt;$Storable::Eval&lt;/code&gt; должно быть установлено в истинное значение. Имейте в виду, что десериализация выполняется с помощью &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , что опасно, если файл Storable содержит вредоносные данные. Вы можете установить &lt;code&gt;$Storable::Eval&lt;/code&gt; как ссылку на подпрограмму, которая будет использоваться вместо &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . См. Ниже пример использования &lt;a href=&quot;safe&quot;&gt;ячейки Safe&lt;/a&gt; для десериализации ссылок CODE.</target>
        </trans-unit>
        <trans-unit id="c88a8ad5ec93e93fc48a98cd339628a0d0dbcb2e" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;Encode::Unicode::UTF7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0441a16b2e74d4d0e51c5a02d816d3fcef92571" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;unicode/utf7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="translated">Поскольку UTF-7 представляет собой 7-битную (повторно) закодированную версию UTF-16BE, она не является частью схемы кодирования символов Unicode. Это отдельно реализовано в Encode :: Unicode :: UTF7. Подробнее см. &lt;a href=&quot;unicode/utf7&quot;&gt;Encode :: Unicode :: UTF7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2162d18e9f113918db80108542b383e4720b61a0" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="translated">Поскольку правила Unicode не определены в этих кодовых точках, если с ними выполняется операция, определенная в Unicode, Perl использует то, что мы считаем разумными, хотя обычно предупреждает, используя категорию &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; . Например, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; сгенерирует такое предупреждение, вернув входной параметр в качестве результата, поскольку Perl определяет верхний регистр каждой кодовой точки, отличной от Unicode, как саму кодовую точку. (Все операции изменения регистра, а не только заглавные, работают таким образом.)</target>
        </trans-unit>
        <trans-unit id="e37eae9f276840962a41c4b116e9f1cbc6df456a" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;uc(&quot;\x{11_0000}&quot;)&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7285a56d9c4d213c9ad280d3cdcf143edd27d7d8" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; . Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="translated">Поскольку VMS отслеживает файлы по иной схеме , чем Unix, это не представляется возможным представлять идентификатор файла в &lt;code&gt;st_dev&lt;/code&gt; и &lt;code&gt;st_ino&lt;/code&gt; полой &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; . Однако Perl старается изо всех сил, и значения, которые он использует, вряд ли будут одинаковыми для двух разных файлов. Однако мы не можем этого гарантировать, поэтому будьте осторожны, скриптор.</target>
        </trans-unit>
        <trans-unit id="f97165e0cc621ecf8ede47b3bb388f24e3bbd9ef" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct stat&lt;/code&gt;. Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5a9b6174ae871df152be709da101732e21f32c" translate="yes" xml:space="preserve">
          <source>Since Windows has nothing as simple as an executable bit, we check the file extension.</source>
          <target state="translated">Поскольку Windows не имеет ничего настолько простого,как исполняемый бит,мы проверяем расширение файла.</target>
        </trans-unit>
        <trans-unit id="fd9730169823a0770803a5925e2496af06ca17b1" translate="yes" xml:space="preserve">
          <source>Since a TODO test does not need a reason, this function can return an empty string even when inside a TODO block. Use &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; to determine if you are currently inside a TODO block.</source>
          <target state="translated">Поскольку для теста TODO причина не нужна, эта функция может возвращать пустую строку даже внутри блока TODO. Используйте &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; чтобы определить, находитесь ли вы в данный момент внутри блока TODO.</target>
        </trans-unit>
        <trans-unit id="9ae46893bafbcba3b5e81c0b6866dc9c42e9443c" translate="yes" xml:space="preserve">
          <source>Since a wide character does not fit into a byte, the Digest::SHA routines croak if they encounter one. Whereas if a Unicode string contains no wide characters, the module accepts it quite happily. The following code illustrates the two cases:</source>
          <target state="translated">Так как широкий символ не помещается в байт,Digest::SHA рутина кричит,если они столкнутся с одним из них.В то время как если строка Юникода не содержит широких символов,модуль принимает это довольно счастливо.Следующий код иллюстрирует эти два случая:</target>
        </trans-unit>
        <trans-unit id="cf5ecd8beadbfc6894afc9b33f8c568a935ac82c" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="translated">Поскольку все директивы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; выполняются во время компиляции, единственный способ изменить перегрузку во время выполнения - это</target>
        </trans-unit>
        <trans-unit id="993a10b235330ad1f20f4c41c806f9d2c3a4329f" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;use&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121e9d461e86db932f5cbbcefdf834cbc71c32ee" translate="yes" xml:space="preserve">
          <source>Since all numbers are not objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes you independent on the fact that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">Поскольку все числа не являются объектами,вы можете использовать все функции,которые являются частью BigInt или BigFloat API.Однако разумно использовать только нотацию bxxx(),а не fxxx().Это делает вас независимым от того,что базовый объект может превратиться в класс,отличный от BigFloat.</target>
        </trans-unit>
        <trans-unit id="a8ab3cbd0a89b8927ddf254335c455bf7a9e0853" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt API. You can only use the bxxx() notation, and not the fxxx() notation, though.</source>
          <target state="translated">Поскольку все числа теперь являются объектами,вы можете использовать все функции,которые являются частью BigInt API.Однако,вы можете использовать только нотацию bxxx(),а не fxxx().</target>
        </trans-unit>
        <trans-unit id="4e2f7ef257d55f0fed05e16ea09bffefc9e8b92c" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes it possible that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">Поскольку все числа теперь являются объектами,вы можете использовать все функции,которые являются частью BigInt или BigFloat API.Однако разумно использовать только нотацию bxxx(),а не fxxx().Это делает возможным,что базовый объект может превратиться в класс,отличный от BigFloat.</target>
        </trans-unit>
        <trans-unit id="6baa6e390f30e8a9126d448dab3ed477bfa1776f" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; , it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="translated">Поскольку выражение &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; - это просто сокращение от &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; , предполагается, что перегруженные константные строки снабжены разумным перегруженным оператором цепочки, иначе будут получены абсурдные результаты. Точно так же отрицательные числа рассматриваются как отрицание положительных констант.</target>
        </trans-unit>
        <trans-unit id="9eab2e484706387d3cb0dc782cf2ac19206003e5" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt;, it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad22ba0685e5d4fac9ab43140e5e8b95922e320" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek
hlagh / ]&lt;/code&gt; ) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; ). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="translated">Поскольку любой скаляр может быть передан как шаблон, можно реализовать механизм, который что-то делает с массивом ( &lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt; ) или с нестроковой формой скомпилированного регулярного выражения ( &lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; ). Собственный движок Perl всегда будет структурировать все, используя приведенный выше фрагмент, но это не означает, что другие движки должны это делать.</target>
        </trans-unit>
        <trans-unit id="a96aedcf3c01c8994f2ad1304c88bcd0b989eae9" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt;) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt;). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641d084a3985af991bd9e2608e23022b03d9ab2f" translate="yes" xml:space="preserve">
          <source>Since blessed objects are actually stored as RV's, it is useful to use the typemap features to preprocess parameters and extract the actual SV stored within the blessed RV. See the sample for T_PTROBJ_SPECIAL below.</source>
          <target state="translated">Так как благословенные объекты на самом деле хранятся как RV,полезно использовать возможности типовой карты для препроцессирования параметров и извлечения действительного SV,хранящегося в благословенном RV.См.пример для T_PTROBJ_SPECIAL ниже.</target>
        </trans-unit>
        <trans-unit id="8c4a595ff52b120e783068a746cfa5bbb3e02fd1" translate="yes" xml:space="preserve">
          <source>Since changing a slice changes the original array or hash that it's slicing, a &lt;code&gt;foreach&lt;/code&gt; construct will alter some--or even all--of the values of the array or hash.</source>
          <target state="translated">Поскольку изменение среза изменяет исходный массив или хэш, который он разрезает, конструкция &lt;code&gt;foreach&lt;/code&gt; изменит некоторые - или даже все - значения массива или хэша.</target>
        </trans-unit>
        <trans-unit id="fe77918163189e19fb5ee32ad02fe79f3b55c3d3" translate="yes" xml:space="preserve">
          <source>Since code that runs both with and without threads is usually pretty messy, it's best to isolate the thread-specific code in its own module. In our example above, that's what &lt;code&gt;MyMod_threaded&lt;/code&gt; is, and it's only imported if we're running on a threaded Perl.</source>
          <target state="translated">Поскольку код, работающий как с потоками, так и без них, обычно довольно запутан, лучше всего изолировать код, зависящий от потока, в его собственном модуле. В нашем примере выше это &lt;code&gt;MyMod_threaded&lt;/code&gt; , и он импортируется только в том случае, если мы работаем на многопоточном Perl.</target>
        </trans-unit>
        <trans-unit id="7cbe078e4c38d00728f285597cf545219cabca7e" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 pathnames are UTF-8 encoded.</source>
          <target state="translated">Так как патнамы cygwin-1.7 кодируются в кодировке UTF-8.</target>
        </trans-unit>
        <trans-unit id="266d3a18d9d36b211495f4b1c929d7f21c8d9c1c" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 textmounts are deprecated and strongly discouraged.</source>
          <target state="translated">Так как цигвин-1,7 текстовых креплений устарел и настоятельно не поощряется.</target>
        </trans-unit>
        <trans-unit id="d1be23ed029f3a9d2b3315834beff1a066fe092b" translate="yes" xml:space="preserve">
          <source>Since environment variables are normally in all uppercase, no additional special formatting is generally needed; they're glaring enough as it is.</source>
          <target state="translated">Поскольку переменные окружения обычно находятся во всех верхних регистрах,дополнительного специального форматирования,как правило,не требуется;они и так достаточно яркие.</target>
        </trans-unit>
        <trans-unit id="7b1f94f3541d2fa04906c8d0560fd0adccde7ea8" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;&quot;CUSTOM TRANSLATORS&quot;&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;eval&lt;/code&gt;s or &lt;code&gt;require&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af76bf7b4202770a0de3b09fc13dec72dab7c4f4" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORS&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="translated">Поскольку оценка функции перевода (см. &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;ПОЛЬЗОВАТЕЛЬСКИЕ ПЕРЕВОДЧИКИ&lt;/a&gt; ) происходит в середине компиляции (строкового литерала), функция перевода не должна выполнять никаких &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; s. Это ограничение должно быть снято (но имеет низкий приоритет) в будущей версии Perl.</target>
        </trans-unit>
        <trans-unit id="e702e67c36d5f56f32c4ca887c029adc55bb2d25" translate="yes" xml:space="preserve">
          <source>Since file associations don't work everywhere, and there are reportedly bugs with file associations where it does work, the old method of wrapping the perl script to make it look like a regular batch file to the OS, may be used. The install process makes available the &quot;pl2bat.bat&quot; script which can be used to wrap perl scripts into batch files. For example:</source>
          <target state="translated">Так как ассоциации файлов работают не везде,и,как сообщается,есть ошибки с ассоциациями файлов,где они работают,можно использовать старый метод обертки perl скрипта,чтобы он выглядел как обычный пакетный файл для ОС.Процесс установки делает доступным сценарий &quot;pl2bat.bat&quot;,который может быть использован для обёртывания perl скриптов в пакетные файлы.Например:</target>
        </trans-unit>
        <trans-unit id="23fd0e0c0c88af650bd14da915c09ac6e76b1837" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="translated">Поскольку хеш-ключи являются строками, нормализатор по умолчанию не будет различать &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и пустую строку. Это также не сработает, если аргументы функции являются ссылками. Например, рассмотрим функцию &lt;code&gt;g&lt;/code&gt; , которая получает два аргумента: число и ссылку на массив чисел:</target>
        </trans-unit>
        <trans-unit id="5436c585986115252a0eaae5572a50baa0e6e228" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;undef&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1b02458a611387371114bfc83a2b6bef610aa1" translate="yes" xml:space="preserve">
          <source>Since in this example only the hostname was used, the redundant conversion of the port number into a service name may be omitted by passing the &lt;code&gt;NIx_NOSERV&lt;/code&gt; flag.</source>
          <target state="translated">Поскольку в этом примере использовалось только имя хоста, избыточное преобразование номера порта в имя службы можно пропустить, передав флаг &lt;code&gt;NIx_NOSERV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43ba5f496d72ffff6bead4e713df055d0751d289" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (not a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">Так как фактический &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (не &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="55f0899d2eb4523813b05345316dcef5758fc23e" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;do&lt;/code&gt; (not a &lt;code&gt;require&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb621853d8928b75d75f89c40a84cc2ef109eca4" translate="yes" xml:space="preserve">
          <source>Since it is based on Linux, the NAS can run many popular Linux software packages, including Perl. In fact, Synology provides a ready-to-install package for Perl, depending on the version of DSM the installed perl ranges from 5.8.6 on DSM-4.3 to 5.24.0 on DSM-6.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7acf7de7efee5f314675d9545729adcf4f4695" translate="yes" xml:space="preserve">
          <source>Since it is only at the compilation stage that the operator mask applies, controlled access to potentially unsafe operations can be achieved by having a handle to a wrapper subroutine (written outside the compartment) placed into the compartment. For example,</source>
          <target state="translated">Поскольку маска оператора применяется только на этапе компиляции,контролируемый доступ к потенциально опасным операциям может быть достигнут с помощью ручки к подпрограмме-обертке (записанной вне отсека),расположенной в отсеке.Например,</target>
        </trans-unit>
        <trans-unit id="1f11ca56ce1f8e288941a46d45decb0b96762c16" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, Perl warns you if &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; is called in void context and if there is a following statement that isn't &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; are enabled--but you always do that, right?). If you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194e3b48a27a3bdaa4b431c05b89584d736f7041" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">Поскольку использование &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; является распространенной ошибкой , Perl предупреждает вас, если &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; вызывается в контексте void и если есть следующий оператор, который не является &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (если установлено &lt;code&gt;-w&lt;/code&gt; , но вы всегда сделай это, правда?). если ты</target>
        </trans-unit>
        <trans-unit id="84dfc8fed05280b5766bcde26ffe3ad58754f68f" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">Поскольку использование &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; является распространенной ошибкой , Perl предупреждает вас, если &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; вызывается в контексте void и если есть следующий оператор, который не является &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (если установлено &lt;code&gt;-w&lt;/code&gt; , но вы всегда сделай это, правда?). если ты</target>
        </trans-unit>
        <trans-unit id="738084392e8e6e74486d375f063b4666c3458a7c" translate="yes" xml:space="preserve">
          <source>Since just passing an SV to an XS function and copying the data of the SV is not enough to copy the UTF8 flags, even less right is just passing a &lt;code&gt;char *&lt;/code&gt; to an XS function.</source>
          <target state="translated">Поскольку простой передачи SV в функцию XS и копирования данных SV недостаточно для копирования флагов UTF8, еще менее правильным является просто передача &lt;code&gt;char *&lt;/code&gt; в функцию XS.</target>
        </trans-unit>
        <trans-unit id="b9469e3eb840b801f9d7d7208ec99b06d836b6ea" translate="yes" xml:space="preserve">
          <source>Since kernel threading can interrupt a thread at any time, they will uncover some of the implicit locking assumptions you may make in your program. For example, something as simple as &lt;code&gt;$x = $x + 2&lt;/code&gt; can behave unpredictably with kernel threads if &lt;code&gt;$x&lt;/code&gt; is visible to other threads, as another thread may have changed &lt;code&gt;$x&lt;/code&gt; between the time it was fetched on the right hand side and the time the new value is stored.</source>
          <target state="translated">Поскольку потоки ядра могут прервать поток в любое время, они обнаружат некоторые из предположений неявной блокировки, которые вы можете сделать в своей программе. Например, такая простая вещь, как &lt;code&gt;$x = $x + 2&lt;/code&gt; может вести себя непредсказуемо с потоками ядра, если &lt;code&gt;$x&lt;/code&gt; виден другим потокам, поскольку другой поток мог изменить &lt;code&gt;$x&lt;/code&gt; между моментом, когда он был получен с правой стороны, и время сохранения нового значения.</target>
        </trans-unit>
        <trans-unit id="50bf4cd3ab25a16dfb39690f40c89ca9d71697ee" translate="yes" xml:space="preserve">
          <source>Since many pieces of code create tiny subroutines consisting of only a few ops, and since a huge slab would be quite a bit of baggage for those to carry around, the first slab is always very small. To avoid allocating too many slabs for a single CV, each subsequent slab is twice the size of the previous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c7d09052cf4af0cf4ad320357c5a1a11966392" translate="yes" xml:space="preserve">
          <source>Since numbers are actually objects, you can call all the usual methods from BigInt/BigFloat on them. This even works to some extent on expressions:</source>
          <target state="translated">Поскольку номера на самом деле являются объектами,вы можете вызывать на них все обычные методы из BigInt/BigFloat.Это даже в некоторой степени работает на выражениях:</target>
        </trans-unit>
        <trans-unit id="ae2a46b8ade0fb9460587cc2799fe61eb4a8fb37" translate="yes" xml:space="preserve">
          <source>Since perl 5.17.1</source>
          <target state="translated">С 5.17.1</target>
        </trans-unit>
        <trans-unit id="3f51453ac56d21d59ae3e879a25ac51097e95502" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="translated">Поскольку perl (пока?) Не поддерживает постоянные объекты, эти константы &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt; только в секундах, поэтому вы не можете, например, сделать это: &lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt; minutes;</target>
        </trans-unit>
        <trans-unit id="cab6e87a3c1e5785b11343a6d4dd9e12fc5fa718" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;print ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea4faada9587774e63ccd6c739ed955f5067def" translate="yes" xml:space="preserve">
          <source>Since pi &amp;asymp; 355/116 is only accurate to 6 decimal places, you would want to say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6206d48617efe1643080f044370ee3db2757b71" translate="yes" xml:space="preserve">
          <source>Since release 1.77, CPAN.pm has been able to verify cryptographically signed module distributions using Module::Signature. The CPAN modules can be signed by their authors, thus giving more security. The simple unsigned MD5 checksums that were used before by CPAN protect mainly against accidental file corruption.</source>
          <target state="translated">Начиная с версии 1.77,CPAN.pm может проверять криптографически подписанные дистрибутивы модулей,используя Module::Signature.Модули CPAN могут быть подписаны их авторами,что обеспечивает большую безопасность.Простые неподписанные контрольные суммы MD5,которые раньше использовались CPAN,в основном,защищают от случайного повреждения файлов.</target>
        </trans-unit>
        <trans-unit id="f410d2ff83f136d497487286db5d2eccb910e974" translate="yes" xml:space="preserve">
          <source>Since some operations can be automatically generated from others, there is a minimal set of operations that need to be overloaded in order to have the complete set of overloaded operations at one's disposal. Of course, the autogenerated operations may not do exactly what the user expects. The minimal set is:</source>
          <target state="translated">Поскольку одни операции могут быть автоматически сгенерированы из других,существует минимальный набор операций,которые необходимо перегрузить,чтобы иметь в своем распоряжении полный набор перегруженных операций.Конечно,автогенерируемые операции могут не совсем соответствовать ожиданиям пользователя.Минимальный набор:</target>
        </trans-unit>
        <trans-unit id="9e13ee98073f6b6ff77b6bcc87f449d4c9298e6d" translate="yes" xml:space="preserve">
          <source>Since static extensions are incorporated directly into</source>
          <target state="translated">Так как статические удлинители встроены непосредственно в</target>
        </trans-unit>
        <trans-unit id="a88aba659efeb2d72344fd5945ed041580ceab14" translate="yes" xml:space="preserve">
          <source>Since storage is performed recursively, you might want to stuff references to objects that share a lot of common data into a single array or hash table, and then store that object. That way, when you retrieve back the whole thing, the objects will continue to share what they originally shared.</source>
          <target state="translated">Поскольку хранение выполняется рекурсивно,вам может понадобиться запихнуть ссылки на объекты,которые имеют много общих данных в один массив или хэш-таблицу,а затем сохранить этот объект.Таким образом,когда вы вернетесь назад,объекты будут продолжать совместно использовать то,что они изначально разделяли.</target>
        </trans-unit>
        <trans-unit id="9ba4735b13fee2b9416d8bafb7be0fc636ca00de" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b31e0831fe480c7543658e6a5c02d003d2e334" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;).</source>
          <target state="translated">Поскольку подпрограммы, реализующие операторы присваивания, не обязаны изменять свои операнды (см. &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Перегрузочные операции&lt;/a&gt; выше), нам не нужно ничего особенного, чтобы заставить работать &lt;code&gt;+=&lt;/code&gt; и друзья, кроме добавления этих операторов в% subr и определения конструктора копирования (необходимо, поскольку Perl имеет нет возможности узнать, что реализация &lt;code&gt;'+='&lt;/code&gt; не изменяет аргумент - см. &lt;a href=&quot;#Copy-Constructor&quot;&gt;Конструктор копирования&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="39828fbb336c2f70993a4540589d36ff13c1f2fe" translate="yes" xml:space="preserve">
          <source>Since such a construct is equivalent to using an empty string, you are recommended to remove such &lt;code&gt;\N{}&lt;/code&gt; constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24efb6846ccb0dd586c9a2d632cd24665dcacdba" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; method treats the &lt;code&gt;$VERSION&lt;/code&gt; number as a simple numeric value it will regard version 1.10 as lower than 1.9. For this reason it is strongly recommended that you use numbers with at least two decimal places, e.g., 1.09.</source>
          <target state="translated">Поскольку метод &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; обрабатывает число &lt;code&gt;$VERSION&lt;/code&gt; как простое числовое значение, он будет считать версию 1.10 ниже, чем 1.9. По этой причине настоятельно рекомендуется использовать числа как минимум с двумя десятичными знаками, например 1.09.</target>
        </trans-unit>
        <trans-unit id="9984a40959f39d46f91cc9c90e354da67e76965d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;ops&lt;/code&gt; pragma currently has an irreversible global effect, it is only of significant practical use with the &lt;code&gt;-M&lt;/code&gt; option on the command line.</source>
          <target state="translated">Поскольку прагма &lt;code&gt;ops&lt;/code&gt; в настоящее время имеет необратимый глобальный эффект, она имеет существенное практическое применение только с параметром &lt;code&gt;-M&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="953376be0c1beefb5a7844380d81b187b71cbf9b" translate="yes" xml:space="preserve">
          <source>Since the CV takes ownership of its slab when flagged, that flag is never copied when a CV is cloned, as one CV could free a slab that another CV still points to, since forced freeing of ops ignores the reference count (but asserts that it looks right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926a29507017e24c08c49eb96c57773fd03c95dd" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="translated">Поскольку алгоритм MD5 ориентирован на байты, вы можете добавлять только биты, кратные 8, поэтому вы, вероятно, захотите вместо этого просто использовать add (). Метод add_bits () предоставляется для совместимости с другими реализациями дайджеста. См. &lt;a href=&quot;../digest&quot;&gt;Дайджест&lt;/a&gt; для описания аргументов, которые принимает add_bits ().</target>
        </trans-unit>
        <trans-unit id="b38cceb121fc001ce43895b005634147912b7f28" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf00ba41dfb6029d72bbfa314d984c685681962" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is only defined for strings of bytes, it can not be used on strings that contains chars with ordinal number above 255 (Unicode strings). The MD5 functions and methods will croak if you try to feed them such input data:</source>
          <target state="translated">Поскольку алгоритм MD5 определен только для строк в байтах,его нельзя использовать на строках,содержащих символы с порядковым номером выше 255 (строки в Unicode).Функции и методы MD5 перекроются,если попытаться подать им такие входные данные:</target>
        </trans-unit>
        <trans-unit id="4504893c7038fe54de5cf229bf7abc99b79c512f" translate="yes" xml:space="preserve">
          <source>Since the Perl extension DLLs are always loaded with the full path, there is no need to mangle their names in a version-specific ways: their directory already reflects the corresponding version of perl, and @INC takes into account binary compatibility with older version. Starting from &lt;code&gt;5.6.2&lt;/code&gt; the name mangling scheme is fixed to be the same as for Perl 5.005_53 (same as in a popular binary release). Thus new Perls will be able to</source>
          <target state="translated">Поскольку библиотеки DLL расширения Perl всегда загружаются с полным путем, нет необходимости изменять их имена специфическими для версии способами: их каталог уже отражает соответствующую версию perl, а @INC учитывает двоичную совместимость со старой версией. Начиная с версии &lt;code&gt;5.6.2&lt;/code&gt; , схема изменения имен исправлена, чтобы быть такой же, как для Perl 5.005_53 (такой же, как в популярной бинарной версии). Таким образом, новый Perls сможет</target>
        </trans-unit>
        <trans-unit id="d9753e3adbb08c389f10d17cb835e755759949e1" translate="yes" xml:space="preserve">
          <source>Since the VMS linker distinguishes symbols based only on the first 31 characters of their names, it is occasionally necessary to shorten symbol names in order to avoid collisions. (This is especially true of names generated by xsubpp, since prefixes generated by nested package names can become quite long.) &lt;code&gt;ExtUtils::XSSymSet&lt;/code&gt; provides functions to shorten names in a consistent fashion, and to track a set of names to insure that each is unique. While designed with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bc7c77475d3cf936d8648a172f314719ec1f56" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">Поскольку первый символ $ x соответствует регулярному выражению, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; добавляет к списку пустой начальный элемент.</target>
        </trans-unit>
        <trans-unit id="e30d9369cb9f674a0338e525db18f9f146fc0752" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2334de3a289af7777d7979b79868746517ddea3f" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regexp, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">Поскольку первый символ $ x соответствует регулярному выражению, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; добавляет к списку пустой начальный элемент.</target>
        </trans-unit>
        <trans-unit id="dfb32be28d90dd8cfadf42b0da79f140a1aebe0c" translate="yes" xml:space="preserve">
          <source>Since the first character of &lt;code&gt;$x&lt;/code&gt; matched the regexp, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9108eba2d411db85e70e8df1569d830e2a5d25c" translate="yes" xml:space="preserve">
          <source>Since the fork() emulation runs code in multiple threads, extensions calling into non-thread-safe libraries may not work reliably when calling fork(). As Perl's threading support gradually becomes more widely adopted even on platforms with a native fork(), such extensions are expected to be fixed for thread-safety.</source>
          <target state="translated">Так как эмуляция fork()выполняет код в нескольких потоках,то при вызове fork()расширение,вызываемое в не-потокобезопасные библиотеки,может работать ненадежно.По мере того,как поддержка Perl-потоков постепенно становится все более распространенной даже на платформах с родной fork(),ожидается,что такие расширения будут исправлены для потокобезопасной работы.</target>
        </trans-unit>
        <trans-unit id="b5c6d6292298eef29abac825fb611cdb8dbc410b" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , the serial number for each SV allocation is also logged.</source>
          <target state="translated">Поскольку при ведении журнала не используется PerlIO, регистрируются все выделения SV, и при включении ведения журнала никаких дополнительных выделений SV не вводится. Если скомпилирован с &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , серийный номер для каждого распределения SV также регистрируется.</target>
        </trans-unit>
        <trans-unit id="3e539eeb6fc84357572fa6a057c29a86c8133533" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt;, the serial number for each SV allocation is also logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3279571aa6d0a69a5a2abdeb30f262cc44dbbdae" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the substitution operator &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="translated">Поскольку оператор сопоставления &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , оператор подстановки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; и оператор цитирования регулярного выражения &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; заключены в двойные кавычки, вы можете интерполировать переменные в шаблон. См. Ответ на вопрос &amp;laquo;Как указать в кавычках переменную для использования в регулярном выражении?&amp;raquo; Больше подробностей.</target>
        </trans-unit>
        <trans-unit id="7344ea0eab36d0c1c0f9a8a859bf628b21f3791b" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;m//&lt;/code&gt;, the substitution operator &lt;code&gt;s///&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;qr//&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b10458d44f04e31c63c483bc8240735b5e37c7" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="translated">Поскольку нулевой дескриптор файла использует форму с двумя аргументами &lt;a href=&quot;functions/open&quot;&gt;open,&lt;/a&gt; он интерпретирует специальные символы, поэтому, если у вас есть сценарий, подобный этому:</target>
        </trans-unit>
        <trans-unit id="66fb7ce305be412987d9aacf9b06a1422f1fe031" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd81accbd1bb6c167fba1a41e5f2407058ac7a87" translate="yes" xml:space="preserve">
          <source>Since the object is also a hash, you can treat it as one, using it to store data associated with the object. Typically, code inside the class can treat the hash as an accessible data structure, while code outside the class should always treat the object as opaque. This is called &lt;b&gt;encapsulation&lt;/b&gt;. Encapsulation means that the user of an object does not have to know how it is implemented. The user simply calls documented methods on the object.</source>
          <target state="translated">Поскольку объект также является хешем, вы можете рассматривать его как единое целое, используя его для хранения данных, связанных с объектом. Обычно код внутри класса может рассматривать хэш как доступную структуру данных, тогда как код вне класса всегда должен рассматривать объект как непрозрачный. Это называется &lt;b&gt;инкапсуляцией&lt;/b&gt; . Инкапсуляция означает, что пользователю объекта не нужно знать, как он реализован. Пользователь просто вызывает задокументированные методы объекта.</target>
        </trans-unit>
        <trans-unit id="db12f27020b74e90b153b0c7282afabc69308986" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt; ; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt; ), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt; , which is the de facto superset of the original big5.</source>
          <target state="translated">Поскольку исходная кодировка &lt;code&gt;big5&lt;/code&gt; (1984 г.) нигде не поддерживается (системы на основе glibc и DOS используют &lt;code&gt;big5&lt;/code&gt; для обозначения &lt;code&gt;big5-eten&lt;/code&gt; ; Microsoft использует &lt;code&gt;big5&lt;/code&gt; для обозначения &lt;code&gt;cp950&lt;/code&gt; ), было принято сознательное решение о присвоении псевдонима &lt;code&gt;big5&lt;/code&gt; и &lt;code&gt;big5-eten&lt;/code&gt; , что является де-факто надмножество оригинального big5.</target>
        </trans-unit>
        <trans-unit id="d8d087310b96c8a2161d52fb071f50cb14fd5ed5" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt;; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt;), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt;, which is the de facto superset of the original big5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e096824f5ca19792394259581d18c44d0fb48327" translate="yes" xml:space="preserve">
          <source>Since the path separators are different on some operating systems ('/' on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec modules wherever portability is a concern.</source>
          <target state="translated">Так как на некоторых операционных системах разделители путей отличаются (&quot;/&quot; на Unix,&quot;:&quot; на MacPerl и т.д...),мы рекомендуем использовать модули File::Spec везде,где важна переносимость.</target>
        </trans-unit>
        <trans-unit id="8b814beacf19306d64e3fcdb9e9e2ebc37bd2f9a" translate="yes" xml:space="preserve">
          <source>Since the return value of EXPR is executed as a block within the lexical context of the current Perl program, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc1d2d6e3b782b2dd5e1481aef1464f9b2e04bc" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">Поскольку область видимости не была лексической, использование других модулей &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a424c04edb43b51178f65103d1803116d4fd0aaa" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;chr&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b947b7b4bc7b90e1cd94b89023d67ed8fe406b" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; , two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; :</source>
          <target state="translated">Поскольку символы, перечисленные в &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; также должны появляться либо в &lt;code&gt;@EXPORT&lt;/code&gt; , либо в &lt;code&gt;@EXPORT_OK&lt;/code&gt; , предусмотрены две служебные функции, которые позволяют легко добавлять тегированные наборы символов в &lt;code&gt;@EXPORT&lt;/code&gt; или &lt;code&gt;@EXPORT_OK&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="12348ccf02ace58fde57dcb8fdfe6146a5174932" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;, two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1ad4491daa19cab8cfcffcbf76d31fdb6dedaa" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt; -flag as in:</source>
          <target state="translated">Поскольку текст для вставки должен отличаться в &lt;code&gt;bytes&lt;/code&gt; режиме и вне него, функция должна проверять текущее состояние &lt;code&gt;bytes&lt;/code&gt; -flag, как в:</target>
        </trans-unit>
        <trans-unit id="a18ac7a6a5b44dc9939056baa28ada3143807b7e" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt;-flag as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57f88b4da7c64e61f7bcbc6480133424225f899" translate="yes" xml:space="preserve">
          <source>Since the total size of all Perl SIS files once installed is over 2 MB, it is recommended to do the installation into a memory card (drive E:) instead of the C: drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50530d766e72e0b6fff4d2cca6e94d3aad2090a6" translate="yes" xml:space="preserve">
          <source>Since there are relatively few objects in a picture, there are only a few colors, which get looked up over and over again. Memoizing &lt;code&gt;ColorToRGB&lt;/code&gt; sped up the program by several percent.</source>
          <target state="translated">Так как на картинке относительно мало объектов, есть только несколько цветов, которые просматриваются снова и снова. Memoizing &lt;code&gt;ColorToRGB&lt;/code&gt; ускорил работу программы на несколько процентов.</target>
        </trans-unit>
        <trans-unit id="6cb6a83a2f2c3167da777a122214abb67623928e" translate="yes" xml:space="preserve">
          <source>Since there are so many, they are presented in table format with languages and corresponding encoding names by vendors. Note that the table is sorted in order of ISO-8859 and the corresponding vendor mappings are slightly different from that of ISO. See &lt;a href=&quot;http://czyborra.com/charsets/iso8859.html&quot;&gt;http://czyborra.com/charsets/iso8859.html&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29f8659dcd90c4211c87b64479756be9287fa54" translate="yes" xml:space="preserve">
          <source>Since there is a bijection between a point in the 2D plane and a complex number (i.e. the mapping is unique and reciprocal), a complex number can also be uniquely identified with polar coordinates:</source>
          <target state="translated">Поскольку существует смещение между точкой в двумерной плоскости и комплексным числом (т.е.отображение уникально и взаимно пересекается),комплексное число также может быть однозначно идентифицировано с полярными координатами:</target>
        </trans-unit>
        <trans-unit id="bc706817bd3a8e95c1023efd45beb0908b6a5e49" translate="yes" xml:space="preserve">
          <source>Since these aren't legal POSIX class specifications, but are legal bracketed character classes, Perl treats them as the latter. In the first example, it matches the characters &lt;code&gt;&quot;:&quot;&lt;/code&gt;, &lt;code&gt;&quot;[&quot;&lt;/code&gt;, &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;m&quot;&lt;/code&gt;, &lt;code&gt;&quot;n&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3716c24306b4924201a3a983711259349f4d7b7c" translate="yes" xml:space="preserve">
          <source>Since these functions are different for most operating systems, each set of OS specific routines is available in a separate module, including:</source>
          <target state="translated">Поскольку эти функции различны для большинства операционных систем,каждый набор специфических для ОС процедур доступен в отдельном модуле,в том числе:</target>
        </trans-unit>
        <trans-unit id="61e7fa1fca7db47b0de02fb29d8bdc7a036c2ad4" translate="yes" xml:space="preserve">
          <source>Since these macros have side-effects don't use them as arguments to macros that may evaluate their argument several times, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d20e57f802de1056f71e94f07efcc76036480f" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="translated">Поскольку такие вещи, как &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;1 / 3&lt;/code&gt; должны быть представлены с ограниченной точностью, чтобы операция не потребляла все ресурсы, каждая операция производит не более запрошенного количества цифр.</target>
        </trans-unit>
        <trans-unit id="55385d26f11babeaaffc540cfe07e740a0d30a4d" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;sqrt(2)&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a21b989b9d575d7d2eef7cf2bea0c2bc7b6c1e" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the convention has become more and more to use hexadecimal notation for code points. To do this with the recipes and to also sort is a multi-step process, so here, for convenience, is the table from above, re-sorted to be in Code Page 1047 order, and using hex notation.</source>
          <target state="translated">С тех пор,как этот документ был впервые написан,стало все больше и больше использоваться шестнадцатеричная нотация для точек кода.Делать это с рецептами,а также сортировать-это многоступенчатый процесс,поэтому здесь,для удобства,таблица сверху,пересортирована,чтобы быть в порядке кодовой страницы 1047,и использована шестнадцатеричная нотация.</target>
        </trans-unit>
        <trans-unit id="ef4f428bd8f59049b7e023a3a37d2ecfa135c01b" translate="yes" xml:space="preserve">
          <source>Since this is 0.something release, any future releases are almost guaranteed to be binary incompatible. As a sign of this the Symbian symbol exports are kept unfrozen and the .def files fully rebuilt every time.</source>
          <target state="translated">Так как это релиз 0.something,любые будущие релизы почти гарантированно будут бинарно несовместимы.В знак этого,экспорт символов Symbian остается незамороженным,а файлы .def каждый раз полностью перестраиваются.</target>
        </trans-unit>
        <trans-unit id="a29b3865557e1b6dfb498bcdde9cd5a7a83c05b9" translate="yes" xml:space="preserve">
          <source>Since this module is most often used only indirectly from extension &lt;code&gt;Makefile.PL&lt;/code&gt; files, here is an example &lt;code&gt;Makefile.PL&lt;/code&gt; entry to add a library to the build process for an extension:</source>
          <target state="translated">Поскольку этот модуль чаще всего используется только косвенно из файлов &lt;code&gt;Makefile.PL&lt;/code&gt; расширения , вот пример записи &lt;code&gt;Makefile.PL&lt;/code&gt; для добавления библиотеки в процесс сборки для расширения:</target>
        </trans-unit>
        <trans-unit id="01f476f0532c2e2f8ff2160a3485f37336e92c5d" translate="yes" xml:space="preserve">
          <source>Since this module refers to perl core's Unicode database in the directory</source>
          <target state="translated">Так как этот модуль относится к базе данных юникода perl core в каталоге</target>
        </trans-unit>
        <trans-unit id="e87fdde57834ef3e5b68a023cf000c8017fe6842" translate="yes" xml:space="preserve">
          <source>Since this procedure may take quite a long time to complete, it makes sense to &quot;freeze&quot; your CPAN configuration by disabling periodic updates of the local copy of CPAN index: set &lt;code&gt;index_expire&lt;/code&gt; to some big value (I use 365), then save the settings</source>
          <target state="translated">Поскольку эта процедура может занять довольно много времени, имеет смысл &amp;laquo;заморозить&amp;raquo; конфигурацию CPAN, отключив периодические обновления локальной копии индекса CPAN: установите &lt;code&gt;index_expire&lt;/code&gt; на какое-то большое значение (я использую 365), затем сохраните настройки.</target>
        </trans-unit>
        <trans-unit id="db30ab250873c1062c4781e4e7b7fad867ddcab0" translate="yes" xml:space="preserve">
          <source>Since this will lead to issues as described above.</source>
          <target state="translated">Поскольку это приведет к проблемам,описанным выше.</target>
        </trans-unit>
        <trans-unit id="5b8353c61df27001cdfae1689cea0393e824247d" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method:</source>
          <target state="translated">Поскольку потоки также являются подпрограммами, они могут возвращать значения. Чтобы дождаться завершения потока и извлечения любых значений, которые он может вернуть, вы можете использовать метод &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9bad1409df4464c147cc94bb57065c1ad067150c" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;join()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865359543cead83315159b60389211a49302275e" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt; s and &lt;code&gt;HMQ&lt;/code&gt; s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="translated">Поскольку для вызова определенного API OS / 2 необходима правильно инициализированная подсистема &lt;code&gt;Win&lt;/code&gt; , для расширений OS / 2 может потребоваться получение &lt;code&gt;HAB&lt;/code&gt; и &lt;code&gt;HMQ&lt;/code&gt; . Если расширение сделает это само по себе, другое расширение может не инициализироваться.</target>
        </trans-unit>
        <trans-unit id="a707076963b2deddc0e47770d659e4e4346ffd5b" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt;s and &lt;code&gt;HMQ&lt;/code&gt;s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac123183aa461484cfbda02f53a1d46605cce417" translate="yes" xml:space="preserve">
          <source>Since v1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c16cb5be350777f69ddd741df453e37c786546" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;&quot;EXPORTS&quot;&lt;/a&gt;, below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993c2506a3b501e251a227378341211573ee7139" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;EXPORTS&lt;/a&gt;, below.</source>
          <target state="translated">Начиная с v5.6.0, CORE :: glob () в Perl реализован в терминах bsd_glob (). Обратите внимание, что они не используют один и тот же прототип - CORE :: glob () принимает только один аргумент. По историческим причинам CORE :: glob () также разделяет свой аргумент на пробелы, рассматривая его как несколько шаблонов, тогда как bsd_glob () рассматривает их как один шаблон. Но см &lt;code&gt;:bsd_glob&lt;/code&gt; разделе &lt;a href=&quot;#EXPORTS&quot;&gt;ЭКСПОРТ&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="4ad68534057bbff035849577fdc9d02265e92498" translate="yes" xml:space="preserve">
          <source>Since valgrind adds significant overhead, tests will take much longer to run. The valgrind tests support being run in parallel to help with this:</source>
          <target state="translated">Так как valgrind добавляет значительные накладные расходы,испытания займут гораздо больше времени.Тесты Valgrind поддерживают параллельный запуск,чтобы помочь в этом:</target>
        </trans-unit>
        <trans-unit id="cddab41a34bae01a0c375cc55e93affd1f3991b2" translate="yes" xml:space="preserve">
          <source>Since version 1.26.</source>
          <target state="translated">С версии 1.26.</target>
        </trans-unit>
        <trans-unit id="6b04b338e1bf6330ffba84da282f69c260eb86f1" translate="yes" xml:space="preserve">
          <source>Since version 1.29.</source>
          <target state="translated">Начиная с версии 1.29.</target>
        </trans-unit>
        <trans-unit id="90fa8ea868e9b39ffa1222c302c6573df472b992" translate="yes" xml:space="preserve">
          <source>Since version 1.30.</source>
          <target state="translated">С версии 1.30.</target>
        </trans-unit>
        <trans-unit id="b46b7661e42d1c9773df584f5695782bec0ddb2f" translate="yes" xml:space="preserve">
          <source>Since version 1.33.</source>
          <target state="translated">С версии 1.33.</target>
        </trans-unit>
        <trans-unit id="4b40436a29419119d4b78bb2f402e947b823a0e2" translate="yes" xml:space="preserve">
          <source>Since version 1.35.</source>
          <target state="translated">С версии 1.35.</target>
        </trans-unit>
        <trans-unit id="3a2c4273e02619f5ed86c67adac94047a5ca0b70" translate="yes" xml:space="preserve">
          <source>Since version 1.36.</source>
          <target state="translated">С версии 1.36.</target>
        </trans-unit>
        <trans-unit id="828428c704d4b18c115ba845d9cbbc499bb7c74e" translate="yes" xml:space="preserve">
          <source>Since version 1.40.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623e941c243fc86dd1af6f5b5214ee2ab1b54b93" translate="yes" xml:space="preserve">
          <source>Since version 1.42.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0995e25b2df10d5239bf46e745e3af66bfa38ff9" translate="yes" xml:space="preserve">
          <source>Since version 1.44.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85fc2cbdcb50a3cca10d3657cdf7b3d3b631c2f4" translate="yes" xml:space="preserve">
          <source>Since version 1.45.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20faedc97370e5707a72fd235e65122603a7fcc7" translate="yes" xml:space="preserve">
          <source>Since version 1.50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a1a8817578d6cd5474a6b1a0cb684b5b5d0681" translate="yes" xml:space="preserve">
          <source>Since version 1.54.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ea051224d185be13b4a3d24b650c0164b10687" translate="yes" xml:space="preserve">
          <source>Since version 1.55.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefe381ec383217e51c9e6b76ef75c74617d1b90" translate="yes" xml:space="preserve">
          <source>Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully compliant to &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2231&quot;&gt;RFC 2231&lt;/a&gt;. Due to the aforementioned bugs in previous versions of the MIME encoder, there is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991cb9597f8a402ad66b55672ad9333f3ec6c358" translate="yes" xml:space="preserve">
          <source>Since version 2.91_01, JSON::PP uses a different number detection logic that converts a scalar that is possible to turn into a number safely. The new logic is slightly faster, and tends to help people who use older perl or who want to encode complicated data structure. However, this may results in a different JSON text from the one JSON::XS encodes (and thus may break tests that compare entire JSON texts). If you do need the previous behavior for compatibility or for finer control, set PERL_JSON_PP_USE_B environmental variable to true before you &lt;code&gt;use&lt;/code&gt; JSON::PP (or JSON.pm).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2498504f50455260e9635ae498353ef8c9decaca" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the PerlIO I/O library. This enables you to use different encodings per IO channel. For example you may use</source>
          <target state="translated">Начиная с версии 5.8 Perl использует библиотеку ввода/вывода PerlIO.Это позволяет использовать различные кодировки для каждого канала ввода-вывода.Например,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="656ca296455da01a08e031bd90f196ae0bd4a55c" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the new PerlIO on BS2000. This enables you using different encodings per IO channel. For example you may use</source>
          <target state="translated">С версии 5.8 Perl используется новый PerlIO на BS2000.Это позволяет использовать различные кодировки для каждого канала ввода-вывода.Например,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="5792847b18d8585cbe32d073b79aab824b6fbb3d" translate="yes" xml:space="preserve">
          <source>Since version 5.8.0, hashes can be</source>
          <target state="translated">Начиная с версии 5.8.0,хэши могут быть</target>
        </trans-unit>
        <trans-unit id="a80731504bb0fcf1278621181ce230d90a8fe55c" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these &lt;code&gt;ARRAY&lt;/code&gt; references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. The following code is equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3045986b0102a2064e1410bb295874d9fe22b31d" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these ARRAY references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; . The following code is equivalent:</source>
          <target state="translated">Начиная с версии &lt;code&gt;1.39&lt;/code&gt; , эти ссылки на ARRAY являются благословенными объектами, распознающими два метода - &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; . Следующий код эквивалентен:</target>
        </trans-unit>
        <trans-unit id="d22b88a2ec6cf389267a717ce7fbb228afb24d03" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.51&lt;/code&gt; they also have a &lt;code&gt;TO_JSON&lt;/code&gt; method to ease serialisation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da1ba2b2bc63ba7f5a165684b362132feb79be8" translate="yes" xml:space="preserve">
          <source>Since version v1.33, Math::BigInt and Math::BigFloat have full support for accuracy and precision based rounding, both automatically after every operation, as well as manually.</source>
          <target state="translated">Начиная с версии v1.33,Math::BigInt и Math::BigFloat имеют полную поддержку округления на основе точности,как автоматически после каждой операции,так и вручную.</target>
        </trans-unit>
        <trans-unit id="75e1e7b33ae8faf22bfba9121d2d99d1efb7768e" translate="yes" xml:space="preserve">
          <source>Since we didn't define a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File::MP3&lt;/code&gt; class, Perl will look at the &lt;code&gt;File::MP3&lt;/code&gt; class's parent classes to find the &lt;code&gt;save()&lt;/code&gt; method. If Perl cannot find a &lt;code&gt;save()&lt;/code&gt; method anywhere in the inheritance hierarchy, it will die.</source>
          <target state="translated">Поскольку мы не определяли метод &lt;code&gt;save()&lt;/code&gt; в классе &lt;code&gt;File::MP3&lt;/code&gt; , Perl будет искать в родительских классах класса &lt;code&gt;File::MP3&lt;/code&gt; метод &lt;code&gt;save()&lt;/code&gt; . Если Perl не может найти метод &lt;code&gt;save()&lt;/code&gt; где-либо в иерархии наследования, он умрет.</target>
        </trans-unit>
        <trans-unit id="3e236441f92cccda5b2d49a5d2e52d11313518e5" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt; , we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="translated">Поскольку у нас нет NV для &lt;code&gt;$b&lt;/code&gt; , нам придется использовать &lt;code&gt;sv_2nv&lt;/code&gt; для его преобразования. Если сделаем шаг еще раз, то окажемся там:</target>
        </trans-unit>
        <trans-unit id="43d65fe03aac7da5dd4ef49b28b5012afba90c77" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt;, we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3708f0927e1925f92bdee0634ab63e7742c6b549" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="translated">Поскольку мы не знаем, работает ли &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; или даже подпрограммы, используйте специальные тесты для этих трех. Будьте осторожны, чтобы не использовать тестируемую функцию. Испытания в</target>
        </trans-unit>
        <trans-unit id="959f38fbc36ca9c82998d3e370dda38e5dddb0bf" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;require&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f9ededf0cd07d09b1ffd3609acb21770a40353" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt; .</source>
          <target state="translated">Поскольку для &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; мы загружаем список из десяти двухзначных шестнадцатеричных строк , шаблон пакета должен содержать десять кодов упаковки. Если это запустить на компьютере с кодировкой символов ASCII, будет напечатано &lt;code&gt;0123456789&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3e96dcf9d6747abca3c34da42f376ec3097c3d9" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;pack&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a3bb738728020d7b3d2bd56167deba0672548c" translate="yes" xml:space="preserve">
          <source>Since we said earlier:</source>
          <target state="translated">С тех пор,как мы сказали раньше:</target>
        </trans-unit>
        <trans-unit id="78829eafb6296e19175ed55a3097f673b5dc1d5f" translate="yes" xml:space="preserve">
          <source>Since you can assign to a list of variables, you can also assign to an array or hash slice.</source>
          <target state="translated">Так как вы можете присвоить список переменных,вы также можете присвоить массив или хэш-фрагмент.</target>
        </trans-unit>
        <trans-unit id="35b796faff1e6866bc3d8ff9ecdff8f636cea4f9" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt; , you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="translated">Поскольку вы запускаете только один тест для каждой программы, &lt;code&gt;new&lt;/code&gt; всегда возвращает один и тот же объект Test :: Builder. Независимо от того, сколько раз вы вызываете &lt;code&gt;new()&lt;/code&gt; , вы получаете один и тот же объект. Это называется синглтоном. Это сделано для того, чтобы несколько модулей совместно использовали такую ​​глобальную информацию, как счетчик тестов и то, куда идет тестовый вывод.</target>
        </trans-unit>
        <trans-unit id="d6632404c7510ee37ef12fec086b1b9886c3c039" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt;, you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df43da3b7bd5966cc2c20737e50dc599284dd8e" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt; , which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="translated">Поскольку вы хотите быть хорошим программистом, вы, вероятно, захотите использовать лексический дескриптор файла, даже несмотря на то, что форматы предназначены для работы с дескрипторами файла, так как имена форматов по умолчанию принимают имя дескриптора файла. Тем не менее, вы можете управлять этим с помощью некоторых специальных переменных Perl для дескрипторов файлов: &lt;code&gt;$^&lt;/code&gt; , который называет формат верхней части страницы, и &lt;code&gt;$~&lt;/code&gt; который показывает формат строки. Вы должны изменить дескриптор файла по умолчанию, чтобы установить эти переменные:</target>
        </trans-unit>
        <trans-unit id="8a72acc5d7f8358918f3a719037cabf59df13c37" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt;, which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ee6b56ac231ef340b4b0ce7a9b1c774baa56bb" translate="yes" xml:space="preserve">
          <source>Since you're assigning to a scalar, the righthand side is in scalar context. The comma operator (yes, it's an operator!) in scalar context evaluates its lefthand side, throws away the result, and evaluates it's righthand side and returns the result. In effect, that list-lookalike assigns to &lt;code&gt;$scalar&lt;/code&gt; it's rightmost value. Many people mess this up because they choose a list-lookalike whose last element is also the count they expect:</source>
          <target state="translated">Поскольку вы назначаете скаляр, правая часть находится в скалярном контексте. Оператор запятая (да, это оператор!) В скалярном контексте оценивает свою левую часть, отбрасывает результат, оценивает его правую часть и возвращает результат. Фактически, подобный список присваивает переменной &lt;code&gt;$scalar&lt;/code&gt; самое правое значение. Многие люди ошибаются, потому что выбирают похожий список, последний элемент которого также является ожидаемым счетчиком:</target>
        </trans-unit>
        <trans-unit id="b1e4d1f3b6584286a7b1e87475e6b68a4163f836" translate="yes" xml:space="preserve">
          <source>Since you're using ssh, you'll have to pass some extra arguments to Configure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e2d6a9962eddfc9f09d9986a8e8b8277588e75" translate="yes" xml:space="preserve">
          <source>Since, as mentioned above, bitwise operators may take extra arguments, you may want to use something like &lt;code&gt;(lobj, robj, swap, ...)&lt;/code&gt; (with literal &lt;code&gt;...&lt;/code&gt;) as your parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0b7bdab70ca2cc9c844a0d74a3af0bbf41c3e" translate="yes" xml:space="preserve">
          <source>Singapore</source>
          <target state="translated">Singapore</target>
        </trans-unit>
        <trans-unit id="b227b1e063b8171583fca32f48c11de71e845c84" translate="yes" xml:space="preserve">
          <source>Single 8-bit characters.</source>
          <target state="translated">Одиночные 8-битные символы.</target>
        </trans-unit>
        <trans-unit id="62539aaf022cade9262a4b6494d3943b6956e5a8" translate="yes" xml:space="preserve">
          <source>Single Byte Encodings</source>
          <target state="translated">Однобайтовые кодировки</target>
        </trans-unit>
        <trans-unit id="4530f93a4bcf9d5873d117244d6fb7434ad7291d" translate="yes" xml:space="preserve">
          <source>Single Quotes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012b49ff1827b6d4c0bd35ca2f9e9f57f854cb53" translate="yes" xml:space="preserve">
          <source>Single form (&lt;code&gt;\p{name}&lt;/code&gt;) tighter rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8a4e28358318025ab4a8b973931c58f9de9358" translate="yes" xml:space="preserve">
          <source>Single quotes indicate the text is to be treated literally with no interpolation of its content. This is similar to single quoted strings except that backslashes have no special meaning, with &lt;code&gt;\\&lt;/code&gt; being treated as two backslashes and not one as they would in every other quoting construct.</source>
          <target state="translated">Одиночные кавычки указывают на то, что текст следует рассматривать буквально без интерполяции его содержания. Это похоже на строки в одинарных кавычках, за исключением того, что обратная косая черта не имеет особого значения, а &lt;code&gt;\\&lt;/code&gt; рассматривается как две обратные косые черты, а не как одна, как в любой другой конструкции цитирования.</target>
        </trans-unit>
        <trans-unit id="2988b7ce72e4ef43941b210b5d2de77bb3a0210b" translate="yes" xml:space="preserve">
          <source>Single space after keywords that are followed by parens, no space between function name and following paren</source>
          <target state="translated">Пробел после ключевых слов,за которыми следуют парены,нет пробела между именем функции и следующими родителями</target>
        </trans-unit>
        <trans-unit id="998773a99793919677d4844303decc2eb2f960f3" translate="yes" xml:space="preserve">
          <source>Single step. Executes until the beginning of another statement, descending into subroutine calls. If an expression is supplied that includes function calls, it too will be single-stepped.</source>
          <target state="translated">Один шаг.Выполняется до начала другого утверждения,спускаясь в подпрограммные вызовы.Если поставляется выражение,включающее вызовы функций,то оно также будет одношаговым.</target>
        </trans-unit>
        <trans-unit id="b39e88e61083334da27e22ac3304f5322910c7a2" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , and &lt;code&gt;Lt&lt;/code&gt; .</source>
          <target state="translated">Однобуквенные свойства соответствуют всем символам в любом из двухбуквенных дополнительных свойств, начинающихся с той же буквы. &lt;code&gt;LC&lt;/code&gt; и &lt;code&gt;L&amp;amp;&lt;/code&gt; специальные: оба являются псевдонимами для множества , состоящее из всего найденного &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , и &lt;code&gt;Lt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8acda7f90b42defaf44562897d2b28bbd83f4e8" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt;, &lt;code&gt;Lu&lt;/code&gt;, and &lt;code&gt;Lt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47784ae534e76f07f938e74b6b49c2e04c524d60" translate="yes" xml:space="preserve">
          <source>Single-step flag. Will be true if the API will stop at the next statement.</source>
          <target state="translated">Одношаговый флаг.Будет верен,если API остановится на следующем утверждении.</target>
        </trans-unit>
        <trans-unit id="3fd72cbf421902beaf4893343701c7e9f292181e" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">Синограммы вроде &amp;laquo;東京&amp;raquo; возвращаются с именами символов &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; и &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , потому что их &amp;laquo;имена&amp;raquo; различаются. Модуль CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; имеет большую базу данных для их декодирования (и многого другого), если вы знаете, как понимать его вывод.</target>
        </trans-unit>
        <trans-unit id="b9df3910d077951b174aefd94b54e0bc3ac87d77" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt;, because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e8fd907b0e11131190209772e747eaed820c59" translate="yes" xml:space="preserve">
          <source>Site-specific perl extensions and modules can be installed in one of two places. Put architecture-independent files into:</source>
          <target state="translated">В одном из двух мест могут быть установлены perl-расширения и модули для конкретного места.Вставляйте файлы,не зависящие от архитектуры:</target>
        </trans-unit>
        <trans-unit id="00832815e260edfba2e83c2f4b5a6a35db1c2d1c" translate="yes" xml:space="preserve">
          <source>Six such conversions are possible:</source>
          <target state="translated">Шесть таких преобразований возможны:</target>
        </trans-unit>
        <trans-unit id="ab71370c759f98b4c2c5f12f621583aa7cb9faf2" translate="yes" xml:space="preserve">
          <source>Sixth:</source>
          <target state="translated">Sixth:</target>
        </trans-unit>
        <trans-unit id="43701334f4b3da3fdeb3363278217ac0f215873d" translate="yes" xml:space="preserve">
          <source>Size of the function table. This is compared against the value PerlIO code &quot;knows&quot; as a compatibility check. Future versions</source>
          <target state="translated">Размер таблицы функций.Для проверки совместимости сравнивается со значением PerlIO-кода &quot;знает&quot;.Будущие версии</target>
        </trans-unit>
        <trans-unit id="936d52e1c615ea7024397f6ff1aeb7c89ebd5bad" translate="yes" xml:space="preserve">
          <source>Size, Endianness, and BOM</source>
          <target state="translated">Размер,Эндианнесс и БОМ.</target>
        </trans-unit>
        <trans-unit id="0ec62bfb6670c34f50ed4190d4e6017dc34d76d5" translate="yes" xml:space="preserve">
          <source>Skip a package when throwing autodie exceptions</source>
          <target state="translated">Пропустить пакет при бросании исключений автообмена</target>
        </trans-unit>
        <trans-unit id="73e856b6ebf6aeb3a630b124c6e02c2a78566450" translate="yes" xml:space="preserve">
          <source>Skip all tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c526a5770e20da3a4179e52c1b052314f790b3" translate="yes" xml:space="preserve">
          <source>Skip event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ffbfd6b2e06775aaf14afc6238b4599cf532c4" translate="yes" xml:space="preserve">
          <source>Skip events bump test counts just like &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt; events, but they can never fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a18bbc33fb3b107b0f37ec04073b6f8f1aa7be" translate="yes" xml:space="preserve">
          <source>Skip sub-char mapping should there be no code point.</source>
          <target state="translated">Пропустите подзарядное отображение,если нет кодовой точки.</target>
        </trans-unit>
        <trans-unit id="fa22bcdeb4f395bdc09dc2fd5b11b93a885994fb" translate="yes" xml:space="preserve">
          <source>Skip the real Pod formatting, and just show the raw Pod source (&lt;b&gt;U&lt;/b&gt;nformatted)</source>
          <target state="translated">Пропустить реальный Pod форматирование и просто показать необработанный источник Pod ( &lt;b&gt;U&lt;/b&gt; nformatted)</target>
        </trans-unit>
        <trans-unit id="e6cd533514432f62bafda9ad5f9825a972ff6179" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3A-Keyword&quot;&gt;&quot;The BOOT: Keyword&quot; in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e59adfb26a9113df0d5c476d39a18d0087952f5" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;The BOOT: Keyword in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">Пропустите этот раздел, если предполагается, что функции XSUB вызываются только из других модулей; прочтите его, только если вы вызываете свои XSUB из кода в своем модуле или имеете раздел &lt;code&gt;BOOT:&lt;/code&gt; в вашем XS файле (см &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;. Ключевое слово BOOT: в perlxs&lt;/a&gt; ). То, что здесь описано, в равной степени применимо к интерфейсу &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a516a3ce4b9fd1e3a2a9186564fe4ca0d9da8218" translate="yes" xml:space="preserve">
          <source>Skipping tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ab6781ff6514e41583039acc42db3e0f3c9201" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt; . Exits immediately with 0.</source>
          <target state="translated">Пропускает все тесты, используя указанную &lt;code&gt;$reason&lt;/code&gt; . Немедленный выход с 0.</target>
        </trans-unit>
        <trans-unit id="9d406363c0222ce5a6c71553ed555dc077dda244" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt;. Exits immediately with 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563adc0d862d00d2bcc7549833d1039985aead2a" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt; .</source>
          <target state="translated">Пропускает текущий тест с сообщением &lt;code&gt;$why&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9a19a668210cd54ae808f068a27dac1e967c53" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1ac1071abc2c48fe8c683c23437c17bcd0e5ba" translate="yes" xml:space="preserve">
          <source>Skips to the next compressed data stream in the input file/buffer. If a new compressed data stream is found, the eof marker will be cleared and &lt;code&gt;$.&lt;/code&gt; will be reset to 0.</source>
          <target state="translated">Переход к следующему потоку сжатых данных во входном файле / буфере. Если будет обнаружен новый поток сжатых данных, маркер eof будет очищен и &lt;code&gt;$.&lt;/code&gt; будет сброшен на 0.</target>
        </trans-unit>
        <trans-unit id="4249f92b08fd3ea49d1d4587b0dc45efe6514ff5" translate="yes" xml:space="preserve">
          <source>SkyMarshal &amp;lt;skymarshal1729@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1af20e2176a0b7a938bf7cbbbf01e3f656d901" translate="yes" xml:space="preserve">
          <source>Skye Shaw &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41574ecb0de77a7fed0beca1f4434e4a44173169" translate="yes" xml:space="preserve">
          <source>Slab leaked from cv %p</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d051f41b7de19e7acc50c00d91bed9bc77c2a243" translate="yes" xml:space="preserve">
          <source>Slab-based operator allocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28422baab3fe565caf66be5cefa3539fc1817282" translate="yes" xml:space="preserve">
          <source>Slab_Alloc</source>
          <target state="translated">Slab_Alloc</target>
        </trans-unit>
        <trans-unit id="dfee07ce355211f20f3bdab2cb3fa2a9def9c336" translate="yes" xml:space="preserve">
          <source>Slab_Free</source>
          <target state="translated">Slab_Free</target>
        </trans-unit>
        <trans-unit id="8b86eb2caadb21d205d9d0ad56cf031153fb8e27" translate="yes" xml:space="preserve">
          <source>Slab_to_ro</source>
          <target state="translated">Slab_to_ro</target>
        </trans-unit>
        <trans-unit id="b4128d18330a7f45f087418a9b524193204735bc" translate="yes" xml:space="preserve">
          <source>Slab_to_rw</source>
          <target state="translated">Slab_to_rw</target>
        </trans-unit>
        <trans-unit id="147d6799969166c3bb4c81176bc4c31ac64ac6bd" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven.rezic@idealo.de&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac691e6a9650a28847ff59e7d257f5f29d2f4fa" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven@rezic.de&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59d0602eb0550fd0dbf5d82907d6271ae4af6ea" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of microseconds (millionths of a second) specified. Returns the number of microseconds actually slept. Can sleep for more than one second, unlike the &lt;code&gt;usleep&lt;/code&gt; system call. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">Спит на указанное количество микросекунд (миллионных долей секунды). Возвращает количество фактически спящих микросекунд. Может спать более одной секунды, в отличие от системного вызова &lt;code&gt;usleep&lt;/code&gt; . Может также спать в течение нуля секунд, что часто работает как</target>
        </trans-unit>
        <trans-unit id="a7c111ccc19a7463efac9caa48bfd176015106c5" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them). Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">Спит указанное количество наносекунд (1e9 секунды).Возвращает количество фактически проспавших наносекунд (с точностью до микросекунд,ближайшая тысяча).Может спать более одной секунды.Может также спать в течение нуля секунд,который часто работает как</target>
        </trans-unit>
        <trans-unit id="858360f4742bec3dbad2b4b1586f95ca8cfce48d" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept. The $which is the &quot;clock id&quot;, as with clock_gettime() and clock_getres(). The flags default to zero but &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; can specified (must be exported explicitly) which means that &lt;code&gt;$nanoseconds&lt;/code&gt; is not a time interval (as is the default) but instead an absolute time. Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">Спит на указанное количество наносекунд (1e9ths). Возвращает количество фактически спящих наносекунд. $, Который является &amp;laquo;идентификатором часов&amp;raquo;, как и в случае с clock_gettime () и clock_getres (). По умолчанию флаги равны нулю, но можно указать &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; (должен быть экспортирован явно), что означает, что &lt;code&gt;$nanoseconds&lt;/code&gt; - это не временной интервал (как по умолчанию), а абсолютное время. Может спать более одной секунды. Может также спать в течение нуля секунд, что часто работает как</target>
        </trans-unit>
        <trans-unit id="bfc9358c36664745e87042ffeea926ba49acc8f0" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">Спит указанное количество секунд. Возвращает количество секунд, в течение которых фактически спал (значение с плавающей запятой). Эта функция может быть импортирована, что приведет к хорошей замене &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; предоставляемого perl, см. &lt;a href=&quot;#EXAMPLES&quot;&gt;ПРИМЕРЫ&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="18ae77017c85766e5d3a71c2d083fdfba9357fdb" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;sleep&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="de97696f04df2d455746fc0459c7a0334ac08b94" translate="yes" xml:space="preserve">
          <source>Slices in scalar context return the last item of the slice.</source>
          <target state="translated">Фрагменты в скалярном контексте возвращают последний элемент фрагмента.</target>
        </trans-unit>
        <trans-unit id="fade4867f2281855741bb2fdfae6ec6bfe669774" translate="yes" xml:space="preserve">
          <source>Slicing operations and parentheses cause the right-hand side to be evaluated in list context:</source>
          <target state="translated">Операции разрезания и круглые скобки приводят к тому,что правая сторона будет оцениваться в контексте списка:</target>
        </trans-unit>
        <trans-unit id="dcf621083da44b050ec0828499127db4dc13006b" translate="yes" xml:space="preserve">
          <source>SlickEdit</source>
          <target state="translated">SlickEdit</target>
        </trans-unit>
        <trans-unit id="71625e10c96350176b8faecaf24d1d897cf6efce" translate="yes" xml:space="preserve">
          <source>Slightly modified by Arthur Bergman to fit the new thread model/module.</source>
          <target state="translated">Слегка модифицирована Артуром Бергманом под новую модель/модуль резьбы.</target>
        </trans-unit>
        <trans-unit id="b6c149c3e00467fba347629a63ed02fed098d061" translate="yes" xml:space="preserve">
          <source>Slovakia</source>
          <target state="translated">Slovakia</target>
        </trans-unit>
        <trans-unit id="d1aa0503612aa4168939b77b59ca74532a11951a" translate="yes" xml:space="preserve">
          <source>Slovenia</source>
          <target state="translated">Slovenia</target>
        </trans-unit>
        <trans-unit id="945d75b6ccb37accbc9182a048ffec51dcd1a47f" translate="yes" xml:space="preserve">
          <source>Slurpy parameter not last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c84511f9de85f2a5bea737ad0651170f5fc9c55" translate="yes" xml:space="preserve">
          <source>Smart matching a non-overloaded object breaks encapsulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05c92e1201b3c7a99b14a3196c426c41067b9ce" translate="yes" xml:space="preserve">
          <source>Smartmatch Operator</source>
          <target state="translated">Smartmatch Operator</target>
        </trans-unit>
        <trans-unit id="853b5644d464d7aa87bcee31b98647e7b0076053" translate="yes" xml:space="preserve">
          <source>Smartmatch expects to be able to allocate an op at run time, run it, and then throw it away. For that to work the op is simply malloced when PL_compcv hasn't been set up. So all slab-allocated ops are marked as such (&lt;code&gt;-&amp;gt;op_slabbed&lt;/code&gt;), to distinguish them from malloced ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226b6fe8f9e2cd4e8ca8e6e55a94a83ba3f2cf5a" translate="yes" xml:space="preserve">
          <source>Smartmatch is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4adce585ab904a3b57996c9eacd1526a8856e59" translate="yes" xml:space="preserve">
          <source>Smartmatching of Objects</source>
          <target state="translated">Умное сопоставление объектов</target>
        </trans-unit>
        <trans-unit id="fcef3abf224b18a1a9539b5cd1a74a21f40eb21d" translate="yes" xml:space="preserve">
          <source>Smartmatching one hash against another reports whether both contain the same keys, no more and no less. This could be used to see whether two records have the same field names, without caring what values those fields might have. For example:</source>
          <target state="translated">Сопоставление одного хэша с другими отчетами о том,содержат ли оба одинаковые ключи,не больше и не меньше.Это может быть использовано для того,чтобы увидеть,имеют ли две записи одни и те же имена полей,не заботясь о том,какие значения могут иметь эти поля.Например:</target>
        </trans-unit>
        <trans-unit id="f02489100f7e7550e46dc3c0c8c28f36daa00353" translate="yes" xml:space="preserve">
          <source>Smoke testing Perl 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c177aabcbd4f359e0aaa8a530199381f4cf98371" translate="yes" xml:space="preserve">
          <source>Snooping</source>
          <target state="translated">Snooping</target>
        </trans-unit>
        <trans-unit id="4460e52ce30ee2f7dab472f65e7bc2c1c88dffad" translate="yes" xml:space="preserve">
          <source>So I got smart: I decided to be lazy and let the C compiler parse the C, which would spit out debugger stabs for me to read. These were much easier to parse. It's still not a pretty program, but at least it's more robust.</source>
          <target state="translated">Так что я поумнел:решил лениться и позволить компилятору Си разобрать Си,который выплюнул бы отладочные удары,чтобы я мог читать.Их было намного проще разбирать.Это все еще не очень красивая программа,но,по крайней мере,более надежная.</target>
        </trans-unit>
        <trans-unit id="a1f5ce193c65cebf4de4614792ca39a016541f36" translate="yes" xml:space="preserve">
          <source>So a typical call to check would look like this:</source>
          <target state="translated">Так что типичный звонок для проверки будет выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="32bf3b4ebf1dd24fdccf516f7c267bd10f4fed6f" translate="yes" xml:space="preserve">
          <source>So assuming the database created above, we can use &lt;code&gt;get_dup&lt;/code&gt; like this:</source>
          <target state="translated">Предполагая, что база данных создана выше, мы можем использовать &lt;code&gt;get_dup&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="9531481e3958e36f87e15fe09a502608d674e17a" translate="yes" xml:space="preserve">
          <source>So called because of a similar construct in &lt;b&gt;shells&lt;/b&gt; that pretends that the &lt;b&gt;lines&lt;/b&gt; following the &lt;b&gt;command&lt;/b&gt; are a separate &lt;b&gt;file&lt;/b&gt; to be fed to the command, up to some terminating string. In Perl, however, it&amp;rsquo;s just a fancy form of quoting.</source>
          <target state="translated">Вызывается так из-за аналогичной конструкции в &lt;b&gt;оболочках,&lt;/b&gt; которая делает вид, что &lt;b&gt;строки,&lt;/b&gt; следующие за &lt;b&gt;командой,&lt;/b&gt; представляют собой отдельный &lt;b&gt;файл,&lt;/b&gt; передаваемый команде, вплоть до некоторой завершающей строки. В Perl, однако, это просто причудливая форма цитирования.</target>
        </trans-unit>
        <trans-unit id="93e9a6ece24ada54b55dc7612c9389e7a638c36b" translate="yes" xml:space="preserve">
          <source>So each subroutine is born with an array of scratchpads (of length 1). On each entry to the subroutine it is checked that the current depth of the recursion is not more than the length of this array, and if it is, new scratchpad is created and pushed into the array.</source>
          <target state="translated">Поэтому каждая подпрограмма рождается с массивом скрэтчпадов (длиной 1).При каждом входе в подпрограмму проверяется,что текущая глубина рекурсии не больше длины этого массива,и если она есть,то создается новая скрэтчпад и заталкивается в массив.</target>
        </trans-unit>
        <trans-unit id="c0f1f69e80ab7ebe217f8989a490d4af7ac57aa2" translate="yes" xml:space="preserve">
          <source>So far I've shown you nothing that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd2a2cfe6e08c35c8f0019242b9920756d8258f" translate="yes" xml:space="preserve">
          <source>So far so good. But suppose the way you're implementing this is:</source>
          <target state="translated">Пока все хорошо.Но представь,что ты это реализуешь:</target>
        </trans-unit>
        <trans-unit id="99d938c6031e3ad535ec502cea56c5d218d4389a" translate="yes" xml:space="preserve">
          <source>So far so good. Those of you who have been paying attention will have spotted that the tied object hasn't been used so far. So lets add an extra method to the Remember class to allow comments to be included in the file; say, something like this:</source>
          <target state="translated">Пока все хорошо.Те из вас,кто обращал внимание,заметили,что завязанный предмет до сих пор не использовался.Так что давайте добавим дополнительный метод в класс Remember,чтобы можно было включать комментарии в файл;скажем,что-нибудь вроде этого:</target>
        </trans-unit>
        <trans-unit id="438b9b4e31229df657e054c261ee9d298ca8b103" translate="yes" xml:space="preserve">
          <source>So far we've merely tried to find and list the experimental features and infer their inception, versions, etc. There's a lot of speculation here.</source>
          <target state="translated">До сих пор мы просто пытались найти и перечислить экспериментальные возможности и сделать вывод об их возникновении,версиях и т.д.Здесь много домыслов.</target>
        </trans-unit>
        <trans-unit id="10bc3a4c124b48037408d12298d27779d339f321" translate="yes" xml:space="preserve">
          <source>So far, so good. With the knowledge above you can already perform searches with just about any literal string regexp you can dream up. Here is a</source>
          <target state="translated">Пока все хорошо.С помощью вышеприведенных знаний вы уже можете осуществлять поиск с помощью практически любого буквального регэкспресса строки,о котором можно только мечтать.Вот</target>
        </trans-unit>
        <trans-unit id="8af65d96d3224572aaaeff6426ae992e0bd5b192" translate="yes" xml:space="preserve">
          <source>So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.</source>
          <target state="translated">Пока мы используем обычный механизм возврата списков.Что случится,если вы хотите пропустить или вернуть гашиш? Ну,если вы используете только один из них,или вы не возражаете против их конкатенации,то обычное соглашение по вызову нормально,хотя и немного дорогое.</target>
        </trans-unit>
        <trans-unit id="6a1a83e9f4437f40c54f1506b859ac7294d0d128" translate="yes" xml:space="preserve">
          <source>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, &lt;code&gt;()*&lt;/code&gt; cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with &lt;code&gt;=&lt;/code&gt; between the name and the value, followed by an additional delimiting null byte. Here's how:</source>
          <target state="translated">До сих пор мы видели литералы, используемые в качестве шаблонов. Если список элементов пакета не имеет фиксированной длины, требуется выражение, составляющее шаблон (всякий раз, когда по какой-либо причине нельзя использовать &lt;code&gt;()*&lt;/code&gt; ). Вот пример: для хранения именованных строковых значений способом, который может быть удобно проанализирован программой C, мы создаем последовательность имен и строк ASCII с завершающим нулем, с &lt;code&gt;=&lt;/code&gt; между именем и значением, за которым следует дополнительный ограничивающий нулевой байт. . Вот как:</target>
        </trans-unit>
        <trans-unit id="7a5692420708108a4d7ad47094be88b57cf9bf66" translate="yes" xml:space="preserve">
          <source>So for English (with Bracket Notation) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; is fine (for 0 it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and for more it returns &quot;2 files&quot;, etc.)</source>
          <target state="translated">Таким образом, для английского языка (с обозначением скобок) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; подходит (для 0 возвращается &quot;0 файлов&quot;, для 1 возвращается &quot;1 файл&quot;, а для большего количества возвращается &quot; 2 файла &amp;raquo;и др.)</target>
        </trans-unit>
        <trans-unit id="8477c048b776b6250b8d3a6b206bd8a95a79a9ff" translate="yes" xml:space="preserve">
          <source>So for example, instead of using:</source>
          <target state="translated">Так,например,вместо того,чтобы использовать:</target>
        </trans-unit>
        <trans-unit id="23a15c81788a2c5aff56ccaef77af7e0b8ce44eb" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; , and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt; . This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">Итак, учитывая приведенную выше диаграмму, Perl будет искать &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; и, наконец, &lt;code&gt;MaternalGrandparent&lt;/code&gt; . Это может быть проблемой, потому что теперь мы ищем &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f8c16c38e4b1347fbe4bd6bed13c87b6b97a967" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt;, &lt;code&gt;Father&lt;/code&gt;, &lt;code&gt;PaternalGrandparent&lt;/code&gt;, &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;, &lt;code&gt;Mother&lt;/code&gt;, and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt;. This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f4e47cc018c4b1c4ca9fc78408994ad8035bd1" translate="yes" xml:space="preserve">
          <source>So here is the bottom line--if you are sure that control will revert back to the enclosing Perl scope fairly quickly after the end of your callback, then it isn't absolutely necessary to dispose explicitly of any temporaries you may have created. Mind you, if you are at all uncertain about what to do, it doesn't do any harm to tidy up anyway.</source>
          <target state="translated">Итак,вот в чем суть-если вы уверены,что управление вернется обратно в прилагаемый диапазон Perl довольно быстро после окончания вашего обратного вызова,то не обязательно явно распоряжаться какими-либо временными объектами,которые вы,возможно,создали.Имейте в виду,что если вы вообще не уверены в том,что делать,это не причинит никакого вреда,чтобы привести в порядок в любом случае.</target>
        </trans-unit>
        <trans-unit id="4443d502fbd614fe670f624b7a8d6e87d74c5b32" translate="yes" xml:space="preserve">
          <source>So hopefully you've now got a few ideas about what's good to modularise. Let's now see how it's done.</source>
          <target state="translated">Так что,надеюсь,теперь у тебя есть несколько идей о том,что хорошо для модуляризации.А теперь посмотрим,как это делается.</target>
        </trans-unit>
        <trans-unit id="6d3a27421600e7d4abecd702bd20845b8466123d" translate="yes" xml:space="preserve">
          <source>So how do I use a proxy with File::Fetch?</source>
          <target state="translated">Как использовать прокси-сервер с File::Fetch?</target>
        </trans-unit>
        <trans-unit id="9d00ee45ac1982b7db0dbf721dd3e3787ed6d62f" translate="yes" xml:space="preserve">
          <source>So how do you use a source filter in a Perl script? Above, I said that a source filter is just a special kind of module. Like all Perl modules, a source filter is invoked with a use statement.</source>
          <target state="translated">Так как же использовать фильтр исходных текстов в Perl-скрипте? Выше я сказал,что фильтр исходных текстов-это просто специальный вид модуля.Как и все модули на Perl,фильтр исходного текста вызывается с оператором use.</target>
        </trans-unit>
        <trans-unit id="6cca2cb75a50d0827a566440232066af85d09fbe" translate="yes" xml:space="preserve">
          <source>So how does it work?</source>
          <target state="translated">Так как это работает?</target>
        </trans-unit>
        <trans-unit id="7fc04ce8d1c409ed6d44985cf7b3c46dd155a24f" translate="yes" xml:space="preserve">
          <source>So how hard could that be? You look at the code that produces the first item, and it reads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9612f816ae3d1d599129006ddc23ec570699e275" translate="yes" xml:space="preserve">
          <source>So if you take for example the shell command</source>
          <target state="translated">Так что если взять,например,команду оболочки</target>
        </trans-unit>
        <trans-unit id="557e6fd5bed4c1d07e89cc778dd5ffa04e712afb" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block as follows;</source>
          <target state="translated">Поэтому, если вы хотите проверить правильность кодировки, заключите выражение в блок &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; следующим образом;</target>
        </trans-unit>
        <trans-unit id="a821fbe9858bdf4860678fd5e1e7551e3704e346" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;eval {}&lt;/code&gt; block as follows;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e30a7ebf49e6593b8da91cf7504894e9cfa473" translate="yes" xml:space="preserve">
          <source>So if you were to supply a new, complete, top-level source file to add to Perl, you should conform to this peculiar practice by yourself selecting an appropriate quotation from Tolkien, retaining the original spelling and punctuation and using the same format the rest of the quotes are in. Indirect and oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.</source>
          <target state="translated">Таким образом,если вы должны предоставить новый,полный,высокоуровневый исходный файл для добавления на Perl,вы должны соответствовать этой специфической практике,самостоятельно выбрав соответствующую цитату из Толкиена,сохранив оригинальное написание и пунктуацию и используя тот же формат,в котором находятся остальные цитаты.Косвенный и косой-это просто прекрасно,помните,что это метафора,так что мета-это,в конце концов,то,для чего она нужна.</target>
        </trans-unit>
        <trans-unit id="02bb4252af15d73e7777da1a95cce444353d918a" translate="yes" xml:space="preserve">
          <source>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</source>
          <target state="translated">Поэтому,если вы работаете с данными Юникода,проконсультируйтесь с документацией каждого модуля,который вы используете,если у вас возникли проблемы с обменом данными в Юникоде.Если в документации вообще не говорится о Юникоде,заподозрите худшее и,возможно,посмотрите на исходные тексты,чтобы узнать,как реализуется модуль.Модули,полностью написанные на Perl,не должны вызывать проблем.Модули,которые прямо или косвенно обращаются к коду,написанному на других языках программирования,находятся под угрозой.</target>
        </trans-unit>
        <trans-unit id="e319523cadbb2780f0ef0af26ce5a7a559c73594" translate="yes" xml:space="preserve">
          <source>So in VMS its pm_to_blib.ts.</source>
          <target state="translated">Так что в VMS его pm_to_blib.ts.</target>
        </trans-unit>
        <trans-unit id="3bce9b15392a6c8658669f57b4a2decac3558eb6" translate="yes" xml:space="preserve">
          <source>So instead you'll want to do something like this:</source>
          <target state="translated">Так что вместо этого ты захочешь сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="6161c23b3048d528f32556aeffc6deb23d6328c9" translate="yes" xml:space="preserve">
          <source>So it is round-trip safe for \xF9\xF9. But if the line above is upside down, here is what happens.</source>
          <target state="translated">Так что для \xF9\xF9 это безопасно для поездок туда и обратно.Но если линия выше перевернута,вот что произойдет.</target>
        </trans-unit>
        <trans-unit id="c06ae4675003e825258b16549181d9f72cc7560a" translate="yes" xml:space="preserve">
          <source>So it's clearer and best to use the compound form when specifying blocks. And be sure that is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">Так что при задании блоков лучше всего использовать составную форму.И будьте уверены,что это то,чего вы действительно хотите.В большинстве случаев сценарии-это то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="3007e0313fdaf4be553a40db748fe3ab3979d2d6" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; , and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">Так что не забывайте всегда использовать конструкторы массивов или хешей с &lt;code&gt;[]&lt;/code&gt; или &lt;code&gt;{}&lt;/code&gt; , и все будет в порядке, хотя это не всегда оптимально эффективно.</target>
        </trans-unit>
        <trans-unit id="d027afb082f340c36adda48951c99192de3bf3d9" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt;, and you'll be fine, although it's not always optimally efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f6b3059bd71a14d4d6430ebaa792ae77f9b5ae" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">Вот и все о текстовых данных. Давайте &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; содержательным вещам, которые лучше всего подходят для &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и распаковки : обработка двоичных форматов чисел. Конечно, существует не только один двоичный формат - жизнь была бы слишком простой - но Perl сделает за вас всю сложную работу.</target>
        </trans-unit>
        <trans-unit id="c03e630c08b97b3f5b437a4e7c4b378ae3776973" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6434510a7a13803f70088fd4384a0dc891e9b671" translate="yes" xml:space="preserve">
          <source>So neither &lt;code&gt;latin1&lt;/code&gt; nor &lt;code&gt;ascii&lt;/code&gt; are incompatible with the &lt;code&gt;utf8&lt;/code&gt; flag - they only govern when the JSON output engine escapes a character or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6d818d0bc8716d4413f806e54c839d9543bd1d" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;tie $scalar&lt;/code&gt; will always tie the scalar, not the handle it holds. To tie the handle, use &lt;code&gt;tie *$scalar&lt;/code&gt; (with an explicit asterisk). The same applies to &lt;code&gt;tied *$scalar&lt;/code&gt; and &lt;code&gt;untie *$scalar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e5670a7ba385b708ff4bcfadcd36a0825afece" translate="yes" xml:space="preserve">
          <source>So now this code would be written:</source>
          <target state="translated">Так что теперь этот код будет написан:</target>
        </trans-unit>
        <trans-unit id="7ec657e348cc94be548b290696e0a818e7f982d5" translate="yes" xml:space="preserve">
          <source>So now you have a file ending in .tar.gz (or, less often, .zip). You know there's a tasty module inside. There are four steps you must now take:</source>
          <target state="translated">Итак,теперь у вас есть файл,заканчивающийся на .tar.gz (или,реже,.zip).Вы знаете,что внутри есть вкусный модуль.Теперь вы должны сделать четыре шага:</target>
        </trans-unit>
        <trans-unit id="9f7f09ef2fcd4d20ffdab1795e6c221c8b2cdf50" translate="yes" xml:space="preserve">
          <source>So please select carefully what library you want to use.</source>
          <target state="translated">Поэтому,пожалуйста,внимательно выбирайте,какую библиотеку вы хотите использовать.</target>
        </trans-unit>
        <trans-unit id="fc4d504736579a86ac1ba1abd47d391cec08a768" translate="yes" xml:space="preserve">
          <source>So put in parentheses to say what you really mean.</source>
          <target state="translated">Так что поставь в скобки,чтобы сказать,что ты на самом деле имеешь в виду.</target>
        </trans-unit>
        <trans-unit id="291a379872204cd90f4de2f2a608af9f0d7dabed" translate="yes" xml:space="preserve">
          <source>So specifically, autoloaded functions cannot see package lexicals (this applies to both the &lt;b&gt;SelfLoader&lt;/b&gt; and the Autoloader). The &lt;code&gt;vars&lt;/code&gt; pragma provides an alternative to defining package-level globals that will be visible to autoloaded routines. See the documentation on &lt;b&gt;vars&lt;/b&gt; in the pragma section of &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">В частности, автозагрузочные функции не могут видеть лексику пакетов (это относится как к &lt;b&gt;SelfLoader, так&lt;/b&gt; и к Autoloader). &lt;code&gt;vars&lt;/code&gt; Прагмы является альтернативой определения глобал уровня пакета , которые будут видны автозагружаемыми рутины. См. Документацию по &lt;b&gt;варам&lt;/b&gt; в разделе &lt;a href=&quot;perlmod&quot;&gt;директив perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="178e0296c43b2c22ca3149a0d363aa4b6a82de7c" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; so far:</source>
          <target state="translated">Вот как мы потребляем и производим данные фиксированной ширины. Давайте резюмировать то , что мы видели &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; до сих пор:</target>
        </trans-unit>
        <trans-unit id="ae19d4915e0b62760549bd4eeb2c1e92ef2ac7db" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; so far:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5a5de8356ec781cae3674738f4fa4085230f11" translate="yes" xml:space="preserve">
          <source>So the Perl interface would look like this</source>
          <target state="translated">Значит,интерфейс Perl будет выглядеть так.</target>
        </trans-unit>
        <trans-unit id="eb361df349469f52fd13dc7f637fd6d3f4002c01" translate="yes" xml:space="preserve">
          <source>So the Perl subroutine would look like this:</source>
          <target state="translated">Чтобы подпрограмма &quot;Перл&quot; выглядела вот так:</target>
        </trans-unit>
        <trans-unit id="f9e5e29abec6c42a24502ee051f01eb881622a3a" translate="yes" xml:space="preserve">
          <source>So the exit codes are...</source>
          <target state="translated">Значит,коды выхода...</target>
        </trans-unit>
        <trans-unit id="ecdcbf5b6eec0983bdba576e908b1b991d7bdaa0" translate="yes" xml:space="preserve">
          <source>So the methods &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; can be invoked like this:</source>
          <target state="translated">Итак, методы &lt;code&gt;PrintID&lt;/code&gt; и &lt;code&gt;Display&lt;/code&gt; можно вызывать следующим образом:</target>
        </trans-unit>
        <trans-unit id="fc02af530f320939749f4c5dd232069afbb23ee8" translate="yes" xml:space="preserve">
          <source>So the return value will be true if the seek operation was successful. For failure, a false value is returned and &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7fd8e534a0a64d6932df0e7228b52bddc2accd" translate="yes" xml:space="preserve">
          <source>So these now have simple defaults rather than probing at build-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050bc5740a1b6bb30a161c3c46fabef260c75737" translate="yes" xml:space="preserve">
          <source>So this:</source>
          <target state="translated">Итак,это:</target>
        </trans-unit>
        <trans-unit id="65f64a88a88a2a42947aa812e415dc968ce4fc3b" translate="yes" xml:space="preserve">
          <source>So to repeat always use SvOK() to check whether an sv is defined.</source>
          <target state="translated">Поэтому,чтобы повторить всегда используйте SvOK()для проверки,определен ли sv.</target>
        </trans-unit>
        <trans-unit id="ec007077340f2b45239679ca4cc61f38315a3433" translate="yes" xml:space="preserve">
          <source>So what happened to dTHR?</source>
          <target state="translated">Так что случилось с ДТПЧ?</target>
        </trans-unit>
        <trans-unit id="dd71b3066f2c37ca89d49c13416a448baf2ad1f1" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt; . As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">Так при чем здесь &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ? Ну, если вы хотите , чтобы составить строку Unicode (то есть внутренне зашифрованная UTF-8), вы можете сделать это, используя шаблон код &lt;code&gt;U&lt;/code&gt; . В качестве примера создадим символ валюты евро (кодовый номер 0x20AC):</target>
        </trans-unit>
        <trans-unit id="be8214c7c17783a92e4d370b91d6755f26454042" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;pack&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt;. As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76db05e5ac37110bc4537d598a8e57f24d0e7d58" translate="yes" xml:space="preserve">
          <source>So what is the big problem? Well, if you are expecting Perl to tidy up those temporaries for you, you might be in for a long wait. For Perl to dispose of your temporaries, control must drop back to the enclosing scope at some stage. In the event driven scenario that may never happen. This means that, as time goes on, your program will create more and more temporaries, none of which will ever be freed. As each of these temporaries consumes some memory your program will eventually consume all the available memory in your system--kapow!</source>
          <target state="translated">Так в чем проблема? Ну,если ты ожидаешь,что Перл уберёт для тебя эти временники,то тебе придётся долго ждать.Для того,чтобы Perl распорядился вашими временами,на каком-то этапе контроль должен вернуться к закрывающему прибору.В событии,которое может никогда не произойти.Это означает,что с течением времени ваша программа будет создавать всё больше и больше времен,ни одно из которых никогда не будет освобождено.По мере того,как каждый из этих временных периодов потребляет некоторую память,ваша программа в конечном счете будет потреблять всю доступную память в вашей системе-kapow!</target>
        </trans-unit>
        <trans-unit id="49dd0c06fd8f279176f457e7dd90bd0af2090341" translate="yes" xml:space="preserve">
          <source>So what's new?</source>
          <target state="translated">Так что нового?</target>
        </trans-unit>
        <trans-unit id="8be287051544a93972a5fe33ce5f2eed6334bad0" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any compressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all compressed data will be appended to the existing buffer.</source>
          <target state="translated">Таким образом,когда на выходе находится файловый менеджер,он будет осуществлять поиск в eof перед записью любых сжатых данных.Если вывод является именем файла,он будет открыт для добавления.Если выходной файл является буфером,то все сжатые данные будут добавлены в существующий буфер.</target>
        </trans-unit>
        <trans-unit id="2b16151fbc25d8d9908507f5cf41dca81006fcb5" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any uncompressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all uncompressed data will be appended to the existing buffer.</source>
          <target state="translated">Таким образом,когда на выходе находится файловый менеджер,он будет осуществлять поиск в eof перед записью любых несжатых данных.Если вывод является именем файла,он будет открыт для добавления.Если выходной файл является буфером,то все несжатые данные будут добавлены в существующий буфер.</target>
        </trans-unit>
        <trans-unit id="faf320f95dede4954f64d637d17b4ef0ec2ac56b" translate="yes" xml:space="preserve">
          <source>So when we parse &lt;code&gt;/foo/&lt;/code&gt; we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. 'tsdy' is a special form of &lt;code&gt;regtail()&lt;/code&gt; which does some extra analysis.</source>
          <target state="translated">Итак, когда мы разбираем &lt;code&gt;/foo/&lt;/code&gt; мы видим что-то вроде следующей таблицы. Слева показано, что анализируется, а число указывает, куда пойдет следующий regop. Справа - результат трассировки графика. Имена выбраны короткими, чтобы изображение на экране было менее плотным. tsdy - это особая форма &lt;code&gt;regtail()&lt;/code&gt; которая выполняет дополнительный анализ.</target>
        </trans-unit>
        <trans-unit id="4ca42b2545bb9f74c7dfcf26ad336456861738d0" translate="yes" xml:space="preserve">
          <source>So why is UNINST=1 not the default?</source>
          <target state="translated">Так почему же UNINST=1 не по умолчанию?</target>
        </trans-unit>
        <trans-unit id="5764d39b6b45dd4fdf0407e6dadfbf8730c1c2c3" translate="yes" xml:space="preserve">
          <source>So why use these? They produce better diagnostics on failure. &lt;code&gt;ok()&lt;/code&gt; cannot know what you are testing for (beyond the name), but &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; know what the test was and why it failed. For example this test:</source>
          <target state="translated">Так зачем их использовать? Они обеспечивают лучшую диагностику неисправности. &lt;code&gt;ok()&lt;/code&gt; не может знать, что вы тестируете (помимо имени), но &lt;code&gt;is()&lt;/code&gt; и &lt;code&gt;isnt()&lt;/code&gt; знают, что это был за тест и почему он не удался. Например этот тест:</target>
        </trans-unit>
        <trans-unit id="0723871c8efb4af11337b70788bc11e5f341de34" translate="yes" xml:space="preserve">
          <source>So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client; that's why accept() takes two arguments.</source>
          <target state="translated">Так зачем же вам понадобилось использовать доменное гнездо Unix вместо более простой именной трубы? Потому что именованная труба не дает вам сеансов.Вы не можете отличить данные одного процесса от данных другого.При программировании сокетов вы получаете отдельный сеанс для каждого клиента;вот почему accept()принимает два аргумента.</target>
        </trans-unit>
        <trans-unit id="907dfd8f705f1e1d725ffd018f44b3318d9e84e1" translate="yes" xml:space="preserve">
          <source>So you can figure out what went wrong without rerunning the test.</source>
          <target state="translated">Так что ты можешь выяснить,что пошло не так,не повторив тест.</target>
        </trans-unit>
        <trans-unit id="23330e80d1d5c0a1be567b0263265e46b7f62019" translate="yes" xml:space="preserve">
          <source>So you rewrite it to read:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a109f19c85f2e155b7bae45252c43e85217d92" translate="yes" xml:space="preserve">
          <source>So you should instead try this;</source>
          <target state="translated">Так что вместо этого тебе стоит попробовать это;</target>
        </trans-unit>
        <trans-unit id="99368e21d7e985fc9382de7cbad3270d6b572550" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; actually does?</source>
          <target state="translated">Итак, вы хотите знать, что на самом деле делает &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="f880312d8311a1d75dbe80304cdf01f9913e6eb1" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;import&lt;/code&gt; actually does?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98457d69f47757522cf080b8cba6d90757ec58b" translate="yes" xml:space="preserve">
          <source>So, beside calls like</source>
          <target state="translated">Итак,кроме звонков вроде</target>
        </trans-unit>
        <trans-unit id="8b676466aa2043751e164c60e8f768fad4f2409b" translate="yes" xml:space="preserve">
          <source>So, for classes and subclasses to have inheritance correctly work with autoloading, you need to ensure stubs are loaded.</source>
          <target state="translated">Таким образом,для того,чтобы классы и подклассы,имеющие наследование,корректно работали с автозагрузкой,необходимо обеспечить загрузку шлейфов.</target>
        </trans-unit>
        <trans-unit id="3fdc850c88acfeea0034b4d0a5ecf1cbe8955116" translate="yes" xml:space="preserve">
          <source>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</source>
          <target state="translated">Так,например,&quot;wb9&quot; означает открытый для записи с максимальным сжатием,используя стратегию по умолчанию,а &quot;wb4R&quot; означает открытый для записи с 4-м уровнем сжатия и кодировкой длины прогона.</target>
        </trans-unit>
        <trans-unit id="ef8d2c630e8e6fd22bf1a2656520cdc24a0e732f" translate="yes" xml:space="preserve">
          <source>So, for example, say you have a file compressed with gzip that you want to recompress with bzip2. Here is all that is needed to carry out the recompression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d3c65256a4087c70ab29c5923eefef7208b53e" translate="yes" xml:space="preserve">
          <source>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</source>
          <target state="translated">Так,например,чтобы упаковать 20302 в подписанное 16-битное целое число в представлении вашего компьютера,вы пишете</target>
        </trans-unit>
        <trans-unit id="5a026df42e6a15ca497ded704c00f477c0e8e518" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt; , you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt; , you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">Итак, если вы видите два термина со знаком &lt;code&gt;=&lt;/code&gt; или &lt;code&gt;+&lt;/code&gt; между ними, вы можете превратить их в одно выражение. Когда вы это сделаете, вы выполните код в блоке в следующей строке: если вы видите &lt;code&gt;=&lt;/code&gt; , вы выполните код в строке 2. Если вы видите &lt;code&gt;+&lt;/code&gt; , вы выполните код в строке 4. Это этот код. который вносит вклад в дерево операций.</target>
        </trans-unit>
        <trans-unit id="0379bb60c338fa89d5d14562ac618c3cb90f2526" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt;, you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt;, you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f012b7bad59a01daf6da8ed100b9c040ae573c55" translate="yes" xml:space="preserve">
          <source>So, if you want to collect memory info in a cycle, you may call</source>
          <target state="translated">Итак,если вы хотите собрать информацию о памяти в цикле,вы можете позвонить</target>
        </trans-unit>
        <trans-unit id="f33ef09895b9595e58c40994534996d41b9b84f6" translate="yes" xml:space="preserve">
          <source>So, in general, &quot;state&quot; subroutines are faster. But &quot;my&quot; subs are necessary if you want to create closures:</source>
          <target state="translated">Итак,в общем,подпрограммы &quot;состояние&quot; быстрее.Но &quot;мои&quot; подпрограммы необходимы,если вы хотите создать замыкания:</target>
        </trans-unit>
        <trans-unit id="b92446e0fc5150a550f9b239a78e7589775be2a5" translate="yes" xml:space="preserve">
          <source>So, let's say you want to add a custom element called 'foo'. In your subclass's &lt;code&gt;new&lt;/code&gt; method, after calling &lt;code&gt;SUPER::new&lt;/code&gt; you'd call:</source>
          <target state="translated">Итак, допустим, вы хотите добавить настраиваемый элемент под названием &amp;laquo;foo&amp;raquo;. В &lt;code&gt;new&lt;/code&gt; методе вашего подкласса после вызова &lt;code&gt;SUPER::new&lt;/code&gt; вы должны вызвать:</target>
        </trans-unit>
        <trans-unit id="6f5a18b784416c2faf1e8dee13b0302a69a860cf" translate="yes" xml:space="preserve">
          <source>So, on the advice of the gettext manual, you rewrite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04546d861006181e7076b52be007eeaf163f592b" translate="yes" xml:space="preserve">
          <source>So, rather than having to say:</source>
          <target state="translated">Так что,вместо того,чтобы говорить:</target>
        </trans-unit>
        <trans-unit id="ce7cf438ffd137d4b9ae434030e4dd1bac347bb0" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt; ). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</source>
          <target state="translated">Итак, выражение &amp;laquo; &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; выполняет операцию &amp;laquo;и&amp;raquo; над числами (что дает &lt;code&gt;3&lt;/code&gt; ). Произнесение &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; выполняет операцию &amp;laquo;и&amp;raquo; над строками (в результате получается &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="82342d83c583203ac699858cccf76690e3807bf1" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt;). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a687b4464c81c65ad71b0b242c9a17889c06be5" translate="yes" xml:space="preserve">
          <source>So, sometimes you might want to use symbolic references to manipulate the symbol table directly. This doesn't matter for formats, handles, and subroutines, because they are always global--you can't use my() on them. For scalars, arrays, and hashes, though--and usually for subroutines-- you probably only want to use hard references.</source>
          <target state="translated">Поэтому иногда вам может понадобиться использовать символьные ссылки для прямого манипулирования таблицей символов.Это не имеет значения для форматов,дескрипторов и подпрограмм,потому что они всегда глобальны-вы не можете использовать мою()на них.Для скаляров,массивов и хэшей,хотя...и обычно для подпрограмм...вы,вероятно,хотите использовать только жесткие ссылки.</target>
        </trans-unit>
        <trans-unit id="988f750cf0c3c51b512a9cb6f00133978c0404e1" translate="yes" xml:space="preserve">
          <source>So, the following examples now works as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b62c1a83484ac0f80542a2de9bd04874ec15952" translate="yes" xml:space="preserve">
          <source>So, the following examples will now work all as expected:</source>
          <target state="translated">Итак,следующие примеры теперь будут работать,как и ожидалось:</target>
        </trans-unit>
        <trans-unit id="b83b5043b490e39d23dba00f7ce754a2ed020ba9" translate="yes" xml:space="preserve">
          <source>So, the following line:</source>
          <target state="translated">Итак,следующая строчка:</target>
        </trans-unit>
        <trans-unit id="e43264c4b337b0feb1da1b34ab4669d9bfde22ae" translate="yes" xml:space="preserve">
          <source>So, the following two statements do the same thing:</source>
          <target state="translated">Итак,следующие два заявления делают то же самое:</target>
        </trans-unit>
        <trans-unit id="0f5b24deb12867f441d62aa11cf38e02b6693a70" translate="yes" xml:space="preserve">
          <source>So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.</source>
          <target state="translated">Итак,строка марсианского &quot;I am CVSGXX!&quot; использует 12 байт для кодирования девяти символов 'I','','a','m','','CV','SG','XX',''!'.</target>
        </trans-unit>
        <trans-unit id="93058ef0377751cf8a22fa887d9f94acca14dc08" translate="yes" xml:space="preserve">
          <source>So, this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a65604ac4ef3bcdf6fdcf41ebba719fc161bed" translate="yes" xml:space="preserve">
          <source>So, what needs to replace gettext is a system that supports lexicons of functions instead of lexicons of strings. An entry in a lexicon from such a system should</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666f233dad00e2e027af2bcddbc736103b174459" translate="yes" xml:space="preserve">
          <source>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</source>
          <target state="translated">Так в чем же проблема? Выглядит правильно,не так ли? В конце концов,я только что сказал тебе,что тебе нужна масса ссылок,так что,чёрт возьми,ты сделал мне одну!</target>
        </trans-unit>
        <trans-unit id="c5f7a9040d43fdd63e7b31365a3279f444817139" translate="yes" xml:space="preserve">
          <source>So, you email your various translators (the boss decides that the languages du jour are Chinese, Arabic, Russian, and Italian, so you have one translator for each), asking for translations for &quot;I scanned %g directory.&quot; and &quot;I scanned %g directories.&quot;. When they reply, you'll put that in the lexicons for gettext to use when it localizes your software, so that when the user is running under the &quot;zh&quot; (Chinese) locale, gettext(&quot;I scanned %g directory.&quot;) will return the appropriate Chinese text, with a &quot;%g&quot; in there where printf can then interpolate $dir_scan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="1a669dbe9f824af2034872bc98a2b6823a4c09af" translate="yes" xml:space="preserve">
          <source>Socket option level constant for setsockopt() and getsockopt().</source>
          <target state="translated">Константа уровня опции сокета для setsockopt()и getockopt().</target>
        </trans-unit>
        <trans-unit id="e89a311c363b4ef4dc4be93eaeb6560498486275" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv4 socket options at the &lt;code&gt;IPPROTO_IP&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для параметров сокета IPv4 на уровне &lt;code&gt;IPPROTO_IP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d741b5bebfd867658e744ca3a901afeae953cecf" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv6 socket options at the &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для параметров сокета IPv6 на уровне &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bea3c52b1b205afb6610aaf669b9a46fdff261d" translate="yes" xml:space="preserve">
          <source>Socket option name constants for TCP socket options at the &lt;code&gt;IPPROTO_TCP&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для параметров сокета TCP на уровне &lt;code&gt;IPPROTO_TCP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8943cecdeb64eeb6c75caac188d81a6e580de3c7" translate="yes" xml:space="preserve">
          <source>Socket option name constants for setsockopt() and getsockopt() at the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level.</source>
          <target state="translated">Константы имени параметра сокета для setsockopt () и getsockopt () на уровне &lt;code&gt;SOL_SOCKET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a16f3d4e350888989be5c310a53b83649d06948" translate="yes" xml:space="preserve">
          <source>Socket option value constants for &lt;code&gt;IP_TOS&lt;/code&gt; socket option.</source>
          <target state="translated">Константы значения &lt;code&gt;IP_TOS&lt;/code&gt; сокета для параметра сокета IP_TOS .</target>
        </trans-unit>
        <trans-unit id="fa50a464d89f205a80a64569fe1c6e97815468d2" translate="yes" xml:space="preserve">
          <source>Socket option value contants for &lt;code&gt;IP_MTU_DISCOVER&lt;/code&gt; socket option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734337896e45cc2ebeff48479a66b46bdd05ddb4" translate="yes" xml:space="preserve">
          <source>Socket type constants to use as the second argument to socket(), or the value of the &lt;code&gt;SO_TYPE&lt;/code&gt; socket option.</source>
          <target state="translated">Константы типа сокета для использования в качестве второго аргумента функции socket () или значения &lt;code&gt;SO_TYPE&lt;/code&gt; сокета SO_TYPE .</target>
        </trans-unit>
        <trans-unit id="5bedda872ecdb70c2a2d140ada477f5b294eb6f0" translate="yes" xml:space="preserve">
          <source>Socket.</source>
          <target state="translated">Socket.</target>
        </trans-unit>
        <trans-unit id="ebe92a08483968e414740930bf0a0a08483ad931" translate="yes" xml:space="preserve">
          <source>Socket.a</source>
          <target state="translated">Socket.a</target>
        </trans-unit>
        <trans-unit id="848572346180cfeef643ccd7fddcc1762d26f13a" translate="yes" xml:space="preserve">
          <source>Sockets: Client/Server Communication</source>
          <target state="translated">Розетки:Связь между клиентом и сервером</target>
        </trans-unit>
        <trans-unit id="7ec10a4e74fb45054402ed905e46c34443ecf08d" translate="yes" xml:space="preserve">
          <source>Sockopts =&amp;gt; ARRAY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96898c7bdde72d33b35d72cb9458ecfe538b1436" translate="yes" xml:space="preserve">
          <source>Software distributions released to the CPAN include a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9951caf8addf9e39a4e5a9ec448dfc26c21d1a" translate="yes" xml:space="preserve">
          <source>Solaris (x86, SPARC)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfadcc007c702d16ecd0e6f6d3baeefff3d72aa" translate="yes" xml:space="preserve">
          <source>Solaris 10 documentation on syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</source>
          <target state="translated">Документация Solaris 10 по syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c7dc4f9a32286dc36b6fd2393ea8eff49fa670d" translate="yes" xml:space="preserve">
          <source>Solaris 11 documentation on syslog, &lt;a href=&quot;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&quot;&gt;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fa552d1b28be69cf1da96419b8a90307162871" translate="yes" xml:space="preserve">
          <source>Solaris 7 and above will run in either 32 bit or 64 bit mode on SPARC CPUs, via a reboot. You can build 64 bit apps whilst running 32 bit mode and vice-versa. 32 bit apps will run under Solaris running in either 32 or 64 bit mode. 64 bit apps require Solaris to be running 64 bit mode.</source>
          <target state="translated">Solaris 7 и выше будет работать либо в 32-битном,либо в 64-битном режиме на процессорах SPARC,путем перезагрузки.Вы можете создавать 64-битные приложения,работая в 32-битном режиме и наоборот.32-битные приложения будут работать в Solaris в 32 или 64-битном режиме.64-битные приложения требуют,чтобы Solaris работал в 64-битном режиме.</target>
        </trans-unit>
        <trans-unit id="bd381ce5f7739cf9ac8dad77ffda2188f3978def" translate="yes" xml:space="preserve">
          <source>Solaris Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed34c43c64cf4558fcdec9f488cfa58f0a1b6fe3" translate="yes" xml:space="preserve">
          <source>Solaris FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef2766b707c501497b46c746afec2754f6fc860" translate="yes" xml:space="preserve">
          <source>Solaris Version Numbers.</source>
          <target state="translated">Solaris Version Numbers.</target>
        </trans-unit>
        <trans-unit id="cc61dfb91810e5a0313350199a1b65c0af136cfa" translate="yes" xml:space="preserve">
          <source>Solaris global loading added by Nick Ing-Simmons with design/coding assistance from Tim Bunce, January 1996.</source>
          <target state="translated">Глобальная загрузка Solaris добавлена Ником Инг-Симмонсом с помощью дизайна/кодирования Тима Банса,январь 1996.</target>
        </trans-unit>
        <trans-unit id="708154fc528413c51483abd6933e68d503e36bdc" translate="yes" xml:space="preserve">
          <source>Solaris may include two versions of perl, e.g. Solaris 9 includes both 5.005_03 and 5.6.1. This is to provide stability across Solaris releases, in cases where a later perl version has incompatibilities with the version included in the preceding Solaris release. The default perl version will always be the most recent, and in general the old version will only be retained for one Solaris release. Note also that the default perl will NOT be configured to search for modules in the older version, again due to compatibility/stability concerns. As a consequence if you upgrade Solaris, you will have to rebuild/reinstall any additional CPAN modules that you installed for the previous Solaris version. See the CPAN manpage under 'autobundle' for a quick way of doing this.</source>
          <target state="translated">Solaris может включать две версии perl,например,Solaris 9 включает как 5.005_03,так и 5.6.1.Это необходимо для обеспечения стабильности во всех релизах Solaris в тех случаях,когда более поздняя версия perl несовместима с версией,включенной в предыдущий релиз Solaris.Перловая версия по умолчанию всегда будет самой последней,и,как правило,старая версия будет сохранена только в одном выпуске Solaris.Обратите также внимание,что perl по умолчанию НЕ будет настроен на поиск модулей в более старой версии,опять же по соображениям совместимости/стабильности.Как следствие,если вы обновите Solaris,вам придется пересобрать/переустановить все дополнительные модули CPAN,которые были установлены для предыдущей версии Solaris.Быстрый способ сделать это можно найти в меню CPAN в разделе &quot;Автоотборка&quot;.</target>
        </trans-unit>
        <trans-unit id="4bfa1cd2c976e4c546cb366d1dac1622384583a6" translate="yes" xml:space="preserve">
          <source>Solaris provides some BSD-compatibility functions in /usr/ucblib/libucb.a. Perl will not build and run correctly if linked against -lucb since it contains routines that are incompatible with the standard Solaris libc. Normally this is not a problem since the solaris hints file prevents Configure from even looking in /usr/ucblib for libraries, and also explicitly omits -lucb.</source>
          <target state="translated">Solaris предоставляет некоторые функции совместимости с BSD в файле /usr/ucblib/libucb.a.Perl не будет собираться и запускаться корректно,если он связан с -lucb,так как содержит подпрограммы,несовместимые со стандартной библиотекой Solaris libc.Обычно это не является проблемой,так как файл подсказок от Solaris не позволяет программе Configure даже искать в /usr/ucblib библиотеки,а также явно пропускает -lucb.</target>
        </trans-unit>
        <trans-unit id="d0c3f51965773ced91efb778a3671a3477592fd4" translate="yes" xml:space="preserve">
          <source>Solaris ships with a range of Solaris-specific modules. If you choose to install your own version of perl you will find the source of many of these modules is available on CPAN under the Sun::Solaris:: namespace.</source>
          <target state="translated">Корабли Solaris с рядом специфических модулей Solaris.Если вы решите установить свою собственную версию perl,вы найдете источник многих из этих модулей в CPAN под именем Sun::Solaris::.</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="9cdf28d779226e286e9b065703a4425b88267886" translate="yes" xml:space="preserve">
          <source>Solving the problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="5f679f54e4d0cf2197954f773a392f8d165d2696" translate="yes" xml:space="preserve">
          <source>Some (minor) parts copyright 2009 Adam Kennedy.</source>
          <target state="translated">Некоторые (незначительные)части авторского права 2009 Адам Кеннеди.</target>
        </trans-unit>
        <trans-unit id="3a644bfc8b4acacc1b56f8b5a49f0fbd16c47364" translate="yes" xml:space="preserve">
          <source>Some *nix programs use fork() a lot; with the mostly useful flavors of perl for OS/2 (there are several built simultaneously) this is supported; but some flavors do not support this (e.g., when Perl is called from inside REXX). Using fork() after</source>
          <target state="translated">Некоторые *nix-программы много используют fork();с наиболее полезными вкусами perl для OS/2 (есть несколько сборок одновременно)это поддерживается;но некоторые вкусы этого не поддерживают (например,когда Perl вызывается изнутри REXX).Использование fork()после</target>
        </trans-unit>
        <trans-unit id="6a808c47f9491da438c1507c81067e0d0ad1d610" translate="yes" xml:space="preserve">
          <source>Some / became \ in pdksh.</source>
          <target state="translated">Некоторые/стал \ в pdksh.</target>
        </trans-unit>
        <trans-unit id="2ced2108dbb21d847b539e5bf8d6eae4e6952b9e" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;/&lt;/code&gt; became &lt;code&gt;\&lt;/code&gt; in pdksh.</source>
          <target state="translated">Какой-то &lt;code&gt;/&lt;/code&gt; стал &lt;code&gt;\&lt;/code&gt; в пдкш.</target>
        </trans-unit>
        <trans-unit id="aee5f872bb2cc36da4c3ed1ff4e14aea96b6faa3" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Win*&lt;/code&gt; entry points also overload a &quot;meaningful&quot; return value with the error indicator; having a 0 return value indicates an error. Yet some other &lt;code&gt;Win*&lt;/code&gt; entry points overload things even more, and 0 return value may mean a successful call returning a valid value 0, as well as an error condition; in the case of a 0 return value one should call WinGetLastError() API to distinguish a successful call from a failing one.</source>
          <target state="translated">Некоторые точки входа &lt;code&gt;Win*&lt;/code&gt; также перегружают &quot;значимое&quot; возвращаемое значение индикатором ошибки; возвращаемое значение 0 указывает на ошибку. Однако некоторые другие точки входа &lt;code&gt;Win*&lt;/code&gt; еще больше перегружают ситуацию, и возвращаемое значение 0 может означать успешный вызов, возвращающий действительное значение 0, а также состояние ошибки; в случае возвращаемого значения 0 следует вызвать API WinGetLastError (), чтобы отличить успешный вызов от неудачного.</target>
        </trans-unit>
        <trans-unit id="7d77130c6b6fd9352c737bed1bb1dcb935bd9ca9" translate="yes" xml:space="preserve">
          <source>Some DLLs are only present in some versions of OS/2, or in some configurations of OS/2. Some exported entry points are present only in DLLs shipped with some versions of OS/2. If these DLLs and entry points were linked directly for a Perl executable/DLL or from a Perl extensions, this binary would work only with the specified versions/setups. Even if these entry points were not needed, the</source>
          <target state="translated">Некоторые DLL присутствуют только в некоторых версиях OS/2 или в некоторых конфигурациях OS/2.Некоторые экспортированные точки входа присутствуют только в DLL,поставляемых с некоторыми версиями OS/2.Если бы эти DLL и точки входа были напрямую связаны с исполняемым файлом/ДЛЛ или с расширением Perl,то этот двоичный файл работал бы только с указанными версиями/настройками.Даже если бы эти точки входа не были нужны,то</target>
        </trans-unit>
        <trans-unit id="8e4ba3d45352907bcc89de2a6a57c8be8f5ee286" translate="yes" xml:space="preserve">
          <source>Some Filters Clobber the &lt;code&gt;DATA&lt;/code&gt; Handle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14adc2a370c74e9f0b7a6eb136961fb44f4e9d5e" translate="yes" xml:space="preserve">
          <source>Some IBM EBCDIC character sets may be known by character code set identification numbers (CCSID numbers) or code page numbers.</source>
          <target state="translated">Некоторые наборы символов IBM EBCDIC могут быть известны по идентификационным номерам наборов символов (CCSID-номера)или номерам кодовых страниц.</target>
        </trans-unit>
        <trans-unit id="20970d609d169c267b614af470114dc6b026c453" translate="yes" xml:space="preserve">
          <source>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known to have issues (coredumps) when compiling perl.c. If you've used -OPT:fast_io=ON and this happens, try removing it. If that fails, or you didn't use that, then try adjusting other optimization options (-LNO, -INLINE, -O3 to -O2, etcetera). The compiler bug has been reported to SGI. (Allen Smith &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</source>
          <target state="translated">Известно, что некоторые версии Irix cc, например 7.3.1.1m (попробуйте cc -version), имеют проблемы (coredump) при компиляции perl.c. Если вы использовали -OPT: fast_io = ON и это случилось, попробуйте удалить его. Если это не помогло или вы не использовали это, попробуйте настроить другие параметры оптимизации (-LNO, -INLINE, -O3 на -O2 и т. Д.). Об ошибке компилятора было сообщено в SGI. (Аллен Смит &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</target>
        </trans-unit>
        <trans-unit id="e270800f9e2c9ef58198c6c9f8463f63bac86a3b" translate="yes" xml:space="preserve">
          <source>Some Linux platforms have a maximum stack size. Setting too large of a stack size will cause thread creation to fail.</source>
          <target state="translated">Некоторые платформы Linux имеют максимальный размер стека.Установка слишком большого размера стека приведет к неудачному созданию потока.</target>
        </trans-unit>
        <trans-unit id="bad9f67e1f3cb77c4fe9db59234d0c5d6bb841b2" translate="yes" xml:space="preserve">
          <source>Some OSes do not need these in which case leave it blank.</source>
          <target state="translated">Некоторым операционным системам они не нужны,в этом случае оставьте их пустыми.</target>
        </trans-unit>
        <trans-unit id="69e7c8fdafb5d76df4c8f736ecf437657f4dc150" translate="yes" xml:space="preserve">
          <source>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I'll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don't break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&amp;lt;160&amp;gt;&quot; or &quot;E&amp;lt;nbsp&amp;gt;&quot; code); and Pod can contain &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; as if it were &quot;foo</source>
          <target state="translated">Некоторые средства форматирования Pod выводят в форматы, которые реализуют неразрывные пробелы как отдельный символ (который я назову &quot;NBSP&quot;), а другие - в форматы, которые реализуют неразрывные пробелы, точно так же, как пробелы, заключенные в &quot;не нарушайте это через строки &quot;кода. Обратите внимание, что на уровне Pod могут встречаться оба вида кодов: Pod может содержать символ NBSP (либо как буквальный, либо как код &amp;laquo;E &amp;lt;160&amp;gt;&amp;raquo; или &amp;laquo;E &amp;lt;nbsp&amp;gt;&amp;raquo;); и Pod может содержать коды &amp;laquo;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&amp;raquo;, где &amp;laquo;простые пробелы&amp;raquo; (символ 32) в таких кодах используются для обозначения неразрывных пробелов. Парсерам Pod следует рассмотреть возможность поддержки необязательного анализа &quot;S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;&quot;, как если бы это был &quot;foo</target>
        </trans-unit>
        <trans-unit id="f04294d93d5e63f6eed93e1148616595ef1487e2" translate="yes" xml:space="preserve">
          <source>Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants. Since these were constant across all architectures, they were often hardwired into perl code. The proper way to deal with this is to &quot;use Socket&quot; to get the correct values.</source>
          <target state="translated">Некоторые системы на базе Sys-V,в частности Solaris 2.X,переопределили некоторые стандартные константы сокетов.Так как они были постоянными во всех архитектурах,они часто были жестко соединены в код на perl.Правильным способом решения этой проблемы является &quot;использование сокета&quot; для получения правильных значений.</target>
        </trans-unit>
        <trans-unit id="a5a0c5f6bf86975f2c301ba492652230f705bf5a" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories.</source>
          <target state="translated">Некоторые свойства Unicode имеют ограниченный набор допустимых значений. Например, все двоичные свойства ограничены только &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; ; а возможных общих категорий всего несколько десятков.</target>
        </trans-unit>
        <trans-unit id="9e6eb6762559c642717c0b35b0e9407b4ea3c431" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">Некоторые свойства Unicode имеют ограниченный набор допустимых значений. Например, все двоичные свойства ограничены только &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; ; а возможных общих категорий всего несколько десятков. Используйте &lt;code&gt;prop_values&lt;/code&gt; , чтобы узнать, является ли данное свойство одним из таких, и если да, чтобы получить список значений:</target>
        </trans-unit>
        <trans-unit id="5c1e962daca68404a4b5aeb9ebaf19ea3e632a80" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f826abadcb88c4b8481c939d03177c526f688d85" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da934a0c72e4b177f3b0df8a238ca7ff76fadba5" translate="yes" xml:space="preserve">
          <source>Some Unixes, especially more recent ones, are free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16213d61f5d76543cce7f4b52c976b8f28e064a" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd2e23e9cee0c22d7103f4f9a78d73d761dd3aa" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;code&gt;$^O&lt;/code&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">Некоторые приблизительные названия операционных систем и их значения &lt;code&gt;$^O&lt;/code&gt; в категории &amp;laquo;ДРУГОЕ&amp;raquo; включают:</target>
        </trans-unit>
        <trans-unit id="fc63731ea34f43c4af1c4ec405f7ea69ef1d9704" translate="yes" xml:space="preserve">
          <source>Some authors have strange characters in their names.</source>
          <target state="translated">У некоторых авторов в имени есть странные символы.</target>
        </trans-unit>
        <trans-unit id="6877eb2746dbad4bb0e9e27d968022bfea3412f0" translate="yes" xml:space="preserve">
          <source>Some background on thread implementations from the operating system viewpoint. There are three basic categories of threads: user-mode threads, kernel threads, and multiprocessor kernel threads.</source>
          <target state="translated">Некоторая подоплека реализации потоков с точки зрения операционной системы.Существует три основные категории потоков:потоки пользовательского режима,потоки ядра и многопроцессорные потоки ядра.</target>
        </trans-unit>
        <trans-unit id="fc0d6a626635ac5ae4291cc3487e50efd6ae5a14" translate="yes" xml:space="preserve">
          <source>Some bits may be relevant at compile-time only, some at run-time only. This is a new mechanism and the details may change. See also &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">Некоторые биты могут иметь значение только во время компиляции, некоторые - только во время выполнения. Это новый механизм, и детали могут измениться. См. Также &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd8e9b1766f0e1e6eaaded7abc870a37e4571ff0" translate="yes" xml:space="preserve">
          <source>Some brief examples:</source>
          <target state="translated">Несколько кратких примеров:</target>
        </trans-unit>
        <trans-unit id="61327002f5b3861abd79c62e144ccb79536f4f22" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">Некоторые встроенные команды (например, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; ) имеют сигнатуру вызова, которую нельзя полностью представить с помощью прототипа Perl. Это означает, что какой-то действующий код Perl будет недействителен при автозаполнении. Например:</target>
        </trans-unit>
        <trans-unit id="7e79ef5917eeda28b646e901197de5a6a38623ed" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;chdir&lt;/code&gt; or &lt;code&gt;truncate&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21eaccc7842c81c4d4f8ac981ea6b511271286ba" translate="yes" xml:space="preserve">
          <source>Some calls simply aren't available, real or emulated, on every platform.</source>
          <target state="translated">Некоторые звонки просто недоступны,реальные или эмулированные,на каждой платформе.</target>
        </trans-unit>
        <trans-unit id="f873ff9032d8b5cf7f774b66c05c986170a4cd42" translate="yes" xml:space="preserve">
          <source>Some characters have multiple names (synonyms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7144ad6e6fa073f902e93d5905df49ebac937d92" translate="yes" xml:space="preserve">
          <source>Some code points also have abbreviated names, such as &quot;LF&quot; or &quot;NL&quot;. &lt;code&gt;viacode&lt;/code&gt; never returns these.</source>
          <target state="translated">Некоторые кодовые точки также имеют сокращенные имена, такие как &amp;laquo;LF&amp;raquo; или &amp;laquo;NL&amp;raquo;. &lt;code&gt;viacode&lt;/code&gt; никогда их не возвращает.</target>
        </trans-unit>
        <trans-unit id="73ac6d49c092929d2ed08d514c7b1beb64ede02a" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">Некоторый код взят из &lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt; , написанный Майклом Шверном &amp;lt;schwern@pobox.com&amp;gt;. Следовательно, эти части Copyright Micheal G Schwern 2001. Используется и распространяется с разрешения.</target>
        </trans-unit>
        <trans-unit id="5561c8c582f640440613f3fca93ddc04efa36da2" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e5cd1d1e32143aa0622aa3ff5ac884d8c3a28f" translate="yes" xml:space="preserve">
          <source>Some comparison operators, as their associativity,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1339e50839100723841e8e48747e9f9a1f5bed3" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">Некоторые константы и функции по умолчанию экспортируются этим модулем; но для обратной совместимости любые недавно добавленные символы не экспортируются по умолчанию и должны запрашиваться явно. Когда список импорта предоставляется в строке &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; , экспорт по умолчанию не импортируется автоматически. Поэтому рекомендуется всегда явно перечислять все необходимые символы.</target>
        </trans-unit>
        <trans-unit id="54e9eafb99e932590ca2a179b6517831860be80f" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;use Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078dd465c32a4795a8e3e38bd49c7d92d32009a8" translate="yes" xml:space="preserve">
          <source>Some constants don't print correctly either with or without &lt;b&gt;-d&lt;/b&gt;. For instance, neither B::Deparse nor Data::Dumper know how to print dual-valued scalars correctly, as in:</source>
          <target state="translated">Некоторые константы не печатаются правильно ни с &lt;b&gt;-d,&lt;/b&gt; ни без него . Например, ни B :: Deparse, ни Data :: Dumper не знают, как правильно печатать двузначные скаляры, как в:</target>
        </trans-unit>
        <trans-unit id="c475f4b24c437233a2b88333a558801f98c19297" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;&quot;Octal escapes&quot; in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt;, or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e689eba4cf9a38a4acdff5d45d4adaf1f020711" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;Octal escapes in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt; , or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">Некоторые контексты позволяют использовать 2 или даже 1 цифру, но любое использование без ровно трех цифр, первая из которых - ноль, может дать непредвиденные результаты. (Например, в регулярном выражении его можно спутать с &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;обратной ссылкой&lt;/a&gt; ; см. Octal escape-последовательности в perlrebackslash .) Начиная с Perl 5.14, вы можете вместо этого использовать &lt;code&gt;\o{}&lt;/code&gt; , что позволяет избежать всех этих проблем. В противном случае лучше всего использовать эту конструкцию только для порядковых номеров &lt;code&gt;\077&lt;/code&gt; и ниже, не забывая заполнять слева нулями, чтобы получить три цифры. Для более крупных порядковых номеров используйте &lt;code&gt;\o{}&lt;/code&gt; или конвертируйте в другое, например в шестнадцатеричное, и используйте вместо него &lt;code&gt;\N{U+}&lt;/code&gt; (который переносится между платформами с разными наборами символов) или &lt;code&gt;\x{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17469d7643e0741d1ada43cbcada6ad7b4213174" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;)</source>
          <target state="translated">Несколько классных примеров из командной строки,чтобы произвести впечатление на толпу Python ;)</target>
        </trans-unit>
        <trans-unit id="4f597c06196db5dfae23debf5b526fce9cd25685" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;) You might want to compare them to the results under -Mbignum or -Mbigrat:</source>
          <target state="translated">Несколько классных примеров из командной строки,чтобы произвести впечатление на толпу Python ;)Возможно,вы захотите сравнить их с результатами в -Mbignum или -Mbigrat:</target>
        </trans-unit>
        <trans-unit id="c6746b978d2a5bd75b46a34b757950222f7e2d87" translate="yes" xml:space="preserve">
          <source>Some database drivers for DBI can also automatically encode and decode, but that is sometimes limited to the UTF-8 encoding.</source>
          <target state="translated">Некоторые драйверы баз данных для DBI также могут автоматически кодировать и декодировать,но иногда это ограничивается кодировкой UTF-8.</target>
        </trans-unit>
        <trans-unit id="20c968c59a29a0ad6a0ddbad176bb82749120644" translate="yes" xml:space="preserve">
          <source>Some devices will be expecting a &quot;\r&quot; at the end of each line rather than a &quot;\n&quot;. In some ports of perl, &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix) ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to give the numeric values you want directly, using octal (&quot;\015&quot;), hex (&quot;0x0D&quot;), or as a control-character specification (&quot;\cM&quot;).</source>
          <target state="translated">Некоторые устройства будут ожидать в конце каждой строки &quot;\r&quot;,а не &quot;\n&quot;.В некоторых портах perl,&quot;\r&quot; и &quot;\n&quot; отличаются от своих обычных (Unix)ASCII-значений &quot;\015&quot; и &quot;\012&quot;.Вам может потребоваться указать нужные вам числовые значения напрямую,используя восьмеричное (&quot;\015&quot;),шестнадцатеричное (&quot;0x0D&quot;),или в качестве спецификации управляющего символа (&quot;\cM&quot;).</target>
        </trans-unit>
        <trans-unit id="29952c75d7a51b190a8cddfeefebadadc1b42414" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038), and LEPCHA DIGIT SIX (U+1C46) looks very much like an ASCII DIGIT FIVE (U+0035). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt;, the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;&quot;num()&quot; in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;undef&lt;/code&gt; if the input string contains such a mixture. Otherwise, for example, a displayed price might be deliberately different than it appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15270299f74ddedc9cb2a27cec0a8d56d430a18" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt; , the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the input string contains such a mixture.</source>
          <target state="translated">Некоторые цифры, которым соответствует &lt;code&gt;\d&lt;/code&gt; выглядят как цифры [0-9], но имеют разные значения. Например, BENGALI DIGIT FOUR (U + 09EA) очень похоже на ASCII DIGIT EIGHT (U + 0038). Приложение, которое ожидает только цифры ASCII, может быть введено в заблуждение, или, если совпадение равно &lt;code&gt;\d+&lt;/code&gt; , соответствующая строка может содержать смесь цифр из разных систем записи, которые выглядят так, как будто они обозначают число, отличное от того, что есть на самом деле. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num () в Unicode :: UCD&lt;/a&gt; можно использовать для безопасного вычисления значения, возвращая &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если входная строка содержит такую ​​смесь.</target>
        </trans-unit>
        <trans-unit id="eb6208f023afd54f9f4acc30a7d493bf14dc6378" translate="yes" xml:space="preserve">
          <source>Some distributions may fail some tests, but you may want to install them anyway (as above, or via &lt;code&gt;force install&lt;/code&gt; command of &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode).</source>
          <target state="translated">Некоторые дистрибутивы могут не пройти некоторые тесты, но вы все равно можете их установить (как указано выше или с помощью команды &lt;code&gt;force install&lt;/code&gt; в &lt;code&gt;CPAN.pm&lt;/code&gt; оболочки CPAN.pm ).</target>
        </trans-unit>
        <trans-unit id="673083d85e2bc8b38798cec75fcc0568d074003d" translate="yes" xml:space="preserve">
          <source>Some distributions may need to link to libraries or other third-party code and their build and installation sequences may be more complicated. Check any</source>
          <target state="translated">Некоторые дистрибутивы могут нуждаться в ссылках на библиотеки или другой сторонний код,а их последовательность сборки и установки может быть более сложной.Проверьте любой</target>
        </trans-unit>
        <trans-unit id="1c42a00c69d1bae42ece6b69f30632a5649a6c28" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;a href=&quot;perldoc&quot;&gt;&lt;code&gt;perldoc perldoc&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;man perldoc&lt;/code&gt;) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14b5226c1b3194a20df87855367bd2962c1e595" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;code&gt;perldoc perldoc&lt;/code&gt; or &lt;code&gt;man perldoc&lt;/code&gt; ) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">Некоторая документация недоступна в виде страниц руководства, поэтому, если человек не нашел перекрестной ссылки, попробуйте ее с помощью &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; . Perldoc также может перенаправить вас прямо к документации по функциям (с ключом &lt;b&gt;-f&lt;/b&gt; ). См. &lt;code&gt;perldoc --help&lt;/code&gt; (или &lt;code&gt;perldoc perldoc&lt;/code&gt; или &lt;code&gt;man perldoc&lt;/code&gt; ) для получения информации о других полезных опциях, &lt;a href=&quot;perldoc&quot;&gt;которые&lt;/a&gt; может предложить perldoc .</target>
        </trans-unit>
        <trans-unit id="24f338e775f9d8f25e87916116198ed5fdfd8fac" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt; .</source>
          <target state="translated">В некоторых более ранних версиях этого модуля была документация с некоторыми сбивающими с толку опечатками в описании &lt;code&gt;skip(...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="755fe62cf032f564de90de30771b7c019c165183" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5fff71fc694b06c17e66dad87b134506e2302b" translate="yes" xml:space="preserve">
          <source>Some essentially obsolete locales that aren't supersets of ASCII, mainly those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have problems, depending on what portions of the ASCII character set get changed by the locale and are also used by the program. The warning message lists the determinable conflicting characters.</source>
          <target state="translated">Некоторые по сути устаревшие локали,не являющиеся суперсетями ASCII,в основном те,что в ISO 646 или других 7-битных локалях,таких как ASMO 449,также могут иметь проблемы,в зависимости от того,какие части набора символов ASCII изменяются локалью и также используются программой.Предупреждающее сообщение содержит список определяемых конфликтующих символов.</target>
        </trans-unit>
        <trans-unit id="e8b38cbb77fcb476bf8e2983ccfda5ed33f46a79" translate="yes" xml:space="preserve">
          <source>Some example section specifications follow.</source>
          <target state="translated">Ниже приведены некоторые примеры спецификаций разделов.</target>
        </trans-unit>
        <trans-unit id="6e29ae8ec1bfc30435ce56e5aeb3c20b82d6940f" translate="yes" xml:space="preserve">
          <source>Some examples of lists include:</source>
          <target state="translated">Некоторые примеры списков включают в себя:</target>
        </trans-unit>
        <trans-unit id="ae84b84bf5612613743104cf4d1d3f624e770f5d" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically invalid attribute lists (with annotation):</source>
          <target state="translated">Некоторые примеры синтаксически неправильных списков атрибутов (с аннотацией):</target>
        </trans-unit>
        <trans-unit id="9c0e82c6c1b276d5dbb162e62c1346aa697136e3" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically valid attribute lists:</source>
          <target state="translated">Некоторые примеры синтаксически корректных списков атрибутов:</target>
        </trans-unit>
        <trans-unit id="9ef77adb00cc27df250473773f43482c29f3a24d" translate="yes" xml:space="preserve">
          <source>Some examples of valid string input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Несколько примеров:</target>
        </trans-unit>
        <trans-unit id="75d23fa0c37e5a03812b09ef6b9c46fbb0fa3389" translate="yes" xml:space="preserve">
          <source>Some extensions provide filters on data entry/exit points, such as &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; and family. Look out for such filters in the documentation of your extensions; they can make the transition to Unicode data much easier.</source>
          <target state="translated">Некоторые расширения предоставляют фильтры по точкам ввода / вывода данных, например &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; и family. Обратите внимание на такие фильтры в документации к вашим расширениям; они могут значительно упростить переход к данным Unicode.</target>
        </trans-unit>
        <trans-unit id="1ba2d8223f5d5832c6d62c8b546d87c608dd84fc" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt; ). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">Некоторые расширения, такие как DB_File и Compress :: Zlib, используют / требуют предварительно построенных библиотек для работы расширений / модулей perl. Если эти библиотеки построены с использованием конфигурации по умолчанию, может случиться так, что вы столкнетесь с ошибкой, такой как &amp;laquo;неверное исправление загрузчика&amp;raquo; на этапе загрузки. HP знает об этой проблеме. Поищите на форумах HP-UX cxx-dev обсуждение этой темы. Короткий ответ: &lt;b&gt;все&lt;/b&gt; (все библиотеки, все) должно быть скомпилировано с помощью &lt;code&gt;+z&lt;/code&gt; или &lt;code&gt;+Z&lt;/code&gt; , чтобы быть PIC (позиционно-независимым кодом). (Для gcc это будет &lt;code&gt;-fpic&lt;/code&gt; или &lt;code&gt;-fPIC&lt;/code&gt; ). В HP-UX 11.00 или новее в сообщении об ошибке компоновщика должно быть указано имя объектного файла, вызывающего нарушение.</target>
        </trans-unit>
        <trans-unit id="97e5fb9532f2e63b2e8307d7b53c5f2c9628f824" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt;). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96048dd05a92d52cf8eb93ed66aaff949feef0b8" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources with the default flags. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7fd53f722062eada03c99c5c0131726fe7cb4c" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">Некоторые функции Storable могут привести к уязвимостям безопасности,если вы принимаете документы Storable из недоверенных источников.Очевидно,что опциональная (по умолчанию выключенная)функция CODE сериализации ссылок позволяет перенести код на процесс десериализации.Более того,любой сериализованный объект заставит Storable удобно загрузить модуль,соответствующий классу объекта в модуле десериализации.Для манипулирования именами модулей это может привести к загрузке практически произвольного кода.Наконец,деструкторы десериализованного объекта будут вызваны,когда объекты будут уничтожены в процессе десериализации.Злоумышленно созданные документы Storable могут поместить такие объекты в значение хэш-ключа,который переопределяется другой парой ключ/значение в том же хэше,вызывая тем самым немедленное выполнение деструктора.</target>
        </trans-unit>
        <trans-unit id="f752a90675005dd54235d7444500f6345be768a8" translate="yes" xml:space="preserve">
          <source>Some fields (prereq, optional_features) indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the Version Range type used to provide this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4359f8aa4aabe1dad1748bdef1a7b9a37c1bbf67" translate="yes" xml:space="preserve">
          <source>Some fields are marked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db1ec9986268b7b9f60738685c3882e9bc3347c" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.) to indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the version specification formats that are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97585d9b5872f5fb97ab1bbd9ba4d3f871bc3309" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.). This section details the version specifications that are currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a5845f2d183141d3d5841eae9982c91a04a877" translate="yes" xml:space="preserve">
          <source>Some filesystems may not support UTF-8 file names, or they may be supported incompatibly with Perl. Therefore UTF-8 names that are visible to the filesystem, such as module names may not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410f15ec6c766d4ad924aef6bed79d8486d14679" translate="yes" xml:space="preserve">
          <source>Some folks are surprised that &lt;code&gt;make distclean&lt;/code&gt; does not delete everything not listed in their MANIFEST (thus making a clean distribution) but only tells them what they need to delete. This is done because it is considered too dangerous. While developing your module you might write a new file, not add it to the MANIFEST, then run a &lt;code&gt;distclean&lt;/code&gt; and be sad because your new work was deleted.</source>
          <target state="translated">Некоторые удивляются, что &lt;code&gt;make distclean&lt;/code&gt; не удаляет все, что не указано в их МАНИФЕСТЕ (таким образом, создавая чистый дистрибутив), а только сообщает им, что им нужно удалить. Это сделано потому, что это считается слишком опасным. При разработке модуля вы можете написать новый файл, а не добавлять его в &lt;code&gt;distclean&lt;/code&gt; а затем запустить distclean и расстроиться , потому что ваша новая работа была удалена.</target>
        </trans-unit>
        <trans-unit id="278e93ddc6a44b33edbb2aa1b1e3252bdefc68ee" translate="yes" xml:space="preserve">
          <source>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.</source>
          <target state="translated">Некоторые предпочитают полные буквенно-цифровые прототипы.Буквенно-цифровые прототипы были намеренно оставлены без прототипов для того,чтобы когда-нибудь в будущем добавить именованные,формальные параметры.Основная цель текущего механизма-позволить авторам модулей обеспечить лучшую диагностику для пользователей модуля.Ларри чувствует,что нотация вполне понятна программистам на Perl,и что она не будет сильно мешать работе модуля,и не сделает ее более сложной для чтения.Шум линии визуально заключен в маленькую таблетку,которую легко проглотить.</target>
        </trans-unit>
        <trans-unit id="97b6babea6d7a1882a7f9edff1a7d1c57e6e6a28" translate="yes" xml:space="preserve">
          <source>Some format names that formatters currently are known to accept include &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;, and &quot;html&quot;. (Some formatters will treat some of these as synonyms.)</source>
          <target state="translated">Некоторые имена форматов,которые форматоры в настоящее время принимают,включают &quot;roff&quot;,&quot;man&quot;,&quot;latex&quot;,&quot;tex&quot;,&quot;text&quot; и &quot;html&quot;.(Некоторые форматоры будут рассматривать некоторые из них как синонимы).</target>
        </trans-unit>
        <trans-unit id="947f64f8eb13b365edd8f2a637d714cf57c4bdc9" translate="yes" xml:space="preserve">
          <source>Some formatter subclasses use this as a flag for whether output should have prologue and epilogue code omitted. For example, setting this to true for an HTML formatter class should omit the &quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;...&amp;lt;/title&amp;gt;&amp;lt;body&amp;gt;...&quot; prologue and the &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; epilogue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae9c58f7596d57c13463eeb374970b17faa09ff" translate="yes" xml:space="preserve">
          <source>Some frequently seen examples:</source>
          <target state="translated">Некоторые часто встречающиеся примеры:</target>
        </trans-unit>
        <trans-unit id="5f63fbe742ecc7df05393f6e705a1b34f98dd874" translate="yes" xml:space="preserve">
          <source>Some functions are provided to simplify customization.</source>
          <target state="translated">Некоторые функции предоставляются для упрощения настройки.</target>
        </trans-unit>
        <trans-unit id="37fca23bc4f77bc45e835fb641ab69a99facbd7e" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">Некоторые функции работают медленнее при работе со строками в кодировке UTF-8, чем со строками в байтовой кодировке. Все функции, которым необходимо перескакивать через символы, такие как &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; , или соответствующие регулярные выражения, могут работать &lt;b&gt;намного&lt;/b&gt; быстрее, если базовые данные закодированы в байтах.</target>
        </trans-unit>
        <trans-unit id="29d81f6ce46ee6c8888e985a057496dc42144979" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;length()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt; or &lt;code&gt;index()&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83116620b210d6b01d6ea586806a731e05a2beb8" translate="yes" xml:space="preserve">
          <source>Some functions available based on the version of VMS. (VMS)</source>
          <target state="translated">Некоторые функции доступны на основе версии VMS.(ЗИС)</target>
        </trans-unit>
        <trans-unit id="851bf3122418d781546b0c8256e17049b7be4c91" translate="yes" xml:space="preserve">
          <source>Some languages work directly with the memory addresses of values, but this can be like playing with fire. Perl provides a set of asbestos gloves for handling all memory management. The closest to an address operator in Perl is the backslash operator, but it gives you a &lt;b&gt;hard reference&lt;/b&gt;, which is much safer than a memory address.</source>
          <target state="translated">Некоторые языки работают напрямую с адресами памяти значений, но это может быть похоже на игру с огнем. Perl предоставляет набор асбестовых перчаток для управления всей памятью. Наиболее близким к оператору адреса в Perl является оператор обратной косой черты, но он дает вам &lt;b&gt;жесткую ссылку&lt;/b&gt; , которая намного безопаснее, чем адрес памяти.</target>
        </trans-unit>
        <trans-unit id="3b63ca608d0f3df96b959d17a1dcc8d27338725f" translate="yes" xml:space="preserve">
          <source>Some layers will automatically insert required lower level layers if not present; for example &lt;code&gt;:perlio&lt;/code&gt; will insert &lt;code&gt;:unix&lt;/code&gt; below itself for low level IO, and &lt;code&gt;:encoding&lt;/code&gt; will insert the platform defaults for buffered IO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2879836a3b0aef43a136fc41d29e15e272723203" translate="yes" xml:space="preserve">
          <source>Some libraries use methods that don't modify their argument, and some libraries don't even use objects, but rather unblessed references. Because of this, liberary methods are always called as class methods, not instance methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2704cdd835e2ffc2151c5b3e73d345acc2100f0" translate="yes" xml:space="preserve">
          <source>Some locales have special sorting rules.</source>
          <target state="translated">В некоторых местах есть специальные правила сортировки.</target>
        </trans-unit>
        <trans-unit id="4cbad0bcc8b3efd678863ec66e302790409bbb20" translate="yes" xml:space="preserve">
          <source>Some methods take slightly different arguments to those defined in &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; in attempt to make the interface more flexible. These are</source>
          <target state="translated">Некоторые методы принимают аргументы, немного отличающиеся от аргументов, определенных в &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc,&lt;/a&gt; чтобы сделать интерфейс более гибким. Эти</target>
        </trans-unit>
        <trans-unit id="4d5ca2cd44839d0147fa7ed895887914f1a8f96d" translate="yes" xml:space="preserve">
          <source>Some modules have an event loop, waiting for user-input. It is highly unlikely that two such modules would work adequately together in a single Perl application.</source>
          <target state="translated">Некоторые модули имеют цикл обработки событий,ожидающий пользовательского ввода.Весьма маловероятно,что два таких модуля будут адекватно работать вместе в одном Perl-приложении.</target>
        </trans-unit>
        <trans-unit id="e535cd54feac531816f027ba1cdedeba3dabdc08" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99aeed54cc1e7c695f296661c28f743d9f582de7" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">Некоторые модули имеют проверку для определенных типов ввода, таких как &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt; и &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8896acdebb142a8bf319a25d0ebc467b0372d0f5" translate="yes" xml:space="preserve">
          <source>Some modules live both in the &lt;b&gt;Standard Library&lt;/b&gt; and on &lt;b&gt;CPAN&lt;/b&gt;. These modules might be developed on two tracks as people modify either version. The trend currently is to untangle these situations.</source>
          <target state="translated">Некоторые модули находятся как в &lt;b&gt;стандартной библиотеке, так&lt;/b&gt; и на &lt;b&gt;CPAN&lt;/b&gt; . Эти модули могут быть разработаны по двум направлениям, поскольку люди изменяют любую версию. В настоящее время существует тенденция распутывать эти ситуации.</target>
        </trans-unit>
        <trans-unit id="267ef3c8246a5b5e4dbd867563c1e64b65448f37" translate="yes" xml:space="preserve">
          <source>Some modules look directly at hash keys on the Test::Builder singleton. The problem here is that the Test::Builder singleton no longer holds anything important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215c8776bbaeb0d62cdfe5e95b87468adeef4092" translate="yes" xml:space="preserve">
          <source>Some modules may call a non-perl library that is locale-aware. This is fine as long as it doesn't try to query or change the locale using the system &lt;code&gt;setlocale&lt;/code&gt;. But if these do call the system &lt;code&gt;setlocale&lt;/code&gt;, those calls may be ineffective. Instead, &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&lt;code&gt;Perl_setlocale&lt;/code&gt;&lt;/a&gt; works in all circumstances. Plain setlocale is ineffective on multi-threaded POSIX 2008 systems. It operates only on the global locale, whereas each thread has its own locale, paying no attention to the global one. Since converting these non-Perl libraries to &lt;code&gt;Perl_setlocale&lt;/code&gt; is out of the question, there is a new function in v5.28 &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;switch_to_global_locale&lt;/code&gt;&lt;/a&gt; that will switch the thread it is called from so that any system &lt;code&gt;setlocale&lt;/code&gt; calls will have their desired effect. The function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;&lt;code&gt;sync_locale&lt;/code&gt;&lt;/a&gt; must be called before returning to perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2536c5611f03605401087c295c560b8c0a55966f" translate="yes" xml:space="preserve">
          <source>Some modules might have special reporting requirements, such as a Github or Google Code tracking system, so you should check the module documentation too.</source>
          <target state="translated">Некоторые модули могут иметь специальные требования к отчетности,например,система отслеживания Github или Google Code,поэтому вам также следует проверить документацию по модулю.</target>
        </trans-unit>
        <trans-unit id="9d3dcbb265761ea263567338345aa34c90c2eea2" translate="yes" xml:space="preserve">
          <source>Some modules, mainly extensions, provide their own AUTOLOAD subroutines. They typically need to check for some special cases (such as constants) and then fallback to &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD for the rest.</source>
          <target state="translated">Некоторые модули, в основном расширения, предоставляют свои собственные подпрограммы AUTOLOAD. Обычно им необходимо проверить некоторые особые случаи (такие как константы), а затем вернуться к &lt;b&gt;AUTOLOAD&lt;/b&gt; AutoLoader для остальных.</target>
        </trans-unit>
        <trans-unit id="f0adb7b022a9b5dadbc9c6aa9b58b0a54e7f8265" translate="yes" xml:space="preserve">
          <source>Some more examples, all returning 250:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c12ec8767768e2405ac12fa9dd3e5b3e02eaa4d" translate="yes" xml:space="preserve">
          <source>Some names known to &lt;code&gt;\N{...}&lt;/code&gt; refer to a sequence of multiple characters, instead of the usual single character. When one of these is included in the class, the entire sequence is matched. For example,</source>
          <target state="translated">Некоторые имена, известные для &lt;code&gt;\N{...}&lt;/code&gt; относятся к последовательности из нескольких символов вместо обычного одиночного символа. Когда один из них включен в класс, сопоставляется вся последовательность. Например,</target>
        </trans-unit>
        <trans-unit id="86874fce71a4882d328a8877cd2a4fc52a6a4fe2" translate="yes" xml:space="preserve">
          <source>Some networking library functions like gethostbyname() are known to have their own implementations of timeouts which may conflict with your timeouts. If you have problems with such functions, try using the POSIX sigaction() function, which bypasses Perl safe signals. Be warned that this does subject you to possible memory corruption, as described above.</source>
          <target state="translated">Некоторые функции сетевой библиотеки,такие как gethostbyname(),как известно,имеют свои собственные реализации таймаутов,которые могут конфликтовать с вашими таймаутами.Если у вас возникли проблемы с такими функциями,попробуйте использовать POSIX функцию sigaction(),которая обходит безопасные сигналы Perl.Предупреждаем,что это может привести к повреждению памяти,как описано выше.</target>
        </trans-unit>
        <trans-unit id="0ce6014b84ac6fe075f649ff6034ad219b7b909a" translate="yes" xml:space="preserve">
          <source>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl &lt;code&gt;Present_In&lt;/code&gt; property; just be aware of that.</source>
          <target state="translated">Некоторые реализации свойства Age, не относящиеся к Perl, могут изменить его значение на то же, что и свойство Perl &lt;code&gt;Present_In&lt;/code&gt; ; просто помните об этом.</target>
        </trans-unit>
        <trans-unit id="020d12e0872ef168546404b52284bd6940ecd187" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">Некоторое нечисловое имя объекта HTML, например &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , означающее то же самое, что &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; в HTML - строчная буква e с острым ударением (в форме /).</target>
        </trans-unit>
        <trans-unit id="d647bb86c88fea55dd1fa79cef8c74e6a775c39b" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt;, meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742d524f056fc75f1015c7da11070249cb40a21b" translate="yes" xml:space="preserve">
          <source>Some notes about ftp archives: Please use a long descriptive file name that includes the version number. Most incoming directories will not be readable/listable, i.e., you won't be able to see your file after uploading it. Remember to send your email notification message as soon as possible after uploading else your file may get deleted automatically. Allow time for the file to be processed and/or check the file has been processed before announcing its location.</source>
          <target state="translated">Несколько заметок о ftp-архивах:Пожалуйста,используйте длинное описательное имя файла,включающее номер версии.Большинство входящих каталогов не будут доступны для чтения/лицензирования,т.е.Вы не сможете увидеть свой файл после его загрузки.Не забудьте отправить уведомление по электронной почте как можно скорее после загрузки,иначе Ваш файл может быть удален автоматически.Разрешите время для обработки файла и/или проверьте,был ли файл обработан,прежде чем объявлять о его местоположении.</target>
        </trans-unit>
        <trans-unit id="7d0867bfec63bbea7b4c7184ee3d3a80f6c90eb5" translate="yes" xml:space="preserve">
          <source>Some of Test::Tester's functions return arrays of these hashes, just like Test::Builder-&amp;gt;details. That is, the hash for the first test will be array element 1 (not 0). Element 0 will not be a hash it will be a string which contains any diagnostic output that came before the first test. This should usually be empty, if it's not, it means something output diagnostics before any test results showed up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5039f425d422cec80636f2fe25c7aa8c335808" translate="yes" xml:space="preserve">
          <source>Some of the books we've listed appear almost ancient in internet scale, but we've included those books because they still describe the current way of doing things. Not everything in Perl changes every day. Many of the beginner-level books, too, go over basic features and techniques that are still valid today. In general though, we try to limit this list to books published in the past five years.</source>
          <target state="translated">Некоторые из книг,которые мы перечислили,кажутся почти древними в интернет-масштабе,но мы включили эти книги,потому что они до сих пор описывают современный порядок вещей.Не все в Перле меняется каждый день.Многие из книг начального уровня тоже перечисляют основные функции и приемы,которые действуют и по сей день.В целом,однако,мы стараемся ограничить этот список книгами,опубликованными за последние пять лет.</target>
        </trans-unit>
        <trans-unit id="ec6365cb89577ea447484ee46de59521b7dffa94" translate="yes" xml:space="preserve">
          <source>Some of the built-in functions do not act exactly as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and a few are not implemented at all. To avoid surprises, particularly if you have had prior exposure to Perl in other operating environments or if you intend to write code that will be portable to other environments, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for a reasonably definitive list of these differences.</source>
          <target state="translated">Некоторые из встроенных функций работают не так, как &lt;a href=&quot;perlfunc&quot;&gt;описано&lt;/a&gt; в perlfunc , а некоторые вообще не реализованы. Чтобы избежать сюрпризов, особенно если вы ранее знакомы с Perl в других операционных средах или если вы намереваетесь написать код, который будет переноситься в другие среды, см. &lt;a href=&quot;perlport&quot;&gt;Perlport&lt;/a&gt; для получения достаточно точного списка этих различий.</target>
        </trans-unit>
        <trans-unit id="0c8239353496c2009cfe543c3292467ce35311ef" translate="yes" xml:space="preserve">
          <source>Some of the configuration files in /etc used by the networking APIs are either missing or have the wrong names. In particular, make sure that there's either an /etc/resolv.conf or an /etc/hosts, so that gethostbyname() works, and make sure that the file /etc/proto has been renamed to /etc/protocol (NOT /etc/protocols, as used by other Unix systems). You may have to look for things like HOSTNAME and DOMAINORIGIN in the &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot; PDS member in order to properly set up your /etc networking files.</source>
          <target state="translated">Некоторые из конфигурационных файлов в /etc,используемых сетевыми API,либо отсутствуют,либо имеют неправильные имена.В частности,убедитесь,что существует либо /etc/resolv.conf,либо /etc/hosts,так что gethostbyname()работает,и убедитесь,что файл /etc/proto был переименован в /etc/protocol (NOT /etc/protocols,как используется другими Unix-системами).Возможно,Вам придется искать такие вещи,как HOSTNAME и DOMAINORIGIN в &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot;.Член PDS для правильной настройки сетевых файлов /etc.</target>
        </trans-unit>
        <trans-unit id="1d2fcdaf6bf2b0dace2c66c8a0e3613f9f85f66f" translate="yes" xml:space="preserve">
          <source>Some of the entries in the list are marked as &quot;experimental&quot;. This means these should not generally be used. They may be removed or changed without notice. You can ask why they are experimental by sending email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b022f479803e9b4139aa894b3173d5ebd19950" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c6dd767013c78841ab05e0e012ebcc93f26f14" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">В некоторых примерах, приведенных ниже в &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4,&lt;/a&gt; используется модуль &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; из CPAN. Причина, по которой вы можете выбрать &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt; вместо встроенных функций perl, заключается в том, что он работает с числами ЛЮБОГО размера, оптимизирован для скорости выполнения некоторых операций и, по крайней мере, некоторым программистам эта нотация может быть знакома.</target>
        </trans-unit>
        <trans-unit id="b1b52c56fd19edbbc0804a6b9841658fb64d4030" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved using XS modules.</source>
          <target state="translated">Часть функциональности отладочного кода может быть реализована с помощью модулей XS.</target>
        </trans-unit>
        <trans-unit id="bf0e1ecb04bb221fe8c8c990742dfa2a73f01086" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved with a non-debugging perl by using XS modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129d9d1e78c142ea547ff6b028cde8ebd0aadf7f" translate="yes" xml:space="preserve">
          <source>Some of the functions are called with a</source>
          <target state="translated">Некоторые из функций вызываются с помощью</target>
        </trans-unit>
        <trans-unit id="43704b45451eba3bea984abb31f94004f6ecfd41" translate="yes" xml:space="preserve">
          <source>Some of the highlights of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;:</source>
          <target state="translated">Некоторые из основных моментов &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="02ba05af57929b86c26da34f7202e0310b46aa70" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;Net::FTP::dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35b9e6be7b3bf5bc03040d536fb7da8f901aae2" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;ftp/dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">Некоторые из методов, определенных в &lt;code&gt;Net::FTP&lt;/code&gt; возвращают объект, который будет производным от класса &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; . См. &lt;a href=&quot;ftp/dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="085f62b2598cb482a6875006e876358d6d804f21" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from this class. The dataconn class itself is derived from the &lt;code&gt;IO::Socket::INET&lt;/code&gt; class, so any normal IO operations can be performed. However the following methods are defined in the dataconn class and IO should be performed using these.</source>
          <target state="translated">Некоторые из методов, определенных в &lt;code&gt;Net::FTP&lt;/code&gt; возвращают объект, производный от этого класса. Сам класс dataconn является производным от класса &lt;code&gt;IO::Socket::INET&lt;/code&gt; , поэтому могут выполняться любые обычные операции ввода-вывода. Однако следующие методы определены в классе dataconn, и ввод-вывод должен выполняться с их помощью.</target>
        </trans-unit>
        <trans-unit id="fbd9bb2f70bdb8a22b7796ad4ee4aab43ab4a22a" translate="yes" xml:space="preserve">
          <source>Some of the modifiers require more explanation than given in the &lt;a href=&quot;#Overview&quot;&gt;&quot;Overview&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2754422800ffdc8654fa173c411cbbdaf9ca8a2" translate="yes" xml:space="preserve">
          <source>Some of the modules that use these libraries &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;, &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;, and &lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312d5ef79ec3abd87646ed6a59f9c68ae862462d" translate="yes" xml:space="preserve">
          <source>Some of the most common mistakes:</source>
          <target state="translated">Некоторые из самых распространенных ошибок:</target>
        </trans-unit>
        <trans-unit id="5796d9bed54a4c270451442098ed19f9f0088003" translate="yes" xml:space="preserve">
          <source>Some of the most common values are &lt;code&gt;O_RDONLY&lt;/code&gt; for opening the file in read-only mode, &lt;code&gt;O_WRONLY&lt;/code&gt; for opening the file in write-only mode, and &lt;code&gt;O_RDWR&lt;/code&gt; for opening the file in read-write mode.</source>
          <target state="translated">Некоторые из наиболее распространенных значений: &lt;code&gt;O_RDONLY&lt;/code&gt; для открытия файла в режиме только для чтения, &lt;code&gt;O_WRONLY&lt;/code&gt; для открытия файла в режиме только для записи и &lt;code&gt;O_RDWR&lt;/code&gt; для открытия файла в режиме чтения-записи.</target>
        </trans-unit>
        <trans-unit id="d5f4367d2cd66fe5bca2400a4df459be12cf9924" translate="yes" xml:space="preserve">
          <source>Some of the parser default template files in /samples are needed in /etc. In particular be sure that you at least copy /samples/yyparse.c to /etc before running Perl's Configure. This step ensures successful extraction of EBCDIC versions of parser files such as perly.c and perly.h. This has to be done before running Configure the first time. If you failed to do so then the easiest way to re-Configure Perl is to delete your misconfigured build root and re-extract the source from the tar ball. Then you must ensure that /etc/yyparse.c is properly in place before attempting to re-run Configure.</source>
          <target state="translated">Некоторые из шаблонных файлов по умолчанию парсера в /samples необходимы в /etc.В частности,убедитесь,что вы по крайней мере скопировали /samples/yyparse.c в /etc перед запуском Perl's Configure.Этот шаг обеспечит успешное извлечение EBCDIC версий парсерных файлов,таких как perly.c и perly.h.Это должно быть сделано перед первым запуском Configure.Если вы этого не сделали,то самым простым способом повторной настройки Perl является удаление неправильно настроенного корня сборки и повторное извлечение исходного текста из tar-шарика.Затем вы должны убедиться,что /etc/yyparse.c находится на месте,прежде чем пытаться выполнить повторную настройку.</target>
        </trans-unit>
        <trans-unit id="83c0811a95d044951ce0ba50edb2e9cd1f45c8cb" translate="yes" xml:space="preserve">
          <source>Some of the reported info, such as hex addresses, is not particularly valuable. Other information would be more useful for the typical programmer, such as line-numbers, pad-slot reuses, etc.. Given this, -newlex is not a particularly good flag-name.</source>
          <target state="translated">Некоторая сообщенная информация,такая как шестнадцатеричные адреса,не представляет особой ценности.Другая информация была бы более полезной для типичного программиста,например,номера строк,повторное использование пэд-слота и т.д..Учитывая это,-newlex не является особенно хорошим флагманским именем.</target>
        </trans-unit>
        <trans-unit id="6116e5b7738fb6cac5aba2e6136f23c97d874e1d" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl XS extensions (see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; are also available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2180880e97e49639996064a1f6af7e81cac534b" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl libraries are included, but not all: see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdf99bdb0c6c762dab8d358da246b612330e8fa" translate="yes" xml:space="preserve">
          <source>Some of these are also deprecated. You can exclude these from your compiled Perl by adding this option to Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</source>
          <target state="translated">Некоторые из них также устарели. Вы можете исключить их из вашего скомпилированного Perl, добавив эту опцию в Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d94da1d47f6dfef189dc9a92fab735da2e9c93d7" translate="yes" xml:space="preserve">
          <source>Some of these books are available as free downloads.</source>
          <target state="translated">Некоторые из этих книг доступны для бесплатного скачивания.</target>
        </trans-unit>
        <trans-unit id="55b425b2a6fe515905b997d3820e2d955eabc2cf" translate="yes" xml:space="preserve">
          <source>Some of these functions also combine dynaloading semantic with the error-propagation semantic discussed above.</source>
          <target state="translated">Некоторые из этих функций также сочетают диналозирующий семантик с рассмотренным выше семантиком с раскладкой ошибок.</target>
        </trans-unit>
        <trans-unit id="7a3b090758880601b5c97fb9b694e1e73a3369bc" translate="yes" xml:space="preserve">
          <source>Some of these methods might be of interest to general users, as well as of interest to formatter-writers.</source>
          <target state="translated">Некоторые из этих методов могут представлять интерес для обычных пользователей,а также для писателей-форматоров.</target>
        </trans-unit>
        <trans-unit id="644a8605b72e956aa183e4a65e2c5fc19e8769dc" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;integer&quot;&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/a&gt;, unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eb2a0ac01474685656b9eca0e98318c5698b3f" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; , unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">Некоторые из этих псевдомодулей импортируют семантику в текущую область видимости блока (например, &lt;code&gt;strict&lt;/code&gt; или &lt;code&gt;integer&lt;/code&gt; , в отличие от обычных модулей, которые импортируют символы в текущий пакет (которые действуют до конца файла).</target>
        </trans-unit>
        <trans-unit id="f69cda68e897fa9c0b4882048fc82a98372f85df" translate="yes" xml:space="preserve">
          <source>Some of these shouldn't really be called in a Perl application, and for others there are thread-safe versions of these already implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc82daea8e525be9f1657205fd39cc94c0720ec" translate="yes" xml:space="preserve">
          <source>Some of these specific cases are shown as examples in other answers in this section of the perlfaq.</source>
          <target state="translated">Некоторые из этих конкретных случаев показаны в качестве примеров в других ответах в этом разделе perlfaq.</target>
        </trans-unit>
        <trans-unit id="7ac7dfacde52b03cada88bb1c11d6be2449d545b" translate="yes" xml:space="preserve">
          <source>Some of this may be confusing. Here's a handy reference to the ASCII CR and LF characters. You can print it out and stick it in your wallet.</source>
          <target state="translated">Кое-что из этого может сбить с толку.Вот удобная ссылка на ASCII CR и LF символы.Вы можете распечатать его и засунуть в бумажник.</target>
        </trans-unit>
        <trans-unit id="9436ec9fafb3dbaf8b6e8266e0c7a558118556b8" translate="yes" xml:space="preserve">
          <source>Some older Pod translators require paragraphs (including command paragraphs like &quot;=head2 Functions&quot;) to be separated by</source>
          <target state="translated">Некоторые старые переводчики Pod требуют,чтобы параграфы (включая параграфы команд типа &quot;=head2 Functions&quot;)были разделены следующим образом</target>
        </trans-unit>
        <trans-unit id="530312ef21d84b684c5534cd434fe4d79ac602e0" translate="yes" xml:space="preserve">
          <source>Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.</source>
          <target state="translated">Некоторые старые версии Berkeley DB имели проблемы с записями фиксированной длины с использованием формата файлов RECNO.Эта проблема была исправлена начиная с версии 1.85 Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="4c2cd6192ba71ba66f15fbdbb416f6e8ad76580e" translate="yes" xml:space="preserve">
          <source>Some operating systems don't ship the CORE directory with their base perl install. To solve the problem, you likely need to install a perl development package such as perl-devel (CentOS, Fedora and other Redhat systems) or perl (Ubuntu and other Debian systems).</source>
          <target state="translated">Некоторые операционные системы не поставляют каталог CORE с их базовой установкой perl.Чтобы решить эту проблему,вам,скорее всего,потребуется установить пакет разработки на perl,такой как perl-devel (CentOS,Fedora и другие системы Redhat)или perl (Ubuntu и другие системы Debian).</target>
        </trans-unit>
        <trans-unit id="a0bcdb116909bbaf782dcc8531648c8104b0144b" translate="yes" xml:space="preserve">
          <source>Some operating systems have bugs in the kernel that make setuid scripts inherently insecure. Perl gives you a number of options (described in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to work around such systems.</source>
          <target state="translated">В некоторых операционных системах есть ошибки в ядре, которые делают сценарии setuid небезопасными. Perl дает вам несколько вариантов (описанных в &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; ) для обхода таких систем.</target>
        </trans-unit>
        <trans-unit id="2250e1a4559063fcac9cec7cc104374f3f26f7ef" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">Некоторые операционные системы могут выполнять &lt;code&gt;IO::File::new()&lt;/code&gt; или &lt;code&gt;IO::File::open()&lt;/code&gt; в каталоге без ошибок. Такое поведение не переносимо и не рекомендуется для использования. &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; использовать opendir () и &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;IO::Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69855bea0e31a33e7317d263f4ec459059c92ed3" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;opendir()&lt;/code&gt; and &lt;code&gt;readdir()&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39015af4e836c35f8e25b30fad81d0e5afdfce43" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">Некоторые операции могут быть медленнее для небольших чисел, но значительно быстрее для больших чисел. Другие операции теперь являются постоянными (O (1), например &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; т.д.), а не O (N), и поэтому почти всегда занимают гораздо меньше времени. Эти оптимизации были сделаны специально.</target>
        </trans-unit>
        <trans-unit id="34443f21f05a44f91512261ff33473bdb84f64b0" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt;, &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9f3e95144e8b33a9458895d77a0f239683f515" translate="yes" xml:space="preserve">
          <source>Some operators are instead non-associative, meaning that it is a syntax error to use a sequence of those operators of the same precedence. For example, &lt;code&gt;&quot;$x .. $y .. $z&quot;&lt;/code&gt; is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62110d88a0d086d7fc7d0ffc86ee7f8031edd34d" translate="yes" xml:space="preserve">
          <source>Some options, in particular &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERL5OPT&lt;/code&gt; can interact, and the order in which they are applied is important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ecacb543bf1cb170543843116f3f4c7e881ad8" translate="yes" xml:space="preserve">
          <source>Some other (not completely debugged) situations when FP flags change include some video drivers (?), and some operations related to creation of the windows. People who code &lt;b&gt;OpenGL&lt;/b&gt; may have more experience on this.</source>
          <target state="translated">К другим (не полностью отлаженным) ситуациям смены флагов FP относятся некоторые видеодрайверы (?) И некоторые операции, связанные с созданием окон. Люди, которые программируют &lt;b&gt;OpenGL,&lt;/b&gt; могут иметь в этом больше опыта.</target>
        </trans-unit>
        <trans-unit id="377fbf88a15d635b8d6d486abdf4ac17224b10a7" translate="yes" xml:space="preserve">
          <source>Some other IO modules don't belong to the perl core but can be loaded as well if they have been installed from CPAN. You can discover which ones exist by searching for &quot;^IO::&quot; on &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;.</source>
          <target state="translated">Некоторые другие модули ввода-вывода не принадлежат ядру Perl, но также могут быть загружены, если они были установлены из CPAN. Вы можете узнать, какие из них существуют, выполнив поиск по запросу &amp;laquo;^ IO ::&amp;raquo; на &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d0a736269bfee7b88f6f3d6b373b941a1d11276" translate="yes" xml:space="preserve">
          <source>Some other values are treated specially for internal use and should not be depended on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7424cd4ab88fb33b2270b2db7bbe8e04cad5739e" translate="yes" xml:space="preserve">
          <source>Some output formats that do allow rendering &quot;L&amp;lt;...&amp;gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</source>
          <target state="translated">Некоторые форматы вывода, которые позволяют отображать коды &amp;laquo;L &amp;lt;...&amp;gt;&amp;raquo; в виде гипертекста, могут не допускать форматирования текста ссылки; в этом случае форматировщикам придется просто игнорировать это форматирование.</target>
        </trans-unit>
        <trans-unit id="256ae5437abb579a53a890ac8a995ac8070fd714" translate="yes" xml:space="preserve">
          <source>Some particular limitations of note include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7659015df8ed2f8e8d7c6aab66109d4919b25a40" translate="yes" xml:space="preserve">
          <source>Some particular sequences of characters are given a single name, in addition to their individual ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a79a974eeb026992ad7b1bb5fab50968d6932c" translate="yes" xml:space="preserve">
          <source>Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually. For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.</source>
          <target state="translated">Некоторые из рассмотренных ниже пассов выполняются одновременно,но поскольку их результаты одинаковы,мы рассматриваем их индивидуально.Для различных конструкций цитирования Perl выполняет разное количество проходов,от одного до четырех,но эти проходы всегда выполняются в одном и том же порядке.</target>
        </trans-unit>
        <trans-unit id="7ae8fed66b51985370778e2e29c81e03a37d1f13" translate="yes" xml:space="preserve">
          <source>Some people get too used to writing things like:</source>
          <target state="translated">Некоторые люди слишком привыкают писать такие вещи,как..:</target>
        </trans-unit>
        <trans-unit id="970ff42e05d0088fd549cac2a995425a1e1eba68" translate="yes" xml:space="preserve">
          <source>Some people have reported encountering &quot;Out of memory!&quot; errors while trying to build Perl using GNU make binaries. If you encounter such trouble then try to download the source code kit and build GNU make from source to eliminate any such trouble. You might also find GNU make (as well as Perl and Apache) in the red-piece/book &quot;Open Source Software for OS/390 UNIX&quot;, SG24-5944-00 from IBM.</source>
          <target state="translated">Некоторые люди сообщали о том,что при попытке собрать Perl с помощью GNU они сталкивались с ошибками &quot;Out of memory!&quot;,делая двоичные файлы.Если вы столкнулись с такой проблемой,попробуйте загрузить комплект исходных текстов и собрать GNU make из исходных текстов,чтобы устранить любую такую проблему.Вы можете также найти GNU make (а также Perl и Apache)в красной части/книге &quot;Open Source Software for OS/390 UNIX&quot;,SG24-5944-00 от IBM.</target>
        </trans-unit>
        <trans-unit id="98c7c01703d39bcc6345fdf8d617292db8f23d37" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">Некоторые люди могут быть склонны включить явный &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; в приведенный выше XSUB, вместо того, чтобы позволить контролю провалиться до конца. В таких ситуациях следует использовать &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; . Это обеспечит правильную настройку стека XSUB. Проконсультируйтесь с &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; по &lt;code&gt;XSRETURN&lt;/code&gt; других макросов XSRETURN .</target>
        </trans-unit>
        <trans-unit id="b6b8960b846f5085f978f5b96b85b0906849df57" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;return&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b055a6a001cadf9ec7b3e638f2bc15cb8ed85e4" translate="yes" xml:space="preserve">
          <source>Some people may wish to outlaw barewords entirely. If you say</source>
          <target state="translated">Некоторые люди,возможно,захотят полностью запретить голые слова.Если вы скажете</target>
        </trans-unit>
        <trans-unit id="bae38a7d38c5d89eb67db6e4b702e604142997e5" translate="yes" xml:space="preserve">
          <source>Some people mistakenly regard this as a security problem. If your program does insecure things, and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">Некоторые люди ошибочно считают это проблемой безопасности.Если ваша программа делает небезопасные вещи и полагается на людей,не знающих,как использовать эти небезопасные вещи,то она небезопасна.Часто кто-то может определить незащищенные вещи и использовать их,не просматривая источник.Безопасность через неясность-название для сокрытия ваших ошибок вместо их исправления-на самом деле мало защищена.</target>
        </trans-unit>
        <trans-unit id="df10001a5e994bd1a3232bcb5d3f173424f0cd78" translate="yes" xml:space="preserve">
          <source>Some people need this and some people avoid it. For Perl, it&amp;rsquo;s an old way to say &lt;b&gt;I/O layer&lt;/b&gt;.</source>
          <target state="translated">Некоторым людям это нужно, а некоторым избегают. Для Perl это старый способ &lt;b&gt;обозначить уровень ввода-вывода&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="37ecbcdb1f8127ee6539d97d23e8c04d2e848681" translate="yes" xml:space="preserve">
          <source>Some people regard this as a security problem. If your program does insecure things and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">Некоторые считают это проблемой безопасности.Если ваша программа делает небезопасные вещи и полагается на людей,не знающих,как использовать эти небезопасные вещи,то она небезопасна.Часто кто-то может определить незащищенные вещи и использовать их,не просматривая источник.Безопасность через неясность-название для сокрытия ваших ошибок вместо их исправления-на самом деле мало защищена.</target>
        </trans-unit>
        <trans-unit id="646207c2365abd1daf6b5c56b0451ba2ee5e82de" translate="yes" xml:space="preserve">
          <source>Some platforms (Win32, AIX, VMS, OS/2, to name a few) require any function that is part of the public API (the shared Perl library) to be explicitly marked as exported. See the discussion about</source>
          <target state="translated">Некоторые платформы (Win32,AIX,VMS,OS/2,и т.д.)требуют,чтобы любая функция,являющаяся частью публичного API (разделяемая библиотека Perl),была явно помечена как экспортируемая.См.обсуждение о</target>
        </trans-unit>
        <trans-unit id="f71f7e49e6244b0a28baf7e54c8479e2d307382e" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; files when you are done with them. Don't &lt;a href=&quot;perlfunc#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#rename-OLDNAME%2CNEWNAME&quot;&gt;&lt;code&gt;rename&lt;/code&gt;&lt;/a&gt; an open file. Don't &lt;a href=&quot;perlfunc#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; a file already tied or opened; &lt;a href=&quot;perlfunc#untie-VARIABLE&quot;&gt;&lt;code&gt;untie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; it first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e0751f43cf70fa1b809101e7e4735cf3d63955" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; files when you are done with them. Don't &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; an open file. Don't &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; a file already tied or opened; &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; it first.</source>
          <target state="translated">Некоторые платформы не могут удалять или переименовывать файлы, открытые системой, это ограничение может также применяться к изменению метаинформации файловой системы, например прав доступа к файлам или владельцев. Не забудьте &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; файлы, когда закончите с ними. Не &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; и не &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; открытый файл. Не &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; и не &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; уже связанный или открытый файл; сначала &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; его.</target>
        </trans-unit>
        <trans-unit id="da26b78199e00ef73fdfb4bbe53a1032367ab8a7" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in a warning, and the minimum stack size will be used.</source>
          <target state="translated">Некоторые платформы имеют минимальный размер стека потоков.Попытка установить размер стека ниже этого значения приведет к появлению предупреждения,и будет использован минимальный размер стека.</target>
        </trans-unit>
        <trans-unit id="bcf43713051466cf97d586bae0917d51d61ca30f" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in the above warning, and the stack size will be set to the minimum.</source>
          <target state="translated">Некоторые платформы имеют минимальный размер стека потоков.Попытка установить размер стека ниже этого значения приведет к появлению приведенного выше предупреждения,а размер стека будет установлен на минимальный.</target>
        </trans-unit>
        <trans-unit id="5105a7088de9859cd20060f09ecf9b0528ad1069" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;&quot;Not within the scope of &quot;use locale&quot;&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11c8787b6044982e680d4ae9bfff407819b6d1c" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale&lt;/a&gt; below.</source>
          <target state="translated">На некоторых платформах есть другие категории, касающиеся таких вещей, как единицы измерения и размеры бумаги. Ни один из них не используется непосредственно Perl, но внешние операции, с которыми Perl взаимодействует, могут их использовать. См. Раздел &amp;laquo; &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Локаль вне области использования&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="27d67098e269de48eafdad3480b3920c43ba2cb7" translate="yes" xml:space="preserve">
          <source>Some points to note:</source>
          <target state="translated">Следует отметить некоторые моменты:</target>
        </trans-unit>
        <trans-unit id="4d3653fc867e65c669e5c29b359dbebb9253c5c0" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">Некоторые возможные причины: ваше наследование сбивается, вы неправильно написали имя метода или объект неправильного типа. Ознакомьтесь с &lt;a href=&quot;perlootut&quot;&gt;perlootut,&lt;/a&gt; чтобы узнать подробности о любом из вышеуказанных случаев. Вы также можете использовать &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; чтобы узнать, в какой класс &lt;code&gt;$object&lt;/code&gt; был благословлен.</target>
        </trans-unit>
        <trans-unit id="290c6b9cea94cfe13fbb802d97a5a0cd78346837" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;print ref($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b61ffed7b1a69179adefb6f5756bdb1cb79574b" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">Некоторые прагмы имеют лексическую область видимости - обычно те, которые влияют на переменную подсказок &lt;code&gt;$^H&lt;/code&gt; Другие влияют на текущий пакет вместо этого, как &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , которые позволяют predeclare переменных или подпрограмм в рамках конкретного</target>
        </trans-unit>
        <trans-unit id="7d87d5053d095f39938496538e49008745b231d2" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;use vars&lt;/code&gt; and &lt;code&gt;use subs&lt;/code&gt;, which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca977f551e014badc60a278bfe97ad872b1a03f5" translate="yes" xml:space="preserve">
          <source>Some problem (forget which ;-)</source>
          <target state="translated">Какая-то проблема (забудьте какая ;-)</target>
        </trans-unit>
        <trans-unit id="747d0cb3f2eb2365d2dd72ee766a74de28620e7d" translate="yes" xml:space="preserve">
          <source>Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</source>
          <target state="translated">Некоторые проблемы связаны с использованием временных файлов,которые находятся на файловых системах NFS,и рекомендуется по возможности использовать локальную файловую систему.Некоторые тесты безопасности,скорее всего,будут неудачными,когда временный файл не является локальным.Кроме того,имейте в виду,что производительность операций ввода/вывода через NFS будет не так хороша,как для локального диска.</target>
        </trans-unit>
        <trans-unit id="82690c6e6b8e4e473e3f2745d7358e432662fc95" translate="yes" xml:space="preserve">
          <source>Some processors may find that the &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply</source>
          <target state="translated">Некоторые процессоры могут обнаружить, что код &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; проще всего реализовать, заменив каждое пространство в дереве синтаксического анализа под содержимым S на NBSP. Но обратите внимание: замена должна применяться</target>
        </trans-unit>
        <trans-unit id="229ed6abc320881bbd15c4ddf8619bff82e22293" translate="yes" xml:space="preserve">
          <source>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</source>
          <target state="translated">Некоторые программисты предпочитают использовать явное преобразование,чтобы не оставлять никаких сомнений:</target>
        </trans-unit>
        <trans-unit id="76cff92347a8a5dd33b0b88b52afc87676bbe1d1" translate="yes" xml:space="preserve">
          <source>Some programmers may prefer to think of filehandles as objects with methods, preferring to write the last example as:</source>
          <target state="translated">Некоторые программисты могут предпочесть думать о файловых дескрипторах как об объектах с методами,предпочитая записать последний пример как:</target>
        </trans-unit>
        <trans-unit id="9293db7d23e9765c2433258535b9e48d3fd5d563" translate="yes" xml:space="preserve">
          <source>Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:</source>
          <target state="translated">Некоторые свойства считаются устаревшими по Юникоду,но все еще доступны.Существует несколько разновидностей устаревания:</target>
        </trans-unit>
        <trans-unit id="8e185e2d007b85b8d377436c39a0c68b4b4f4ab1" translate="yes" xml:space="preserve">
          <source>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</source>
          <target state="translated">Некоторые редкие приложения должны будут создавать более одного переводчика во время сеанса.Такое приложение может время от времени принимать решение об освобождении любых ресурсов,связанных с переводчиком.</target>
        </trans-unit>
        <trans-unit id="0314a7222da4e53e09e85e4d4942b044d7cacfc9" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5ce3e6e9260f74f3afe8318024d986a7fd16de" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;name)&lt;/code&gt;.</source>
          <target state="translated">Некоторые регулярные выражения используют одинаковые подшаблоны в нескольких местах. Начиная с Perl 5.10, можно определить именованные подшаблоны в разделе шаблона, чтобы их можно было вызывать по имени в любом месте шаблона. Этот синтаксический шаблон для этой группы определений - &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt; . Вставка именованного шаблона записывается как &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58899e8b736f7c4726449bcec0f3b25df5fc7632" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef, &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">Некоторые процедуры ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) возвращают true или false, в то время как другие ( &lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) возвращают undef, &amp;lt;0, 0 или&amp;gt; 0 и подходят для сортировки.</target>
        </trans-unit>
        <trans-unit id="834cc437cec84afae22c004e80ee3d6149cb6f55" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; , etc.) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef (if NaN is involved), &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">Некоторые подпрограммы ( &lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; и т. Д.) Возвращают true или false, в то время как другие ( &lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) возвращают либо undef (если задействовано NaN. ), &amp;lt;0, 0 или&amp;gt; 0 и подходят для сортировки.</target>
        </trans-unit>
        <trans-unit id="b07ef2379b9c2b49ab7fe4b04878c3104f0be76f" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt; .</source>
          <target state="translated">Некоторые скалярные переменные содержат более одного типа скалярных данных. Например, переменная &lt;code&gt;$!&lt;/code&gt; содержит либо числовое значение &lt;code&gt;errno&lt;/code&gt; , либо его строковый эквивалент из &lt;code&gt;strerror&lt;/code&gt; или &lt;code&gt;sys_errlist[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293877a0e77da8a8b9fbcbcd030c4833f67c96da" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b802bf6a4f1848df9acbe46a4e2a4fe02ad51578" translate="yes" xml:space="preserve">
          <source>Some scripts, usually identified with a *.PL extension, are self-configuring and are able to correctly create their own shebang path from config information located in Plan 9 Perl. These you won't need to be worried about.</source>
          <target state="translated">Некоторые скрипты,обычно идентифицируемые с расширением *.PL,являются самонастраивающимися и могут корректно создавать свой собственный путь к ней из конфигурационной информации,находящейся в Plan 9 Perl.О них вам не нужно будет беспокоиться.</target>
        </trans-unit>
        <trans-unit id="0de1611bc5300339bfc467a34c6fb8f9747fd7ed" translate="yes" xml:space="preserve">
          <source>Some servers are configured to only work in passive mode. If you have one of these you can force &lt;code&gt;Net::FTP&lt;/code&gt; to always transfer in passive mode; when not going via a firewall, by setting &lt;code&gt;ftp_int_passive&lt;/code&gt; to a</source>
          <target state="translated">Некоторые серверы настроены на работу только в пассивном режиме. Если у вас есть один из них, вы можете заставить &lt;code&gt;Net::FTP&lt;/code&gt; всегда передавать данные в пассивном режиме; если вы не используете брандмауэр, установив &lt;code&gt;ftp_int_passive&lt;/code&gt; на</target>
        </trans-unit>
        <trans-unit id="ebc3655c5b01cc226f09d2ace7c8e5f430f35ebd" translate="yes" xml:space="preserve">
          <source>Some servers do not understand this command, but issuing it and ignoring the response is harmless.</source>
          <target state="translated">Некоторые серверы не понимают эту команду,но выдача ее и игнорирование ответа безвредны.</target>
        </trans-unit>
        <trans-unit id="c3d7fb888727f4ae5ed3bb068213cd5f194d2bf2" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use POSIX' sigprocmask.</source>
          <target state="translated">Некоторые сигналы не могут быть ни захвачены,ни проигнорированы,например,сигналы KILL и STOP (но не TSTP).Обратите внимание,что игнорирование сигналов заставляет их исчезнуть.Если вы хотите,чтобы они только временно блокировались,не теряясь,вам придется использовать sigprocmask POSIX.</target>
        </trans-unit>
        <trans-unit id="2b6d2a03109d9cfeb6b788931c3af13636a6e9ce" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use the &lt;code&gt;POSIX&lt;/code&gt; module's &lt;a href=&quot;posix#sigprocmask&quot;&gt;sigprocmask&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcba60d06f3c08a852e1ccedb100d4bd2f6af23" translate="yes" xml:space="preserve">
          <source>Some simple style guidelines</source>
          <target state="translated">Некоторые простые рекомендации по стилю</target>
        </trans-unit>
        <trans-unit id="0a3063c3a46746b861b03ccbf2777db3ca544d44" translate="yes" xml:space="preserve">
          <source>Some simple tricks for determining if you are running on an EBCDIC platform could include any of the following (perhaps all):</source>
          <target state="translated">Некоторые простые трюки для определения,работаете ли вы на платформе EBCDIC,могут включать в себя любое из следующих (возможно,все):</target>
        </trans-unit>
        <trans-unit id="3f3c0a1f0f425bdd141982a9f345d9ad53284159" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle, but on the other hand totally ignore the text after &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038ab8e08e45dcac2b1a2ba44edc5e7ade978952" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle.</source>
          <target state="translated">Некоторые исходные фильтры используют дескриптор &lt;code&gt;DATA&lt;/code&gt; для чтения вызывающей программы. При использовании этих исходных фильтров вы не можете полагаться на этот дескриптор или ожидать какого-либо конкретного поведения при работе с ним. Фильтры на основе Filter :: Util :: Call (и, следовательно, Filter :: Simple) не изменяют дескриптор файла &lt;code&gt;DATA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1b44415edca47e18840114c042b3fbafad7d31e" translate="yes" xml:space="preserve">
          <source>Some special cases like a trailing 0x00 byte or a lone 0x1B byte are not well-defined and decode() will return an empty string for them. One possible workaround is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887e76ddfe1351446ffd243bda2aac92d02dd5a3" translate="yes" xml:space="preserve">
          <source>Some subclasses that indiscriminately dump event attributes (well, except for ones beginning with &quot;~&quot;) can use this object attribute for refraining to dump the &quot;start_line&quot; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0397fafffa0394e8352d14b65804f0f4b7e0e7f0" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;a href=&quot;#-l%5Boctnum%5D&quot;&gt;-l&lt;/a&gt; and &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3ebd295e43b2c81df8bd4b9c3baef266ee5f66" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;b&gt;-l&lt;/b&gt; and &lt;b&gt;-0&lt;/b&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">Некоторые переключатели заботятся о том, обрабатываются ли они дважды, например, комбинации &lt;b&gt;-l&lt;/b&gt; и &lt;b&gt;-0&lt;/b&gt; . Либо поместите все переключатели после границы из 32 символов (если применимо), либо замените использование &lt;b&gt;-0&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="109f18c999c7939dc43da5678ce045bdc21c20e9" translate="yes" xml:space="preserve">
          <source>Some systems define &lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#socketpair-SOCKET1%2CSOCKET2%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socketpair&lt;/code&gt;&lt;/a&gt;, in which a call to &lt;code&gt;pipe($rdr, $wtr)&lt;/code&gt; is essentially:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c346e3627bcf4ba52fad903600add2510035afb4" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">Некоторые системы определяют &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; в терминах &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; , в которой вызов &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; по существу:</target>
        </trans-unit>
        <trans-unit id="6fc6b04b810684b6c41fe63810499cab8b09c739" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">Некоторые системы определяют &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; в терминах &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; , в которой вызов &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; по существу:</target>
        </trans-unit>
        <trans-unit id="ec2cddcb7714cb3145808dbf1959d4cf532d708d" translate="yes" xml:space="preserve">
          <source>Some systems have APIs but not implementations: for example QNX and Haiku have the interval timer APIs but not the functionality.</source>
          <target state="translated">Некоторые системы имеют API,но не реализации:например QNX и Haiku имеют API интервального таймера,но не функциональность.</target>
        </trans-unit>
        <trans-unit id="af9e4e7dc8e2d766a51ba5d183c159f4967112d1" translate="yes" xml:space="preserve">
          <source>Some systems have thread-safe versions of some of the functions, such as &lt;code&gt;getpwnam_r()&lt;/code&gt; instead of &lt;code&gt;getpwnam()&lt;/code&gt;. There, Perl automatically and invisibly substitutes the thread-safe version, without notice. This means that code that safely runs on some systems can fail on others that lack the thread-safe versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b5dcc57517fdbe334dfa953d44b8287e96b48c" translate="yes" xml:space="preserve">
          <source>Some systems may have even weirder byte orders such as</source>
          <target state="translated">Некоторые системы могут иметь еще более странные порядки байтов,такие как</target>
        </trans-unit>
        <trans-unit id="6223cb44b81823af78522ece7689e7171de5236a" translate="yes" xml:space="preserve">
          <source>Some systems use CONFORMING TO to note conformance to relevant standards and MT-LEVEL to note safeness for use in threaded programs or signal handlers. These headings are primarily useful when documenting parts of a C library.</source>
          <target state="translated">Некоторые системы используют КОНФОРМИНГ,чтобы отметить соответствие соответствующим стандартам и MT-LEVEL,чтобы отметить безопасность для использования в резьбовых программах или обработчиках сигналов.Эти заголовки в первую очередь полезны при документировании частей Си-библиотеки.</target>
        </trans-unit>
        <trans-unit id="b5f78f639815d7596cee6bf607be57c18273af36" translate="yes" xml:space="preserve">
          <source>Some test failures may occur if you use a command shell other than the native &quot;cmd.exe&quot;, or if you are building from a path that contains spaces. So don't do that.</source>
          <target state="translated">Некоторые ошибки теста могут возникнуть,если вы используете командную оболочку,отличную от родной &quot;cmd.exe&quot;,или если вы строите из пути,содержащего пробелы.Так что не делайте этого.</target>
        </trans-unit>
        <trans-unit id="db2f4892c2d72b4b87094017ed92e99d93095f9c" translate="yes" xml:space="preserve">
          <source>Some test modules would replace the Test::Builder singleton instance with their own instance or subclass. This was usually done to intercept or modify results as they happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec70ba84fc671de1bea2095d64f0ecee13115e62" translate="yes" xml:space="preserve">
          <source>Some tests are known to fail:</source>
          <target state="translated">Некоторые тесты,как известно,провалились:</target>
        </trans-unit>
        <trans-unit id="6a89cc5c4b8e960cca98e5c9aef6613a37510494" translate="yes" xml:space="preserve">
          <source>Some tests depended on &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; being modified in subtle ways. A patch was applied to correct things that changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d98556687379d0793051b330180895e416a427" translate="yes" xml:space="preserve">
          <source>Some tests may complain under known circumstances.</source>
          <target state="translated">Некоторые тесты могут жаловаться при известных обстоятельствах.</target>
        </trans-unit>
        <trans-unit id="c1340d9e04d7bf928c677a3bd6e8e8121f7021a3" translate="yes" xml:space="preserve">
          <source>Some tests may generate extra messages similar to</source>
          <target state="translated">Некоторые тесты могут генерировать дополнительные сообщения,похожие на</target>
        </trans-unit>
        <trans-unit id="ed680f9db7c37de4a3fb02472a48fb5b299c3b28" translate="yes" xml:space="preserve">
          <source>Some tests were fragile and required base.pm to be loaded at a late stage. Test2 was loading base.pm too early. The tests were updated to fix this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3e7fb048dd3da6c3efee2236b9f7245e42c776" translate="yes" xml:space="preserve">
          <source>Some tests were fragile, but have been fixed. The actual breakage was from the subtest comment indentation change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c36c454152688ffa8f0d5944c5eae241cf584a" translate="yes" xml:space="preserve">
          <source>Some tests will be skipped because they need the fork() function:</source>
          <target state="translated">Некоторые тесты будут пропущены,так как им нужна функция fork():</target>
        </trans-unit>
        <trans-unit id="ae4dfb05b376af0b4aa8499ceeb5ad1587cfc612" translate="yes" xml:space="preserve">
          <source>Some things might not work as you expect them. Below is documented what is known to be troublesome:</source>
          <target state="translated">Некоторые вещи могут работать не так,как вы ожидаете.Ниже задокументировано то,что,как известно,причиняет беспокойство:</target>
        </trans-unit>
        <trans-unit id="c22086010db6828bca64b97b121f052c5aaeaeec" translate="yes" xml:space="preserve">
          <source>Some time ago I had reports it does not work. Nowadays it is checked in the Perl test suite, so grep</source>
          <target state="translated">Некоторое время назад у меня были сообщения,что это не работает.Сейчас он проверяется в тестовом наборе Perl,так что grep...</target>
        </trans-unit>
        <trans-unit id="ff04f69dfe09fd05da827bf89d221c2f8cd81859" translate="yes" xml:space="preserve">
          <source>Some tools did do a good job setting these to the correct hub, but you cannot always rely on that. Use the 'hubs' facet list instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d4257cf6ff6a8e43bd3c5319c1718bd7fb9ab6" translate="yes" xml:space="preserve">
          <source>Some type of removable media other than a floppy diskette.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729fe9bb5c1721be7b9c47b47d38d0043a1d5be9" translate="yes" xml:space="preserve">
          <source>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</source>
          <target state="translated">Также могут быть локализованы некоторые типы значений:хэш-элементы и срезы массива,условные (при условии,что их результат всегда локализуем)и символические ссылки.Что касается простых переменных,то при этом создаются новые,динамически просматриваемые значения.</target>
        </trans-unit>
        <trans-unit id="36c279e82d37aef763f2dc425df33d302f2edc2c" translate="yes" xml:space="preserve">
          <source>Some unusual systems, such as VMS, require special filename handling in order to deal with symbolic names for files (i.e., VMS's Logical Names).</source>
          <target state="translated">Некоторые необычные системы,такие как VMS,требуют специальной обработки имен файлов для работы с символическими именами файлов (например,Логические имена VMS).</target>
        </trans-unit>
        <trans-unit id="6a39214b093577878080cd0246589b3e208ffeb5" translate="yes" xml:space="preserve">
          <source>Some user's however may feel that the above &quot;economy of expression&quot; is not particularly readable nor consistent and may instead choose to do something more like the following:</source>
          <target state="translated">Однако некоторые пользователи могут почувствовать,что вышеприведенная &quot;экономия выражения&quot; не является особенно читабельной и непротиворечивой,и вместо этого могут выбрать что-то более похожее на следующее:</target>
        </trans-unit>
        <trans-unit id="1ad295080cd8e985d193a33706aa64c82df7132f" translate="yes" xml:space="preserve">
          <source>Some users have expressed that they think this whole mechanism of having a &quot;fail&quot; attribute at all, seems a rather pointless complication. But I want Locale::Maketext to be usable for software projects of</source>
          <target state="translated">Некоторые пользователи высказывают мнение,что весь этот механизм,имеющий атрибут &quot;fail&quot; вообще,кажется довольно бессмысленным усложнением.Но я хочу,чтобы Locale::Maketext был пригоден для использования в программном проекте</target>
        </trans-unit>
        <trans-unit id="7ab6d61e44a0f4b38225b697b64d41eb4c216b63" translate="yes" xml:space="preserve">
          <source>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</source>
          <target state="translated">Некоторые пользователи,возможно,пожелают поощрить использование лексически описанных переменных.В качестве подспорья в перехвате неявного использования для пакетов переменных,которые всегда являются глобальными,если вы говорите</target>
        </trans-unit>
        <trans-unit id="020ce1178f605ac1782ec8459fa4fa7fd0cf745e" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;DB_File&lt;/code&gt; won't let you store data under a key of length 0. That means that if you have a function &lt;code&gt;f&lt;/code&gt; which you memoized and the cache is in a &lt;code&gt;DB_File&lt;/code&gt; database, then the value of &lt;code&gt;f()&lt;/code&gt; (&lt;code&gt;f&lt;/code&gt; called with no arguments) will not be memoized. If this is a big problem, you can supply a normalizer function that prepends &lt;code&gt;&quot;x&quot;&lt;/code&gt; to every key.</source>
          <target state="translated">Некоторые версии &lt;code&gt;DB_File&lt;/code&gt; не позволяют хранить данные с ключом длины 0. Это означает, что если у вас есть функция &lt;code&gt;f&lt;/code&gt; , которую вы запомнили, а кеш находится в &lt;code&gt;DB_File&lt;/code&gt; данных DB_File , тогда значение &lt;code&gt;f()&lt;/code&gt; ( &lt;code&gt;f&lt;/code&gt; вызывается с без аргументов) мемоизироваться не будет. Если это большая проблема, вы можете предоставить функцию нормализатора, которая добавляет &lt;code&gt;&quot;x&quot;&lt;/code&gt; к каждой клавише.</target>
        </trans-unit>
        <trans-unit id="8bb4498f94e563a623dff663cd55b4fc862752c4" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt; . Others do not. This variable contains the string to be included in</source>
          <target state="translated">Некоторые версии &lt;code&gt;make&lt;/code&gt; устанавливают переменную &lt;code&gt;MAKE&lt;/code&gt; . У других нет. Эта переменная содержит строку, которая должна быть включена в</target>
        </trans-unit>
        <trans-unit id="fd2f9dd996c82ce27f9d189fd038a8b3dc2b29cb" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt;. Others do not. This variable contains the string to be included in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954f7aeec06323e12a6983f37a0846eca84625d3" translate="yes" xml:space="preserve">
          <source>Some versions of flock() can't lock files over a network (e.g. on NFS file systems), so you'd need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and the</source>
          <target state="translated">Некоторые версии flock () не могут блокировать файлы по сети (например, в файловых системах NFS), поэтому вам нужно принудительно использовать fcntl (2) при сборке Perl. Но даже это в лучшем случае сомнительно. См. &lt;a href=&quot;perlfunc&quot;&gt;Статью perlfunc&lt;/a&gt; и</target>
        </trans-unit>
        <trans-unit id="dd60cc6568aba712fcca69343c88a2420637338a" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;&quot;utf8_to_uvuni_buf&quot;&lt;/a&gt; for alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d311518a6bb3b8613076ce871f73cf8cb1a1e05f" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; for alternatives.</source>
          <target state="translated">Некоторые, но не все, дефекты UTF-8 обнаруживаются, и на самом деле некоторые искаженные вводимые данные могут вызвать чтение за пределами конца входного буфера, что является одной из причин, по которой эта функция устарела. Во-вторых, сравнение Unicode и нативного кода может представлять для вас интерес только в крайне ограниченных случаях. &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;Альтернативы&lt;/a&gt; см. В utf8_to_uvuni_buf .</target>
        </trans-unit>
        <trans-unit id="f0f7251754bf0f46339bfaca2d9d1483409569f4" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc9641c97ef26419e8b09582d42e0230f643449" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; instead.</source>
          <target state="translated">Некоторые, но не все, дефекты UTF-8 обнаруживаются, и на самом деле некоторые искаженные входные данные могут вызвать чтение за пределами конца входного буфера, поэтому эта функция устарела. &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;Вместо&lt;/a&gt; этого используйте utf8_to_uvchr_buf .</target>
        </trans-unit>
        <trans-unit id="d5b99daee126bc167396885e5a173ca7e1b5727f" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">Некоторые из них, такие как &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; , не предоставляются, потому что в Plan 9 нет этой концепции. Другие, например, некоторые функции, связанные с сокетами, просто еще не написаны. Многие из последней категории могут получить поддержку в будущем.</target>
        </trans-unit>
        <trans-unit id="63c9382b076dd9dd8161d9b49e86f36c6b0988c1" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;chown&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b529d1f2a1daeac288a5dc3e3f1ad071820c7a2" translate="yes" xml:space="preserve">
          <source>Some/Module.pm</source>
          <target state="translated">Some/Module.pm</target>
        </trans-unit>
        <trans-unit id="75f6f0269318d3e6d862e35e227cdb78f8aa0076" translate="yes" xml:space="preserve">
          <source>Someone like Larry, or one of his peculiar friends. Also refers to the strange prefixes that Perl requires as noun markers on its variables.</source>
          <target state="translated">Кто-то вроде Ларри или одного из его необычных друзей.Также относится к странным префиксам,которые Perl требует в качестве существительных маркеров на своих переменных.</target>
        </trans-unit>
        <trans-unit id="4645c18015bf5520c386fecd9f2627c0f851f491" translate="yes" xml:space="preserve">
          <source>Someone who &amp;ldquo;carries&amp;rdquo; software from one &lt;b&gt;platform&lt;/b&gt; to another. Porting programs written in platform-dependent languages such as C can be difficult work, but porting programs like Perl is very much worth the agony.</source>
          <target state="translated">Тот, кто &amp;laquo;переносит&amp;raquo; программное обеспечение с одной &lt;b&gt;платформы&lt;/b&gt; на другую. Перенос программ, написанных на платформенно-зависимых языках, таких как C, может быть сложной задачей, но перенос программ, таких как Perl, стоит мучений.</target>
        </trans-unit>
        <trans-unit id="81901ca358030c454d79961747b435397961631e" translate="yes" xml:space="preserve">
          <source>Someone who breaks security on computer systems. A cracker may be a true &lt;b&gt;hacker&lt;/b&gt; or only a &lt;b&gt;script kiddie&lt;/b&gt;.</source>
          <target state="translated">Кто-то, кто взламывает безопасность компьютерных систем. Взломщик может быть настоящим &lt;b&gt;хакером&lt;/b&gt; или просто &lt;b&gt;скрипачом&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1964ccb6039dfc22b78b8e0d35db2a914eb047cc" translate="yes" xml:space="preserve">
          <source>Someone who is brilliantly persistent in solving technical problems, whether these involve golfing, fighting orcs, or programming. Hacker is a neutral term, morally speaking. Good hackers are not to be confused with evil &lt;b&gt;crackers&lt;/b&gt; or clueless &lt;b&gt;script kiddies&lt;/b&gt;. If you confuse them, we will presume that you are either evil or clueless.</source>
          <target state="translated">Тот, кто блестяще настойчив в решении технических проблем, будь то игра в гольф, борьба с орками или программирование. Хакер - нейтральный термин с моральной точки зрения. Не следует путать хороших хакеров со злыми &lt;b&gt;взломщиками&lt;/b&gt; или невежественными &lt;b&gt;скрипачами&lt;/b&gt; . Если вы их запутаете, мы будем считать, что вы злой или невежественный.</target>
        </trans-unit>
        <trans-unit id="a06bdcd2151c9efce6b287181e34780a4956856f" translate="yes" xml:space="preserve">
          <source>Something &amp;ldquo;iffy&amp;rdquo;. See &lt;b&gt;Boolean context&lt;/b&gt;.</source>
          <target state="translated">Что-то &amp;laquo;ненадежное&amp;raquo;. См. &lt;b&gt;Логический контекст&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e155f24963deb993057b4c0bc7a9a37afd51cb22" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) has the side effect of forcing a flush after every &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">Что-то дополнительное, что происходит, когда вы оцениваете &lt;b&gt;выражение&lt;/b&gt; . В настоящее время это может относиться практически ко всему. Например, оценка простого оператора присваивания обычно имеет &amp;laquo;побочный эффект&amp;raquo; присвоения значения переменной. (И вы думали, что присвоение значения было вашим основным намерением!) Аналогичным образом, присвоение значения специальной переменной &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) имеет побочный эффект принудительного сброса после каждой &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; для текущего выбранного дескриптора файла.</target>
        </trans-unit>
        <trans-unit id="4a7cb9b5327bb852f44f8593a79f045c7ad57891" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt;) has the side effect of forcing a flush after every &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;print&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783e080adee89f0dfad650da0b7f44d322697c43" translate="yes" xml:space="preserve">
          <source>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</source>
          <target state="translated">Что-то прогнило в состоянии программы.Приписываемая подпрограмма перестает существовать между точкой,в которой она была объявлена,и точкой,в которой был бы вызван обработчик(и)ее атрибута.</target>
        </trans-unit>
        <trans-unit id="9119b80c4db3125e0e5d3f36b18c5029258c49c9" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt; , since then the loop will not terminate.</source>
          <target state="translated">Что-то еще не так: рассмотрите переменную цикла $ cnt скрипта. Это было число, а не объект. Мы не можем сделать это значение типа &lt;code&gt;symbolic&lt;/code&gt; , так как тогда цикл не завершится.</target>
        </trans-unit>
        <trans-unit id="e0a55c1b08a5503b38a652a677cea0c95bbc3889" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt;, since then the loop will not terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b420f56b3a25fc6071dc9a2a0d9e492a4d5a4fac" translate="yes" xml:space="preserve">
          <source>Something like &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</source>
          <target state="translated">Что-то вроде &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2229723dcea531af53507e7f80155b0032f61e90" translate="yes" xml:space="preserve">
          <source>Something not owned by anybody. Perl is copyrighted and is thus</source>
          <target state="translated">Что-то,что никому не принадлежит.Perl защищен авторским правом и,таким образом.</target>
        </trans-unit>
        <trans-unit id="63320e06b401dd030b4898741e99304253f96385" translate="yes" xml:space="preserve">
          <source>Something of a hack but it prevents a lot of code duplication between MM_* variants.</source>
          <target state="translated">Что-то вроде взлома,но это предотвращает большое дублирование кода между вариантами MM_*.</target>
        </trans-unit>
        <trans-unit id="bbccb8a40149fe00b8fef910fa55b43eced89db6" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt; . Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">Что-то похожее на взлом смещения выполняется на AV, чтобы обеспечить эффективное смещение и сращивание начала массива; в то время как &lt;code&gt;AvARRAY&lt;/code&gt; указывает на первый элемент в массиве, видимый из Perl, &lt;code&gt;AvALLOC&lt;/code&gt; указывает на реальное начало массива C. Обычно это одно и то же, но операцию &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; можно выполнить, увеличив &lt;code&gt;AvARRAY&lt;/code&gt; на единицу и уменьшив &lt;code&gt;AvFILL&lt;/code&gt; и &lt;code&gt;AvMAX&lt;/code&gt; . Опять же, местоположение реального начала массива C вступает в игру только при освобождении массива. См. &lt;code&gt;av_shift&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="d8e742452f6bb725bfab3a5c5dba5836e7b3c368" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;shift&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt;. Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4332fef1f22d39fca98466a0536a5b2d1aaa44ee" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">Что-то, что сообщает вашей программе, какой тип переменной вам нужен. Perl не требует, чтобы вы объявляли переменные, но вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , чтобы указать, что вы хотите что-то иное, кроме значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e3fc8d53ca8cfa587374cbbfc4c208732524185a" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;state&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad3b77572daa04075d4890e62387b4b824f1955" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то для исключения с префиксом &lt;code&gt;&quot;-&quot;&lt;/code&gt; : существующее свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) определяемое пользователем свойство символа, чтобы представить все символы в этом свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="7bf62f5d5b516cf40152d9946d4ef2a34c8991f7" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7458ff984e1016174a3ccc404733830b1557d4" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt; : a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то для включения с префиксом &lt;code&gt;&quot;+&quot;&lt;/code&gt; : встроенное свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) свойство символа, определяемое пользователем, для представления всех символов в этом свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="bb71dc1c8ef0238d1cf6b1ff9fe27bbba1762fb7" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt;: a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691cfd6a9c9ef44b73a6c3b1fc2fc7e231422dbe" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то, с чем нужно пересекаться, с префиксом &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : существующее свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) определяемое пользователем свойство символа для всех символов, кроме символов в свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="4e94a757edcaa7aad7a0e5c39dc75f3c74ce6898" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6131959027de2eb65107afa87755cfdbae0af220" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">Что-то отрицательное, с префиксом &lt;code&gt;&quot;!&quot;&lt;/code&gt; : существующее свойство символа (с префиксом &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) или полностью определенное (включая имя пакета) свойство символа, определяемое пользователем, для представления всех символов в этом свойстве; две шестнадцатеричные кодовые точки для диапазона; или один шестнадцатеричный код.</target>
        </trans-unit>
        <trans-unit id="1f4e74c8c058a6efc1c6982e3f86bee213dbdf3d" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29b35d3b7e27c5736fa04a9d5a9779f7c0d02b4" translate="yes" xml:space="preserve">
          <source>Something we&amp;rsquo;d call a &lt;b&gt;metacharacter&lt;/b&gt; except that it&amp;rsquo;s a sequence of more than one character. Generally, the first character in the sequence must be a true metacharacter to get the other characters in the metasymbol to misbehave along with it.</source>
          <target state="translated">То, что мы бы назвали &lt;b&gt;метасимволом,&lt;/b&gt; за исключением того, что это последовательность из более чем одного символа. Как правило, первый символ в последовательности должен быть истинным метасимволом, чтобы другие символы в метасимволе плохо себя вели вместе с ним.</target>
        </trans-unit>
        <trans-unit id="0939ed03ca5713b7d596d517d3a21d567b42a063" translate="yes" xml:space="preserve">
          <source>Something went horribly wrong-- the number of microseconds that cannot become negative just became negative. Maybe your compiler is broken?</source>
          <target state="translated">Что-то пошло не так-количество микросекунд,которое не может стать отрицательным,просто стало отрицательным.Может,ваш компилятор сломался?</target>
        </trans-unit>
        <trans-unit id="c59ba282daa2ae9441382d6bdd1d5cbb102eba6e" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">Что-то, что вы можете увидеть откуда угодно, обычно это &lt;b&gt;переменные&lt;/b&gt; и &lt;b&gt;подпрограммы&lt;/b&gt; , которые видны повсюду в вашей программе. В Perl только некоторые специальные переменные являются действительно глобальными - большинство переменных (и все подпрограммы) существуют только в текущем &lt;b&gt;пакете&lt;/b&gt; . Глобальные переменные могут быть объявлены с помощью &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; . См. &amp;laquo;Глобальные декларации&amp;raquo; в главе 4 Camel &amp;laquo;Заявления и декларации&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e2c9c959fabe06831c4dbb79467f69e8f2c98312" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;our&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e88fa4cc64647b2e3278d50a97cb8b0618c720" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Что-то, что вы делаете для кого-то, чтобы сделать его счастливым, например, давая ему время суток (или время его жизни). На некоторых машинах известные службы перечислены функцией &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3583892f6ad6941063be20d46c43faa9b54da5ee" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;getservent&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae96bed2910e868f1f0a103c503d2b55a0cc3496" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;&quot;When Unicode Does Not Happen&quot;&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::upgrade($bytestring)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::downgrade($utf8string[, FAIL_OK])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457be77433ae10862116d65ca361c913afdc2edf" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::upgrade($bytestring) &lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::downgrade($utf8string[, FAIL_OK]) &lt;/a&gt;.</source>
          <target state="translated">Иногда (см. &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Раздел &amp;laquo; &lt;/a&gt;&lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;Когда Unicode не происходит&amp;raquo;&lt;/a&gt; или &amp;laquo;Ошибка Unicode&amp;raquo; ) возникают ситуации, когда вам просто нужно принудительно преобразовать строку байтов в UTF-8 или наоборот. Для этого можно использовать стандартный модуль &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; или низкоуровневые вызовы &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: upgrade ($ bytestring)&lt;/a&gt; и &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: downgrade ($ utf8string [, FAIL_OK])&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f608ce8dd6d68e4a0eca5a70c40d0ca13048d16" translate="yes" xml:space="preserve">
          <source>Sometimes a change affects code paths which you cannot test on the OSes which are directly available to you and it would be wise to have users on other OSes test the change before you commit it to blead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c72f071a765fd3018bc7af5d49df36cbd9aae7b" translate="yes" xml:space="preserve">
          <source>Sometimes greed is not good. At times, we would like quantifiers to match a</source>
          <target state="translated">Иногда жадность-это плохо.Иногда нам хотелось бы,чтобы квантификаторы соответствовали</target>
        </trans-unit>
        <trans-unit id="0aa27e840004256e29009bb974e009bb34e90abf" translate="yes" xml:space="preserve">
          <source>Sometimes instead of zeroing the allocated heap by using Newxz() you should consider &quot;poisoning&quot; the data. This means writing a bit pattern into it that should be illegal as pointers (and floating point numbers), and also hopefully surprising enough as integers, so that any code attempting to use the data without forethought will break sooner rather than later. Poisoning can be done using the Poison() macros, which have similar arguments to Zero():</source>
          <target state="translated">Иногда вместо обнуления выделенной кучи с помощью Newxz()следует подумать об &quot;отравлении&quot; данных.Это означает записать в него битовую закономерность,которая должна быть запрещена в качестве указателей (и чисел с плавающей точкой),а также,надеюсь,достаточно удивительна в качестве целых чисел,так что любой код,пытающийся бездумно использовать данные,рано или поздно разобьется.Отравление можно сделать с помощью макросов Poison(),которые имеют аргументы,аналогичные Zero():</target>
        </trans-unit>
        <trans-unit id="cae5675054ecaa30b3d68d273e86faefe7bf19e0" translate="yes" xml:space="preserve">
          <source>Sometimes it is advantageous to construct a pattern from the</source>
          <target state="translated">Иногда бывает выгодно построить шаблон из</target>
        </trans-unit>
        <trans-unit id="fa5de12a356ae81ac7e15fb6c4fdf4f42322289c" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to make more than one pass over the input files. If this is the case you have several options. You can make the first pass using &lt;b&gt;Pod::Parser&lt;/b&gt; and override your methods to store the intermediate results in memory somewhere for the &lt;b&gt;end_pod()&lt;/b&gt; method to process. You could use &lt;b&gt;Pod::Parser&lt;/b&gt; for several passes with an appropriate state variable to control the operation for each pass. If your input source can't be reset to start at the beginning, you can store it in some other structure as a string or an array and have that structure implement a &lt;b&gt;getline()&lt;/b&gt; method (which is all that &lt;b&gt;parse_from_filehandle()&lt;/b&gt; uses to read input).</source>
          <target state="translated">Иногда может потребоваться выполнить более одного прохода по входным файлам. В этом случае у вас есть несколько вариантов. Вы можете сделать первый проход, используя &lt;b&gt;Pod :: Parser,&lt;/b&gt; и переопределить свои методы для сохранения промежуточных результатов где-нибудь в памяти для &lt;b&gt;обработки&lt;/b&gt; методом &lt;b&gt;end_pod ()&lt;/b&gt; . Вы можете использовать &lt;b&gt;Pod :: Parser&lt;/b&gt; для нескольких проходов с соответствующей переменной состояния для управления операцией на каждом проходе. Если ваш источник ввода не может быть сброшен, чтобы начать с самого начала, вы можете сохранить его в какой-либо другой структуре как строку или массив и заставить эту структуру реализовать метод &lt;b&gt;getline ()&lt;/b&gt; (который является всем, что &lt;b&gt;parse_from_filehandle ()&lt;/b&gt; использует для чтения ввод).</target>
        </trans-unit>
        <trans-unit id="f6006f7823a5727b8006f191fa888a2e039ea099" translate="yes" xml:space="preserve">
          <source>Sometimes minimal matching can help a lot. Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you write something like this:</source>
          <target state="translated">Иногда минимальное соответствие может очень помочь.Представьте,что вы хотели бы сопоставить все между &quot;фу&quot; и &quot;бар&quot;.Изначально вы пишете что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="7e0fb1495abd7611e5570cce2cb4d1976ffa0113" translate="yes" xml:space="preserve">
          <source>Sometimes older versions of the module you're installing live in other directories in @INC. Because Perl loads the first version of a module it finds, not the newest, you might accidentally get one of these older versions even after installing a brand new version. To delete</source>
          <target state="translated">Иногда старые версии модуля,который вы устанавливаете,живут в других каталогах в @INC.Так как Perl загружает первую версию модуля,который он находит,а не самую новую,вы можете случайно получить одну из этих старых версий даже после установки совершенно новой версии.Чтобы удалить</target>
        </trans-unit>
        <trans-unit id="eb753520a2d796d4f761ee04ddf336bdbe0915a3" translate="yes" xml:space="preserve">
          <source>Sometimes ops are executed within an inner runops loop, such as tie, sort or overload code. In this case, something like</source>
          <target state="translated">Иногда операторы выполняются во внутреннем цикле runops,например,в цикле связывания,сортировки или кода перегрузки.В этом случае,что-то вроде</target>
        </trans-unit>
        <trans-unit id="147ec757892c0aed445b0fb45a48e27c978e8a0c" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">Иногда выполнение теста при определенных условиях приводит к зависанию тестового сценария. Определенная функция или метод не реализованы (например, &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; в MacOS), некоторые ресурсы недоступны (например, сетевое соединение) или модуль недоступен. В этих случаях необходимо пропустить тесты или объявить, что они не пройдут, но будут работать в будущем (тест todo).</target>
        </trans-unit>
        <trans-unit id="7390e59acad33d69c3848b5a344152fa281f8af4" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;fork()&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a525fd22c2b653fcabe0c32c53b3975d5455dc" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Иногда счетчик теста Test :: Builder увеличивается без вывода каких-либо результатов теста, например, при изменении &lt;code&gt;current_test()&lt;/code&gt; . В этих случаях Test :: Builder не знает результата теста, поэтому его тип &amp;laquo;неизвестен&amp;raquo;. Эти данные для этих тестов заполнены. Они считаются нормальными, но name и actual_ok оставлены &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f02b8eb27bf0ac9011c417f61209efd72c4a3f25" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd534b46a8017bb548267c02f58ed840dafad837" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c117b85f5735958c8ac918f5819ede8cc1b0ef4" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">Иногда интерфейса Test :: More недостаточно. К счастью, Test :: More построен на основе &lt;a href=&quot;builder&quot;&gt;Test :: Builder,&lt;/a&gt; который предоставляет единый унифицированный бэкэнд для использования любой тестовой библиотекой. Это означает, что две тестовые библиотеки, которые обе используют &amp;lt;Test :: Builder&amp;gt;, &lt;b&gt;могут&lt;/b&gt; использоваться вместе в одной программе&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="df8dfca3bc58e211921f51d53ab1d95cb5cb75f5" translate="yes" xml:space="preserve">
          <source>Sometimes the tests are wrong</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0436b0b7df1e2c343b73c639e499fd807b68f3" translate="yes" xml:space="preserve">
          <source>Sometimes there is some confusion about where &lt;code&gt;todo()&lt;/code&gt; should be looking for the &lt;code&gt;$TODO&lt;/code&gt; variable. If you want to be sure, tell it explicitly what $pack to use.</source>
          <target state="translated">Иногда возникает некоторая путаница в том, где &lt;code&gt;todo()&lt;/code&gt; должна искать переменную &lt;code&gt;$TODO&lt;/code&gt; . Если вы хотите быть уверенным, укажите явно, какой пакет $ использовать.</target>
        </trans-unit>
        <trans-unit id="399765aa05845ba02b6fea1a15de4bf746fb4a9e" translate="yes" xml:space="preserve">
          <source>Sometimes we would like our regexp to be able to match different possible words or character strings. This is accomplished by using the</source>
          <target state="translated">Иногда нам хотелось бы,чтобы наш регэксперт мог сопоставлять различные возможные слова или строки символов.Это достигается с помощью</target>
        </trans-unit>
        <trans-unit id="c45fdfd630d6939174042d52a2669877eec8162b" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt; . This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">Иногда вы хотите передавать подпрограмме не значение массива, а его имя, чтобы подпрограмма могла изменять его глобальную копию, а не работать с локальной копией. В Perl вы можете ссылаться на все объекты с определенным именем, поставив перед именем звездочку: &lt;code&gt;*foo&lt;/code&gt; . Это часто называют &amp;laquo;typeglob&amp;raquo;, потому что звезду на лицевой стороне можно рассматривать как совпадение с подстановочными знаками для всех забавных префиксных символов в переменных, подпрограммах и т.п.</target>
        </trans-unit>
        <trans-unit id="5af3185bc4cb6153940818cc124ced30384d5bf0" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt;. This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd89c56c7d1482880d960bf6dbcdba4cb33c9a40" translate="yes" xml:space="preserve">
          <source>Sometimes you have a context that is not current, and you want things to use it as the current one. In these cases you can call &lt;code&gt;$ctx-&amp;gt;do_in_context(sub { ... })&lt;/code&gt;. The codeblock will be run, and anything inside of it that looks for a context will find the one on which the method was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc7c2918cdb381ad384c3d9167215ff71a8a0da" translate="yes" xml:space="preserve">
          <source>Sometimes you have to store undefined values in AVs or HVs. Although this may be a rare case, it can be tricky. That's because you're used to using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; if you need an undefined SV.</source>
          <target state="translated">Иногда вам нужно хранить неопределенные значения в AV или HV. Хотя это может быть редким случаем, это может быть сложно. Это потому, что вы привыкли использовать &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; если вам нужен неопределенный SV.</target>
        </trans-unit>
        <trans-unit id="ce5b78669327a1c5203b6d6638f97e91e235e173" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt; . In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt; .</source>
          <target state="translated">Иногда просто хочется сказать, что тесты прошли. Обычно дело в том, что у вас есть какое-то сложное условие, которое трудно вставить в &lt;code&gt;ok()&lt;/code&gt; . В этом случае вы можете просто использовать &lt;code&gt;pass()&lt;/code&gt; (чтобы объявить тест в порядке) или fail (если не в порядке). Это синонимы &lt;code&gt;ok(1)&lt;/code&gt; и &lt;code&gt;ok(0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a82677750f0ce8e378152fcb09ef45c3dffa03dc" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt;. In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ad657b111885cfb86229225ce3dd7e07ab7571" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to truncate an already-existing file. This can be done using the &lt;code&gt;O_TRUNC&lt;/code&gt; flag. The behavior of &lt;code&gt;O_TRUNC&lt;/code&gt; with &lt;code&gt;O_RDONLY&lt;/code&gt; is undefined.</source>
          <target state="translated">Иногда вам может потребоваться обрезать уже существующий файл. Это можно сделать с помощью флага &lt;code&gt;O_TRUNC&lt;/code&gt; . Поведение &lt;code&gt;O_TRUNC&lt;/code&gt; с &lt;code&gt;O_RDONLY&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="d108e62bce7d546642fdcfcda3e786d8361305f7" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to leave the processes run by CPAN alone without caring about them. Because the Makefile.PL or the Build.PL sometimes contains question you're expected to answer, you can set a timer that will kill a 'perl Makefile.PL' process after the specified time in seconds.</source>
          <target state="translated">Иногда Вы можете захотеть оставить процессы,выполняемые CPAN,в покое,не заботясь о них.Так как Makefile.PL или Build.PL иногда содержит вопрос,на который вы должны ответить,вы можете установить таймер,который убьет процесс 'perl Makefile.PL' по истечении заданного времени в секундах.</target>
        </trans-unit>
        <trans-unit id="c00f6f509d151b6fb1ea7605fa661bc15fbf5303" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; function or the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">Иногда вам действительно может понадобиться узнать длину строки в байтах, а не длину символа. Для этого используйте либо функцию &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; либо директиву &lt;code&gt;bytes&lt;/code&gt; и функцию &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f11bb3346a94ad8679e866144b82f5a7774a030a" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;length()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ca48a72c9601cef59e5c67d6f3681c75e3b061" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to build a statically linked perl although your system supports dynamic loading. In this case you may explicitly set the linktype with the invocation of the Makefile.PL or make:</source>
          <target state="translated">Иногда вам может понадобиться построить статически подключенный perl,хотя ваша система поддерживает динамическую загрузку.В этом случае вы можете явно задать тип ссылки с помощью вызова Makefile.PL или make:</target>
        </trans-unit>
        <trans-unit id="d30402c312d3b94f0c6f02a6509532f4e38398dd" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt; , control characters (like &lt;code&gt;\n&lt;/code&gt; ) are displayed as &lt;code&gt;\x..&lt;/code&gt; , and the rest of the characters as themselves:</source>
          <target state="translated">Иногда вам может потребоваться отобразить скаляры Perl, содержащие Unicode, как простой текст ASCII (или EBCDIC). Следующая подпрограмма преобразует свой аргумент так, что символы Unicode с кодовыми точками больше 255 отображаются как &lt;code&gt;\x{...}&lt;/code&gt; , управляющие символы (например, &lt;code&gt;\n&lt;/code&gt; ) отображаются как &lt;code&gt;\x..&lt;/code&gt; , а остальные символы как сами себя :</target>
        </trans-unit>
        <trans-unit id="93f2d5137c1ee615f6cf1836ee85be0ea4a982af" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt;, control characters (like &lt;code&gt;\n&lt;/code&gt;) are displayed as &lt;code&gt;\x..&lt;/code&gt;, and the rest of the characters as themselves:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cab2a917ae8f995aa91a73cd34dbac7106cc0f" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand. These routines should live in the .pm file. Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed. You can also consult &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; for an alternate way to store and load your extra subroutines.</source>
          <target state="translated">Иногда вы можете захотеть предоставить некоторые дополнительные методы или подпрограммы, чтобы упростить или облегчить понимание интерфейса между Perl и вашим расширением. Эти процедуры должны находиться в файле .pm. Загружаются ли они автоматически при загрузке самого расширения или загружаются только при вызове, зависит от того, где в файле .pm помещается определение подпрограммы. Вы также можете обратиться к &lt;a href=&quot;autoloader&quot;&gt;AutoLoader,&lt;/a&gt; чтобы узнать об альтернативном способе хранения и загрузки дополнительных подпрограмм.</target>
        </trans-unit>
        <trans-unit id="d50f25bb7791c3200f165a11a2621c66fc26aa1f" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. One way to go is to put them into separate directories, but sometimes this is not the most suitable solution. The following technique allows you to put two (and more) XS files in the same directory.</source>
          <target state="translated">Иногда вам нужно иметь два и более XS-файлов в одном пакете.Один из способов-поместить их в отдельные каталоги,но иногда это не самое подходящее решение.Следующая техника позволяет поместить два (и более)XS-файла в одну директорию.</target>
        </trans-unit>
        <trans-unit id="aecdaaa113e37c215923d6d01ac79b4d26b62dd7" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. There are three ways: &lt;code&gt;XSMULTI&lt;/code&gt;, separate directories, and bootstrapping one XS from another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc76b72e97adc6a2bca89e4051260b585b27319" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84ae75a88af76cd17f4e95ee970d0624fc53ec5" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">Иногда вам нужно повторно вызывать одну и ту же подпрограмму. Обычно это происходит с функцией, которая работает со списком значений, например с встроенной функцией sort () в Perl. Вы можете передать функцию сравнения в sort (), которая затем будет вызываться для каждой пары значений, которые необходимо сравнить. Функции first () и reduce () из &lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt; следуют аналогичному шаблону.</target>
        </trans-unit>
        <trans-unit id="74631c8a306d075a7cfb9919a67e89afd99fe44c" translate="yes" xml:space="preserve">
          <source>Sometimes you really don't know how many tests were run, or it's too difficult to calculate. In which case you can leave off $number_of_tests_run.</source>
          <target state="translated">Иногда вы действительно не знаете,сколько тестов было проведено,или это слишком сложно подсчитать.В этом случае можно оставить $number_of_tests_run.</target>
        </trans-unit>
        <trans-unit id="85a6426e0300f2135b305a518e04a9c8bcb36f5b" translate="yes" xml:space="preserve">
          <source>Sometimes you should change the positions of the constant and the variable. For example, let's say you wanted to test which of many answers you were given, but in a case-insensitive way that also allows abbreviations. You can use the following technique if the strings all start with different characters or if you want to arrange the matches so that one takes precedence over another, as &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; has precedence over &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; here:</source>
          <target state="translated">Иногда вам следует изменить положение константы и переменной. Например, предположим, что вы хотите проверить, какой из многих ответов вам был дан, но без учета регистра, что также позволяет использовать сокращения. Вы можете использовать следующую технику, если все строки начинаются с разных символов или если вы хотите расположить совпадения так, чтобы одно имело приоритет над другим, поскольку &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; имеет приоритет над &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e295d93f5cf54bf6ebaedc8fedd1af1c66b62ba7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to combine the best of hashes and arrays. For example, the command line:</source>
          <target state="translated">Иногда хочется совместить лучшее из хэшей и массивов.Например,командную строку:</target>
        </trans-unit>
        <trans-unit id="eb405d6eff8a4115aee698cb0c98540a6a3fb25a" translate="yes" xml:space="preserve">
          <source>Sometimes you want to test if a module, or a list of modules, can successfully load. For example, you'll often want a first test which simply loads all the modules in the distribution to make sure they work before going on to do more complicated testing.</source>
          <target state="translated">Иногда необходимо проверить,может ли модуль или список модулей успешно загрузиться.Например,часто возникает необходимость в первом тесте,который просто загружает все модули в дистрибутиве,чтобы убедиться,что они работают,прежде чем приступать к более сложному тестированию.</target>
        </trans-unit>
        <trans-unit id="39b7fbc0e51ead34509190d6590e14e10ef47adc" translate="yes" xml:space="preserve">
          <source>Sometimes, blead will move while you're building or testing your changes. When this happens, your push will be rejected with a message like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf8f669e0c9325d3a3aabdd507e3c59589ddd67" translate="yes" xml:space="preserve">
          <source>Sometimes, for example when there are a lot of options, having a separate variable for each of them can be cumbersome. GetOptions() supports, as an alternative mechanism, storing options values in a hash.</source>
          <target state="translated">Иногда,например,когда вариантов много,наличие отдельной переменной для каждого из них может быть громоздким.GetOptions()в качестве альтернативного механизма поддерживает хранение значений опций в хэше.</target>
        </trans-unit>
        <trans-unit id="02fbdd8083e416b0e9b5fb808fb524ba8afb9c15" translate="yes" xml:space="preserve">
          <source>Sometimes, however, linked lists can be useful in situations where you want to &quot;shard&quot; an array so you have many small arrays instead of a single big array. You can keep arrays longer than Perl's largest array index, lock smaller arrays separately in threaded programs, reallocate less memory, or quickly insert elements in the middle of the chain.</source>
          <target state="translated">Иногда,однако,связанные списки могут быть полезны в ситуациях,когда вы хотите &quot;измельчить&quot; массив,так что у вас есть много маленьких массивов вместо одного большого массива.Вы можете хранить массивы дольше,чем самый большой индекс массива Perl,отдельно блокировать меньшие массивы в потоковых программах,перераспределять меньше памяти или быстро вставлять элементы в середину цепочки.</target>
        </trans-unit>
        <trans-unit id="97c577b8a14d559ea222f726e98e3c5c96ca2ea7" translate="yes" xml:space="preserve">
          <source>Sometimes, it can be necessary or useful to make sure that a certain function is fully loaded by AutoLoader. This is the case, for example, when you need to wrap a function to inject debugging code. It is also helpful to force early loading of code before forking to make use of copy-on-write as much as possible.</source>
          <target state="translated">Иногда бывает необходимо или полезно убедиться,что определенная функция полностью загружена автозагрузчиком.Это происходит,например,когда необходимо обернуть функцию для впрыскивания отладочного кода.Также полезно форсировать раннюю загрузку кода до форкинга,чтобы максимально использовать копирование на запись.</target>
        </trans-unit>
        <trans-unit id="135822a5181e82def02074d4f94c0948ca18c68d" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;&lt;code&gt;Encode::_utf8_on()&lt;/code&gt;&lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69c69258cfab486eea48fb3f2e535b94c5ff785" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode::_utf8_on() &lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">Иногда, когда расширение не преобразует данные, а просто сохраняет и извлекает их, вы можете использовать опасную функцию &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode :: _ utf8_on ()&lt;/a&gt; . Скажем, популярное расширение &lt;code&gt;Foo::Bar&lt;/code&gt; , написанное на C, предоставляет метод &lt;code&gt;param&lt;/code&gt; , который позволяет сохранять и извлекать данные в соответствии с этими прототипами:</target>
        </trans-unit>
        <trans-unit id="915dac0cd6a2dc4688c56bcdae8cb3044da9ebd2" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.</source>
          <target state="translated">Иногда,основываясь на некоторых критериях,вы можете не захотеть распаковывать полный архив,а только те файлы,которые вам подходят.</target>
        </trans-unit>
        <trans-unit id="f51205933e073241a85c203ffa02d17e6d6be23a" translate="yes" xml:space="preserve">
          <source>Somewhat obsolete (last update in 1996), but still useful. Also try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb96cd07e3d9541f84e40d3e5c507a59f023fa2" translate="yes" xml:space="preserve">
          <source>Sorry, hash keys must be smaller than 2**31 bytes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2c8f1aa042b04053bafd03d4559b130a601b41" translate="yes" xml:space="preserve">
          <source>Sort an array, with various options.</source>
          <target state="translated">Сортировка массива,с различными опциями.</target>
        </trans-unit>
        <trans-unit id="f11b2d382bb4d1812bd22f06feccfbd16f64c011" translate="yes" xml:space="preserve">
          <source>Sort an array. Here is an example:</source>
          <target state="translated">Сортируй массив.Вот пример:</target>
        </trans-unit>
        <trans-unit id="4d31f4a6a4ae686389ba0f01ad7435ce3ff7f965" translate="yes" xml:space="preserve">
          <source>Sort speed and memory use impacts</source>
          <target state="translated">Сортировка скорости и использования памяти воздействия</target>
        </trans-unit>
        <trans-unit id="669dcc90bf40cd3f0218ee9881e32132c08114cc" translate="yes" xml:space="preserve">
          <source>Sort subroutines written using &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are bound to their calling package. It is possible, but of limited interest, to define them in a different package, since the subroutine must still refer to the calling package's &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86fa3b469953cdb9c0cfc2f27adce6dc70ff6d4" translate="yes" xml:space="preserve">
          <source>Sort your map in Unicode order.</source>
          <target state="translated">Отсортируйте карту в порядке Юникода.</target>
        </trans-unit>
        <trans-unit id="ba790800e4b9f3d3512c898b0e6088f4dbb30c87" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function is very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">Сортировка-алгоритм сортировки quicksort,использовавшийся в Perls до 5.8.0 для реализации функции sort(),очень легко обмануть в неправильное поведение,так что это отнимает много времени.Начиная с Perl 5.8.0 по умолчанию используется другой алгоритм сортировки-слияние.Слияние не может приводить к неправильному поведению ни на одном из входных данных.</target>
        </trans-unit>
        <trans-unit id="375ce09517152463f4dde67936d2c7e3cbb12301" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function was very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a6e89fe9499560d5c7c4f0eba879f0797fcbdf" translate="yes" xml:space="preserve">
          <source>Sorts a list of strings.</source>
          <target state="translated">Сортирует список строк.</target>
        </trans-unit>
        <trans-unit id="89989e7858233b758069d9e36e356e32ea1f4ab9" translate="yes" xml:space="preserve">
          <source>Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one of the pieces of a process. Every process has at least one thread and, up until now, every process running Perl had only one thread. With 5.8, though, you can create extra threads. We're going to show you how, when, and why.</source>
          <target state="translated">Звучит ужасно похоже на процесс,не так ли? Ну,так и должно быть.Нитки-одна из частей процесса.Каждый процесс имеет по крайней мере одну нить,и до сих пор каждый процесс,запущенный Perl,имел только одну нить.Однако,с помощью 5.8 можно создавать дополнительные нити.Мы покажем вам,как,когда и почему.</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">Исходный код</target>
        </trans-unit>
        <trans-unit id="f0a8c7951e6c30a3c63c9dfb78486cbdf3df91af" translate="yes" xml:space="preserve">
          <source>Source Documentation</source>
          <target state="translated">Исходная документация</target>
        </trans-unit>
        <trans-unit id="c29ede2e39eca25683627a84bf1a76ac20119bd7" translate="yes" xml:space="preserve">
          <source>Source Filters</source>
          <target state="translated">Фильтры источника</target>
        </trans-unit>
        <trans-unit id="ade8f2661e9afaab2f2ac27ea8394747efc3b4bf" translate="yes" xml:space="preserve">
          <source>Source Handler</source>
          <target state="translated">обработчик источника</target>
        </trans-unit>
        <trans-unit id="862ba12e5a4342d2fb92f862ee8e26706e1ba4d8" translate="yes" xml:space="preserve">
          <source>Source code locations, even if available, can often be missing or misleading if the compiler has e.g. inlined code. Optimizer can make matching the source code and the object code quite challenging.</source>
          <target state="translated">Расположение исходного кода,даже если оно доступно,часто может отсутствовать или вводить в заблуждение,если у компилятора есть,например,inlined-код.Оптимизатор может сделать совмещение исходного и объектного кода довольно сложным.</target>
        </trans-unit>
        <trans-unit id="145cfa7abc78d317a3cc42e7465f11df70966408" translate="yes" xml:space="preserve">
          <source>Source detection stuff added by Steve Purkis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0272509bdb0dc4d43ea57d6e30f085a388335e1" translate="yes" xml:space="preserve">
          <source>Source documentation is created by putting POD comments into the C source, like this:</source>
          <target state="translated">Исходная документация создается путем добавления POD-комментариев в исходные тексты на C,как это сделано:</target>
        </trans-unit>
        <trans-unit id="4e42a4c9cdabac1017a64b490d8e6fd830b2d27a" translate="yes" xml:space="preserve">
          <source>Source filtering is an immensely powerful feature of recent versions of Perl. It allows one to extend the language itself (e.g. the Switch module), to simplify the language (e.g. Language::Pythonesque), or to completely recast the language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use the full power of Perl as its own, recursively applied, macro language.</source>
          <target state="translated">Фильтрация источников является чрезвычайно мощной функцией последних версий Perl.Она позволяет расширить сам язык (например,модуль Switch),упростить язык (например,Language::Pythonesque)или полностью переделать язык (например,Lingua::Romana::Perligata).По сути,это позволяет использовать всю мощь Perl в качестве собственного,рекурсивно применяемого макроязыка.</target>
        </trans-unit>
        <trans-unit id="83fa9e2aac616eaf300f336da8ba4cb15a670bf8" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; leak out into whichever</source>
          <target state="translated">Исходные фильтры, активированные в &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , просачиваются в любую</target>
        </trans-unit>
        <trans-unit id="29b60a7012567152c7f8bb1a380fa37b7673b6a3" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;eval&lt;/code&gt; leak out into whichever file scope is currently being compiled. To give an example with the CPAN module &lt;a href=&quot;Semi::Semicolons&quot;&gt;Semi::Semicolons&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800c2a6e745195ecf7cc595cd16957a9d13fb318" translate="yes" xml:space="preserve">
          <source>Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4d1a2fe52cc093111f41dbe07243489fb88fda" translate="yes" xml:space="preserve">
          <source>Source filters apply only to byte streams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c4984b5ea778bfe1a620b2921096dd64ef1a0a" translate="yes" xml:space="preserve">
          <source>Source filters only work on the string level, thus are highly limited in its ability to change source code on the fly. It cannot detect comments, quoted strings, heredocs, it is no replacement for a real parser. The only stable usage for source filters are encryption, compression, or the byteloader, to translate binary code back to source code.</source>
          <target state="translated">Фильтры исходных текстов работают только на уровне строк,поэтому их возможность изменять исходный код &quot;на лету&quot; крайне ограничена.Он не может обнаружить комментарии,цитируемые строки,heredocs,он не является заменой реальному парсеру.Единственное стабильное использование для фильтров исходного кода-это шифрование,сжатие или байтзайдер для преобразования двоичного кода обратно в исходный.</target>
        </trans-unit>
        <trans-unit id="80de4aac92ca7a214fcac217051e36befa5aa31a" translate="yes" xml:space="preserve">
          <source>Source for Perl documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf561fd42e8003d80556309fdb07a79bace6a7b" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-2 codes.</source>
          <target state="translated">Источник кодов ИСО 639-2.</target>
        </trans-unit>
        <trans-unit id="178db77b6a3b9b6df2ef880ae7bdafacae37b3c6" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-5 codes.</source>
          <target state="translated">Источник кодов ИСО 639-5.</target>
        </trans-unit>
        <trans-unit id="b69498a9aee25a26e6f9b5b4bc9ecc63222abc92" translate="yes" xml:space="preserve">
          <source>SourceHandler</source>
          <target state="translated">SourceHandler</target>
        </trans-unit>
        <trans-unit id="8644212c6ba60e5d4b37bed3eca56024c125205f" translate="yes" xml:space="preserve">
          <source>SourceHandlers</source>
          <target state="translated">SourceHandlers</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="0933c3d8de99d538b1745c97c9ac4e0808ab779e" translate="yes" xml:space="preserve">
          <source>Sources of further information</source>
          <target state="translated">Источники дополнительной информации</target>
        </trans-unit>
        <trans-unit id="35fda17ff05f63e9061208c2dd2aaaf98790e921" translate="yes" xml:space="preserve">
          <source>South Africa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ffb4c07982ffdd1d32da2ad256d5f400cca0af" translate="yes" xml:space="preserve">
          <source>South America</source>
          <target state="translated">Южная Америка</target>
        </trans-unit>
        <trans-unit id="ac6a60017b0bf8bff41d9bd208e6ef210c47fbdf" translate="yes" xml:space="preserve">
          <source>South Carolina</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f082fd9f31b253e1bc875b4f98b8b4196b3c96c9" translate="yes" xml:space="preserve">
          <source>Space after each comma.</source>
          <target state="translated">Пространство после каждой запятой.</target>
        </trans-unit>
        <trans-unit id="b842d2b9fb013f376f25c0749d5ad88cdb3e09d2" translate="yes" xml:space="preserve">
          <source>Space after last parenthesis matching on current line.</source>
          <target state="translated">Пробел после последнего совмещения скобок на текущей строке.</target>
        </trans-unit>
        <trans-unit id="155b83258e151629b360ae86e49e0abf46f96413" translate="yes" xml:space="preserve">
          <source>Space around a &quot;complex&quot; subscript (inside brackets).</source>
          <target state="translated">Пространство вокруг &quot;сложного&quot; абонемента (внутри скобок).</target>
        </trans-unit>
        <trans-unit id="3f9d9d7fddff18fb290d25d4e2d47eb10b024565" translate="yes" xml:space="preserve">
          <source>Space around most operators.</source>
          <target state="translated">Пространство вокруг большинства операторов.</target>
        </trans-unit>
        <trans-unit id="01ea9b6b043a2469906ded26f3a48de8eaf9e6e3" translate="yes" xml:space="preserve">
          <source>Space before the opening curly of a multi-line BLOCK.</source>
          <target state="translated">Пространство перед открытием вьющегося многострочного BLOCK.</target>
        </trans-unit>
        <trans-unit id="1109418eced3ecb23f96484aec5504c863ea2053" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , so see &lt;a href=&quot;../text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="translated">Пробелы в аргументе разделяют отдельные шаблоны, поэтому &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; объединяет все имена файлов, которые заканчиваются на &lt;code&gt;.exe&lt;/code&gt; или &lt;code&gt;.dll&lt;/code&gt; . Если вы хотите поставить буквальные пробелы в шаблоне глобуса, вы можете экранировать их двойными кавычками или обратной косой чертой. например, &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . Аргумент токенизируется с помощью &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , поэтому см. &lt;a href=&quot;../text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt; для получения подробной информации об используемых правилах цитирования.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
