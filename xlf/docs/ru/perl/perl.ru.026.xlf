<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">Все,что здесь написано,будет передано в MY::postamble(),если она у вас есть.</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">Все, что следует за &lt;code&gt;#&lt;/code&gt; , рассматривается как комментарий.</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">Все, что вы можете на законных основаниях сказать в месте, где требуется &lt;b&gt;значение&lt;/b&gt; . Обычно состоит из &lt;b&gt;литералов&lt;/b&gt; , &lt;b&gt;переменных&lt;/b&gt; , &lt;b&gt;операторов&lt;/b&gt; , &lt;b&gt;функций&lt;/b&gt; и вызовов &lt;b&gt;подпрограмм&lt;/b&gt; , не обязательно в этом порядке.</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">В любом случае,вот оно.Должна работать на perl v4 или больше.Может,меньше.</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">В любом случае,это то,что ты можешь сделать,если не можешь помочь себе.</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">Где бы Вы ни поместили идентификатор (или цепочку идентификаторов)в качестве части имени переменной или подпрограмм,Вы можете заменить идентификатор на BLOCK,возвращая ссылку правильного типа.Другими словами,предыдущие примеры могут быть написаны таким образом:</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">Везде,куда бы Вы ни поместили идентификатор (или цепочку идентификаторов)в качестве части имени переменной или подпрограмм,Вы можете заменить идентификатор на простую скалярную переменную,содержащую ссылку правильного типа:</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache::GZip Revisited</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">Помимо того, что это не переносимо для некоторых операционных систем, это затрудняло использование &lt;code&gt;gzopen&lt;/code&gt; в ситуациях, когда вы хотели извлечь / создать поток данных gzip, который встроен в файл большего размера, без необходимости открывать и закрывать файл несколько раз. раз.</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">Помимо обсуждения интерфейса C,предоставляемого Perl для написания обратных вызовов,документ использует ряд примеров,чтобы показать,как интерфейс на самом деле работает на практике.Кроме того,рассматриваются некоторые методы кодирования обратных вызовов.</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">Помимо того, что теперь переменная &lt;code&gt;$^W&lt;/code&gt; является логической, она работает точно так же ужасно неконтролируемым глобальным образом, за исключением того, что она не может отключать / включать предупреждения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="03dfbadf395083cbac3ebe537f5fd26158769beb" translate="yes" xml:space="preserve">
          <source>Apart from resetting the iterator, &lt;code&gt;values @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt;. (We recommend that you use void context &lt;code&gt;keys @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;values @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">Кроме поведения,описанного выше,Perl не расширяет множественные уровни интерполяции.В частности,вопреки ожиданиям программистов-оболочек,обратные кавычки делают</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">Кроме первого параметра,импорт может принимать необязательный список параметров.Их можно использовать для передачи параметров фильтру.Например:</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">Не считая избыточного, он во всех отношениях работает как Pod :: Text. См. &lt;a href=&quot;../text&quot;&gt;Pod :: Text&lt;/a&gt; для подробностей и доступных опций.</target>
        </trans-unit>
        <trans-unit id="da695cf6105edcb1a8b40d8d706c52df71f42750" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9828a7d2d366fc4b8702a1f03e94b53802450369" translate="yes" xml:space="preserve">
          <source>Apollo Domain/OS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f771942800f2d67122e33798021164ef80e3a2" translate="yes" xml:space="preserve">
          <source>App::Cpan</source>
          <target state="translated">App::Cpan</target>
        </trans-unit>
        <trans-unit id="5d59978967734805e51a9980657b59fbf6558d9e" translate="yes" xml:space="preserve">
          <source>App::Cpan - easily interact with CPAN from the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove - реализует команду &lt;code&gt;prove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State - хранилище состояний для команды &lt;code&gt;prove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">Приложение::Доказать::Состояние::Результат-результаты индивидуального теста.</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">Приложение::Доказать::Состояние::Результат::Тест-Индивидуальные результаты теста.</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">Видимо,IBM использовал компилятор (на некоторое время около 95?),который меняет маску FP направо и налево.Это не</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">Обращайтесь к их собственным интересам! Если Perl для них новый (и,следовательно,страшный),найдите что-нибудь,что Perl может сделать,чтобы решить одну из их проблем.Это может означать,что Perl либо экономит им что-то (время,головные боли,деньги),либо дает им что-то (гибкость,власть,контролепригодность).</target>
        </trans-unit>
        <trans-unit id="7820ab67805cf1ba0f215418474bf3c391c0a394" translate="yes" xml:space="preserve">
          <source>Appearances can be deceptive, especially when it comes to emptiness. If you are scratching your head trying to work out why Test::Tester is saying that your diagnostics are wrong when they look perfectly right then the answer is probably whitespace. From version 0.10 on, Test::Tester surrounds the expected and got diag values with single quotes to make it easier to spot trailing whitespace. So in this example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">Добавить элемент в список операторов,содержащийся непосредственно в опции типа списка,возвращая удлиненный список.</target>
        </trans-unit>
        <trans-unit id="555e00ca2c34efb8f2b3198b481016b18bb0499c" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list. &lt;code&gt;first&lt;/code&gt; is the list-type op, and &lt;code&gt;last&lt;/code&gt; is the op to append to the list. &lt;code&gt;optype&lt;/code&gt; specifies the intended opcode for the list. If &lt;code&gt;first&lt;/code&gt; is not already a list of the right type, it will be upgraded into one. If either &lt;code&gt;first&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; is null, the other is returned unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">Прилагаемые элементы</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">Добавить элементы СПИСКА в массив.</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">Добавить время выполнения для каждого теста для вывода. Если доступно, использует &lt;a href=&quot;../../time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">Добавить время выполнения для каждого теста для вывода. Если доступно, использует &lt;a href=&quot;../time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d38ef820bcef303880baae14bb62295e88bb8d" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">Добавление флага G_KEEPERRR,чтобы</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">Прикладывает заданную строку или объект дерева разбора или последовательности к дереву разбора этой внутренней последовательности.</target>
        </trans-unit>
        <trans-unit id="bc939bc86e4ec12055b78bc1367433c6c3dc048c" translate="yes" xml:space="preserve">
          <source>Apple Mac OS 8/9</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">Применение патчей</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">Выпуск приложения в сентябре 2001 года,HP-UX 11.00 является первым,который поставляется с Perl.К тому времени он был perl-5.6.1 в /opt/perl.Первое появление находится на CD 5012-7954 и может быть установлено с помощью</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">Применяет синтаксический контекст к дереву оп,представляющему выражение.</target>
        </trans-unit>
        <trans-unit id="4e768fecef5f9dd672611658c8743f59705b1284" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression. &lt;code&gt;o&lt;/code&gt; is the op tree, and &lt;code&gt;context&lt;/code&gt; must be &lt;code&gt;G_SCALAR&lt;/code&gt;, &lt;code&gt;G_ARRAY&lt;/code&gt;, or &lt;code&gt;G_VOID&lt;/code&gt; to specify the context to apply. The modified op tree is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">Применяет dl_find_symbol()к членам @dl_librefs и возвращает первое найденное совпадение.</target>
        </trans-unit>
        <trans-unit id="8f16d6f27d971ff843245cdc989aa538f3326e5f" translate="yes" xml:space="preserve">
          <source>Apply &lt;a href=&quot;#int-EXPR&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to the value returned by &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">Примените &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; к значению, возвращаемому &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; если вам нужны случайные целые числа вместо случайных дробных чисел. Например,</target>
        </trans-unit>
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">Примените &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; к значению, возвращаемому &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; если вам нужны случайные целые числа вместо случайных дробных чисел. Например,</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">Применить перл-специфическую эвристику,чтобы найти правильные POD.Это включает удаление Perl-подобных расширений,опускание подкаталогов,которые являются числовыми,но делают</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">Применить список опций коммутатора к состоянию,в результате чего обновляется состояние внутреннего объекта.Ничего не возвращается.</target>
        </trans-unit>
        <trans-unit id="7b0453d0169f10e0dd546ac420ad360f4311387a" translate="yes" xml:space="preserve">
          <source>Applying %s to %s will act on scalar(%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">Применение &lt;code&gt;autodie&lt;/code&gt; к &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; приводит к тому, что экзотические формы &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; будут считаться синтаксической ошибкой до конца лексической области видимости. Если вам действительно нужно использовать экзотическую форму, вы можете вызвать &lt;code&gt;CORE::system&lt;/code&gt; или &lt;code&gt;CORE::exec&lt;/code&gt; вместо этого, или не использовать &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; перед вызовом экзотической формы.</target>
        </trans-unit>
        <trans-unit id="73c33410e3cd1ef38b870e6e841b6a111c44ea15" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; causes the exotic forms &lt;code&gt;system { $cmd } @args &lt;/code&gt; or &lt;code&gt;exec { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">Приблизительный эквивалент Perl: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">Приблизительный эквивалент Perl: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f08b9c9f0996e8f22c8e80713baa3b2c5d6b61a" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171752021f257ea835e63866304a10e0627a5496" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">04-07 апреля 1997 года:Jarkko Hietaniemi добавил функциональность исполнения на время выполнения.</target>
        </trans-unit>
        <trans-unit id="538beea89400340066f03de9b8531baacd233ee4" translate="yes" xml:space="preserve">
          <source>April 2010</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">Произвольные большие рациональные числа</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">Пакет математических расчетов с плавающей запятой произвольного размера</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">Произвольный размер целочисленный/плавающий математический пакет</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="fa197ea9d1ebf357ab1895c0454edae5ed010094" translate="yes" xml:space="preserve">
          <source>Archive and test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Архив::Tar-модуль для манипуляций с таровыми архивами</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive::Tar предоставляет объектно-ориентированный механизм для работы с tar-файлами.Он предоставляет методы классов для быстрой и простой работы с файлами,а также позволяет создавать объекты tar-файлов для пользовательских манипуляций.Если у вас установлен модуль IO::Zlib,Archive::Tar также будет поддерживать сжатые или gzipped tar-файлы.</target>
        </trans-unit>
        <trans-unit id="2de9e103622352aeb9a5f8214ffe2d70dee8d73d" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 / xz compressed file and the IO::Uncompress::Bunzip2 / IO::Uncompress::UnXz are not available and simply return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">Архив::Tar предупредит,если вы попытаетесь передать сжатый bzip2 файл,а модули IO::Zlib/IO::Uncompress::Bunzip2 будут недоступны и просто вернутся.</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">Архив :: Tar-&amp;gt; create_archive ($ file, $ compressed, @filelist)</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">Архив :: Tar-&amp;gt; extract_archive ($ файл, $ сжатый)</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">Archive :: Tar-&amp;gt; iter ($ filename, [$ compressed, {opt =&amp;gt; $ val}])</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">Архив :: Tar-&amp;gt; list_archive ($ file, $ compressed, [\ @properties])</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">Архив :: Tar-&amp;gt; новый ([$ file, $ compressed])</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Архив::Tar::Файл-подкласс для внутрипамятного извлеченного файла из архива::Tar</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">Архив :: Tar :: File-&amp;gt; new (chunk =&amp;gt; $ chunk)</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">Archive :: Tar :: File-&amp;gt; new (данные =&amp;gt; $ path, $ data, $ opt)</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">Архив :: Tar :: Файл-&amp;gt; новый (файл =&amp;gt; $ путь)</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Архив::Tar::Файлы обеспечивают аккуратный маленький объектный слой для извлекаемых в памяти файлов.В основном он используется внутри Archive::Tar для приведения кода в порядок,но нет причин,по которым пользователи не должны использовать и это API.</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">Архивирование и сжатие</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Перл регексы DFA или NFA? Соответствуют ли они стандарту POSIX?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">Это те же самые нити?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">еще не реализованы.</target>
        </trans-unit>
        <trans-unit id="37ca7d873908345ae9a97f86f6ad04967916d66e" translate="yes" xml:space="preserve">
          <source>Are we at end of file?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">Ты работаешь под Windows,и ты написал</target>
        </trans-unit>
        <trans-unit id="d10b1e8f0d25e8ced1066c8aec43c1966f5ae507" translate="yes" xml:space="preserve">
          <source>Are you running the latest released version of perl?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3fcfe8bf10e9354f16b7f74dc1d506d9b370761" translate="yes" xml:space="preserve">
          <source>Are you sure what you have is a bug?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">Вы используете действительно старую версию Perl?</target>
        </trans-unit>
        <trans-unit id="1f76843fe2bb213b3ad1c4d889f7769d9611e0fa" translate="yes" xml:space="preserve">
          <source>Arg too short for msgsnd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354bf98925838ca68611b950e2a37ebd11c21640" translate="yes" xml:space="preserve">
          <source>Argentina</source>
          <target state="translated">Argentina</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">Возможно, это единственные процедуры, которые вам когда-либо понадобятся для выполнения фрагментов кода Perl из вашей программы C. Ваш код может быть сколь угодно длинным; он может содержать несколько операторов; он может использовать &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; и &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; для включения внешних файлов Perl.</target>
        </trans-unit>
        <trans-unit id="1bfedcdfdca0d5a6460d0d9a3f351f6cd3b4ab7e" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt;, and &lt;a href=&quot;perlfunc#do&quot;&gt;&quot;do&quot; in perlfunc&lt;/a&gt; to include external Perl files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="a16749b15d046173fc9fcdf8d075749c151dba6a" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; isn't numeric%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c043537672dbd0f8f35895f8245f3c4e263a6c8f" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; treated as 0 in increment (++)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">обратный звонок по аргументам</target>
        </trans-unit>
        <trans-unit id="f421070543c0b96709c29a61e7bc0e29c9a6f773" translate="yes" xml:space="preserve">
          <source>Argument list not closed for PerlIO layer &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">стопка аргументов</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">Управление стеком аргументов в ядре точно такое же, как и в XSUB - см. &lt;a href=&quot;perlxstut&quot;&gt;Perlxstut&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; и &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; для более подробного описания макросов, используемых при манипулировании стеком.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">Аргументы нечувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">Аргументы принудительно переводятся в целочисленный формат,если не строки.</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">Аргументы передаются в код PP и возвращаются из кода PP с использованием стека аргументов &lt;code&gt;ST&lt;/code&gt; . Типичный способ обработки аргументов - вытащить их из стека, обработать их так, как вы хотите, а затем отправить результат обратно в стек. Так работает, например, оператор косинуса:</target>
        </trans-unit>
        <trans-unit id="ad4cbcd9603c1cc923fb5986131d15966c20d956" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt;. The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">Аргументы обычно форматируются так, чтобы иметь ширину, необходимую для отображения данного значения. Вы можете переопределить ширину, поместив здесь число, или получить ширину из следующего аргумента (с &lt;code&gt;*&lt;/code&gt; ) или из указанного аргумента (например, с &lt;code&gt;*2$&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="79b342195140d9018897c02d4477a0cd2a68bcbe" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt;) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">Аргументами директивы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; являются пары (ключ, значение). Полный набор допустимых ключей см. В разделе &amp;laquo; &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Перегружаемые операции&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="cb61e5648eb703f1cc9dab71a052768830d8cd36" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;use overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">Аргументы, которые не начинаются с дефиса, считаются именами подпрограмм или форматов для рендеринга; если такие функции не указаны, отображается основная часть программы (вне каких-либо подпрограмм, за исключением используемых или требуемых файлов). Передача &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; или &lt;code&gt;END&lt;/code&gt; приведет к печати всех соответствующих специальных блоков. Аргументы должны следовать за вариантами.</target>
        </trans-unit>
        <trans-unit id="c05d8fdf0d667d5e67ac75211debe610ccbb3189" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">Аргументы для &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; которые &lt;b&gt;не&lt;/b&gt; проверяются на taintedness.</target>
        </trans-unit>
        <trans-unit id="4006b3311082c7bd892aab6f8d46c918fb22f118" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;syswrite&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">Аргументы в пользу испытаний</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">Аргументы,которые будут добавлены в командную строку</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">Аргументами к этим командам являются либо строки,точно соответствующие идентификационной строке объекта,либо регулярные выражения,нечувствительные к регистру различных атрибутов объектов.Синтаксический анализатор распознает регулярное выражение только в том случае,если оно заключено в косую черту.</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">Аргументы:COUNT-это количество раз,которое необходимо выполнить цикл,а CODE-это код,который необходимо выполнить.CODE может быть как кодовой ссылкой,так и строкой для оценки;в любом случае он будет запущен в пакете вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">Аргументы:ВРЕМЯ-это минимальное время,в течение которого должен быть запущен КОД,а КОД-это код,который должен быть запущен.КОД может быть как кодовой ссылкой,так и строкой для оценки;в любом случае он будет запущен в пакете вызывающего абонента.</target>
        </trans-unit>
        <trans-unit id="38bfcf708d6931f7d42f920765aaabb5369a9058" translate="yes" xml:space="preserve">
          <source>Aristotle</source>
          <target state="translated">Aristotle</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="aa4a9120c32b4442874b4d46d816ed7dd9bbe6c6" translate="yes" xml:space="preserve">
          <source>Arithmetic methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6532be8ff2d954f60f4660f2c54f2ea6702b27e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104fd3fd5302e037fb8d66ee6c616a71d0739a71" translate="yes" xml:space="preserve">
          <source>Arizona</source>
          <target state="translated">Arizona</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">Арнольд,Кен и Джеймс Гослинг.Язык программирования Java,2-е изд.Эддисон-Уэсли,1998,ISBN 0-201-31006-6.</target>
        </trans-unit>
        <trans-unit id="f59bbf13db8733c389e26cc50790aefa49bd87eb" translate="yes" xml:space="preserve">
          <source>Around line 755:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85b5fb626816d8525d58d40352050c4cc00a98a" translate="yes" xml:space="preserve">
          <source>Around line 804:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab366efdd1504cdfaa681a633d790c9ce967f2c" translate="yes" xml:space="preserve">
          <source>Arranges for &lt;code&gt;sv&lt;/code&gt; to be shared between threads if a suitable module has been loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2eecdf1f299504d5505f21d414522aaf018f39c" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Обеспечивает чтение или запись FILEHANDLE в &amp;laquo;двоичном&amp;raquo; или &amp;laquo;текстовом&amp;raquo; режиме в системах, где библиотеки времени выполнения различают двоичные и текстовые файлы. Если FILEHANDLE является выражением, значение принимается как имя дескриптора файла. Возвращает true в случае успеха, в противном случае возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно).</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Обеспечивает чтение или запись FILEHANDLE в &amp;laquo;двоичном&amp;raquo; или &amp;laquo;текстовом&amp;raquo; режиме в системах, где библиотеки времени выполнения различают двоичные и текстовые файлы. Если FILEHANDLE является выражением, значение принимается как имя дескриптора файла. Возвращает true в случае успеха, в противном случае возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно).</target>
        </trans-unit>
        <trans-unit id="9aa41e54fbd34ab084dcbe15fa8b4cafcc06eac6" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on &lt;code&gt;sv&lt;/code&gt; if a suitable module has been loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">Устанавливает блокировку взаимного исключения на sv,если загружен подходящий модуль.</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">Упорядочивает распределение sv между потоками,если загружен подходящий модуль.</target>
        </trans-unit>
        <trans-unit id="77504b93a8457067677bb3cc3aa5311d924675f5" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">Устанавливает доставку SIGALRM этому процессу по истечении заданного количества секунд настенных часов. Если SECONDS не указан, используется значение, хранящееся в &lt;code&gt;$_&lt;/code&gt; . (На некоторых машинах, к сожалению, прошедшее время может быть на одну секунду меньше или больше, чем вы указали из-за того, как подсчитываются секунды, а планирование процессов может задержать доставку сигнала еще больше.)</target>
        </trans-unit>
        <trans-unit id="8d25b4a3297455b9e035c6b89f1c17b7c2bce696" translate="yes" xml:space="preserve">
          <source>Array (&lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">Массивная интерполяция</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">Функции манипуляции массивом</target>
        </trans-unit>
        <trans-unit id="380a0ee1c3f2add958e20ae4dd8479917cbbbae8" translate="yes" xml:space="preserve">
          <source>Array holding list of directories to be searched for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">Массив имен расширений для включения при статической сборке.При статической сборке MakeMaker обычно собирается со всеми установленными расширениями,и это обычно является желаемым поведением.Если присутствует INCLUDE_EXT,то MakeMaker будет собирать только с теми расширениями,которые явно упомянуты.(например,[qw(Socket POSIX)])).</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">Массив имен расширений для исключения при статической сборке.Это игнорируется,если присутствует INCLUDE_EXT.За более подробной информацией обратитесь к INCLUDE_EXT.(например,[qw(Socket POSIX)])).</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">Массив строк,содержащих имя (и адрес электронной почты)автора(ов)пакета.Используется в файлах CPAN Meta (META.yml или META.json)и PPD (Perl Package Description)для PPM (Perl Package Manager).</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">Массив имен символов для переменных,которые будут доступны как универсальные символы.В настоящее время используется только под AIX,OS/2,VMS и Win32.По умолчанию установлено значение [].(например,[qw(Foo_version Foo_numstreams Foo_tree)])).</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Операции с массивами, которые изменяют скаляры, переупорядочивают их, добавляют или вычитают некоторые скаляры, работают только с массивами. Они не могут работать со списком, который исправлен. Массивы операция включает в себя &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a460c81ea3de2b351104bc9016134c2ac95be02" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78674941505b9a2d4a3ebcad653295e98eb9dd4f" translate="yes" xml:space="preserve">
          <source>Array passed to stat will be coerced to a scalar%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dd682c69e6440164f6188906ac10fd3b501a3b" translate="yes" xml:space="preserve">
          <source>Array reference of files to examine. May not be specified with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a46ecccd0814a0e990fda1f36238fc6513b396" translate="yes" xml:space="preserve">
          <source>Array refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">Размер массива можно получить,сделав это:</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">Массив,индексируемый по опкоду,функций,которые будут вызываться для &quot;проверки&quot; фазы сборки опций при компиляции Perl кода.Для большинства (но не для всех)типов оп,после первоначальной сборки и заполнения дочерними опциями,она будет отфильтровываться через функцию проверки,на которую ссылается соответствующий элемент этого массива.Новый оп передается в качестве единственного аргумента в функцию проверки,а функция проверки возвращает завершенный оп.Функция проверки может (как следует из названия)проверять операцию на достоверность и ошибки сигнала.Она также может инициализировать или изменять части оп,или выполнять более радикальные операции,такие как добавление или удаление дочерних оп,или даже выбрасывать опцию и возвращать на ее место другую операцию.</target>
        </trans-unit>
        <trans-unit id="cbf55f45c7afc72d6bf912afc7befb393f385b76" translate="yes" xml:space="preserve">
          <source>Arrayref containing the facet-data hashes of events nested under this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref. Например, [qw (archname manext)] определяет ARCHNAME и MANEXT из config.sh. MakeMaker в любом случае добавит к CONFIG следующие значения: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">Массив.Например,[qw(name1 name2)]пропустить (не писать)секции Makefile.Внимание! Не используйте атрибут SKIP для незначительного ускорения.Это может серьезно повредить Makefile.Используйте его только в том случае,если он вам действительно нужен.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">Массивы и фрагменты интерполируются в строки, заключенные в двойные кавычки, путем соединения элементов с разделителем, указанным в переменной &lt;code&gt;$&quot;&lt;/code&gt; ( &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; если указано &quot; use English; &quot;), по умолчанию пробел. Следующие элементы эквивалентны:</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">Массивы не индексированы.Вот как получить элементы в массиве:</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">Индекс массивов от 0.Аналогично позиции строк в substr()и index().</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="758bdbae166b00a3d8e1212d185299f382e9e26b" translate="yes" xml:space="preserve">
          <source>Arrow Notation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">Правило стрелки</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">Статья о локализации программного обеспечения</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">Статьи, которые либо посвящены &lt;b&gt;DB_File,&lt;/b&gt; либо используют его.</target>
        </trans-unit>
        <trans-unit id="a75b4962c21a671a678a35a002d5a9cabe9f37df" translate="yes" xml:space="preserve">
          <source>Artistic License</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Артур Бергман &amp;lt;небо в сети DOT&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Артур Бергман, &amp;laquo;Где волшебники боятся ступить&amp;raquo;, 11 июня 2002 г., &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">Как &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; или &lt;a href=&quot;../functions/lstat&quot;&gt;lstat,&lt;/a&gt; но с временными метками доступа / изменения / изменения в субсекундном разрешении, если и операционная система, и файловая система поддерживают такие временные метки. Чтобы переопределить стандартный stat ():</target>
        </trans-unit>
        <trans-unit id="cad0de4aeb2435c3e6250aa64da21872a52c4d61" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#stat&quot;&gt;&quot;stat&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlfunc#lstat&quot;&gt;&quot;lstat&quot; in perlfunc&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674c2b9678e49fe5c48ffe3cac937cee6706d2ff" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt; but with the ability to set the access/modify file timestamps in subsecond resolution, if the operating system and the filesystem, and the mount options of the filesystem, all support such timestamps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">Как &lt;b&gt;-nok,&lt;/b&gt; за исключением того, что он сообщает о старых системах.</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">Как &lt;b&gt;-ok,&lt;/b&gt; за исключением того, что он сообщает о старых системах.</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">В качестве &lt;code&gt;$form_name&lt;/code&gt; должно быть указано одно из следующих имен.</target>
        </trans-unit>
        <trans-unit id="bdbf26fc42681222abf14a2b96b2aee6d500b3fc" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt;, one of the following names must be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">Поскольку &lt;code&gt;-Dm&lt;/code&gt; использует слой PerlIO для вывода, он сам по себе будет выделять довольно много SV, которые скрыты, чтобы избежать рекурсии. Вы можете обойти уровень PerlIO, если вместо этого используете ведение журнала SV, предоставляемое &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a4f04aeb40af858ae530be27c732d3a12776244" translate="yes" xml:space="preserve">
          <source>As DSM is a trimmed-down Linux system, it lacks many of the tools and libraries commonly found on Linux. The basic tools like sh, cp, rm, etc. are implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a9797fcef19ae902b7dc1fdcbae68c956c3e1b" translate="yes" xml:space="preserve">
          <source>As I work on a particular part of my module it's most likely that the tests that cover that code will fail. I'd like to run the whole test suite but have it prioritize these 'hot' tests. I can tell prove to do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4dc14381957936768414e0ffe59b0595e92060" translate="yes" xml:space="preserve">
          <source>As JSON cannot directly represent Perl objects, you have to choose between a pure JSON representation (without the ability to deserialise the object automatically again), and a nonstandard extension to the JSON syntax, tagged values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">Поскольку Perl разрабатывается глобальной командой волонтеров,наша документация часто содержит заклинания,которые выглядят забавно,чтобы</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">Поскольку Storable не знает и не заботится о наборах символов (хотя и знает,что ширина символов может превышать восемь бит),любая разница в интерпретации кодов символов между хостом и целевой системой-это ваша проблема.В частности,если хост и целевая система используют разные точки кода для представления символов,используемых в текстовом представлении чисел с плавающей точкой,вы не сможете обмениваться данными с плавающей точкой,даже с помощью nstore().</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">Как начинающий Perl программист,ваше самое распространенное использование OO Perl будет заключаться в использовании модулей сторонних производителей,которые описаны ниже.</target>
        </trans-unit>
        <trans-unit id="053c80fe967b67f5a7cb2ee310e9489c54536633" translate="yes" xml:space="preserve">
          <source>As a code reference, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">Как следствие того факта, что &lt;code&gt;:raw&lt;/code&gt; обычно выводит слои, обычно имеет смысл использовать его только как единственный или первый элемент в спецификации слоя. При использовании в качестве первого элемента он обеспечивает известную основу для построения, например</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">Как следствие, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; игнорирует любое число или &lt;code&gt;*&lt;/code&gt; после &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="794de411ca7a9fef9a487a0fcead83c094be14c9" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;pack&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">Как следствие,поведение оператора % согласуется с поведением встроенного в Perl оператора % (как документировано в manpage perlop),а также с уравнением</target>
        </trans-unit>
        <trans-unit id="b71d9a336a26729c423fab79edbbfcd18fbf6683" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">Для удобства метод setsockopt () &lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt; преобразует число в упакованный байтовый буфер, а getsockopt () распакует байтовый буфер правильного размера обратно в число.</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">Для удобства,если передается только один аргумент,то этот аргумент принимается за название теста (как в вышеприведенных примерах).</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">Как отладочное средство,вы можете заставить Карпа обращаться с крокодилой как с признанием,а карпа-как с кулаком.</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">Как производный класс от Pod :: Parser, Pod :: PlainText поддерживает те же методы и интерфейсы. См. &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; для всех подробностей; вкратце, создается новый парсер с помощью &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; а затем вызывается либо parse_from_filehandle (), либо parse_from_file ().</target>
        </trans-unit>
        <trans-unit id="64d726339f8e6e60df57582ad6893533391488ae" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Как производный класс от Pod :: Simple, Pod :: Man поддерживает те же методы и интерфейсы. См. Все подробности в &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7614b2907ce626d34be33e5f930e92fbced576b9" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Как производный класс от Pod :: Simple, Pod :: Text поддерживает те же методы и интерфейсы. См. Все подробности в &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; ; вкратце, создается новый парсер с помощью &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; а затем обычно вызывается parse_file ().</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">В качестве последнего замечания,обратите внимание,что можно заполнить %subr посредством</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">В качестве заключительной мысли помните,что невозможно (на момент написания статьи)создать полезную программу,которая будет выполняться в нулевое или отрицательное время,и этот основной принцип можно записать как:</target>
        </trans-unit>
        <trans-unit id="b93fce445dda74a4e62d212ddcfc5d79912e276b" translate="yes" xml:space="preserve">
          <source>As a final word of warning, if you're using adb, &lt;code&gt;make test&lt;/code&gt; may appear to hang; this is because it doesn't output anything until it finishes running all tests. You can check its progress by logging into the device, moving to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">В качестве следующего примера это означает, что если вы хотите поместить эти фрагменты кода в стиль &lt;code&gt;C&lt;/code&gt; (код):</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">В качестве еще одного примера:На момент написания статьи идентификатор &quot;библиографии&quot; не поддерживается,но предположим,что какой-то процессор был написан для того,чтобы распознать его как способ (скажем)обозначения библиографической ссылки (обязательно содержащей коды форматирования в обычных параграфах).Тот факт,что абзацы &quot;библиографии&quot; предназначены для обычной обработки,будет указываться путем указания двоеточия перед каждым идентификатором &quot;библиографии&quot;:</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">В качестве дополнительной оптимизации при выходе из блока eval в &lt;code&gt;FETCH&lt;/code&gt; выполнение кода, следующего за блоком, все еще продолжается во внутреннем цикле. Когда возбуждается исключение, &lt;code&gt;docatch&lt;/code&gt; сравнивает &lt;code&gt;JMPENV&lt;/code&gt; уровень &lt;code&gt;CxEVAL&lt;/code&gt; с &lt;code&gt;PL_top_env&lt;/code&gt; и если они отличаются, просто повторно бросает исключение. Таким образом появляются любые внутренние петли.</target>
        </trans-unit>
        <trans-unit id="52bd4fd38df2dbb2fd4340b3f74e473ef3bdf3bc" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt;, execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1271bc4a381b470fd6a076ccacce4ffa6ad068" translate="yes" xml:space="preserve">
          <source>As a further performance optimisation, the various &lt;code&gt;PUSH&lt;/code&gt; macros all operate using a local variable &lt;code&gt;SP&lt;/code&gt;, rather than the interpreter-global variable &lt;code&gt;PL_stack_sp&lt;/code&gt;. This variable is declared by the &lt;code&gt;dSP&lt;/code&gt; macro - though it is normally implied by XSUBs and similar so it is rare you have to consider it directly. Once declared, the &lt;code&gt;PUSH&lt;/code&gt; macros will operate only on this local variable, so before invoking any other perl core functions you must use the &lt;code&gt;PUTBACK&lt;/code&gt; macro to return the value from the local &lt;code&gt;SP&lt;/code&gt; variable back to the interpreter variable. Similarly, after calling a perl core function which may have had reason to move the stack or push/pop values to it, you must use the &lt;code&gt;SPAGAIN&lt;/code&gt; macro which refreshes the local &lt;code&gt;SP&lt;/code&gt; value back from the interpreter one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">Как правило,ваше сообщение о коммите должно помочь программисту,который знает ядро Perl,быстро понять,что вы пытались сделать,как вы пытались это сделать,и почему изменение имеет значение для Perl.</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">Как правило,вы должны</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">Как правило, если модуль пытается быть объектно-ориентированным, ничего не экспортируется. Если это просто набор функций, тогда &lt;code&gt;@EXPORT_OK&lt;/code&gt; что угодно, но используйте &lt;code&gt;@EXPORT&lt;/code&gt; с осторожностью. Для имен функций и методов используйте голые слова вместо имен с префиксом амперсанда для списков экспорта.</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">Как правило,если модуль пытается быть объектно-ориентированным,то экспортировать ничего не надо.Если это просто набор функций,то @EXPORT_OK все что угодно,но используйте @EXPORT с осторожностью.</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">Как правило, если модуль пытается быть объектно-ориентированным, ничего не экспортируйте. Если это просто набор функций и переменных, вы можете экспортировать их через другой массив, называемый &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Этот массив не помещает автоматически свои подпрограммы и имена переменных в пространство имен, если только пользователь специально этого не требует.</target>
        </trans-unit>
        <trans-unit id="d1e3854176f62c2a9d9d5efd5fe3ab87123d6cec" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt;. This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b6a2f89138fc36d28abf12c8042d8936138512" translate="yes" xml:space="preserve">
          <source>As a historical predecessor, Microsoft's variant probably has more rights for the name, though it may be objected that Microsoft shouldn't have used JIS as part of the name in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">Однако,в крайнем случае:</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">В крайнем случае,вы можете использовать перл-однолинейный:</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">В крайнем случае вы также можете использовать &lt;code&gt;PERL5DB&lt;/code&gt; для настройки отладчика, напрямую задав внутренние переменные или вызывая функции отладчика.</target>
        </trans-unit>
        <trans-unit id="3641087c3ef51813afe729b7c79e589f770bbb23" translate="yes" xml:space="preserve">
          <source>As a matter of policy we do &lt;b&gt;not&lt;/b&gt; edit the history of the blead and maint-* branches. If a typo (or worse) sneaks into a commit to blead or maint-*, we'll fix it in another commit. The only types of updates allowed on these branches are &quot;fast-forwards&quot;, where all history is preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04cbbe97dbf5020460c7615ae57692f7d59ba371" translate="yes" xml:space="preserve">
          <source>As a nonstandard extension to the JSON syntax that is enabled by the &lt;code&gt;relaxed&lt;/code&gt; setting, shell-style comments are allowed. They can start anywhere outside strings and go till the end of the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">Как существительное, часть синтаксиса, состоящая из более мелких частей. Как переходный глагол, создать &lt;b&gt;объект&lt;/b&gt; с помощью &lt;b&gt;конструктора&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d308f1d2a7a4e49c9b329da294e48e6b1847ac8e" translate="yes" xml:space="preserve">
          <source>As a qr// compiled regular expression, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">В результате этих проблем,начиная с версии v5.20,Perl делает то,что рассматривает точки,не относящиеся к коду Юникода,как типичные неприсвоенные символы Юникода,и соответствует им.(Примечание:Юникод имеет нетипичные неприсвоенные точки кода.Например,у него есть несимвольные точки кода,а те,которые,когда им присваивают,предназначены для написания справа налево,как на арабском и иврите.Perl предполагает,что ни одна не-некодовая точка кода не имеет нетипичных свойств).</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">В итоге &lt;code&gt;$?&lt;/code&gt; всегда будет нулевым, если статус выхода подпроцесса указывает на успешное завершение, и ненулевым, если возникло предупреждение или ошибка или была запущена программа, соответствующая кодировке значений _POSIX_EXIT, и установила статус.</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">Как скалярный оператор:</target>
        </trans-unit>
        <trans-unit id="752c53cfef8630f9f583dd0b9dbea60f05156327" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; can be written &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">В качестве ярлыка &lt;code&gt;(*MARK:NAME)&lt;/code&gt; можно написать &lt;code&gt;(*:NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">В качестве ярлыка однопараметрический вызов принимает имя файла из глобальной скалярной переменной с тем же именем,что и ручка файла:</target>
        </trans-unit>
        <trans-unit id="039d51ec286cc421077f33a0f875e9f7cff415a2" translate="yes" xml:space="preserve">
          <source>As a shortcut, a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">В качестве ярлыка вы можете использовать модуль &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="36ff34b524a3157846677e62919073347584851b" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">В качестве побочного эффекта, поскольку &lt;code&gt;_&lt;/code&gt; не работает, операторы стекового тестирования файлов ( &lt;code&gt;-f -w $file&lt;/code&gt; ) также не будут работать.</target>
        </trans-unit>
        <trans-unit id="62159e969c4500e73917688c4b98b60605e2b166" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt;) won't work either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d4d9254656022c6da49a40120c1e05ea2c02db" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the keys. In particular, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e28725785d22d9074c048ed573cb348e22b3201" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; resets the HASH or ARRAY's internal iterator (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the values. In particular, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">В качестве побочного эффекта вызов keys () сбрасывает внутренний итератор HASH или ARRAY (см. &lt;a href=&quot;#each&quot;&gt;Каждый&lt;/a&gt; ). В частности, вызов keys () в контексте void сбрасывает итератор без дополнительных затрат.</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">В качестве побочного эффекта вызов keys () сбрасывает внутренний итератор HASH или ARRAY (см. &lt;a href=&quot;each&quot;&gt;Каждый&lt;/a&gt; ). В частности, вызов keys () в контексте void сбрасывает итератор без дополнительных затрат.</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">В качестве побочного эффекта вызов values ​​() сбрасывает внутренний итератор HASH или ARRAY, см. &lt;a href=&quot;#each&quot;&gt;Каждый&lt;/a&gt; . (В частности, вызов values ​​() в контексте void сбрасывает итератор без каких-либо дополнительных затрат. Помимо сброса итератора, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; в контексте списка такие же, как и простой &lt;code&gt;@array&lt;/code&gt; . (Мы рекомендуем использовать &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; пустого контекста @array для этого, но рассудил, что получение &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out потребует больше документации, чем оставление его внутри.)</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">В качестве побочного эффекта вызов values ​​() сбрасывает внутренний итератор HASH или ARRAY, см. &lt;a href=&quot;each&quot;&gt;Каждый&lt;/a&gt; . (В частности, вызов values ​​() в контексте void сбрасывает итератор без каких-либо дополнительных затрат. Помимо сброса итератора, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; в контексте списка такие же, как и простой &lt;code&gt;@array&lt;/code&gt; . (Мы рекомендуем использовать &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; пустого контекста @array для этого, но рассудил, что получение &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out потребует больше документации, чем оставление его внутри.)</target>
        </trans-unit>
        <trans-unit id="af3e12604d06f443cb762354f1d6409bffc768b2" translate="yes" xml:space="preserve">
          <source>As a side effect, the timestamps of the written specfiles reflect the linear order of all dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb674c50cbe5a1c37b1e7edbe788950bfe9342b0" translate="yes" xml:space="preserve">
          <source>As a simple string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">В качестве особого случая</target>
        </trans-unit>
        <trans-unit id="0643313e18655a38535055ff2dedcaffb5a9d742" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt;) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">В качестве особого случая для &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; пустой шаблон, указанный в синтаксисе &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;оператора сопоставления&lt;/a&gt; ( &lt;code&gt;//&lt;/code&gt; ), конкретно соответствует пустой строке, что противоречит его обычной интерпретации как последнее успешное сопоставление.</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">В качестве особого случая для &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; пустой шаблон, указанный в синтаксисе &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;оператора сопоставления&lt;/a&gt; ( &lt;code&gt;//&lt;/code&gt; ), конкретно соответствует пустой строке, что противоречит его обычной интерпретации как последнее успешное сопоставление.</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">В качестве особого случая, если перегрузка возвращает сам объект, он будет использоваться напрямую. Перегруженное преобразование, возвращающее объект, вероятно, является ошибкой, потому что вы, вероятно, получите что-то похожее на &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a27c6716a696c868b2b90bc0841f6de8cd23a521" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b483703a04a580981cff65069d8ecd06f49d995" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">В качестве особого случая форма с тремя аргументами с режимом чтения / записи и третьим аргументом &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">В качестве особого случая форма с тремя аргументами с режимом чтения / записи и третьим аргументом &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">В качестве особого случая &lt;code&gt;\(@foo)&lt;/code&gt; возвращает список ссылок на содержимое &lt;code&gt;@foo&lt;/code&gt; , а не ссылку на сам &lt;code&gt;@foo&lt;/code&gt; . То же самое для &lt;code&gt;%foo&lt;/code&gt; , за исключением того, что ключевые ссылки относятся к копиям (поскольку ключи - это просто строки, а не полноценные скаляры).</target>
        </trans-unit>
        <trans-unit id="783b2ec5714a2b5973ee8fd00ae088eee54cd571" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt;, not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt;, except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e559b691f686abba65a2b1bdefbe0a3fb92d6845" translate="yes" xml:space="preserve">
          <source>As a special case, if the constructor is passed a single argument (as opposed to an even-sized list of key/value pairs), it is taken to be the value of the &lt;code&gt;PeerAddr&lt;/code&gt; parameter. This is parsed in the same way, according to the behaviour given in the &lt;code&gt;PeerHost&lt;/code&gt; AND &lt;code&gt;LocalHost&lt;/code&gt; PARSING section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">В особом случае, если тест в &lt;code&gt;for&lt;/code&gt; цикла (или соответствующий во &lt;code&gt;while&lt;/code&gt; цикла) пусто, оно рассматривается как верно. То есть оба</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">В качестве особого случая, если значение этой переменной разделено пробелами, хвост можно использовать для отключения орнаментов, установив для него значение &lt;code&gt;o=0&lt;/code&gt; или &lt;code&gt;ornaments=0&lt;/code&gt; . Голова должна быть такой, как описано выше, скажем</target>
        </trans-unit>
        <trans-unit id="ea8552b1560e05c9733562fefc877a4a04a62b1f" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt;. The head should be as described above, say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">В качестве особого случая, если вы укажете имя модуля &lt;code&gt;Unicode&lt;/code&gt; , вы получите номер версии базы данных символов Unicode в комплекте с запрошенными версиями Perl.</target>
        </trans-unit>
        <trans-unit id="ed0f26789d5db7e7c0ccec99b141a92d811bb2de" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt;, you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">В особом случае,когда аксессуар вызывается со ссылкой на хэш в качестве единственного аргумента,это приводит к присвоению всего хэш-элемента.Возвращается ссылка на объект.</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">В особом случае,когда аксессуар вызывается со ссылкой на массив в качестве единственного аргумента,это приводит к присвоению всему элементу массива.Возвращается объектная ссылка.</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">В качестве особого исключения,когда вы режете список (но не массив или хэш),если список оценивает как пустой,то,взяв кусочек этого пустого списка,вы всегда получите пустой список по очереди.Таким образом:</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">Как поставщик, вам может потребоваться выполнить резервное копирование исправлений безопасности после того, как мы предоставим поддержку в течение 3 лет. Мы можем предоставить вам ограниченную поддержку и советы, когда вы это сделаете, и, где это возможно, попытаемся применить эти исправления к соответствующим веткам -maint в git, хотя мы можем или не можем сделать доступными нумерованные выпуски или &amp;laquo;официальные&amp;raquo; исправления. Свяжитесь с нами по адресу &amp;lt;perl5-security-report@perl.org&amp;gt;, чтобы начать этот процесс.</target>
        </trans-unit>
        <trans-unit id="f4351851a4bb7c858433022e707056375232e54d" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. See &lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;&quot;SECURITY VULNERABILITY CONTACT INFORMATION&quot; in perlsec&lt;/a&gt; for details on how to begin that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">Как добровольческая организация,обязательства,которые мы берем на себя,в значительной степени зависят от доброй воли и упорного труда людей,которые не обязаны вносить свой вклад в Perl.</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">Как и выше,но текст узла назначения ссылки.</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">Поскольку все значения истинны, простого теста &lt;code&gt;if&lt;/code&gt; достаточно, чтобы определить, присутствует ли расширение.</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">Как уже упоминалось ранее,вы также можете объявить inlined subs динамически в BEGIN время,если их тело состоит из лексически описанного скаляра,который не имеет других ссылок.Только первый пример здесь будет inlined:</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; при использовании для потока управления Perl предоставляет операторы &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; (см. ниже). Поведение при коротком замыкании идентично. Однако приоритет &lt;code&gt;&quot;and&quot;&lt;/code&gt; и &lt;code&gt;&quot;or&quot;&lt;/code&gt; намного ниже, так что вы можете безопасно использовать их после оператора списка без скобок:</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">Как всегда с Перлом,есть не один способ сделать это.Ниже приведены несколько примеров подходов к выполнению общих преобразований между числовыми представлениями.Это должно быть репрезентативным,а не исчерпывающим.</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">Как всегда,если кто-то из них когда-нибудь будет официально объявлен дефектом,он будет исправлен и удален.</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">Как всегда, настройка сервера немного сложнее, чем запуск клиента. Модель состоит в том, что сервер создает особый вид сокета, который ничего не делает, кроме как прослушивает определенный порт для входящих соединений. Для этого он вызывает метод &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; с аргументами, немного отличающимися от аргументов клиента.</target>
        </trans-unit>
        <trans-unit id="b052d1d2bb45ec362535f92deef9adc1abd8b3f0" translate="yes" xml:space="preserve">
          <source>As an (ahem) accidental feature, &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines were looked up as methods (using the &lt;code&gt;@ISA&lt;/code&gt; hierarchy) even when the subroutines to be autoloaded were called as plain functions (e.g. &lt;code&gt;Foo::bar()&lt;/code&gt;), not as methods (e.g. &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; or &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">В качестве дополнительного удобства,модуль Digest::SHA предлагает подпрограммы для вычисления кешированных хэшей с использованием алгоритмов HMAC-SHA-1/224/256/384/512.Эти сервисы существуют только в функциональной форме,и имитируют стиль и поведение</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">В качестве помощи в сбросе цветов функция color()принимает скаляр в качестве первого аргумента и любое количество строк атрибутов в качестве второго аргумента и возвращает скаляр,обёрнутый в экранирующие коды,так что атрибуты будут установлены,как было запрошено до строки и сброшены в нормальное состояние после строки.В качестве первого аргумента можно передать ссылку на массив,а затем содержимое этого массива будет принято за атрибуты и цветовые коды,а остальные аргументы-за текст для раскрашивания.</target>
        </trans-unit>
        <trans-unit id="0317f97de63b01d4c67910fb17a2e6ee0d204ecf" translate="yes" xml:space="preserve">
          <source>As an alternative to subclassing the components I need to change I can attach callbacks to the default classes. TAP::Harness exposes these callbacks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">В качестве альтернативы,вы можете предпочесть бросать исключения,используя модуль Error.</target>
        </trans-unit>
        <trans-unit id="8f3dc04daa3638b5aaf1c862a68465a157788d9e" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f943c4f68c18459667f13d0990dfceca7c5ca2a9" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">В качестве альтернативы перегруженные константы (см. &lt;a href=&quot;overload&quot;&gt;Раздел &amp;laquo;Перегрузка&amp;raquo;&lt;/a&gt; ) предоставляют простой способ расширить функциональные возможности механизма RE путем замены одного шаблона другим.</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">В качестве альтернативы укажите число вместо списка букв (например, &lt;b&gt;-D14&lt;/b&gt; эквивалентно &lt;b&gt;-Dtls&lt;/b&gt; ):</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">В качестве альтернативы,чтобы сохранить регистр заменяющего слова,если оно длиннее оригинала,можно воспользоваться этим кодом,по словам Джеффа Пиняна:</target>
        </trans-unit>
        <trans-unit id="b70856a89ed6672d06c69a35074c3c6f2093e9dd" translate="yes" xml:space="preserve">
          <source>As an example consider the structure of a zip file. This is a well-defined file format that mixes both compressed and uncompressed sections of data in a single file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">Примером того, что попадает в категорию &lt;code&gt;&quot;strict'&lt;/code&gt; , но не иначе, является шаблон</target>
        </trans-unit>
        <trans-unit id="ec5fbaf06c5491bc9e0146955b6b1bccb85f04a8" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt;, but not otherwise, is the pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">В качестве примера приведен код,который печатает сообщение &quot;Perl exited with active threads:2 работает и не работает&quot;:</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">В качестве примера,для которого подходит притягательный квантификатор,рассмотрим соответствие строки,приведенной в кавычках,как это бывает в нескольких языках программирования.Обратный слеш используется как экранирующий символ,который указывает на то,что следующий символ должен восприниматься буквально,как еще один символ для строки.Поэтому,после вступительной кавычки,мы ожидаем (возможно,пустую)последовательность альтернатив:либо какой-то символ за исключением нецифровой кавычки,либо обратный слеш,либо экранированный символ.</target>
        </trans-unit>
        <trans-unit id="5cd508967ae1e206046e267640fdf9448ece0fe7" translate="yes" xml:space="preserve">
          <source>As an example, let's implement a &lt;code&gt;THAW&lt;/code&gt; function that regenerates the &lt;code&gt;My::Object&lt;/code&gt; from the &lt;code&gt;FREEZE&lt;/code&gt; example earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">Например, когда Perl видит &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , он кодирует символ в UTF-8 и сохраняет его в $ x. Затем он помечается как символьные данные, поэтому, например, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; возвращает &lt;code&gt;1&lt;/code&gt; . Однако в области прагмы &lt;code&gt;bytes&lt;/code&gt; $ x рассматривается как последовательность байтов - байтов, составляющих кодировку UTF8, - а &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; возвращает &lt;code&gt;2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cc20e99e2c8e44ee448eca66f36aaad208e30f4" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = chr(400)&lt;/code&gt;, it encodes the character in UTF-8 and stores it in &lt;code&gt;$x&lt;/code&gt;. Then it is marked as character data, so, for instance, &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, &lt;code&gt;$x&lt;/code&gt; is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">В качестве временной меры,вы можете либо изменить строку #! в ваших скриптах,чтобы она конкретно ссылалась на старую версию perl,например,в Solaris 9 использовать #!/usr/perl5/5.00503/bin/perl,чтобы использовать версию perl,которая была по умолчанию для Solaris 8,или,если у вас есть большое количество скриптов,может быть более удобно сделать старую версию perl по умолчанию в вашей системе.Вы можете сделать это,изменив соответствующие сим-ссылки в /usr/perl5 следующим образом (пример для Solaris 9):</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">В &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; оптимизации нельзя вызывать командную оболочку, указанную в $ ENV {PERL5SHELL} . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; порождает внешний процесс и немедленно возвращает его обозначение процесса, не дожидаясь его завершения. Возвращаемое значение может быть впоследствии использовано в &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; . Невозможность &lt;code&gt;spawn()&lt;/code&gt; подпроцесса указывается установкой &lt;code&gt;$?&lt;/code&gt; на &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; устанавливается способом, совместимым с Unix (т.е. статус выхода подпроцесса получается с помощью &lt;code&gt;&quot;$?&lt;/code&gt; 8&amp;raquo; &amp;gt;&amp;gt;, как описано в документации). (Win32)</target>
        </trans-unit>
        <trans-unit id="137d06b82a3cf943b3082535121ce9ca48c386c5" translate="yes" xml:space="preserve">
          <source>As another example, this Pod source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24dac5f3b0ae02bfc967e018bd163c71db2de949" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a string composed of a single space character (such as &lt;code&gt;' '&lt;/code&gt; or &lt;code&gt;&quot;\x20&quot;&lt;/code&gt;, but not e.g. &lt;code&gt;/ /&lt;/code&gt;). In this case, any leading whitespace in EXPR is removed before splitting occurs, and the PATTERN is instead treated as if it were &lt;code&gt;/\s+/&lt;/code&gt;; in particular, this means that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">В качестве другого особого случая &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; имитирует поведение инструмента командной строки &lt;b&gt;awk&lt;/b&gt; по умолчанию, когда ШАБЛОН либо опущен, либо</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">В качестве другого особого случая &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; имитирует поведение инструмента командной строки &lt;b&gt;awk&lt;/b&gt; по умолчанию, когда ШАБЛОН либо опущен, либо</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">В качестве другого обходного пути для этой проблемы Perl 5.10.0 представил &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , которые эквивалентны &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;за исключением того,&lt;/b&gt; что они только гарантируют быть определенным после успешного совпадения, которое было выполнено с модификатором &lt;code&gt;/p&lt;/code&gt; (сохранение). Использование этих переменных не влечет за собой глобального снижения производительности, в отличие от их эквивалентов знаков препинания, однако с компромиссом, заключающимся в том, что вы должны указать Perl, когда вы хотите их использовать. Начиная с Perl 5.20, эти три переменные эквивалентны &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$'&lt;/code&gt; и &lt;code&gt;/p&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="5306125a9b9482228b73d9001504cb8ff0235e3b" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, which are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation character equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">Как описано &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;выше&lt;/a&gt; , Perl может вызывать методы для таких операторов, как &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;&amp;amp;&lt;/code&gt; , в ходе реализации отсутствующих операций, таких как &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; и &lt;code&gt;&amp;amp;=&lt;/code&gt; . Хотя эти методы могут обнаруживать такое использование, проверяя определенность третьего аргумента, они во всех случаях должны избегать изменения своих операндов. Это потому, что Perl не вызывает конструктор копирования перед вызовом этих методов.</target>
        </trans-unit>
        <trans-unit id="20dd96aab8100e801c2698dbb8e487016840bd2c" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, and &lt;code&gt;&amp;amp;=&lt;/code&gt;. While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c1d88156738ffdc72a22d4eb2c079c412ad705" translate="yes" xml:space="preserve">
          <source>As described earlier, if there are many changes on your smoke-me branch then you should prepare a merge commit in which to give an overview of those changes by using the following command instead of the last command above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">Как уже говорилось,у Perl есть одна нога (два копыта?),посаженная в каждом из двух миров:старый мир ASCII и однобайтовые локали,и новый мир Unicode,модернизирующийся по мере необходимости.Если ваш старый код не использует Юникод в явном виде,автоматического перехода на Юникод не должно произойти.</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">Как объяснялось выше,анонимная функция с доступом к лексическим переменным,видимым при компиляции этой функции,создает закрытие.Она сохраняет доступ к этим переменным,несмотря на то,что запускается только позже,например,в обработчике сигнала или обратном вызове Tk.</target>
        </trans-unit>
        <trans-unit id="03fe8a37ea6c568501bcfeecc21187a67095c9a8" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot;&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">Как объясняется в разделе &amp;laquo; &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;Правила ASCII по сравнению с правилами Юникода&amp;raquo;&lt;/a&gt; , в соответствии с правилами ASCII они считаются неназначенными символами.</target>
        </trans-unit>
        <trans-unit id="48e236093008993b6e4def956b958d0cb620db14" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot;&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">Как объяснено в &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist ()&lt;/a&gt; , то, находится ли кодовая точка в списке или нет, зависит от того, является ли индекс четным (в) или нечетным (нет). И как объясняется в &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap ()&lt;/a&gt; , индекс используется с возвращенным параллельным массивом для поиска сопоставления.</target>
        </trans-unit>
        <trans-unit id="bf0e7abd7a09ee9c2ba9a8344c5b618840f66e79" translate="yes" xml:space="preserve">
          <source>As far as creating the &lt;code&gt;$pOverlapped&lt;/code&gt; structure, you are currently on your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101540b4758da815d4da97e60284cb84f98af97f" translate="yes" xml:space="preserve">
          <source>As for new features and requests to change common behaviors, please ask the author of JSON::XS (Marc Lehmann, &amp;lt;schmorp[at]schmorp.de&amp;gt;) first, by email (important!), to keep compatibility among JSON.pm backends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">Что касается других операций, подпрограмме, реализующей '=', передаются три аргумента, хотя последние два всегда &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;''&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf65c0259648a27866b59740e85994dce5ffc5e7" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;undef&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf2ef2540039c1386257379903eff22c20c0bad" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt;, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">Как будто всех этих классов было недостаточно, Perl также определяет классы символов в стиле POSIX. Они имеют форму &lt;code&gt;[:name:]&lt;/code&gt; , с &lt;code&gt;name&lt;/code&gt; имя класса POSIX. Классы POSIX - это &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; и &lt;code&gt;xdigit&lt;/code&gt; , а также два расширения, &lt;code&gt;word&lt;/code&gt; (расширение Perl для соответствия &lt;code&gt;\w&lt;/code&gt; ) и &lt;code&gt;blank&lt;/code&gt; (расширение GNU ). &lt;code&gt;//a&lt;/code&gt; модификатор ограничивает их совпадением только в диапазоне ASCII; в противном случае они могут совпадать с соответствующими классами Perl Unicode: &lt;code&gt;[:upper:]&lt;/code&gt; совпадает с &lt;code&gt;\p{IsUpper}&lt;/code&gt; и т. д. (Здесь есть некоторые исключения и подводные камни; см. &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; для полного обсуждения.) &lt;code&gt;[:digit:]&lt;/code&gt; , &lt;code&gt;[:word:]&lt;/code&gt; и &lt;code&gt;[:space:]&lt;/code&gt; соответствуют знакомым классам символов &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; и &lt;code&gt;\s&lt;/code&gt; . Чтобы отменить класс POSIX, поместите &lt;code&gt;^&lt;/code&gt; перед именем, чтобы, например, &lt;code&gt;[:^digit:]&lt;/code&gt; соответствовал &lt;code&gt;\D&lt;/code&gt; а в Unicode - &lt;code&gt;\P{IsDigit}&lt;/code&gt; . Классы символов Unicode и POSIX могут использоваться так же, как &lt;code&gt;\d&lt;/code&gt; , за исключением того, что классы символов POSIX могут использоваться только внутри класса символов:</target>
        </trans-unit>
        <trans-unit id="c16f46255f2c5b016b34cc67482e93dd7025a2f9" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt;. Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">Как подразумевается выше, среда, доступ к которой осуществляется через &lt;code&gt;%ENV&lt;/code&gt; является глобальной, и существует соглашение, что переменные среды, специфичные для программы, имеют форму &lt;code&gt;Program$Name&lt;/code&gt; . Каждая файловая система поддерживает текущий каталог, а текущий каталог текущей файловой системы является &lt;b&gt;глобальным&lt;/b&gt; текущим каталогом. Следовательно, общительные программы не изменяют текущий каталог, а полагаются на полные пути, а программы (и Makefiles) не могут предполагать, что они могут порождать дочерний процесс, который может изменять текущий каталог, не затрагивая его родительский (и всех остальных в этом отношении) .</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">Как и в некоторых оболочках,имя переменной можно заключить в фигурные скобки,чтобы отличить ее от следующих буквенно-цифровых (и подчеркивающих).Вы также должны сделать это при интерполяции переменной в строку,чтобы отделить имя переменной от следующего двойного столбца или апострофа,так как в противном случае они будут рассматриваться как разделитель пакетов:</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">Как он есть,он предшествует версии version.pm,но имеет ту же цель:сделать строки версий видимыми и сопоставимыми.</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">Как следует из названия, если ваш код выдал обязательное предупреждение, вы получите предупреждение, хотите вы этого или нет. Например, приведенный ниже код всегда будет выдавать предупреждение &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; относительно &amp;laquo;2:&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">Как уже упоминалось, все переменные по умолчанию являются локальными для потока. Чтобы использовать общие переменные, вам также необходимо загрузить &lt;a href=&quot;threads/shared&quot;&gt;потоки :: shared&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7273a25ae51ae519b823516d45a11747d27d1f68" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">Поскольку блокировки являются рекомендательными,они не препятствуют доступу к данным или их модификации другим потоком,который сам по себе не пытается получить блокировку переменной.</target>
        </trans-unit>
        <trans-unit id="3b3a54f56722c72f0cfe48a91b285385f9f3fe3e" translate="yes" xml:space="preserve">
          <source>As long as a context exists for a given hub, all tools that try to get a context will get the existing instance. If you try to store the context you will pollute other tools with incorrect context information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">Пока все обработанные документы приводят к некоторому выводу, даже если этот вывод содержит ошибки ( раздел &lt;code&gt;POD ERRORS&lt;/code&gt; &lt;code&gt;--errors=pod&lt;/code&gt; созданный с помощью --errors = pod ), &lt;b&gt;pod2man&lt;/b&gt; выйдет со статусом 0. Если какой-либо из обрабатываемых документов не приведет к &lt;b&gt;ошибке&lt;/b&gt; выходной документ, &lt;b&gt;pod2man&lt;/b&gt; завершит работу со статусом 1. Если в обрабатываемом документе POD есть синтаксические ошибки и для стиля обработки ошибок установлено значение по умолчанию &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;b&gt;pod2man&lt;/b&gt; немедленно &lt;b&gt;прервется&lt;/b&gt; со статусом выхода 255.</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">Пока все обработанные документы приводят к некоторому выводу, даже если этот вывод содержит ошибки ( раздел &lt;code&gt;POD ERRORS&lt;/code&gt; &lt;code&gt;--errors=pod&lt;/code&gt; созданный с помощью --errors = pod ), &lt;b&gt;pod2text&lt;/b&gt; завершит работу со статусом 0. Если какой-либо из обрабатываемых документов не приведет к &lt;b&gt;ошибке&lt;/b&gt; выходной документ, &lt;b&gt;pod2text&lt;/b&gt; выйдет со статусом 1. Если есть синтаксические ошибки в обрабатываемом документе POD и стиль обработки ошибок установлен на &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; по умолчанию , &lt;b&gt;pod2text&lt;/b&gt; немедленно &lt;b&gt;прервется&lt;/b&gt; со статусом выхода 255.</target>
        </trans-unit>
        <trans-unit id="0269a38b4ec57ba243ba2782b49b270dd9c32426" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b9b379a8f2df5ad39a7bc04538ebad9bc6c049" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c56046221181f7e1bfa30bafe704cdc7899788" translate="yes" xml:space="preserve">
          <source>As long as the code inside the SKIP block at least compiles. Please don't ask how. No, it's not a filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">До тех пор,пока ссылка не будет возвращена ни одной из функций внутри модуля,ни один внешний модуль не сможет увидеть подпрограмму,так как его имени нет ни в одной из таблиц символов пакета.Помните,что это не</target>
        </trans-unit>
        <trans-unit id="9a46642b51b5bbcfbb8a5a0fab6a1a748c3835a7" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt;, and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt;, then the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">Как упоминалось &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;выше&lt;/a&gt; , эта операция вызывается, когда мутатор применяется к ссылке, которая разделяет свой объект с какой-либо другой ссылкой. Например, если &lt;code&gt;$b&lt;/code&gt; является математическим, а &lt;code&gt;'++'&lt;/code&gt; перегружено &lt;code&gt;'incr'&lt;/code&gt; , а &lt;code&gt;'='&lt;/code&gt; перегружено &lt;code&gt;'clone'&lt;/code&gt; , тогда код</target>
        </trans-unit>
        <trans-unit id="4a4d04edd6d111dfba357a91be03d0f8c653a2d2" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;&quot;ALIASES&quot;&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">Как упоминалось выше в разделе &lt;a href=&quot;#ALIASES&quot;&gt;АЛИАСЫ&lt;/a&gt; , Unicode 6.1 определяет дополнительные имена (синонимы или псевдонимы) для некоторых кодовых точек, большинство из которых уже были доступны как расширения Perl. Все это принимается &lt;code&gt;\N{...}&lt;/code&gt; и другими функциями в этом модуле, но через &lt;code&gt;viacode&lt;/code&gt; должен выбрать, какое имя возвращать для данной точки кода ввода, поэтому оно возвращает &amp;laquo;лучшее&amp;raquo; имя. Чтобы понять, как это работает, полезно узнать больше о свойствах имени Unicode. Все кодовые точки фактически имеют только одно имя, которое (начиная с Unicode 2.0) никогда не может измениться после того, как символ был назначен кодовой точке. Но были допущены ошибки при присвоении имен, например, иногда во время публикации Стандарта делалась техническая ошибка, из-за которой слова были написаны с ошибками, и не было возможности исправить их. Свойство Name_Alias ​​было в конечном итоге создано для обработки таких ситуаций. Если имя было неправильным, для него будет опубликован исправленный синоним с использованием Name_Alias. &lt;code&gt;viacode&lt;/code&gt; вернет этот исправленный синоним как &amp;laquo;лучшее&amp;raquo; имя для кодовой точки. (Возможно даже, хотя этого еще не произошло, что сама поправка должна быть исправлена, и поэтому для этой кодовой точки может быть создан другой Name_Alias; &lt;code&gt;viacode&lt;/code&gt; вернет самое последнее исправление.)</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">Как упоминалось выше, UTF-8 использует переменное количество байтов для хранения символа. Символы со значениями 0 ... 127 хранятся в одном байте, как и старый добрый ASCII. 128-й символ сохраняется как &lt;code&gt;v194.128&lt;/code&gt; ; это продолжается до символа 191, то есть &lt;code&gt;v194.191&lt;/code&gt; . Теперь у нас закончились биты (191 - это двоичное &lt;code&gt;10111111&lt;/code&gt; ), поэтому мы идем дальше; символ 192 - &lt;code&gt;v195.128&lt;/code&gt; . И так далее, перейдя к трем байтам &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;в символе&lt;/a&gt; 2048. Unicode Encodings в perlunicode показывает , как это работает.</target>
        </trans-unit>
        <trans-unit id="6394bb5241172d16852f3bd3688b62b5907e9510" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt;; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt;. Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt;) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt;. And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot; in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">Как упоминалось выше,вы можете определить контекст выполняемой в настоящее время подпрограммы на Perl с помощью параметра</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">Как упоминалось в верхней части этого документа,если у вас возникли проблемы с этими примерами расширений,вы можете увидеть,не поможет ли вам что-нибудь из этих расширений.</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">Как упоминалось ранее,Perl может хранить число в любом из трех форматов,но большинство операторов обычно понимают только один из этих форматов.Когда числовое значение передаётся в качестве аргумента такому оператору,оно преобразуется в формат,понятный оператору.</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">Как упоминалось ранее, в конструктор &lt;code&gt;TAP::Parser&lt;/code&gt; может быть добавлен &amp;laquo;обратный вызов&amp;raquo; . Если присутствует, каждый обратный вызов, соответствующий данному типу результата, будет вызываться с результатом в качестве аргумента, если &lt;code&gt;run&lt;/code&gt; метод run . Ожидается, что обратный вызов будет ссылкой на подпрограмму (или анонимной подпрограммой), которая вызывается с результатом синтаксического анализа в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">Как упоминалось ранее, в случае механизмов по умолчанию &lt;code&gt;pprivate&lt;/code&gt; будет указателем на структуру regexp_internal, которая содержит скомпилированную программу и любые дополнительные данные, которые являются частными для реализации механизма регулярных выражений.</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">Как упоминалось в &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; , кодировки (по крайней мере, в текущей реализации) определены как объекты. Сопоставление имени кодировки с объектом осуществляется с помощью хэша &lt;code&gt;%Encode::Encoding&lt;/code&gt; . Хотя вы можете напрямую управлять этим хешем, настоятельно рекомендуется использовать этот модуль базового класса и добавлять методы encode () и decode ().</target>
        </trans-unit>
        <trans-unit id="4b732b611600d48e618ee4980714b28a0f9ad12e" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">Как упоминалось в предыдущем пункте,это до сих пор не работает при использовании сокетного ввода/вывода между Unix и Macintosh.В таком случае,вам нужно будет жестко закодировать свои терминаторы строки.</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">Как упоминалось ранее,в настоящее время динамическая загрузка недоступна и отсутствует MakeMaker.Оба элемента являются высокоприоритетными.</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">Как упоминалось, функция возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если имя кодовой точки неизвестно. В Юникоде их собственное имя - пустая строка, в которую &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (Если вы запросите кодовую точку за допустимым максимумом Unicode U + 10FFFF, которому вы не назначили псевдоним, вы получите &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; плюс предупреждение.)</target>
        </trans-unit>
        <trans-unit id="3d4ae46619b16556205991103a3ee51a24d3e1e6" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;undef&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;undef&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;undef&lt;/code&gt; plus a warning.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">Поскольку большая часть оставшегося ожидаемого выхода на поток ошибок будет создан &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; &amp;laquo;s &lt;code&gt;diag&lt;/code&gt; функции &lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Тестер&lt;/a&gt; обеспечивает функцию удобства &lt;code&gt;test_diag&lt;/code&gt; , которые вы можете использовать вместо &lt;code&gt;test_err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77c366c0e7fb4976a90caf137a45b2b3674180a3" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e01de119b6c27502755389f5ecb232b0f5fe3f3" translate="yes" xml:space="preserve">
          <source>As much as possible, the version.pm module remains compatible with all current code. However, if your module is using a module that has defined &lt;code&gt;$VERSION&lt;/code&gt; using the version class, there are a couple of things to be aware of. For purposes of discussion, we will assume that we have the following module installed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">Как было отмечено выше,если файл еще не существует,то открытый режим append-mode создаст его для вас.Но если файл уже существует,его содержимое не причинит вреда,так как вы будете добавлять новый текст после окончания старого.</target>
        </trans-unit>
        <trans-unit id="a7e52b3ee94a5bcfcbfa100ffa60b7bfdd3a2e7b" translate="yes" xml:space="preserve">
          <source>As noted above, the &lt;code&gt;mark&lt;/code&gt; variable itself will point at the most recently pushed value on the value stack before the list begins, and so the list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;. The values of the list may be iterated by code such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9988c3a40e007efc46894bc022da2f7d4a303e25" translate="yes" xml:space="preserve">
          <source>As noted above, xV references on the main value stack do not contribute to the reference count of an xV, and so another mechanism is used to track when temporary values which live on the stack must be released. This is the job of the temporaries stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">Как отмечалось ранее в этом документе,скалярное значение задания списка-это количество элементов справа от задания.Нулевой список не содержит элементов,поэтому,когда файл паролей исчерпан,результат равен 0,а не 2.</target>
        </trans-unit>
        <trans-unit id="3e5e8b8f30fce2b639027bd3be7728c79d978675" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;use locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">Как отмечено в &lt;a href=&quot;#USING-LOCALES&quot;&gt;ИСПОЛЬЗОВАНИИ ЛОКАЛОВ&lt;/a&gt; , &lt;code&gt;cmp&lt;/code&gt; сравнивает в соответствии с текущим языковым стандартом сопоставления, когда &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , но возвращается к сравнению символов по символам для строк, которые, согласно языку, равны. Вы можете использовать &lt;code&gt;POSIX::strcoll()&lt;/code&gt; если вам не нужен этот откат:</target>
        </trans-unit>
        <trans-unit id="39a23dc03cf7dc5e3d6e19189da7b65ab7a30cf2" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;&quot;TESTING&quot; in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">Как отмечалось в &lt;a href=&quot;perlhack#TESTING&quot;&gt;разделе ТЕСТИРОВАНИЕ в perlhack&lt;/a&gt; , при написании тестовых скриптов файл</target>
        </trans-unit>
        <trans-unit id="1655e6b218596b71d5606712f426706cfda24e83" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">Начиная с версии 1.37_02 install () поддерживает использование списка шаблонов для фильтрации файлов, которые не следует устанавливать. Если $ skip опущен или не определен, то программа установки попытается прочитать список из INSTALL.SKIP в CWD. Этот файл представляет собой список регулярных выражений и похож на файл MANIFEST.SKIP, используемый &lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">Начиная с 3.10,внутренние данные для всех типов кодов могут быть изменены.</target>
        </trans-unit>
        <trans-unit id="4f51af2e950bc010c45298268ec1c3013383b233" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">Начиная с версии 5.14, ни один из них не вызывает исключения, если они не поддерживаются на вашей платформе. Однако, если предупреждения включены, предупреждение класса предупреждений &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; выдается при неподдерживаемом флаге преобразования. Если вы предпочитаете исключение, сделайте следующее:</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">Начиная с версии 5.14, ни один из них не вызывает исключения, если они не поддерживаются на вашей платформе. Однако, если предупреждения включены, предупреждение класса предупреждений &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; выдается при неподдерживаемом флаге преобразования. Если вы предпочитаете исключение, сделайте следующее:</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">Начиная с 5.14,это также может быть написано таким образом:</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">Начиная с 5.19.9 установка &lt;code&gt;$/&lt;/code&gt; для любой другой формы ссылки вызовет фатальное исключение. Это подготовка к поддержке новых способов установки &lt;code&gt;$/&lt;/code&gt; в будущем.</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">Начиная с версии 5.8.1,длинные двойники работают,если вы используете компиляторы Sun (необходимые для дополнительных математических процедур,не включенных в libm).</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">Начиная с версии 5.8.1, за &lt;b&gt;-C&lt;/b&gt; может следовать номер или список букв опций. Буквы, их числовые значения и эффекты следующие: перечисление букв равносильно суммированию чисел.</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">Начиная с 5.9.5, директива &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; и ее эквиваленты имеют лексическую область видимости, как и другие директивы. Однако они имеют эффекты как во время компиляции, так и во время выполнения.</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">Начиная с 5.9.5, директива &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; и ее эквиваленты имеют лексическую область видимости, как и другие директивы. Однако они имеют эффекты как во время компиляции, так и во время выполнения.</target>
        </trans-unit>
        <trans-unit id="88f554d7cda5067d9baf3d30fcba8c29b1dbb104" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6609b05c1701ded1ef1eec29d7bb5f4a5b93b02d" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">Начиная с &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; также может быть ссылкой на код, которая принимает порядковое значение неотображенного символа в качестве аргумента и возвращает октеты, представляющие резервный символ. Например:</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">Начиная с версии &lt;code&gt;Encode&lt;/code&gt; 2.21, поэтому добавлен новый метод &lt;code&gt;mime_name()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">Начиная с CPAN 1.9463, если у вас нет разрешения на запись в каталоги библиотеки Perl по умолчанию, процесс настройки CPAN спросит вас, хотите ли вы загрузить &amp;lt;local :: lib&amp;gt;, что упрощает сохранение каталога личной библиотеки Perl.</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">Начиная с кодировки 1.87,старая форма</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">По состоянию на июль 2002 года (выпуск Perl 5.8.0) следующие платформы могли собирать Perl из стандартного дистрибутива исходного кода, доступного на &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">Начиная с Perl 5.10, можно использовать переменные &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; . Они устанавливаются, только если присутствует модификатор &lt;code&gt;/p&lt;/code&gt; . Следовательно, они не наказывают остальную часть программы. В Perl 5.20 &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; и &lt;code&gt;${^POSTMATCH}&lt;/code&gt; доступны вне зависимости от того, использовался ли &lt;code&gt;/p&lt;/code&gt; (модификатор игнорируется), а &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; и &lt;code&gt;$&amp;amp;&lt;/code&gt; нет вызвать разницу в скорости.</target>
        </trans-unit>
        <trans-unit id="e79e99fb499b4f259d0eaa53033cd09b0a52555d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">Начиная с Perl 5.10, эта прагма имеет лексическую область видимости и вступает в силу во время компиляции. В более ранних версиях его эффект был глобальным и действовал во время выполнения; в документации предлагается использовать &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; для изменения поведения:</target>
        </trans-unit>
        <trans-unit id="331b4594e4263cc88f44953b4d0b8305968e3f99" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;eval()&lt;/code&gt; to change the behaviour:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">Начиная с Perl 5.10, вы можете сопоставлять сбалансированный текст с регулярными выражениями, используя рекурсивные шаблоны. До Perl 5.10 вам приходилось прибегать к различным уловкам, таким как использование кода Perl в &lt;code&gt;(??{})&lt;/code&gt; последовательностях.</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">Начиная с версии Perl 5.10.0,Perl поддерживает несколько специфических для Python/PCRE расширений синтаксиса регекса.Хотя Perl-программистам рекомендуется использовать специфический для Perl синтаксис,принимаются также и следующие:</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">Начиная с Perl 5.10.0, как форма чисто синтаксического сахара, вы можете складывать операторы проверки файлов таким образом, что &lt;code&gt;-f -w -x $file&lt;/code&gt; эквивалентно &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (Это всего лишь причудливый синтаксис: если вы используете возвращаемое значение &lt;code&gt;-f $file&lt;/code&gt; в качестве аргумента для другого оператора filetest, особого волшебства не произойдет.)</target>
        </trans-unit>
        <trans-unit id="03db908cbb1531eee3e0f01a16bb3f1d5ad12f15" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt;. (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">Начиная с Perl 5.10.0, можно создавать собственные механизмы регулярных выражений. Это не для слабонервных, так как они должны подключаться на уровне C. См. &lt;a href=&quot;perlreapi&quot;&gt;Perlreapi&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">Начиная с Perl 5.10.0, вы также можете использовать модификаторы &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;&lt;/code&gt; для принудительного порядка байтов с прямым или обратным порядком байтов. Это полезно, например, если вы хотите хранить целые числа со знаком или 64-битные целые числа.</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">Начиная с версии Perl 5.10.1 появился новый интерфейс для подключения и использования ордеров на разрешение методов,отличных от стандартных (линейный поиск глубины сначала).Приказ на разрешение метода C3,добавленный в версии 5.10.0,был заново реализован в виде плагина,без изменения его интерфейса Perl-space.</target>
        </trans-unit>
        <trans-unit id="ec3d8a5f4531571b478743636520cd49e4ac13cb" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either a &lt;code&gt;readdir&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;readdir&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.12 вы можете использовать голую &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.12 вы можете использовать голую &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">Начиная с версии Perl 5.12,устаревшие функции и модули предупреждают пользователя об их использовании.Когда модуль устарел,он также будет доступен в CPAN.Установка его из CPAN заставит замолчать предупреждения об устаревшем модуле.</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">Начиная с версии Perl 5.18 каждый хэш имеет свой собственный порядок прохождения хэша,и этот порядок меняется каждый раз,когда в хэш вставляется новый элемент.Эта функциональность обеспечивается поддержанием беззнаковой целочисленной маски (U32),которая является xor'ed с фактическим идентификатором хэша во время обхода хэш-букетов с помощью keys(),values()или each().</target>
        </trans-unit>
        <trans-unit id="52e65492e2356da13376652cd3b63537c008c53e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either an &lt;code&gt;each&lt;/code&gt; expression or an explicit assignment of an &lt;code&gt;each&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.18 вы можете использовать обнажить &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">На Perl 5.18 вы можете использовать обнажить &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; в &lt;code&gt;while&lt;/code&gt; петля, которая будет устанавливать &lt;code&gt;$_&lt;/code&gt; на каждой итерации.</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">Начиная с Perl 5.20, вместо &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;используйте&lt;/a&gt; FATAL =&amp;gt; 'all'; ты можешь использовать:</target>
        </trans-unit>
        <trans-unit id="9ee11b59ca6b84291fdd57fa90c4a5348d5dae02" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">Начиная с Perl 5.22, существует экспериментальный вариант этого цикла, который принимает переменную, которой предшествует обратная косая черта для VAR, и в этом случае элементы в LIST должны быть ссылками. Переменная с обратной косой чертой станет псевдонимом для каждого элемента, на который имеется ссылка, в СПИСКЕ, который должен иметь правильный тип. В этом случае переменная не обязательно должна быть скаляром, а за обратной косой чертой может следовать &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . Чтобы использовать эту форму, вы должны включить функцию &lt;code&gt;refaliasing&lt;/code&gt; помощью &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; . (См &lt;a href=&quot;feature&quot;&gt;функции&lt;/a&gt; См. Также &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Присвоение Ссылки в perlref&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="4cc3a1608477d241ae1d9f45daf77429c175f625" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;my&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;use feature&lt;/code&gt;. (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">Начиная с версии Perl 5.22,эта ошибка,хотя и сохранена для обратной совместимости,обнаруживается и выдает предупреждение об утечке.Если вы хотите,чтобы подпрограмма была вложена (без предупреждения),убедитесь,что переменная не используется в контексте,в котором она может быть изменена,кроме того места,где она объявлена.</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">Начиная с Perl 5.22, вы также можете использовать &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; вместо &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (Вы также можете сделать &lt;code&gt;($x) x 2&lt;/code&gt; , что менее полезно, потому что оно дважды присваивает одну и ту же переменную, затирая первое назначенное значение.)</target>
        </trans-unit>
        <trans-unit id="adc72631156437f156fe787062790a9076462201" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(undef)x2&lt;/code&gt; instead of &lt;code&gt;undef, undef&lt;/code&gt;. (You can also do &lt;code&gt;($x) x 2&lt;/code&gt;, which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485dbe5ed6cb5d47f12b9abb8eb25ef72fc078a7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.24, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::postderef&lt;/code&gt; warning category still exists (for compatibility with code that disables it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="795c67df489058534540e8b295b838da24c8850d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.25 the return was changed to be the count of keys in the hash. If you need access to the old behavior you can use &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4dc26e9cc8e6190d88b95c93b52fd5320659be" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, the list-context range operator on strings works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: its behavior depends on the internal encoding of the range endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8155f16a3b816f25d3b7bda9eaf9e783e3bae93" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::lexical_subs&lt;/code&gt; warning category still exists (for compatibility with code that disables it). In addition, this syntax is not only no longer experimental, but it is enabled for all Perl code, regardless of what feature declarations are in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644c2bcdf8b193d872fddb3b64677c202b8cacc1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26.0, this module has no effect. The internal Perl feature that was used to implement this module has been removed. In recent years, much work has been done on the Perl core to eliminate discrepancies in the treatment of upgraded versus downgraded strings. In addition, the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which caused many of the problems, is no longer supported. Thus, the warnings this module produced are no longer necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1154c7dc017ae8cf6bc262f38694d16778c8f10" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, setting &lt;code&gt;$/&lt;/code&gt; to a reference of a non-positive integer throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097112fced1ea44933320d3c2e627da3a57d8e96" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, these attributes are syntax errors. Since the attributes do not do anything, removing them from your code fixes the syntax error; and removing them will not influence the behaviour of your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4698cfe65801c463a3e671c9cf65833d68ff49ae" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, this special-cased whitespace splitting works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: characters that are whitespace according to Unicode rules but not according to ASCII rules can be treated as part of fields rather than as field separators, depending on the string's internal encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df44a28f7cb4ce868d57f8dd07bcda2680ebf3e0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.30, use of delimiters which are non-standalone graphemes is fatal, in order to move the language to be able to accept multi-character graphemes as delimiters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcb750cd92914748543d04c418a1857ae25be47" translate="yes" xml:space="preserve">
          <source>As of Perl 5.32, this message is no longer generated. Instead, see &lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;&quot;Non-octal character '%c' terminates \o early. Resolved as &quot;%s&quot;&quot;&lt;/a&gt;. (W misc, regexp) You wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. All but the last digit is treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">Начиная с версии Perl 5.6,вы можете представлять файловые хэндлы со скалярными переменными,которые вы рассматриваете как любой другой скаляр.</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">Начиная с Perl 5.8.0, после использования этого модуля вы не можете использовать неявный &lt;code&gt;$_&lt;/code&gt; или специальный дескриптор файла &lt;code&gt;_&lt;/code&gt; с stat () или lstat (), попытка сделать это приводит к странным ошибкам. Обходной путь - явное указание &lt;code&gt;$_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="115a406a7271cc4332af7b8bb93f168d625583f1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, at least the following encodings are recognized. Note that unless otherwise specified, they are all case insensitive (via alias) and all occurrence of spaces are replaced with '-'. In other words, &quot;ISO 8859 1&quot; and &quot;iso-8859-1&quot; are identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">Начиная с версии Perl 5.8.0,&quot;Полное&quot; складывание дела из</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">Начиная с Perl 5.8.0, вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; с несколькими аргументами. Как и в случае со списками &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; , экранирования оболочки не происходит.</target>
        </trans-unit>
        <trans-unit id="df8794a0813798e6a0cf5a13a0dc7223a79a0992" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;open()&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;system()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;, no shell escapes happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">Начиная с версии Perl 5.8.1,динамическая загрузка библиотек (DynaLoader,XSLoader),похоже,также прервалась в SunOS 4.x.Поэтому по умолчанию Perl собирается статически.</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">Начиная с Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; также имеет функцию &lt;code&gt;utf8::is_utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">Начиная с версии Perl 5.9.5 появился новый интерфейс для подключения и использования движков регулярных выражений,отличных от тех,что используются по умолчанию.</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">Начиная с версии 0.4.1 для порта Perl Symbian,любая часть стандартного набора регрессионных тестов Perl не была запущена на реальном устройстве Symbian с использованием перенесенного Perl,поэтому бесчисленные ошибки могут лежать в ожидании.Поэтому нет абсолютно никакой гарантии.</target>
        </trans-unit>
        <trans-unit id="470b823d90414a4ffaec0c54908966f5bb0b6779" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">Начиная с Perl v5.16.0, это реализовано модулем &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; . Подробнее о его поведении см. В &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cf84017310ef88efe853e952dd2c6c52ce61386" translate="yes" xml:space="preserve">
          <source>As of Perl v5.30.0, or under &lt;code&gt;use v5.16&lt;/code&gt;, or &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt;, &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">Начиная с версии R2.5 USS для OS / 390 и версии 2.3 VM / ESA, эти подсистемы Unix не поддерживают &lt;code&gt;#!&lt;/code&gt; трюк shebang для вызова скрипта. Следовательно, в OS / 390 и VM / ESA Perl-скрипты могут выполняться с заголовком, подобным следующему простому скрипту:</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">Начиная с Юникода 6.0,он всегда пуст.</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">Начиная с версии 1.18 все объекты IO::Socket по умолчанию имеют включенную автопромывку.В предыдущих релизах этого не было.</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">Начиная с db-4.2.x,больше нет необходимости делать это вручную.Sleepycat изменил процесс конфигурирования на автоматическое добавление +z на HP-UX.</target>
        </trans-unit>
        <trans-unit id="d75d887c21a8a54a73e586867619f60f35cac751" translate="yes" xml:space="preserve">
          <source>As of libcrypt 1.3 (March 2016), you will need to install the libcrypt-devel package for Configure to detect crypt().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">Начиная с Perl 5.14, можно подключиться к механизму лексической области во время компиляции, используя &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . Это используется так:</target>
        </trans-unit>
        <trans-unit id="ad95286c36cd410295b8a2ce1cb7201a227c4aba" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt;. This is used like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e27b1acb1512cd132ffd47cefd52584149d78c" translate="yes" xml:space="preserve">
          <source>As of perl 5.25 this function is used only for debugging purposes, and the number of used hash buckets is not in any way cached, thus this function can be costly to execute as it must iterate over all the buckets in the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">Начиная с версии 5.9.5 're' отладка содержит ряд функций утилиты,которые могут быть опционально экспортированы в пространство имен вызывающего абонента.Они перечислены ниже.</target>
        </trans-unit>
        <trans-unit id="e452fc188847c39d477f7724ca763c55646692fe" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5/Win32 0.27, these functions have been moved into the Win32 module. Win32CORE provides stubs for each of the former CORE Win32:: functions that internally just load the Win32 module and call it's version, and Win32CORE is statically linked to perl for both cygwin and regular win32 builds. This will permit these functions to be updated in the CPAN Win32 module independently of updating perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">Начиная с версии perl5.6,open()autovivifies file and directory handleles as references if you pass it an uninitialized scalar variable.Затем вы можете передать эти ссылки так же,как и любой другой скаляр,и использовать их вместо именованных дескрипторов.</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">Согласно пункту 5.7.2 все тесты проходят в соответствии с требованиями:</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">По состоянию на 5.8.1 есть,по крайней мере,один тест,который все еще не прошел.</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">Начиная с версии Perl 5, присвоение &lt;code&gt;$[&lt;/code&gt; рассматривается как директива компилятора и не может влиять на поведение любого другого файла. (Вот почему вы можете назначать ему только константы времени компиляции.) Его использование крайне не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">С версии 5.003_01 perl связана с многопоточной C RTL DLL.Если сам perl не скомпилирован с поддержкой многопоточности,то не будет использоваться malloc()perl.Тем не менее,расширения могут использовать многопоточную библиотеку на свой страх и риск.</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">На данный момент возвращается 2,если путь абсолютный с громкостью,1,если абсолютный без громкости,0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">На дату последнего обновления настоящего документа следующие системы содержат чипы PA-RISC 2.0:</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">На момент написания данного документа Perl полностью 64-битный на HP-UX 11.00 и подходит как для сборки cc-,так и для gcc.Если вы собираетесь собирать 64-битный Perl с помощью GNU gcc,пожалуйста,внимательно прочитайте раздел gcc.</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">На момент последней редакции данного документа в порту VMS на Perl были реализованы следующие Perl-функции (функции,помеченные *,более подробно рассматриваются ниже):</target>
        </trans-unit>
        <trans-unit id="4d788164927e274de517225973608d97db84fe9f" translate="yes" xml:space="preserve">
          <source>As of this writing, any encoding whose class belongs to Encode::XS and Encode::Unicode works. The Encode module has a &lt;code&gt;perlio_ok&lt;/code&gt; method which you can use before applying PerlIO encoding to the filehandle. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">Начиная с версии 5.14,Perl выделяет три подкласса предупреждений UTF-8.</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">Начиная с версии 5.18.0, ключи и значения, хранящиеся в &lt;code&gt;%ENV&lt;/code&gt; , преобразованы в строки .</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">Начиная с версии 1.01 модуля AutoSplit возможно иметь несколько пакетов в одном файле.Поддерживаются оба следующих случая:</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">Начиная с версии 1.02 (поставляется с perl 5.12) объект обеспечивает перегрузку &lt;code&gt;&quot;-X&quot;&lt;/code&gt; , поэтому вы можете вызывать на нем операторы проверки файлов ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; и т. Д.). Он также предоставляет метод &lt;code&gt;-&amp;gt;cando&lt;/code&gt; , называемый как</target>
        </trans-unit>
        <trans-unit id="3f4a112eabf93bbafc4bcc9a1025d0ef06b216ad" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">Начиная с версии 1.04 (Perl 5.10),строгая проверка используется как &quot;строгая&quot;,чтобы избежать страшной строгой ловушки на нечувствительных к регистру файловых системах.</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">Начиная с версии 1.32 данного модуля,константы могут быть определены в пакетах,отличных от вызывающего,путем включения имени пакета в имя константы:</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">Начиная с версии 1.47,были внесены следующие дополнения в установочный интерфейс.Обратите внимание,что рекомендуется новый стиль аргументов и использование хэша %result.</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">Начиная с версии 2.12, &lt;code&gt;Encode&lt;/code&gt; поддерживает значения coderef для &lt;code&gt;CHECK&lt;/code&gt; ; увидеть ниже.</target>
        </trans-unit>
        <trans-unit id="ffc6a36f7c22fafbcd2974930b9d682b59ed0fd0" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt;; see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">Начиная с версии 2.32 Getopt::Long предоставляет автопомощь,быстрый и простой способ добавить опции --help и -? в вашу программу,и обрабатывать их.</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">Начиная с версии 5.00305,бинарный дистрибутив OS/2 perl разделен на 11 компонентов.К сожалению,чтобы включить настраиваемую двоичную установку,пути к файлам в zip-файлах не абсолютные,а относительные к некоторому каталогу.</target>
        </trans-unit>
        <trans-unit id="0a03b6b4ddea7ad90c28bf2de5b6b3532c441bd5" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the time implementation of the operating system it's running on. Instead, it has its own implementation of those routines with a safe range of at least +/- 2**52 (about 142 million years)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">Начиная с версии 5.12.0,perl перестал использовать базовую библиотеку времени операционной системы,на которой он работает,и имеет свою собственную реализацию этих процедур с безопасным диапазоном не менее +/2**52 (около 142 миллионов лет).</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">На момент написания статьи (2010-09)только</target>
        </trans-unit>
        <trans-unit id="9bba94e9dfeb863cebb5f1b8b07f6bae30ef1d7d" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;atoi(3)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtol(3)&lt;/a&gt;, &lt;code&gt;grok_atoUV&lt;/code&gt; does NOT allow optional leading whitespace, nor negative inputs. If such features are required, the calling code needs to explicitly implement those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">Согласно строке &lt;a href=&quot;functions/readline&quot;&gt;чтения&lt;/a&gt; , в скалярном контексте она должна возвращать следующую строку или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , чтобы больше данных не было. В контексте списка он должен возвращать все оставшиеся строки или пустой список, если больше нет данных. Возвращаемые строки должны включать разделитель входных записей &lt;code&gt;$/&lt;/code&gt; (см. &lt;a href=&quot;perlvar&quot;&gt;Perlvar&lt;/a&gt; ), если он не является &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (что означает режим &quot;slurp&quot;).</target>
        </trans-unit>
        <trans-unit id="008a0000ee5b61a83c14df2cf7cee7f4e080298a" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;perlfunc#readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;undef&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;undef&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">В соответствии с функцией get(),но возвращает привязанную файловую ручку.Чтение из этой файловой папки возвращает запрошенное сообщение.Ручка файлов возвращает EOF в конце сообщения и не должна использоваться повторно.</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">Поскольку perl не использует его,он плохо протестирован.</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">Поскольку прагматы реализованы в виде модулей, как и любой другой модуль, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; становится</target>
        </trans-unit>
        <trans-unit id="95ffc5a9c7d9d21832644aa0005e8ab6e5d3fda8" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;use myint;&lt;/code&gt; becomes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">Как упоминалось ранее, функция &amp;laquo;переключения&amp;raquo; считается в высшей степени экспериментальной; он может быть изменен без предварительного уведомления. В частности, &lt;code&gt;when&lt;/code&gt; имеет сложное поведение, которое, как ожидается, изменится, чтобы стать менее сложным в будущем. Не полагайтесь на его текущую (неправильную) реализацию. До Perl 5.18 у &lt;code&gt;given&lt;/code&gt; также было сложное поведение, которого вы все равно должны остерегаться, если ваш код должен работать на более старых версиях Perl.</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">Как уже отмечалось ранее,отдельные записи (в отличие от хэша целиком)являются настраиваемыми.Perl заботится только о булевом истине здесь,хотя значения,используемые для</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">В качестве примера установки рассмотрим этот (хотя и довольно надуманный)пример привязки;все,что он делает,это использует файл для ведения журнала значений,назначенных скаляру.</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">В поставке единственная история командной строки-это упрощенная история,которая проверяет наличие ведущих восклицательных знаков.Однако,если вы установите модули Term::ReadKey и Term::ReadLine из CPAN (такие как Term::ReadLine::Gnu,Term::ReadLine::Perl,....),у вас будут полные возможности редактирования,подобные тем,что GNU</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">Как показано выше,Perl создает файл резервной копии,независимо от того,был ли на самом деле изменен выходной файл.Таким образом,это просто причудливый способ копирования файлов:</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">Как показано в этом примере, на &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; не действует правило &amp;laquo;выглядит как функция&amp;raquo;. Пара скобок, следующая за ним, не (обязательно) ограничивает аргумент. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Кроме того, в отличие от большинства именованных операторов, это имеет тот же приоритет, что и присваивание.</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">Как показано в этом примере, на &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; не действует правило &amp;laquo;выглядит как функция&amp;raquo;. Пара скобок, следующая за ним, не (обязательно) ограничивает аргумент. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; эквивалентно &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Кроме того, в отличие от большинства именованных операторов, это имеет тот же приоритет, что и присваивание.</target>
        </trans-unit>
        <trans-unit id="69217332278a487735b9f765568e5e6b60cb13f1" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;goto EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; is equivalent to &lt;code&gt;goto NEXT&lt;/code&gt;. Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc78a790919531fd0718a68912f96b73236dccd" translate="yes" xml:space="preserve">
          <source>As some variables are reported by a different name in the output of &lt;code&gt;perl -V&lt;/code&gt; than their actual name in &lt;code&gt;%Config&lt;/code&gt;, I decided to leave the &lt;code&gt;config&lt;/code&gt; entry as close to reality as possible, and put in the entries that might have been guessed by the printed output in a separate block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a035147de7a604eb6e8f9633c18d50b5e19c9b" translate="yes" xml:space="preserve">
          <source>As soon as one of my failing tests passes it will be removed from the list of failed tests. Eventually I fix them all and prove can find no failing tests to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81930da4a8c9e7cfd6af4afe44478552245004db" translate="yes" xml:space="preserve">
          <source>As such, consumers may use this data for informational analysis, but presenting it to the user as canonical or relying on it as such is invariably the height of folly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">Таким образом, сигналы, которые обычно не подходят для использования в команде &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; (например, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ), можно использовать с методом &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; (опять же, как показано выше) .</target>
        </trans-unit>
        <trans-unit id="2afd2bab6cbdd50c9685439c6b9fc8e46337a3ed" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;kill()&lt;/code&gt; command (e.g., &lt;code&gt;kill('KILL', $$)&lt;/code&gt;) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24bd5acc92d8894261d7ef9b04b6f856fb374ce1" translate="yes" xml:space="preserve">
          <source>As such, you open a pipe using the same &lt;code&gt;open&lt;/code&gt; call that you use for opening files, setting the second (&lt;code&gt;MODE&lt;/code&gt;) argument to special characters that indicate either an input or an output pipe. Use &lt;code&gt;&quot;-|&quot;&lt;/code&gt; for a filehandle that will let your Perl program read data from an external program, and &lt;code&gt;&quot;|-&quot;&lt;/code&gt; for a filehandle that will send data to that program instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">Так как системные библиотеки (прежде всего glibc)также являются триггерами ошибок,valgrind позволяет подавлять такие ошибки с помощью файлов подавления.Файл подавления по умолчанию,который поставляется с valgrind,уже ловит многие из них.Некоторые дополнительные подавления определены в</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">Так как это несколько выражений на языке C,то они довольно распространены,поэтому вместо этого посмотрите на эту идиому:</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">Поскольку ловушка &lt;code&gt;'IGNORE'&lt;/code&gt; не поддерживается &lt;code&gt;__WARN__&lt;/code&gt; , вы можете отключить предупреждения с помощью пустой подпрограммы:</target>
        </trans-unit>
        <trans-unit id="d759f2151ab12005046fd0fb7fc374d93cc7fcaa" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt;, its effect is the same as using &lt;code&gt;'DEFAULT'&lt;/code&gt;. You can disable warnings using the empty subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">Так как интерпретатор Perl смотрит на сигнальные флаги только тогда,когда собирается выполнить новый опкод,сигнал,который поступает во время долгого опкода (например,операция регулярного выражения на очень большой строке),не будет виден до тех пор,пока текущий опкод не завершится.</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">Так как PerlIO слой использует исходный IO (байты)внутри,все это полностью игнорирует такие вещи,как тип вашей файловой системы (ASCII или EBCDIC).</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">Так как PerlIO слой использует исходный IO внутри,все это полностью игнорирует тип вашей файловой системы (ASCII или EBCDIC)и переменную окружения IO_CONVERSION.Если вы хотите получить старое поведение,то то то,что IO функции BS2000 определяют преобразование в зависимости от файловой системы,PerlIO все равно является вашим другом.Вы используете IO_CONVERSION как обычно и говорите Perl,что он должен использовать родной IO слой:</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">Как говорится в комментарии, это не лучший способ реализовать аксессоры. Это очень медленно и слишком умно. Однако вы можете рассматривать это как способ предоставления средств доступа в старом коде Perl. См. &lt;a href=&quot;perlootut&quot;&gt;Perlootut&lt;/a&gt; для рекомендаций по объектно- ориентированному кодированию на Perl.</target>
        </trans-unit>
        <trans-unit id="1139ca2064130f83bd2fbbeaae8eb84583cc89ac" translate="yes" xml:space="preserve">
          <source>As the example in &lt;a href=&quot;#new%28%29&quot;&gt;&quot;new()&quot;&lt;/a&gt; shows, you can always create a copy of an existing version object with the same value by the very compact:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">Как видно из примера,если второй аргумент-пустая строка,то локаль категории возвращается по умолчанию,указанному соответствующими переменными окружения.Обычно это приводит к возврату к значениям по умолчанию,которые действовали при запуске Perl:изменения в окружении,внесенные приложением после запуска,могут быть замечены или не замечены,в зависимости от библиотеки C вашей системы.</target>
        </trans-unit>
        <trans-unit id="1edaf8c27fdae81166329d8ebc45bdc56d4e0e72" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portability to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt;, &lt;code&gt;\N{U+28}&lt;/code&gt;, &lt;code&gt;\N{U+29}&lt;/code&gt;, ..., &lt;code&gt;\N{U+3D}&lt;/code&gt;, &lt;code&gt;\N{U+3E}&lt;/code&gt;, and &lt;code&gt;\N{U+3F}&lt;/code&gt;, whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">Как показывают два последних примера выше, вы можете достичь переносимости на не-ASCII-платформы, используя форму &lt;code&gt;\N{...}&lt;/code&gt; для конечных точек диапазона. Они указывают на то, что указанный диапазон должен интерпретироваться с использованием значений Unicode, поэтому &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; означает соответствие &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; и &lt;code&gt;\N{U+3F}&lt;/code&gt; , вне зависимости от версии собственного кода для них. Это диапазоны &quot;Unicode&quot;. Если любой конец имеет форму &lt;code&gt;\N{...}&lt;/code&gt; , диапазон считается Unicode. &lt;code&gt;regexp&lt;/code&gt; предупреждение возникает при &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; если другая конечная точка указана без возможности переноса:</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">В качестве последнего символа прототипа или непосредственно перед точкой с запятой, &lt;code&gt;@&lt;/code&gt; или &lt;code&gt;%&lt;/code&gt; вы можете использовать &lt;code&gt;_&lt;/code&gt; вместо &lt;code&gt;$&lt;/code&gt; : если этот аргумент не указан, вместо него будет использоваться &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd30084251e957fbd55793c63ff1e2e0b66c3d5" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt;, you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;: if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">Как показывает последний пример,обработчик может быть настроен на (повторный)вызов в две или более фаз.Имя фазы передается в качестве последнего аргумента обработчика.</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">Когда синтаксический анализатор считывает вторую и последующие строки из исходного потока, он пропускает эти строки через исходный фильтр &lt;code&gt;cpp&lt;/code&gt; перед их обработкой. &lt;code&gt;cpp&lt;/code&gt; фильтр просто проходит каждую линию через реальный C препроцессор. Выходные данные препроцессора C затем вставляются фильтром обратно в исходный поток.</target>
        </trans-unit>
        <trans-unit id="de16f72d9bd04b071a155fd420870c413322270a" translate="yes" xml:space="preserve">
          <source>As the parser sees sections like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">Поскольку синтаксический анализатор понимает программу на Perl,он строит дерево операций,которые интерпретатор должен выполнять во время выполнения.Процедуры,которые строят и связывают между собой различные операции,можно найти в следующих разделах</target>
        </trans-unit>
        <trans-unit id="720247a05069501ddebd25eded634ebdeed59cfd" translate="yes" xml:space="preserve">
          <source>As the sorting is done in the JSON::PP scope, you usually need to prepend &lt;code&gt;JSON::PP::&lt;/code&gt; to the subroutine name, and the special variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; used in the subrontine used by &lt;code&gt;sort&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">Так как существуют различные Make программы с несовместимым синтаксисом,использующие оболочки операционной системы,опять же с несовместимым синтаксисом,то пользователям этого модуля важно знать,для какого вкуса был написан Make a Makefile,поэтому они будут использовать правильный и им не придётся сталкиваться с возможными запутанными ошибками,возникающими в результате использования неправильного синтаксиса.</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">Так как существует перекрытие между номерами ошибок,используемыми для</target>
        </trans-unit>
        <trans-unit id="267c472340bc23541eca7afc953c80b9af09e6af" translate="yes" xml:space="preserve">
          <source>As this callback gets called less often then the &lt;code&gt;filter_json_object&lt;/code&gt; one, decoding speed will not usually suffer as much. Therefore, single-key objects make excellent targets to serialise Perl objects into, especially as single-key JSON objects are as close to the type-tagged value concept as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not support this in any way, so you need to make sure your data never looks like a serialised Perl hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae4c3659f41e6ea72787219e7dd135169795201" translate="yes" xml:space="preserve">
          <source>As to how you'd implement the Russian example from the beginning of the article, well, There's More Than One Way To Do It, but it could be something like this (using English words for Russian, just so you know what's going on):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1931b1f7f35afcd5d7f66942f927b9ab23c40a" translate="yes" xml:space="preserve">
          <source>As to sharing of auxiliary functions, consider the problem of Russian numbers from the beginning of this article; obviously, you'd want to write only once the hairy code that, given a numeric value, would return some specification of which case and number a given quantified noun should use. But suppose that you discover, while localizing an interface for, say, Ukranian (a Slavic language related to Russian, spoken by several million people, many of whom would be relieved to find that your Web site's or software's interface is available in their language), that the rules in Ukranian are the same as in Russian for quantification, and probably for many other grammatical functions. While there may well be no phrases in common between Russian and Ukranian, you could still choose to have the Ukranian module inherit from the Russian module, just for the sake of inheriting all the various grammatical methods. Or, probably better organizationally, you could move those functions to a module called &lt;code&gt;_E_Slavic&lt;/code&gt; or something, which Russian and Ukrainian could inherit useful functions from, but which would (presumably) provide no lexicon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">Как было сказано выше, Perl 5.6.1 все еще был хорош в AmigaOS, как и 5.7.2. После Perl 5.7.2 (изменение # 11423, см. Файл изменений и файл pod / perlhack.pod, чтобы узнать, как получить отдельные изменения) Perl отказался от своей внутренней поддержки vfork (), и, скорее всего, это был шаг, который сломал AmigaOS (поскольку в библиотеке ixemul есть только vfork). В конечном итоге сборка завершается неудачей, когда создается ext / DynaLoader, и PERL заканчивается как &amp;laquo;0&amp;raquo; в созданном Makefile, попытка запустить &amp;laquo;0&amp;raquo; не совсем работает. Кроме того, выполнение miniperl в обратных кавычках, похоже, ничего не генерирует: очень вероятно, связано с проблемами (v) fork. &lt;b&gt;Для исправления поломки нужен кто-то, хорошо знакомый с библиотекой ixemul и с тем, как следует запускать внешние команды в AmigaOS без fork ().&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">Как обычно, &lt;code&gt;PL_restartop&lt;/code&gt; извлекается из &lt;code&gt;CxEVAL&lt;/code&gt; и выполняется &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , который возвращает стек C обратно в документ:</target>
        </trans-unit>
        <trans-unit id="2a573f9f62b976f78c5ac59164a50ae13a402046" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt;, and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">Как обычно,бегите</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">Как мы видели выше,принцип 0 отменяет остальные.Регеxp будет соответствовать как можно раньше,остальные принципы определяют,как регеxp будет соответствовать на самой ранней позиции персонажа.</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">Как мы уже упоминали,встроенная система OOO Perl очень минимальна,но в то же время достаточно гибка.На протяжении многих лет многие люди разрабатывали системы,которые строились на основе встроенной системы Perl,чтобы обеспечить больше возможностей и удобства.</target>
        </trans-unit>
        <trans-unit id="4f2e51cb7fb14eb8f1de406668bded94aec1752e" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">Как мы упоминали ранее, роли предоставляют альтернативу наследованию, но Perl не имеет встроенной поддержки ролей. Если вы решите использовать Moose, он будет иметь полноценную реализацию роли. Однако, если вы используете один из других рекомендованных нами OO-модулей, вы все равно можете использовать роли с &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">Как мы уже упоминали ранее,Perl не предоставляет специального синтаксиса конструктора.Это означает,что класс должен реализовать свой собственный конструктор.Конструктор-это просто метод класса,который возвращает ссылку на новый объект.</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">Пока мы возвращаем пустой список,все в порядке.</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">Как мы уже говорили ранее,система минимального OOO Perl привела к изобилию систем OO на CPAN.Несмотря на то,что Вы все еще можете опускаться на голый металл и писать уроки от руки,на самом деле нет никаких причин делать это с современным Perl.</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Как мы сказали ранее, большинство объектов Perl являются хешами, но объект может быть экземпляром любого типа данных Perl (скаляр, массив и т. Д.). Превращение простой структуры данных в объект осуществляется путем &lt;b&gt;благословения&lt;/b&gt; этой структуры данных с помощью функции Perl &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b99a5371cd1d193aeb40f1c8ec4bf090e8b2c97" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;bless&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">Как мы видели ранее, объект - это просто структура данных, которая была добавлена ​​в класс с помощью функции &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; . Функция &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; может принимать один или два аргумента:</target>
        </trans-unit>
        <trans-unit id="86afd7b293cb09c0f55f2b3f4442d25492c71a40" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;bless&lt;/code&gt; function. The &lt;code&gt;bless&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">Как мы уже показали, &lt;code&gt;call_sv&lt;/code&gt; можно использовать для вызова анонимной подпрограммы. Однако в нашем примере показан сценарий Perl, вызывающий XSUB для выполнения этой операции. Давайте посмотрим, как это можно сделать внутри нашего кода на C:</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">Помимо доступа к БД Беркли с помощью связанного хэша или массива,можно также напрямую использовать большинство функций API,определенных в документации к БД Беркли.</target>
        </trans-unit>
        <trans-unit id="0237593efedf8b6eff88bac44019384e6b74f34f" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the array (like &lt;code&gt;av_clear()&lt;/code&gt;), this also frees the memory used by the av to store its list of scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a89b3b004de95ce93de721c0f8e3cdeec13f545" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like &lt;code&gt;hv_clear()&lt;/code&gt;), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">Помимо освобождения всех элементов хэша (например,hv_clear()),это также освобождает любые вспомогательные данные и хранилища,связанные с хэшем.</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">Круглые скобки служат не только для группировки, но и для другой цели. Их можно использовать для сбора результатов совпадений регулярных выражений для дальнейшего использования. Результаты в конечном итоге в &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="3a1788b97e5572fb886ee20a2620cc1ef5c829d9" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998a4f37f47dfa1a21fcb95591647fa7596884ba" translate="yes" xml:space="preserve">
          <source>As well as the following methods, this class inherits all the methods in &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">Как и эти двое,есть еще один преобразователь:</target>
        </trans-unit>
        <trans-unit id="79309f713ddbfafe2f6334a91eabf7f9425eca6b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; is set prior to unwinding the call stack; any &lt;code&gt;DESTROY&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; handlers can then alter this value, and thus Perl's exit code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Как и в случае с &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; псевдонимом &lt;code&gt;$_&lt;/code&gt; для перечисления элементов, &lt;code&gt;pairfirst&lt;/code&gt; псевдонимы &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; для элементов данного списка. Любые модификации этого блока кода будут видны вызывающему.</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Как и в случае с &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; псевдонимом &lt;code&gt;$_&lt;/code&gt; для перечисления элементов, &lt;code&gt;pairgrep&lt;/code&gt; присваивает псевдонимы &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; элементам данного списка. Любые модификации этого блока кода будут видны вызывающему.</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Как и в случае &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; псевдонимов &lt;code&gt;$_&lt;/code&gt; для элементов списка, &lt;code&gt;pairmap&lt;/code&gt; псевдонимов &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; для элементов данного списка. Любые модификации этого блока кода будут видны вызывающему.</target>
        </trans-unit>
        <trans-unit id="fec85543ad9986bf912be9475be1ac989c167db7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;PERL5OPT&lt;/code&gt;, a string of additional &lt;code&gt;cpan(1)&lt;/code&gt; options to add to those you specify on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc99e7ad503065bd82f24f799275058edae300da" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d482c5453c9dc11a8d1e3e4a1d4df1955e90671" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">Как и &lt;code&gt;gzerror()&lt;/code&gt; он возвращает номер ошибки в числовом контексте и сообщение об ошибке в строковом контексте. Однако, в отличие от &lt;code&gt;gzerror()&lt;/code&gt; , сообщение об ошибке будет соответствовать</target>
        </trans-unit>
        <trans-unit id="ad8ddc963c1faca12f5a1122723298a5bb8081cc" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;map&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">Как и в случае с &lt;code&gt;mro::get_linear_isa&lt;/code&gt; выше, &lt;code&gt;UNIVERSAL&lt;/code&gt; особенный. &lt;code&gt;UNIVERSAL&lt;/code&gt; (и родительские) списки isarev не включают все существующие классы, хотя все классы фактически являются потомками для целей наследования методов.</target>
        </trans-unit>
        <trans-unit id="32eae94f86fad4a1553a0eb1f5e32221b0ef149f" translate="yes" xml:space="preserve">
          <source>As with CORE::utime(), passing undef as both the atime and mtime will call the syscall with a NULL argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">Как и G_SCALAR,этот флаг имеет 2 эффекта:</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">Как и в случае с GetOptionsFromArray,первый аргумент,ссылающийся на хэш-функцию,теперь становится вторым аргументом.</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">Как и в случае со всеми директивами &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , определение константы происходит во время компиляции. Таким образом, вероятно, неправильно помещать объявление константы внутри условного оператора (например, &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5354f6304cc90aca1a4c69a0041cb7b6c7daa540" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;use&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">Как и во всех опциях бэкенда компилятора,они должны следовать непосредственно после '-MO=Deparse',разделенного запятой,но не любым белым пробелом.</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">Как и все стандартные команды,односимвольный переключатель может быть скомпонован со следующим переключателем,если таковой имеется.</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">Как и все вещи в Перле,</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">Как и в случае любой рекомендательной схемы блокировки, защита работает, только если вы систематически используете &lt;code&gt;lock_store&lt;/code&gt; и &lt;code&gt;lock_retrieve&lt;/code&gt; . Если одна сторона вашего приложения использует &lt;code&gt;store&lt;/code&gt; , а другая - &lt;code&gt;lock_retrieve&lt;/code&gt; , вы вообще не получите защиты.</target>
        </trans-unit>
        <trans-unit id="cbbf76ef92d8f729f36aea391937508d71d89ba4" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt;. If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt;, you will get no protection at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">Как и в случае с конструкторами,Perl не предоставляет специального синтаксиса объявления доступа,поэтому классы должны предоставлять явно написанные методы доступа.Существует два общих типа доступа-доступ только для чтения и чтение-запись.</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">Как и в случае со многими unix-портами,этот порт зависит от нескольких &quot;стандартных&quot; утилит unix,которые не обязательно являются стандартными для QNX4.</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">Как и в случае с обычными Perl-массивами,доступ к массиву RECNO можно получить с помощью отрицательных индексов.Индекс -1 относится к последнему элементу массива,-2-ко второму последнему и так далее.Попытка получить доступ к элементу до начала работы массива приведет к фатальной ошибке во время выполнения.</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">Как и в случае с постфиксным массивом,разыменование среза постфиксного значения</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">Как и в подпрограммном обеспечении,тип значения,возвращаемого из функции точки входа потока,может быть определен по типу значения потока</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">Как и в случае с</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">Как и в формате DB_HASH,для выполнения сравнения ключей можно предусмотреть рутину Perl,заданную пользователем.Однако по умолчанию ключи хранятся в лексическом порядке.</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Как и в режиме добавления, когда вы открываете файл в режиме только для записи, теперь вы можете писать в этот дескриптор файла, используя любой из &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d97479933fa1462fae02a9e50ede26b28a53d5f2" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166455d62d96ee30d0f7c0e9ebb9b193aa0e9037" translate="yes" xml:space="preserve">
          <source>As with the built-in &lt;code&gt;chmod()&lt;/code&gt;, &lt;code&gt;$file&lt;/code&gt; may be a filename or a file handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061a3cd33d1bd9d36627a353371c49a4d11968d" translate="yes" xml:space="preserve">
          <source>As with the mark stack to the value stack, the scope stack forms a pair with the save stack. The scope stack stores the height of the save stack at which nested scopes begin, and allows the save stack to be unwound back to that point when the scope is left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">Как и в случае с оператором match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; может использовать другие разделители, например &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; , и даже &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . Если используются одинарные кавычки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; , то регулярное выражение и замена обрабатываются как строки в одинарных кавычках и подстановки переменных отсутствуют. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; в контексте списка возвращает то же самое, что и в скалярном контексте, то есть количество совпадений.</target>
        </trans-unit>
        <trans-unit id="8a7f1aef7986985cb8cfbcb39be9e92c12b6802e" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;m//&lt;/code&gt; operator, &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;s///&lt;/code&gt; in list context returns the same thing as in scalar context,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5751273786ef031d84398bd287378b577d2ec97d" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">Как и в случае с оператором сопоставления, в цитате регулярного выражения могут использоваться разные разделители, например &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; . Апострофы как разделители ( &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ) запрещают любую интерполяцию.</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">Как и в случае с другими типами привязок, этот метод будет вызываться, когда произойдет &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; . В этом случае может быть целесообразно &amp;laquo;автоматическое закрытие&amp;raquo;. См. &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;Раздел &amp;laquo;Развязка Gotcha&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="afcbb54437173c8bdb1b71e9fdd8c918462556a8" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;untie&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">Как и в случае с другими типами связей,этот метод будет вызван,когда связанная рукоятка вот-вот будет уничтожена.Это полезно для отладки и возможной очистки.</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">Как и в случае со стеком возвратов,можно было бы (и небольшой выигрыш в производительности)предварительно расширить массив возвратов,прежде чем вставлять в него данные,так как мы знаем,сколько элементов мы вернем:</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">Как и в случае с оболочкой, в Perl символ &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; используется для открытия файла в режиме только для чтения. Если это удается, Perl выделяет для вас новый дескриптор файла и заполняет ранее неопределенный аргумент &lt;code&gt;$handle&lt;/code&gt; ссылкой на этот дескриптор.</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">Как видите, 3 записи были успешно созданы с помощью key &lt;code&gt;Wall&lt;/code&gt; - единственное, что когда они извлекаются из базы данных, они</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">Как видите, оба модуля имеют в целом похожую структуру. Оба они используют модуль &lt;code&gt;Filter::Util::Call&lt;/code&gt; и оба имеют метод &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; . Разница между ними в том, что</target>
        </trans-unit>
        <trans-unit id="6c90ba06fa5e1fe7496f3d2e8756e36b17de7ff3" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;import&lt;/code&gt; method. The difference between them is that the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">Как вы можете видеть в резюме,на основе вашего шаблона,предоставленные аргументы будут проверены.</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">Как видите,</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">Как вы можете видеть, новый поток был создан для чтения источника от &lt;code&gt;Fred.pm&lt;/code&gt; . Этот поток будет оставаться активным до тех пор, &lt;code&gt;Fred.pm&lt;/code&gt; не будет проанализирован весь Fred.pm. Исходный поток для &lt;code&gt;cpp_test&lt;/code&gt; все еще существует, но неактивен. Как только синтаксический анализатор закончит читать Fred.pm, связанный с ним исходный поток будет уничтожен. Исходный поток для &lt;code&gt;cpp_test&lt;/code&gt; затем снова становится активным, и анализатор читает строку 4 и последующие строки из &lt;code&gt;cpp_test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d30857f7aa9b41378f7136a05fa07d62994d4300" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt;. This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25de0c5886c2da663b8272fdb54e70c4ca6e8f92" translate="yes" xml:space="preserve">
          <source>As you can see, either a bare number or a quoted string can usually be used interchangeably, except in the case of a trailing zero, which must be quoted to be converted properly. For this reason, it is strongly recommended that all initializers to qv() be quoted strings instead of bare numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">Как видите, даже если мы разобрали ветвь и кусок, в конечном итоге это был всего лишь атом. Последняя программа показывает нам, как все работает. У нас есть &lt;code&gt;EXACT&lt;/code&gt; regop, а затем с помощью &lt;code&gt;END&lt;/code&gt; regop. Число в скобках указывает, куда &lt;code&gt;regnext&lt;/code&gt; узла. &lt;code&gt;regnext&lt;/code&gt; из &lt;code&gt;END&lt;/code&gt; regop не используется, так как &lt;code&gt;END&lt;/code&gt; regops означает , что мы успешно согласованы. Число слева указывает позицию regop в массиве regnode.</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">Как видите,все немного усложняется.Вот почему иногда легче взять временный на себя:</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">Как видите, &amp;laquo;большой конец&amp;raquo; стрелки касается символа &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , что является хорошим способом запомнить, что &lt;code&gt;&amp;gt;&lt;/code&gt; - это модификатор прямого порядка байтов. То же самое, очевидно, работает для &lt;code&gt;&amp;lt;&lt;/code&gt; , где &quot;конец&quot; касается кода.</target>
        </trans-unit>
        <trans-unit id="e38e7377d2adf9700c078e4fa63c0bfa66881f41" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;s&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt;, where the &quot;little end&quot; touches the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66163e2bfe72429a8264b60a772dffb530266b37" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;&quot;|&quot;&lt;/code&gt; binds less tightly than a sequence of ordinary characters. We can override this by using the grouping metacharacters, the parentheses &lt;code&gt;&quot;(&quot;&lt;/code&gt; and &lt;code&gt;&quot;)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">Как вы можете видеть, все байты продолжения начинаются с &lt;code&gt;&quot;10&quot;&lt;/code&gt; , а ведущие биты начального байта говорят, сколько байтов содержится в закодированном символе.</target>
        </trans-unit>
        <trans-unit id="d1ec4366039f138acb113c4753f7ee644d2c9618" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt;, and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">Как видите,мы сохранили данные о пути и файле в самом объекте.Помните,что под капотом этот объект все еще просто хэш.Позже мы запишем аксессуары,чтобы манипулировать этими данными.</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">Как вы можете понять с &lt;a href=&quot;perlpod&quot;&gt;первого&lt;/a&gt; взгляда на perlpod , код L &amp;lt;...&amp;gt; является наиболее сложным из кодов форматирования Pod. Мы надеемся, что приведенные ниже пункты прояснят, что это означает и как обработчики должны с этим справляться.</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">По мере того,как вы создаёте каждый патч,который вы собираетесь отправить в ядро Perl,важно написать хорошее сообщение о коммите.Это особенно важно,если ваша заявка будет состоять из серии коммитов.</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">Как вы могли догадаться из приведенной выше документации и примеров, прототип &lt;code&gt;ok&lt;/code&gt; - &lt;code&gt;($;$$)&lt;/code&gt; (и, кстати, &lt;code&gt;skip&lt;/code&gt; - &lt;code&gt;($;$$$)&lt;/code&gt; ). Это означает, например, что вы можете сделать &lt;code&gt;ok @foo, @bar&lt;/code&gt; чтобы сравнить</target>
        </trans-unit>
        <trans-unit id="60f0e85b8faee0b99818f50244dd5f18552cf61a" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt;'s prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt;'s is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">Как вы,возможно,заметили,название метода FETCH (и др.)одинаково для всех обращений,даже несмотря на то,что конструкторы различаются названиями (TIESCALAR vs TIEARRAY).В то время как в теории можно было бы иметь один и тот же класс,обслуживающий несколько связанных типов,на практике это становится громоздким,и проще всего удержать их на одном связанном типе в каждом классе.</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">Как вы, возможно, знаете, это вызывает функцию &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; &lt;code&gt;attributes&lt;/code&gt; во время компиляции со следующими параметрами: &amp;laquo;атрибуты&amp;raquo;, имя пакета вызывающей стороны, ссылка на код и &amp;laquo;метод&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="62f1e6ecdd027dd1eaef3a110461833a51c5767e" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;import&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">Как видно из этих примеров, &lt;code&gt;STDOUT&lt;/code&gt; и &lt;code&gt;STDERR&lt;/code&gt; - дескрипторы вывода, а &lt;code&gt;STDIN&lt;/code&gt; и &lt;code&gt;ARGV&lt;/code&gt; - дескрипторы ввода. Они &lt;code&gt;@ARGV&lt;/code&gt; заглавными буквами, потому что они зарезервированы для Perl, как и массив @ARGV и хеш &lt;code&gt;%ENV&lt;/code&gt; . Их внешние ассоциации были созданы вашей оболочкой.</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">Как видите,довольно легко запутаться.Хотя небольшая часть вины за это может быть приписана реализации,основанной на ссылках,на самом деле это в большей степени связано с отсутствием существующей документации с примерами,разработанными для новичка.</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">Как видите,он удивительно похож на TCP-сервер домена Интернет,настолько,что мы опустили несколько дублирующих функций -spawn(),logmsg(),ctime()и REAPER()-которые такие же,как и на другом сервере.</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">Как видите,название пакета-это название структуры.Обычные поля-это только их собственные имена.Кроме того,для вашего удобства предусмотрены следующие функции аксессуара:</target>
        </trans-unit>
        <trans-unit id="1963330f0948df59dbdb1893ed34078a319f8af0" translate="yes" xml:space="preserve">
          <source>As you see, the next buffer begins with \x43. But \x43 is 'C' in ASCII, which is wrong in this case because we are now in JISX 0208 area so it has to convert \x43\x46, not \x43. Unlike utf8 and EUC, in escape-based encodings you can't tell if a given octet is a whole character or just part of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">Как видите, есть одно исключение: в ASCII. Таким образом, вы можете принять цель №1. А с &lt;code&gt;Encode&lt;/code&gt; предполагается цель №2, но вы все равно должны быть осторожны в случаях, упомянутых в параграфах &lt;b&gt;CAVEAT&lt;/b&gt; выше.</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">Как видите,это может быть немного сложно.Важно понимать,что регулярное выражение-это всего лишь набор утверждений,дающих определение успеху.Может быть 0,1,или несколько различных способов,чтобы определение могло иметь успех в отношении конкретной строки.А если есть несколько способов,то для того,чтобы понять,какое разнообразие будет иметь успех,нужно понимать,что нужно идти на попятную.</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">Как и следовало ожидать, этот модификатор приводит, например, к тому, что &lt;code&gt;\D&lt;/code&gt; означает то же, что и &lt;code&gt;[^0-9]&lt;/code&gt; ; на самом деле, все символы не-ASCII соответствует &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , и &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; прежнему означает совпадение на границе между &lt;code&gt;\w&lt;/code&gt; и &lt;code&gt;\W&lt;/code&gt; , используя &lt;code&gt;/a&lt;/code&gt; определения / a (аналогично для &lt;code&gt;\B&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="326d016c49ef7a973850d57e2bcbf3c0189253be" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt;; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt;, using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">По мере написания приложения вы решаете,какие сообщения вам нужно отправить.Обычно вы идете,чтобы написать это:</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">Как вы видели, вы можете заставить &lt;code&gt;catdir()&lt;/code&gt; создать абсолютный путь, передав либо пустую строку, либо путь, который начинается с имени тома в качестве первого аргумента. Однако настоятельно рекомендуется не делать этого, поскольку это сделано только для обратной совместимости. Новые версии File :: Spec поставляются с методом &lt;code&gt;catpath()&lt;/code&gt; (см. Ниже), который разработан, чтобы предложить переносимое решение для создания абсолютных путей. Он берет части тома, каталога и файла и возвращает полный путь. Хотя &lt;code&gt;catdir()&lt;/code&gt; по-прежнему подходит для конкатенации</target>
        </trans-unit>
        <trans-unit id="b050afe32e842917948687f3937c11147c83dc8c" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_bin()&lt;/code&gt;, but with a &quot;0b&quot; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a7400facc4c4fbcaa07e7c2bb5aa1602866660" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_hex()&lt;/code&gt;, but with a &quot;0x&quot; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743f14ce73f3cd35ea5c0dbbced7d93ed35d470e" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_oct()&lt;/code&gt;, but with a &quot;0&quot; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="ef98034aa566e13ada7b3540ed05db8863763db2" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;my()&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot;&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot;&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;&quot;Packages&quot; in perlmod&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">Помимо экспериментальной установки (см. &lt;a href=&quot;#Signatures&quot;&gt;Сигнатуры&lt;/a&gt; ниже), Perl не имеет именованных формальных параметров. На практике все, что вам нужно сделать, это назначить их списку &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; . Переменные, которые не объявлены как частные, являются глобальными переменными. Подробные сведения о создании частных переменных см. &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;В разделах &amp;laquo;Частные переменные через my ()&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Временные значения через local ()&amp;raquo;&lt;/a&gt; . Чтобы создать защищенную среду для набора функций в отдельном пакете (и, возможно, в отдельном файле), см. &lt;a href=&quot;perlmod#Packages&quot;&gt;Пакеты в perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">Попросите его создать новый исполняемый файл Perl:</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">Попросите текущего мейнтейнера сделать вас со-монтажником или передать модуль вам.</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">Спросите у сервера &quot;полезную информацию&quot; (так говорит КСФ)о командах,которые он принимает.</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">Спроси их об этом.Доступно столько провайдеров электронной почты,что вряд ли локальная система имеет представление о том,как определить адрес электронной почты пользователя.</target>
        </trans-unit>
        <trans-unit id="8175f0d205c5d75254bfd57646dfed8cae5e64df" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are not the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105ecea82b3155461bbe416d044a05c528e58f67" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd83e9891bd9f5bea1baf962bedc44d308569ef" translate="yes" xml:space="preserve">
          <source>Assertion %s failed: file &quot;%s&quot;, line %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">Утверждения являются условиями,которые должны быть правдой;на самом деле они не соответствуют части подстроки.Существует шесть утверждений,которые записываются как последовательности обратного слеша.</target>
        </trans-unit>
        <trans-unit id="ec473104d4054125a1271db8c3a3c454c061191a" translate="yes" xml:space="preserve">
          <source>Assigned Charset Names by IANA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a86826951e8fe2168fef92e79a3e63e6f4fad1f" translate="yes" xml:space="preserve">
          <source>Assigned value is not %s reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6fd2dd7df68753c5a7360c0d8b35ab5d159443" translate="yes" xml:space="preserve">
          <source>Assigned value is not a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">Назначение Магия</target>
        </trans-unit>
        <trans-unit id="50bb715253aae843187816dcb0ecbb87efcdec5e" translate="yes" xml:space="preserve">
          <source>Assigning a filehandle to a bareword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">Назначение и разыменование переменных.</target>
        </trans-unit>
        <trans-unit id="9b18b9bc51526dfb449c1c7223109c18c9530a59" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93015f6058ffbf0e4e5d995a578a534b1b45233" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is no longer possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39852930a7cbed0e34d5b478d338273371ea5664" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to &lt;code&gt;$[&lt;/code&gt; is fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">Назначение на Ссылки</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">Присвоение списка приватных переменных для именования ваших аргументов:</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">Присвоение записи в хэше приведет к изменению временных меток файла.Если файл не существует,то он будет создан.Присвоение одному целому числу элемента хэша приведет к изменению как времени доступа,так и времени модификации на это значение.В качестве альтернативы может быть передана ссылка на массив из двух значений.Первый элемент массива будет использоваться для установки времени доступа,а второй элемент-для установки времени модификации.</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">Присвоение специальной переменной $[</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">Назначенные операторы</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">Присвоение немного особенное в том,что оно использует свой левый аргумент для определения контекста для правого аргумента.Присвоение скаляру оценивает правую сторону в контексте скаляра,в то время как присвоение массиву или хэшу оценивает правую сторону в контексте списка.Присвоение списку (или срезу,который в любом случае является просто списком)также оценивает правую сторону в контексте списка.</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">Назначенные операторы работают как в C.То есть..,</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">Назначение на печатный шрифт выполняет операцию наложения псевдонима,т.е,</target>
        </trans-unit>
        <trans-unit id="efdb1ec14f21e9ed5ad15f6e0bef5c8c9ed1a0b1" translate="yes" xml:space="preserve">
          <source>Assignment to both a list and a scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">Присвоение ссылок и не ссылок может быть объединено в списках и условных тернарных выражениях,при условии,что значения справа являются правым типом для каждого элемента слева,хотя это может привести к обфусцированному коду:</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">Связанный с переменным соответствием &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... являются &lt;b&gt;обратные_связь &lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Обратные являются соответствующим переменными , которые могут быть использованы</target>
        </trans-unit>
        <trans-unit id="de3f3ea1d0b7efcc3a2ee5d6b60bcc68b1043b48" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt;, &lt;code&gt;\g2&lt;/code&gt;, ... Backreferences are matching variables that can be used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68987493bca5f5e7abadf4c61d3d6f22214b34fc" translate="yes" xml:space="preserve">
          <source>Associates an internal FILEHANDLE with the external file specified by EXPR. That filehandle will subsequently allow you to perform I/O operations on that file, such as reading from it or writing to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">Предполагайте &lt;b&gt;что-нибудь&lt;/b&gt; о структурах (особенно о тех, которые вы не контролируете, например о тех, которые поступают из системных заголовков)</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">Предположим,что каждое предложение заканчивается двумя пробелами и постараемся сохранить это расстояние.Без этой опции все последовательные пробелы в невербатичных абзацах сжимаются в один пробел.</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">Предположим, что четыре класса: A, B, C и D.</target>
        </trans-unit>
        <trans-unit id="52c1183f42274e0344acc650141fdfaebc8ac557" translate="yes" xml:space="preserve">
          <source>Assume no one is paying attention and skips prompts for distributions that do that correctly. &lt;code&gt;cpan(1)&lt;/code&gt; sets this to &lt;code&gt;1&lt;/code&gt; unless it already has a value (even if that value is false).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2226e484e68600c3306101e70d0302d670391b19" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt;. However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; are portable, and starting in Perl v5.24, the same ranges are portable in &lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">Ничего не предполагайте о числовых значениях ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ) символов. Не используйте явные диапазоны кодовых точек (например, &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . Однако, начиная с Perl v5.22, диапазоны классов символов в квадратных скобках шаблона регулярного выражения, указанные как &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; , переносимы. Вы можете переносимо использовать символьные классы символов, такие как &lt;code&gt;[:print:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">Предположим,что целое число не может занимать менее 20 байт памяти,флот не может занимать менее 24 байт,строка не может занимать менее 32 байт (все эти примеры предполагают 32-битные архитектуры,на 64-битных архитектурах результат значительно хуже).Если доступ к переменной осуществляется двумя из трех различных способов (для чего требуется целое число,плавающий диск или строка),то объем памяти может увеличиться еще на 20 байт.Неаккуратная реализация malloc(3)может резко раздуть эти числа.</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">Предположим,что старую DLL называют</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">Предположим,что вы опытный портер,так что будьте уверены,что все необходимые инструменты уже есть в вашей системе,и вы знаете,как получить дистрибутив исходников Perl.Используйте его,перейдите в каталог извлечения,и</target>
        </trans-unit>
        <trans-unit id="111d847871723c094fda67b2b5bccd84d523f158" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">Предположим, что эта версия TAP для &lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt; вместо версии TAP по умолчанию 12.</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">Очень мало думайте о наборах персонажей.</target>
        </trans-unit>
        <trans-unit id="14aa653264a55e7f75e0cffdf8147628d06e0a12" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;PL_op&lt;/code&gt; is the OP that originally triggered the error, and that &lt;code&gt;PL_comppad&lt;/code&gt;/&lt;code&gt;PL_curpad&lt;/code&gt; points to the currently executing pad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">Предположительно,PL_op является операцией,которая изначально спровоцировала ошибку,и что PL_comppad/PL_curpad указывает на текущий исполняющий блокнот.</target>
        </trans-unit>
        <trans-unit id="40680f85edea3366c2b9e8f14183ac57a5e6081e" translate="yes" xml:space="preserve">
          <source>Assuming NOT a POSIX class since %s in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">Предполагая,что для любого типа данных можно разыменовать любой тип указателя.</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">Предположим sizeof(int)==sizeof(long)</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">Если предположить, что файлы &lt;code&gt;man&lt;/code&gt; были размещены в соответствующем месте, это завершает установку минимальной системы Perl. (Бинарный дистрибутив также содержит множество дополнительных модулей и документацию в формате INF.)</target>
        </trans-unit>
        <trans-unit id="d729092ca24191c5dd2dddf6e45eb913d7433329" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt;-files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">Предполагая,что мы должны сопоставить календарные даты,которые могут быть даны в одном из трех форматов yyyy-mm-dd,mm/dd/yyyy или dd.mm.yyyy,мы можем написать три подходящих шаблона,в которых мы используем 'd','m' и 'y' соответственно в качестве названий групп,захватывающих соответствующие компоненты даты.Операция совмещения объединяет эти три шаблона в качестве альтернативы:</target>
        </trans-unit>
        <trans-unit id="391cee4ecd3812f9caf92f329d5fa158ab37c5f3" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use &lt;code&gt;'d'&lt;/code&gt;, &lt;code&gt;'m'&lt;/code&gt; and &lt;code&gt;'y'&lt;/code&gt; respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fc34e986ee3355963fe79a5b72db07365ea4e2" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression (see also &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">Если предположить,что вас не волнуют такие нотации IEEE,как &quot;NaN&quot; или &quot;Infinity&quot;,вы,вероятно,просто хотите использовать регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">Предположим,что набор символов ASCIIish</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">Предполагая,что набор символов просто ASCII.</target>
        </trans-unit>
        <trans-unit id="f18b4264a48b77c77d31682d53d915137b1c2a2b" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;&quot;savepv&quot; in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">Предполагая, что содержимое статической памяти, на которую указывают возвращаемые значения оболочек Perl для функций библиотеки C, не изменяется. Многие функции библиотеки C возвращают указатели на статическое хранилище, которое может быть перезаписано последующими вызовами тех же или связанных функций. Perl имеет легкие оболочки для некоторых из этих функций, которые не создают копий статической памяти. Хорошим примером является интерфейс переменных среды, действующих в программе. Perl имеет &lt;code&gt;PerlEnv_getenv&lt;/code&gt; получать ценности из окружающей среды. Но возврат - это указатель на статическую память в библиотеке C. Если вы используете значение для немедленной проверки чего-либо, это нормально, но если вы сохраните значение и ожидаете, что оно не изменится при последующей обработке, вы ошибетесь, но, возможно, вы этого не узнаете, потому что разные реализации библиотеки C ведут себя по-другому, и тот, который находится на платформе, на которой вы тестируете, может работать в вашей ситуации. Но на некоторых платформах последующий вызов &lt;code&gt;PerlEnv_getenv&lt;/code&gt; или связанной функции БУДЕТ перезаписывать память, на которую указывает ваш первый вызов. Это привело к возникновению некоторых трудных для отладки проблем. Сделайте &lt;a href=&quot;perlapi#savepv&quot;&gt;сохранение pv в perlapi&lt;/a&gt;сделать копию, чтобы избежать этих проблем. Когда вы закончите, вам придется освободить копию, чтобы избежать утечки памяти. Если у вас нет контроля над тем, когда он будет освобожден, вам нужно будет сделать копию в смертном скаляре, например:</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">Предполагая базу данных из предыдущего примера:</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">Предполагая, что они должны вести себя аналогично Perl &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; , перегруженные реализации этих операторов должны изменять свои операнды.</target>
        </trans-unit>
        <trans-unit id="3db726b30f88089aabcbf03ff0837b3e46de1fc1" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0a71c399dfe91f864d3abd9d93805888be04d4" translate="yes" xml:space="preserve">
          <source>Assuming we are on the branch &lt;code&gt;blead&lt;/code&gt; immediately after a pull, this command would be more or less equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">Предположив,что вы называете свой класс Projname::L10N,создайте класс,состоящий минимально из:</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">Если предположить,что у вас хорошее тестовое покрытие,то ваши тесты должны давать сбой с отсутствующими зависимостями,сообщающими пользователю сильнее о том,что что-то не так.Вы можете написать</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">Предполагая, что вы знаете, что имеете дело со строкой UTF-8, вы можете узнать, какой длины первый символ в ней, с &lt;code&gt;UTF8SKIP&lt;/code&gt; макроса UTF8SKIP :</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">Предполагая, что вы работаете с достаточными разрешениями, вы сможете установить общесистемную дату и время, запустив программу &lt;code&gt;date(1)&lt;/code&gt; . (Невозможно установить время и дату для каждого процесса.) Этот механизм будет работать для Unix, MS-DOS, Windows и NT; эквивалент VMS - &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02ec0a4ff8284bf3708641e3963c674ad5d28a0e" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">Предполагая, что ваша система поддерживает такие вещи, просто отправьте соответствующий сигнал процессу (см. &lt;a href=&quot;functions/kill&quot;&gt;Kill&lt;/a&gt; ). Обычно сначала отправляют сигнал TERM, немного подождите, а затем отправляют сигнал KILL, чтобы завершить его.</target>
        </trans-unit>
        <trans-unit id="a095cda27752254d76d70e270420e5ff5d39b90c" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;perlfunc#kill&quot;&gt;&quot;kill&quot; in perlfunc&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489e70109e67cf9da0e282567e7dfa75ecfec0d5" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">В 10:23 эта функция генерирует 10-ю строку файла данных; в 15:45 вместо этого генерируется 15-я строка. По умолчанию &lt;code&gt;Memoize&lt;/code&gt; будет видеть только аргумент $ problem_type. Чтобы исправить это, включите текущий час в нормализатор:</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">При заданной позиции персонажа первым вариантом,позволяющим успешно провести регекс-матч,будет тот,который совпадает.Здесь все альтернативы совпадают на первой позиции строки,то есть первые совпадают.</target>
        </trans-unit>
        <trans-unit id="35d56b3c766a2a7d81a6ef179791e69c5926ffe4" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and don't affect the other parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">В любой момент времени действует именно один из этих модификаторов.Их наличие позволяет Perl сохранять изначально скомпилированное поведение регулярного выражения,независимо от того,какие правила действуют в момент его фактического выполнения.И если оно интерполировано в более крупный регекс,то правила оригинала продолжают к нему применяться,и только к нему.</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">В любом случае, само использование &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; вызывает сомнения, когда дело касается символов Юникода, поскольку вы должны учитывать такие вещи, как ширина символа (т.е. двойная ширина для идеограмм) и направления (например, BIDI для арабского и иврита).</target>
        </trans-unit>
        <trans-unit id="b3d5fa45c550ce1b12a041713732b9ad3afd79b2" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;format&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">Во время десериализации вам будет возвращен тот же СПИСОК,но все дополнительные ссылки будут указывать на десериализованную структуру.</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">На каждом уровне стека отображается имя подпрограммы вместе с ее параметрами. Для простых скаляров этого достаточно. Для сложных типов данных, таких как объекты и другие ссылки, это может просто отобразить &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3499c5b318f8c7ae1f2cab230c6e5e96c7a777c" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">В точках входа в perl, таких как &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; и &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; каждый выполняет &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , затем входит в цикл runops или что-то еще и обрабатывает возможные возвраты исключения. Для возврата 2 выполняется окончательная очистка, такая как выталкивание стеков и вызов блоков &lt;code&gt;CHECK&lt;/code&gt; или &lt;code&gt;END&lt;/code&gt; . Среди прочего, это то, как очистка области все еще происходит во время &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5843723152f1754465e406a2b90b574561ffc4" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt;, &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt;, then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">На первый взгляд может показаться, что он не должен печатать, потому что, очевидно, &lt;code&gt;ddd&lt;/code&gt; не будет соответствовать целевой строке. Но посмотрите на этот пример:</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">По крайней мере,для соответствия WinNT,вы должны сохранить рекомендуемое значение.</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">По крайней мере, в Unix вы можете обойти это, увеличив пределы размера данных процесса: в csh / tcsh используйте &lt;code&gt;limit&lt;/code&gt; и &lt;code&gt;limit datasize n&lt;/code&gt; (где &lt;code&gt;n&lt;/code&gt; - количество килобайт), чтобы проверить текущие ограничения и изменить их, а в ksh / bash / zsh используйте &lt;code&gt;ulimit -a&lt;/code&gt; и &lt;code&gt;ulimit -d n&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="66f7b8a4f3dad67cd26cb07eaab73c32a3b79d31" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">По крайней мере,она обратно совместима,не делая многого.</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">По крайней мере, один из &lt;code&gt;s1&lt;/code&gt; и &lt;code&gt;s2&lt;/code&gt; должен иметь цель (хотя бы один из &lt;code&gt;l1&lt;/code&gt; и &lt;code&gt;l2&lt;/code&gt; должен быть ненулевым), и если оба имеют, то для успешного совпадения должны быть достигнуты оба. Кроме того, если складка символа состоит из нескольких символов, все они должны быть сопоставлены (см. Ссылку на tr21 ниже для &amp;laquo;складывания&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">По крайней мере, три встроенные функции: &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; . Мы могли бы когда-нибудь добавить их позже, если мы подумаем о них.</target>
        </trans-unit>
        <trans-unit id="36309277752b244d6584b5ffd8f2594deef16e94" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;defined(...)&lt;/code&gt;, &lt;code&gt;exists(...)&lt;/code&gt;, and &lt;code&gt;eof(...)&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">В строке под номером 4 находится полезный указатель,который сообщает вам,где вы сейчас находитесь.Чтобы увидеть больше кода,снова наберите 'v':</target>
        </trans-unit>
        <trans-unit id="0f8b916c14aa42230cca14b7fbe9aee5db398694" translate="yes" xml:space="preserve">
          <source>At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher, and this code point is higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">В настоящее время этот список:ослабленный,сдвинутый,dualvar,isvstring,set_prototype</target>
        </trans-unit>
        <trans-unit id="945b483b1ccbe65e925900ec39e83bbc97a9ab8a" translate="yes" xml:space="preserve">
          <source>At present the following compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">В настоящее время поддерживаются три метода сжатия IO::Compress::Zip,а именно Store (сжатие отсутствует вообще),Deflate,Bzip2 и LZMA.</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">В настоящее время, когда вы впервые перебираете% ENV с использованием &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; , вы понесете штраф по времени, так как все логические имена будут прочитаны, чтобы полностью заполнить% ENV. Последующие итерации не будут перечитывать логические имена, поэтому они не будут такими медленными, но они также не будут отражать никаких изменений в таблицах логических имен, вызванных другими программами.</target>
        </trans-unit>
        <trans-unit id="214ce8ba80d0a179d1db87f227b4915a835aed62" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;keys&lt;/code&gt;, or &lt;code&gt;values&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">Во время выполнения,каждый из перечисленных плагинов инстанцируется как однокнопочный объект,запуская эквивалент этого псевдокода:</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">Во время работы вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">В какой-то момент построенный может умереть,сообщая,что</target>
        </trans-unit>
        <trans-unit id="fdde3eae592d85a1bbf81dc1dcb5f03f478df9d3" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agreed to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">На выставке QA Hackathon 2008 в Осло сопровождающие модулей Perl согласились использовать формат CPAN Meta для передачи пост-конфигурационных требований между компонентами инструментальной цепочки.Эти файлы,</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">За счет небольших накладных расходов на заголовок вы можете сохранить в уже открытый дескриптор файла с &lt;code&gt;store_fd&lt;/code&gt; процедуры store_fd и получить из файла с помощью &lt;code&gt;fd_retrieve&lt;/code&gt; . Эти имена не импортируются по умолчанию, поэтому вам придется сделать это явно, если вам нужны эти процедуры. Предоставленный вами файловый дескриптор должен быть уже открыт для чтения, если вы собираетесь получить, и для записи, если вы хотите сохранить.</target>
        </trans-unit>
        <trans-unit id="e5ffbd456858663ac301bf7789eac1b059f62c98" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt;. Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">В конце</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">В конце всех блоков &lt;code&gt;when&lt;/code&gt; идет неявный &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; . Вы можете переопределить это с помощью явного &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; если вас интересует только первое совпадение.</target>
        </trans-unit>
        <trans-unit id="1e41ae8e63f613457fbc688a05901eda0e76d2fb" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;next&lt;/code&gt;. You can override that with an explicit &lt;code&gt;last&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">В конце анализа вызовите &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; чтобы получить верхний узел дерева.</target>
        </trans-unit>
        <trans-unit id="7dfefef1d68ca5b408b29dae9e3fff68c7b274a2" translate="yes" xml:space="preserve">
          <source>At the end of the subtest, the final &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event is sent to the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">На самом низком уровне макросы new_SV()и del_SV()захватывают и освобождают голову SV.(При отладке с помощью -DD,del_SV()вызывает функцию S_del_sv()для возврата SV в свободный список с проверкой на ошибки)new_SV()вызывает more_sv()/sv_add_arena()для добавления дополнительной арены,если свободный список пуст.SV в свободном списке имеют поле SvTYPE,установленное для всех.</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">На момент написания, AIX поддерживает два различных нативные компиляторы, для которых вы должны платить: &lt;b&gt;XLC&lt;/b&gt; и &lt;b&gt;VAC&lt;/b&gt; . Если вы решите использовать любой из этих двух (что намного проще, чем использование gcc), обязательно обновитесь до последнего доступного уровня исправления. В настоящее время:</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">Рискуя заявить очевидное,модули предназначены для модульной установки.Разработчик на Perl должен иметь возможность использовать модули для компоновки строительных блоков своего приложения.Тем не менее,важно,чтобы блоки имели правильную форму,и чтобы разработчику не приходилось использовать большой блок,когда все,что им нужно,это маленький блок.</target>
        </trans-unit>
        <trans-unit id="1014d039b0716d418675db8cd3420cc810aff463" translate="yes" xml:space="preserve">
          <source>At the same time, this pragma cannot detect when such a module has installed from CPAN to the core library, and so it would endlessly and uselessly exhort the user to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">На момент написания данной статьи (2009-03)работало три реализации YAML:YAML,YAML::Syck и YAML::XS.Последние две быстрее,но требуют установки компилятора C на вашей системе.Модулей,соответствующих YAML,может быть больше.Когда я попробовал два других проигрывателя,YAML::Tiny и YAML::Perl,они казались недостаточно мощными для работы с CPAN.pm.Возможно,за это время ситуация изменилась.</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">На момент написания этой статьи (июнь 2002 г.) в Tru64 libc при печати длинных дубликатов без использования нотации &amp;laquo;e&amp;raquo; была известная ошибка. Значения верны и пригодны для использования, но вы получите только ограниченное количество отображаемых цифр, если вы не &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; проблему с помощью &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;% .33e&quot;, $ num или подобных. Для версий Tru64 от V5.0A до V5.1A патч ожидается через некоторое время после выпуска perl 5.8.0. Если ваша библиотека libc еще не была исправлена, вы получите предупреждение от Configure при выборе длинных двойников.</target>
        </trans-unit>
        <trans-unit id="cff077ec447ff4f924a23e0da4a7a4062c468c7a" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">На момент написания данной статьи Perl 5.18.0 считался хорошо защищенным от атак на его алгоритмическую сложность реализации хэша.Это в значительной степени обусловлено следующими мерами по смягчению атак:</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">Во время очень финальной очистки вызывается sv_free_arenas()из функции perl_destruct(),чтобы физически освободить все арены,выделенные с момента запуска интерпретатора.</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">На момент создания f она не может захватить текущую подпрограмму &quot;a&quot;,так как анонимная подпрограмма еще не создана.И наоборот,следующее не выдаст предупреждение,так как анонимная подпрограмма уже создана и работает в реальном времени:</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">На момент создания f она не может захватить текущее значение $a,так как анонимная подпрограмма еще не создана.И наоборот,предупреждение не будет выдано,так как анонимная подпрограмма уже создана и находится в прямом эфире:</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">На момент последнего обновления этого документа,Cygwin 1.7.16 был действующим.</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">По крайней мере,это полезно для того,чтобы увидеть,что SelfLoader считает шлейфами-для того,чтобы будущие версии SelfStubber не отставали от SelfLoader,SelfStubber фактически использует SelfLoader,чтобы определить,какие шлейфы нужны.</target>
        </trans-unit>
        <trans-unit id="9d086f75055dc823d417d876f240b4ce1aa5f40a" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass needs to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">Как минимум, любой подкласс должен предоставить свой собственный &lt;code&gt;new()&lt;/code&gt; и может хранить дополнительные хеш-ключи в объекте. Также необходимо определить некоторые глобальные переменные пакетов, например:</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">На данный момент,если ты используешь</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">На данный момент мы рассмотрели все основные понятия реге Exp,поэтому давайте приведем более увлекательный пример регулярного выражения.Мы построим регеxp,который будет соответствовать числам.</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">На данный момент xsubpp делает очень мало работы-различия между Mytest.xs и Mytest.c минимальны.</target>
        </trans-unit>
        <trans-unit id="4cb351d8164d812dc7e335f6aa1c330c2f5b0d24" translate="yes" xml:space="preserve">
          <source>At this time, &lt;code&gt;study&lt;/code&gt; does nothing. This may change in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">На момент написания значения &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; были двух типов: либо имя страницы Pod, например &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (которое может быть настоящим модулем Perl или программой в каталоге @INC / PATH, либо .pod файл в тех местах); или имя страницы руководства Unix, например &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . Теоретически, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; неоднозначен между страницей модуля под названием &amp;laquo;chmod&amp;raquo; и страницей руководства Unix &amp;laquo;chmod&amp;raquo; (в любом разделе man). Однако наличие строки в скобках, как в &amp;laquo;crontab (5)&amp;raquo;, является достаточным, чтобы сигнализировать, что обсуждаемая страница не является страницей Pod, а значит, предположительно, страницей руководства Unix. Это различие не имеет значения для многих процессоров Pod,но некоторым процессорам, выполняющим рендеринг в гипертекстовые форматы, может потребоваться различать их, чтобы знать, как рендерить данный &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; Код L &amp;lt;foo&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="1402e155751b829c93df5128b5d19d797691621a" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt;. In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; is ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f8d626a483cf6ebf2f3cd6cefe211ee98242ab" translate="yes" xml:space="preserve">
          <source>At time of writing, I don't think you'll need to use this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b127225208f5ac9bbb6a72b48b20b7d3616ff18" translate="yes" xml:space="preserve">
          <source>Atari MiNT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3342f30bf4c3977d537b68719b3f6636e25cb1" translate="yes" xml:space="preserve">
          <source>Athena</source>
          <target state="translated">Athena</target>
        </trans-unit>
        <trans-unit id="fb5b8f9948a5df2cd992c1e84448561317bc6a25" translate="yes" xml:space="preserve">
          <source>Atrributes such as package, file, and caller are determined automatically, and cannot be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3493cb8763751f88e1926ab01085068e369734c9" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat(2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">Присоедините сегмент разделяемой памяти, идентифицированный идентификатором, к адресному пространству вызывающего процесса. См. &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;Шмат&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">Присоединение &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; к массивам допустимо , но не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">Попытка SASL-аутентификации.</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">Попытка SASL-аутентификации.Требуется аутентификация::SASL модуля.</target>
        </trans-unit>
        <trans-unit id="ccd854e11a4d11e3e9e58ceb95944b13ef3a518a" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module. The first form constructs a new Authen::SASL object using the given username and password; the second form uses the given Authen::SASL object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883f5c19fa9ca67ce62c443fd2ce7bac60b6089d" translate="yes" xml:space="preserve">
          <source>Attempt to access disallowed key '%s' in a restricted hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf0ab65502bfcdd00cde497405332ccea4e648b" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a freed package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8614ea5fd745bc313cc5245a331edbc4dddec890" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">Попытка сменить каталог на каталог, указанный в &lt;code&gt;$dir&lt;/code&gt; . Если &lt;code&gt;$dir&lt;/code&gt; - &lt;code&gt;&quot;..&quot;&lt;/code&gt; , команда FTP &lt;code&gt;CDUP&lt;/code&gt; используется для попытки перехода на один каталог вверх. Если каталог не указан, делается попытка изменить каталог на корневой каталог.</target>
        </trans-unit>
        <trans-unit id="6f0b75ab4748fe5742f8fdfbfa72a1464729d3b5" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt;. If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt;, the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aef18d28c95173a99a1a9cd9b174366e83e56c" translate="yes" xml:space="preserve">
          <source>Attempt to clear deleted array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">Попытайтесь преобразовать абсолютную спецификацию файла в относительную спецификацию.</target>
        </trans-unit>
        <trans-unit id="2c4880c9fdd4f4d9c5b79e2c012fb0e250d383e7" translate="yes" xml:space="preserve">
          <source>Attempt to delete disallowed key '%s' from a restricted hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0798ebadbab9bffb1e99c85507d3edee83caa008" translate="yes" xml:space="preserve">
          <source>Attempt to delete readonly key '%s' from a restricted hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">Попытка уничтожить все объекты,которые еще не освобождены.</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">Попытка оценить текущее имя хоста и его домен.</target>
        </trans-unit>
        <trans-unit id="80fda9c03868b272773d0d41887e0dbe18413719" translate="yes" xml:space="preserve">
          <source>Attempt to free non-arena SV: 0x%x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d38b115a5aa938320799c6531228c69b9fa275" translate="yes" xml:space="preserve">
          <source>Attempt to free nonexistent shared string '%s'%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b479273a362ea2e8c34f077e9e3c6360ab77808" translate="yes" xml:space="preserve">
          <source>Attempt to free temp prematurely: SV 0x%x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34a51b6be5af9431919f62ebe158c42fa203ea7" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced glob pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f310189c328c36df3675b24385fea4a52ffa6b" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced scalar: SV 0x%x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51aff28048c322c0b88140e9c1dcb9278d5b60c1" translate="yes" xml:space="preserve">
          <source>Attempt to pack pointer to temporary value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">Попытайтесь распечатать сводную информацию,если запуск прерван SIGINT (Ctrl-C).</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">Попробуйте произвести цветной вывод.</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">Попытка прочитать &lt;code&gt;$length&lt;/code&gt; байт несжатых данных в &lt;code&gt;$buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a9c5fb7a8cb670c472dd87151c6343a5662154" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9d551547de808708f971d391e53086cf3f44fc" translate="yes" xml:space="preserve">
          <source>Attempt to reload %s aborted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c4ceba341469a694caa6a8c164987d97a35645" translate="yes" xml:space="preserve">
          <source>Attempt to set length of freed array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee621066cdf5eff50fe796c90fc14083ab2dd15" translate="yes" xml:space="preserve">
          <source>Attempt to use reference as lvalue in substr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">Попытка унаследовать от себя порождает предупреждение.</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">Попытка упаковать специальные значения с плавающей запятой &lt;code&gt;Inf&lt;/code&gt; и &lt;code&gt;NaN&lt;/code&gt; (бесконечность, также отрицательные и не числовые) в упакованные целочисленные значения (например, &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) является фатальной ошибкой. Причина этого в том, что для этих специальных значений просто не существует разумного преобразования в целые числа.</target>
        </trans-unit>
        <trans-unit id="d1f53d7ce9f579730ddb96734ab811ab0bbc0590" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt;) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">Попытка снова открыть базу данных,не закрывая ее.</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">Пытается несколькими способами получить имя хоста системы, а затем кэширует результат. Он пробует первый доступный из библиотеки C gethostname (), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname (2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; и файл</target>
        </trans-unit>
        <trans-unit id="82ba9728173d7f6ba4ffa539ae706dc3eec02b8f" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt;, uname(2), &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt;, &lt;code&gt;`uname -n`&lt;/code&gt;, and the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba76ae4290c1441342a9f4f7bc1b58233fe69fb" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like &lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect(2)&lt;/a&gt;. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Попытки подключиться к удаленному сокету, как и connect (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Попытки подключиться к удаленному сокету, как и connect (2). Возвращает true в случае успеха и false в противном случае. ИМЯ должно быть упакованным адресом соответствующего типа для сокета. См. Примеры в &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client / Server Communication in perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">Попытки преобразовать на месте октетную последовательность,закодированную как</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">Попытки преобразовать PV SV из символов в байты. Если PV содержит символ, который не может поместиться в байт, это преобразование завершится ошибкой; в этом случае либо возвращает false, либо, если &lt;code&gt;fail_ok&lt;/code&gt; не истинно, хрипит.</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">Попытки определить,находится ли данный узел за пределами вашего брандмауэра.Возможные возвращаемые значения.</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">Попытки прочитать ЛЕНГТ</target>
        </trans-unit>
        <trans-unit id="c8be1bb9a549008dc0e0461ce94dfbc02a8ed8c1" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read(2)&lt;/a&gt;. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with other kinds of reads, &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; can cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; or &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">Пытается прочитать LENGTH байтов данных в переменную SCALAR из указанного FILEHANDLE, используя read (2). Он обходит буферное IO, поэтому смешивание это с другими видами чтения, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO или STDIO слоев , как правило , буфера данных. Возвращает количество фактически прочитанных байтов, &lt;code&gt;0&lt;/code&gt; в конце файла или undef, если произошла ошибка (в последнем случае также устанавливается &lt;code&gt;$!&lt;/code&gt; ). SCALAR будет увеличиваться или уменьшаться так, чтобы последний фактически прочитанный байт был последним байтом скаляра после чтения.</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">Пытается прочитать LENGTH байтов данных в переменную SCALAR из указанного FILEHANDLE, используя read (2). Он обходит буферное IO, поэтому смешивание это с другими видами чтения, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO или STDIO слоев , как правило , буфера данных. Возвращает количество фактически прочитанных байтов, &lt;code&gt;0&lt;/code&gt; в конце файла или undef, если произошла ошибка (в последнем случае также устанавливается &lt;code&gt;$!&lt;/code&gt; ). SCALAR будет увеличиваться или уменьшаться так, чтобы последний фактически прочитанный байт был последним байтом скаляра после чтения.</target>
        </trans-unit>
        <trans-unit id="1a8348f0c0ac76ec0ef2040ebe72ee4d10ad1e13" translate="yes" xml:space="preserve">
          <source>Attempts to set_hints_for unidentifiable subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e09b188ae4a3fab1a81562daadb429ed4fd7f6d" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write(2)&lt;/a&gt;. If LENGTH is not specified, writes whole SCALAR. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with reads (other than &lt;code&gt;sysread)&lt;/code&gt;), &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; may cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually written, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; if there was an error (in this case the errno variable &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">Пытается записать LENGTH байтов данных из переменной SCALAR в указанный FILEHANDLE, используя write (2). Если ДЛИНА не указана, записывается весь СКАЛЯР. Он обходит буферное IO, так что смешивание это с читает (кроме &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO и STDIO слоев , как правило , буфер данных. Возвращает количество фактически записанных байтов или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если произошла ошибка (в этом случае также устанавливается переменная errno &lt;code&gt;$!&lt;/code&gt; ). Если ДЛИНА больше, чем данные, доступные в СКАЛЯРЕ после СМЕЩЕНИЯ, будет записано столько данных, сколько доступно.</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">Пытается записать LENGTH байтов данных из переменной SCALAR в указанный FILEHANDLE, используя write (2). Если ДЛИНА не указана, записывается весь СКАЛЯР. Он обходит буферное IO, так что смешивание это с читает (кроме &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , или &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; может вызвать путаницу , поскольку PerlIO и STDIO слоев , как правило , буфер данных. Возвращает количество фактически записанных байтов или &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если произошла ошибка (в этом случае также устанавливается переменная errno &lt;code&gt;$!&lt;/code&gt; ). Если ДЛИНА больше, чем данные, доступные в СКАЛЯРЕ после СМЕЩЕНИЯ, будет записано столько данных, сколько доступно.</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">Попытки завершить слово.Не может быть изменено.</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="295826f440604d6a675c4c66d0a324dc4eaca56b" translate="yes" xml:space="preserve">
          <source>Attribute prototype(%s) discards earlier prototype attribute in same sub</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Атрибут::Обработчики-более простое определение обработчиков атрибутов</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers прилагает большие усилия для преобразования аргумента данных ( &lt;code&gt;$_[4]&lt;/code&gt; ) в пригодную для использования форму перед передачей его обработчику (но см. &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Неинтерпретативные обработчики атрибутов&lt;/a&gt; ). Если эти попытки увенчаются успехом, интерпретированные данные передаются в виде ссылки на массив; если они терпят неудачу, необработанные данные передаются в виде строки. Например, все это:</target>
        </trans-unit>
        <trans-unit id="04790e00da71beac2f86333318faed6cfab890a0" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;&quot;Non-interpretive attribute handlers&quot;&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="4ce085fab8976266bb7771327c95a06a2d92883d" translate="yes" xml:space="preserve">
          <source>Attributes :locked and :unique</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57744968c9ece6a6fd393a9a1f9a16852d8d26e2" translate="yes" xml:space="preserve">
          <source>Attributes &lt;code&gt;:locked&lt;/code&gt; and &lt;code&gt;:unique&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65ce706012d5cc8515dbfba3f0c94b3cae90800" translate="yes" xml:space="preserve">
          <source>Attributes =&amp;gt; $sAttributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">Атрибуты часто хранятся в самом объекте.Например,если объект является анонимным хэшем,мы можем хранить значения атрибутов в хэше,используя имя атрибута в качестве ключа.</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">Атрибуты обычно определяются как &quot;только для чтения&quot; или &quot;только для чтения-записи&quot;.Атрибуты,доступные только для чтения,могут быть установлены только при первом создании объекта,в то время как атрибуты,доступные для чтения и записи,могут быть изменены в любое время.</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">Атрибуты как &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; интерфейсы</target>
        </trans-unit>
        <trans-unit id="dd541d956cc1115542e113d51d19e51923523667" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;tie&lt;/code&gt; interfaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">Атрибуты как интерфейсы связи</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">Атрибуты делают отличный и интуитивно понятный интерфейс,через который можно связывать переменные.Например:</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">Атрибуты, однажды установленные, действуют до тех пор, пока они не будут сняты (путем печати атрибута &lt;code&gt;clear&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ). Будьте осторожны при этом, иначе ваш атрибут будет работать после того, как ваш скрипт будет запущен, и люди будут очень раздражены тем, что их подсказка и ввод изменяются на странные цвета.</target>
        </trans-unit>
        <trans-unit id="8aad82b8fbc6c4c52822cc8ecd0cf935a1127780" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;reset&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51da1fd65173253fff2051ffdb2fb4742bcd89d" translate="yes" xml:space="preserve">
          <source>Audrey Tang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">Одри Танг &amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f2cb213ffe5688a539a9e042d127473bf2e3ad45" translate="yes" xml:space="preserve">
          <source>August 2005</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b22c9a35903363899da803d503fe897e1743fa7" translate="yes" xml:space="preserve">
          <source>August 23, 2005</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceafb51e2b0783d53dd620019dff3aa66708a26f" translate="yes" xml:space="preserve">
          <source>Australia</source>
          <target state="translated">Australia</target>
        </trans-unit>
        <trans-unit id="593905b31972f6ffe58325abf98595caf4ebf458" translate="yes" xml:space="preserve">
          <source>Austria</source>
          <target state="translated">Austria</target>
        </trans-unit>
        <trans-unit id="95786e021d4a315fb9439c8c152d524cf9f59cc3" translate="yes" xml:space="preserve">
          <source>Authen::SASL is required for AUTH support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">Выполните аутентификацию на сервере, идентифицированном как &lt;code&gt;USER&lt;/code&gt; с паролем &lt;code&gt;PASS&lt;/code&gt; . Аналогично &lt;a href=&quot;#login&quot;&gt;логину&lt;/a&gt; , но пароль не передается в виде открытого текста.</target>
        </trans-unit>
        <trans-unit id="2d308c897b8201e557fb3734cdc42302c1f694dd" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt;. Similar to &lt;a href=&quot;#login&quot;&gt;&quot;login&quot;&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">Аутентифицируется на сервере (используя оригинальную форму AUTHINFO USER/AUTHINFO PASS,определенную в RFC2980),используя предоставленные имя пользователя и пароль.Обратите внимание,что пароль отправляется на сервер открытым текстом.Эту команду не следует использовать с ценными паролями,если только соединение с сервером не защищено каким-либо образом.</target>
        </trans-unit>
        <trans-unit id="4be2c3e4a055e66e61888715b3835a0acb5d7f3e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;&quot;authinfo&quot;&lt;/a&gt; the password is sent in clear text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">Аутентифицируется на сервере (с использованием предложенной формы NNTP V2 AUTHINFO SIMPLE, определенной и устаревшей в RFC2980) с использованием предоставленных имени пользователя и пароля. Как и в случае с &lt;a href=&quot;#authinfo&quot;&gt;authinfo,&lt;/a&gt; пароль отправляется открытым текстом.</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">Аутентификация,безопасность и шифрование</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="a250719f5509f4b060ed02cea92bc61a08d442f3" translate="yes" xml:space="preserve">
          <source>Author and Copyright Information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">Автор и сопровождающий: Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">История автора и изменений</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">Автор данного программного обеспечения не претендует на пригодность,надежность,возможность редактирования или использования данного продукта,и не несет ответственности за любой ущерб,возникший в результате его использования.Если вы можете использовать его,вам повезло,если нет,то я не должен нести за это ответственность.Держите под рукой удобную копию своей ленты для резервного копирования.</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">Автор: Марк Джейсон Доминус, Plover Systems ( &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b0d417f355d7d062d5dedda5f6e9d6e446d1132a" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">Авторы не должны вкладывать L &amp;lt;...&amp;gt; коды. Например, &quot;L &amp;lt;The L &amp;lt;Foo :: Bar&amp;gt; man page&amp;gt;&quot; следует рассматривать как ошибку.</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">Напоминаем авторам средств форматирования Pod, что &quot;= over&quot; ... &quot;= back&quot; может соответствовать нескольким различным конструкциям в вашем выходном формате. Например, при преобразовании Pod в (X) HTML он может отображаться на любой из &amp;lt;ul&amp;gt; ... &amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt; ... &amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt; ... &amp;lt;/dl&amp;gt; , или &amp;lt;blockquote&amp;gt; ... &amp;lt;/blockquote&amp;gt;. Точно так же &quot;= item&quot; может отображаться на &amp;lt;li&amp;gt; или &amp;lt;dt&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">Авторы форматоров Pod должны обратить внимание на эту конструкцию:</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">Авторы форматеров/процессоров Pod должны приложить все усилия,чтобы избежать написания собственного парсера Pod.В CPAN уже есть несколько,с широким диапазоном стилей интерфейса --и один из них,Pod::Parser,поставляется с современными версиями Perl.</target>
        </trans-unit>
        <trans-unit id="ee6ba2eca154c452d912ba72284ef9425f5cac4c" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Simple, comes with modern versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">Авторы подклассов форматирования могут посчитать эти методы полезными для вызова объекта парсера,с которого вы еще не начали вытаскивать токены:</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">Автоматическое уменьшение значения в SV,при необходимости выполняя преобразование строки в числовую.Обрабатывает магию 'get' и перегрузку оператора.</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">Автоматическое уменьшение значения в SV,при необходимости выполняя преобразование строки в числовую.Обрабатывает перегрузку оператора.Пропускает обработку магии 'get'.</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">Авто-инкремент и авто-декремент</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">Автоматическое добавление значения в SV,при необходимости делая строковое преобразование в числовое.Обрабатывает магию 'get' и перегрузку оператора.</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">Автоматическое добавление значения в SV,при необходимости делая строковое преобразование в числовое.Обрабатывает перегрузку оператора.Пропускает обработку магии 'get'.</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">Автопогрузчик-загрузка подпрограммы только по требованию</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">AutoLoader может не найти файлы авторазбивки (или даже найти неправильные) в тех случаях, когда &lt;code&gt;@INC&lt;/code&gt; содержит относительные пути, &lt;b&gt;а&lt;/b&gt; программа выполняет &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4651f865ebaf11dee249fb89b162cf3da62c9078" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;chdir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5080d78f65857a5bb4650061f6068b73782d0765" translate="yes" xml:space="preserve">
          <source>AutoLoader vs. SelfLoader</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Автозагрузчики до Perl 5.002 имели немного другой интерфейс. Любые старые модули, использующие &lt;b&gt;AutoLoader,&lt;/b&gt; должны быть изменены на новый стиль вызова. Как правило , это просто означает , изменяющих требуют к использованию, добавив явную &lt;code&gt;'AUTOLOAD'&lt;/code&gt; импорта , если это необходимо, и удаления &lt;b&gt;AutoLoader&lt;/b&gt; из &lt;code&gt;@ISA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1e103fc57cef534d77a1863a7beda04c276011" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-разделить пакет для автозагрузки</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">Автосоздание констант</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodie использует простой набор категорий для группировки похожих встроенных функций. Запрос типа категории (начинающийся с двоеточия) включит автозапуск для всех встроенных модулей ниже этой категории. Например, запрос &lt;code&gt;:file&lt;/code&gt; включит autodie для &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d86d0ceb4ab6dfa49a2928ed69a6b234345c4271" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;fcntl&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;sysopen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; сгенерирует исключение, если &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; вернет false с любой другой ошибкой.</target>
        </trans-unit>
        <trans-unit id="dfa0c806bb2bafe199faa77554873951783b04df" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;flock&lt;/code&gt; will generate an exception if &lt;code&gt;flock&lt;/code&gt; returns false with any other error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">Автозагрузка и пакетная лексика</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">Автозагрузка с XSUB</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">Автоматическая бинарная установка</target>
        </trans-unit>
        <trans-unit id="e7b3540721074f2b16f8319edcdb7f16ebcac6ca" translate="yes" xml:space="preserve">
          <source>Automatic filehandle closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4347ed90164094c8291f74a6e4466cefbf468214" translate="yes" xml:space="preserve">
          <source>Automatic pipe flushing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">Автоматически создавать XSUB на основе объявлений функций в файле заголовка. Пакет &lt;code&gt;C::Scan&lt;/code&gt; должен быть установлен. Если указана эта опция, имя файла заголовка может выглядеть как &lt;code&gt;NAME1,NAME2&lt;/code&gt; . В этом случае NAME1 используется вместо указанной строки, но XSUB генерируются только для объявлений, включенных из файла NAME2.</target>
        </trans-unit>
        <trans-unit id="5d64745dc0e8fe8b3b6097336c3b9ed3a673cecd" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt;. In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">Автоматически предоставлять поддержку &lt;b&gt;--help&lt;/b&gt; и &lt;b&gt;-? &lt;/b&gt;options, если приложение не указало обработчик для самой этой опции.</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">Автоматически предоставлять поддержку опции &lt;b&gt;--version,&lt;/b&gt; если приложение не указало обработчик для самой этой опции.</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">Автоотношения чаще всего используются в модуле, к которому они фактически привязаны, и им необходимо экспортировать их атрибуты в любой модуль, который их вызывает. Чтобы облегчить это, Attribute :: Handlers распознает специальный &amp;laquo;псевдокласс&amp;raquo; - &lt;code&gt;__CALLER__&lt;/code&gt; , который может быть указан как квалификатор атрибута:</target>
        </trans-unit>
        <trans-unit id="caebe3a78fcebc80600d1c2befdf4f9537e79eaa" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt;, which may be specified as the qualifier of an attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b404ad26695e85bc7cc28bdc0dded7208f879f3b" translate="yes" xml:space="preserve">
          <source>Autovivification</source>
          <target state="translated">Autovivification</target>
        </trans-unit>
        <trans-unit id="bf3b722c40bbbb50ad0fb62696f5d22f07dbb403" translate="yes" xml:space="preserve">
          <source>AvFILL</source>
          <target state="translated">AvFILL</target>
        </trans-unit>
        <trans-unit id="90bf7946c287adae3d715c64ee31d396014df2f6" translate="yes" xml:space="preserve">
          <source>AvFILLp</source>
          <target state="translated">AvFILLp</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">Доступные плагины</target>
        </trans-unit>
        <trans-unit id="3f5fe2a468e50383b2ee86c82b0cbc98dd7d8c3d" translate="yes" xml:space="preserve">
          <source>Available Since 0.05.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">Доступные подпрограммы</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">Доступный экспорт</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">Доступно в Perls 5.8.1 и новее. Если установлено значение &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , поведение сигнала до Perl-5.8.0 (которое является немедленным, но небезопасным) восстанавливается. Если установлено значение &lt;code&gt;safe&lt;/code&gt; , используются безопасные (но отложенные) сигналы. См. &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Отложенные сигналы (безопасные сигналы) в perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86ef598431b2f464d3fea7c4a79b483722ad9f02" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt;, the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt;, then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">Доступно в версии 2.22 и выше.</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">Доступно в версии 2.32 и выше</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">Доступно в версии 2.66 и выше.</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">Доступно в версии 2.77 и выше.</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">Доступно в версии 2.99 и выше.</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">Доступно в версии 3.00 и выше.</target>
        </trans-unit>
        <trans-unit id="a51b57f95b46e8e4e842d85639326f6206ff272d" translate="yes" xml:space="preserve">
          <source>Available in version 6.18 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c501834b7b0b901f2df0d6603e7d6136330ca271" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_01 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2902c53bc06bcbcd50a3060b02d4d1a785d162" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_02 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">Доступно в версии 6.31 и выше.</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">Доступно в версии 6.46 и выше.</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">Доступно в версии 6.48 и выше.</target>
        </trans-unit>
        <trans-unit id="6813343f2b8479035fb49fea7be4fff847bf5d84" translate="yes" xml:space="preserve">
          <source>Available in version 6.51_01 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">Доступно в версии 6.52 и выше.</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">Доступно в версии 6.5503 и выше.</target>
        </trans-unit>
        <trans-unit id="50ef4d62519ad32b490887468033714841e5c394" translate="yes" xml:space="preserve">
          <source>Available in version 6.55_03 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94a4ea271ebeb34f1da9b94033460c66ab594da" translate="yes" xml:space="preserve">
          <source>Available in version 6.57_02 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">Доступно в версии 6.64 и выше.</target>
        </trans-unit>
        <trans-unit id="35008f0927cc370d80fa1feb2cb101b493da804e" translate="yes" xml:space="preserve">
          <source>Available in version 6.7501 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0f8c774f58768a8219ed32fc69bb6c645c818c" translate="yes" xml:space="preserve">
          <source>Available in version 6.8305 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a55162e32a4d313034aeda2facf36c09febf1e" translate="yes" xml:space="preserve">
          <source>Available in version 6.8502 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3781d883fbe89e1fc4d95fc3c8a343771b42879b" translate="yes" xml:space="preserve">
          <source>Available in version 7.12 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">Доступно на 64-битной OpenVMS 8.2 и более поздних версиях.(VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">Доступно только для дескрипторов сокетов, и он выполняет то же самое, что и &lt;code&gt;ioctlsocket()&lt;/code&gt; в Winsock API. (Win32)</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">Доступно только для ручек-розеток.(RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">Доступная только в многопоточных сборках, эта функция выделяет запись в &lt;code&gt;PL_stashpad&lt;/code&gt; для переданного ей тайника .</target>
        </trans-unit>
        <trans-unit id="24db3617e94fd8213371a29596a3d186b94b903d" translate="yes" xml:space="preserve">
          <source>Available since 0.05.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8904628a4cafc1997d22ed36de689160cc550e45" translate="yes" xml:space="preserve">
          <source>Available since 0.14.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b9977311f14febdb908b3d7c8768e488ba1bdf" translate="yes" xml:space="preserve">
          <source>Available since 0.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484973f71a15c235b16dffbc3bc34be0d16c15f0" translate="yes" xml:space="preserve">
          <source>Available since 0.19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf20cba49d40f80adc31be98bf7c874514e9c65b" translate="yes" xml:space="preserve">
          <source>Available since version 1.000020.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ebee27a76026f487f2506be21a330fd5bb55de" translate="yes" xml:space="preserve">
          <source>Available since version 2.141170.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c0a2e766dbfbf8f4dc8178b6428ab302e4b061" translate="yes" xml:space="preserve">
          <source>Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">Избегайте /usr/ucb/cc.</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">Избегайте использования &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; где можно использовать &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; и &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">Избегайте присвоений в условных выражениях, но если они неизбежны, используйте дополнительный парен, например, &amp;laquo;if (a &amp;amp;&amp;amp; (b = c)) ...&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">Избегайте пустых слов,если можете,особенно всех строчных.Вы не можете определить,является ли голое слово функцией или строкой.Используя кавычки на строках и круглые скобки на вызовах функций,вы никогда не запутаете их.</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">Избегайте проверки имени класса, например: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Как правило, вы можете удалить часть &lt;code&gt;eq 'FOO'&lt;/code&gt; без всякого вреда. Пусть предметы позаботятся о себе! Как правило, по возможности избегайте зашитых имен классов.</target>
        </trans-unit>
        <trans-unit id="6c6177d46cc76c5db51cee88fceed0a2c4936349" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt;. Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">Избегайте хранения любой государственной информации в ваших посылках.Это затрудняет использование вашего пакета несколькими другими пакетами.Хранить информацию о состоянии в объектах.</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">Избегайте либукба.</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">Избегайте запуска новой иерархии верхнего уровня,особенно если уже существует подходящая иерархия,под которую можно разместить модуль.</target>
        </trans-unit>
        <trans-unit id="e368cb46427a0a7114b3f3aa59a320144f3a18b6" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary quotes and stringification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">Избегайте использования &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (или &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ) или `обратных кавычек` в пустом контексте, то есть когда вы просто отбрасываете их возвращаемые значения. Все эти функции имеют возвращаемые значения, поэтому используйте их. В противном случае используйте вместо этого цикл &lt;code&gt;foreach()&lt;/code&gt; или функцию &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d1b147c04752308a754e45a088f0a5ced1e3189" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;grep()&lt;/code&gt; (or &lt;code&gt;map()&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;system()&lt;/code&gt; function instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">По возможности избегайте использования жестко закодированных номеров тестов (EXPECTED/GOT,найденный в t/op/tie.t,гораздо более удобен в обслуживании и дает лучшие отчеты о сбоях).</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">Избегайте использования qx//и system(),если только вы не тестируете их.Если вы используете их,убедитесь,что вы покрываете _all_perl платформы.</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">Избегание трубных тупиков</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">Предотвращение повторений</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">Оук Ловушки</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="960ee8c49bfa63dfbcee503c121c56c7a1e4101b" translate="yes" xml:space="preserve">
          <source>B *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">Б-Бэкэнд компилятора на Perl</target>
        </trans-unit>
        <trans-unit id="66cbfa5966aea2edc7cf64e032e34c46ba4f5e91" translate="yes" xml:space="preserve">
          <source>B line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="19869e35c46a3e66430c519067a6d3e7137c0ed7" translate="yes" xml:space="preserve">
          <source>B. Execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96bf8801b12adefc37c1e7fc962c4790aa5f3c1" translate="yes" xml:space="preserve">
          <source>B. K. Oxley (binkley),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B.UNPACK</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">В:::AV Методы</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">В::Биноп Метод</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">В::БМ Методы</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">В::Методы КС</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">В::CV Методы</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B::Краткое-Пройдитесь по синтаксическому дереву Perl,распечатав краткую информацию об операторах.</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B::Отладка-Прогулка по синтаксическому дереву Perl,печать отладочной информации об операционных системах</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B::Deparse-Бэкэнд компилятора Perl для генерации perl кода</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B::Депарсив также может быть использован на суб-субподоснове из других программ perl.</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparse - это внутренний модуль для компилятора Perl, который генерирует исходный код perl на основе внутренней скомпилированной структуры, которую сам perl создает после синтаксического анализа программы. Вывод B :: Deparse не будет в точности таким же, как исходный исходный код, поскольку perl не отслеживает комментарии или пробелы, и нет однозначного соответствия между синтаксическими конструкциями perl и их скомпилированными форма, но часто будет близко. Когда вы используете опцию &lt;b&gt;-p&lt;/b&gt; , вывод также включает круглые скобки, даже если они не требуются по приоритету, что может помочь увидеть, анализирует ли Perl ваши выражения так, как вы планировали.</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">В::GV методы</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">В::HV методы</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">В::IO Методы</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B::Объекты IO производятся от объектов IO,и вы получите больше информации от самого объекта IO.</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">В::IV Методы</target>
        </trans-unit>
        <trans-unit id="f3d775a1d64c4d9d033d742b01a011ef21c3139b" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">В::IV,В::NV,В::RV,В::PV,В::PVIV,В::PVNV,В::PVMG,В::BM (5.9.5 и ранее),В::PVLV,В::AV,В::HV,В::CV,В::GV,В::FM,В::IO.Эти классы в явном виде соответствуют лежащим в основе C структурам с похожими именами.Иерархия наследования имитирует лежащее в основе С &quot;наследование&quot;.Для ветви 5.10.x,(</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">В::Метод LISTOP</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">В::Метод ЛОГОПа</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">В::Методы LOOP</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">В::MAGIC Методы</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">В::Методы Метода Метода (с версии Perl 5.22)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">В::NV Методы</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">В::ОП Методы</target>
        </trans-unit>
        <trans-unit id="9f43dd0af65c2a7397a364fed7e94a6388954481" translate="yes" xml:space="preserve">
          <source>B::OP::terse</source>
          <target state="translated">B::OP::terse</target>
        </trans-unit>
        <trans-unit id="b8644ca464436a14d88fc7211463f2c65ed97695" translate="yes" xml:space="preserve">
          <source>B::Op_private</source>
          <target state="translated">B::Op_private</target>
        </trans-unit>
        <trans-unit id="67239ea053c2700f5ce63cb3454a4558b2cbf5e7" translate="yes" xml:space="preserve">
          <source>B::Op_private - OP op_private flag definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">В::Методы ПАДЛИСТА</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">В::ПАДНАМИ Методы</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">В::Методы ПАДНАМЕЛИСТА</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">В::Метод PADOP</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">В::PMOP Методы</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">В::PV методы</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">В:::PVLV Методы</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">В:::PVMG методы</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">В::PVOP Метод</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">В::REGEXP Методы</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">В::RV Методы</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">В::SV методы</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">В::SVOP методы</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B::Showlex-Показать лексические переменные,используемые в функциях или файлах</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B::Территория-Прогулка по синтаксическому дереву Perl,печать территориальной информации об операторах.</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">В::ЮНОП Метод</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">В::UNOP_AUX Методы (начиная с 5.22)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B::Xref-Генерирует отчеты по перекрёстным ссылкам для программ на Perl.</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">ОБРАТНАЯ СОВМЕСТИМОСТЬ И ОБЕСЦЕНИВАНИЕ</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">ОБРАТНАЯ СОВМЕСТИМОСТЬ</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">ОСНОВНЫЕ МЕТОДЫ</target>
        </trans-unit>
        <trans-unit id="aa6878b1c31a9420245df1daffb7b223338737a3" translate="yes" xml:space="preserve">
          <source>BBB</source>
          <target state="translated">BBB</target>
        </trans-unit>
        <trans-unit id="a76d28d6a4e36d4447b9f4c252abca9f3cac325b" translate="yes" xml:space="preserve">
          <source>BBEdit and TextWrangler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">ПЕРЕД НАЧАЛОМ НАПИСАНИЯ МОДУЛЯ</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="d94255a33af2a233413bdca7bd8b5cd50ff62d1b" translate="yes" xml:space="preserve">
          <source>BEGIN blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38cb5ebde363f32ca7879125654df658667bbf73" translate="yes" xml:space="preserve">
          <source>BEGIN failed--compilation aborted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70821eae507ac85cc9e07ce2b4ef46d0ec3667a3" translate="yes" xml:space="preserve">
          <source>BEGIN not safe after errors--compilation aborted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">Начало,УНИТЧЕК,ЧЕК,ИНИТ и КОНЕЦ</target>
        </trans-unit>
        <trans-unit id="ee1ec7cf5d1203d7be37071bc2244af5ad59b465" translate="yes" xml:space="preserve">
          <source>BEHAVIOR HOOKS</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
