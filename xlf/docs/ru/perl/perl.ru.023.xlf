<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d47de889df56d979834e9722ebde0c0a6a0fae68" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that keeps two surrounding strings from being confused with each other. The &lt;code&gt;split&lt;/code&gt; function works on separators. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;terminators&lt;/b&gt;. The &amp;ldquo;or&amp;rdquo; in the previous sentence separated the two alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc52a9bce5d37da72e4313c9442e3059934389e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that marks the end of another string. The &lt;code&gt;$/&lt;/code&gt; variable contains the string that terminates a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; operation, which &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; deletes from the end. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;separators&lt;/b&gt;. The period at the end of this sentence is a terminator.</source>
          <target state="translated">&lt;b&gt;Символ&lt;/b&gt; или &lt;b&gt;строка&lt;/b&gt; , которая знаменует конец другой строки. &lt;code&gt;$/&lt;/code&gt; Переменная содержит строку , которая завершает &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; операция, которая &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; удаляет с конца. Не путать с &lt;b&gt;разделителями&lt;/b&gt; или &lt;b&gt;разделителями&lt;/b&gt; . Точка в конце этого предложения - терминатор.</target>
        </trans-unit>
        <trans-unit id="d839106acdc670985a28069f0c98ef61f88fbf3e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that marks the end of another string. The &lt;code&gt;$/&lt;/code&gt; variable contains the string that terminates a &lt;code&gt;readline&lt;/code&gt; operation, which &lt;code&gt;chomp&lt;/code&gt; deletes from the end. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;separators&lt;/b&gt;. The period at the end of this sentence is a terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ccb7e4dc3cd3bdbacbf8b76f79619db792d436" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that sets bounds to an arbitrarily sized textual object, not to be confused with a &lt;b&gt;separator&lt;/b&gt; or &lt;b&gt;terminator&lt;/b&gt;. &amp;ldquo;To delimit&amp;rdquo; really just means &amp;ldquo;to surround&amp;rdquo; or &amp;ldquo;to enclose&amp;rdquo; (like these parentheses are doing).</source>
          <target state="translated">&lt;b&gt;Символ&lt;/b&gt; или &lt;b&gt;строка&lt;/b&gt; , которая устанавливает границы для произвольного размера текстового объекта, не следует путать с &lt;b&gt;сепаратором&lt;/b&gt; или &lt;b&gt;терминатором&lt;/b&gt; . &amp;laquo;Разграничивать&amp;raquo; на самом деле означает просто &amp;laquo;окружать&amp;raquo; или &amp;laquo;заключать&amp;raquo; (как в этих скобках).</target>
        </trans-unit>
        <trans-unit id="ea08291e93224eb22a8479c3ec9c014b05bce7f2" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that is</source>
          <target state="translated">&lt;b&gt;Характер&lt;/b&gt; , что является</target>
        </trans-unit>
        <trans-unit id="5cba1f2a968bf42f9b6478a5e49fa1b60b1a7141" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that moves your cursor but doesn&amp;rsquo;t otherwise put anything on your screen. Typically refers to any of: space, tab, line feed, carriage return, or form feed. In Unicode, matches many other characters that Unicode considers whitespace, including the ɴ-ʙʀ .</source>
          <target state="translated">&lt;b&gt;Персонаж&lt;/b&gt; , который перемещает курсор , но не иначе положить что - нибудь на экране. Обычно относится к любому из: пробела, табуляции, перевода строки, возврата каретки или перевода страницы. В Unicode соответствует многим другим символам, которые Unicode считает пробелами, включая ɴ-ɴ.</target>
        </trans-unit>
        <trans-unit id="2aa2a649bec9b1fd1ac1866bab10ba2afe8f796b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; defines the behavior of a category of objects. A class is a name for a category (like &quot;File&quot;), and a class also defines the behavior of objects in that category.</source>
          <target state="translated">&lt;b&gt;Класс&lt;/b&gt; определяет поведение категории объектов. Класс - это имя категории (например, &amp;laquo;Файл&amp;raquo;), и класс также определяет поведение объектов в этой категории.</target>
        </trans-unit>
        <trans-unit id="1a75079cb5fa51afe9c7f949ddf0f69d6f477b63" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; that defines some of its &lt;b&gt;methods&lt;/b&gt; in terms of a more generic class, called a &lt;b&gt;base class&lt;/b&gt;. Note that classes aren&amp;rsquo;t classified exclusively into base classes or derived classes: a class can function as both a derived class and a base class simultaneously, which is kind of classy.</source>
          <target state="translated">&lt;b&gt;Класс&lt;/b&gt; , который определяет некоторые из его &lt;b&gt;методов&lt;/b&gt; с точки зрения более общего класса, называется &lt;b&gt;базовым классом&lt;/b&gt; . Обратите внимание, что классы не классифицируются исключительно на базовые классы или производные классы: класс может одновременно функционировать как производный класс и как базовый класс, что в некотором роде классно.</target>
        </trans-unit>
        <trans-unit id="99d0667db3792046333bf54560031cc7b2ecf43e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt; to the computer about what to do next, like a step in a recipe: &amp;ldquo;Add marmalade to batter and mix until mixed.&amp;rdquo; A statement is distinguished from a &lt;b&gt;declaration&lt;/b&gt;, which doesn&amp;rsquo;t tell the computer to do anything, but just to learn something.</source>
          <target state="translated">&lt;b&gt;Команда&lt;/b&gt; к компьютеру о том , что делать дальше, как шаг в рецепте: &amp;laquo;Добавить мармелад в тесто и перемешать до смешанного.&amp;raquo; Заявление отличается от &lt;b&gt;объявления&lt;/b&gt; , которое не говорит компьютеру что-либо делать, а просто чему-то научиться.</target>
        </trans-unit>
        <trans-unit id="0c8b51997be5611d837a8ab6c5cb1982a471c7f6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt;-line &lt;b&gt;interpreter&lt;/b&gt;. The program that interactively gives you a prompt, accepts one or more &lt;b&gt;lines&lt;/b&gt; of input, and executes the programs you mentioned, feeding each of them their proper &lt;b&gt;arguments&lt;/b&gt; and input data. Shells can also execute scripts containing such commands. Under Unix, typical shells include the Bourne shell (</source>
          <target state="translated">&lt;b&gt;Команда&lt;/b&gt; -линии &lt;b&gt;переводчик&lt;/b&gt; . Программа, которая в интерактивном режиме дает вам подсказку, принимает одну или несколько &lt;b&gt;строк&lt;/b&gt; ввода и выполняет указанные вами программы, передавая каждой из них соответствующие &lt;b&gt;аргументы&lt;/b&gt; и входные данные. Оболочки также могут выполнять сценарии, содержащие такие команды. В Unix к типичным оболочкам относится оболочка Bourne (</target>
        </trans-unit>
        <trans-unit id="52e02137a3f5dfcbaf26aaed0daa92b24d1f6a82" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;conditional&lt;/b&gt; or &lt;b&gt;loop&lt;/b&gt; that you put after the &lt;b&gt;statement&lt;/b&gt; instead of before, if you know what we mean.</source>
          <target state="translated">&lt;b&gt;Условный&lt;/b&gt; или &lt;b&gt;цикл&lt;/b&gt; , что вы положили после &lt;b&gt;заявления&lt;/b&gt; вместо ранее, если вы знаете , что мы имеем в виду.</target>
        </trans-unit>
        <trans-unit id="8b7c0791290fe9b8909bf7acee3f40cc62fd3b4d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;constructor&lt;/b&gt; creates a new object. In Perl, a class's constructor is just another method, unlike some other languages, which provide syntax for constructors. Most Perl classes use &lt;code&gt;new&lt;/code&gt; as the name for their constructor:</source>
          <target state="translated">&lt;b&gt;Конструктор&lt;/b&gt; создает новый объект. В Perl конструктор класса - это просто еще один метод, в отличие от некоторых других языков, которые предоставляют синтаксис для конструкторов. Большинство классов Perl используют &lt;code&gt;new&lt;/code&gt; в качестве имени своего конструктора:</target>
        </trans-unit>
        <trans-unit id="7959cb1d43e022aebe37e1efd0d8727ca1bc0118" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;cracker&lt;/b&gt; who is not a &lt;b&gt;hacker&lt;/b&gt; but knows just enough to run canned scripts. A &lt;b&gt;cargo-cult&lt;/b&gt; programmer.</source>
          <target state="translated">&lt;b&gt;Взломщик&lt;/b&gt; , который не является &lt;b&gt;хакером&lt;/b&gt; , но знает достаточно просто запустить законсервированные скрипты. Программист &lt;b&gt;культа карго&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0c56375aec608f2fe483b5d49fe200437f6d13" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;data paragraph&lt;/b&gt;. This is a paragraph that</source>
          <target state="translated">&lt;b&gt;Пункт данных&lt;/b&gt; . Это абзац, который</target>
        </trans-unit>
        <trans-unit id="f4407d7bf8b4e86a5ab3d8b6cfe6f792d1bff9b9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that defines a &lt;b&gt;package&lt;/b&gt; of (almost) the same name, which can either &lt;b&gt;export&lt;/b&gt; symbols or function as an &lt;b&gt;object&lt;/b&gt; class. (A module&amp;rsquo;s main</source>
          <target state="translated">&lt;b&gt;Файл&lt;/b&gt; , который определяет &lt;b&gt;пакет&lt;/b&gt; (почти) с одноименным названием, который может либо &lt;b&gt;экспортировать&lt;/b&gt; символы или функции в качестве &lt;b&gt;объекта&lt;/b&gt; класса. (Основной модуль модуля</target>
        </trans-unit>
        <trans-unit id="560dff37fc95faf8528a7887fa6dc08d1b06155b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that is specially marked to tell the &lt;b&gt;operating system&lt;/b&gt; that it&amp;rsquo;s okay to run this file as a program. Usually shortened to &amp;ldquo;executable&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;Файл&lt;/b&gt; , который специально помечены , чтобы сообщить &lt;b&gt;операционной системе&lt;/b&gt; , что это нормально , чтобы запустить этот файл как программу. Обычно сокращается до &amp;laquo;исполняемый&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="832195e4157a51d08607c1f931cf313eaae32121" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that&amp;rsquo;s not a &lt;b&gt;directory&lt;/b&gt;, a &lt;b&gt;device&lt;/b&gt;, a named &lt;b&gt;pipe&lt;/b&gt; or &lt;b&gt;socket&lt;/b&gt;, or a &lt;b&gt;symbolic link&lt;/b&gt;. Perl uses the &lt;code&gt;&amp;ndash;f&lt;/code&gt; file test operator to identify regular files. Sometimes called a &amp;ldquo;plain&amp;rdquo; file.</source>
          <target state="translated">&lt;b&gt;Файл&lt;/b&gt; это не &lt;b&gt;каталог&lt;/b&gt; , &lt;b&gt;устройство&lt;/b&gt; , поименованные &lt;b&gt;трубы&lt;/b&gt; или &lt;b&gt;гнездо&lt;/b&gt; , или &lt;b&gt;символическая ссылка&lt;/b&gt; . Perl использует оператор проверки файлов &lt;code&gt;&amp;ndash;f&lt;/code&gt; для идентификации обычных файлов. Иногда называется &amp;laquo;обычным&amp;raquo; файлом.</target>
        </trans-unit>
        <trans-unit id="ed2a6a7fae032e7b7f63170d07ec12a9d190796a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; call directly to the &lt;b&gt;operating system&lt;/b&gt;. Many of the important subroutines and functions you use aren&amp;rsquo;t direct system calls, but are built up in one or more layers above the system call level. In general, Perl programmers don&amp;rsquo;t need to worry about the distinction. However, if you do happen to know which Perl functions are really syscalls, you can predict which of these will set the &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) variable on failure. Unfortunately, beginning programmers often confusingly employ the term &amp;ldquo;system call&amp;rdquo; to mean what happens when you call the Perl &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function, which actually involves many syscalls. To avoid any confusion, we nearly always say &amp;ldquo;syscall&amp;rdquo; for something you could call indirectly via Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function, and never for something you would call with Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;b&gt;Функция&lt;/b&gt; вызова непосредственно в &lt;b&gt;операционной системе&lt;/b&gt; . Многие из важных подпрограмм и функций, которые вы используете, не являются прямыми системными вызовами, а построены на одном или нескольких уровнях выше уровня системного вызова. В общем, программисты Perl не должны беспокоиться о различиях. Однако, если вы знаете, какие функции Perl на самом деле являются системными вызовами, вы можете предсказать, какая из них установит &lt;code&gt;$!&lt;/code&gt; ( &lt;code&gt;$ERRNO&lt;/code&gt; ) при сбое. К сожалению, начинающие программисты часто используют смешение термина &amp;laquo;системный вызов&amp;raquo; означают , что происходит , когда вы вызываете Perl &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; функция, которая на самом деле включает в себя множество системных вызовов. Чтобы избежать путаницы, мы почти всегда говорим &amp;laquo;syscall&amp;raquo; для того, что вы можете вызвать косвенно через функцию &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; Perl , и никогда для того, что вы вызываете с помощью &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; функции Perl .</target>
        </trans-unit>
        <trans-unit id="dcd5ec0f720736e7e329b0a32b061d1c915a3b97" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; call directly to the &lt;b&gt;operating system&lt;/b&gt;. Many of the important subroutines and functions you use aren&amp;rsquo;t direct system calls, but are built up in one or more layers above the system call level. In general, Perl programmers don&amp;rsquo;t need to worry about the distinction. However, if you do happen to know which Perl functions are really syscalls, you can predict which of these will set the &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt;) variable on failure. Unfortunately, beginning programmers often confusingly employ the term &amp;ldquo;system call&amp;rdquo; to mean what happens when you call the Perl &lt;code&gt;system&lt;/code&gt; function, which actually involves many syscalls. To avoid any confusion, we nearly always say &amp;ldquo;syscall&amp;rdquo; for something you could call indirectly via Perl&amp;rsquo;s &lt;code&gt;syscall&lt;/code&gt; function, and never for something you would call with Perl&amp;rsquo;s &lt;code&gt;system&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dedded5626e20b474bf02bc245fb0066d03ede" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; that is predefined in the language. Even when hidden by &lt;b&gt;overriding&lt;/b&gt;, you can always get at a built- in function by &lt;b&gt;qualifying&lt;/b&gt; its name with the &lt;code&gt;CORE::&lt;/code&gt; pseudopackage.</source>
          <target state="translated">&lt;b&gt;Функция&lt;/b&gt; , которая предопределена на языке. Даже если она скрыта путем &lt;b&gt;переопределения&lt;/b&gt; , вы всегда можете получить доступ к встроенной функции, &lt;b&gt;уточнив&lt;/b&gt; ее имя с помощью псевдопакета &lt;code&gt;CORE::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="017327ec6f67ab86c897b578939f74863c44350b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;grapheme&lt;/b&gt; consisting of either a carriage return followed by a line feed or any character with the Unicode Vertical Space &lt;b&gt;character property&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Графема&lt;/b&gt; , состоящий либо возврат каретки с последующим переводом строки или любой символ с Unicode вертикального пространства &lt;b&gt;свойства символа&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="8ef4c16c3e84bcc76d6d7f8f70086c0645d39a22" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;handler&lt;/b&gt; that you register with some other part of your program in the hope that the other part of your program will &lt;b&gt;trigger&lt;/b&gt; your handler when some event of interest transpires.</source>
          <target state="translated">&lt;b&gt;Обработчик&lt;/b&gt; , который вы регистрируетесь с какой - либо другой частью программы в надежде , что другая часть вашей программы будет &lt;b&gt;вызывать&lt;/b&gt; обработчик , когда какое - либо событие процентных Выясняется.</target>
        </trans-unit>
        <trans-unit id="9a3af3525966bde47d8478ba5aa28630e345cb9d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;lexical variable&lt;/b&gt; lexical&amp;gt;that is declared with a &lt;b&gt;class&lt;/b&gt; type: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Pony $bill&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;Лексическая переменная&lt;/b&gt; лексическая&amp;gt; , который объявлен с &lt;b&gt;классом&lt;/b&gt; типа: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Pony $bill&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0039cc9cd8e39570b8877a1785674415311675e9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;lexical variable&lt;/b&gt; lexical&amp;gt;that is declared with a &lt;b&gt;class&lt;/b&gt; type: &lt;code&gt;my Pony $bill&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3163207648959163d9c84cb3f038389746ed27" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;line&lt;/b&gt; in a file consists of zero or more non-newline characters, terminated by either a newline or the end of the file.</source>
          <target state="translated">&lt;b&gt;Строка&lt;/b&gt; в файле состоит из нуля или более не новой строки символов, заканчивающихся либо символ новой строки или конец файла.</target>
        </trans-unit>
        <trans-unit id="e216248dbe62e4deb5d290410cf6cba07540c708" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;list value&lt;/b&gt; with zero elements, represented in Perl by &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">Значение &lt;b&gt;списка&lt;/b&gt; с нулевыми элементами, представленное в Perl знаком &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab4abc50479b714a6d10020d55e78dc7b1940fd" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;list value&lt;/b&gt; with zero elements, represented in Perl by &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d256991d914c75f7b2e344bf10f0577b5147db" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;, as opposed to a &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Метод&lt;/b&gt; из &lt;b&gt;объекта&lt;/b&gt; , в отличие от &lt;b&gt;метода класса&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cd9f719db48a7ef2cd4cdce77f9516eff0561abe" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; used to indirectly inspect or update an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state (its &lt;b&gt;instance variables&lt;/b&gt;).</source>
          <target state="translated">&lt;b&gt;Метод&lt;/b&gt; используется для проверки или косвенно обновить &lt;b&gt;объект&lt;/b&gt; &amp;laquo;S State (его &lt;b&gt;переменный экземпляр&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f76f67b831d3545d647111a95485f14adb897eb" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is a &lt;b&gt;package&lt;/b&gt; name, not an &lt;b&gt;object&lt;/b&gt; reference. A method associated with the class as a whole. Also see &lt;b&gt;instance method&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Метод&lt;/b&gt; которого &lt;b&gt;invocant&lt;/b&gt; является &lt;b&gt;пакет&lt;/b&gt; имя, не является &lt;b&gt;объектом&lt;/b&gt; ссылка. Метод, связанный с классом в целом. Также см. &lt;b&gt;Метод экземпляра&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="67eb1a20651dea215f187f74f8fc385e50d58eac" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is an &lt;b&gt;object&lt;/b&gt;, not a &lt;b&gt;package&lt;/b&gt; name. Every object of a class shares all the methods of that class, so an instance method applies to all instances of the class, rather than applying to a particular instance. Also see &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Метод&lt;/b&gt; которого &lt;b&gt;invocant&lt;/b&gt; является &lt;b&gt;объектом&lt;/b&gt; , а не &lt;b&gt;пакет&lt;/b&gt; имя. Каждый объект класса разделяет все методы этого класса, поэтому метод экземпляра применяется ко всем экземплярам класса, а не к конкретному экземпляру. Также см. &lt;b&gt;Метод класса&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9a608f9301d7c9b44868aa9a54155b51fc141a42" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;mortal&lt;/b&gt; SV.</source>
          <target state="translated">&lt;b&gt;Смертный&lt;/b&gt; SV.</target>
        </trans-unit>
        <trans-unit id="53f7bde55489a9151bd15ee3f737a362e089a682" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;namespace&lt;/b&gt; for global &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;subroutines&lt;/b&gt;, and the like, such that they can be kept separate from like-named &lt;b&gt;symbols&lt;/b&gt; in other namespaces. In a sense, only the package is global, since the symbols in the package&amp;rsquo;s symbol table are only accessible from code &lt;b&gt;compiled&lt;/b&gt; outside the package by naming the package. But in another sense, all package symbols are also globals&amp;mdash;they&amp;rsquo;re just well-organized globals.</source>
          <target state="translated">Пространство &lt;b&gt;имен&lt;/b&gt; для глобальных &lt;b&gt;переменных&lt;/b&gt; , &lt;b&gt;подпрограмм&lt;/b&gt; и т.п., так что их можно хранить отдельно от одноименных &lt;b&gt;символов&lt;/b&gt; в других пространствах имен. В некотором смысле глобальным является только пакет, поскольку символы в таблице символов пакета доступны только из кода, &lt;b&gt;скомпилированного&lt;/b&gt; вне пакета, путем присвоения имени пакету. Но в другом смысле все символы пакетов также являются глобальными - это просто хорошо организованные глобальные переменные.</target>
        </trans-unit>
        <trans-unit id="28abc12d5fd2eda36e36f614d582aeb865b478e3" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;newline sequence&lt;/b&gt; is usually a platform-dependent concept, but Pod parsers should understand it to mean any of CR (ASCII 13), LF (ASCII 10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in addition to any other system-specific meaning. The first CR/CRLF/LF sequence in the file may be used as the basis for identifying the newline sequence for parsing the rest of the file.</source>
          <target state="translated">Последовательность &lt;b&gt;новой строки&lt;/b&gt; обычно зависит от платформы, но парсеры Pod должны понимать, что она означает любой из CR (ASCII 13), LF (ASCII 10) или CRLF (ASCII 13, за которым сразу следует ASCII 10), в дополнение к любому другое системное значение. Первая последовательность CR / CRLF / LF в файле может использоваться в качестве основы для идентификации последовательности новой строки для анализа остальной части файла.</target>
        </trans-unit>
        <trans-unit id="28a5d8434506c4b65f1bc6f82e7222a2e44f2923" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pipe&lt;/b&gt; with a name embedded in the &lt;b&gt;filesystem&lt;/b&gt; so that it can be accessed by two unrelated &lt;b&gt;processes&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Труба&lt;/b&gt; с именем встроенного в &lt;b&gt;файловой системе&lt;/b&gt; , так что она может быть доступны два неродственными &lt;b&gt;процессами&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b07ce80ba704512a4daf926d6423f21ae6d581f7" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pod&lt;/b&gt; directive. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;Стручок&lt;/b&gt; директива. См. Главу 23 Camel &amp;laquo;Обычная старая документация&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a7bb769998e6fdfcf3ee0c66d7f29c1ed39a8790" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pumpkin&lt;/b&gt; holder, the person in charge of pumping the pump, or at least priming it. Must be willing to play the part of the Great Pumpkin now and then.</source>
          <target state="translated">&lt;b&gt;Тыквы&lt;/b&gt; держатель, лицо, ответственное за откачки насоса, или , по крайней мере , заливка его. Должен быть готов время от времени играть роль Великой Тыквы.</target>
        </trans-unit>
        <trans-unit id="e6f9796d5e8ba560b9616a39b17ea2e32ae9ff4b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; component potentially matching a &lt;b&gt;substring&lt;/b&gt; containing one or more characters and treated as an indivisible syntactic unit by any following &lt;b&gt;quantifier&lt;/b&gt;. (Contrast with an &lt;b&gt;assertion&lt;/b&gt; that matches something of &lt;b&gt;zero width&lt;/b&gt; and may not be quantified.)</source>
          <target state="translated">&lt;b&gt;Регулярное выражение&lt;/b&gt; компонент потенциально согласовани &lt;b&gt;подстроки&lt;/b&gt; , содержащую один или несколько символов и рассматриваются как неделимая синтаксическая единица любого следующего &lt;b&gt;квантором&lt;/b&gt; . (Сравните это с &lt;b&gt;утверждением,&lt;/b&gt; которое соответствует чему-то &lt;b&gt;нулевой ширины&lt;/b&gt; и не может быть определено количественно.)</target>
        </trans-unit>
        <trans-unit id="a4efc9f0f784617b2ff5677e0ce1302bbda5d4d6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; subpattern whose real purpose is to execute some Perl code&amp;mdash;for example, the &lt;code&gt;(?{...})&lt;/code&gt; and &lt;code&gt;(??{...})&lt;/code&gt; subpatterns.</source>
          <target state="translated">&lt;b&gt;Регулярное выражение&lt;/b&gt; подшаблон, действительная цель состоит в том, чтобы выполнить некоторые Perl код, например, &lt;code&gt;(?{...})&lt;/code&gt; и &lt;code&gt;(??{...})&lt;/code&gt; подшаблонами.</target>
        </trans-unit>
        <trans-unit id="b7ffd563f4456054759e7694e65ebb89f76facae" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;scalar&lt;/b&gt;&lt;b&gt;value&lt;/b&gt; containing the actual address of a &lt;b&gt;referent&lt;/b&gt;, such that the referent&amp;rsquo;s &lt;b&gt;reference&lt;/b&gt; count accounts for it. (Some hard references are held internally, such as the implicit reference from one of a &lt;b&gt;typeglob&lt;/b&gt;&amp;rsquo;s variable slots to its corresponding referent.) A hard reference is different from a &lt;b&gt;symbolic reference&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Скалярное &lt;/b&gt;&lt;b&gt;значение&lt;/b&gt; , содержащее фактический адрес &lt;b&gt;референта&lt;/b&gt; , таким образом, что референт в &lt;b&gt;опорном&lt;/b&gt; счетчике счет за него. (Некоторые жесткие ссылки хранятся внутри, например неявная ссылка из одного из &lt;b&gt;слотов&lt;/b&gt; переменных &lt;b&gt;typeglob&lt;/b&gt; на соответствующий ему референт.) Жесткая ссылка отличается от &lt;b&gt;символьной ссылки&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5022eeaf3b922dfb2c6df5364e9c4781dc19e0ff" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;stash&lt;/b&gt; is a hash that contains all variables that are defined within a package. Each key of the stash is a symbol name (shared by all the different types of objects that have the same name), and each value in the hash table is a GV (Glob Value). This GV in turn contains references to the various objects of that name, including (but not limited to) the following:</source>
          <target state="translated">&lt;b&gt;Копить&lt;/b&gt; хэш , который содержит все переменные, которые определены в пакете. Каждый ключ тайника - это имя символа (общее для всех различных типов объектов с одинаковыми именами), а каждое значение в хеш-таблице - это GV (Glob Value). Этот GV, в свою очередь, содержит ссылки на различные объекты с таким именем, включая (но не ограничиваясь) следующие:</target>
        </trans-unit>
        <trans-unit id="92b538532d72576aaeda7a7cef805a1cba7aaa2a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; containing no characters, not to be confused with a string containing a &lt;b&gt;null character&lt;/b&gt;, which has a positive length and is &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Строка&lt;/b&gt; , не содержащая символов, не следует путать со строкой , содержащей &lt;b&gt;нулевой символ&lt;/b&gt; , который имеет положительную длину и является &lt;b&gt;истинным&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d02500198bfb1874e50da33c4e532a6d834d3e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; or &lt;b&gt;file&lt;/b&gt; containing primarily printable characters.</source>
          <target state="translated">&lt;b&gt;Строка&lt;/b&gt; или &lt;b&gt;файл&lt;/b&gt; , содержащий в основном печатаемые символы.</target>
        </trans-unit>
        <trans-unit id="963346bf337afa73872e46c5b7ebdcda13950ed0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subpattern&lt;/b&gt; whose &lt;b&gt;quantifier&lt;/b&gt; wants to match as many things as possible.</source>
          <target state="translated">&lt;b&gt;Подшаблон&lt;/b&gt; которого &lt;b&gt;квантор&lt;/b&gt; хочет , чтобы соответствовать как много вещей , как это возможно.</target>
        </trans-unit>
        <trans-unit id="b40a047ee9609abd7c464a0e25538925a09e0994" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;method&lt;/b&gt; that Perl calls when your program needs to respond to some internal event, such as a &lt;b&gt;signal&lt;/b&gt;, or an encounter with an operator subject to &lt;b&gt;operator overloading&lt;/b&gt;. See also &lt;b&gt;callback&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Подпрограмма&lt;/b&gt; или &lt;b&gt;метод&lt;/b&gt; , который Perl вызывает , когда ваши потребности программы , чтобы ответить на некоторые внутренние события, такие как &lt;b&gt;сигнал&lt;/b&gt; , или при встрече с оператором при условии &lt;b&gt;перегрузки операторов&lt;/b&gt; . См. Также &lt;b&gt;обратный вызов&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b88557bd91c6ee2c1cde6ebbe7211914850d4976" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; that, instead of being content to be called in the normal fashion, sits around waiting for a bolt out of the blue before it will deign to &lt;b&gt;execute&lt;/b&gt;. Under Perl, bolts out of the blue are called signals, and you send them with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in. See the &lt;code&gt;%SIG&lt;/code&gt; hash in Camel chapter 25, &amp;ldquo;Special Names&amp;rdquo; and the section &amp;ldquo;Signals&amp;rdquo; in Camel chapter 15, &amp;ldquo;Interprocess Communication&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;Подпрограмма&lt;/b&gt; , что, вместо того , чтобы содержание называться обычным способом, сидит сложа руки , ожидая гром среди ясного неба , прежде чем он соизволит &lt;b&gt;выполнить&lt;/b&gt; . В Perl неожиданные сообщения называются сигналами, и вы отправляете их со встроенной &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; . См. Хэш &lt;code&gt;%SIG&lt;/code&gt; в Camel, глава 25, &amp;laquo;Специальные имена&amp;raquo;, и раздел &amp;laquo;Сигналы&amp;raquo; в Camel, глава 15, &amp;laquo;Межпроцессное взаимодействие&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6eb90f749c779c72ed00584c8a37ccf80a60ff84" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; that, instead of being content to be called in the normal fashion, sits around waiting for a bolt out of the blue before it will deign to &lt;b&gt;execute&lt;/b&gt;. Under Perl, bolts out of the blue are called signals, and you send them with the &lt;code&gt;kill&lt;/code&gt; built-in. See the &lt;code&gt;%SIG&lt;/code&gt; hash in Camel chapter 25, &amp;ldquo;Special Names&amp;rdquo; and the section &amp;ldquo;Signals&amp;rdquo; in Camel chapter 15, &amp;ldquo;Interprocess Communication&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322f029b3b0fb52a6b3d088717d1bec9ab25e434" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Подпрограмма&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="76724a25473397cad776a8c2a824ea6f3262e159" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;symbol&lt;/b&gt; such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; that tells Perl to do the arithmetic you were supposed to learn in grade school.</source>
          <target state="translated">Такой &lt;b&gt;символ&lt;/b&gt; , как &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;/&lt;/code&gt; , который говорит Perl выполнять арифметические действия, которые вы должны были выучить в начальной школе.</target>
        </trans-unit>
        <trans-unit id="d32877203298997d4e4d665fab49d7f32caf1082" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; chosen for you if you don&amp;rsquo;t supply a value of your own.</source>
          <target state="translated">&lt;b&gt;Значение&lt;/b&gt; выбрано для вас , если вы не предоставите ценность самостоятельно.</target>
        </trans-unit>
        <trans-unit id="87af2986b4851cce0bdd68d60a1169a1374d676b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that indicates the position of a particular &lt;b&gt;array&lt;/b&gt;&lt;b&gt;element&lt;/b&gt; in an array.</source>
          <target state="translated">&lt;b&gt;Значение&lt;/b&gt; , которое указывает положение конкретного &lt;b&gt;массива &lt;/b&gt;&lt;b&gt;элемента&lt;/b&gt; в массиве.</target>
        </trans-unit>
        <trans-unit id="56587e718c7ecb23875006ffccf7c7d756c6fa62" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that you might find on the right side of an &lt;b&gt;assignment&lt;/b&gt;. See also &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Значение&lt;/b&gt; , которые вы можете найти на правой стороне на &lt;b&gt;уступки&lt;/b&gt; . См. Также &lt;b&gt;lvalue&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="99b9fdd9de86d1d00f397b16abef1b9cafbc97c4" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; in a language like C that contains the exact memory location of some other item. Perl handles pointers internally so you don&amp;rsquo;t have to worry about them. Instead, you just use symbolic pointers in the form of &lt;b&gt;keys&lt;/b&gt; and &lt;b&gt;variable&lt;/b&gt; names, or &lt;b&gt;hard references&lt;/b&gt;, which aren&amp;rsquo;t pointers (but act like pointers and do in fact contain pointers).</source>
          <target state="translated">&lt;b&gt;Переменная&lt;/b&gt; в языке , как C , который содержит точное местоположение памяти какого - либо другого элемента. Perl обрабатывает указатели внутренне, поэтому вам не нужно о них беспокоиться. Вместо этого вы просто используете символические указатели в форме &lt;b&gt;ключей&lt;/b&gt; и имен &lt;b&gt;переменных&lt;/b&gt; или &lt;b&gt;жестких ссылок&lt;/b&gt; , которые не являются указателями (но действуют как указатели и фактически содержат указатели).</target>
        </trans-unit>
        <trans-unit id="51c90d619538801ef4598602775b97c77a42912f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; prefixed with &lt;code&gt;$&lt;/code&gt; that holds a single value.</source>
          <target state="translated">&lt;b&gt;Переменная&lt;/b&gt; с префиксом &lt;code&gt;$&lt;/code&gt; , который содержит одно значение.</target>
        </trans-unit>
        <trans-unit id="a036ff35f0b4159168ba2281ee65e4b238ac5692" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="translated">&lt;b&gt;Переменный&lt;/b&gt; с учетом &lt;b&gt;лексической области видимости&lt;/b&gt; , заявленным &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . Часто просто &amp;laquo;лексический&amp;raquo;. (В &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; объявлении объявляется имя с лексической областью видимости для глобальной переменной, которая сама по себе не является лексической переменной.)</target>
        </trans-unit>
        <trans-unit id="06985481b8abaac45139622f2df52c61b1d4a275" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;my&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;our&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d364f02d6990848dc623c28306b3b67cfe16a460" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;verbatim paragraph&lt;/b&gt;. The first line of this paragraph must be a literal space or tab, and this paragraph must not be inside a &quot;=begin</source>
          <target state="translated">&lt;b&gt;Дословное пункт&lt;/b&gt; . Первая строка этого абзаца должна быть буквальным пробелом или табуляцией, и этот абзац не должен находиться внутри символа &quot;= begin</target>
        </trans-unit>
        <trans-unit id="42c5695455abfd814bba117ac56b83739b6fccd8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2475be186a7213d2a980a851a800269b2e5a86" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for unpack(), also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="translated">Группа &lt;code&gt;()&lt;/code&gt; - это вложенный ШАБЛОН, заключенный в круглые скобки. Группа может вести подсчет повторов либо как postfix, либо как unpack (), также через символ &lt;code&gt;/&lt;/code&gt; template. В каждом повторении группы позиционирование с &lt;code&gt;@&lt;/code&gt; начинается заново с 0. Следовательно, результат</target>
        </trans-unit>
        <trans-unit id="a287ce1841efe5bc899e4207e715388b0c45e263" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; allows the subroutine to accept a bareword, constant, scalar expression, typeglob, or a reference to a typeglob in that slot. The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob. If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:</source>
          <target state="translated">A &lt;code&gt;*&lt;/code&gt; позволяет подпрограмме принимать голое слово, константу, скалярное выражение, typeglob или ссылку на typeglob в этом слоте. Значение будет доступно подпрограмме либо как простой скаляр, либо (в последних двух случаях) как ссылка на typeglob. Если вы хотите всегда преобразовывать такие аргументы в ссылку typeglob, используйте Symbol :: qualify_to_ref () следующим образом:</target>
        </trans-unit>
        <trans-unit id="175dabd836c19199f903fe2faf157b003fcf09ec" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, nybbles are converted to a string of hexadecimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61da191aeee246a70549905e1a2b4d958c2fd1c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For unpack(), nybbles are converted to a string of hexadecimal digits.</source>
          <target state="translated">A &lt;code&gt;*&lt;/code&gt; для счетчика повторов использует все символы поля ввода. Для unpack () nybbles преобразуются в строку шестнадцатеричных цифр.</target>
        </trans-unit>
        <trans-unit id="815c847c3d1b9e3c91a01ec8d23807326737a6a0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt; s and &lt;code&gt;1&lt;/code&gt; s.</source>
          <target state="translated">A &lt;code&gt;*&lt;/code&gt; для счетчика повторов использует все символы поля ввода. При распаковке биты преобразуются в строку из &lt;code&gt;0&lt;/code&gt; с и &lt;code&gt;1&lt;/code&gt; с.</target>
        </trans-unit>
        <trans-unit id="f9e01e48d826d5a43209d5317fe5971b7609b128" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt;s and &lt;code&gt;1&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c65ec9d77b183c5b39e5d9c73a8c71422dfc22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--&lt;/code&gt; signals the end of options and disables further option processing. Any arguments after the &lt;code&gt;--&lt;/code&gt; are treated as filenames and arguments.</source>
          <target state="translated">A &lt;code&gt;--&lt;/code&gt; сигнализирует об окончании опций и отключает дальнейшую обработку опций. Любые аргументы после &lt;code&gt;--&lt;/code&gt; обрабатываются как имена файлов и аргументы.</target>
        </trans-unit>
        <trans-unit id="bde6ae184752daa5e5b6a5c7417008782a0b714a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="translated">Ошибка &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; может привести к сбою следующих тестов:</target>
        </trans-unit>
        <trans-unit id="290859ef4b0199eb4b067a5c07f38a6730cc7301" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized variable, the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; просто модификатор на выражении - значения. При назначении в &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; роскопию переменной, &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; не меняется ли его список рассматривается как скаляр или массив. Так</target>
        </trans-unit>
        <trans-unit id="1ac670f70b9818c1a06875d85552011a54fbdd94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; --and to</source>
          <target state="translated">А &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; модифицирую перечисленный переменные , чтобы быть &amp;laquo;локальными&amp;raquo; в вмещающем блоке, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; -й в</target>
        </trans-unit>
        <trans-unit id="5e64f0ec46a4ae84b19fc32e43ef29768338a5a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; объявляет перечисленные переменные локальными (лексически) в ограждающих блок, файл или &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если указано более одной переменной, список должен быть заключен в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="f1479b4bde8f3dbb0c16d564288196fd25f56ff5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; имеет как во время компиляции и во время выполнения эффекта. Во время компиляции компилятор замечает это. Основная полезность этого заключается в том, чтобы спокойно &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , но это также важно для генерации замыканий, как подробно описано в &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; . Однако фактическая инициализация откладывается до времени выполнения, поэтому она выполняется в подходящее время, например, каждый раз через цикл.</target>
        </trans-unit>
        <trans-unit id="31962f6029a8a1eb17179745d335b5ef4fc0067e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; утверждение может быть использовано для выхода из подпрограммы, при необходимости указав возвращаемое значение, которое будет оцениваться в соответствующем контексте (список, скаляр или пустоты) , в зависимости от контекста вызова подпрограммы. Если вы не укажете возвращаемое значение, подпрограмма вернет пустой список в контексте списка, неопределенное значение в скалярном контексте или ничего в пустом контексте. Если вы вернете один или несколько агрегатов (массивов и хэшей), они будут сведены вместе в один большой неразличимый список.</target>
        </trans-unit>
        <trans-unit id="0e88bf889822c4c5cba2a75e272c3a1e9aeaadd3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; объявляет перечисленные переменные локальными (лексически) в ограждающих блок, файл или &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; . Если указано более одной переменной, список должен быть заключен в круглые скобки.</target>
        </trans-unit>
        <trans-unit id="7218467ff9ee5b0a5da705bdf5367f50f9fd934e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that has no matching =end command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e47480cd5deac560f9564740a3fdd3588ea30d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that is not followed by the formatter specification.</source>
          <target state="translated">Обнаружена команда &lt;code&gt;=begin&lt;/code&gt; , за которой не следует спецификация средства форматирования.</target>
        </trans-unit>
        <trans-unit id="5a9827f3a3a35194fce6eb84ce82e990f6ef9b53" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=cut&lt;/code&gt; command was found without a preceding POD paragraph.</source>
          <target state="translated">Обнаружена команда A &lt;code&gt;=cut&lt;/code&gt; без предшествующего абзаца POD.</target>
        </trans-unit>
        <trans-unit id="4af95277282f9dbbdb980c39fe078720a20bab01" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=pod&lt;/code&gt; command was found after a preceding POD paragraph.</source>
          <target state="translated">Команда A &lt;code&gt;=pod&lt;/code&gt; была найдена после предыдущего абзаца POD.</target>
        </trans-unit>
        <trans-unit id="31f4edd1c949bdbda291e425d6bef6044643ffd6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BEGIN&lt;/code&gt; code block is executed as soon as possible, that is, the moment it is completely defined, even before the rest of the containing file (or string) is parsed. You may have multiple &lt;code&gt;BEGIN&lt;/code&gt; blocks within a file (or eval'ed string); they will execute in order of definition. Because a &lt;code&gt;BEGIN&lt;/code&gt; code block executes immediately, it can pull in definitions of subroutines and such from other files in time to be visible to the rest of the compile and run time. Once a &lt;code&gt;BEGIN&lt;/code&gt; has run, it is immediately undefined and any code it used is returned to Perl's memory pool.</source>
          <target state="translated">Блок кода &lt;code&gt;BEGIN&lt;/code&gt; выполняется как можно скорее, то есть в тот момент, когда он полностью определен, даже до того, как остальная часть содержащего файла (или строки) будет проанализирована. У вас может быть несколько блоков &lt;code&gt;BEGIN&lt;/code&gt; в файле (или в строке eval); они будут выполняться в порядке определения. Поскольку &lt;code&gt;BEGIN&lt;/code&gt; кода BEGIN выполняется немедленно, он может вовремя извлекать определения подпрограмм и тому подобное из других файлов, чтобы они были видны остальной части времени компиляции и выполнения. После запуска &lt;code&gt;BEGIN&lt;/code&gt; он сразу же становится неопределенным, и любой код, который он использовал, возвращается в пул памяти Perl.</target>
        </trans-unit>
        <trans-unit id="3948c72682ed13a39df444bd90a131ad77b87fa0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;File::Fetch&lt;/code&gt; object has the following accessors</source>
          <target state="translated">Объект &lt;code&gt;File::Fetch&lt;/code&gt; имеет следующие методы доступа</target>
        </trans-unit>
        <trans-unit id="a0df5f12010c9e2a341950853965986995045017" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MAYBE&lt;/code&gt; string should contain at least one combining character or the like. For example, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; has the MAYBE_NFC/MAYBE_NFKC property.</source>
          <target state="translated">&lt;code&gt;MAYBE&lt;/code&gt; строка должна содержать , по меньшей мере , один символ , сочетающий или тому подобное. Например, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; имеет свойство MAYBE_NFC / MAYBE_NFKC.</target>
        </trans-unit>
        <trans-unit id="d9aa930129748b8e7f36983538600e4ef3003dd2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NUL&lt;/code&gt; character will be written after the end of the string.</source>
          <target state="translated">&lt;code&gt;NUL&lt;/code&gt; символ будет написан после того, как в конце строки.</target>
        </trans-unit>
        <trans-unit id="14e49abd4463a2df704c3d0c251781f20f08e519" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PerlIOl *&lt;/code&gt; is a pointer to the struct, and the</source>
          <target state="translated">&lt;code&gt;PerlIOl *&lt;/code&gt; это указатель на структуру, и</target>
        </trans-unit>
        <trans-unit id="e73ed792e4d7284609d9e1372b30eccc321faca0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SelectSaver&lt;/code&gt; object contains a reference to the file handle that was selected when it was created. If its &lt;code&gt;new&lt;/code&gt; method gets an extra parameter, then that parameter is selected; otherwise, the selected file handle remains unchanged.</source>
          <target state="translated">Объект &lt;code&gt;SelectSaver&lt;/code&gt; содержит ссылку на дескриптор файла, который был выбран при его создании. Если его &lt;code&gt;new&lt;/code&gt; метод получает дополнительный параметр, то выбирается этот параметр; в противном случае выбранный дескриптор файла остается неизменным.</target>
        </trans-unit>
        <trans-unit id="8fe48706c46ddab56d87823274b5a44ca94ef7e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TAP::Parser::SourceHandler&lt;/code&gt; does whatever is necessary to produce &amp;amp; capture a stream of TAP from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a99f3f0858c303c1b78e0bc06e71d69f8940558" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot;&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c30b7d6b5dae1d9e52bc3dfa57d215caf5d862" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; Не специальный внутри класса символов, если это не начало класса символов POSIX (см &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Классы символов&lt;/a&gt; ниже). Обычно это не требует побега.</target>
        </trans-unit>
        <trans-unit id="6776cbbe11f1658efaaee2f3dd38010bf8c93b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;\L&lt;/code&gt; или &lt;code&gt;\U&lt;/code&gt; указывает на длительное преобразование случае, пока не будет прекращено &lt;code&gt;\E&lt;/code&gt; или перекинутой через другой &lt;code&gt;\U&lt;/code&gt; или &lt;code&gt;\L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a24307b632bac4af20bd3048bef792d9059be490" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb525767ec147f71507ec3fe5c0bbfd43e23622a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt; . This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="translated">A &lt;code&gt;\w&lt;/code&gt; соответствует одному буквенно-цифровому символу (буквенному символу или десятичной цифре); или соединительный знак препинания, например подчеркивание (&quot;_&quot;); или знак &quot;знак&quot; (например, какой-то акцент), который прикрепляется к одному из них. Это не соответствует целому слову. Чтобы найти слово целиком, используйте &lt;code&gt;\w+&lt;/code&gt; . Это не то же самое, что сопоставление английского слова, но в диапазоне ASCII это то же самое, что и строка символов Perl-идентификатора.</target>
        </trans-unit>
        <trans-unit id="3bd4c66560dca0578d3070157d991dfce3ac854e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt;. This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46827aa6986ffad2428550f266417b4a216e73cc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot;&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387f0590ce374c162a12f59ad2a352b45a0b6a2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="translated">A &lt;code&gt;]&lt;/code&gt; обычно либо конец класса символов POSIX (см. &amp;laquo; &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;Классы символов POSIX&amp;raquo;&lt;/a&gt; ниже), либо сигнализирует о конце класса символов в квадратных скобках. Если вы хотите включить &lt;code&gt;]&lt;/code&gt; в набор символов, вы должны обычно его избегать.</target>
        </trans-unit>
        <trans-unit id="1193d9cb8f306d664b7ff329f363fa64604ab25b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;bgzip&lt;/code&gt; file consists of a series of valid gzip-compliant data streams concatenated together. To read a file created by &lt;code&gt;bgzip&lt;/code&gt; with &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; use the &lt;code&gt;MultiStream&lt;/code&gt; option as shown in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a086836899301702e84e6ebfd5a64e6e1514ec1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;clean&lt;/code&gt; command results in a</source>
          <target state="translated">&lt;code&gt;clean&lt;/code&gt; команда приводит к</target>
        </trans-unit>
        <trans-unit id="30a979776a12ffbd2ccae1dfa8877b7ee9e2e1ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fork()&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2260ddde35cc7bc21b5b592a2612689aeec99e22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;local&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;local&lt;/code&gt;ized variable, the &lt;code&gt;local&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa451e4004dc04e11969a902e7778f3071f1b2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;local&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do FILE&lt;/code&gt;--and to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d318e0e7d10811cf9d04b1c9ec7142e2b390f3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;my&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;use strict 'vars'&lt;/code&gt;, but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82e2956ae874578dae0b862a6205fc9ad9a10d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; commands before executing them:</source>
          <target state="translated">&lt;code&gt;quiet&lt;/code&gt; параметр говорит &lt;code&gt;CBuilder&lt;/code&gt; , чтобы не печатать его &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; команды перед их выполнением:</target>
        </trans-unit>
        <trans-unit id="7e6166d094ef7a8c9acbf1912950fe415bf80619" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;system()&lt;/code&gt; commands before executing them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537fa0e7c3fc8f4f2ff13df46f07e5efa8b0d873" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="translated">&lt;code&gt;regexp_paren_pair&lt;/code&gt; структура , которая определяет смещение в строку, совпадающие которые соответствуют &lt;code&gt;$&amp;amp;&lt;/code&gt; и &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , то и т.д. захватывает &lt;code&gt;regexp_paren_pair&lt;/code&gt; структура определяются следующим образом :</target>
        </trans-unit>
        <trans-unit id="88f343e9050a80a8547d07e80fa1abe57f501fdb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c85a606418ea2141ddded1f2ff2c1a9dc2e0148" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c401b707420030372d274c701dc85d8905c95ac7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;select()&lt;/code&gt; wrapper that compensates for platform peculiarities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9187cecc86ed031f1a1d91cbbf85586329ad9482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt; . The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; будет создана &lt;code&gt;struct netconfig&lt;/code&gt; . Объект Perl будет благословлен в классе, соответствующем имени типа C, с добавленным тегом &lt;code&gt;Ptr&lt;/code&gt; , и имя не должно иметь встроенных пробелов, если это будет имя пакета Perl. Деструктор будет помещен в класс, соответствующий классу объекта, а ключевое слово PREFIX будет использоваться для обрезки имени до слова DESTROY, как того и ожидает Perl.</target>
        </trans-unit>
        <trans-unit id="303080e3bc4b5d987f533b7d3f189bfcd0ce0dec" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt;. The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a29e0934f06be58e8f45f6ccaf516ef19ec003" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for 'our' variables.</source>
          <target state="translated">B::HV объект,представляющий заначку для 'наших' переменных.</target>
        </trans-unit>
        <trans-unit id="f45e12c8a06cbfbc829397737665446dbd9373fc" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for a typed lexical.</source>
          <target state="translated">A B::HV объект,представляющий тайник для набранной лексики.</target>
        </trans-unit>
        <trans-unit id="42fcd5050adf426bbdb7192c3683fb606974ed22" translate="yes" xml:space="preserve">
          <source>A BLOCK by itself (labeled or not) is semantically equivalent to a loop that executes once. Thus you can use any of the loop control statements in it to leave or restart the block. (Note that this is</source>
          <target state="translated">БЛОКИРОВКА сама по себе (помеченная или нет)семантически эквивалентна циклу,который выполняется один раз.Таким образом,вы можете использовать любое из управляющих воздействий цикла в нем,чтобы покинуть или перезапустить блок.(Обратите внимание,что это</target>
        </trans-unit>
        <trans-unit id="d2fb8a4ed8386e8349fe099520462ea5055d627c" translate="yes" xml:space="preserve">
          <source>A Buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3fa7a6472c1947a3e3fb9a265bfaa097653d2a" translate="yes" xml:space="preserve">
          <source>A Build.PL is run by perl in a separate process. Likewise we run './Build' and './Build install' in separate processes. If you have any parameters you want to pass to the calls, please specify them here.</source>
          <target state="translated">Build.PL запускается на perl в отдельном процессе.Аналогично мы запускаем './Build' и './Build install' в отдельных процессах.Если у вас есть какие-либо параметры,которые вы хотите передать на вызовы,пожалуйста,укажите их здесь.</target>
        </trans-unit>
        <trans-unit id="2b8f77588c05a56fb0aa83c01416be422180616b" translate="yes" xml:space="preserve">
          <source>A C expression for the value of the constant, or a list of C expressions if the type is aggregate. This defaults to the</source>
          <target state="translated">Выражение С для значения константы,или список выражений С,если тип является агрегированным.По умолчанию значение по умолчанию равно</target>
        </trans-unit>
        <trans-unit id="e9567baf2c716fe48fcad56160dbe55dcf6fe52e" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3A-Keyword&quot;&gt;&quot;The ALIAS: Keyword&quot;&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;&quot;Variable-length Parameter Lists&quot;&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt;. When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt;, but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bca895b6521acf14049f748fb255c795b1e71c" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt; . When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; , but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</source>
          <target state="translated">CASE: может переключаться через параметр XSUB, через переменную &lt;code&gt;ix&lt;/code&gt; ALIAS: (см &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;. Ключевое слово ALIAS:)&lt;/a&gt; или, может быть, через переменную &lt;code&gt;items&lt;/code&gt; (см. &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;Списки параметров переменной длины&lt;/a&gt; ). Последний CASE: становится случаем по &lt;b&gt;умолчанию,&lt;/b&gt; если он не связан с условием. В следующем примере показано переключение CASE через &lt;code&gt;ix&lt;/code&gt; с функцией &lt;code&gt;rpcb_gettime()&lt;/code&gt; имеющей псевдоним &lt;code&gt;x_gettime()&lt;/code&gt; . Когда функция вызывается как &lt;code&gt;rpcb_gettime()&lt;/code&gt; ее параметры являются обычными &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; , но когда функция вызывается как &lt;code&gt;x_gettime()&lt;/code&gt; ее параметры меняются местами, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="428a171aa5c95cac510361d11fc204293b5e9395" translate="yes" xml:space="preserve">
          <source>A CD-ROM drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14cb1f44ba3d5ff6c6389f7f3c7c6da1d1bedbef" translate="yes" xml:space="preserve">
          <source>A CES that was carefully designed to coexist with ASCII. There are a 7 bit version and an 8 bit version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55f978db59708209a54d8bfb17d98c3ae019b46" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt; . See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">Зеркало CPAN, которое включает только последние версии для каждого дистрибутива, вероятно, созданное с помощью &lt;code&gt;CPAN::Mini&lt;/code&gt; . См. Camel главу 19, &amp;laquo;CPAN&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="27d5797833bb46c5943f83ed90ba2705b5e06f66" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt;. See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a412a9c43c3b078621b984e4d63b01678d573c0" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Feature object describes an optional feature offered by a CPAN distribution and specified in the distribution's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9014220da96470ddba467afeca088e6c77df7b" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN distribution or one of its optional features. Each set of prereqs is organized by phase and type, as described in &lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN::Meta::Prereqs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee116ec6b595415c9ecd2e7f6b24967dd7bd2c41" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Requirements object models a set of version constraints like those specified in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79fea87c96ec94013ff8e4540cf4e641c3aa0b8" translate="yes" xml:space="preserve">
          <source>A Class is Simply a Package</source>
          <target state="translated">Класс-это просто пакет</target>
        </trans-unit>
        <trans-unit id="6fbb257e39c68ad3d78df4ebee2ad99fbc20665b" translate="yes" xml:space="preserve">
          <source>A Comparison between various tar implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">Полный пример</target>
        </trans-unit>
        <trans-unit id="9f22eaf2aa717bb5924e306e9ab40bd24eefc92a" translate="yes" xml:space="preserve">
          <source>A DBM Filter allows the keys and/or values in a tied hash to be modified by some user-defined code just before it is written to the DBM file and just after it is read back from the DBM file. For example, this snippet of code</source>
          <target state="translated">Фильтр DBM позволяет модифицировать ключи и/или значения в связанном хэше каким-то определенным пользователем кодом непосредственно перед его записью в DBM-файл и сразу после его считывания из DBM-файла.Например,этот фрагмент кода</target>
        </trans-unit>
        <trans-unit id="a3dd10dc1183e2df3ed7ea791b7d9b7560ba9d95" translate="yes" xml:space="preserve">
          <source>A DBM Filter is a piece of code that is be used when you</source>
          <target state="translated">DBM-фильтр-это часть кода,которая используется,когда вы</target>
        </trans-unit>
        <trans-unit id="5fea2d2439b0d67404b2ac6ae1e3bd78930fdef9" translate="yes" xml:space="preserve">
          <source>A Filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c2104df6e4f42e9c4248a2a9dcd9a50f8cd70b" translate="yes" xml:space="preserve">
          <source>A Filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74127e4dc0844d9e1d0d37669c77b5e1d7d7dc1c" translate="yes" xml:space="preserve">
          <source>A GV is a structure which corresponds to to a Perl typeglob, ie *foo. It is a structure that holds a pointer to a scalar, an array, a hash etc, corresponding to $foo, @foo, %foo.</source>
          <target state="translated">GV-это структура,которая соответствует печатному шрифту Perl,т.е.*foo.Это структура,которая содержит указатель на скаляр,массив,хэш и т.д.,соответствующий $foo,@foo,%foo.</target>
        </trans-unit>
        <trans-unit id="13db893228041bbd750755e5ceeab1edf73eb3b3" translate="yes" xml:space="preserve">
          <source>A Graeco-Roman word meaning &amp;ldquo;to bring oneself to life&amp;rdquo;. In Perl, storage locations (&lt;b&gt;lvalues&lt;/b&gt;) spontaneously generate themselves as needed, including the creation of any &lt;b&gt;hard reference&lt;/b&gt; values to point to the next level of storage. The assignment &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; potentially creates five scalar storage locations, plus four references (in the first four scalar locations) pointing to four new anonymous arrays (to hold the last four scalar locations). But the point of autovivification is that you don&amp;rsquo;t have to worry about it.</source>
          <target state="translated">Греко-римское слово, означающее &amp;laquo;оживить&amp;raquo;. В Perl места хранения ( &lt;b&gt;lvalue&lt;/b&gt; ) самопроизвольно генерируются по мере необходимости, включая создание любых &lt;b&gt;жестких ссылочных&lt;/b&gt; значений, указывающих на следующий уровень хранения. Присваивание &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; потенциально создает пять скалярных ячеек хранения плюс четыре ссылки (в первых четырех скалярных ячейках), указывающие на четыре новых анонимных массива (для хранения последние четыре скалярных положения). Но суть автовивификации в том, что вам не о чем беспокоиться.</target>
        </trans-unit>
        <trans-unit id="644fba68887f0f6c83a3c9ad6b03efeafe64485f" translate="yes" xml:space="preserve">
          <source>A HV structure represents a Perl hash. It consists mainly of an array of pointers, each of which points to a linked list of HE structures. The array is indexed by the hash function of the key, so each linked list represents all the hash entries with the same hash value. Each HE contains a pointer to the actual value, plus a pointer to a HEK structure which holds the key and hash value.</source>
          <target state="translated">Структура HV представляет собой Perl хэш.Она состоит в основном из массива указателей,каждый из которых указывает на связанный список структур HE.Массив индексируется хэш-функцией ключа,поэтому каждый связанный список представляет все записи хэша с одинаковым значением хэша.Каждый HE содержит указатель на фактическое значение,плюс указатель на структуру HEK,которая содержит ключ и хэш-значение.</target>
        </trans-unit>
        <trans-unit id="bee561e494291ea6e45d02ab405b622a25e73320" translate="yes" xml:space="preserve">
          <source>A JSON array becomes a reference to an array in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b24830f56f4ce8a9945d4c6990fbf400347674" translate="yes" xml:space="preserve">
          <source>A JSON null atom becomes &lt;code&gt;undef&lt;/code&gt; in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ff79ae5f44199fcff8b98322b150333800977d" translate="yes" xml:space="preserve">
          <source>A JSON number becomes either an integer, numeric (floating point) or string scalar in perl, depending on its range and any fractional parts. On the Perl level, there is no difference between those as Perl handles all the conversion details, but an integer may take slightly less memory and might represent more values exactly than floating point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d89eab13bda50b0d87fbbc9b957fca297e5455" translate="yes" xml:space="preserve">
          <source>A JSON object becomes a reference to a hash in Perl. No ordering of object keys is preserved (JSON does not preserve object key ordering itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d71ce97eec8dd4e08afea15be12b4484ab4838" translate="yes" xml:space="preserve">
          <source>A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON are represented by the same codepoints in the Perl string, so no manual decoding is necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec06e557b7618ed05ba8c87c2bab1b53c6df4c84" translate="yes" xml:space="preserve">
          <source>A List of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ae4d993cdecbfc0080ff736e7e6c054fcca9fe" translate="yes" xml:space="preserve">
          <source>A List of keywords that describe this distribution. Keywords &lt;b&gt;must not&lt;/b&gt; include whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85434ba02f21ca07aa9cc6c2aef0afe50dbbf404" translate="yes" xml:space="preserve">
          <source>A Localization Horror Story: It Could Happen To You</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01232ff6c4ca9ea380827b743047b1207b0966c9" translate="yes" xml:space="preserve">
          <source>A Method is Simply a Subroutine</source>
          <target state="translated">Метод-это просто подпрограмма.</target>
        </trans-unit>
        <trans-unit id="4fc1e89e0ebaf9800ac39a369b83b7a80fc77ec4" translate="yes" xml:space="preserve">
          <source>A Note about the Examples</source>
          <target state="translated">Примечание о примерах</target>
        </trans-unit>
        <trans-unit id="0d72d9979807c702328842043bb2529c640d1c5d" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'DELAY' &quot;indicates the sender's willingness to receive delayed DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the Message Transfer Agent (MTA) at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a &quot;delayed&quot; DSN NOT be issued under any conditions.&quot;</source>
          <target state="translated">Параметр уведомления 'DELAY' &quot;указывает на готовность отправителя получать задержанные DSN&quot;.Задержанные DSN могут быть выданы,если доставка сообщения задерживается на необычное время (как определено агентом передачи сообщений (MTA),на котором сообщение задерживается),но окончательный статус доставки (успешная или неуспешная)не может быть определен.Отсутствие ключевого слова DELAY в параметре NOTIFY (ЗАДЕРЖКА)требует,чтобы &quot;задержанное&quot; DSN НЕ выдавалось ни при каких условиях&quot;.</target>
        </trans-unit>
        <trans-unit id="9dbcef065eab9753a6c0d2e89dd406c9f007951b" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'SUCCESS' or 'FAILURE' &quot;requests that a DSN be issued on successful delivery or delivery failure, respectively.&quot;</source>
          <target state="translated">Параметр &quot;Уведомление&quot; параметра &quot;SUCCESS&quot; или &quot;FAILURE&quot; &quot;запрашивает выдачу DSN при успешной или неуспешной доставке,соответственно&quot;.</target>
        </trans-unit>
        <trans-unit id="7d978821811172b896c82b24fc810ad3863e3b13" translate="yes" xml:space="preserve">
          <source>A PID of &lt;code&gt;0&lt;/code&gt; indicates to wait for any child process whose process group ID is equal to that of the current process. A PID of less than &lt;code&gt;-1&lt;/code&gt; indicates to wait for any child process whose process group ID is equal to -PID. A PID of &lt;code&gt;-1&lt;/code&gt; indicates to wait for any child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f40c0f83e1e526b0b0b6c66a8b36e802555138" translate="yes" xml:space="preserve">
          <source>A Perl extension to the POSIX character class is the ability to negate it. This is done by prefixing the class name with a caret (&lt;code&gt;^&lt;/code&gt;). Some examples:</source>
          <target state="translated">Расширение Perl для символьного класса POSIX - это способность отрицать его. Для этого к имени класса добавляется символ каретки ( &lt;code&gt;^&lt;/code&gt; ). Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="0d2d7129fe49ff692643bf989abc3c8db9550c7a" translate="yes" xml:space="preserve">
          <source>A Perl floating point number. Similar to T_IV and T_UV in that the return type is cast to the requested numeric type rather than to a specific type.</source>
          <target state="translated">Номер с плавающей точкой Perl.Аналогично T_IV и T_UV в том,что возвращаемый тип приводится к запрашиваемому числовому типу,а не к конкретному типу.</target>
        </trans-unit>
        <trans-unit id="baf019a8a8ab4371dcf7bafbfc9ccbe01c8c24c2" translate="yes" xml:space="preserve">
          <source>A Perl module that also pulls in &lt;b&gt;compiled&lt;/b&gt; C or C++ code. More generally, any experimental option that can be &lt;b&gt;compiled&lt;/b&gt; into Perl, such as multithreading.</source>
          <target state="translated">Модуль Perl, который также использует &lt;b&gt;скомпилированный&lt;/b&gt; код C или C ++. В общем, любой экспериментальный вариант, который можно &lt;b&gt;скомпилировать&lt;/b&gt; в Perl, например многопоточность.</target>
        </trans-unit>
        <trans-unit id="d50862820d3a8aab33b93133b7d33cb935834ef5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">Шаблон Perl, который позволяет устранять неоднозначность длинных и коротких префиксов. По умолчанию &lt;code&gt;--&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0493d06ff5354c921727ebe3abf0dda51d197688" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e904ead9b94d6204fd6b39a939871c992e738f5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that identifies the strings that introduce options. Default is &lt;code&gt;--|-|\+&lt;/code&gt; unless environment variable POSIXLY_CORRECT has been set, in which case it is &lt;code&gt;--|-&lt;/code&gt;.</source>
          <target state="translated">Шаблон Perl, определяющий строки, которые вводят параметры. По умолчанию &lt;code&gt;--|-|\+&lt;/code&gt; если не была установлена ​​переменная среды POSIXLY_CORRECT, в этом случае это &lt;code&gt;--|-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45c72c917209e7e654e9e53f35f4bca27fd858cf" translate="yes" xml:space="preserve">
          <source>A Perl program consists of a sequence of declarations and statements which run from the top to the bottom. Loops, subroutines, and other control structures allow you to jump around within the code.</source>
          <target state="translated">Программа на Perl состоит из последовательности деклараций и выражений,которые выполняются сверху вниз.Петли,подпрограммы и другие структуры управления позволяют прыгать внутри кода.</target>
        </trans-unit>
        <trans-unit id="8f1d991ccec8e09953b3e8579dace5ef70ea0563" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; .</source>
          <target state="translated">Программа Perl выполняется только один раз, а не один раз для каждой строки ввода. Вы можете выполнить неявный цикл с помощью &lt;code&gt;-n&lt;/code&gt; или &lt;code&gt;-p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="719dc6b149ed9df2e9b30d38b9f401996838ec54" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05351cbee8badd4677882f72f83a69a3c04e972" translate="yes" xml:space="preserve">
          <source>A Perl program to do these tasks takes the basic form of opening a file, printing its lines, then closing the file:</source>
          <target state="translated">Программа Perl для выполнения этих задач принимает базовую форму открытия файла,распечатки его строк,затем закрытия файла:</target>
        </trans-unit>
        <trans-unit id="9f85dbe5a418fb4bcdecb47b2f0b2cac2a377668" translate="yes" xml:space="preserve">
          <source>A Perl script or program consists of one or more statements. These statements are simply written in the script in a straightforward fashion. There is no need to have a &lt;code&gt;main()&lt;/code&gt; function or anything of that kind.</source>
          <target state="translated">Сценарий или программа Perl состоит из одного или нескольких операторов. Эти утверждения просто записываются в сценарии в простой форме. Нет необходимости иметь функцию &lt;code&gt;main()&lt;/code&gt; или что-то в этом роде.</target>
        </trans-unit>
        <trans-unit id="ab689318c03ebde720ae51176a11effea3a569dc" translate="yes" xml:space="preserve">
          <source>A Perl user group, taking the form of its name from the New York Perl mongers, the first Perl user group. Find one near you at &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt;.</source>
          <target state="translated">Группа пользователей Perl, получившая свое название от New York Perl mongers, первой группы пользователей Perl. Найдите ближайшего к вам на &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eefc3e21c06e6017f8c10a8bb69ea540ab281b02" translate="yes" xml:space="preserve">
          <source>A Pod formatter may also note, in a comment or warning, a list of what unrenderable characters were encountered.</source>
          <target state="translated">Формат Pod может также отметить в комментарии или предупреждении список того,с какими неудержимыми символами пришлось столкнуться.</target>
        </trans-unit>
        <trans-unit id="90bcd0d55b890352044335ec7ff338d09cd4b9d1" translate="yes" xml:space="preserve">
          <source>A Pod processor may signal that the above (specifically the &quot;=head1&quot; paragraph) is an error. Note, however, that the following should</source>
          <target state="translated">Процессор Pod может сигнализировать о том,что вышесказанное (в частности,абзац &quot;=head1&quot;)является ошибкой.Обратите внимание,однако,что следующее должно</target>
        </trans-unit>
        <trans-unit id="185a19a7a82d49a0358676fb031bca8138fc5f0d" translate="yes" xml:space="preserve">
          <source>A Rename script</source>
          <target state="translated">Сценарий переименования</target>
        </trans-unit>
        <trans-unit id="bb0e1d56b4fab0cf7a60aa29b48524e0458e7730" translate="yes" xml:space="preserve">
          <source>A Simple Client</source>
          <target state="translated">Простой клиент</target>
        </trans-unit>
        <trans-unit id="b671ac0d028246c423146116e7e15964cde16b69" translate="yes" xml:space="preserve">
          <source>A Simple Example</source>
          <target state="translated">Простой пример</target>
        </trans-unit>
        <trans-unit id="35d2688dd60f4771865d489a975386b1e2e85efc" translate="yes" xml:space="preserve">
          <source>A Social Contract about Artistic Control</source>
          <target state="translated">Общественный договор о художественном контроле</target>
        </trans-unit>
        <trans-unit id="ce9f49f53bf8557e68c16a6cb0cab50ed319c852" translate="yes" xml:space="preserve">
          <source>A Solution</source>
          <target state="translated">Решение</target>
        </trans-unit>
        <trans-unit id="33b832366f848ffdd1c9a8efe9f8d3f20e39c539" translate="yes" xml:space="preserve">
          <source>A TAP</source>
          <target state="translated">ТАП</target>
        </trans-unit>
        <trans-unit id="f5889f236a4188d2629daf331b9d72acfd600c43" translate="yes" xml:space="preserve">
          <source>A TAP parser consumes input from a single</source>
          <target state="translated">TAP-анализатор потребляет входной сигнал от одного</target>
        </trans-unit>
        <trans-unit id="ebf6d3df00e862a08b0d79e0b9d4a2527d73a290" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7010880f6ae20816985e9d146f66cebdc5b3456f" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="translated">Парсер TAP создает &lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt; во время итерации по входу.</target>
        </trans-unit>
        <trans-unit id="cbc0d3fb42afd0ba8dd15a85a63c440071f45982" translate="yes" xml:space="preserve">
          <source>A TAP parser uses</source>
          <target state="translated">TAP парсер использует</target>
        </trans-unit>
        <trans-unit id="c7adba530805a495085a55a74870dea40f6e16bc" translate="yes" xml:space="preserve">
          <source>A TAP source &amp;amp; meta data about it</source>
          <target state="translated">Источник TAP и метаданные о нем</target>
        </trans-unit>
        <trans-unit id="92ce2bc3533d042b851a960d43bdd7c40fb70ee1" translate="yes" xml:space="preserve">
          <source>A TERM has the highest precedence in Perl. They include variables, quote and quote-like operators, any expression in parentheses, and any function whose arguments are parenthesized. Actually, there aren't really functions in this sense, just list operators and unary operators behaving as functions because you put parentheses around the arguments. These are all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">TERM имеет наивысший приоритет в Perl. Они включают переменные, кавычки и операторы, подобные кавычкам, любое выражение в круглых скобках и любую функцию, аргументы которой заключены в скобки. На самом деле в этом смысле нет никаких функций, только операторы списков и унарные операторы, которые ведут себя как функции, потому что вы заключаете аргументы в круглые скобки. Все это задокументировано в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1a6a3b8076da1517275a693db5de38381afda3" translate="yes" xml:space="preserve">
          <source>A TRUE return means that at least one code point represented by the sequence either is a wide character not representable as a single byte, or the representation differs depending on whether the sequence is encoded in UTF-8 or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c2c3a67955f622ae2a621c93e51552fb8bf822" translate="yes" xml:space="preserve">
          <source>A Thread Pitfall: Deadlocks</source>
          <target state="translated">Опухоль нитей:Тупики</target>
        </trans-unit>
        <trans-unit id="54dda450dbc946f563a52bcd0e2371c672a57c0d" translate="yes" xml:space="preserve">
          <source>A UCM file looks like this.</source>
          <target state="translated">Файл UCM выглядит вот так.</target>
        </trans-unit>
        <trans-unit id="43f36bb558eea29df73dc728bcd3a54abd7ec2ae" translate="yes" xml:space="preserve">
          <source>A UTF in 16-bit encoding. Can either be in big endian or little endian. The big endian version is called UTF-16BE (equal to UCS-2 + surrogate support) and the little endian version is called UTF-16LE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311a8f73aa0632dde20a979ee931fae45488ea90" translate="yes" xml:space="preserve">
          <source>A Unicode</source>
          <target state="translated">Юникод</target>
        </trans-unit>
        <trans-unit id="636617240302996a8f020159cb2e15c959a81dd5" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt; ), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\b{}, \b, \B{}, \B in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="translated">Граница Unicode ( &lt;code&gt;\b{}&lt;/code&gt; ), доступная начиная с v5.22, представляет собой точку между двумя символами, либо перед первым символом в строке, либо после последнего символа в строке, где выполняются определенные критерии, определенные Unicode. Подробнее см. &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\ B {}, \ b, \ B {}, \ B в perlrebackslash&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76eb73f0015e13b24af055123c49d9a38b6acaf0" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt;), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6ccb5c3173a4892e5e2944faba0f70f7b55ac3" translate="yes" xml:space="preserve">
          <source>A Unicode linebreak matches the two-character CRLF grapheme or any of seven vertical whitespace characters. Good for dealing with textfiles coming from different operating systems.</source>
          <target state="translated">Разрыв строки в юникоде соответствует двухсимвольному графему CRLF или любому из семи вертикальных пробельных символов.Хорошо подходит для работы с текстовыми файлами,поступающими из различных операционных систем.</target>
        </trans-unit>
        <trans-unit id="d796a3e99a29b5e8798e5ee8787d53dec284ccde" translate="yes" xml:space="preserve">
          <source>A Webget Client</source>
          <target state="translated">Вебджет-клиент</target>
        </trans-unit>
        <trans-unit id="50dd095330e040b6a4649d187065a771e5fe7217" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules required for building and/or testing of this distribution. These dependencies are not required after the module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155290232ccec43841ef670c256ec20f15263b43" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules that cannot be installed while this distribution is installed. This is a pretty uncommon situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23933c4c7f89ad6b6468098ec568e0891d00fbb" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules this distribution recommends for enhanced operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcc493f623faaa5166c4233037cd1025c6b0ae1" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules this distribution requires for proper operation. The keys are the module names, and the values are version specifications as described in the &lt;a href=&quot;Module::Build::API#requires&quot;&gt;documentation for Module::Build's &quot;requires&quot; parameter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625ef9e7e1c1fa35b033333425cc32cf0c3ed6bf" translate="yes" xml:space="preserve">
          <source>A backslash sequence is a sequence of characters, the first one of which is a backslash. Perl ascribes special meaning to many such sequences, and some of these are character classes. That is, they match a single character each, provided that the character belongs to the specific set of characters defined by the sequence.</source>
          <target state="translated">Последовательность обратного слеша-это последовательность символов,первый из которых-обратный слеш.Perl придает особое значение многим таким последовательностям,и некоторые из них являются классами символов.То есть они соответствуют каждому из них по одному символу при условии,что этот символ принадлежит к определенному набору символов,определяемому последовательностью.</target>
        </trans-unit>
        <trans-unit id="0a7351fee5999f66ec79553b15a43f5d86c41d6e" translate="yes" xml:space="preserve">
          <source>A backward-compatibility alias for TYPE.</source>
          <target state="translated">Псевдоним обратной совместимости для ТИПа.</target>
        </trans-unit>
        <trans-unit id="f7fb814e1c2c79d0e734419e57ea9495c267d50e" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; ; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt; . Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="translated">Версия &lt;code&gt;GIMME_V&lt;/code&gt; с обратной совместимостью, которая может возвращать только &lt;code&gt;G_SCALAR&lt;/code&gt; или &lt;code&gt;G_ARRAY&lt;/code&gt; ; в &lt;code&gt;G_SCALAR&lt;/code&gt; контексте он возвращает G_SCALAR . Устарело. &lt;code&gt;GIMME_V&lt;/code&gt; этого используйте GIMME_V .</target>
        </trans-unit>
        <trans-unit id="ea63daaa7584ad162122c04feefcccd273238637" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt;; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt;. Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825d3b4cdbdd793ff6bcae81fea3eedc9476aefd" translate="yes" xml:space="preserve">
          <source>A bare declaration like that declares the function to be a list operator, not a unary operator, so you have to be careful to use parentheses (or &lt;code&gt;or&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt;.) The &lt;code&gt;||&lt;/code&gt; operator binds too tightly to use after list operators; it becomes part of the last element. You can always use parentheses around the list operators arguments to turn the list operator back into something that behaves more like a function call. Alternatively, you can use the prototype &lt;code&gt;($)&lt;/code&gt; to turn the subroutine into a unary operator:</source>
          <target state="translated">В таком простом объявлении функция объявляется оператором списка, а не унарным оператором, поэтому вы должны быть осторожны, используя круглые скобки (или &lt;code&gt;or&lt;/code&gt; вместо &lt;code&gt;||&lt;/code&gt; ). Символ &lt;code&gt;||&lt;/code&gt; оператор связывает слишком сильно, чтобы использовать операторы после списка; он становится частью последнего элемента. Вы всегда можете использовать круглые скобки вокруг аргументов операторов списка, чтобы снова превратить оператор списка во что-то, что больше похоже на вызов функции. В качестве альтернативы вы можете использовать прототип &lt;code&gt;($)&lt;/code&gt; , чтобы превратить подпрограмму в унарный оператор:</target>
        </trans-unit>
        <trans-unit id="79d7fc67720af71225bb992fc841089461a260dd" translate="yes" xml:space="preserve">
          <source>A bare, single &lt;b&gt;statement&lt;/b&gt;, without any braces, hanging off an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; conditional. C allows them. Perl doesn&amp;rsquo;t.</source>
          <target state="translated">Простой, единственный &lt;b&gt;оператор&lt;/b&gt; без фигурных скобок, свисающий с условным условием &lt;code&gt;if&lt;/code&gt; или &lt;code&gt;while&lt;/code&gt; . C позволяет им. Perl этого не делает.</target>
        </trans-unit>
        <trans-unit id="7c021cbe956d43771e93a19ff22791f5da1edc86" translate="yes" xml:space="preserve">
          <source>A basic building block. When you&amp;rsquo;re talking about an &lt;b&gt;array&lt;/b&gt;, it&amp;rsquo;s one of the items that make up the array.</source>
          <target state="translated">Базовый строительный блок. Когда вы говорите о &lt;b&gt;массиве&lt;/b&gt; , это один из элементов, составляющих массив.</target>
        </trans-unit>
        <trans-unit id="dc24770c94125e3eea533d29f62a33f6fca11b44" translate="yes" xml:space="preserve">
          <source>A basic example</source>
          <target state="translated">Основной пример</target>
        </trans-unit>
        <trans-unit id="f7282a24ce95eed40d8f1f24671950459bbf71d8" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="translated">Базовый небуферизованный уровень, который вызывает Unix / POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; . Без буферизации. Даже на платформах, которые различают O_TEXT и O_BINARY, этот уровень всегда O_BINARY.</target>
        </trans-unit>
        <trans-unit id="96f31fcb471e12245ded4f9a6d4759ba999aaaaa" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3269aa1ef3bfcd123309b115096aa27b3b0a0aa8" translate="yes" xml:space="preserve">
          <source>A bigger, fancier sort of &lt;b&gt;program&lt;/b&gt; with a fancier name so people don&amp;rsquo;t realize they are using a program.</source>
          <target state="translated">Более крупная и интересная &lt;b&gt;программа&lt;/b&gt; с более красивым названием, чтобы люди не осознавали, что используют программу.</target>
        </trans-unit>
        <trans-unit id="3fc8298d557ca48e82c9d8c77d3a4da35fed0d13" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist()&quot;&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1395a44d1527cd51acf9f72e88e221dc5e7a43dc" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="translated">Бинарный поиск, такой как предоставляемый &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist ()&lt;/a&gt; , можно использовать для быстрого поиска кодовой точки в списке инверсии и, следовательно, соответствующего сопоставления.</target>
        </trans-unit>
        <trans-unit id="a3982f0643b548a46d27f9bb45d706ffed3877fd" translate="yes" xml:space="preserve">
          <source>A bit of magic: executing Perl code in a regular expression</source>
          <target state="translated">Немного магии:выполнение Perl-кода в регулярном выражении</target>
        </trans-unit>
        <trans-unit id="a21b7a38b7737dbecfe5abeb569d1f5e67680088" translate="yes" xml:space="preserve">
          <source>A bitfield containing &lt;code&gt;AI_*&lt;/code&gt; constants; see below.</source>
          <target state="translated">Битовое поле, содержащее константы &lt;code&gt;AI_*&lt;/code&gt; ; увидеть ниже.</target>
        </trans-unit>
        <trans-unit id="5315c3bf863fe0d813794db09004e209616806a3" translate="yes" xml:space="preserve">
          <source>A bolt out of the blue; that is, an event triggered by the &lt;b&gt;operating system&lt;/b&gt;, probably when you&amp;rsquo;re least expecting it.</source>
          <target state="translated">Гром из ниоткуда; то есть событие, инициированное &lt;b&gt;операционной системой&lt;/b&gt; , вероятно, когда вы меньше всего этого ожидаете.</target>
        </trans-unit>
        <trans-unit id="37f6985b23fa2a35e2960a3080f908d1bc2f10c9" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , and &lt;code&gt;!=&lt;/code&gt; ), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , and &lt;code&gt;ne&lt;/code&gt; ).</source>
          <target state="translated">Логический оператор сравнения, например &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; или &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . Операторы отношения, к которым это применяется, - это шесть числовых сравнений ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; ) И шесть сравнений строк ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; и &lt;code&gt;ne&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="f872d192d60363c8ec38811eaa9cd396b2186576" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt;. The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, and &lt;code&gt;!=&lt;/code&gt;), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, and &lt;code&gt;ne&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16e0ea8efa85160b2ce98c496eca41e4f3f0abe" translate="yes" xml:space="preserve">
          <source>A boolean flag indicating whether a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5784bf453d1712122e0236fafc88e209e3c6adfe" translate="yes" xml:space="preserve">
          <source>A boolean flag that indicates if this argument was a required argument. If marked as required and not provided, check() will fail.</source>
          <target state="translated">Булевый флаг,указывающий,был ли этот аргумент обязательным.Если он отмечен как требуемый и не предоставлен,функция check()не будет работать.</target>
        </trans-unit>
        <trans-unit id="e6fe446e073ed79c5385621f6ed10de019fdcb46" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether or not the test suite passed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26eff46626719c9961598f48502b4f5bf7c8df23" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether or not this call is for a subtest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5d923e23cbfcf9ddbcab23430ab0d60567d207" translate="yes" xml:space="preserve">
          <source>A boolean that denotes whether this is a decimal or dotted-decimal version. See &lt;a href=&quot;version#is_qv%28%29&quot;&gt;&quot;is_qv()&quot; in version&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f45f2fd37a08c482eccef8f9a0e056c9088589f" translate="yes" xml:space="preserve">
          <source>A boolean that denotes whether this is an alpha version. NOTE: that the underscore can only appear in the last position. See &lt;a href=&quot;version#is_alpha%28%29&quot;&gt;&quot;is_alpha()&quot; in version&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806d4e84607ce29c56416e6b774c66e8a0e936b0" translate="yes" xml:space="preserve">
          <source>A boolean to indicate whether &lt;code&gt;check&lt;/code&gt; should be verbose and warn about what went wrong in a check or not.</source>
          <target state="translated">Логическое значение, указывающее, должна ли &lt;code&gt;check&lt;/code&gt; быть подробной и предупреждать о том, что в проверке пошло не так.</target>
        </trans-unit>
        <trans-unit id="75de768f80b992cf9735e1b55771968cbd72780f" translate="yes" xml:space="preserve">
          <source>A boolean type. This can be used to pass true and false values to and from C.</source>
          <target state="translated">Булевского типа.Он может использоваться для передачи значений true и false в и из C.</target>
        </trans-unit>
        <trans-unit id="aaea9ae3f33d9df07a73532337b752e2bd4004dd" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether or not the module was found to be at least the version you specified. If you did not specify a version, uptodate will always be true if the module was found. If no parsable version was found in the module, uptodate will also be true, since &lt;code&gt;check_install&lt;/code&gt; had no way to verify clearly.</source>
          <target state="translated">Логическое значение, указывающее, соответствует ли модуль указанной вами версии. Если вы не указали версию, обновление всегда будет истинным, если модуль был найден. Если в модуле не найдена версия для синтаксического анализа, обновление также будет истинным, поскольку &lt;code&gt;check_install&lt;/code&gt; не имеет возможности четко проверить.</target>
        </trans-unit>
        <trans-unit id="cf5fbd766ee0c61b894a2e6590881532089d7fdc" translate="yes" xml:space="preserve">
          <source>A brief description for most of the mentioned CJK encodings is contained in &lt;a href=&quot;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&quot;&gt;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4da841a146cb38a789f449f32f4b854b9d0c640" translate="yes" xml:space="preserve">
          <source>A built-in unary operator that you use to determine whether something is &lt;b&gt;true&lt;/b&gt; about a file, such as &lt;code&gt;&amp;ndash;o
$filename&lt;/code&gt; to test whether you&amp;rsquo;re the owner of the file.</source>
          <target state="translated">Встроенный унарный оператор, который вы используете, чтобы определить, &lt;b&gt;верно&lt;/b&gt; ли что-то о файле, например &lt;code&gt;&amp;ndash;o $filename&lt;/code&gt; чтобы проверить, являетесь ли вы владельцем файла.</target>
        </trans-unit>
        <trans-unit id="7359d066cd43a6821cadbf98e46de3780a2f14da" translate="yes" xml:space="preserve">
          <source>A bundle is just a perl module in the namespace Bundle:: that does not define any functions or methods. It usually only contains documentation.</source>
          <target state="translated">Пакет-это просто perl-модуль в пространстве имён Bundle:::,который не определяет никаких функций или методов.Обычно он содержит только документацию.</target>
        </trans-unit>
        <trans-unit id="dcc2eb86ccf8cc61d11e939a89cf35406fa7d7cc" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8e1c29a7f993180d6961dbd822ca7a9b81fdce" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcefaccadd4fc0b82966dd6fe0502b4a54a13075" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">Вызов &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; должен быть сделан для объявления во время компиляции частной переменной, используемой этим макросом и двумя &lt;code&gt;STORE&lt;/code&gt; . Этот макрос следует вызывать как отдельный оператор, а не как выражение, но с пустым списком аргументов, например:</target>
        </trans-unit>
        <trans-unit id="85dcd887c15b971af653f15a54e47c2790e7a16c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">Вызов &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; должен быть сделан для объявления во время компиляции частной переменной, используемой этим макросом. Этот макрос следует вызывать как отдельный оператор, а не как выражение, но с пустым списком аргументов, например:</target>
        </trans-unit>
        <trans-unit id="6d081cdfc1719628de161b242cc46c6122417557" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt; . If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="translated">Вызов &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; заставит Perl выйти и вызвать команду, указанную в качестве аргумента для &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; через &lt;code&gt;lib$do_command&lt;/code&gt; . Если аргумент начинается с &amp;laquo;@&amp;raquo; или &amp;laquo;$&amp;raquo; (кроме как часть спецификации файла), он выполняется как команда DCL. В противном случае первый токен в командной строке обрабатывается как спецификация файла образа для запуска, и делается попытка вызвать его (используя</target>
        </trans-unit>
        <trans-unit id="85638aa0428bad6b05c5801235d5757932516e51" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;exec&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;exec&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt;. If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1310b4d6c00ffc23a2f0bae5e7870ed9e6ede4" translate="yes" xml:space="preserve">
          <source>A character class is a way of denoting a set of characters in such a way that one character of the set is matched. It's important to remember that: matching a character class consumes exactly one character in the source string. (The source string is the string the regular expression is matched against.)</source>
          <target state="translated">Класс символов-это способ обозначения набора символов таким образом,чтобы один символ набора совпадал.Важно помнить об этом:при совпадении символьного класса в исходной строке потребляется ровно один символ.(Исходная строка-это строка,которой сопоставляется регулярное выражение).</target>
        </trans-unit>
        <trans-unit id="2d7e4b0e3a328dba3c81ba02d01a3c0f782c72a5" translate="yes" xml:space="preserve">
          <source>A character encoding form plus byte serialization. There are Seven character encoding schemes in Unicode: UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and UTF-32LE (UCS-4LE), and UTF-7.</source>
          <target state="translated">Форма кодирования символов плюс сериализация байтов.В Юникоде есть семь схем кодирования:UTF-8,UTF-16,UTF-16BE,UTF-16LE,UTF-32 (UCS-4),UTF-32BE (UCS-4BE)и UTF-32LE (UCS-4LE),и UTF-7.</target>
        </trans-unit>
        <trans-unit id="e2b2859306209b5e788c7205519699be5962c3a1" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt; .</source>
          <target state="translated">Обнаружен символьный объект, не принадлежащий стандартному набору ISO или специальным &lt;code&gt;verbar&lt;/code&gt; POD verbar и &lt;code&gt;sol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3efbfb7c6f5b656c49fa17f73fcaa9b6dc991658" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3facef3525988e61e4c03673d831959bbb24fc" translate="yes" xml:space="preserve">
          <source>A character in the range 0 .. 2**32-1 (or more); what Perl's strings are made of.</source>
          <target state="translated">Символ в диапазоне 0 ...2**32-1 (или более);из чего состоят строки Perl.</target>
        </trans-unit>
        <trans-unit id="4c66dbdd31c41ff8290d5b9e5b84c42f44091393" translate="yes" xml:space="preserve">
          <source>A character in the range 0..255; a special case of a Perl character.</source>
          <target state="translated">Символ в диапазоне 0...255;специальный случай символа Perl.</target>
        </trans-unit>
        <trans-unit id="deb99f697e889e229888732646e1d9a4b2cd77a6" translate="yes" xml:space="preserve">
          <source>A character range may be specified with a hyphen, so &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; does the same replacement as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt;. For &lt;b&gt;sed&lt;/b&gt; devotees, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; is provided as a synonym for &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;. If the</source>
          <target state="translated">Диапазон символов может быть указан с дефисом, поэтому &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; выполняет ту же замену, что и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt; . Для приверженцев &lt;b&gt;sed &lt;/b&gt; &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; является синонимом &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; . Если</target>
        </trans-unit>
        <trans-unit id="62e5445beeff56a35c0dc5ca65bde86d53c27ebb" translate="yes" xml:space="preserve">
          <source>A character set comprising all the major character sets of the world, more or less. See &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">Набор символов, более или менее содержащий все основные наборы символов мира. См. &lt;a href=&quot;http://www.unicode.org&quot;&gt;Http://www.unicode.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5a861e5d79ec9801dc0afc379f1516aa190f92" translate="yes" xml:space="preserve">
          <source>A character set that aims to include all character repertoires of the world. Many character sets in various national as well as industrial standards have become, in a way, just subsets of Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd6e4ff71c892f21b92e2e5137c07d6d2cc0f6c" translate="yes" xml:space="preserve">
          <source>A character set that is mapped in a way computers can use directly. Many character encodings, including EUC, fall in this category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c07be0779b2376c619d1a65316d136daa5c26ab" translate="yes" xml:space="preserve">
          <source>A character symbolizing the type of IO Handle.</source>
          <target state="translated">Символ,символизирующий тип ручки ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="ad2f4627442f7e9e5cdd45c11902cca0d8325c3b" translate="yes" xml:space="preserve">
          <source>A character with the numeric value of zero. It&amp;rsquo;s used by C to terminate strings, but Perl allows strings to contain a null.</source>
          <target state="translated">Символ с нулевым числовым значением. Он используется C для завершения строк, но Perl позволяет строкам содержать нуль.</target>
        </trans-unit>
        <trans-unit id="a98fe200a320861843965673193461dc42788194" translate="yes" xml:space="preserve">
          <source>A check is made to make sure that the file that is found does contain some pod documentation.</source>
          <target state="translated">Проверяется,что найденный файл содержит некоторую документацию по pod.</target>
        </trans-unit>
        <trans-unit id="dff052af6a3279311d539bddc8b2f4ffb4c3bccf" translate="yes" xml:space="preserve">
          <source>A check routine is called when the node is fully constructed except for the execution-order thread. Since at this time there are no back-links to the currently constructed node, one can do most any operation to the top-level node, including freeing it and/or creating new nodes above/below it.</source>
          <target state="translated">Процедура проверки вызывается,когда узел полностью построен,за исключением потока исполнения заказа.Так как в это время нет обратных ссылок на узел,построенный в данный момент,то можно выполнить большинство операций с узлом верхнего уровня,в том числе освободить его и/или создать новые узлы выше/ниже него.</target>
        </trans-unit>
        <trans-unit id="ffb83db9b043670ff139e922da8f6f1ecd3cdb22" translate="yes" xml:space="preserve">
          <source>A class implementing a filehandle should have the following methods:</source>
          <target state="translated">Класс,реализующий файловую обработку,должен иметь следующие методы:</target>
        </trans-unit>
        <trans-unit id="78efc3f39c8e446fbaac2a63562d8cf90bbe3489" translate="yes" xml:space="preserve">
          <source>A class implementing a hash should have the following methods:</source>
          <target state="translated">Класс,реализующий хэш,должен иметь следующие методы:</target>
        </trans-unit>
        <trans-unit id="c29da3bd78457adcea44e08fd7ad308e312eac90" translate="yes" xml:space="preserve">
          <source>A class implementing a scalar should have the following methods:</source>
          <target state="translated">Класс,реализующий скаляр,должен иметь следующие методы:</target>
        </trans-unit>
        <trans-unit id="63533b67267a9fe7a63e719b4e79f437e64bb6e7" translate="yes" xml:space="preserve">
          <source>A class implementing a tied filehandle should define the following methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC, READ, and possibly CLOSE, UNTIE and DESTROY. The class can also provide: BINMODE, OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators are used on the handle.</source>
          <target state="translated">Класс,реализующий связанный файловый менеджер,должен определить следующие методы:TIEHANDLE,по крайней мере один из методов PRINT,PRINTF,WRITE,READLINE,GETC,READ и,возможно,CLOSE,UNTIE и DESTROY.Класс также может предоставить:BINMODE,OPEN,EOF,FILENO,SEEK,TELL-если на ручке используются соответствующие операторы perl.</target>
        </trans-unit>
        <trans-unit id="860765a0ff8cee1341ccc04233da280b71701cf8" translate="yes" xml:space="preserve">
          <source>A class implementing a tied ordinary array should define the following methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR and perhaps UNTIE and/or DESTROY.</source>
          <target state="translated">Класс,реализующий связанный обычный массив,должен определить следующие методы:TIEARRAY,FETCH,STORE,FETCHSIZE,STORESIZE,CLEAR и,возможно,UNTIE и/или DESTROY.</target>
        </trans-unit>
        <trans-unit id="bf2fe5249c3fde4bdfb3247a51b433da9021cc26" translate="yes" xml:space="preserve">
          <source>A class implementing a tied scalar should define the following methods: TIESCALAR, FETCH, STORE, and possibly UNTIE and/or DESTROY.</source>
          <target state="translated">Класс,реализующий связанный скаляр,должен определить следующие методы:ТИЕСКАЛАР,ТЕХНИЧЕСКИЙ,СТОР,и,возможно,ВНЕШНИЙ и/или УНИВЕРСАЛЬНЫЙ.</target>
        </trans-unit>
        <trans-unit id="172ef2f1ff718aa5d74e2eddddd8780306842005" translate="yes" xml:space="preserve">
          <source>A class implementing an ordinary array should have the following methods:</source>
          <target state="translated">Класс,реализующий обычный массив,должен иметь следующие методы:</target>
        </trans-unit>
        <trans-unit id="7a3aaef4b6bdc65044d6cee8905b655c826b75aa" translate="yes" xml:space="preserve">
          <source>A class is simply a package. A class provides methods that expect to operate on objects.</source>
          <target state="translated">Класс-это просто пакет.Класс предоставляет методы,которые ожидают работы с объектами.</target>
        </trans-unit>
        <trans-unit id="db991666cef49d40c1a8876d8e678d10cc5c5920" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC message queues.</source>
          <target state="translated">Класс,предоставляющий объектно-ориентированный интерфейс к очередям сообщений SysV IPC.</target>
        </trans-unit>
        <trans-unit id="4b371730a083c396c011c1644f5fee33b2fe22c7" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC semaphores.</source>
          <target state="translated">Класс,предоставляющий объектный интерфейс к семафорам SysV IPC.</target>
        </trans-unit>
        <trans-unit id="937b26fb80fdcafceefce4e180073ce7c0d23781" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC shared memory.</source>
          <target state="translated">Класс,предоставляющий объектно-ориентированный интерфейс к разделяемой памяти SysV IPC.</target>
        </trans-unit>
        <trans-unit id="bd175d0ab34111d2e7b8c50a111622dec0708ca3" translate="yes" xml:space="preserve">
          <source>A class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2558ecb874a35a0f9b83568f215824db4e665c" translate="yes" xml:space="preserve">
          <source>A cleaner interface.</source>
          <target state="translated">Чистый интерфейс.</target>
        </trans-unit>
        <trans-unit id="243557da44bd0a5796f8364017fe91e379f3fd89" translate="yes" xml:space="preserve">
          <source>A client for such a server could be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057ca0c3c407c4a073d1e7a556976d6dc49abacf" translate="yes" xml:space="preserve">
          <source>A code for the type of media. See the &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt; export class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38d53db5215d12738985d5f40428b967eb33230" translate="yes" xml:space="preserve">
          <source>A collection of unique characters. A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac161b3e973b3214fa6c5dba36e6bf752d3c13d" translate="yes" xml:space="preserve">
          <source>A comma-separated list of mirrors to use for just this run. The &lt;code&gt;-P&lt;/code&gt; option can find them for you automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551df32d5b94297e0a676020a161e26c925fb485" translate="yes" xml:space="preserve">
          <source>A command &quot;=begin</source>
          <target state="translated">Команда &quot;=начало</target>
        </trans-unit>
        <trans-unit id="4b51cb486fb82b1f8836c9909ccc915ba4671256" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="translated">Командный параграф (также называемый &amp;laquo;директивой&amp;raquo;). Первая строка этого абзаца должна соответствовать &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; . Абзацы команд обычно состоят из одной строки, например:</target>
        </trans-unit>
        <trans-unit id="a57f5a78e79b4e4e45aef57f5fe85eaf31a249f1" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63e70d9d65f24f45184b420c514e63650be0655" translate="yes" xml:space="preserve">
          <source>A command paragraph is used for special treatment of whole chunks of text, usually as headings or parts of lists.</source>
          <target state="translated">Командный параграф используется для специальной обработки целых фрагментов текста,обычно в виде заголовков или частей списков.</target>
        </trans-unit>
        <trans-unit id="d9ff878c605ee9fd388f0b2eb88f5ce5a0c8f433" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="translated">Такая команда, как эта, может значительно уменьшить объем материала, который нужно разобрать, и ее нельзя игнорировать просто из-за ее простоты. Принцип &lt;code&gt;KISS&lt;/code&gt; слишком часто упускается из виду - в следующем примере для демонстрации используется простая утилита системного &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; . Давайте посмотрим на реальный пример сортировки содержимого большого файла, подойдет файл журнала apache. У этого есть более четверти миллиона строк, размер 50M, и его фрагмент выглядит так:</target>
        </trans-unit>
        <trans-unit id="0aea28bdea157023aa3d7cd5bd7e48a433c74487" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;time&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950be6f2b3fd35cd65faf61436fcb9557d03c11d" translate="yes" xml:space="preserve">
          <source>A command which has ended up in the middle of a paragraph or other command, such as</source>
          <target state="translated">Команда,которая оказалась в середине абзаца или другой команды,такой как</target>
        </trans-unit>
        <trans-unit id="dfc138f19fcb5bcbc53f0752d4f1867a8fa0e913" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt; , to query what modules were shipped with given versions of perl.</source>
          <target state="translated">&lt;code&gt;Module::CoreList&lt;/code&gt; командной строки для Module :: CoreList , чтобы узнать , какие модули поставлялись с данными версиями perl.</target>
        </trans-unit>
        <trans-unit id="03a5eed393d50b8ebdff34b45b799ace9b9158b6" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt;, to query what modules were shipped with given versions of perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbae24479d2e6391e2d1be21dd08d1626f00360" translate="yes" xml:space="preserve">
          <source>A comment</source>
          <target state="translated">Комментарий</target>
        </trans-unit>
        <trans-unit id="79414afc2393f5f2f467ceef02de3748e14d7a7a" translate="yes" xml:space="preserve">
          <source>A comment, indicated by putting a '#' in the first column.</source>
          <target state="translated">Комментарий,обозначаемый добавлением '#' в первой колонке.</target>
        </trans-unit>
        <trans-unit id="b093d0d89cc94439fab7e6d11818a74b1c71812b" translate="yes" xml:space="preserve">
          <source>A comment. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee091682ad4b542f16ac50d991bfff2ba6d1e9a6" translate="yes" xml:space="preserve">
          <source>A comment. The text is ignored. Note that Perl closes the comment as soon as it sees a &lt;code&gt;)&lt;/code&gt;, so there is no way to put a literal &lt;code&gt;)&lt;/code&gt; in the comment. The pattern's closing delimiter must be escaped by a backslash if it appears in the comment.</source>
          <target state="translated">Комментарий. Текст игнорируется. Обратите внимание, что Perl закрывает комментарий, как только видит a &lt;code&gt;)&lt;/code&gt; , поэтому нет возможности поместить в комментарий литерал &lt;code&gt;)&lt;/code&gt; . Закрывающий разделитель шаблона должен быть экранирован обратной косой чертой, если он появляется в комментарии.</target>
        </trans-unit>
        <trans-unit id="1efe142409d27cde9607bba9f906e0c889b26956" translate="yes" xml:space="preserve">
          <source>A commit message isn't intended to take the place of comments in your code. Commit messages should describe the change you made, while code comments should describe the current state of the code.</source>
          <target state="translated">Сообщение о фиксации не предназначено для того,чтобы заменить комментарии в вашем коде.Сообщения о фиксации должны описывать внесённое вами изменение,а комментарии к коду-текущее состояние кода.</target>
        </trans-unit>
        <trans-unit id="bf7ad1fec29a3549dc58ded16ba4af5fb14c45da" translate="yes" xml:space="preserve">
          <source>A common abuse of this power stems from the ability to make infinite loops using regular expressions, with something as innocuous as:</source>
          <target state="translated">Обычное злоупотребление этой властью проистекает из способности делать бесконечные петли,используя регулярные выражения,с чем-то столь же безобидным,как:</target>
        </trans-unit>
        <trans-unit id="80ff7af3da26f57aaa8f224ec06b92247a2ede78" translate="yes" xml:space="preserve">
          <source>A common bit of code &lt;b&gt;NOT TO USE&lt;/b&gt; is this:</source>
          <target state="translated">Типичный фрагмент кода, который &lt;b&gt;НЕ ИСПОЛЬЗУЕТСЯ&lt;/b&gt; , следующий:</target>
        </trans-unit>
        <trans-unit id="bcd3e6faa389885dcad88118cf027340603a19e2" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="translated">Распространенное заблуждение в программировании сокетов состоит в том, что &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; везде. При использовании таких протоколов, как обычные Интернет-протоколы, &lt;code&gt;\012&lt;/code&gt; и &lt;code&gt;\015&lt;/code&gt; вызываются специально, и значения логических &lt;code&gt;\n&lt;/code&gt; и &lt;code&gt;\r&lt;/code&gt; (возврат каретки) не являются надежными.</target>
        </trans-unit>
        <trans-unit id="547a6fcaad39d8d2e51072980c79106e4d8f2797" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n eq \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e9593af1f1c680a3827d8f5e0edca15a66c226" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;-string. For this reason, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="translated">Распространенной ошибкой является попытка разделить слова запятыми или поместить комментарии в многострочную &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; -строку . По этой причине, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; прагмы и &lt;b&gt;-w&lt;/b&gt; переключателя (то есть, &lt;code&gt;$^W&lt;/code&gt; переменного) производит предупреждения , если</target>
        </trans-unit>
        <trans-unit id="7281583226716ee344a88588c1f30e8169fcc770" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;qw&lt;/code&gt;-string. For this reason, the &lt;code&gt;use warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad5d9b3c5a0d882bf3ecc970194923dc4421054" translate="yes" xml:space="preserve">
          <source>A common mistake is to write:</source>
          <target state="translated">Обычная ошибка-писать:</target>
        </trans-unit>
        <trans-unit id="7892054117b48e6a3618b7ba1c611a106354c30a" translate="yes" xml:space="preserve">
          <source>A common pitfall is to forget that &lt;code&gt;&quot;#&quot;&lt;/code&gt; characters begin a comment under &lt;code&gt;/x&lt;/code&gt; and are not matched literally. Just keep that in mind when trying to puzzle out why a particular &lt;code&gt;/x&lt;/code&gt; pattern isn't working as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053544785eaa005951fc7923348a6ed5ac918733" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1998491c1e38cb900464f10bbb2d155c01472d" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="translated">Распространенная ошибка - использовать &lt;a href=&quot;#precision()&quot;&gt;precision (),&lt;/a&gt; когда вы хотите округлить результат до определенного количества цифр:</target>
        </trans-unit>
        <trans-unit id="008944edbc996e59046c342b9a5abf856d868927" translate="yes" xml:space="preserve">
          <source>A common sight is code which looks something like this:</source>
          <target state="translated">Обычное зрелище-это код,который выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="7a1613d252216a78f3f6c4f13b80070f584c7ea5" translate="yes" xml:space="preserve">
          <source>A common value you might want would be just &quot;.&quot; for the current directory:</source>
          <target state="translated">Общим значением,которое вы,возможно,захотите,будет просто &quot;...&quot; для текущей директории:</target>
        </trans-unit>
        <trans-unit id="fe5d8a965ad75566e7f17ed9a970119fdb9dbef8" translate="yes" xml:space="preserve">
          <source>A comparison of GNU and POSIX tar standards; &lt;code&gt;http://www.delorie.com/gnu/docs/tar/tar_114.html&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c241c23e5c55b1df65f14fa3926fd6466b90d17" translate="yes" xml:space="preserve">
          <source>A complete list of Perl's error messages and warnings with explanatory text can be found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. You can also use the splain program (distributed with Perl) to explain the error messages:</source>
          <target state="translated">Полный список сообщений об ошибках и предупреждений Perl с пояснительным текстом можно найти в &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; . Вы также можете использовать программу splain (распространяется с Perl) для объяснения сообщений об ошибках:</target>
        </trans-unit>
        <trans-unit id="2766232819d1e10808eb2c0fa9745fbc9935b0e0" translate="yes" xml:space="preserve">
          <source>A complete list of blocks and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">Полный список блоков и их ярлыков находится в &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cbbc7ef27b343f02ecb00286ffab06c25627261" translate="yes" xml:space="preserve">
          <source>A complete list of blocks is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9c8e1e2ba56e67cb98e64490d656c0331322db" translate="yes" xml:space="preserve">
          <source>A complete list of models at the time the OS was built is in the file /usr/sam/lib/mo/sched.models. The first column corresponds to the last part of the output of the &quot;model&quot; command. The second column is the PA-RISC version and the third column is the exact chip type used. (Start browsing at the bottom to prevent confusion ;-)</source>
          <target state="translated">Полный список моделей на момент сборки ОС находится в файле /usr/sam/lib/mo/sched.models.Первая колонка соответствует последней части вывода команды &quot;модель&quot;.Второй столбец-версия PA-RISC,а третий столбец-точный тип используемого чипа.(Начните просмотр снизу во избежание путаницы ;-)</target>
        </trans-unit>
        <trans-unit id="57f247bd806924e603c825d46c359f392e5225bb" translate="yes" xml:space="preserve">
          <source>A complete list of scripts and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">Полный список скриптов и их ярлыков находится в &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="352eea5d492543a075b98638f01aabee71fa53f5" translate="yes" xml:space="preserve">
          <source>A complete thread tutorial could fill a book (and has, many times), but with what we've covered in this introduction, you should be well on your way to becoming a threaded Perl expert.</source>
          <target state="translated">Полный учебник по нитке может заполнить книгу (и уже много раз),но с тем,что мы рассмотрели в этом введении,вы должны быть хорошо на пути к тому,чтобы стать нитью эксперта Perl.</target>
        </trans-unit>
        <trans-unit id="018d8cf23f3e4a65b253a6e3de9afa4ba28bc385" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; pattern.</source>
          <target state="translated">Компонент шаблона &lt;b&gt;регулярного выражения&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="f5c9d218e3a29ce718317121d0020d3ccf6b9e88" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; specifying how many times the foregoing &lt;b&gt;atom&lt;/b&gt; may occur.</source>
          <target state="translated">Компонент &lt;b&gt;регулярного выражения,&lt;/b&gt; определяющий, сколько раз может встречаться вышеупомянутый &lt;b&gt;атом&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ca17448c2b0615d183e89c2b8af18e1466ef0123" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; that must be true for the pattern to match but does not necessarily match any characters itself. Often used specifically to mean a &lt;b&gt;zero-width&lt;/b&gt; assertion.</source>
          <target state="translated">Компонент &lt;b&gt;регулярного выражения,&lt;/b&gt; который должен быть истинным для соответствия шаблону, но не обязательно должен соответствовать каким-либо символам. Часто используется специально для обозначения утверждения &lt;b&gt;нулевой ширины&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e4b110fd2e9cb16d7f0633f61d623ac063cd7727" translate="yes" xml:space="preserve">
          <source>A comprehensive list of Perl-related mailing lists can be found at &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;</source>
          <target state="translated">Полный список списков рассылки, связанных с Perl, можно найти на &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93cab815f48685f272ec4cd3a106ebc83fa3cbb8" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of the Korean (&lt;code&gt;KS *&lt;/code&gt;) standards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b95e9b387684f580231ace97a79e9e9349d1ddf" translate="yes" xml:space="preserve">
          <source>A consequence of the &lt;code&gt;split&lt;/code&gt; formulation is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffdc43a299a7177f53314c9b7e876aeb0c84ac8" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="translated">Следствием этого является то, что &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = number&lt;/b&gt; никогда не проверяет версию, если сам &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; не настроен для проверки версии, что может произойти, например, если</target>
        </trans-unit>
        <trans-unit id="350e3e899dba4b57e7486366f0fbf9264f9b61f7" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt; , for technical reasons.</source>
          <target state="translated">Константа с именем в списке &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; не допускается нигде, кроме как в пакете &lt;code&gt;main::&lt;/code&gt; , по техническим причинам.</target>
        </trans-unit>
        <trans-unit id="33082690d5a42fa2c8743ad22c40a6af2321de88" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt;, for technical reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f90a10d8180ed5dc542d1b277136194356a682" translate="yes" xml:space="preserve">
          <source>A construct that performs something repeatedly, like a roller coaster.</source>
          <target state="translated">Конструкция,которая выполняет что-то многократно,например,американские горки.</target>
        </trans-unit>
        <trans-unit id="98c376c5464a7cbd0f7597422425141a29b3dc1e" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Конструкция, которая иногда выглядит как функция, но на самом деле таковой не является. Обычно зарезервировано для модификаторов &lt;b&gt;lvalue&lt;/b&gt; , таких как &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , для модификаторов &lt;b&gt;контекста&lt;/b&gt; , таких как &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; , и для конструкций pick-your-own-quotes, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="806f6b00b71ddb7f8c4ade43c00b3953a355f7bd" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;my&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;scalar&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;q//&lt;/code&gt;, &lt;code&gt;qq//&lt;/code&gt;, &lt;code&gt;qx//&lt;/code&gt;, &lt;code&gt;qw//&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt;, &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;y///&lt;/code&gt;, and &lt;code&gt;tr///&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8552f673941f3d1978946011be4253061336584" translate="yes" xml:space="preserve">
          <source>A contact email address for the author/maintainer</source>
          <target state="translated">Контактный адрес электронной почты автора/монтажника</target>
        </trans-unit>
        <trans-unit id="1e9afcf85fc0132156a56c6d8cb4ffccff6b369d" translate="yes" xml:space="preserve">
          <source>A convenience function which combines creating an object and calling &lt;code&gt;isa_ok()&lt;/code&gt; on that object.</source>
          <target state="translated">Удобная функция, которая сочетает создание объекта и вызов &lt;code&gt;isa_ok()&lt;/code&gt; для этого объекта.</target>
        </trans-unit>
        <trans-unit id="53128330b7badc08928ea23290fdacf578eb391d" translate="yes" xml:space="preserve">
          <source>A convenience variable which is typically used with &lt;code&gt;SvPV&lt;/code&gt; when one doesn't care about the length of the string. It is usually more efficient to either declare a local variable and use that instead or to use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro.</source>
          <target state="translated">Удобная переменная, которая обычно используется с &lt;code&gt;SvPV&lt;/code&gt; , когда не важна длина строки. Обычно более эффективно либо объявить локальную переменную и использовать ее вместо &lt;code&gt;SvPV_nolen&lt;/code&gt; либо использовать макрос SvPV_nolen .</target>
        </trans-unit>
        <trans-unit id="df5714f0f92eb562b41f83c46ccd5b057e98cc38" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of &lt;code&gt;ARRAY&lt;/code&gt; references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638f854b99669da73bce286ea189e697af8d4b5f" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of ARRAY references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="translated">Удобный ярлык для работы с четными списками пар,данная функция возвращает список ссылок ARRAY,каждый из которых содержит два элемента из данного списка.Это более эффективная версия</target>
        </trans-unit>
        <trans-unit id="1166e931ea27a942799d52c7c1f3e445e7d6efa2" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the first values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">Удобный ярлык для работы с четными списками пар,данная функция возвращает список первых значений каждой из пар в данном списке.Это более эффективная версия</target>
        </trans-unit>
        <trans-unit id="0dbcf107b79ffefab41fba2fbb5cf9a734cd1746" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the second values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">Удобный ярлык для работы с четными списками пар,данная функция возвращает список вторых значений каждой из пар в данном списке.Это более эффективная версия</target>
        </trans-unit>
        <trans-unit id="77f68a02d61a77d7eed2d175da1b876e8aceace1" translate="yes" xml:space="preserve">
          <source>A convenient way to set up your tests. Call this and Test::Builder will print the appropriate headers and take the appropriate actions.</source>
          <target state="translated">Удобный способ настройки тестов.Позвоните этому и Test::Builder распечатает соответствующие заголовки и предпримет соответствующие действия.</target>
        </trans-unit>
        <trans-unit id="d87e8f492879ce02bf236daf94692483d0fd4b5c" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . This implementation doesn't allow arbitrary inheritance.</source>
          <target state="translated">Обычная (не вывернутая наизнанку) реализация, в которой объект представляет собой хэш, в котором хранятся значения полей, без поддержки &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . Эта реализация не допускает произвольного наследования.</target>
        </trans-unit>
        <trans-unit id="e03c6ee9246ced2486b144fcb4c37588f21f6f7f" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt;. This implementation doesn't allow arbitrary inheritance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646b8162acfbdd090f426555f4c9a32ee73eeb01" translate="yes" xml:space="preserve">
          <source>A copy of IO::Scalar for Test::Builder</source>
          <target state="translated">Копия IO::Scalar для теста::Builder</target>
        </trans-unit>
        <trans-unit id="5a070156d8ac581b1ec13fda608b6d3f5d95a087" translate="yes" xml:space="preserve">
          <source>A copy of a Win* viewer is contained in the &quot;Just add OS/2 Warp&quot; package</source>
          <target state="translated">Копия программы просмотра Win*содержится в пакете &quot;Просто добавьте искривление OS/2&quot;.</target>
        </trans-unit>
        <trans-unit id="6e407ab7758af4150015ce0b8baf63576cf02a27" translate="yes" xml:space="preserve">
          <source>A copyright notice - see below.</source>
          <target state="translated">Уведомление об авторских правах-см.ниже.</target>
        </trans-unit>
        <trans-unit id="d687cc7b81ffa630de399555f3a224dda7b56cfa" translate="yes" xml:space="preserve">
          <source>A correct CPAN version number is a floating point number with at least 2 digits after the decimal. You can test whether it conforms to CPAN by using</source>
          <target state="translated">Правильным номером версии CPAN является число с плавающей точкой,содержащее не менее 2-х цифр после запятой.Вы можете проверить,соответствует ли оно номеру CPAN с помощью</target>
        </trans-unit>
        <trans-unit id="8295d6831975ca50ed9530db07dca19a25c715be" translate="yes" xml:space="preserve">
          <source>A count passed to Tpad to modify the padding applied to the output string. If $cnt is zero or one then the resulting string will be cached.</source>
          <target state="translated">Счетчик,переданный Tpad для изменения подкладки,примененной к выходной строке.Если $cnt равен нулю или единице,то результирующая строка будет кэширована.</target>
        </trans-unit>
        <trans-unit id="3ca2814f3e720b9b1b346f0c76354ef75ff06f2d" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;Грубое&lt;/a&gt; оглавление для набора man- страниц Perl можно найти в perltoc .</target>
        </trans-unit>
        <trans-unit id="2162bc552d862ed6307a58382e17717e6d290a61" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03adc2f14ebb3d0a7a9ba21528d13d42030133f9" translate="yes" xml:space="preserve">
          <source>A data debugging tool for the XS programmer</source>
          <target state="translated">Инструмент отладки данных для программиста XS.</target>
        </trans-unit>
        <trans-unit id="07e1664c3b50241d29a1670852c2daa101e50db7" translate="yes" xml:space="preserve">
          <source>A data repository. Instead of computing expensive answers several times, compute it once and save the result.</source>
          <target state="translated">Хранилище данных.Вместо того,чтобы несколько раз вычислять дорогие ответы,вычислите его один раз и сохраните результат.</target>
        </trans-unit>
        <trans-unit id="40b9a92df275c1cef5fb6a4e3d00cf2b3d4203b3" translate="yes" xml:space="preserve">
          <source>A data structure used internally by Perl for implementing associative arrays (hashes) efficiently. See also &lt;b&gt;bucket&lt;/b&gt;.</source>
          <target state="translated">Структура данных, используемая Perl внутри для эффективной реализации ассоциативных массивов (хешей). См. Также &lt;b&gt;ведро&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b6431d472e1b30028a75ba55229126e2e191ae3c" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="translated">Объявление может быть помещено в любое место, где может быть оператор, но не влияет на выполнение основной последовательности операторов: все объявления вступают в силу во время компиляции. Все объявления обычно помещаются в начало или конец скрипта. Однако, если вы используете частные переменные с лексической областью видимости, созданные с помощью &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; , вам нужно будет убедиться, что ваш формат или определение подпрограммы находится в той же области блока, что и my, если вы ожидайте доступа к этим частным переменным.</target>
        </trans-unit>
        <trans-unit id="07181764640c06f85b9c3b200709c9c9e50a1f77" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;my()&lt;/code&gt;, &lt;code&gt;state()&lt;/code&gt;, or &lt;code&gt;our()&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753d1d91d799e4e070ffae305c67c5e3d698281a" translate="yes" xml:space="preserve">
          <source>A default hashing algorithm, which will be adequate for most applications, is built into Berkeley DB. If you do need to use your own hashing algorithm it is possible to write your own in Perl and have &lt;b&gt;DB_File&lt;/b&gt; use it instead.</source>
          <target state="translated">В Berkeley DB встроен алгоритм хеширования по умолчанию, который подходит для большинства приложений. Если вам действительно нужно использовать свой собственный алгоритм хеширования, можно написать свой собственный на Perl и использовать его вместо &lt;b&gt;DB_File&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b9828da4e803d376a194bd30931557a328ae046c" translate="yes" xml:space="preserve">
          <source>A default site INSTALL.SKIP may be provided by setting then environment variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there isn't a distribution specific INSTALL.SKIP. If the environment variable EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be performed.</source>
          <target state="translated">Сайт по умолчанию INSTALL.SKIP может быть предоставлен путем установки переменной окружения EU_INSTALL_SITE_SKIPFILE,она будет использоваться только в том случае,если нет дистрибутива,специфичного для INSTALL.SKIP.Если переменная окружения EU_INSTALL_IGNORE_SKIP имеет значение true,то фильтрация установочного файла выполняться не будет.</target>
        </trans-unit>
        <trans-unit id="0e649d4a2c7d23eccbd6705217dd0baed80106ea" translate="yes" xml:space="preserve">
          <source>A deferred action like this:</source>
          <target state="translated">Отложенное действие,как это:</target>
        </trans-unit>
        <trans-unit id="3f6d365313b0491e7a9d65439f28a847ca8b2399" translate="yes" xml:space="preserve">
          <source>A deprecated property may also be stabilized, but this fact is not shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb6a6e39c30f33cc261f9965991eae25b915199" translate="yes" xml:space="preserve">
          <source>A deprecated property may be made unavailable in a future Perl version, so it is best to move away from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b7b32d1f43857ac978062d5529fcaa75b008c1" translate="yes" xml:space="preserve">
          <source>A description of how C types may be transformed to and from Perl types within an &lt;b&gt;extension&lt;/b&gt; module written in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">Описание того, как типы C могут быть преобразованы в типы Perl и из них в модуле &lt;b&gt;расширения,&lt;/b&gt; написанном на &lt;b&gt;XS&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="152e62c7af6a3030011c43a7ed3a060f156647cc" translate="yes" xml:space="preserve">
          <source>A description of the callable function in each module</source>
          <target state="translated">Описание вызываемой функции в каждом модуле</target>
        </trans-unit>
        <trans-unit id="a361777f63c2dac8a5f187498445ea69ff2e5fd2" translate="yes" xml:space="preserve">
          <source>A description of the module/package/extension etc.</source>
          <target state="translated">Описание модуля/пакета/расширения и т.д.</target>
        </trans-unit>
        <trans-unit id="2d3ff2a56a13511ba72ba40a6fa6a2c401a75cdb" translate="yes" xml:space="preserve">
          <source>A detailed document on Encode and PerlIO</source>
          <target state="translated">Подробный документ по кодированию и PerlIO</target>
        </trans-unit>
        <trans-unit id="6acb6151fda2f69cbd4a7ea5c8537d8c57875e5a" translate="yes" xml:space="preserve">
          <source>A device you can put things on the top of, and later take them back off in the opposite order in which you put them on. See &lt;b&gt;LIFO&lt;/b&gt;.</source>
          <target state="translated">Устройство, на которое можно положить предметы, а затем снять их в порядке, обратном их надеванию. См. &lt;b&gt;LIFO&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ce6d3879a0b885e4f02b96959f6d870d8f5b1fa8" translate="yes" xml:space="preserve">
          <source>A different approach is to autoload seldom-used Perl code. See the AutoSplit and AutoLoader modules in the standard distribution for that. Or you could locate the bottleneck and think about writing just that part in C, the way we used to take bottlenecks in C code and write them in assembler. Similar to rewriting in C, modules that have critical sections can be written in C (for instance, the PDL module from CPAN).</source>
          <target state="translated">Другой подход-автозагрузка редко используемого Perl кода.См.модули AutoSplit и AutoLoader в стандартном дистрибутиве для этого.Или вы можете найти узкое место и подумать о том,чтобы написать именно эту часть на C,как мы раньше брали узкие места в C-коде и записывали их в ассемблере.Подобно переписыванию на Си,модули,имеющие критические секции,могут быть написаны на Си (например,модуль PDL из CPAN).</target>
        </trans-unit>
        <trans-unit id="fd02787c52da0901c066d4ccff09232fd888e22e" translate="yes" xml:space="preserve">
          <source>A different type of portability issue arises when writing XS code: availability of a C compiler on the end-user's system. C brings with it its own portability issues, and writing XS code will expose you to some of those. Writing purely in Perl is an easier way to achieve portability.</source>
          <target state="translated">При написании кода XS возникает другой тип проблемы переносимости:наличие компилятора Си на системе конечного пользователя.C приносит с собой свои собственные проблемы переносимости,и написание XS-кода подвергнет вас некоторым из них.Написание чисто на Perl-более простой способ достижения переносимости.</target>
        </trans-unit>
        <trans-unit id="7549e9114a09a619af3acd4b50c3c4a53ce35871" translate="yes" xml:space="preserve">
          <source>A direct &lt;b&gt;connection&lt;/b&gt; that carries the output of one &lt;b&gt;process&lt;/b&gt; to the input of another without an intermediate temporary file. Once the pipe is set up, the two processes in question can read and write as if they were talking to a normal file, with some caveats.</source>
          <target state="translated">Прямое &lt;b&gt;соединение,&lt;/b&gt; которое переносит вывод одного &lt;b&gt;процесса&lt;/b&gt; на ввод другого без промежуточного временного файла. После того, как канал настроен, два рассматриваемых процесса могут читать и писать, как если бы они разговаривали с обычным файлом, с некоторыми оговорками.</target>
        </trans-unit>
        <trans-unit id="4b845b5f598804539b9d3429d1e0dde292769ef5" translate="yes" xml:space="preserve">
          <source>A distribution of modules to handle locale codes</source>
          <target state="translated">Распределение модулей для работы с кодами локали</target>
        </trans-unit>
        <trans-unit id="36dbba4844dbb20711f751da227a18044b073c86" translate="yes" xml:space="preserve">
          <source>A distribution's original author is usually the contact listed within this field. Co-maintainers, successor maintainers or mailing lists devoted to the distribution may also be listed in addition to or instead of the original author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6b7ccc64e5147f1acc2484c6d3b919c5bc2282" translate="yes" xml:space="preserve">
          <source>A document having more than one &quot;=encoding&quot; line should be considered an error. Pod processors may silently tolerate this if the not-first &quot;=encoding&quot; lines are just duplicates of the first one (e.g., if there's a &quot;=encoding utf8&quot; line, and later on another &quot;=encoding utf8&quot; line). But Pod processors should complain if there are contradictory &quot;=encoding&quot; lines in the same document (e.g., if there is a &quot;=encoding utf8&quot; early in the document and &quot;=encoding big5&quot; later). Pod processors that recognize BOMs may also complain if they see an &quot;=encoding&quot; line that contradicts the BOM (e.g., if a document with a UTF-16LE BOM has an &quot;=encoding shiftjis&quot; line).</source>
          <target state="translated">Документ,содержащий более одной строки &quot;=кодировка&quot;,следует считать ошибкой.Процессоры Pod могут молча терпеть это,если не первые строки &quot;=encoding&quot; являются просто дубликатами первой (например,если есть строка &quot;=encoding utf8&quot;,а затем еще одна строка &quot;=encoding utf8&quot;).Но процессоры Pod должны жаловаться,если в одном и том же документе есть противоречивые строки &quot;=кодирование&quot; (например,если в начале документа есть строка &quot;=кодирование utf8&quot;,а позже-&quot;=кодирование big5&quot;).Процессоры подшипников,распознающие закладки,также могут жаловаться,если они видят строку &quot;=encoding&quot;,противоречащую закладке (например,если документ с закладкой UTF-16LE имеет строку &quot;=encoding shiftjis&quot;).</target>
        </trans-unit>
        <trans-unit id="4df78e410296e2b3f4b712de1ae484fe7cd130b2" translate="yes" xml:space="preserve">
          <source>A document type tag for the file. This option is not set by default.</source>
          <target state="translated">Тэг типа документа для файла.Этот параметр не установлен по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d80c6e485dc27886043d9d72950290e87158018b" translate="yes" xml:space="preserve">
          <source>A domain of names. You needn&amp;rsquo;t worry about whether the names in one such domain have been used in another. See &lt;b&gt;package&lt;/b&gt;.</source>
          <target state="translated">Домен имен. Вам не нужно беспокоиться о том, использовались ли имена из одного такого домена в другом. См. &lt;b&gt;Пакет&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7598f11ff5b1103678a9d5639c3dfc75e6d4a5e6" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt; .</source>
          <target state="translated">Число двойной точности с плавающей запятой. Эта карта типов гарантирует возврат преобразования переменной в значение типа &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f284c3eb8e2f99c285a6237d4bc92dc027b78cd" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102050331265d60ae1056cdc3a0d24fd9e06376e" translate="yes" xml:space="preserve">
          <source>A double-quoted, interpolated string.</source>
          <target state="translated">Строка в двойных кавычках с интерполяцией.</target>
        </trans-unit>
        <trans-unit id="faeb399a5d08eaa739b873af03a2a402dd907834" translate="yes" xml:space="preserve">
          <source>A dummy layer which never exists on the layer stack. Instead when &quot;pushed&quot; it actually pops the stack removing itself, it then calls Binmode function table entry on all the layers in the stack - normally this (via PerlIOBase_binmode) removes any layers which do not have &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; bit set. Layers can modify that behaviour by defining their own Binmode entry.</source>
          <target state="translated">Фиктивный слой, который никогда не существует в стеке слоев. Вместо этого при &quot;нажатии&quot; он фактически выталкивает стек, удаляя себя, затем вызывает запись таблицы функции Binmode на всех слоях в стеке - обычно это (через PerlIOBase_binmode) удаляет все слои, для которых не установлен бит &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; . Слои могут изменять это поведение, определяя свою собственную запись Binmode.</target>
        </trans-unit>
        <trans-unit id="f90a52847d42c09984d572f3b595cda347017f00" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regex/gc&lt;/code&gt; .</source>
          <target state="translated">Неудачное совпадение или изменение целевой строки сбрасывают позицию. Если вы не хотите, чтобы позиция сбрасывалась после сбоя, добавьте &lt;code&gt;//c&lt;/code&gt; , как в &lt;code&gt;/regex/gc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5efee2d4f79d8ba35cf758e77756920ee770903" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regexp/gc&lt;/code&gt; . The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="translated">Неудачное совпадение или изменение целевой строки сбрасывают позицию. Если вы не хотите, чтобы позиция сбрасывалась после неудачного совпадения, добавьте &lt;code&gt;//c&lt;/code&gt; , как в &lt;code&gt;/regexp/gc&lt;/code&gt; . Текущая позиция в строке связана со строкой, а не с регулярным выражением. Это означает, что разные строки имеют разные позиции, и их соответствующие позиции могут быть установлены или прочитаны независимо.</target>
        </trans-unit>
        <trans-unit id="7f27a18129c02d053ab6f802e18b05e35c62f037" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;/c&lt;/code&gt;, as in &lt;code&gt;/regex/gc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67a945b29a3d1fe6def81e71ffaffd29e4c4803" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;/c&lt;/code&gt;, as in &lt;code&gt;/regexp/gc&lt;/code&gt;. The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656a7d55b2753fa751b87d85db4a4654a61963c4" translate="yes" xml:space="preserve">
          <source>A fairly common feature in applications is to allow you to define a C function that will be called whenever something nasty occurs. What we would like is to be able to specify a Perl subroutine that will be called instead.</source>
          <target state="translated">Довольно распространенной функцией в приложениях является возможность определения функции C,которая будет вызываться всякий раз,когда происходит что-то неприятное.Нам бы хотелось иметь возможность указать подпрограмму Perl,которая будет вызываться вместо нее.</target>
        </trans-unit>
        <trans-unit id="4373b47dc81d066ae69b5e362fdbfdc644e26aed" translate="yes" xml:space="preserve">
          <source>A fairly common use-case is where compressed data is embedded in a larger file/buffer and you want to read both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23193c87a7c196063bf7501e9b39457a40a9ece" translate="yes" xml:space="preserve">
          <source>A faithful representation of the value used to initialize this version object. The only time this will not be precisely the same characters that exist in the source file is if a short dotted-decimal version like v1.2 was used (in which case it will contain 'v1.2'). This form is &lt;b&gt;STRONGLY&lt;/b&gt; discouraged, in that it will confuse you and your users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145432bffd79619206143de90cf2e154ae94a2c3" translate="yes" xml:space="preserve">
          <source>A false value, in scalar context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27669facce8e75680a82515ceb4a7dde4554488" translate="yes" xml:space="preserve">
          <source>A fancy computer science term meaning &amp;ldquo;to follow a &lt;b&gt;reference&lt;/b&gt; to what it points to&amp;rdquo;. The &amp;ldquo;de&amp;rdquo; part of it refers to the fact that you&amp;rsquo;re taking away one level of &lt;b&gt;indirection&lt;/b&gt;.</source>
          <target state="translated">Причудливый компьютерный термин, означающий &amp;laquo;следовать &lt;b&gt;ссылке&lt;/b&gt; на то, на что она указывает&amp;raquo;. Часть &amp;laquo;де&amp;raquo; относится к тому факту, что вы убираете один уровень &lt;b&gt;косвенности&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4dde098cc45c330d3e8fa85a502fc0eae6cde3" translate="yes" xml:space="preserve">
          <source>A fancy kind of interlock that prevents multiple &lt;b&gt;threads&lt;/b&gt; or &lt;b&gt;processes&lt;/b&gt; from using up the same resources simultaneously.</source>
          <target state="translated">Замечательный вид блокировки, который предотвращает одновременное использование одних и тех же ресурсов несколькими &lt;b&gt;потоками&lt;/b&gt; или &lt;b&gt;процессами&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2f52178a4e9cc243237404e962bb98cf1d11d03e" translate="yes" xml:space="preserve">
          <source>A fancy term for an error. See &lt;b&gt;fatal error&lt;/b&gt;.</source>
          <target state="translated">Замечательный термин для обозначения ошибки. Смотрите &lt;b&gt;фатальную ошибку&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d130552cd3247973054cf88d786bc01b68b3a6e5" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if the Compress::Zlib module is not available.</source>
          <target state="translated">Если модуль Compress::Zlib не будет доступен,будет выброшена фатальная ошибка.</target>
        </trans-unit>
        <trans-unit id="c1f172aa731045204a1719d56bb2cc8625060274" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if:</source>
          <target state="translated">Фатальная ошибка будет выброшена,если:</target>
        </trans-unit>
        <trans-unit id="206dcfa56d21a53d3ca90835f2da1335f0ce9141" translate="yes" xml:space="preserve">
          <source>A feature of &lt;b&gt;operator overloading&lt;/b&gt; of &lt;b&gt;objects&lt;/b&gt;, whereby the behavior of certain &lt;b&gt;operators&lt;/b&gt; can be reasonably deduced using more fundamental operators. This assumes that the overloaded operators will often have the same relationships as the regular operators. See Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">Особенность &lt;b&gt;перегрузки операторов&lt;/b&gt; из &lt;b&gt;объектов&lt;/b&gt; , в результате чего поведение некоторых &lt;b&gt;операторов&lt;/b&gt; может быть разумно выведено с использованием более фундаментальными операторов. Это предполагает, что перегруженные операторы часто имеют те же отношения, что и обычные операторы. См. Главу 13 &amp;laquo;Camel&amp;raquo;, &amp;laquo;Перегрузка&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="96f7456dc10c0f5e5c69de568de641b9d361467e" translate="yes" xml:space="preserve">
          <source>A few dir-vs-file optimizations result in glob importation being 10 times faster than using perlglob.exe, and using perlglob.bat is only twice as slow as perlglob.exe (GSAR 28-MAY-97)</source>
          <target state="translated">В результате нескольких оптимизаций dir-vs-файлов импорт глобуса происходит в 10 раз быстрее,чем при использовании perlglob.exe,а использование perlglob.bat лишь в два раза медленнее,чем perlglob.exe (GSAR 28-MAY-97).</target>
        </trans-unit>
        <trans-unit id="29b977997a9e174d5b0509df5c6aa92021e1d1e4" translate="yes" xml:space="preserve">
          <source>A few example globmaps</source>
          <target state="translated">Несколько примеров глобусов</target>
        </trans-unit>
        <trans-unit id="4079515a56f3376aa599af18d3ce02d4fa762708" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &quot;.</source>
          <target state="translated">Некоторые функции не реализованы, потому что они специфичны для C. Если вы попытаетесь вызвать их, они напечатают сообщение о том, что они не реализованы, и предложат использовать эквивалент Perl, если он существует. Например, попытка доступа к вызову &lt;code&gt;setjmp()&lt;/code&gt; вызовет сообщение &amp;laquo; &lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a9aa66452d6cc33fe8925436987e0f746352b862" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: use eval {} instead&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0bccac60c0333be23e859b75e6846e6cbff2f2" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#endpwent&quot;&gt;&lt;code&gt;endpwent&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;time+86_400&lt;/code&gt; always means &lt;code&gt;time() + 86_400&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd9feea0227978a722652bf64b2da3e239d9119" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; always means &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; .</source>
          <target state="translated">Некоторые функции вообще не принимают аргументов и поэтому не работают ни как унарные, ни как списковые операторы. К ним относятся такие функции, как &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt; . Например, &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; всегда означает &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18d4ec4509605bbb34d201f389b34f426f595148" translate="yes" xml:space="preserve">
          <source>A few general-purpose tools are shipped with perl, mostly because they came along modules included in the perl distribution.</source>
          <target state="translated">Несколько инструментов общего назначения поставляются с perl,в основном потому,что они поставляются с модулями,включенными в дистрибутив perl.</target>
        </trans-unit>
        <trans-unit id="6c69ec260ad056301204f0c643b8c2696665eb7e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="translated">Предлагается несколько методов для &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; за вас.</target>
        </trans-unit>
        <trans-unit id="8472b15b35050b2df3090f934f689efe2217997e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;use Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6d4c905f963b3015f8686516337be08979225b" translate="yes" xml:space="preserve">
          <source>A few more:</source>
          <target state="translated">Еще несколько:</target>
        </trans-unit>
        <trans-unit id="f6dd53866881999d8a6a377532c2c8626c21bab7" translate="yes" xml:space="preserve">
          <source>A few of the entries in the list below are marked as DEPRECATED. You should not use these for new code, and should be converting existing uses to use something better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb9b3626d6aeb9e84350d1131ed3080f1617e37" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="translated">Некоторые варианты требуют дополнительного обсуждения. При использовании C-эквивалент ключей &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; и &lt;code&gt;prefix&lt;/code&gt; сохраняет указатели на функции C. В &lt;b&gt;DB_File&lt;/b&gt; эти ключи используются для хранения ссылок на &lt;b&gt;подпрограммы&lt;/b&gt; Perl. Ниже приведены шаблоны для каждой из подписок:</target>
        </trans-unit>
        <trans-unit id="492f5e2fcdceaa8c5ab146c091e30572e3a68f3d" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c283830e9199de7049f4c9e9b8481f0f4f024e4c" translate="yes" xml:space="preserve">
          <source>A few of these variables are considered &quot;read-only&quot;. This means that if you try to assign to this variable, either directly or indirectly through a reference, you'll raise a run-time exception.</source>
          <target state="translated">Некоторые из этих переменных считаются &quot;только для чтения&quot;.Это означает,что если вы попытаетесь присвоить эту переменную,прямо или косвенно,по ссылке,вы поднимете исключение во время выполнения.</target>
        </trans-unit>
        <trans-unit id="8090aa705fafbfcbe40caa6a39d4969f2ffa75f0" translate="yes" xml:space="preserve">
          <source>A few points to note about this example:</source>
          <target state="translated">Отметим несколько моментов об этом примере:</target>
        </trans-unit>
        <trans-unit id="5940abb3e966e0e3ab0e5074976963a86d9bf337" translate="yes" xml:space="preserve">
          <source>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</source>
          <target state="translated">Несколько специальных голов SV не выделяются с арены,а создаются непосредственно в структуре интерпретатора,например PL_sv_undef.Размер арен может быть изменен по умолчанию путем соответствующей установки PERL_ARENA_SIZE во время компиляции.</target>
        </trans-unit>
        <trans-unit id="99bc1dc13c67f6154f44d88464d4083e5ca5c87d" translate="yes" xml:space="preserve">
          <source>A fifo is convenient when you want to connect a process to an unrelated one. When you open a fifo, the program will block until there's something on the other end.</source>
          <target state="translated">Фитография fifo удобна,когда вы хотите подключить процесс к не связанному с ним.Когда вы открываете пятёрку,программа будет блокироваться до тех пор,пока на другом конце не появится что-нибудь.</target>
        </trans-unit>
        <trans-unit id="0034cae2f50c204559522cfff1ceebd6deb989fa" translate="yes" xml:space="preserve">
          <source>A file containing certain required definitions that you must include &amp;ldquo;ahead&amp;rdquo; of the rest of your program to do certain obscure operations. A C header file has a</source>
          <target state="translated">Файл, содержащий определенные обязательные определения, которые вы должны включить &amp;laquo;перед&amp;raquo; остальной частью вашей программы для выполнения определенных непонятных операций. Заголовочный файл AC имеет</target>
        </trans-unit>
        <trans-unit id="731000aad647991373ca7dfb79bf96ee23280bc2" translate="yes" xml:space="preserve">
          <source>A file full of regular expressions to exclude when using 'make manifest' to generate the MANIFEST. These regular expressions are checked against each file path found in the distribution (so you're matching against &quot;t/foo.t&quot; not &quot;foo.t&quot;).</source>
          <target state="translated">Файл,полный регулярных выражений для исключения при использовании 'make manifest' для генерации MANIFEST.Эти регулярные выражения проверяются по каждому пути к файлу,найденному в дистрибутиве (поэтому вы сравниваете их с &quot;t/foo.t&quot;,а не с &quot;foo.t&quot;).</target>
        </trans-unit>
        <trans-unit id="a17865a45ecaf1ad63bbdbb5dd8742ba69a071dc" translate="yes" xml:space="preserve">
          <source>A file in XS format starts with a C language section which goes until the first &lt;code&gt;MODULE =&lt;/code&gt; directive. Other XS directives and XSUB definitions may follow this line. The &quot;language&quot; used in this part of the file is usually referred to as the XS language. &lt;b&gt;xsubpp&lt;/b&gt; recognizes and skips POD (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) in both the C and XS language sections, which allows the XS file to contain embedded documentation.</source>
          <target state="translated">Файл в формате XS начинается с раздела языка C, который продолжается до первой директивы &lt;code&gt;MODULE =&lt;/code&gt; . Другие директивы XS и определения XSUB могут следовать за этой строкой. &amp;laquo;Язык&amp;raquo;, используемый в этой части файла, обычно называется языком XS. &lt;b&gt;xsubpp&lt;/b&gt; распознает и пропускает POD (см. &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; ) как в языковых разделах C, так и в XS, что позволяет файлу XS содержать встроенную документацию.</target>
        </trans-unit>
        <trans-unit id="ef34906ac9f2871761f209af13c79ffbe88cb8f1" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;, except for &lt;code&gt;-t&lt;/code&gt;, which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno). With the exception of the &lt;code&gt;-l&lt;/code&gt; test they all follow symbolic links because they use &lt;code&gt;stat()&lt;/code&gt; and not &lt;code&gt;lstat()&lt;/code&gt; (so dangling symlinks can't be examined and will therefore report failure).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51841b4270c479a7cdbc29c3d5f66446edf393a3" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">Файл test, где X - одна из букв, перечисленных ниже. Этот унарный оператор принимает один аргумент, либо имя файла, либо дескриптор файла, либо дескриптор каталога, и проверяет связанный файл, чтобы узнать, верно ли что-то в нем. Если аргумент опущен, проверяет &lt;code&gt;$_&lt;/code&gt; , за исключением &lt;code&gt;-t&lt;/code&gt; , который проверяет STDIN. Если не указано иное, он возвращает &lt;code&gt;1&lt;/code&gt; для истины и &lt;code&gt;''&lt;/code&gt; для false. Если файл не существует или не может быть исследован, он возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно). Несмотря на забавные названия, приоритет такой же, как и у любого другого именованного унарного оператора. Оператор может быть любым из:</target>
        </trans-unit>
        <trans-unit id="1c04b0088e704fdeb38d1fecd8838e16e9a29f09" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">Файл test, где X - одна из букв, перечисленных ниже. Этот унарный оператор принимает один аргумент, либо имя файла, либо дескриптор файла, либо дескриптор каталога, и проверяет связанный файл, чтобы узнать, верно ли что-то в нем. Если аргумент опущен, проверяет &lt;code&gt;$_&lt;/code&gt; , за исключением &lt;code&gt;-t&lt;/code&gt; , который проверяет STDIN. Если не указано иное, он возвращает &lt;code&gt;1&lt;/code&gt; для истины и &lt;code&gt;''&lt;/code&gt; для false. Если файл не существует или не может быть исследован, он возвращает &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; и устанавливает &lt;code&gt;$!&lt;/code&gt; (эррно). Несмотря на забавные названия, приоритет такой же, как и у любого другого именованного унарного оператора. Оператор может быть любым из:</target>
        </trans-unit>
        <trans-unit id="85304934df21007f1e6dacead79952e515167d3e" translate="yes" xml:space="preserve">
          <source>A file that controls the compilation of a program. Perl programs don&amp;rsquo;t usually need a &lt;b&gt;Makefile&lt;/b&gt; because the Perl compiler has plenty of self-control.</source>
          <target state="translated">Файл, управляющий компиляцией программы. Программы Perl обычно не нуждаются в &lt;b&gt;Makefile,&lt;/b&gt; потому что компилятор Perl обладает достаточным самоконтролем.</target>
        </trans-unit>
        <trans-unit id="9c91c447fc7873fa1590ab524304262f61375872" translate="yes" xml:space="preserve">
          <source>A filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef0646f1946010fd71391d670cdd7f3f2cde9ba" translate="yes" xml:space="preserve">
          <source>A filehandle for catching standard output.</source>
          <target state="translated">Ручка-файл для захвата стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="dddbea875ae221e63e546196812256d3f13f54a9" translate="yes" xml:space="preserve">
          <source>A filehandle is opened but the file operations are performed &quot;in-memory&quot; on a scalar variable. All the normal file operations can be performed on the handle. The scalar is considered a stream of bytes. Currently fileno($fh) returns -1.</source>
          <target state="translated">Открывается файловый менеджер,но выполняются файловые операции &quot;в памяти&quot; над скалярной переменной.Все обычные операции с файлами можно выполнять с помощью дескриптора.Скаляр считается потоком байт.В настоящее время fileno($fh)возвращает -1.</target>
        </trans-unit>
        <trans-unit id="2ead9b8d6ddfb62275b7ebf2bc90be0c9e8b9ced" translate="yes" xml:space="preserve">
          <source>A filehandle that should read or write UTF-8</source>
          <target state="translated">Ручка файлов,которая должна прочитать или записать UTF-8.</target>
        </trans-unit>
        <trans-unit id="c2227149e71cd22222d8c43a50c19d04660c6c2c" translate="yes" xml:space="preserve">
          <source>A filehandle to write the C code to. If not given, then</source>
          <target state="translated">Ручка файлов для написания кода на C.Если не указано,то</target>
        </trans-unit>
        <trans-unit id="51118efef78727e7eccbadc9f314bd7f4afcf597" translate="yes" xml:space="preserve">
          <source>A filehandle to write the XS code to. If not given, then</source>
          <target state="translated">Ручка файлов для написания кода XS.Если не указано,то</target>
        </trans-unit>
        <trans-unit id="94e7ed7be4ff1750888b6ea45dc5effd2b37d94d" translate="yes" xml:space="preserve">
          <source>A filehandle, from which the file will be read.</source>
          <target state="translated">Ручка файлов,из которой будет читаться файл.</target>
        </trans-unit>
        <trans-unit id="7c79e2e3cdb811630721119bd1fda8fa5ffcd8fa" translate="yes" xml:space="preserve">
          <source>A filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34303a3b313a718df7cf274a0efcf1c25994c0c" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; , and &lt;code&gt;-C&lt;/code&gt; , as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="translated">Оператор проверки файлов с четырьмя исключениями: &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; и &lt;code&gt;-C&lt;/code&gt; , поскольку они возвращают числовые значения, а не логические. Оператор &lt;code&gt;-z&lt;/code&gt; filetest не включен в список исключений.</target>
        </trans-unit>
        <trans-unit id="f4fe6298165162f938688f8a2c671c5d42d80d9b" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;-A&lt;/code&gt;, and &lt;code&gt;-C&lt;/code&gt;, as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571b7a68e22aaaa36cb39947748347ab43ae89aa" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done.</source>
          <target state="translated">Программа-фильтр,в традиционном понимании Unix (ввод из stdin,вывод в stdout),которая передается в каждом .pm файле во время сборки (в фазе pm_to_blib()).По умолчанию он пуст,что означает,что фильтрация не производится.</target>
        </trans-unit>
        <trans-unit id="f1bffd13ce3099184de722f73a1304bb3285fcc2" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done. You could use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb35ae131a8a2012ab4bde2210fbfdcbd7023aa3" translate="yes" xml:space="preserve">
          <source>A fix for Proc::ProcessTable is to edit Makefile to explicitly remove the largefile flags from the ones MakeMaker picks up from Config.pm. This will result in Proc::ProcessTable being built under the correct environment. Everything should then be OK as long as Proc::ProcessTable doesn't try to share off_t's with the rest of perl, or if it does they should be explicitly specified as off64_t.</source>
          <target state="translated">Исправление для Proc::ProcessTable заключается в редактировании Makefile для явного удаления флагов большого профиля из тех,которые MakeMaker поднимает с Config.pm.В результате Proc::ProcessTable будет собрана в правильном окружении.Тогда все должно быть в порядке,пока Proc::ProcessTable не пытается поделиться off_t с остальными perl,а если и пытается,то они должны быть явно указаны как off64_t.</target>
        </trans-unit>
        <trans-unit id="a9d22545c3578b64eb5fa290d40cfb8cd3124e35" translate="yes" xml:space="preserve">
          <source>A fix for that problem is scheduled to be released in the following levels of AIX, all of which should be coming out in the 4th quarter of 2009:</source>
          <target state="translated">Решение этой проблемы планируется выпустить на следующих уровнях AIX,все из которых должны выйти в 4-м квартале 2009 года:</target>
        </trans-unit>
        <trans-unit id="42701417421c1ef72d52e9b7e2d8ce1f61f1f95a" translate="yes" xml:space="preserve">
          <source>A fixed hard disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcd311c30c802b9eee4a011f2523c74bbb4eeb7" translate="yes" xml:space="preserve">
          <source>A fixed length thing, given as a [pointer, length] pair. If you know the length of a string at compile time you may use this instead of</source>
          <target state="translated">Фиксированная длина,заданная в виде пары [указатель,длина].Если вы знаете длину строки во время компиляции,вы можете использовать это вместо</target>
        </trans-unit>
        <trans-unit id="2dd9070969808d13493b31f8533aee2df5f82471" translate="yes" xml:space="preserve">
          <source>A fixed number of digits before (positive) or after (negative) the decimal point. For example, 123.45 has a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means two digits to the left of the decimal point are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before the decimal point may have different precisions, because 1200 can have p = 0, 1 or 2 (depending on what the initial value was). It could also have p &amp;lt; 0, when the digits after the decimal point are zero.</source>
          <target state="translated">Фиксированное количество цифр до (положительное) или после (отрицательное) десятичной точки. Например, 123,45 имеет точность -2. 0 означает целое число, например 123 (или 120). Точность 2 означает, что две цифры слева от десятичной точки равны нулю, поэтому 123 с P = 1 становится 120. Обратите внимание, что числа с нулями перед десятичной точкой могут иметь разную точность, потому что 1200 может иметь p = 0, 1 или 2 (в зависимости от начального значения). Он также может иметь p &amp;lt;0, когда цифры после десятичной точки равны нулю.</target>
        </trans-unit>
        <trans-unit id="27aa36567c7de687c1256c668f8713e83fe0a789" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="translated">Флаг, указывающий, является ли элемент 3 (если есть) URL-адресом (например, &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; ), и в этом случае не должно быть атрибута раздела; имя Pod (например, &quot;perldoc&quot; и &quot;Getopt :: Std&quot;); или, возможно, имя страницы руководства (например, &quot;crontab (5)&quot;).</target>
        </trans-unit>
        <trans-unit id="106d15351f4a75ec3f2797be6646ec091bf455c8" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;http://lists.perl.org&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa81fd53ffda939e60f21a6a48bc3fd1ecb33421" translate="yes" xml:space="preserve">
          <source>A floating point number potentially has a sign, an integral part, a decimal point, a fractional part, and an exponent. One or more of these parts is optional, so we need to check out the different possibilities. Floating point numbers which are in proper form include 123., 0.345, .34, -1e6, and 25.4E-72. As with integers, the sign out front is completely optional and can be matched by &lt;code&gt;[+-]?&lt;/code&gt;. We can see that if there is no exponent, floating point numbers must have a decimal point, otherwise they are integers. We might be tempted to model these with &lt;code&gt;\d*\.\d*&lt;/code&gt;, but this would also match just a single decimal point, which is not a number. So the three cases of floating point number without exponent are</source>
          <target state="translated">Число с плавающей запятой потенциально может иметь знак, целую часть, десятичную точку, дробную часть и показатель степени. Одна или несколько из этих частей являются необязательными, поэтому нам нужно проверить различные возможности. Числа с плавающей запятой в правильной форме включают 123., 0,345, .34, -1e6 и 25,4E-72. Как и в случае с целыми числами, знак спереди не является обязательным и может быть заменен знаком &lt;code&gt;[+-]?&lt;/code&gt; . Мы видим, что при отсутствии показателя степени числа с плавающей запятой должны иметь десятичную точку, в противном случае они являются целыми числами. У нас может возникнуть соблазн смоделировать их с помощью &lt;code&gt;\d*\.\d*&lt;/code&gt; , но это также будет соответствовать только одной десятичной запятой, которая не является числом. Итак, три случая чисел с плавающей запятой без экспоненты:</target>
        </trans-unit>
        <trans-unit id="ff8a1f9e295a3b368fdb0bcb2f6682d3f1a7706d" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt; .</source>
          <target state="translated">Число с плавающей запятой. Эта карта типов гарантирует возврат преобразования переменной в число с &lt;code&gt;float&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="989e51ade0bc6499f4e6912c535b030573178b2b" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032a7b56b1da4c1e8613c276b9cfb6d58696eaf8" translate="yes" xml:space="preserve">
          <source>A floppy diskette drive or other removable media drive, but not a CD-ROM drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb62089bcb14b38f0a60a1ce278c6aa2cfaf6aec" translate="yes" xml:space="preserve">
          <source>A flow of data into or out of a process as a steady sequence of bytes or characters, without the appearance of being broken up into packets. This is a kind of &lt;b&gt;interface&lt;/b&gt;&amp;mdash;the underlying &lt;b&gt;implementation&lt;/b&gt; may well break your data up into separate packets for delivery, but this is hidden from you.</source>
          <target state="translated">Поток данных в процесс или из процесса в виде устойчивой последовательности байтов или символов без видимого разбиения на пакеты. Это своего рода &lt;b&gt;интерфейс&lt;/b&gt; - базовая &lt;b&gt;реализация&lt;/b&gt; вполне может разбить ваши данные на отдельные пакеты для доставки, но это скрыто от вас.</target>
        </trans-unit>
        <trans-unit id="e81e65da76994db0744db8c12c18f7cc1632c8c6" translate="yes" xml:space="preserve">
          <source>A fork of &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; that provides version checking in parent class modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f93ab55d0cd5dedac331be7a34ca8ef2c56a43" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt; . Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; , and &lt;code&gt;'NFKC'&lt;/code&gt; . See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="translated">Имя формы, которое принимает &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; будет применяться как &lt;code&gt;$normalization_form&lt;/code&gt; . Допустимые названия включают &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; и &lt;code&gt;'NFKC'&lt;/code&gt; . См. Подробности в &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; . Если не &lt;code&gt;'NFD'&lt;/code&gt; используется &amp;laquo;NFD&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="561ab06d7f47c467c676cc1068bd4564e1083a7b" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt;. Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt;, &lt;code&gt;'NFC'&lt;/code&gt;, &lt;code&gt;'NFKD'&lt;/code&gt;, and &lt;code&gt;'NFKC'&lt;/code&gt;. See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49b8a933b39ce175d6f4d01ed275b88dda586c3" translate="yes" xml:space="preserve">
          <source>A form of &lt;b&gt;scalar context&lt;/b&gt; in which an &lt;b&gt;expression&lt;/b&gt; is not expected to return any &lt;b&gt;value&lt;/b&gt; at all and is evaluated for its &lt;b&gt;side effects&lt;/b&gt; alone.</source>
          <target state="translated">Форма &lt;b&gt;скалярного контекста,&lt;/b&gt; в которой не ожидается, что &lt;b&gt;выражение&lt;/b&gt; вообще вернет какое-либо &lt;b&gt;значение&lt;/b&gt; и оценивается только по его &lt;b&gt;побочным эффектам&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="95b8b92c738006a6a5118bef738de47b796e9ea2" translate="yes" xml:space="preserve">
          <source>A formal grammar would look similar to the following:</source>
          <target state="translated">Формальная грамматика будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="721d8611bd61e5ecdf8561b50e0139065e69ec6d" translate="yes" xml:space="preserve">
          <source>A formalized definition of the legal forms for version strings is included in the &lt;code&gt;version::regex&lt;/code&gt; class. Primitives are included for common elements, although they are scoped to the file so they are useful for reference purposes only. There are two publicly accessible scalars that can be used in other code (not exported):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6424f6bb5e3764fd5434bcd18cd75bdd7582fd" translate="yes" xml:space="preserve">
          <source>A format name of &quot;comment&quot; is common for just making notes (presumably to yourself) that won't appear in any formatted version of the Pod document:</source>
          <target state="translated">Название формата &quot;комментарий&quot; является обычным для простого создания заметок (предположительно для себя),которые не будут отображаться ни в одной из форматированных версий документа Pod:</target>
        </trans-unit>
        <trans-unit id="2446a10134816c33cde7e4a21588ee8f42d4b1d2" translate="yes" xml:space="preserve">
          <source>A formatter can specify by implementing the &lt;code&gt;hide_buffered()&lt;/code&gt; method. If this method returns true then events generated inside a buffered subtest will not be sent independently of the final subtest event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76335714c7e25f79355585f9f9381d9b64c34cd" translate="yes" xml:space="preserve">
          <source>A formatter is any package or object with a &lt;code&gt;write($event, $num)&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26b5fa96c287794c375f977fd86d1fe4bad1833" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by a &quot;&amp;lt;&quot;, any number of characters, and ending with the first matching &quot;&amp;gt;&quot;. Examples:</source>
          <target state="translated">Код форматирования начинается с заглавной буквы (только US-ASCII [AZ]), за которой следует &amp;laquo;&amp;lt;&amp;raquo;, любое количество символов, и заканчивается первым совпадающим знаком &amp;laquo;&amp;gt;&amp;raquo;. Примеры:</target>
        </trans-unit>
        <trans-unit id="e1ebaf29b6e50a9147fa41854529f9f91464bbca" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by two or more &quot;&amp;lt;&quot;'s, one or more whitespace characters, any number of characters, one or more whitespace characters, and ending with the first matching sequence of two or more &quot;&amp;gt;&quot;'s, where the number of &quot;&amp;gt;&quot;'s equals the number of &quot;&amp;lt;&quot;'s in the opening of this formatting code. Examples:</source>
          <target state="translated">Код форматирования начинается с заглавной буквы (только US-ASCII [AZ]), за которой следуют два или более символа &amp;laquo;&amp;lt;&amp;raquo;, один или несколько символов пробела, любое количество символов, один или несколько символов пробела и заканчиваются первым совпадающая последовательность из двух или более &quot;&amp;gt;&quot;, где количество &quot;&amp;gt;&quot; равно количеству &quot;&amp;lt;&quot; в открытии этого кода форматирования. Примеры:</target>
        </trans-unit>
        <trans-unit id="ee13838be926e942481224190d1b48d665a53c86" translate="yes" xml:space="preserve">
          <source>A free perl5-based PERL.NLM for Novell Netware is available in precompiled binary and source code form from &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt; as well as from CPAN.</source>
          <target state="translated">Бесплатная версия PERL.NLM на основе Perl5 для Novell Netware доступна в виде предварительно скомпилированного двоичного кода и исходного кода с &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/,&lt;/a&gt; а также с CPAN.</target>
        </trans-unit>
        <trans-unit id="3b03ecae28b894e59a1c00c717f1b1e736c5b6b6" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements Perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601ccb979c895092a89a9db855c8bb290abdfbb7" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="translated">Реализация буферизации для PerlIO с нуля. Обеспечивает быстрый доступ к буферу для &lt;code&gt;sv_gets&lt;/code&gt; , который реализует perl readline / &amp;lt;&amp;gt; и в целом пытается минимизировать копирование данных.</target>
        </trans-unit>
        <trans-unit id="0f062561102eb36fb52de67c711e92bb30c79c71" translate="yes" xml:space="preserve">
          <source>A full commandline to run via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;. During execution, the environment variable PERL is set to $^X (but with an absolute path). If &lt;code&gt;commandline&lt;/code&gt; is specified, &lt;code&gt;args&lt;/code&gt; is not used.</source>
          <target state="translated">Полная командная строка для запуска через &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; . Во время выполнения для переменной среды PERL устанавливается значение $ ^ X (но с абсолютным путем). Если &lt;code&gt;commandline&lt;/code&gt; задана, &lt;code&gt;args&lt;/code&gt; не используется.</target>
        </trans-unit>
        <trans-unit id="14cec31abd2e629547d353d78977abf26c0ffa5f" translate="yes" xml:space="preserve">
          <source>A full set of HTML documentation is installed, so you should be able to use it if you have a web browser installed on your system.</source>
          <target state="translated">Установлен полный набор HTML-документации,поэтому вы сможете пользоваться им,если в вашей системе установлен веб-браузер.</target>
        </trans-unit>
        <trans-unit id="6a2c1a54fe4430e99127181c7879f97150ac83b4" translate="yes" xml:space="preserve">
          <source>A fully qualified filename such as</source>
          <target state="translated">Полностью квалифицированное имя,например</target>
        </trans-unit>
        <trans-unit id="66350a7ced5e0598bbaa01d95aa21c1aa8b64d66" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt; .</source>
          <target state="translated">Функция с именем &lt;code&gt;new&lt;/code&gt; не должна быть явно определена в классе, созданном &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbfff922711d57d226b2688d07195e70805b9750" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2945149f02dd35ba51bde27d2145bb414391b9dd" translate="yes" xml:space="preserve">
          <source>A function returning a single scalar with &lt;code&gt;#define&lt;/code&gt; definitions for the constants used internally between the generated C and XS functions.</source>
          <target state="translated">Функция, возвращающая один скаляр с определениями &lt;code&gt;#define&lt;/code&gt; для констант, используемых внутри сгенерированных функций C и XS.</target>
        </trans-unit>
        <trans-unit id="b69855856bd43ed93ca10429f84d959193788fea" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="translated">Функция, которой нужен собственный дескриптор файла, должна использовать &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; для всего typeglob. Это можно использовать для создания новых записей в таблице символов:</target>
        </trans-unit>
        <trans-unit id="60bce2f6faa5df9b0e4a3b944a64f25b88cc7ae4" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;local()&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074e275ec83817fc8f7919a77c7d1bc574268f70" translate="yes" xml:space="preserve">
          <source>A function that returns a &lt;b&gt;list&lt;/b&gt; of C subroutine definitions that return the value and type of constants when passed the name by the XS wrapper.</source>
          <target state="translated">Функция, которая возвращает &lt;b&gt;список&lt;/b&gt; определений подпрограмм C, которые возвращают значение и тип констант при передаче имени оболочкой XS.</target>
        </trans-unit>
        <trans-unit id="16f5ca42729ef594d519db59b85f9698b43a3153" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt; , with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="translated">Функция для генерации кода Perl для Makefile.PL, который будет восстанавливать подпрограммы констант. Параметры имеют имена, переданные в &lt;code&gt;WriteConstants&lt;/code&gt; , с добавлением &lt;code&gt;INDENT&lt;/code&gt; для указания количества ведущих пробелов (по умолчанию 2).</target>
        </trans-unit>
        <trans-unit id="d909b3c9635ad08512fcce3363f9ca841d9148f8" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt;, with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1112f59bf733c8ebebfbb190c9c3efe0aeac9b" translate="yes" xml:space="preserve">
          <source>A function to generate the AUTOLOAD subroutine for the module</source>
          <target state="translated">Функция генерации подпрограммы AUTOLOAD для модуля</target>
        </trans-unit>
        <trans-unit id="b0a02614782733bf06479ea297bf790f7927505f" translate="yes" xml:space="preserve">
          <source>A function to generate the XS code to implement the perl subroutine</source>
          <target state="translated">Функция для генерации кода XS для реализации подпрограммы perl</target>
        </trans-unit>
        <trans-unit id="94d15a8aa6cbd7f8b0a2a414f5a5f7d2b35f7284" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for C's &quot;&quot; or ''. It will die if passed Unicode characters.</source>
          <target state="translated">Функция,которая корректно возвращает 7-битный ASCII \ экранированную версию переданной строки,подходящую для C &quot;&quot; или ''.При передаче символов Юникода она умирает.</target>
        </trans-unit>
        <trans-unit id="c45b17fcb375003bf4d5bd87967dc1245beb7fd4" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for a perl &quot;&quot; string.</source>
          <target state="translated">Функция,которая корректно возвращает 7-битный ASCII \ экранированную версию переданной строки,подходящей для строки perl &quot;&quot;.</target>
        </trans-unit>
        <trans-unit id="5e16a22c3d8b0f460cffd4d274f2db99a8a3ae51" translate="yes" xml:space="preserve">
          <source>A fundamental feature of regular expression matching involves the notion called</source>
          <target state="translated">Фундаментальная особенность соответствия регулярных выражений включает в себя понятие,называемое</target>
        </trans-unit>
        <trans-unit id="f32db861d817164e66eceb71b5a4c52967492203" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level &lt;code&gt;splice()&lt;/code&gt; function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2100c9b6a5bc83c2e9c2b9fd7c9dc09b08c1aad2" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level splice() function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="translated">Общая функция для редактирования структуры существующей цепочки узлов op_sibling.По аналогии с функцией splice()perl-уровня,позволяет удалять нуль и более последовательных узлов,заменяя их нулями и более разными узлами.Выполняет необходимые операции op_first/op_last на родительском узле и op_sibling манипуляции на дочерних узлах.Последний удаленный узел будет помечен как последний узел путем обновления поля op_sibling/op_sibparent или op_moresib соответственно.</target>
        </trans-unit>
        <trans-unit id="16b0d3e317f9f7b5ddb72b16cb53e05b583e9133" translate="yes" xml:space="preserve">
          <source>A general solution to the serialization problem would require another level of registry, one that associates</source>
          <target state="translated">Общее решение проблемы сериализации потребует другого уровня реестра,который ассоциируется с</target>
        </trans-unit>
        <trans-unit id="ed526677b5c541991128da9f35ea30909114035f" translate="yes" xml:space="preserve">
          <source>A generic &lt;b&gt;object&lt;/b&gt; type; that is, a &lt;b&gt;class&lt;/b&gt; from which other, more specific classes are derived genetically by &lt;b&gt;inheritance&lt;/b&gt;. Also called a &amp;ldquo;superclass&amp;rdquo; by people who respect their ancestors.</source>
          <target state="translated">Универсальный тип &lt;b&gt;объекта&lt;/b&gt; ; то есть &lt;b&gt;класс,&lt;/b&gt; от которого генетически &lt;b&gt;наследуются&lt;/b&gt; другие, более конкретные классы . Также называется &amp;laquo;суперклассом&amp;raquo; люди, уважающие своих предков.</target>
        </trans-unit>
        <trans-unit id="0a9918e5dda4793cf3ecc366ce8266f117c17195" translate="yes" xml:space="preserve">
          <source>A generic file fetching mechanism</source>
          <target state="translated">Общий механизм забора файлов</target>
        </trans-unit>
        <trans-unit id="a625d1d6246943bf40d50608e758f2319151f17b" translate="yes" xml:space="preserve">
          <source>A generic input parsing/checking mechanism.</source>
          <target state="translated">Общий механизм разбора/проверки входных данных.</target>
        </trans-unit>
        <trans-unit id="af15d07731a55a9ecedf87f6009285e2acc4ef80" translate="yes" xml:space="preserve">
          <source>A git GUI shell extension for Windows such as TortoiseGit will cause the build and later &lt;code&gt;make test&lt;/code&gt; to run much slower since every file is checked for its git status as soon as it is created and/or modified. TortoiseGit doesn't cause any test failures or build problems unlike the antivirus software described above, but it does cause similar slowness. It is suggested to use Task Manager to look for background processes which use high CPU amounts during the building process.</source>
          <target state="translated">Расширение оболочки git GUI для Windows, такое как TortoiseGit, приведет к тому, что сборка и последующий &lt;code&gt;make test&lt;/code&gt; будут выполняться намного медленнее, поскольку каждый файл проверяется на его статус git, как только он создается и / или изменяется. TortoiseGit не вызывает сбоев тестирования или проблем сборки, в отличие от антивирусного программного обеспечения, описанного выше, но вызывает аналогичную медлительность. Рекомендуется использовать диспетчер задач для поиска фоновых процессов, которые используют большие объемы ЦП во время процесса сборки.</target>
        </trans-unit>
        <trans-unit id="ca6613321ff6c370136985bf48b668224b2f6734" translate="yes" xml:space="preserve">
          <source>A gizmo that transforms some number of input values to some number of output values, often built into a language with a special syntax or symbol. A given operator may have specific expectations about what &lt;b&gt;types&lt;/b&gt; of data you give as its arguments (&lt;b&gt;operands&lt;/b&gt;) and what type of data you want back from it.</source>
          <target state="translated">Гизмо, преобразующее некоторое количество входных значений в некоторое количество выходных значений, часто встроенное в язык с помощью специального синтаксиса или символа. У данного оператора могут быть определенные ожидания относительно того, какие &lt;b&gt;типы&lt;/b&gt; данных вы передаете в качестве его аргументов ( &lt;b&gt;операндов&lt;/b&gt; ) и какой тип данных вы хотите получить от него.</target>
        </trans-unit>
        <trans-unit id="b0da5e61aa8557d6b28694e8c5217513361c3a66" translate="yes" xml:space="preserve">
          <source>A glossary of terms (technical and otherwise) used in the Perl documentation, derived from the Glossary of</source>
          <target state="translated">Глоссарий терминов (технических и иных),используемых в Perl-документации,взятый из глоссария</target>
        </trans-unit>
        <trans-unit id="b29b7f7af6cfd5aa471dc4da158609e558212777" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , and &lt;code&gt;%&lt;/code&gt; .</source>
          <target state="translated">Символ, используемый в магии. Или для Perl - символ перед именем переменной, например &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; и &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d989c44f106d0ab2b9ca7513c2727428f0d1bd66" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010767009a82e3c3f2315997ed16da6d8fa110ca" translate="yes" xml:space="preserve">
          <source>A good book on OO on Perl is the &quot;Object-Oriented Perl&quot; by Damian Conway from Manning Publications, or &quot;Intermediate Perl&quot; by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.</source>
          <target state="translated">Хорошей книгой об OO на Perl является &quot;Объектно-ориентированный Perl&quot; Дэмиана Конвэя из Manning Publications или &quot;Промежуточный Perl&quot; Рэндала Шварца,brian d foy,и Тома Феникса из O'Reilly Media.</target>
        </trans-unit>
        <trans-unit id="b82c3e9cadf17adecf1d24dc6cb64a89ca8103d6" translate="yes" xml:space="preserve">
          <source>A good place to start is &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;, and you can use &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for reference.</source>
          <target state="translated">Хорошее место для начала - &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; , и вы можете использовать &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; для справки.</target>
        </trans-unit>
        <trans-unit id="96ba2b7e6fee57191ec1137ef371aff044df9901" translate="yes" xml:space="preserve">
          <source>A good resource on the predefined macros for various operating systems, compilers, and so forth is &lt;a href=&quot;http://sourceforge.net/p/predef/wiki/Home/&quot;&gt;http://sourceforge.net/p/predef/wiki/Home/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878d4536576dbff5139c196eb475074b04b81dfd" translate="yes" xml:space="preserve">
          <source>A good test case has most of these attributes: short, simple code; few dependencies on external commands, modules, or libraries; no platform-dependent code (unless it's a platform-specific bug); clear, simple documentation.</source>
          <target state="translated">Хороший тестовый пример имеет большинство из этих атрибутов:короткий,простой код;несколько зависимостей от внешних команд,модулей или библиотек;никакого зависящего от платформы кода (если только это не ошибка,специфичная для платформы);понятная,простая документация.</target>
        </trans-unit>
        <trans-unit id="819fe6a0aff125bab30e82da5634d29a9188e255" translate="yes" xml:space="preserve">
          <source>A good test case is almost always a good candidate to be included in Perl's test suite. If you have the time, consider writing your test case so that it can be easily included into the standard test suite.</source>
          <target state="translated">Хороший тестовый случай почти всегда является хорошим кандидатом для включения в тестовый набор Perl.Если у Вас есть время,подумайте о написании тестового кейса,чтобы его можно было легко включить в стандартный набор тестов.</target>
        </trans-unit>
        <trans-unit id="6800c5039fcfc25d3805f20efcfc998a8922a07e" translate="yes" xml:space="preserve">
          <source>A grab bag of methods to generate specific macros and commands.</source>
          <target state="translated">Пакет методов для генерации специфических макросов и команд.</target>
        </trans-unit>
        <trans-unit id="52f74d52da3fd8ec9d4b9513d833d3c381a80abc" translate="yes" xml:space="preserve">
          <source>A grammar for the Test Anything Protocol.</source>
          <target state="translated">Грамматика для протокола &quot;Test Anything&quot;.</target>
        </trans-unit>
        <trans-unit id="4068f0366f48575a0048eca3205a24ad39495e7b" translate="yes" xml:space="preserve">
          <source>A grammar form might be something like this:</source>
          <target state="translated">Грамматическая форма может быть чем-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="856ecf1b456990ad6225d8774e68fb8a4307706a" translate="yes" xml:space="preserve">
          <source>A grapheme is what appears to a native-speaker of a language to be a character. In Unicode (and hence Perl) a grapheme may actually be several adjacent characters that together form a complete grapheme. For example, there can be a base character, like &quot;R&quot; and an accent, like a circumflex &quot;^&quot;, that appear to be a single character when displayed, with the circumflex hovering over the &quot;R&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19193405de37cb91769fc940baebbd6ae904906a" translate="yes" xml:space="preserve">
          <source>A graphene is an allotrope of carbon arranged in a hexagonal crystal lattice one atom thick. A &lt;b&gt;grapheme&lt;/b&gt;, or more fully, a</source>
          <target state="translated">Графен - это аллотроп углерода, расположенный в гексагональной кристаллической решетке толщиной в один атом. &lt;b&gt;Графема&lt;/b&gt; , или более полно,</target>
        </trans-unit>
        <trans-unit id="07663ed8c039244f1bbba8bbd0f2248a550eeeb7" translate="yes" xml:space="preserve">
          <source>A graphical representation of complex numbers is possible in a plane (also called the</source>
          <target state="translated">Графическое представление комплексных чисел возможно на плоскости (также называемой</target>
        </trans-unit>
        <trans-unit id="b2a17fedc722e35cf530893f218ec96ab466a1ef" translate="yes" xml:space="preserve">
          <source>A great circle is section of a circle that contains the circle diameter: the shortest distance between two (non-antipodal) points on the spherical surface goes along the great circle connecting those two points.</source>
          <target state="translated">Большая окружность-это отрезок окружности,содержащий диаметр окружности:наименьшее расстояние между двумя (неантиподальными)точками на сферической поверхности проходит по большой окружности,соединяющей эти две точки.</target>
        </trans-unit>
        <trans-unit id="cf830d0f970841c8b5873e5f5dc448f292f1330c" translate="yes" xml:space="preserve">
          <source>A group of related modules on &lt;b&gt;CPAN&lt;/b&gt;. (Also sometimes refers to a group of command-line switches grouped into one &lt;b&gt;switch cluster&lt;/b&gt;.)</source>
          <target state="translated">Группа связанных модулей на &lt;b&gt;CPAN&lt;/b&gt; . (Также иногда относится к группе переключателей командной строки, сгруппированных в один &lt;b&gt;кластер переключателей&lt;/b&gt; .)</target>
        </trans-unit>
        <trans-unit id="d92a635a2c1e502bba680458b972125c4a0be466" translate="yes" xml:space="preserve">
          <source>A group that is required to bundle a set of alternatives may or may not be useful as a capturing group. If it isn't, it just creates a superfluous addition to the set of available capture group values, inside as well as outside the regexp. Non-capturing groupings, denoted by &lt;code&gt;(?:regexp)&lt;/code&gt;, still allow the regexp to be treated as a single unit, but don't establish a capturing group at the same time. Both capturing and non-capturing groupings are allowed to co-exist in the same regexp. Because there is no extraction, non-capturing groupings are faster than capturing groupings. Non-capturing groupings are also handy for choosing exactly which parts of a regexp are to be extracted to matching variables:</source>
          <target state="translated">Группа, которая требуется для объединения набора альтернатив, может быть полезна в качестве группы захвата, а может и не быть. Если это не так, он просто создает лишнее дополнение к набору доступных значений группы захвата, как внутри, так и вне регулярного выражения. Группы без захвата, обозначенные &lt;code&gt;(?:regexp)&lt;/code&gt; , по-прежнему позволяют обрабатывать регулярное выражение как единое целое, но не создают группу захвата одновременно. И захватывающие, и не захватывающие группы могут сосуществовать в одном регулярном выражении. Поскольку нет извлечения, группировки без захвата работают быстрее, чем группы с захватом. Группы без захвата также удобны для выбора, какие именно части регулярного выражения должны быть извлечены для сопоставления переменных:</target>
        </trans-unit>
        <trans-unit id="e98254b9797c79a405fb849ceb15e69b1be1e9de" translate="yes" xml:space="preserve">
          <source>A handful of characters have a dedicated</source>
          <target state="translated">У горстки персонажей есть специальный</target>
        </trans-unit>
        <trans-unit id="f93caa5208bfa6818a90d520fb7ad0e15665c128" translate="yes" xml:space="preserve">
          <source>A handler for an attributes with an all-lowercase name was declared. An attribute with an all-lowercase name might have a meaning to Perl itself some day, even though most don't yet. Use a mixed-case attribute name, instead.</source>
          <target state="translated">Объявлен обработчик для атрибута с именем в нижнем регистре.Атрибут с прописным именем может когда-нибудь иметь значение для самого Perl,хотя большинство из них пока не имеют этого значения.Вместо этого используйте смешанное имя атрибута.</target>
        </trans-unit>
        <trans-unit id="c3e6d55f9badd1667902eb5523efa20bcbd3e70c" translate="yes" xml:space="preserve">
          <source>A handler for attributes of the specified name</source>
          <target state="translated">Обработчик атрибутов указанного имени</target>
        </trans-unit>
        <trans-unit id="49edbe08e4bfabb8ba065c602451240e8c0f2a33" translate="yes" xml:space="preserve">
          <source>A handy tag name for a</source>
          <target state="translated">Удобное название метки для</target>
        </trans-unit>
        <trans-unit id="3aa757aa90e3b991f02cc566dd247ec484d84771" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Поддерживается хэш &lt;code&gt;%DB::sub&lt;/code&gt; , ключи которого являются именами подпрограмм, а значения имеют вид &lt;code&gt;filename:startline-endline&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; имеет форму &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; для подпрограмм, определенных внутри &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="c68c21cffb386f2efa2b6778aa32c6a355b62cff" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(eval 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;eval&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b55c7f5cfe4830cdb1fa796511bc1073b11348" translate="yes" xml:space="preserve">
          <source>A hash can be initialized using a literal list holding pairs of items to be interpreted as a key and a value:</source>
          <target state="translated">Хэш может быть инициализирован с помощью буквального списка,содержащего пары элементов,которые должны интерпретироваться как ключ и значение:</target>
        </trans-unit>
        <trans-unit id="8a814541e8cdf1052da6ce7b4056b3b5847f1f69" translate="yes" xml:space="preserve">
          <source>A hash is an ideal mechanism to store the mapping between C and Perl.</source>
          <target state="translated">Хэш-идеальный механизм для хранения карты между C и Perl.</target>
        </trans-unit>
        <trans-unit id="70381f72f3a7fd8e9863739e409cd4fabcba3c1e" translate="yes" xml:space="preserve">
          <source>A hash of array references in list context. Each entry of the hash has the fully qualified method name as its key and a reference to an array containing the method's list-context return values as its value.</source>
          <target state="translated">Хэш ссылок на массив в контексте списка.Каждый элемент хэша имеет в качестве ключа полное имя метода,а в качестве значения-ссылку на массив,содержащий возвращаемые значения метода в контексте списка.</target>
        </trans-unit>
        <trans-unit id="5ea60218a99582e9bc2b801ff2d5e8c50e9c5afa" translate="yes" xml:space="preserve">
          <source>A hash of hashes keyed on perl version and on module name. If a module is defined it indicates that that module is deprecated in that perl version and is scheduled for removal from core at some future point.</source>
          <target state="translated">Хэш хэшей,нанесенный на perl-версию и на имя модуля.Если модуль определен,это указывает на то,что он устарел в perl-версии и в какой-то момент времени планируется удалить его из ядра.</target>
        </trans-unit>
        <trans-unit id="3ce60ae7ced566f5220eb260ad49e428425ac3a8" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is module =&amp;gt; version pairs.</source>
          <target state="translated">Хеш хэшей, введенный в версию Perl, как указано в $]. Хэш второго уровня - это пары модуль =&amp;gt; версия.</target>
        </trans-unit>
        <trans-unit id="2c10d53a97cb7fcb7d7054e473e3b77644c85cb9" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is utility / defined pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c605211961bb9e43df625e92f911448dae2ef07" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to build your module but not run it.</source>
          <target state="translated">Хэш-модуль,который необходим для сборки вашего модуля,но не для его запуска.</target>
        </trans-unit>
        <trans-unit id="e6392db0e8aa8a4e0a54f37942aac32926d2e82c" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do.</source>
          <target state="translated">Хэш-модули,необходимые для запуска вашего модуля.Ключами являются названия модулей,т.е.Test::More,а минимальной версией является значение.Если требуемый номер версии равен 0,подойдет любая версия.</target>
        </trans-unit>
        <trans-unit id="1e045c2b4c33d3a322a7c93d405ec1e436652383" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do. The versions given may be a Perl v-string (see &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt;) or a range (see &lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN::Meta::Requirements&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922e915de9e8740eca506cd44d1ed8c10a9b1671" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to test your module but not run or build it.</source>
          <target state="translated">Хэш-модули,которые необходимы для тестирования вашего модуля,но не запускают и не собирают его.</target>
        </trans-unit>
        <trans-unit id="cd4d1c09ebac99b02cf9a7c9fa8cd90d4f94f599" translate="yes" xml:space="preserve">
          <source>A hash of modules that are required to run Makefile.PL itself, but not to run your distribution.</source>
          <target state="translated">Хэш-модуль,который необходим для запуска самого Makefile.PL,но не для запуска вашего дистрибутива.</target>
        </trans-unit>
        <trans-unit id="f704787fb624926417400f97106f18daa25dcf15" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt; , the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; , but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt; .</source>
          <target state="translated">Хэш обработчиков сигналов реального времени POSIX. Это расширение стандартного &lt;code&gt;%SIG&lt;/code&gt; , &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; примерно эквивалентно &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; , но правильные перемещения POSIX (см. Ниже) выполняются с помощью &lt;code&gt;POSIX::SigSet&lt;/code&gt; и &lt;code&gt;POSIX::sigaction&lt;/code&gt; вместо доступа к &lt;code&gt;%SIG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28dd39596f5df333ab0f97240c1b59801abaec4f" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt;, the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt;, but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ab26088a220041ec5c97911d9e6f565f5cbd7a" translate="yes" xml:space="preserve">
          <source>A hash or array element can be true only if it's defined and defined only if it exists, but the reverse doesn't necessarily hold true.</source>
          <target state="translated">Хэш или элемент массива может быть истинным только в том случае,если он определен и определен только в том случае,если он существует,но обратное не обязательно совпадает с истинным.</target>
        </trans-unit>
        <trans-unit id="0bf79c7c035d7be8a20888854f2234466da28ff7" translate="yes" xml:space="preserve">
          <source>A hash reference containing various parsing options (see below)</source>
          <target state="translated">Ссылка на хэш,содержащая различные варианты разбора (см.ниже).</target>
        </trans-unit>
        <trans-unit id="71468d46c3d10b4d4aab17a5abca352e48601869" translate="yes" xml:space="preserve">
          <source>A hash represents a set of key/value pairs:</source>
          <target state="translated">Хэш представляет собой набор пар ключ/значение:</target>
        </trans-unit>
        <trans-unit id="10f78a1f223b35e25505609f4916f6f91875834d" translate="yes" xml:space="preserve">
          <source>A hash that contains information on the appropriate bug tracker for each core module.</source>
          <target state="translated">Хэш,содержащий информацию о соответствующем трекере ошибок для каждого основного модуля.</target>
        </trans-unit>
        <trans-unit id="567327a8b7280b6715ced030a81d31782682314b" translate="yes" xml:space="preserve">
          <source>A hash that contains information on where patches should be directed for each core module.</source>
          <target state="translated">Хэш,содержащий информацию о том,куда должны быть направлены патчи для каждого модуля ядра.</target>
        </trans-unit>
        <trans-unit id="9f6e2604d963e87b1664555e25f241bb06bae1e9" translate="yes" xml:space="preserve">
          <source>A hash that maps from each Pod filespec to its pod-name (like &quot;/whatever/plib/Stuff/Thing.pm&quot; =&amp;gt; &quot;Stuff::Thing&quot;)</source>
          <target state="translated">Хэш, который сопоставляется из каждой спецификации файла пода с его именем пода (например, &quot;/whatever/plib/Stuff/Thing.pm&quot; =&amp;gt; &quot;Stuff :: Thing&quot;)</target>
        </trans-unit>
        <trans-unit id="215fe982a4e5c65f0b82e82b7b97c0bfc5c0deef" translate="yes" xml:space="preserve">
          <source>A hash that maps from each pod-name to the filespec (like &quot;Stuff::Thing&quot; =&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</source>
          <target state="translated">Хэш, который сопоставляет имя каждого модуля с указанием файла (например, &quot;Stuff :: Thing&quot; =&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</target>
        </trans-unit>
        <trans-unit id="bb3108415359d307ae0dd29af4dd93824067960c" translate="yes" xml:space="preserve">
          <source>A hashref of items to add to the CPAN Meta file (</source>
          <target state="translated">Хэш-файл элементов для добавления в мета-файл CPAN (</target>
        </trans-unit>
        <trans-unit id="b8c62243e4644d3b1d9b849dccb04e48b7d5ff46" translate="yes" xml:space="preserve">
          <source>A hashref of options may be appended to modify the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039b44468fab1aa4f939b768b655c31c005e5690" translate="yes" xml:space="preserve">
          <source>A hashref with one or more of the keys &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; , and &lt;code&gt;env&lt;/code&gt; that specify whether a document is targeted at a specific CPAN distribution or installation. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">Хэш-ссылка с одним или несколькими из следующих ключей: &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; и &lt;code&gt;env&lt;/code&gt; , которые определяют, предназначен ли документ для конкретного распределения или установки CPAN. Ключи с префиксом &lt;code&gt;not_&lt;/code&gt; отменяют соответствующее совпадение.</target>
        </trans-unit>
        <trans-unit id="8c60ca8fe75e29a9dfda50be5b6bb79ab9c86c02" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) without any text? That ain't no heading!</source>
          <target state="translated">Заголовок ( &lt;code&gt;=head1&lt;/code&gt; или &lt;code&gt;=head2&lt;/code&gt; ) без текста? Это не заголовок!</target>
        </trans-unit>
        <trans-unit id="e61f2f28c623b8bf615200619cdf69dae431768b" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt;) without any text? That ain't no heading!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9832f7772423825e7be09c103f042abd3956ccc" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt; , with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; knows where to stop.</source>
          <target state="translated">Шестнадцатеричный дамп &lt;code&gt;$berbuf&lt;/code&gt; с пробелами, вставленными в нужных местах, показывает 01 8100 8101 81807F. Поскольку последний байт всегда меньше 128, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; знает, где остановиться.</target>
        </trans-unit>
        <trans-unit id="e25c820f972869adef22f733ce82d7969564bd8d" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt;, with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;unpack&lt;/code&gt; knows where to stop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2983a66dc1728b3d6b6e5a9cf2faed1865191ff" translate="yes" xml:space="preserve">
          <source>A hex dump of the bytes in field in the order they are stored in the zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40a76a5eb1fbe1d4b01f9b8fcd76ad6df4acf92" translate="yes" xml:space="preserve">
          <source>A hex string consists of hex digits and an optional &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; prefix. Each hex digit may be preceded by a single underscore, which will be ignored. Any other character triggers a warning and causes the rest of the string to be ignored (even leading whitespace, unlike &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt;). Only integers can be represented, and integer overflow triggers a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e7070b1f249f379f9a778af2f10d3b11497505" translate="yes" xml:space="preserve">
          <source>A hierarchy of &quot;categories&quot; have been defined to allow groups of warnings to be enabled/disabled in isolation.</source>
          <target state="translated">Была определена иерархия &quot;категорий&quot;,позволяющая включать/выключать группы предупреждений по отдельности.</target>
        </trans-unit>
        <trans-unit id="536684f67238bfdb66acbda52de51ea79291a12f" translate="yes" xml:space="preserve">
          <source>A is the root class, B is a subclass of A, C is a subclass of B, and D is another subclass of A.</source>
          <target state="translated">A-это корневой класс,B-подкласс A,C-подкласс B,а D-еще один подкласс A.</target>
        </trans-unit>
        <trans-unit id="8f3e40034aa0308d28f4dfc54288a8825f6cfd1e" translate="yes" xml:space="preserve">
          <source>A kind of &lt;b&gt;overloading&lt;/b&gt; that you can do on built-in &lt;b&gt;operators&lt;/b&gt; to make them work on &lt;b&gt;objects&lt;/b&gt; as if the objects were ordinary scalar values, but with the actual semantics supplied by the object class. This is set up with the overload &lt;b&gt;pragma&lt;/b&gt;&amp;mdash;see Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">Это своего рода &lt;b&gt;перегрузка,&lt;/b&gt; которую вы можете выполнить для встроенных &lt;b&gt;операторов,&lt;/b&gt; чтобы заставить их работать с &lt;b&gt;объектами,&lt;/b&gt; как если бы объекты были обычными скалярными значениями, но с фактической семантикой, предоставляемой классом объектов. Это устанавливается с перегрузкой &lt;b&gt;прагмой&lt;/b&gt; -см Camel главе 13, &amp;laquo;перегрузкой&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e9cfe5685ea0ecd4847a06232a077cb874b35be7" translate="yes" xml:space="preserve">
          <source>A kind of action that an &lt;b&gt;object&lt;/b&gt; can take if you tell it to. See Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;.</source>
          <target state="translated">Вид действия, которое &lt;b&gt;объект&lt;/b&gt; может предпринять, если вы ему скажете. См. Главу 12 &amp;laquo;Верблюд&amp;raquo;, &amp;laquo;Объекты&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="dfe222b0c92a8225eafa0e0da38f08258e2a6e75" translate="yes" xml:space="preserve">
          <source>A kind of key or name attached to a loop (or roller coaster) so that loop control statements can talk about which loop they want to control.</source>
          <target state="translated">Своего рода ключ или имя,прикрепленное к контуру (или американским горкам),чтобы можно было говорить о том,каким контуром они хотят управлять.</target>
        </trans-unit>
        <trans-unit id="e7d72d06babc67750c6b28a2b28bed949fa33a88" translate="yes" xml:space="preserve">
          <source>A kinder, gentler tutorial on object-oriented programming in Perl can be found in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;. You should also check out &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for some style guides on constructing both modules and classes.</source>
          <target state="translated">Более мягкое и мягкое руководство по объектно-ориентированному программированию на Perl можно найти в &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; . Вы также должны проверить &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; для некоторых руководств по стилю построения модулей и классов.</target>
        </trans-unit>
        <trans-unit id="b68c5f288b44308b58cb523d3e60b493b484f9c4" translate="yes" xml:space="preserve">
          <source>A language beloved by many for its inside-out &lt;b&gt;type&lt;/b&gt; definitions, inscrutable &lt;b&gt;precedence&lt;/b&gt; rules, and heavy &lt;b&gt;overloading&lt;/b&gt; of the function-call mechanism. (Well, actually, people first switched to C because they found lowercase identifiers easier to read than upper.) Perl is written in C, so it&amp;rsquo;s not surprising that Perl borrowed a few ideas from it.</source>
          <target state="translated">Язык, любимый многими за его определения &lt;b&gt;типов&lt;/b&gt; наизнанку , непостижимые правила &lt;b&gt;приоритета&lt;/b&gt; и сильную &lt;b&gt;перегрузку&lt;/b&gt; механизма вызова функций. (На самом деле, люди сначала перешли на C, потому что они обнаружили, что строчные идентификаторы легче читать, чем верхние.) Perl написан на C, поэтому неудивительно, что Perl позаимствовал у него некоторые идеи.</target>
        </trans-unit>
        <trans-unit id="7a70c2d1db9e3781c948c3f568d555da43db83b2" translate="yes" xml:space="preserve">
          <source>A language class is a class containing a lexicon of phrases as class data, and possibly also some methods that are of use in interpreting phrases in the lexicon, or otherwise dealing with text in that language.</source>
          <target state="translated">Класс языка-это класс,содержащий лексикон фраз в качестве данных класса,а также,возможно,некоторые методы,которые используются при интерпретации фраз в лексиконе,или иным образом имеющие дело с текстом на этом языке.</target>
        </trans-unit>
        <trans-unit id="c64c47113f6df7e33ad198a5fed1bb8f3af6d13f" translate="yes" xml:space="preserve">
          <source>A language handle is a flyweight object -- i.e., it doesn't (necessarily) carry any data of interest, other than just being a member of whatever class it belongs to.</source>
          <target state="translated">Языковой дескриптор-это летающий объект-т.е.он (обязательно)не несет никаких данных,представляющих интерес,кроме того,что является членом того или иного класса,к которому он принадлежит.</target>
        </trans-unit>
        <trans-unit id="c3a083f1f9c38b9c0d77465662a942c4c5d48d8d" translate="yes" xml:space="preserve">
          <source>A language handle is implemented as a blessed hash. Subclasses of yours can store whatever data you want in the hash. Currently the only hash entry used by any crucial Maketext method is &quot;fail&quot;, so feel free to use anything else as you like.</source>
          <target state="translated">Языковая ручка реализуется в виде благословенного гашиша.Подклассы могут хранить в хэше любые данные.В настоящее время единственная запись в хэше,используемая любым важным методом Maketext-это &quot;fail&quot;,так что не стесняйтесь использовать что угодно.</target>
        </trans-unit>
        <trans-unit id="9fb1cb589c473c75eb212d9b744da125c770bad8" translate="yes" xml:space="preserve">
          <source>A language such as Perl that is good at hooking things together that weren&amp;rsquo;t intended to be hooked together.</source>
          <target state="translated">Такой язык, как Perl, хорош для объединения вещей, которые не собирались соединять вместе.</target>
        </trans-unit>
        <trans-unit id="7ea3dfebe2530a429cde54a5f0bc78f862792455" translate="yes" xml:space="preserve">
          <source>A large scalar that you know can only contain ASCII</source>
          <target state="translated">Большой скаляр,который вы знаете,может содержать только ASCII.</target>
        </trans-unit>
        <trans-unit id="8078fbdb7cd614c0fbe18240c94f727ccdf4ed5e" translate="yes" xml:space="preserve">
          <source>A layer can be added that does &quot;\n&quot; to CRLF translation. This layer can be used on any platform, not just those that normally do such things.</source>
          <target state="translated">В перевод CRLF можно добавить слой,который делает &quot;\n&quot;.Этот слой может использоваться на любой платформе,а не только на тех,которые обычно делают такие вещи.</target>
        </trans-unit>
        <trans-unit id="c418f05188c75b7cf5ccc4221979555d292c85f1" translate="yes" xml:space="preserve">
          <source>A layer contains a &quot;vtable&quot;, the table of I/O operations (at C level a table of function pointers), and status flags. The functions in the vtable implement operations like &quot;open&quot;, &quot;read&quot;, and &quot;write&quot;.</source>
          <target state="translated">Слой содержит &quot;v-таблицу&quot;,таблицу операций ввода/вывода (на C-уровне-таблицу указателей функций)и флаги состояния.Функции в таблице реализуют такие операции,как &quot;открыть&quot;,&quot;прочитать&quot;,&quot;записать&quot;.</target>
        </trans-unit>
        <trans-unit id="4f0330995dfa2fce16816cd443c9581a48699cf3" translate="yes" xml:space="preserve">
          <source>A layer derived using &quot;perlio&quot; as a base class. It provides Win32-like &quot;\n&quot; to CR,LF translation. Can either be applied above &quot;perlio&quot; or serve as the buffer layer itself. &quot;crlf&quot; over &quot;unix&quot; is the default if system distinguishes between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; opens. (At some point &quot;unix&quot; will be replaced by a &quot;native&quot; Win32 IO layer on that platform, as Win32's read/write layer has various drawbacks.) The &quot;crlf&quot; layer is a reasonable model for a layer which transforms data in some way.</source>
          <target state="translated">Слой, полученный с использованием &amp;laquo;perlio&amp;raquo; в качестве базового класса. Он обеспечивает перевод &quot;\ n&quot; в стиле Win32 в CR, LF. Может быть нанесен поверх &quot;perlio&quot; или служить самим буферным слоем. &quot;crlf&quot; вместо &quot;unix&quot; используется по умолчанию, если система различает &lt;code&gt;O_TEXT&lt;/code&gt; и &lt;code&gt;O_BINARY&lt;/code&gt; . (В какой-то момент &quot;unix&quot; будет заменен &quot;собственным&quot; уровнем ввода-вывода Win32 на этой платформе, поскольку уровень чтения / записи Win32 имеет различные недостатки.) Уровень &quot;crlf&quot; является разумной моделью для уровня, который преобразует данные в некоторые путь.</target>
        </trans-unit>
        <trans-unit id="c575f3b4bff37dcf26ab538523523b73298b17f9" translate="yes" xml:space="preserve">
          <source>A layer does not have to implement all the functions, but the whole table has to be present. Unimplemented slots can be NULL (which will result in an error when called) or can be filled in with stubs to &quot;inherit&quot; behaviour from a &quot;base class&quot;. This &quot;inheritance&quot; is fixed for all instances of the layer, but as the layer chooses which stubs to populate the table, limited &quot;multiple inheritance&quot; is possible.</source>
          <target state="translated">Слой не обязательно должен реализовывать все функции,но должна присутствовать вся таблица.Неиспользуемые слоты могут быть NULL (что приведет к ошибке при вызове)или могут быть заполнены заглушками для &quot;наследования&quot; поведения от &quot;базового класса&quot;.Это &quot;наследование&quot; фиксировано для всех экземпляров слоя,но поскольку слой выбирает,какие заглушки заполнять таблицу,возможно ограниченное &quot;множественное наследование&quot;.</target>
        </trans-unit>
        <trans-unit id="f3c275bcbbeb5e10eabf8b5098a80ac8ed647d3b" translate="yes" xml:space="preserve">
          <source>A layer implementing &quot;in memory&quot; files using scalar variables, automatically used in place of the platform defaults for IO when opening such a handle. As such, the scalar is expected to act like a file, only containing or storing bytes. See &lt;a href=&quot;PerlIO::scalar&quot;&gt;PerlIO::scalar&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f64a4152a5af0c9ac4baa66afb914d700fb3ea6" translate="yes" xml:space="preserve">
          <source>A layer that implements &quot;reading&quot; of files by using</source>
          <target state="translated">Слой,реализующий &quot;чтение&quot; файлов с использованием</target>
        </trans-unit>
        <trans-unit id="29bee167ef354a3d46f2326d367f6d5e9ab52d50" translate="yes" xml:space="preserve">
          <source>A layer that implements DOS/Windows like CRLF line endings. On read converts pairs of CR,LF to a single &quot;\n&quot; newline character. On write converts each &quot;\n&quot; to a CR,LF pair. Note that this layer will silently refuse to be pushed on top of itself.</source>
          <target state="translated">Слой,реализующий DOS/Windows,например,CRLF-концы линий.При чтении конвертирует пары CR,LF в один символ новой строки &quot;\n&quot;.При записи конвертирует каждый &quot;\n&quot; в пару CR,LF.Обратите внимание,что этот слой беззвучно откажется от нажимания на себя.</target>
        </trans-unit>
        <trans-unit id="49890359753a7b7c09475de22e069c5121e36bd2" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems, and also provides buffering similar to &lt;code&gt;:perlio&lt;/code&gt; on these architectures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b39500363434cc0ff0f52b520ce130f3b3a554" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems. (It currently does</source>
          <target state="translated">Уровень, который выполняет перевод CRLF в &lt;code&gt;&quot;\n&quot;&lt;/code&gt; различая &quot;текстовые&quot; и &quot;двоичные&quot; файлы в манере MS-DOS и подобных операционных систем. (В настоящее время</target>
        </trans-unit>
        <trans-unit id="d99ca2d73d6bc9954c1f5d38358ae63b3448d053" translate="yes" xml:space="preserve">
          <source>A layer which implements &quot;reading&quot; of files by using &lt;code&gt;mmap()&lt;/code&gt; to make a (whole) file appear in the process's address space, and then using that as PerlIO's &quot;buffer&quot;. This</source>
          <target state="translated">Уровень, который реализует &amp;laquo;чтение&amp;raquo; файлов с помощью &lt;code&gt;mmap()&lt;/code&gt; чтобы (весь) файл появлялся в адресном пространстве процесса, а затем используя его в качестве &amp;laquo;буфера&amp;raquo; PerlIO. это</target>
        </trans-unit>
        <trans-unit id="fd687d324576d9173f6d5752bc85ac325e3d235f" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; .</source>
          <target state="translated">Уровень, который предоставляет PerlIO API через схему слоев, но реализует его, вызывая системный stdio. Это (в настоящее время) значение по умолчанию, если системный stdio предоставляет достаточный доступ, чтобы разрешить &quot;быстрый доступ&quot; perl и который не различает &lt;code&gt;O_TEXT&lt;/code&gt; и &lt;code&gt;O_BINARY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05d6c08e7d4d9ce599909cfee99a9592e335ccd5" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1841e889a880ebb77b0a2697210c6744f8df031b" translate="yes" xml:space="preserve">
          <source>A leading ! indicates that matching names should be deleted from the list of names to import. If the first specification is a deletion it is treated as though preceded by :DEFAULT. If you just want to import extra names in addition to the default set you will still need to include :DEFAULT explicitly.</source>
          <target state="translated">Ведущий ! указывает на то,что соответствующие имена должны быть удалены из списка имен для импорта.Если первая спецификация является удалением,то она обрабатывается так,как будто ей предшествует :DEFAULT.Если вы просто хотите импортировать дополнительные имена в дополнение к набору по умолчанию,вам все равно нужно явно включить :DEFAULT.</target>
        </trans-unit>
        <trans-unit id="f747bcc2647296135613b88a3e62cca47b6c1dc6" translate="yes" xml:space="preserve">
          <source>A leading colon removes the &quot;name=&quot; part of the response, this allows you to map to the name you need. (mnemonic: empty label)</source>
          <target state="translated">Ведущий двоеточие удаляет часть ответа &quot;name=&quot;,что позволяет сопоставить его с нужным именем.(мнемонический:пустая метка)</target>
        </trans-unit>
        <trans-unit id="96fa00367bcfdb4784c34a4a3babbe9475afc22d" translate="yes" xml:space="preserve">
          <source>A legally formed name for most anything in which a computer program might be interested. Many languages (including Perl) allow identifiers to start with an alphabetic character, and then contain alphabetics and digits. Perl also allows connector punctuation like the underscore character wherever it allows alphabetics. (Perl also has more complicated names, like &lt;b&gt;qualified&lt;/b&gt; names.)</source>
          <target state="translated">Официально оформленное имя для всего, что может быть интересно компьютерной программе. Многие языки (включая Perl) позволяют идентификаторам начинаться с буквенного символа, а затем содержать буквы и цифры. Perl также позволяет использовать знаки препинания в соединителях, такие как символ подчеркивания, везде, где разрешены буквы. (Perl также имеет более сложные имена, например, &lt;b&gt;уточненные&lt;/b&gt; имена.)</target>
        </trans-unit>
        <trans-unit id="69d4d84a09fc968a07bdda5a53812534fa74783b" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt; ) nor about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; ) or similar cases.</source>
          <target state="translated">Библиотеке нужно иметь дело только с большими целыми числами без знака. Проверка допустимости входных параметров выполняется вызывающей стороной, поэтому нет необходимости беспокоиться о недополнении (например, в &lt;code&gt;_sub()&lt;/code&gt; и &lt;code&gt;_dec()&lt;/code&gt; ) или о делении на ноль (например, в &lt;code&gt;_div()&lt;/code&gt; ) или подобных случаях.</target>
        </trans-unit>
        <trans-unit id="d63d0720eeb53645d19249b7b0b30c1e9040b91f" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt;) or about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; and &lt;code&gt;_mod()&lt;/code&gt;)) or similar cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf7193a51535e24fe6d6e597b0723102b292f35" translate="yes" xml:space="preserve">
          <source>A line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b89fa4e541f30b4e921956619e05676831d4d1c" translate="yes" xml:space="preserve">
          <source>A line number may be prefixed by a single letter:</source>
          <target state="translated">Номер строки может быть префиксом одной буквы:</target>
        </trans-unit>
        <trans-unit id="2d89336c3df3636aebec0ee20d5e9be98d7da075" translate="yes" xml:space="preserve">
          <source>A line-oriented form of quoting is based on the shell &quot;here-document&quot; syntax. Following a &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; you specify a string to terminate the quoted material, and all lines following the current line down to the terminating string are the value of the item.</source>
          <target state="translated">Строчная форма цитирования основана на синтаксисе оболочки &amp;laquo;здесь-документ&amp;raquo;. После &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; вы указываете строку, завершающую цитируемый материал, и все строки, следующие за текущей строкой до завершающей строки, являются значением элемента.</target>
        </trans-unit>
        <trans-unit id="ba737ca3db1e413142acc2b22e379ceb469071d3" translate="yes" xml:space="preserve">
          <source>A list containing a single undef, in list context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e8b52d2267761231a600214a302dc93a9097e4" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt; s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">Список, введенный с помощью &lt;code&gt;=over&lt;/code&gt; , начинается с текста или дословного абзаца, но продолжается с &lt;code&gt;=item&lt;/code&gt; s. Переместите абзац, не связанный с элементом, из блока &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e132d5a818c0fde195a981571859eee6be87b1c" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt;s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aee76ae2469acd57d2557387480876b03411474" translate="yes" xml:space="preserve">
          <source>A list is a fixed collection of scalars. An array is a variable that holds a variable collection of scalars. An array can supply its collection for list operations, so list operations also work on arrays:</source>
          <target state="translated">Список-это фиксированная коллекция скаляров.Массив-это переменная,содержащая переменную коллекцию скаляров.Массив может поставлять свою коллекцию для операций со списками,поэтому операции со списками также работают и с массивами:</target>
        </trans-unit>
        <trans-unit id="b201394353dbcc6ef2561ba6cd863dea90b88222" translate="yes" xml:space="preserve">
          <source>A list of additional libraries or other shared objects which can be used to resolve any undefined symbols that might be generated by a later call to load_file().</source>
          <target state="translated">Список дополнительных библиотек или других разделяемых объектов,которые могут быть использованы для разрешения любых неопределенных символов,которые могут быть сгенерированы последующим вызовом load_file().</target>
        </trans-unit>
        <trans-unit id="e216fd26bc604e567680be656aeb4002407fb587" translate="yes" xml:space="preserve">
          <source>A list of all the INSTALL* variables without the INSTALL prefix. Useful for iteration or building related variable sets.</source>
          <target state="translated">Список всех переменных УСТАНОВКИ*без префикса УСТАНОВКИ.Полезен для итераций или построения связанных с ними наборов переменных.</target>
        </trans-unit>
        <trans-unit id="e85ab034c5cddfa0ece70fbf99712ce6eb1bc6c8" translate="yes" xml:space="preserve">
          <source>A list of custom keys are available from the &lt;code&gt;custom_keys&lt;/code&gt; method and particular keys may be retrieved with the &lt;code&gt;custom&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94957d0f7514017339244da4cc1607583b5fc84e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. Any architecture-specific and version-specific directories, such as</source>
          <target state="translated">Список каталогов,в которых можно искать файлы Perl-библиотеки,прежде чем искать в стандартной библиотеке и текущем каталоге.Любые каталоги,специфичные для архитектуры и версии,такие как</target>
        </trans-unit>
        <trans-unit id="7103902d7143d091cfd2b7d907958a451f56b4e9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. If PERL5LIB is defined, PERLLIB is not used.</source>
          <target state="translated">Список каталогов,в которых можно искать файлы Perl-библиотеки,прежде чем искать в стандартной библиотеке и текущем каталоге.Если определено значение PERL5LIB,то PERLLIB не используется.</target>
        </trans-unit>
        <trans-unit id="74c3a8ebaa1190b475b719545a9be33666f3621e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library. Any architecture-specific and version-specific directories, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b17875309177ed716e25c72207fa65946c2db9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library. If &lt;a href=&quot;#PERL5LIB&quot;&gt;&quot;PERL5LIB&quot;&lt;/a&gt; is defined, PERLLIB is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cc07c6f57898b2ef6aaadd57be04cf61845061" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt; . The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="translated">Список путей к каталогам. Если входной файл не существует, он будет найден в указанном списке каталогов (в том порядке, в котором каталоги появляются в списке). По умолчанию это список каталогов, подразумеваемый &lt;code&gt;$ENV{PATH}&lt;/code&gt; . Список может быть определен либо путем ссылки на массив, или строкой путей каталогов , которые используют один и тот же разделитель пути как &lt;code&gt;$ENV{PATH}&lt;/code&gt; в вашей системе (например, &lt;code&gt;:&lt;/code&gt; для Unix, &lt;code&gt;;&lt;/code&gt; для MSWin32 и DOS).</target>
        </trans-unit>
        <trans-unit id="f2a928fe21ff1b5f7955724187f967a836701c95" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt;. The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337601b93965c28568bbedd0632699f2eefded6b" translate="yes" xml:space="preserve">
          <source>A list of files in the distribution, one file per line. The MANIFEST always uses Unix filepath conventions even if you're not on Unix. This means</source>
          <target state="translated">Список файлов в дистрибутиве,по одному файлу на строку.MANIFEST всегда использует соглашения о путях передачи файлов Unix,даже если вы не на Unix.Это означает.</target>
        </trans-unit>
        <trans-unit id="0555d0b38c03024b415a75a77593c5880fa79206" translate="yes" xml:space="preserve">
          <source>A list of one or more symbol names that are in the library/object file to be dynamically loaded. This is only required on some platforms.</source>
          <target state="translated">Список одного или нескольких имен символов,которые находятся в библиотеке/объектном файле для динамической загрузки.Это требуется только на некоторых платформах.</target>
        </trans-unit>
        <trans-unit id="681b6abf464391de8dd3a7916ae06f2d521a9817" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one contains the names.</source>
          <target state="translated">Список прокладок.Первый содержит имена.</target>
        </trans-unit>
        <trans-unit id="da9e40582037de588b1af66d3e9b3a340700ef73" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one is a B::PADNAMELIST containing the names. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f9cb55d32eb52f68051c89a619f41d785a1129" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt; .</source>
          <target state="translated">Список возможных вариантов, из которого вы можете выбрать только один, например: &amp;laquo;Хотите дверь A, B или C?&amp;raquo; Альтернативные варианты в регулярных выражениях разделяются одной вертикальной чертой: &lt;code&gt;|&lt;/code&gt; . Альтернативы в обычных выражениях Perl разделены двойной вертикальной чертой: &lt;code&gt;||&lt;/code&gt; . Логические альтернативы в &lt;b&gt;булевых&lt;/b&gt; выражениях разделяются символом &lt;code&gt;||&lt;/code&gt; или &lt;code&gt;or&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2d1159bd9f6222036057dab76c68aab36c4921c" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346e1107e8ac97822d23a43881fe3f608701a635" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">Список имен сигналов, поддерживаемых текущей платформой, можно найти в &lt;code&gt;$Config{sig_name}&lt;/code&gt; , который предоставляется модулем &lt;code&gt;Config&lt;/code&gt; . Смотрите &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="d9eb54a7b38bb34c8e5e028a36e767398adf41e8" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">Список имен сигналов, поддерживаемых текущей платформой, можно найти в &lt;code&gt;$Config{sig_name}&lt;/code&gt; , который предоставляется модулем &lt;code&gt;Config&lt;/code&gt; . Смотрите &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="fc0773d86c1f156c02879741dc6d62b20714e966" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt;, which is provided by the &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccc6f087795a7e9086a2d2fafcbe724d6efe6cc" translate="yes" xml:space="preserve">
          <source>A list of tailorable locales</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a6ca6e50a55d219bc744f957b355e8b7592c8a" translate="yes" xml:space="preserve">
          <source>A list of the built-in functions in Perl can be found in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">Список встроенных функций Perl можно найти в &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="372e15c083e652a86b064f2068748142c2ada459" translate="yes" xml:space="preserve">
          <source>A list of variant codes and their aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35384fe66627b2cc2fb84aa2b93b3f9464bdd2e5" translate="yes" xml:space="preserve">
          <source>A list started with e.g. a bullet-like &lt;code&gt;=item&lt;/code&gt; and continued with a numbered one. This is obviously inconsistent. For most translators the type of the</source>
          <target state="translated">Список начинается, например, с bullet-like &lt;code&gt;=item&lt;/code&gt; и продолжается нумерованным. Это явно непоследовательно. Для большинства переводчиков тип</target>
        </trans-unit>
        <trans-unit id="aa018bd7e5de867ce0e0e74c715e38d76832212f" translate="yes" xml:space="preserve">
          <source>A list value may also be subscripted like a normal array. You must put the list in parentheses to avoid ambiguity. For example:</source>
          <target state="translated">Значение списка также может быть подписано как обычный массив.Чтобы избежать двусмысленности,необходимо заключить список в круглые скобки.Например:</target>
        </trans-unit>
        <trans-unit id="6d0412d7581939fe7cd594904f6d1f6283358f69" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt; . Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="translated">&lt;code&gt;newLISTOP&lt;/code&gt; типа списка обычно создается по одному ребенку за раз с помощью newLISTOP , &lt;code&gt;op_prepend_elem&lt;/code&gt; и &lt;code&gt;op_append_elem&lt;/code&gt; . Затем, наконец, он передается в &lt;code&gt;op_convert_list&lt;/code&gt; , чтобы сделать его правильным типом.</target>
        </trans-unit>
        <trans-unit id="14189fe432e4560d9641abb356065b320734ccfd" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt;, &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt;. Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f682c29d99c6edee87a4e2c8b480a19c081d9f4" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; . This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="translated">Литерал формы &lt;code&gt;v1.20.300.4000&lt;/code&gt; анализируется как строка, состоящая из символов с указанными порядковыми номерами. Эта форма, известная как v-строки, предоставляет альтернативный, более читаемый способ построения строк вместо использования несколько менее читаемой формы интерполяции &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; . Это полезно для представления строк Unicode и для сравнения &amp;laquo;номеров&amp;raquo; версий с использованием операторов сравнения строк, &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; и т. Д. Если в литерале есть две или более точки, ведущий &lt;code&gt;v&lt;/code&gt; может быть опущен.</target>
        </trans-unit>
        <trans-unit id="2818d2fc350cf7ade47132bea5c3b21871e52fea" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt;. This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f7e21c905ecc7463ec1c2d73cca6ccc870ec21" translate="yes" xml:space="preserve">
          <source>A little bit less simple options</source>
          <target state="translated">Немного менее простые варианты</target>
        </trans-unit>
        <trans-unit id="6b6e0528ee125aa344dac0cd2afd7b5168d26910" translate="yes" xml:space="preserve">
          <source>A little bit of magic happens here. When running on anything but MacOS, all the tests run normally. But when on MacOS, &lt;code&gt;skip()&lt;/code&gt; causes the entire contents of the SKIP block to be jumped over. It never runs. Instead, &lt;code&gt;skip()&lt;/code&gt; prints special output that tells &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; that the tests have been skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd2ad667ca8cebc07144e83ae02050c5a406af0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="translated">Небольшой встроенный синтаксический сахар означает, что вы также можете сказать &lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; или &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; как ярлык для &lt;b&gt;'-M &lt;i&gt;MODULE&lt;/i&gt; qw (foo bar)'&lt;/b&gt; . Это позволяет избежать использования кавычек при импорте символов. Фактический код, сгенерированный &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . Обратите внимание, что форма &lt;code&gt;=&lt;/code&gt; удаляет различие между &lt;b&gt;-m&lt;/b&gt; и &lt;b&gt;-M&lt;/b&gt; ; то есть &lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt; это то же самое, что &lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo, bar&lt;/b&gt;.</target>
        </trans-unit>
        <trans-unit id="7fd937dfbc8cdfcbf7f8d9bddf92ad4d9bacfca0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;use module split(/,/,q{foo,bar})&lt;/code&gt;. Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b161330532dd0ec0afc3fa6fafbca99d0e5e09ac" translate="yes" xml:space="preserve">
          <source>A little funky, because VOS's notion of ownership is a little funky (VOS).</source>
          <target state="translated">Немного фанково,потому что понятие собственности VOS немного фанково (VOS).</target>
        </trans-unit>
        <trans-unit id="fe38aea6f56711cc8a09262301b75b1d00f515d0" translate="yes" xml:space="preserve">
          <source>A little interface to ExtUtils::Installed to examine installed modules, validate your packlists and even create a tarball from an installed module.</source>
          <target state="translated">Небольшой интерфейс к ExtUtils::Установлен для изучения установленных модулей,проверки своих пакетов и даже создания тарбола из установленного модуля.</target>
        </trans-unit>
        <trans-unit id="fab5a9063d3279beff24f900f22a1e9be454b440" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="translated">Малоизвестная особенность &lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness&lt;/a&gt; заключается в том, что он поддерживает списки TODO в плане:</target>
        </trans-unit>
        <trans-unit id="e09dee149111fbdc75066a3a4b04ff33ac64fdce" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18dd594cfef1216511213db962d79c422701e3a6" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">Local изменяет перечисленные переменные, чтобы они были локальными для включающего блока, файла или eval. Если указано более одного значения, список должен быть заключен в круглые скобки. См. &amp;laquo; &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;Временные значения через local ()&amp;raquo; в perlsub&lt;/a&gt; для получения подробной информации, включая проблемы со связанными массивами и хешами.</target>
        </trans-unit>
        <trans-unit id="c4f458b856b0a12ad8d1fe86f374dff1cb18e135" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot; in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9869654ca036fa59fd44e2a08b434b738df4df1" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">Local изменяет перечисленные переменные, чтобы они были локальными для включающего блока, файла или eval. Если указано более одного значения, список должен быть заключен в круглые скобки. См. &amp;laquo; &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;Временные значения через local ()&amp;raquo; в perlsub&lt;/a&gt; для получения подробной информации, включая проблемы со связанными массивами и хешами.</target>
        </trans-unit>
        <trans-unit id="851216238693688504d3297975d3a9648a0c15ac" translate="yes" xml:space="preserve">
          <source>A locale is a set of data that describes various aspects of how various communities in the world categorize their world. These categories are broken down into the following types (some of which include a brief note here):</source>
          <target state="translated">Локаль-это набор данных,описывающих различные аспекты того,как различные сообщества в мире классифицируют свой мир.Эти категории разбиты на следующие типы (некоторые из них включают в себя краткую справку здесь):</target>
        </trans-unit>
        <trans-unit id="13e5d1d67a5e143b58f5105851151e51a7ee96cb" translate="yes" xml:space="preserve">
          <source>A location in a &lt;b&gt;hash table&lt;/b&gt; containing (potentially) multiple entries whose keys &amp;ldquo;hash&amp;rdquo; to the same hash value according to its hash function. (As internal policy, you don&amp;rsquo;t have to worry about it unless you&amp;rsquo;re into internals, or policy.)</source>
          <target state="translated">Местоположение в &lt;b&gt;хеш-таблице,&lt;/b&gt; содержащее (потенциально) несколько записей, ключи которых &amp;laquo;хешируют&amp;raquo; к одному и тому же хеш-значению в соответствии с его хеш-функцией. (Что касается внутренней политики, вам не нужно беспокоиться об этом, если вы не разбираетесь во внутренностях или политике.)</target>
        </trans-unit>
        <trans-unit id="62c12399ed6b551ce7f2dd44832d843392fa0233" translate="yes" xml:space="preserve">
          <source>A lock can either be used to guard the data contained within the variable being locked, or it can be used to guard something else, like a section of code. In this latter case, the variable in question does not hold any useful data, and exists only for the purpose of being locked. In this respect, the variable behaves like the mutexes and basic semaphores of traditional thread libraries.</source>
          <target state="translated">Блокировка может быть использована либо для защиты данных,содержащихся в блокируемой переменной,либо для защиты чего-то еще,например,части кода.В последнем случае переменная,о которой идет речь,не содержит никаких полезных данных и существует только для того,чтобы быть заблокированной.В этом отношении переменная ведет себя как мьютексы и базовые семафоры традиционных нитевых библиотек.</target>
        </trans-unit>
        <trans-unit id="e53273bd96405d6a9351857fe0d8e6743bfe42f3" translate="yes" xml:space="preserve">
          <source>A log of changes you've made to this module. The layout is free-form. Here's an example:</source>
          <target state="translated">Журнал изменений,которые вы внесли в этот модуль.Макет в свободной форме.Вот пример:</target>
        </trans-unit>
        <trans-unit id="e77a6f13193bcd6e24d605469f11ccf9737a2eb7" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt; .</source>
          <target state="translated">Одинокий тире в командной строке теперь будет допустимым вариантом, и его использование установит переменную &lt;code&gt;$stdio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82708ef5882db99166c7c8cd03934807e0af6cda" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518574ccfd2af3125f764f2199d90530c80ca8ba" translate="yes" xml:space="preserve">
          <source>A longer sequence is a script run if and only if &lt;b&gt;all&lt;/b&gt; of the following conditions are met:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e09920138d7232024aa812a56f04053ae3c9db" translate="yes" xml:space="preserve">
          <source>A longer, more complete description of the purpose or intended use of the distribution than the one provided by the &lt;code&gt;abstract&lt;/code&gt; key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb4c7413d2efeeaac13a33033548176fe547847" translate="yes" xml:space="preserve">
          <source>A lot of &lt;code&gt;bad free&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebb7eb8448d50869adcfaf8c37d6e3e449e059f" translate="yes" xml:space="preserve">
          <source>A lot of Git tools (Gitweb, GitHub, git log --pretty=oneline, ...) will only display the first line (cut off at 50 characters) when presenting commit summaries.</source>
          <target state="translated">Многие инструменты Git'а (Gitweb,GitHub,git log --pretty=oneline,...)будут отображать только первую строку (обрезанную на 50 символов)при представлении аннотаций коммитов.</target>
        </trans-unit>
        <trans-unit id="02a8d66dfb847fc32e205ee4aa1e54636c91fd8e" translate="yes" xml:space="preserve">
          <source>A lot of opcodes (this is an elementary operation in the internal perl stack machine) put an SV* on the stack. However, as an optimization the corresponding SV is (usually) not recreated each time. The opcodes reuse specially assigned SVs (</source>
          <target state="translated">Много опкодов (это элементарная операция во внутренней машине стека perl)помещают SV*на стек.Однако,в качестве оптимизации соответствующее SV (обычно)не воссоздается каждый раз.Опкоды повторно используют специально назначенные SV (</target>
        </trans-unit>
        <trans-unit id="afe9679193e46dcbc5b397149b0a40382533461a" translate="yes" xml:space="preserve">
          <source>A lot of the behaviour of &lt;code&gt;check()&lt;/code&gt; can be altered by setting package variables. See the section on &lt;code&gt;Global Variables&lt;/code&gt; for details on this.</source>
          <target state="translated">Многое в поведении &lt;code&gt;check()&lt;/code&gt; можно изменить, задав переменные пакета. Подробнее об этом см. В разделе &amp;laquo; &lt;code&gt;Global Variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc40634e762614784aeafebfe726c582b35ad008" translate="yes" xml:space="preserve">
          <source>A lot of the methods in this package are accessors to the various fields in the tar header:</source>
          <target state="translated">Многие из методов в этом пакете-это доступ к различным полям в заголовке tar:</target>
        </trans-unit>
        <trans-unit id="fdb88e271e5277826500f05676e2c0be0095eb4c" translate="yes" xml:space="preserve">
          <source>A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565ddf2f41fdaae2f6c398d4a9fce10061d3fdb0" translate="yes" xml:space="preserve">
          <source>A map to the empty string means that there is no alias defined for the code point.</source>
          <target state="translated">Карта к пустой строке означает,что для точки кода не определен псевдоним.</target>
        </trans-unit>
        <trans-unit id="962035547fe5a8c87c148cca16aad0a4071407ed" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Маска тех &lt;b&gt;битов разрешений,&lt;/b&gt; которые следует отключить при создании файлов или каталогов, чтобы установить политику, к которой вы обычно отказываетесь в доступе. См. Функцию &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1942e2dc4da6fcab23b5c63e120680f59662794" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;umask&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb92546e7ee6f466e3b9ad9b8c6c91db11b1f74" translate="yes" xml:space="preserve">
          <source>A meaningless value will currently be returned if the input is not an unsigned integer.</source>
          <target state="translated">В настоящее время возвращается бессмысленное значение,если вход не является беззнаковым целым числом.</target>
        </trans-unit>
        <trans-unit id="46b7f4ae99fce16ec6771e2703c08b126f8c5237" translate="yes" xml:space="preserve">
          <source>A mechanism by which some high-level agent such as a user can pass its preferences down to its future offspring (child &lt;b&gt;processes&lt;/b&gt;, grandchild processes, great-grandchild processes, and so on). Each environment variable is a &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pair, like one entry in a &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">Механизм, с помощью которого некоторый высокоуровневый агент, такой как пользователь, может передавать свои предпочтения своим будущим потомкам (дочерние &lt;b&gt;процессы&lt;/b&gt; , процессы-внуки, процессы-правнуки и т. Д.). Каждая переменная среды представляет собой пару &lt;b&gt;ключ&lt;/b&gt; / &lt;b&gt;значение&lt;/b&gt; , как одна запись в &lt;b&gt;хэше&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2a69447aeea5209e44940fc7462f35a5d6ac88b2" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="translated">Механизм в Perl, который позволяет вам сохранять вывод каждой &lt;b&gt;команды&lt;/b&gt; Perl, а затем выгружать его как единый запрос к &lt;b&gt;операционной системе&lt;/b&gt; . Это включается установкой &lt;code&gt;$|&lt;/code&gt; ( &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) к истинному значению. Он используется, когда вы не хотите, чтобы данные лежали без дела, а не шли туда, куда они должны были, что может произойти, потому что по умолчанию для &lt;b&gt;файла&lt;/b&gt; или &lt;b&gt;канала&lt;/b&gt; используется &lt;b&gt;блочная буферизация&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="73a790a34f989c156e242df378ee398a811d0fa6" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt;) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51120e7f8481f25cf88f8c7a272aee4be9724200" translate="yes" xml:space="preserve">
          <source>A memory address (pointer). Typically associated with a &lt;code&gt;void *&lt;/code&gt; type.</source>
          <target state="translated">Адрес памяти (указатель). Обычно ассоциируется с типом &lt;code&gt;void *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a89278430a1f2647d19e07faa6dcd5ce49e8cc5" translate="yes" xml:space="preserve">
          <source>A message of the form:</source>
          <target state="translated">Сообщение формы:</target>
        </trans-unit>
        <trans-unit id="f4fff5e041e8ffd1750d8230d717d49c7140db99" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="translated">Сообщение, &lt;code&gt;STDERR&lt;/code&gt; поток STDERR, о том, что что-то может быть не так, но не стоит раздумывать. См &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; в Camel главе 27, &amp;laquo;Функция&amp;raquo; и &lt;code&gt;warnings&lt;/code&gt; Прагма в Camel главе 28, &amp;laquo;Pragmantic модули&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="698adb24081e5dd75873b482d129bef5c7d6f56b" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;warn&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6e29399630661da9d8d4454f316b8b579ac7c9" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt; .</source>
          <target state="translated">Сообщение для печати до &lt;code&gt;@args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f32f46fd3a16d86d6b29b7249d408acc0fd9dade" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1e82245324d77d7c4b1f38686539fbc87f4207" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">Метахарактер можно сопоставить,поставив перед ним обратный слеш:</target>
        </trans-unit>
        <trans-unit id="22cc73f771c76a642b402e7e0f9c578239ac498b" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched literally by putting a backslash before it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb23d39b57fee733dc53600af45c98c9b288bdde" translate="yes" xml:space="preserve">
          <source>A method is simply a subroutine that expects a reference to an object (or a package name, for class methods) as the first argument.</source>
          <target state="translated">Метод-это просто подпрограмма,которая ожидает в качестве первого аргумента ссылки на объект (или имя пакета,для методов класса).</target>
        </trans-unit>
        <trans-unit id="8b793382672991d71fa4d5891acf893cacd7e306" translate="yes" xml:space="preserve">
          <source>A method of making input and output efficient by passing one &lt;b&gt;block&lt;/b&gt; at a time. By default, Perl does block buffering to disk files. See &lt;b&gt;buffer&lt;/b&gt; and &lt;b&gt;command buffering&lt;/b&gt;.</source>
          <target state="translated">Метод повышения эффективности ввода и вывода путем передачи одного &lt;b&gt;блока&lt;/b&gt; за раз. По умолчанию Perl блокирует буферизацию файлов на диске. См. &lt;b&gt;Буферизация буферов&lt;/b&gt; и &lt;b&gt;команд&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="caf2b56be7a3ef3288ab77eb65ba11acb464aa6d" translate="yes" xml:space="preserve">
          <source>A method of storing numbers in &amp;ldquo;scientific notation&amp;rdquo;, such that the precision of the number is independent of its magnitude (the decimal point &amp;ldquo;floats&amp;rdquo;). Perl does its numeric work with floating-point numbers (sometimes called &amp;ldquo;floats&amp;rdquo;) when it can&amp;rsquo;t get away with using &lt;b&gt;integers&lt;/b&gt;. Floating-point numbers are mere approximations of real numbers.</source>
          <target state="translated">Метод хранения чисел в &amp;laquo;экспоненциальной нотации&amp;raquo;, при котором точность числа не зависит от его величины (десятичная точка &amp;laquo;плавает&amp;raquo;). Perl выполняет свою числовую работу с числами с плавающей запятой (иногда называемыми &amp;laquo;плавающими&amp;raquo;), когда не может обойтись без &lt;b&gt;целых чисел&lt;/b&gt; . Числа с плавающей запятой - это просто приближение действительных чисел.</target>
        </trans-unit>
        <trans-unit id="944278d690e3fc7e64864c32faa75a96c4fa698a" translate="yes" xml:space="preserve">
          <source>A method returning a scalar containing definitions needed, typically for a C header file.</source>
          <target state="translated">Метод,возвращающий скаляр,содержащий необходимые определения,обычно для заголовочного файла на языке C.</target>
        </trans-unit>
        <trans-unit id="b261259b0ea34efe663b89fa4a355d967119ff59" translate="yes" xml:space="preserve">
          <source>A method to return a suitable &lt;code&gt;#ifdef&lt;/code&gt; clause.</source>
          <target state="translated">Метод возврата подходящего предложения &lt;code&gt;#ifdef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e298259952faa9b6dc589a73a54938eb75e8b9ca" translate="yes" xml:space="preserve">
          <source>A method to return a suitable C &lt;code&gt;if&lt;/code&gt; statement to check whether</source>
          <target state="translated">Метод для возврата подходящего оператора C &lt;code&gt;if&lt;/code&gt; для проверки того,</target>
        </trans-unit>
        <trans-unit id="b8d289dec370b10085acc876037d4a80d75d741c" translate="yes" xml:space="preserve">
          <source>A method to return a suitable assignment clause. If</source>
          <target state="translated">Метод возврата подходящего положения о переуступке.Если</target>
        </trans-unit>
        <trans-unit id="0c03f6a0b53898fc9e24cba2362fd5fb8fa53375" translate="yes" xml:space="preserve">
          <source>A miniature type system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7330449bff2c39517a4e897b762ab9507a795d4" translate="yes" xml:space="preserve">
          <source>A minimal required perl version, if present, will look like this:</source>
          <target state="translated">Минимально необходимая perl-версия,если она есть,будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="e9a3539678256349db8d3cedb932d5bd4be41d3e" translate="yes" xml:space="preserve">
          <source>A misnamed feature&amp;mdash;it should be called, &amp;ldquo;expecting your mother to pick up after you&amp;rdquo;. Strictly speaking, Perl doesn&amp;rsquo;t do this, but it relies on a reference-counting mechanism to keep things tidy. However, we rarely speak strictly and will often refer to the reference-counting scheme as a form of garbage collection. (If it&amp;rsquo;s any comfort, when your interpreter exits, a &amp;ldquo;real&amp;rdquo; garbage collector runs to make sure everything is cleaned up if you&amp;rsquo;ve been messy with circular references and such.)</source>
          <target state="translated">Неправильно названная особенность - ее следует назвать &amp;laquo;ожиданием, что мама заберет вас за вами&amp;raquo;. Строго говоря, Perl этого не делает, но он полагается на механизм подсчета ссылок, чтобы поддерживать порядок. Однако мы редко говорим строго и часто будем называть схему подсчета ссылок формой сборки мусора. (Если вам удобно, когда ваш интерпретатор завершает работу, запускается &amp;laquo;настоящий&amp;raquo; сборщик мусора, чтобы убедиться, что все очищено, если вы запутались с циклическими ссылками и т. Д.)</target>
        </trans-unit>
        <trans-unit id="b76b41563e694ef10941bc1da1406e4e19d640cf" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; evaluation modifier. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="translated">Модификатор, доступный специально для поиска и замены, - это модификатор оценки &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; рассматривает замещающий текст как код Perl, а не как строку в двойных кавычках. Значение, возвращаемое кодом, заменяется совпадающей подстрокой. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; полезен, если вам нужно произвести небольшие вычисления в процессе замены текста. В этом примере подсчитывается частота символов в строке:</target>
        </trans-unit>
        <trans-unit id="978f8f9b8df9741b30748f830e018b2a20eda4a7" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;s///e&lt;/code&gt; evaluation modifier. &lt;code&gt;s///e&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;s///e&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f750d1b2bf1dcd617bfb9b0ddbb157dd528256" translate="yes" xml:space="preserve">
          <source>A modifier is overridden by later occurrences of this construct in the same scope containing the same modifier, so that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d67d7e195f6e0fb6e2bd79bf9224c3c8d1e2fd" translate="yes" xml:space="preserve">
          <source>A module for loading must be quoted.</source>
          <target state="translated">Должен быть указан модуль для загрузки.</target>
        </trans-unit>
        <trans-unit id="8d98e6118bd0f23607596b779080678b5a48db1b" translate="yes" xml:space="preserve">
          <source>A module is a file that (by convention) provides a class of the same name (sans the .pm), plus an import method in that class that can be called to fetch exported symbols. This module may implement some of its methods by loading dynamic C or C++ objects, but that should be totally transparent to the user of the module. Likewise, the module might set up an AUTOLOAD function to slurp in subroutine definitions on demand, but this is also transparent. Only the</source>
          <target state="translated">Модуль-это файл,который (по соглашению)предоставляет класс с таким же именем (без .pm),плюс метод импорта в этом классе,который может быть вызван для получения экспортируемых символов.Этот модуль может реализовывать некоторые из своих методов путем загрузки динамических объектов на C или C++,но это должно быть полностью прозрачно для пользователя модуля.Точно так же модуль может настроить функцию AUTOLOAD,чтобы по требованию не раскрывать определения подпрограмм,но это также прозрачно.Только</target>
        </trans-unit>
        <trans-unit id="22a73f9dccbade36d652d965f87a8dc414d1002a" translate="yes" xml:space="preserve">
          <source>A module is just a set of related functions in a library file, i.e., a Perl package with the same name as the file. It is specifically designed to be reusable by other modules or programs. It may do this by providing a mechanism for exporting some of its symbols into the symbol table of any package using it, or it may function as a class definition and make its semantics available implicitly through method calls on the class and its objects, without explicitly exporting anything. Or it can do a little of both.</source>
          <target state="translated">Модуль-это просто набор связанных функций в файле библиотеки,т.е.пакет Perl с тем же именем,что и файл.Он специально разработан для многократного использования другими модулями или программами.Он может сделать это,предоставив механизм экспорта некоторых своих символов в таблицу символов любого пакета,использующего его,или же он может функционировать как определение класса и делать его семантику неявно доступной через вызовы методов к классу и его объектам,без явного экспорта чего бы то ни было.Или же он может сделать и то,и другое.</target>
        </trans-unit>
        <trans-unit id="e2c608d01740d058ca105f502acc61136af2e317" translate="yes" xml:space="preserve">
          <source>A module that breaks a program text into a sequence of &lt;b&gt;tokens&lt;/b&gt; for later analysis by a parser.</source>
          <target state="translated">Модуль, который разбивает текст программы на последовательность &lt;b&gt;токенов&lt;/b&gt; для последующего анализа парсером.</target>
        </trans-unit>
        <trans-unit id="a247d01be7fadaf27f2b9413690f6e9d188b0db4" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">Модуль, который помогает вам тестировать модули тестирования, созданные с помощью &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5af87f8a65e9ecb41934ff3d4e29f132cd6922de" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3605e1a22b2192fa5aa9baada403491f3d035bb2" translate="yes" xml:space="preserve">
          <source>A module that implements DOS-like globbing with a few enhancements. It is largely compatible with perlglob.exe (the M$ setargv.obj version) in all but one respect--it understands wildcards in directory components.</source>
          <target state="translated">Модуль,реализующий DOS-подобный глобус с некоторыми улучшениями.Он в значительной степени совместим с perlglob.exe (версия M$ setargv.obj)во всех,кроме одного-он понимает подстановочные знаки в компонентах каталогов.</target>
        </trans-unit>
        <trans-unit id="28b02d8f461ab26400c63c168a94b3b2407585a9" translate="yes" xml:space="preserve">
          <source>A module's code has to be warning and strict-clean, since you can't guarantee the conditions that it'll be used under. Besides, you wouldn't want to distribute code that wasn't warning or strict-clean anyway, right?</source>
          <target state="translated">Код модуля должен быть предупреждающим и строго чистым,так как вы не можете гарантировать условия,при которых он будет использоваться.Кроме того,вы все равно не захотите распространять код,который не является предупреждающим или строго чистым,не так ли?</target>
        </trans-unit>
        <trans-unit id="c91f5a59bb26aa2af0fbaed73706b37f93fe9a63" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; . See &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="translated">Более полный и гибкий интерфейс для чтения / записи файлов / буферов gzip включен в модуль &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; . См. &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt; и &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="d54d0f134a7e139701b0fa7cb70f024a89595497" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt;. See &lt;a href=&quot;IO::Compress::Gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47893a0d4c8d8763c8f1003ea95b492858375e4" translate="yes" xml:space="preserve">
          <source>A more complete example of this is the Shell module on CPAN, which can treat undefined subroutine calls as calls to external programs.</source>
          <target state="translated">Более полным примером этого является модуль Shell на CPAN,который может трактовать неопределенные вызовы подпрограмм как вызовы к внешним программам.</target>
        </trans-unit>
        <trans-unit id="548a58ac3a8a4f644d16e2322da948be053c0188" translate="yes" xml:space="preserve">
          <source>A more dangerous version of getcwd(), but potentially faster.</source>
          <target state="translated">Более опасная версия getcwd(),но потенциально более быстрая.</target>
        </trans-unit>
        <trans-unit id="9c501a7097bf538c4d236187aed836b438d78d12" translate="yes" xml:space="preserve">
          <source>A more dangerous, but potentially faster version of abs_path.</source>
          <target state="translated">Более опасная,но потенциально более быстрая версия abs_path.</target>
        </trans-unit>
        <trans-unit id="2fcc75b6685bd19dcf8c164fa65f41da165a633c" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7a13ddb80b2e7ad5a52fa1664ac4bd3c5aef4e" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">Более простой способ - изменить дескрипторы файлов, используемые &lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f085d06d504bc04c8c1f364c54e3b2d32d488c0" translate="yes" xml:space="preserve">
          <source>A more elegant (and safer) interface is needed.</source>
          <target state="translated">Необходим более элегантный (и более безопасный)интерфейс.</target>
        </trans-unit>
        <trans-unit id="d906501834bb08ebb1263e2b0973fc289f4c913f" translate="yes" xml:space="preserve">
          <source>A more general approach is to intervene manually, as with an example for the DB_File module, which requires SleepyCat's libdb.sl:</source>
          <target state="translated">Более общий подход заключается в ручном вмешательстве,как в примере для модуля DB_File,для которого требуется libdb.sl от SleepyCat:</target>
        </trans-unit>
        <trans-unit id="a0a3703fe588fb0e60a0c01fcfb0d140fe8770a1" translate="yes" xml:space="preserve">
          <source>A more readable, and perhaps more &quot;plain&quot; way is to use an alternate set of delimiters that doesn't require a single &quot;&amp;gt;&quot; to be escaped. Doubled angle brackets (&quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;) may be used</source>
          <target state="translated">Более читаемый и, возможно, более &amp;laquo;простой&amp;raquo; способ - использовать альтернативный набор разделителей, который не требует экранирования одного символа &amp;laquo;&amp;gt;&amp;raquo;. Можно использовать двойные угловые скобки (&amp;laquo;&amp;lt;&amp;lt;&amp;raquo; и &amp;laquo;&amp;gt;&amp;gt;&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="4f3108171bdddd798db1e9b26d8d770fd7116c20" translate="yes" xml:space="preserve">
          <source>A morpheme in a programming language, the smallest unit of text with semantic significance.</source>
          <target state="translated">Морфема на языке программирования,наименьшая единица текста с семантической значимостью.</target>
        </trans-unit>
        <trans-unit id="2790cfc68a916af917f3cc04e172e9586561a9c1" translate="yes" xml:space="preserve">
          <source>A naive, but often sufficient heuristic on ASCII platforms, for testing the first highbit byte-sequence in a BOM-less file (whether in code or in Pod!), to see whether that sequence is valid as UTF-8 (RFC 2279) is to check whether that the first byte in the sequence is in the range 0xC2 - 0xFD</source>
          <target state="translated">Наивный,но часто достаточный эвризм на ASCII платформах,для тестирования первой старшей байтовой последовательности в BOM-файле (будь то в коде или в Pod!),чтобы убедиться,что эта последовательность действительна в виде UTF-8 (RFC 2279),-это проверить,находится ли первый байт в последовательности в диапазоне 0xC2-0xFD</target>
        </trans-unit>
        <trans-unit id="826c2733de66381609264a147718bd8a6dee2df5" translate="yes" xml:space="preserve">
          <source>A name for a concrete set of behaviors. A role is a way to add behavior to a class without inheritance.</source>
          <target state="translated">Название для конкретного набора поведения.Роль-это способ добавить поведение в класс без наследования.</target>
        </trans-unit>
        <trans-unit id="6cc90f6ad3d71e4b26203e2d58a28aac467dba0f" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Имя, представляющее конкретный случай открытия каталога для чтения, пока вы его не закроете. См. &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6c6fe92e40ceff3ff69d97ca9dd71043580f61d" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;opendir&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d4f638a5f1b060674c6232dbb757e9b9e2d99e" translate="yes" xml:space="preserve">
          <source>A name you give to a &lt;b&gt;statement&lt;/b&gt; so that you can talk about that statement elsewhere in the program.</source>
          <target state="translated">Имя, которое вы даете &lt;b&gt;оператору,&lt;/b&gt; чтобы вы могли говорить об этом операторе в другом месте программы.</target>
        </trans-unit>
        <trans-unit id="c7a5f11c051d5e99d07f67bdaab9eaa5cf1c7964" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list concatenation version of the comma. That means it was never a list to start with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e963f1a0b66c9a6c01f8278ff2607d7847c7265" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list construction version of the comma. That means it was never a list to start with.</source>
          <target state="translated">Именованный массив в скалярном контексте сильно отличается от того, что на первый взгляд может показаться списком в скалярном контексте. Вы не можете получить список типа &lt;code&gt;(1,2,3)&lt;/code&gt; в скалярном контексте, потому что компилятор знает контекст во время компиляции. Здесь будет сгенерирован скалярный оператор запятой, а не версия запятой для построения списка. Это означает, что это никогда не было списком для начала.</target>
        </trans-unit>
        <trans-unit id="ccb2fe3157763e6463fb7171376abf423c75879f" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt;. See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75daf7108ed110da5eff87e476f0ddf2290f10b8" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{NAME}&lt;/code&gt; ) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; . See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="translated">Именованная группа захвата. Идентичен во всех отношениях обычным скобкам захвата &lt;code&gt;()&lt;/code&gt; , но с дополнительным фактом, что на группу можно ссылаться по имени в различных конструкциях регулярных выражений (например, &lt;code&gt;\g{NAME}&lt;/code&gt; ) и к ней можно обращаться по имени после успешного совпадения через &lt;code&gt;%+&lt;/code&gt; или &lt;code&gt;%-&lt;/code&gt; . См. &lt;a href=&quot;perlvar&quot;&gt;Perlvar&lt;/a&gt; для получения более подробной информации о хешах &lt;code&gt;%+&lt;/code&gt; и &lt;code&gt;%-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="184923b65ef8ae0c8a3e87da3ade2989c9cad4ca" translate="yes" xml:space="preserve">
          <source>A named collection of data, usually stored on disk in a &lt;b&gt;directory&lt;/b&gt; in a &lt;b&gt;filesystem&lt;/b&gt;. Roughly like a document, if you&amp;rsquo;re into office metaphors. In modern filesystems, you can actually give a file more than one name. Some files have special properties, like directories and devices.</source>
          <target state="translated">Именованные сбор данных, как правило , хранятся на диске в &lt;b&gt;директории&lt;/b&gt; в &lt;b&gt;файловой системе&lt;/b&gt; . Примерно как документ, если вам нравятся офисные метафоры. В современных файловых системах вы можете дать файлу несколько имен. Некоторые файлы имеют особые свойства, например каталоги и устройства.</target>
        </trans-unit>
        <trans-unit id="6a9ab3c01eb064a3661e1bb7b921e5b073d19ecd" translate="yes" xml:space="preserve">
          <source>A named or otherwise accessible piece of program that can be invoked from elsewhere in the program in order to accomplish some subgoal of the program. A subroutine is often parameterized to accomplish different but related things depending on its input &lt;b&gt;arguments&lt;/b&gt;. If the subroutine returns a meaningful &lt;b&gt;value&lt;/b&gt;, it is also called a &lt;b&gt;function&lt;/b&gt;.</source>
          <target state="translated">Именованный или иным образом доступный фрагмент программы, который может быть вызван из любого места в программе для достижения некоторой подцели программы. Подпрограмма часто параметризуется для выполнения разных, но связанных вещей в зависимости от ее входных &lt;b&gt;аргументов&lt;/b&gt; . Если подпрограмма возвращает значимое &lt;b&gt;значение&lt;/b&gt; , она также называется &lt;b&gt;функцией&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fd84ea80f8d7433a1aa60b125a9e6b4dc8885ca9" translate="yes" xml:space="preserve">
          <source>A named pipe (often referred to as a FIFO) is an old Unix IPC mechanism for processes communicating on the same machine. It works just like regular anonymous pipes, except that the processes rendezvous using a filename and need not be related.</source>
          <target state="translated">Именованная труба (часто называемая FIFO)-это старый Unix IPC механизм для процессов,взаимодействующих на одной и той же машине.Он работает точно так же,как обычные анонимные трубы,за исключением того,что процессы рандеву используют имя файла и не должны быть связаны друг с другом.</target>
        </trans-unit>
        <trans-unit id="1bcf4b5c3266b1cc1c63363a98c94938d5445b2f" translate="yes" xml:space="preserve">
          <source>A named pipe, created via &lt;code&gt;CreateNamedPipe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d06a3ea39fd5acfb66f824c51baebd59e34891" translate="yes" xml:space="preserve">
          <source>A named storage location that can hold any of various kinds of &lt;b&gt;value&lt;/b&gt;, as your program sees fit.</source>
          <target state="translated">Именованное хранилище, которое может содержать любые из различных типов &lt;b&gt;значений&lt;/b&gt; , как ваша программа считает нужным.</target>
        </trans-unit>
        <trans-unit id="092b494909d87658298161632e734b7420bfadba" translate="yes" xml:space="preserve">
          <source>A negatable option is specified with an exclamation mark &lt;code&gt;!&lt;/code&gt; after the option name:</source>
          <target state="translated">Отрицательный параметр обозначается восклицательным знаком &lt;code&gt;!&lt;/code&gt; после названия опции:</target>
        </trans-unit>
        <trans-unit id="99e2aec2990f88ba3867f8f52b0dfe7ccc80feb8" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; . The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="translated">Отрицательное выражение, будь то &lt;code&gt;!(EXPR)&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt; , или логическое исключающее &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; , (EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2) . Побитовые версии ( &lt;code&gt;~&lt;/code&gt; и &lt;code&gt;^&lt;/code&gt; ) не включены.</target>
        </trans-unit>
        <trans-unit id="9d1e74169dd288f80b0a507b493221feacddf276" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;not(EXPR)&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) xor (EXPR2)&lt;/code&gt;. The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854efffaefa787b0da74283032eac82589c1370b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">Имя отрицательного сигнала совпадает с номером отрицательного сигнала, уничтожая группы процессов вместо процессов. Например, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; отправит &lt;code&gt;SIGKILL&lt;/code&gt; всей указанной группе процессов. Это означает, что вы обычно хотите использовать положительные, а не отрицательные сигналы.</target>
        </trans-unit>
        <trans-unit id="489423251916154fc8d55b14cad49fcf24beefc2" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">Имя отрицательного сигнала совпадает с номером отрицательного сигнала, уничтожая группы процессов вместо процессов. Например, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; отправит &lt;code&gt;SIGKILL&lt;/code&gt; всей указанной группе процессов. Это означает, что вы обычно хотите использовать положительные, а не отрицательные сигналы.</target>
        </trans-unit>
        <trans-unit id="5839d6eebd6bf96dcf15322f2ba95d945cb0ed5b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;kill '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;kill -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7af62eb6dd0992f67ddc428ca2b71250ece618" translate="yes" xml:space="preserve">
          <source>A nested code block was found that started with a delimiter that was specified as being only to be used as an outermost bracket.</source>
          <target state="translated">Был найден вложенный блок кода,который начинался с разделителя,который был указан только как крайняя скобка.</target>
        </trans-unit>
        <trans-unit id="ef68acbebe6cbfeffd4c2199fc642b8e08d6c12d" translate="yes" xml:space="preserve">
          <source>A network share.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfb1c2f0e03b3f5c0a88fd5a3243fdba91d6307" translate="yes" xml:space="preserve">
          <source>A new Net::POP3 object must be created with the</source>
          <target state="translated">Новый объект Net::POP3 должен быть создан с помощью параметра</target>
        </trans-unit>
        <trans-unit id="a6942aa9b1458599174d5fd62309534ead314562" translate="yes" xml:space="preserve">
          <source>A new Net::SMTP object must be created with the</source>
          <target state="translated">Новый объект Net::SMTP должен быть создан с помощью параметра</target>
        </trans-unit>
        <trans-unit id="a156df59890d9311b601d33944f7c60f5c525f91" translate="yes" xml:space="preserve">
          <source>A new dumper is created by a call</source>
          <target state="translated">Новый самосвал создается по вызову.</target>
        </trans-unit>
        <trans-unit id="ce307d445764b039e813c87b536bf4d7ae071734" translate="yes" xml:space="preserve">
          <source>A new executable loads an extension compiled for the old executable when an old perl executable is running. In this case the extension will not pick up the forwarder - with fatal results.</source>
          <target state="translated">Новый исполняемый файл загружает расширение,скомпилированное для старого исполняемого файла,когда запущен старый исполняемый файл на perl.В этом случае расширение не будет подхватывать форвардер-с фатальным результатом.</target>
        </trans-unit>
        <trans-unit id="ebbd18c3575dd80f81d435a80fe2d3c8ed42ba76" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked
method&lt;/code&gt; . Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="translated">Новая функция, которая позволяет объявлять &lt;b&gt;переменные&lt;/b&gt; и &lt;b&gt;подпрограммы&lt;/b&gt; с модификаторами, как в &lt;code&gt;sub foo : locked method&lt;/code&gt; . Кроме того, еще одно имя для &lt;b&gt;переменной экземпляра&lt;/b&gt; в качестве &lt;b&gt;объекта&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c0543491269b3103c51b9af9cf33ea5cb5bbeafd" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked method&lt;/code&gt;. Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0af11825c345bf1ba555a00fc78d3675a49bab" translate="yes" xml:space="preserve">
          <source>A new version object can be created as a copy of an existing version object, either as a class method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e164afa95fb2ed837b476e0b8fef0b485a678f9f" translate="yes" xml:space="preserve">
          <source>A new version of the output file is always created, which inherits the structure and RMS attributes of the input file, except for owner and protections (and possibly timestamps; see below). All data from the input file is copied to the output file; if either of the first two parameters to &lt;code&gt;rmscopy&lt;/code&gt; is a file handle, its position is unchanged. (Note that this means a file handle pointing to the output file will be associated with an old version of that file after &lt;code&gt;rmscopy&lt;/code&gt; returns, not the newly created version.)</source>
          <target state="translated">Всегда создается новая версия выходного файла, которая наследует структуру и атрибуты RMS входного файла, за исключением владельца и средств защиты (и, возможно, временных меток; см. Ниже). Все данные из входного файла копируются в выходной файл; если один из первых двух параметров &lt;code&gt;rmscopy&lt;/code&gt; является дескриптором файла, его положение не изменяется. (Обратите внимание, что это означает, что дескриптор файла, указывающий на выходной файл, будет связан со старой версией этого файла после &lt;code&gt;rmscopy&lt;/code&gt; , а не с вновь созданной версией.)</target>
        </trans-unit>
        <trans-unit id="c0eacc7ea97ca14f2375b6edf715d33122368ca7" translate="yes" xml:space="preserve">
          <source>A nice general-purpose fixer-upper function for indented here documents follows. It expects to be called with a here document as its argument. It looks to see whether each line begins with a common substring, and if so, strips that substring off. Otherwise, it takes the amount of leading whitespace found on the first line and removes that much off each subsequent line.</source>
          <target state="translated">Симпатичная универсальная функция фиксатора-верхней части для отпечатанных здесь документов следует.Она рассчитывает быть вызвана здесь документом как ее аргумент.Она смотрит,начинается ли каждая строка с общей подстроки,и если да,то отсекает эту подстроку.В противном случае,она берет количество лидирующих пробельных символов,найденных в первой строке,и удаляет столько же пробельных символов из каждой последующей строки.</target>
        </trans-unit>
        <trans-unit id="0198bb3fbec60180f4c0bac09f0a4bb94105a46c" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration.</source>
          <target state="translated">Псевдоним для чего-либо, который во всех отношениях ведет себя так, как если бы вы использовали исходное имя вместо псевдонима. Временные псевдонимы неявно создаются в переменной цикла для циклов &lt;code&gt;foreach&lt;/code&gt; , в переменной &lt;code&gt;$_&lt;/code&gt; для операторов &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; , в &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; во время функции сравнения &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; и в каждом элементе &lt;code&gt;@_&lt;/code&gt; для &lt;b&gt;фактических аргументов&lt;/b&gt; a вызов подпрограммы. Постоянные псевдонимы явно создаются в &lt;b&gt;пакетах&lt;/b&gt; путем &lt;b&gt;импорта&lt;/b&gt; символов или присвоения &lt;b&gt;typeglobs&lt;/b&gt;. Псевдонимы с лексической областью видимости для переменных пакета явно создаются &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; объявлением.</target>
        </trans-unit>
        <trans-unit id="91ae023a14ec4220bee3363a586d5172c30ca7a4" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;sort&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;our&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1173dc0bd47411653c3329572e8d27b49fadacc" translate="yes" xml:space="preserve">
          <source>A no-op job.</source>
          <target state="translated">Безработная.</target>
        </trans-unit>
        <trans-unit id="fb1ec4028a0ac13b58d2706d78d6f0e42a16b590" translate="yes" xml:space="preserve">
          <source>A no-op job. Returned by &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; as an instruction to the harness to spin (keep executing tests) while the scheduler can't return a real job.</source>
          <target state="translated">Безоперационная работа. Возвращается &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; в качестве инструкции жгуту вращаться (продолжать выполнение тестов), в то время как планировщик не может вернуть реальное задание.</target>
        </trans-unit>
        <trans-unit id="7309346a0851b1fe75cb3e5cdad78936072ace5d" translate="yes" xml:space="preserve">
          <source>A non-empty Z&amp;lt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3187ac42757f3c2b53340569d4306b0db3207981" translate="yes" xml:space="preserve">
          <source>A non-optional prefix was specified but wasn't found at the start of the text.</source>
          <target state="translated">Неопциональный префикс был указан,но не был найден в начале текста.</target>
        </trans-unit>
        <trans-unit id="f9ce11826e25a9f2a78731b7ee2ed1865f372e1a" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt; , not &lt;code&gt;79908&lt;/code&gt; :</source>
          <target state="translated">Не столь очевидная оговорка (см. [RT # 79908]) заключается в том, что переменная будет немедленно встроена и перестанет вести себя как обычная лексическая переменная, например, это напечатает &lt;code&gt;79907&lt;/code&gt; , а не &lt;code&gt;79908&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f08995644089d73bded5c431bbdb0a14a2ba0c4e" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt;, not &lt;code&gt;79908&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33aa5e0c48db29d1cb8a94c57d888257eb0656f5" translate="yes" xml:space="preserve">
          <source>A notable and rather unavoidable problem with this method: &quot;x-mingo-tom&quot; has an &quot;x&quot; because the whole tag isn't an IANA-registered tag -- but super_languages('x-mingo-tom') is ('x-mingo') -- which isn't really right, since 'i-mingo' is registered. But this module has no way of knowing that. (But note that same_language_tag('x-mingo', 'i-mingo') is TRUE.)</source>
          <target state="translated">Заметная и довольно неизбежная проблема с этим методом:&quot;x-mingo-tom&quot; имеет &quot;x&quot;,потому что весь тэг не зарегистрирован IANA --но super_languages('x-mingo-tom')('x-mingo-tom')--что на самом деле неправильно,так как 'i-mingo' зарегистрирован.Но этот модуль не может этого знать.(Но обратите внимание,что same_language_tag('x-mingo','i-mingo')-это TRUE).</target>
        </trans-unit>
        <trans-unit id="11f822ddf21914cec4db6b8a6e4ef4d83bd0921c" translate="yes" xml:space="preserve">
          <source>A note about prefixes</source>
          <target state="translated">Записка о префиксах</target>
        </trans-unit>
        <trans-unit id="76a89e2dcaf10bf4c615af7db34f35d8d2e129e8" translate="yes" xml:space="preserve">
          <source>A note on derived files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3c02a71990e114ae348bdc123412980dc80cfc" translate="yes" xml:space="preserve">
          <source>A note on freshness</source>
          <target state="translated">Записка о свежести</target>
        </trans-unit>
        <trans-unit id="fabcf1ad8a30bffca7d5c34f9a41567038863f1c" translate="yes" xml:space="preserve">
          <source>A note: to save time, &quot;regular expression&quot; is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e5798976260679942afb564efdac5fe47bc36f" translate="yes" xml:space="preserve">
          <source>A note: to save time, 'regular expression' is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="translated">Примечание:для экономии времени,&quot;регулярное выражение&quot; часто сокращается как регэкспресс или регэкс.Регекс-более естественное сокращение,чем регекс,но его сложнее произнести.Документация по Perl pod равномерно разделена на регеxp и регекс;в Perl есть более чем один способ его сокращения.Мы будем использовать регэксп в этом учебнике.</target>
        </trans-unit>
        <trans-unit id="7a28dfd2dad981af662c7cb062386ed614bc87a3" translate="yes" xml:space="preserve">
          <source>A notional &amp;ldquo;baton&amp;rdquo; handed around the Perl community indicating who is the lead integrator in some arena of development.</source>
          <target state="translated">Условная &amp;laquo;эстафета&amp;raquo;, переданная сообществу Perl, показывающая, кто является ведущим интегратором в определенной области разработки.</target>
        </trans-unit>
        <trans-unit id="ab0d25629a9f27d8e2343a6d3ae7ea4be0af2ea6" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; . Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt; . See also the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">Число по основанию 16, сокращенно &amp;laquo;шестнадцатеричный&amp;raquo;. Цифры от 10 до 15 обычно обозначаются буквами от &lt;code&gt;a&lt;/code&gt; до &lt;code&gt;f&lt;/code&gt; . Шестнадцатеричные константы в Perl начинаются с &lt;code&gt;0x&lt;/code&gt; . См. Также &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; функцию в Camel, глава 27, &amp;laquo;Функции&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f9e8cabeba10a3bcb61dba08b487b1b09e68f5dd" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt;. See also the &lt;code&gt;hex&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e5df9d465cc20aefe1124101a063a27122315b" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Число в базе 8. Разрешены только цифры от 0 до 7. Восьмеричные константы в Perl начинаются с 0, как в 013. См. Также функцию &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fa37e6f196e06e72c5f214ea85cb6255f2f8ebd" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;oct&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69cd7220ef5a1c647fe095901d92bd9cd440d40" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ряд последовательностей обратной косой черты связаны с изменением символа или следующих за ними символов. &lt;code&gt;\l&lt;/code&gt; будет строчными буквами следующий за ним символ, а &lt;code&gt;\u&lt;/code&gt; будет прописными буквами (или, точнее, заголовком) символ, следующий за ним. Они предоставляют функциональные возможности, аналогичные функциям &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93a2720acec49cfe060d50c7a0a7fff2508e38b0" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;lcfirst&lt;/code&gt; and &lt;code&gt;ucfirst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459b7ae43dc0118e5f951dff6050b593d0645ae4" translate="yes" xml:space="preserve">
          <source>A number of canned filers are provided with this module. They cover a number of the main areas that filters are needed when interfacing with DBM files. They also act as templates for your own filters.</source>
          <target state="translated">В комплект поставки этого модуля входит несколько консервных фильтров.Они охватывают ряд основных областей,которые необходимы фильтрам при взаимодействии с файлами DBM.Они также выступают в качестве шаблонов для ваших собственных фильтров.</target>
        </trans-unit>
        <trans-unit id="f165970578836ece242fb56057dfca4b475f795a" translate="yes" xml:space="preserve">
          <source>A number of functions are supplied in</source>
          <target state="translated">Ряд функций поставляется в</target>
        </trans-unit>
        <trans-unit id="6be56084a39af168e51355bee3d9a2b6a1443404" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">Некоторым методам в &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; требуется ряд символических констант . По умолчанию ничего не импортируется.</target>
        </trans-unit>
        <trans-unit id="4deb3640bfb1ba76e4eb91a284fff22ce6cde951" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f171c4c952b5198d03d74dd09582818a3af3ac23" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">Некоторым методам в &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; требуется ряд символических констант . По умолчанию ничего не импортируется.</target>
        </trans-unit>
        <trans-unit id="3c0835dba02f363011b0b421bc52d49d766ce416" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8444a37c81d8d0b0573487ab107c561cc0dcc2fd" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">Некоторым методам в &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; требуется ряд символических констант . По умолчанию ничего не импортируется.</target>
        </trans-unit>
        <trans-unit id="625cd39bbda422f4927006460178ed47c79bf138" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8207ded75c4eb74b9b2506733acf10f3db4dee" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">Некоторым методам в &lt;code&gt;IO::Compress::Zip&lt;/code&gt; требуется ряд символьных констант . По умолчанию ничего не импортируется.</target>
        </trans-unit>
        <trans-unit id="81a3e04f06d43cad2f607ec957e7b72dedcb4f99" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13520cd60b01e1d5b0a654b3de30cd8d691bfd72" translate="yes" xml:space="preserve">
          <source>A number of the perl self-tests fails for various reasons; generally these are minor and due to subtle differences between common POSIX-based environments and the OpenVOS POSIX environment. Ensure that you conduct sufficient testing of your code to guarantee that it works properly in the OpenVOS environment.</source>
          <target state="translated">Ряд самотестов на perl терпит неудачу по разным причинам;как правило,они незначительны и обусловлены тонкими различиями между распространенными POSIX-окружениями и OpenVOS POSIX-окружением.Убедитесь,что вы провели достаточное тестирование вашего кода,чтобы гарантировать его корректную работу в среде OpenVOS.</target>
        </trans-unit>
        <trans-unit id="6938035226ed22bf21a82d2591890e65b71e1814" translate="yes" xml:space="preserve">
          <source>A number or quoted &lt;b&gt;string&lt;/b&gt;&amp;mdash;an actual &lt;b&gt;value&lt;/b&gt; in the text of your program, as opposed to a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">Число или &lt;b&gt;строка в&lt;/b&gt; кавычках - фактическое &lt;b&gt;значение&lt;/b&gt; в тексте вашей программы, а не &lt;b&gt;переменная&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="817e0a226397234bf07db9517946a4f73aedf564" translate="yes" xml:space="preserve">
          <source>A number with no fractional (decimal) part. A counting number, like 1, 2, 3, and so on, but including 0 and the negatives.</source>
          <target state="translated">Число без дробной (десятичной)части.Считающее число,например,1,2,3 и так далее,но включающее 0 и отрицательные числа.</target>
        </trans-unit>
        <trans-unit id="c7326b507f702c91b1651bab340f7fd9d1233ba7" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status</source>
          <target state="translated">Цифровое значение,соответствующее требуемому статусу выхода.</target>
        </trans-unit>
        <trans-unit id="516dd9f40fab20fab164bbcf97c01e41beccb620" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status.</source>
          <target state="translated">Числовое значение,соответствующее требуемому статусу выхода.</target>
        </trans-unit>
        <trans-unit id="f65805b27975bd2ea9ebc728a7ffd9aba1dc2684" translate="yes" xml:space="preserve">
          <source>A one- or two-character abbreviation for the OP's name.</source>
          <target state="translated">Одно-или двухсимвольная аббревиатура названия ОП.</target>
        </trans-unit>
        <trans-unit id="3834679d6aeef19dae7b1ac9263711aa538649cc" translate="yes" xml:space="preserve">
          <source>A opposite problem occurs if you extract a UTF8-encoded file from a tarball. Using &lt;code&gt;get_content()&lt;/code&gt; on the &lt;code&gt;Archive::Tar::File&lt;/code&gt; object will return its content as a bytestring, not as a Unicode string.</source>
          <target state="translated">Противоположная проблема возникает, если вы извлекаете файл в кодировке UTF8 из tarball. Использование &lt;code&gt;get_content()&lt;/code&gt; на &lt;code&gt;Archive::Tar::File&lt;/code&gt; объекта возвращает его содержимое в виде массива байт, а не в виде строки Unicode.</target>
        </trans-unit>
        <trans-unit id="d534bb490c9aaec5af5d234ddc4047716ba79bca" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; on, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d591c8e0c3b224f857fbffdd8e1cd395cd343c4" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">Оператор пакета влияет только на динамические переменные, включая те, которые вы использовали &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; , но</target>
        </trans-unit>
        <trans-unit id="fb0a21b3a9fa52dc9e4b76474cd2a329094bf2cb" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">Оператор пакета влияет только на динамические переменные, включая те, которые вы использовали &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; , но</target>
        </trans-unit>
        <trans-unit id="17811bc7788393455d0445378861485836290fe5" translate="yes" xml:space="preserve">
          <source>A packet of data, such as a &lt;b&gt;UDP&lt;/b&gt; message, that (from the viewpoint of the programs involved) can be sent independently over the network. (In fact, all packets are sent independently at the &lt;b&gt;IP&lt;/b&gt; level, but &lt;b&gt;stream&lt;/b&gt; protocols such as &lt;b&gt;TCP&lt;/b&gt; hide this from your program.)</source>
          <target state="translated">Пакет данных, например сообщение &lt;b&gt;UDP&lt;/b&gt; , который (с точки зрения задействованных программ) может быть независимо отправлен по сети. (Фактически, все пакеты отправляются независимо на уровне &lt;b&gt;IP&lt;/b&gt; , но &lt;b&gt;потоковые&lt;/b&gt; протоколы, такие как &lt;b&gt;TCP,&lt;/b&gt; скрывают это от вашей программы.)</target>
        </trans-unit>
        <trans-unit id="41fc1fe8da73d2058878cb04079cedd356502e52" translate="yes" xml:space="preserve">
          <source>A parameter list for the constructor is a hash, which can include a special key &lt;code&gt;locale&lt;/code&gt; and its value (case-insensitive) standing for a Unicode base language code (two or three-letter). For example, &lt;code&gt;Unicode::Collate::Locale-&amp;gt;new(locale =&amp;gt; 'ES')&lt;/code&gt; returns a collator tailored for Spanish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fade7e7e6957062a1ff55f1cde07bb98b07451" translate="yes" xml:space="preserve">
          <source>A parenthesized &lt;b&gt;subpattern&lt;/b&gt; used to group parts of a &lt;b&gt;regular expression&lt;/b&gt; into a single &lt;b&gt;atom&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;Подшаблон в&lt;/b&gt; скобках, используемый для группировки частей &lt;b&gt;регулярного выражения&lt;/b&gt; в один &lt;b&gt;атом&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d31a105759b488881233b964b8bc299b268f919f" translate="yes" xml:space="preserve">
          <source>A particular 8-bit extension to ASCII that includes grave and acute accented Latin characters. Languages that can employ ISO 8859-1 include all the languages covered by ASCII as well as Afrikaans, Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian, Portuguese, Spanish, and Swedish. Dutch is covered albeit without the ij ligature. French is covered too but without the oe ligature. German can use ISO 8859-1 but must do so without German-style quotation marks. This set is based on Western European extensions to ASCII and is commonly encountered in world wide web work. In IBM character code set identification terminology, ISO 8859-1 is also known as CCSID 819 (or sometimes 0819 or even 00819).</source>
          <target state="translated">Особое 8-разрядное расширение ASCII,включающее в себя тяжелые и остро акцентированные латинские символы.Языки,которые могут использовать ISO 8859-1,включают все языки,охватываемые ASCII,а также африканский,албанский,баскский,каталанский,датский,фарерский,финский,норвежский,португальский,испанский,финский и шведский.Голландский язык охватывается,хотя и без лигатуры ij.Французский тоже покрыт,но без вязки.Немецкий язык может использовать ISO 8859-1,но должен делать это без кавычек в немецком стиле.Этот набор основан на западноевропейских расширениях ASCII и часто встречается во всемирной паутине.В терминологии идентификации набора символов IBM,ISO 8859-1 также известен как CCSID 819 (или иногда 0819 или даже 00819).</target>
        </trans-unit>
        <trans-unit id="e0e8dc4da39b64602467413f10af7327c1334e77" translate="yes" xml:space="preserve">
          <source>A past developer of this module once said that it was no longer being actively developed. However, rumors of its demise were greatly exaggerated. Feedback and suggestions are quite welcome.</source>
          <target state="translated">Один из прошлых разработчиков этого модуля однажды сказал,что он больше не активно разрабатывается.Однако слухи о его гибели были сильно преувеличены.Обратная связь и предложения приветствуются.</target>
        </trans-unit>
        <trans-unit id="8c54ff10ac1e2c9e724650394df49761e14faa10" translate="yes" xml:space="preserve">
          <source>A patch is likely to be rejected if it closes off future avenues of development. For instance, a patch that placed a true and final interpretation on prototypes is likely to be rejected because there are still options for the future of prototypes that haven't been addressed.</source>
          <target state="translated">Заплатка,скорее всего,будет отклонена,если она перекроет будущие пути развития.Например,заплатка,содержащая истинную и окончательную интерпретацию прототипов,скорее всего,будет отклонена,потому что все еще есть варианты будущего прототипов,которые не были рассмотрены.</target>
        </trans-unit>
        <trans-unit id="8b84380ed4a63c4a53b35f4fed5c94c1acb30451" translate="yes" xml:space="preserve">
          <source>A pattern that contains one or more variables to be interpolated before parsing the pattern as a &lt;b&gt;regular expression&lt;/b&gt;, and that therefore cannot be analyzed at compile time, but must be reanalyzed each time the pattern match operator is evaluated. Runtime patterns are useful but expensive.</source>
          <target state="translated">Шаблон, который содержит одну или несколько переменных, которые должны быть интерполированы перед синтаксическим анализом шаблона как &lt;b&gt;регулярного выражения&lt;/b&gt; , и, следовательно, не может быть проанализировано во время компиляции, но должен анализироваться повторно каждый раз, когда вычисляется оператор сопоставления с шаблоном. Шаблоны времени выполнения полезны, но дороги.</target>
        </trans-unit>
        <trans-unit id="e54b749fa56abf529dd225e42a12bbcecb4cb20e" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt; ). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;.</source>
          <target state="translated">Шаблон, скомпилированный с модификаторами &lt;code&gt;/u&lt;/code&gt; или &lt;code&gt;/a&lt;/code&gt; , рассматривается как Unicode (хотя есть некоторые ограничения с &lt;code&gt;/a&lt;/code&gt; ). Под модификаторами &lt;code&gt;/d&lt;/code&gt; и &lt;code&gt;/l&lt;/code&gt; есть несколько других указаний для Unicode; см. &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Модификаторы набора символов в perlre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c44383cd9d72dfa1b63f63e5ddbda12ce021d43c" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt;). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;&quot;Character set modifiers&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac81362ffb97f570e29dfbe7c502b0eb97a9aae0" translate="yes" xml:space="preserve">
          <source>A person with permissions to index a &lt;b&gt;namespace&lt;/b&gt; in &lt;b&gt;PAUSE&lt;/b&gt;. Anyone can upload any namespace, but only primary and co-maintainers get their contributions indexed.</source>
          <target state="translated">Человек с разрешениями на индексирование &lt;b&gt;пространства имен&lt;/b&gt; в &lt;b&gt;PAUSE&lt;/b&gt; . Кто угодно может загрузить любое пространство имен, но индексируются только основные участники и соавторы.</target>
        </trans-unit>
        <trans-unit id="9102b11ae3e872fd1d8e80bc53ef699d92261f27" translate="yes" xml:space="preserve">
          <source>A phrase is a function; a phrasebook is a bunch of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf584f5364a06bf31c21ab092ad59923872f304" translate="yes" xml:space="preserve">
          <source>A pidgin-like lingo spoken among &amp;rsquo;droids when they don&amp;rsquo;t wish to reveal their orientation (see &lt;b&gt;endian&lt;/b&gt;). Named after some similar languages spoken (for similar reasons) between compilers and interpreters in the late 20ᵗʰ century. These languages are characterized by representing everything as a nonarchitecture-dependent sequence of bytes.</source>
          <target state="translated">Пиджин-подобный жаргон, на котором говорят дроиды, когда они не хотят раскрывать свою ориентацию (см. &lt;b&gt;Порядок байтов&lt;/b&gt; ). Назван в честь некоторых похожих языков, на которых (по схожим причинам) говорили компиляторы и интерпретаторы в конце 20-го века. Для этих языков характерно представление всего в виде последовательности байтов, не зависящей от архитектуры.</target>
        </trans-unit>
        <trans-unit id="d44cad0ebf83404ba135e65877b0a7348740b15c" translate="yes" xml:space="preserve">
          <source>A piece of &lt;b&gt;memory&lt;/b&gt; accessible by two different &lt;b&gt;processes&lt;/b&gt; who otherwise would not see each other&amp;rsquo;s memory.</source>
          <target state="translated">Часть &lt;b&gt;памяти,&lt;/b&gt; доступная для двух разных &lt;b&gt;процессов,&lt;/b&gt; которые в противном случае не видели бы память друг друга.</target>
        </trans-unit>
        <trans-unit id="ae75b42221a978d2300d9bbb31da21cdb6583f30" translate="yes" xml:space="preserve">
          <source>A piece of data supplied to a &lt;b&gt;program&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, &lt;b&gt;function&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt; to tell it what it&amp;rsquo;s supposed to do. Also called a &amp;ldquo;parameter&amp;rdquo;.</source>
          <target state="translated">Фрагмент данных, передаваемых &lt;b&gt;программе&lt;/b&gt; , &lt;b&gt;подпрограмме&lt;/b&gt; , &lt;b&gt;функции&lt;/b&gt; или &lt;b&gt;методу,&lt;/b&gt; чтобы сообщить, что они должны делать. Также называется &amp;laquo;параметром&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="94f70c32cf9b02415f8a7273bc9818046dbf12f7" translate="yes" xml:space="preserve">
          <source>A piece of data worth eight &lt;b&gt;bits&lt;/b&gt; in most places.</source>
          <target state="translated">В большинстве случаев фрагмент данных стоит восемь &lt;b&gt;бит&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b577f26c3053457a977acc838db8d07639cc6ac7" translate="yes" xml:space="preserve">
          <source>A pitfall when fallback is TRUE and Perl resorts to a built-in implementation of an operator is that some operators have more than one semantic, for example &lt;code&gt;|&lt;/code&gt;:</source>
          <target state="translated">Ловушка, когда откат имеет значение ИСТИНА и Perl прибегает к встроенной реализации оператора, заключается в том, что некоторые операторы имеют более одной семантики, например &lt;code&gt;|&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d50a84892f70340bd3a9931b241841288e99df2a" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; implies &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are not enabled by default. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; requires the optional &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below for more details.</source>
          <target state="translated">Простое &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; подразумевает &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; . Обратите внимание, что &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; по умолчанию не включены. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; требует установки дополнительного модуля &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt; , а включение &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; сделает их экзотические формы недействительными. Подробнее см. &quot; &lt;a href=&quot;#BUGS&quot;&gt;ОШИБКИ&quot;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="784586eba74e7681571d441503dffdaa38283f14" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;use autodie&lt;/code&gt; implies &lt;code&gt;use autodie qw(:default)&lt;/code&gt;. Note that &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; are not enabled by default. &lt;code&gt;system&lt;/code&gt; requires the optional &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5112ffa79f8fbea8b85cd379c0dac6621cfbb1b" translate="yes" xml:space="preserve">
          <source>A port of SysV IPC is available for Cygwin.</source>
          <target state="translated">Для Cygwin доступен порт SysV IPC.</target>
        </trans-unit>
        <trans-unit id="608e0fee3c4504f82197f6257599cc064afc0c33" translate="yes" xml:space="preserve">
          <source>A port of dmake for Windows is available from:</source>
          <target state="translated">Порт dmake для Windows доступен из:</target>
        </trans-unit>
        <trans-unit id="107ead699a34a6b92016575e257f6bfde51b2d06" translate="yes" xml:space="preserve">
          <source>A portion of a &lt;b&gt;string&lt;/b&gt;, starting at a certain &lt;b&gt;character&lt;/b&gt; position (&lt;b&gt;offset&lt;/b&gt;) and proceeding for a certain number of characters.</source>
          <target state="translated">Часть &lt;b&gt;строки&lt;/b&gt; , начинающаяся с определенной позиции &lt;b&gt;символа&lt;/b&gt; ( &lt;b&gt;смещения&lt;/b&gt; ) и продолжающаяся определенным количеством символов.</target>
        </trans-unit>
        <trans-unit id="2df08b2dab9ca8b1fdefb915b96c623e0200cba0" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt; :</source>
          <target state="translated">Позиционный параметр делается необязательным путем указания значения по умолчанию, отделенного от имени параметра знаком &lt;code&gt;=&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b4ce78434f00859636eea671cd22aebe6d9b1f5" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85d6bf4f6c4fdd5d60e077f21d5dcceb61dc47f" translate="yes" xml:space="preserve">
          <source>A possibly-threaded program using a possibly-threaded module might have code like this:</source>
          <target state="translated">Потенциальнопоточная программа,использующая вероятностно-поточный модуль,может иметь такой код:</target>
        </trans-unit>
        <trans-unit id="d97df54b4f20c3925188511860c47d716ece4831" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#%28%3F%3Epattern%29&quot;&gt;&quot;&lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt;&quot;&lt;/a&gt;). Note also that zero-length lookahead/lookbehind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of lookahead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3a72b5c10540ed557a8982bdee312dd7a07842" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt;pattern)&lt;/a&gt;). Note also that zero-length look-ahead/look-behind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of look-ahead</source>
          <target state="translated">Мощный инструмент для оптимизации таких зверей - это так называемая &amp;laquo;независимая группа&amp;raquo;, которая не отступает (см. &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt; Шаблон)&lt;/a&gt; ). Также обратите внимание, что утверждения упреждающего / ретроспективного просмотра нулевой длины не будут выполнять обратный переход, чтобы обеспечить совпадение хвоста, поскольку они находятся в &amp;laquo;логическом&amp;raquo; контексте: релевантным считается только то, совпадают ли они. Например, побочные эффекты упреждающего просмотра</target>
        </trans-unit>
        <trans-unit id="f8090f10d3e078e45a1b56ad19ca0993e67735bf" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt; . With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="translated">Прагма - это модуль, который влияет на некоторые аспекты поведения Perl во время компиляции или выполнения, такие как &lt;code&gt;strict&lt;/code&gt; или &lt;code&gt;warnings&lt;/code&gt; . С Perl 5.10 вы больше не ограничены встроенными прагматами; теперь вы можете создавать пользовательские прагматы, которые изменяют поведение пользовательских функций в лексической области.</target>
        </trans-unit>
        <trans-unit id="49eb60196e1bcc3fb82f50394c222a091a65381b" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt;. With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adf63746ff6644ce7bf5f35f924e0b644796838" translate="yes" xml:space="preserve">
          <source>A precomputed hash value for the MRO's name, or 0.</source>
          <target state="translated">Предварительно вычисленное хэш-значение для имени MRO,или 0.</target>
        </trans-unit>
        <trans-unit id="fef186fd41bd258794b7d0075ad4e261c2b3c05f" translate="yes" xml:space="preserve">
          <source>A predefined &lt;b&gt;character class&lt;/b&gt; matchable by the &lt;code&gt;\p&lt;/code&gt; or &lt;code&gt;\P&lt;/code&gt;&lt;b&gt;metasymbol&lt;/b&gt;. &lt;b&gt;Unicode&lt;/b&gt; defines hundreds of standard properties for every possible codepoint, and Perl defines a few of its own, too.</source>
          <target state="translated">Предварительно определенный &lt;b&gt;класс символов&lt;/b&gt; Matchable по &lt;code&gt;\p&lt;/code&gt; или &lt;code&gt;\P&lt;/code&gt; &lt;b&gt;метасимвол&lt;/b&gt; . &lt;b&gt;Unicode&lt;/b&gt; определяет сотни стандартных свойств для каждой возможной кодовой точки, и Perl также определяет несколько собственных.</target>
        </trans-unit>
        <trans-unit id="a831506546d580a7eadbcde59099e4315b6e4d7c" translate="yes" xml:space="preserve">
          <source>A prerequisite for any of the SDKs is to install ActivePerl from ActiveState, &lt;a href=&quot;http://www.activestate.com/Products/ActivePerl/&quot;&gt;http://www.activestate.com/Products/ActivePerl/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753111eab29b1d3a3d48d9bfe5c8e1db8a75f990" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvIVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">Частная реализация макроса &lt;code&gt;SvIVx&lt;/code&gt; для компиляторов, которые не могут справиться со сложными макросами . Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="194c1f16db6963ad188c9a67ab4a97692452c7d0" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvNVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">Частная реализация макроса &lt;code&gt;SvNVx&lt;/code&gt; для компиляторов, которые не могут справляться со сложными макросами . Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="45f81efd0665fe345ae1ff71f7dc78b1d8a8b9cf" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPV&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">Частная реализация макроса &lt;code&gt;SvPV&lt;/code&gt; для компиляторов, которые не могут справляться со сложными макросами . Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="28ff9ef13649ddfcf7cbf759240331fcc05c09ec" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVbyte&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">Частная реализация макроса &lt;code&gt;SvPVbyte&lt;/code&gt; для компиляторов, которые не могут справиться со сложными макросами . Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="4c48a8487b346d5dd9b069a77af5f464c4aaa911" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVutf8&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">Частная реализация макроса &lt;code&gt;SvPVutf8&lt;/code&gt; для компиляторов, которые не могут справляться со сложными макросами . Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="ccefc2a8adb4ddac3b369c74930a6dbb95e32f5b" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvUVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">Частная реализация макроса &lt;code&gt;SvUVx&lt;/code&gt; для компиляторов, которые не могут справляться со сложными макросами . Вместо этого всегда используйте макрос.</target>
        </trans-unit>
        <trans-unit id="daa3f361ccd92e0c8c69a72e7a450ec455f808bd" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="translated">Процесс, который умер (завершился), но родительский элемент которого еще не получил надлежащего уведомления о его прекращении в силу того, что вызвал &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; . Если вы &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; , вы должны очищать дочерние процессы после их выхода; в противном случае таблица процессов заполнится, и системный администратор не будет доволен вами.</target>
        </trans-unit>
        <trans-unit id="10a925aa1992fe1dac52557b4ea82e693d886104" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;wait&lt;/code&gt; or &lt;code&gt;waitpid&lt;/code&gt;. If you &lt;code&gt;fork&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efafe66eae216a82a4ad38f05565ca385de1f6b" translate="yes" xml:space="preserve">
          <source>A process that usually starts when the system boots and shuts down when the system is shut down is called a daemon (Disk And Execution MONitor). If a daemon process has a configuration file which is modified after the process has been started, there should be a way to tell that process to reread its configuration file without stopping the process. Many daemons provide this mechanism using a &lt;code&gt;SIGHUP&lt;/code&gt; signal handler. When you want to tell the daemon to reread the file, simply send it the &lt;code&gt;SIGHUP&lt;/code&gt; signal.</source>
          <target state="translated">Процесс, который обычно запускается при загрузке системы и завершает свою работу при выключении системы, называется демоном (Disk And Execution MONitor). Если у процесса-демона есть файл конфигурации, который изменяется после запуска процесса, должен быть способ указать этому процессу перечитать его файл конфигурации без остановки процесса. Многие демоны предоставляют этот механизм с помощью обработчика сигнала &lt;code&gt;SIGHUP&lt;/code&gt; . Если вы хотите, чтобы демон перечитал файл, просто отправьте ему сигнал &lt;code&gt;SIGHUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cb736d823d351c183302791cfaf0e9b2bb8195b" translate="yes" xml:space="preserve">
          <source>A program designed to take a &lt;b&gt;stream&lt;/b&gt; of input and transform it into a stream of output.</source>
          <target state="translated">Программа, предназначенная для преобразования &lt;b&gt;потока&lt;/b&gt; ввода в поток вывода.</target>
        </trans-unit>
        <trans-unit id="0e57854f673e33842a3f502762fb9daa3a8e1f70" translate="yes" xml:space="preserve">
          <source>A program or subroutine that runs some other program or subroutine for you, modifying some of its input or output to better suit your purposes.</source>
          <target state="translated">Программа или подпрограмма,которая запускает другую программу или подпрограмму для Вас,изменяя некоторые из ее входных или выходных данных,чтобы они лучше соответствовали Вашим целям.</target>
        </trans-unit>
        <trans-unit id="d4949b399696681050e02e3aa6d195b375c7c318" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt; . See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">Программный метод, который позволяет вам оценить &lt;b&gt;выражение,&lt;/b&gt; а затем, в зависимости от значения выражения, выполнить многосторонний переход к соответствующему фрагменту кода для этого значения. Также называется &amp;laquo;case-структурой&amp;raquo;, названной в честь аналогичной конструкции Паскаля. Большинство операторов коммутатора в Perl написаны с &lt;code&gt;given&lt;/code&gt; . Обратитесь к разделу &amp;laquo; &lt;code&gt;given&lt;/code&gt; заявление&amp;raquo; в Camel главе 4, &amp;laquo;Заявления и декларации&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="226a5640a6bc542b475e6c67b50cca7825517b1f" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt;. See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5911c3911da879ac96181b5190227b6bb058fcf1" translate="yes" xml:space="preserve">
          <source>A program that lets you step through the &lt;b&gt;execution&lt;/b&gt; of your program, stopping or printing things out here and there to see whether anything has gone wrong, and, if so, what. The &amp;ldquo;symbolic&amp;rdquo; part just means that you can talk to the debugger using the same symbols with which your program is written.</source>
          <target state="translated">Программа, которая позволяет вам пошагово &lt;b&gt;выполнять&lt;/b&gt; вашу программу, останавливая или распечатывая кое-что, чтобы увидеть, что что-то пошло не так, и если да, то что. &amp;laquo;Символическая&amp;raquo; часть просто означает, что вы можете разговаривать с отладчиком, используя те же символы, с которыми написана ваша программа.</target>
        </trans-unit>
        <trans-unit id="e0a439842f796bec28d81800d0c2072dc425e000" translate="yes" xml:space="preserve">
          <source>A property may be deprecated, perhaps because its original intent has been replaced by another property, or because its specification was somehow defective. This means that its use is strongly discouraged, so much so that a warning will be issued if used, unless the regular expression is in the scope of a &lt;code&gt;no warnings 'deprecated'&lt;/code&gt; statement. A '&lt;b&gt;D&lt;/b&gt;' flags each such entry in the table, and the entry there for the longest, most descriptive version of the property will give the reason it is deprecated, and perhaps advice. Perl may issue such a warning, even for properties that aren't officially deprecated by Unicode, when there used to be characters or code points that were matched by them, but no longer. This is to warn you that your program may not work like it did on earlier Unicode releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ccfd6a1d722c44d4bb4f0ae8561be32c66dd88" translate="yes" xml:space="preserve">
          <source>A property may be stabilized. Such a determination does not indicate that the property should or should not be used; instead it is a declaration that the property will not be maintained nor extended for newly encoded characters. Such properties are marked with an '&lt;b&gt;S&lt;/b&gt;' in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8959e21bc141d47a80e97a7ffb793dfa86254ad0" translate="yes" xml:space="preserve">
          <source>A property named 'var' is assumed to exist for the opcodes, and is interpolated into the rendering.</source>
          <target state="translated">Свойство под названием var предполагается существующим для опкодов и интерполируется в рендеринг.</target>
        </trans-unit>
        <trans-unit id="7afee4b0974cba3382e7bb4183222667ce915680" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt; ), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt; ). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="translated">Свойство определенных персонажей. Первоначально наборщик сохранял заглавные буквы в верхнем из двух регистров и строчные буквы в нижнем. Unicode распознает три случая: в &lt;b&gt;нижнем регистре&lt;/b&gt; ( &lt;b&gt;свойство символа &lt;/b&gt; &lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;titlecase&lt;/b&gt; ( &lt;code&gt;\p{title}&lt;/code&gt; ), а в &lt;b&gt;верхнем регистре&lt;/b&gt; ( &lt;code&gt;\p{upper}&lt;/code&gt; ). Четвертое отображение casemapping, называемое &lt;b&gt;foldcase,&lt;/b&gt; само по себе не является отдельным случаем, но оно используется внутри для реализации &lt;b&gt;casefolding&lt;/b&gt; . Не все буквы имеют регистр, а некоторые небуквенные - регистр.</target>
        </trans-unit>
        <trans-unit id="33b899d68b6367eee5e01ad07784bbb907d587b3" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt;), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt;), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt;). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992dca0adb9b646b76591cb61fee4cdfffebc9ec" translate="yes" xml:space="preserve">
          <source>A pseudo layer that removes the top-most layer. Gives perl code a way to manipulate the layer stack. Note that &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; only works on real layers and will not undo the effects of pseudo layers like &lt;code&gt;:utf8&lt;/code&gt; . An example of a possible use might be:</source>
          <target state="translated">Псевдослой, удаляющий самый верхний слой. Предоставляет коду Perl способ управления стеком слоев. Обратите внимание, что &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; работает только с реальными слоями и не отменяет эффекты псевдослоев, таких как &lt;code&gt;:utf8&lt;/code&gt; . Примером возможного использования может быть:</target>
        </trans-unit>
        <trans-unit id="e9e574b20ec44e2ea9a82161cd9d396ddf6c16be" translate="yes" xml:space="preserve">
          <source>A pseudo-layer that removes the top-most layer. Gives Perl code a way to manipulate the layer stack. Note that &lt;code&gt;:pop&lt;/code&gt; only works on real layers and will not undo the effects of pseudo-layers or flags like &lt;code&gt;:utf8&lt;/code&gt;. An example of a possible use might be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff419cc31e5dd99b3e00b537155bcea526bbe610" translate="yes" xml:space="preserve">
          <source>A pseudolayer that enables a flag in the layer below to tell Perl that output should be in utf8 and that input should be regarded as already in valid utf8 form. &lt;b&gt;WARNING: It does not check for validity and as such should be handled with extreme caution for input, because security violations can occur with non-shortest UTF-8 encodings, etc.&lt;/b&gt; Generally &lt;code&gt;:encoding(utf8)&lt;/code&gt; is the best option when reading UTF-8 encoded data.</source>
          <target state="translated">Псевдослой, который включает флаг в слое ниже, чтобы сообщить Perl, что вывод должен быть в utf8 и что ввод должен рассматриваться как уже имеющийся в допустимой форме utf8. &lt;b&gt;ПРЕДУПРЕЖДЕНИЕ. Он не проверяет достоверность, поэтому с ним следует обращаться с особой осторожностью при вводе данных, поскольку нарушения безопасности могут возникать при использовании не кратчайших кодировок UTF-8 и т. Д.&lt;/b&gt; Как правило &lt;code&gt;:encoding(utf8)&lt;/code&gt; является лучшим вариантом при чтении UTF- 8 закодированных данных.</target>
        </trans-unit>
        <trans-unit id="c46a1417af942e441ec740293a77160106782547" translate="yes" xml:space="preserve">
          <source>A pseudolayer that manipulates other layers. Applying the &lt;code&gt;:raw&lt;/code&gt; layer is equivalent to calling &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt;. It makes the stream pass each byte as-is without translation. In particular, both CRLF translation and intuiting &lt;code&gt;:utf8&lt;/code&gt; from the locale are disabled.</source>
          <target state="translated">Псевдослой, управляющий другими слоями. Применение слоя &lt;code&gt;:raw&lt;/code&gt; эквивалентно вызову &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; . Это заставляет поток передавать каждый байт как есть без перевода. В частности, отключены как перевод CRLF, так и интуитивное управление &lt;code&gt;:utf8&lt;/code&gt; из локали.</target>
        </trans-unit>
        <trans-unit id="fefe2bbba2d7bf83c98ed3d05237098307bf7f4b" translate="yes" xml:space="preserve">
          <source>A pseudolayer that turns the &lt;code&gt;:utf8&lt;/code&gt; flag</source>
          <target state="translated">Псевдослой, который включает флаг &lt;code&gt;:utf8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecc09e716a2c2d18e2be806f7183c30c2f3b51c2" translate="yes" xml:space="preserve">
          <source>A psychoactive drug, popular in the &amp;rsquo;80s, probably developed at UC Berkeley or thereabouts. Similar in many ways to the prescription-only medication called &amp;ldquo;System V&amp;rdquo;, but infinitely more useful. (Or, at least, more fun.) The full chemical name is &amp;ldquo;Berkeley Standard Distribution&amp;rdquo;.</source>
          <target state="translated">Психоактивный препарат, популярный в 80-х, вероятно, был разработан в Калифорнийском университете в Беркли или около того. Во многом похоже на лекарство, отпускаемое только по рецепту, под названием &amp;laquo;Система V&amp;raquo;, но гораздо более полезно. (Или, по крайней мере, веселее.) Полное химическое название - &amp;laquo;Стандартное распределение Беркли&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b62f9f104139d9b8c4e453ea5b9cd7a8ac0140f4" translate="yes" xml:space="preserve">
          <source>A public function (i.e. part of the internal API, but not necessarily sanctioned for use in extensions) begins like this:</source>
          <target state="translated">Так начинается публичная функция (т.е.часть внутреннего API,но не обязательно санкционированная для использования в расширениях):</target>
        </trans-unit>
        <trans-unit id="1fcfaef1b89a51f30ffb896e8c738cde9ef6077c" translate="yes" xml:space="preserve">
          <source>A pull-parser interface to parsing Pod</source>
          <target state="translated">Вытаскивающий парсерный интерфейс для разбора Pod</target>
        </trans-unit>
        <trans-unit id="ce01020c3704b898a0c0774b915a9978c7a43b90" translate="yes" xml:space="preserve">
          <source>A question mark was chosen for this and for the minimal-matching construct because 1) question marks are rare in older regular expressions, and 2) whenever you see one, you should stop and &quot;question&quot; exactly what is going on. That's psychology....</source>
          <target state="translated">Для этого и для конструкции минимального соответствия был выбран вопросительный знак,потому что 1)вопросительные знаки редки в старых регулярных выражениях,и 2)всякий раз,когда вы их видите,вы должны останавливаться и &quot;задавать вопрос&quot; именно о том,что происходит.Это психология...</target>
        </trans-unit>
        <trans-unit id="7af52ef72c21fce506c2fc73241d0f35d841b4ef" translate="yes" xml:space="preserve">
          <source>A queue is a special thread-safe object that lets you put data in one end and take it out the other without having to worry about synchronization issues. They're pretty straightforward, and look like this:</source>
          <target state="translated">Очередь-это специальный потокобезопасный объект,который позволяет помещать данные в один конец и извлекать их из другого,не беспокоясь о проблемах синхронизации.Они довольно просты и выглядят так:</target>
        </trans-unit>
        <trans-unit id="ce5a6f66f06330588b1d9e78cc960a0c4ce6fd02" translate="yes" xml:space="preserve">
          <source>A quick and dirty fix involves a little bit of code, but this may be all you need to figure out the problem.</source>
          <target state="translated">Быстрое и грязное исправление включает в себя немного кода,но это может быть все,что вам нужно,чтобы разобраться в проблеме.</target>
        </trans-unit>
        <trans-unit id="6e5b863f1eff6fa26a4e90b6efd2628e9a8b1279" translate="yes" xml:space="preserve">
          <source>A quick bit of zip file terminology -- A zip archive consists of one or more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f4c66121a13dbcd4a35fcb46d7559bf401584e" translate="yes" xml:space="preserve">
          <source>A quick fix to the offending line (insert the missing parentheses) in the actual program and we're finished.</source>
          <target state="translated">Быстро исправим ошибку (вставим недостающие скобки)в реальную программу,и мы закончим.</target>
        </trans-unit>
        <trans-unit id="ee22003c9d3f871e01a3bbc57135bc551a023e8c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an &lt;code&gt;sv&lt;/code&gt; should be passed to &lt;code&gt;sv_force_normal&lt;/code&gt; to be &quot;downgraded&quot; before &lt;code&gt;SvIVX&lt;/code&gt; or &lt;code&gt;SvPVX&lt;/code&gt; can be modified directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf25dde2a598596295bb7a94644c4b4622cf06c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an sv should be passed to sv_force_normal to be &quot;downgraded&quot; before SvIVX or SvPVX can be modified directly.</source>
          <target state="translated">Быстрая проверка флага,чтобы понять,следует ли передавать sv в sv_force_normal для &quot;понижения рейтинга&quot; перед тем,как SvIVX или SvPVX могут быть изменены напрямую.</target>
        </trans-unit>
        <trans-unit id="5714e693202d7afa5eda5b56d0aae30074e97131" translate="yes" xml:space="preserve">
          <source>A quick note on terms</source>
          <target state="translated">Краткая справка на условиях</target>
        </trans-unit>
        <trans-unit id="1d94544d51208195a231709cf1963af0c4de7162" translate="yes" xml:space="preserve">
          <source>A race condition exists when the result of several interrelated events depends on the ordering of those events, but that order cannot be guaranteed due to nondeterministic timing effects. If two or more programs, or parts of the same program, try to go through the same series of events, one might interrupt the work of the other. This is a good way to find an &lt;b&gt;exploit&lt;/b&gt;.</source>
          <target state="translated">Состояние гонки возникает, когда результат нескольких взаимосвязанных событий зависит от порядка этих событий, но этот порядок не может быть гарантирован из-за недетерминированных временных эффектов. Если две или более программы или части одной программы попытаются пройти одну и ту же серию событий, одна из них может прервать работу другой. Это хороший способ найти &lt;b&gt;эксплойт&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b4fd04892bbded81531e522d3212286340ec1840" translate="yes" xml:space="preserve">
          <source>A read-write accessor will allow the caller to set the value as well as get it:</source>
          <target state="translated">Ассистент чтения-записи позволит вызывающему абоненту не только установить значение,но и получить его:</target>
        </trans-unit>
        <trans-unit id="caaace35cefc12e27812e75c68a502f8caf0f7cf" translate="yes" xml:space="preserve">
          <source>A recent net or commercial release of Cygwin is required.</source>
          <target state="translated">Требуется недавний сетевой или коммерческий релиз Cygwin.</target>
        </trans-unit>
        <trans-unit id="279e88205b97d17edeab01fe3aebcdc1b843db2f" translate="yes" xml:space="preserve">
          <source>A recent version of perl for the Amiga can be found at the Geek Gadgets section of the Aminet:</source>
          <target state="translated">Последнюю версию perl для Amiga можно найти в разделе Geek Gadgets в Aminet:</target>
        </trans-unit>
        <trans-unit id="091b3fb1a508c2d701cd7e6f7c6e6e5c3add3716" translate="yes" xml:space="preserve">
          <source>A recipe book for programming with CPAN.pm</source>
          <target state="translated">Рецептурная книга для программирования с CPAN.pm</target>
        </trans-unit>
        <trans-unit id="2d7c582850510d1397c7e76f17b16cc5d91e6066" translate="yes" xml:space="preserve">
          <source>A recreational vehicle, not to be confused with vehicular recreation. RV also means an internal Reference Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold. See also &lt;b&gt;IV&lt;/b&gt; and &lt;b&gt;NV&lt;/b&gt; if you&amp;rsquo;re not confused yet.</source>
          <target state="translated">Транспортное средство для отдыха, не путать с автомобильным отдыхом. RV также означает внутреннее эталонное значение того типа, который может содержать &lt;b&gt;скаляр&lt;/b&gt; . См. Также &lt;b&gt;IV&lt;/b&gt; и &lt;b&gt;NV,&lt;/b&gt; если вы еще не запутались.</target>
        </trans-unit>
        <trans-unit id="ad0a627886d7457b4c1bf3b7879c79721531858f" translate="yes" xml:space="preserve">
          <source>A reference can be blessed into a package with the following function:</source>
          <target state="translated">Ссылка может быть благословлена в пакете со следующей функцией:</target>
        </trans-unit>
        <trans-unit id="b9d8f8326d44e724663f7d05cf4610dd9fa3fff9" translate="yes" xml:space="preserve">
          <source>A reference can be created by using a special syntax, lovingly known as the *foo{THING} syntax. *foo{THING} returns a reference to the THING slot in *foo (which is the symbol table entry which holds everything known as foo).</source>
          <target state="translated">Ссылка может быть создана с помощью специального синтаксиса,любовно известного как синтаксис *foo{THING}.*foo{THING}возвращает ссылку на слот THING в *foo (это запись в таблице символов,в которой хранится все,что известно как foo).</target>
        </trans-unit>
        <trans-unit id="aa895f94ce4272825894257bb4b5f46a12e2a648" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value and can refer to any other Perl data type. So by storing a reference as the value of an array or hash element, you can easily create lists and hashes within lists and hashes. The following example shows a 2 level hash of hash structure using anonymous hash references.</source>
          <target state="translated">Ссылка является скалярным значением и может относиться к любому другому типу данных Perl.Таким образом,сохраняя ссылку в качестве значения массива или хэш-элемента,вы можете легко создавать списки и хэши внутри списков и хэшей.В следующем примере показан 2-х уровневый хэш хэш-структуры с использованием анонимных хэш-ссылок.</target>
        </trans-unit>
        <trans-unit id="31756567f0b0edb207ae4b6d556e511492c04f15" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value that</source>
          <target state="translated">Ссылка-это скалярное значение,которое</target>
        </trans-unit>
        <trans-unit id="9246f92f3034b3a452a0afe45331277281745beb" translate="yes" xml:space="preserve">
          <source>A reference that doesn&amp;rsquo;t get counted normally. When all the normal references to data disappear, the data disappears. These are useful for circular references that would never disappear otherwise.</source>
          <target state="translated">Ссылка, которая не считается нормально. Когда все обычные ссылки на данные исчезнут, данные исчезнут. Они полезны для циклических ссылок, которые в противном случае никогда бы не исчезли.</target>
        </trans-unit>
        <trans-unit id="5bbf68c2e549802b044298b09b378b5fd28092c9" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file from which the invoking script's pod documentation should be read. It defaults to the file indicated by &lt;code&gt;$0&lt;/code&gt; (&lt;code&gt;$PROGRAM_NAME&lt;/code&gt; for users of</source>
          <target state="translated">Ссылка на дескриптор файла или путь к файлу, из которого следует читать документацию модуля вызывающего скрипта. По умолчанию используется файл, обозначенный как &lt;code&gt;$0&lt;/code&gt; ( &lt;code&gt;$PROGRAM_NAME&lt;/code&gt; для пользователей</target>
        </trans-unit>
        <trans-unit id="f5b22d93dc114d0a0d964dd5bfa61e077311cb6a" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt; ).</source>
          <target state="translated">Ссылка на дескриптор файла или путь к файлу, в который должно быть записано сообщение об использовании. По умолчанию используется &lt;code&gt;\*STDERR&lt;/code&gt; , если значение выхода не меньше 2 (в этом случае по умолчанию используется &lt;code&gt;\*STDOUT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="980006b576a2cc0a15260aa4e5fea4bbf14c9495" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be21fde0d5a369b6626dd71f37562d95b7a892a" translate="yes" xml:space="preserve">
          <source>A reference to a hash</source>
          <target state="translated">Ссылка на гашиш</target>
        </trans-unit>
        <trans-unit id="caf281724b21daca5b76b0ce26ffdceb6ed5b592" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="translated">Ссылка на хэш правил, которые определяют, какие тесты могут выполняться параллельно. Если правила не объявлены и &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt; доступен, &lt;code&gt;TAP::Harness&lt;/code&gt; пытается загрузить правила из файла YAML, указанного параметром &lt;code&gt;rulesfile&lt;/code&gt; . Если файл правил не существует, по умолчанию все тесты могут выполняться параллельно.</target>
        </trans-unit>
        <trans-unit id="a706802a8a2475d51bc83970dc392f76564c5864" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;CPAN::Meta::YAML&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd42c7f4f6784f49153b357722a869874cd7cab5" translate="yes" xml:space="preserve">
          <source>A reference to a hash of scalar values in scalar context. Each entry of the hash has the fully qualified method name as its key and the method's scalar-context return values as its value.</source>
          <target state="translated">Ссылка на хэш скалярных значений в скалярном контексте.Каждая запись хэша имеет в качестве ключа полностью квалифицированное имя метода,а возвращаемые значения скалярного контекста метода-его значение.</target>
        </trans-unit>
        <trans-unit id="c3a87c12004d018bcf7a69155be997af1914286c" translate="yes" xml:space="preserve">
          <source>A reference to a hash.</source>
          <target state="translated">Ссылка на гашиш.</target>
        </trans-unit>
        <trans-unit id="9c7f4017cfb229c284c5327072ab9da27410d7df" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; . These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="translated">Ссылка на список строк &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; маски в форме &amp;laquo;134.99.4.0/24&amp;raquo; . Они используются функцией &lt;code&gt;requires_firewall&lt;/code&gt; , чтобы определить, находится ли данный хост внутри или за пределами вашего брандмауэра.</target>
        </trans-unit>
        <trans-unit id="55220c7cc22e62cddb006a6a8bf77ab5a2807bb5" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt;. These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ea49a873c1ff374f329e97efef0ff346dccc25" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) the list:</source>
          <target state="translated">Ссылка на список ссылок на подпрограммы и / или объекты qr // и / или литеральные строки и / или хеш-ссылки, определяющие экстракторы, которые будут использоваться для разделения строки. Если этот аргумент опущен (или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) список:</target>
        </trans-unit>
        <trans-unit id="dd1cf33c811e37d20a0f1536729842fe8b28cf07" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;undef&lt;/code&gt;) the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2512ecb6dd2165eaa0de868a807f9b3c24936be1" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;&quot;TODO TESTS&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f47fcb868f1bdb2ed44c13b2967f53238fb92e" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;TODO TESTS&lt;/a&gt;.</source>
          <target state="translated">Ссылка на список тестов, которым разрешено неуспешно. См. &lt;a href=&quot;#TODO-TESTS&quot;&gt;ТЕСТЫ TODO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a16beaf14f9ebf81709ac7687142e7324bffbcbc" translate="yes" xml:space="preserve">
          <source>A reference to a scalar, containing any initial source code to prepend to the file or generator output.</source>
          <target state="translated">Ссылка на скаляр,содержащий любой исходный код для подготовки к выводу файла или генератора.</target>
        </trans-unit>
        <trans-unit id="ca57032a4acbb0f04dd265f2403ba03843451cb5" translate="yes" xml:space="preserve">
          <source>A reference to a simple scalar</source>
          <target state="translated">Ссылка на простой скаляр</target>
        </trans-unit>
        <trans-unit id="2f7717bc46f8882825267f8fb5ae31ad534d8604" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine</source>
          <target state="translated">Ссылка на подпрограмму</target>
        </trans-unit>
        <trans-unit id="13ea76e1a2a772c23eb3e3af45f4e6c39d604a09" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. Again, return 1 for each valid line, and 0 after all lines have been returned. For historical reasons the subroutine will receive a meaningless argument (in fact always the numeric value zero) as &lt;code&gt;$_[0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60540604d1e514c1059c3b516595d77c9c95f5f" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;code&gt;$_&lt;/code&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;code&gt;$_&lt;/code&gt; . Again, return 1 for each valid line, and 0 after all lines have been returned.</source>
          <target state="translated">Ссылка на подпрограмму. Если нет дескриптора файла (предыдущий элемент), то ожидается, что эта подпрограмма будет генерировать одну строку исходного кода за вызов, записывая строку в &lt;code&gt;$_&lt;/code&gt; и возвращая 1, а затем, наконец, в конце файла возвращая 0. Если есть дескриптор файла, тогда будет вызвана подпрограмма, которая будет действовать как простой исходный фильтр, со строкой, прочитанной в &lt;code&gt;$_&lt;/code&gt; . Опять же, возвращайте 1 для каждой допустимой строки и 0 после того, как были возвращены все строки.</target>
        </trans-unit>
        <trans-unit id="69d2c7af1b1feb58183b6cd3ab9665d62ba3318e" translate="yes" xml:space="preserve">
          <source>A reference to an &lt;code&gt;@INC&lt;/code&gt; style array of arguments to be passed to each test program.</source>
          <target state="translated">Ссылка на массив аргументов в стиле &lt;code&gt;@INC&lt;/code&gt; , передаваемый каждой тестовой программе.</target>
        </trans-unit>
        <trans-unit id="c036eaf04cdd3c79b7e1454ebb2a945c2a1cd7fe" translate="yes" xml:space="preserve">
          <source>A reference to an SV which holds a C pointer</source>
          <target state="translated">Ссылка на SV,у которого есть указатель на С.</target>
        </trans-unit>
        <trans-unit id="23549f2151bb51628d2f58bbcf1156a64c3296ce" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous array can be created using square brackets:</source>
          <target state="translated">Ссылка на анонимный массив может быть создана с помощью квадратных скобок:</target>
        </trans-unit>
        <trans-unit id="227fa37704dcf65c895f6b48accf114132dd71b4" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous hash can be created using curly brackets:</source>
          <target state="translated">Ссылка на анонимный хэш может быть создана с помощью фигурных скобок:</target>
        </trans-unit>
        <trans-unit id="75f71bb1e5a64ddcdb9e050cbea388199a1108b3" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; without a subname:</source>
          <target state="translated">Ссылку на анонимную подпрограмму можно создать, используя &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; без имени:</target>
        </trans-unit>
        <trans-unit id="c2b28a0f04f7d25df0ba15127b6c78099a8d8001" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;sub&lt;/code&gt; without a subname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1d9fe90cb9aed401ad78a9cb46511d34021ee8" translate="yes" xml:space="preserve">
          <source>A reference to an array</source>
          <target state="translated">Ссылка на массив</target>
        </trans-unit>
        <trans-unit id="e31779df8d209b3542cc04e2be4c9b32f5d08f2c" translate="yes" xml:space="preserve">
          <source>A reference to an array of sections specifications (as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;) which indicate the desired set of POD sections and subsections to be selected from input. If no section specifications are given, then all sections of the PODs are used.</source>
          <target state="translated">Ссылка на массив спецификаций разделов (как описано в &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;СПЕЦИФИКАЦИЯХ РАЗДЕЛА&lt;/a&gt; ), которые указывают желаемый набор разделов и подразделов POD, которые следует выбрать из входных данных. Если спецификации секций не указаны, используются все секции POD.</target>
        </trans-unit>
        <trans-unit id="c89226f4c3258d3bce7e696eba292fd5daa132bc" translate="yes" xml:space="preserve">
          <source>A reference to the object for a virtual method or the name of the class for a static method</source>
          <target state="translated">Ссылка на объект для виртуального метода или имя класса для статического метода</target>
        </trans-unit>
        <trans-unit id="21f30d908543711c9f728d7de0ea1261250a9055" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; . This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="translated">Регресс в AIX 7 вызывает сбой при выполнении теста make в Time :: Piece при переходе на летнее время. APAR IV16514 предоставляет исправление для этого. Быстрый тест , чтобы увидеть , если это требуется, при условии , что в настоящее время в летнее по восточному времени, было бы запустить &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; . Обычно это возвращается с &lt;code&gt;EST&lt;/code&gt; , но ничего, если у вас есть проблема.</target>
        </trans-unit>
        <trans-unit id="f9c19d164e4eea1cf98cc917d39776c748efd08d" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt;. This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc4dbf2e586369f7ce889ec848c85dffcc1c599" translate="yes" xml:space="preserve">
          <source>A regular expression engine is a program that takes a set of constraints specified in a mini-language, and then applies those constraints to a target string, and determines whether or not the string satisfies the constraints. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for a full definition of the language.</source>
          <target state="translated">Механизм регулярных выражений - это программа, которая принимает набор ограничений, указанных на мини-языке, а затем применяет эти ограничения к целевой строке и определяет, удовлетворяет ли строка ограничениям. См. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; для полного определения языка.</target>
        </trans-unit>
        <trans-unit id="898d96d1a86448c10c01fff6d7c680ca19e7f093" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo =~ EXPR&lt;/code&gt; . Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo !~ EXPR&lt;/code&gt; .</source>
          <target state="translated">Соответствие регулярному выражению в форме &lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; или &lt;code&gt;$foo =~ EXPR&lt;/code&gt; . Кроме того, совпадение с отрицательным регулярным выражением в форме &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; или &lt;code&gt;$foo !~ EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01f7272df9cfce47663749712543393fb8ccb06b" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt;, &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt;, or &lt;code&gt;$foo =~ EXPR&lt;/code&gt;. Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt;, &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt;, or &lt;code&gt;$foo !~ EXPR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b61a0c27a77da1e69f8478b8fd9175ff4c338f9" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt; . Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="translated">Регулярное выражение, которое в противном случае компилируется с использованием правил &lt;code&gt;/d&lt;/code&gt; и которое использует эту конструкцию, вместо этого будет использовать &lt;code&gt;/u&lt;/code&gt; . Таким образом, эта конструкция сообщает Perl, что вам не нужны правила &lt;code&gt;/d&lt;/code&gt; для всего содержащего ее регулярного выражения.</target>
        </trans-unit>
        <trans-unit id="3b6937e0ce314d5ad6696b2c87b4dd9e05cd8786" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt;. Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8052f2558ed14ca1695f0756ea843781532061f7" translate="yes" xml:space="preserve">
          <source>A related issue is thread-safety. When a new thread is created, the Perl interpreter is cloned, which implies that all reference addresses in use will be replaced with new ones. Thus, if a class tries to access a field of a cloned object its (cloned) data will still be stored under the now invalid reference address of the original in the parent thread. A general &lt;code&gt;CLONE&lt;/code&gt; method must be provided to re-establish the association.</source>
          <target state="translated">Связанная проблема - безопасность потоков. Когда создается новый поток, интерпретатор Perl клонируется, что означает, что все используемые ссылочные адреса будут заменены новыми. Таким образом, если класс пытается получить доступ к полю клонированного объекта, его (клонированные) данные все равно будут храниться под теперь недопустимым адресом ссылки оригинала в родительском потоке. Для восстановления связи необходимо предоставить общий метод &lt;code&gt;CLONE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5a4d830992a6346407400c2bf4e88b4a6e3e575" translate="yes" xml:space="preserve">
          <source>A related issue is use with perl's malloc. Perl's malloc uses &lt;code&gt;sbrk()&lt;/code&gt; to get memory, and &lt;code&gt;sbrk()&lt;/code&gt; is limited to the first allocation so in this case something like:</source>
          <target state="translated">Связанная проблема - использование perl malloc. Perl malloc использует &lt;code&gt;sbrk()&lt;/code&gt; для получения памяти, а &lt;code&gt;sbrk()&lt;/code&gt; ограничивается первым выделением, поэтому в этом случае что-то вроде:</target>
        </trans-unit>
        <trans-unit id="773c247356b687b3912aff9a0cf7c1a25f2fade5" translate="yes" xml:space="preserve">
          <source>A related strategy that's less open to forgery is to give them a PIN (personal ID number). Record the address and PIN (best that it be a random one) for later processing. In the mail you send, include a link to your site with the PIN included. If the mail bounces, you know it's not valid. If they don't click on the link, either they forged the address or (assuming they got the message) following through wasn't important so you don't need to worry about it.</source>
          <target state="translated">Связанная с этим стратегия,менее открытая для подделки,заключается в том,чтобы дать им PIN-код (персональный идентификационный номер).Запишите адрес и PIN-код (лучше всего,чтобы он был случайным)для последующей обработки.В письме,которое вы отправите,укажите ссылку на ваш сайт с PIN-кодом.Если почта откажет,вы знаете,что она недействительна.Если они не нажимают на ссылку,то либо подделывают адрес,либо (предполагая,что они получили сообщение)отслеживание не важно,поэтому вам не нужно беспокоиться об этом.</target>
        </trans-unit>
        <trans-unit id="1b0e6d749250f42dda0dbf4bdf376cdb3adb5626" translate="yes" xml:space="preserve">
          <source>A relationship between two &lt;b&gt;objects&lt;/b&gt; in which one object is considered to be a more specific version of the other, generic object: &amp;ldquo;A camel is a mammal.&amp;rdquo; Since the generic object really only exists in a Platonic sense, we usually add a little abstraction to the notion of objects and think of the relationship as being between a generic &lt;b&gt;base class&lt;/b&gt; and a specific &lt;b&gt;derived class&lt;/b&gt;. Oddly enough, Platonic classes don&amp;rsquo;t always have Platonic relationships&amp;mdash;see &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">Отношения между двумя &lt;b&gt;объектами,&lt;/b&gt; в которых один объект считается более конкретной версией другого, универсального объекта: &amp;laquo;Верблюд - это млекопитающее&amp;raquo;. Поскольку универсальный объект действительно существует только в платоническом смысле, мы обычно добавляем небольшую абстракцию к понятию объектов и думаем об отношениях как о взаимосвязи между универсальным &lt;b&gt;базовым классом&lt;/b&gt; и конкретным &lt;b&gt;производным классом&lt;/b&gt; . Как ни странно, платонические классы не всегда имеют платонические отношения - см. &lt;b&gt;Наследование&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc57b74bcbf78eacbd6b02d09950f83d1e82c98" translate="yes" xml:space="preserve">
          <source>A relatively new conference franchise with a large Perl portion is the Open Source Developers Conference or OSDC. First held in Australia it has recently also spread to Israel and France. More information can be found at: &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt; for Australia, &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt; for Israel, and &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt; for France.</source>
          <target state="translated">Относительно новая серия конференций с большой долей Perl - это Open Source Developers Conference или OSDC. Впервые проведенный в Австралии, недавно он распространился также на Израиль и Францию. Дополнительную информацию можно найти по адресу: &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt; для Австралии, &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt; для Израиля и &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt; для Франции.</target>
        </trans-unit>
        <trans-unit id="125bb83bd0e2557d465d8cae2a201d255865cfc8" translate="yes" xml:space="preserve">
          <source>A relatively recent addition to socket functions, may not be implemented even in Unix platforms.</source>
          <target state="translated">Относительно недавнее дополнение к функциям сокета,может быть не реализовано даже на Unix-платформах.</target>
        </trans-unit>
        <trans-unit id="0fb2c7925dc01622384910beb32c259581a32e6c" translate="yes" xml:space="preserve">
          <source>A remark that doesn&amp;rsquo;t affect the meaning of the program. In Perl, a comment is introduced by a &lt;code&gt;#&lt;/code&gt; character and continues to the end of the line.</source>
          <target state="translated">Замечание, не влияющее на смысл программы. В Perl комментарий начинается с символа &lt;code&gt;#&lt;/code&gt; и продолжается до конца строки.</target>
        </trans-unit>
        <trans-unit id="05ceaec7b64c7ce9cdeec60b39e51b96ddb09fbd" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="translated">Счетчик повторов после &lt;code&gt;u&lt;/code&gt; устанавливает количество байтов, помещаемых в строку с кодировкой uu, которое по умолчанию составляет максимум 45, но может быть установлено в некоторое (меньшее) целое число, кратное трем. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; просто игнорирует счетчик повторов.</target>
        </trans-unit>
        <trans-unit id="39e5a93524da5ebc880d6f2d48ae7f4158fdf997" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;unpack&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a53eb20270176512fa5bd8bf4b4f1be0776d385" translate="yes" xml:space="preserve">
          <source>A return code of 1 means that the requested key was not in the database.</source>
          <target state="translated">Код возврата 1 означает,что запрашиваемого ключа не было в базе данных.</target>
        </trans-unit>
        <trans-unit id="ed4d8a6dc7b98d70bce7c0cb5069c17fe03ce939" translate="yes" xml:space="preserve">
          <source>A rudimentary command-line completion is also available, including lexical variables in the current scope if the &lt;code&gt;PadWalker&lt;/code&gt; module is installed.</source>
          <target state="translated">Также доступно элементарное завершение командной строки, включая лексические переменные в текущей области, если &lt;code&gt;PadWalker&lt;/code&gt; модуль PadWalker .</target>
        </trans-unit>
        <trans-unit id="195465d41845715cc8feeb944d84d82eca7db90c" translate="yes" xml:space="preserve">
          <source>A safe filename for the package.</source>
          <target state="translated">Безопасное имя для упаковки.</target>
        </trans-unit>
        <trans-unit id="e965283a692e93e5f3c352fa50ba572d5ad94533" translate="yes" xml:space="preserve">
          <source>A sample Configure invocation looks something like this:</source>
          <target state="translated">Образец Призыв к настройке выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="c38c9f9afa364c973ff5615c1cc8f4fc08593cdb" translate="yes" xml:space="preserve">
          <source>A sanitized VERSION with . replaced by _. For places where . has special meaning (some filesystems, RCS labels, etc...)</source>
          <target state="translated">Дезинфицированная ВЕРСИЯ с ...заменена на _...Для мест,где.имеет особое значение (некоторые файловые системы,RCS метки и т.д...).</target>
        </trans-unit>
        <trans-unit id="854d2d0c342e6a9cd9c52af8350f79c5b69ee115" translate="yes" xml:space="preserve">
          <source>A sanity check is done to ensure that the versions of the</source>
          <target state="translated">Проверка на вменяемость проводится для того,чтобы убедиться,что версии</target>
        </trans-unit>
        <trans-unit id="52b0650d241bfe8b8773b0c925166a2b232578a5" translate="yes" xml:space="preserve">
          <source>A sanity check that what Perl thinks the architecture is and what Config thinks the architecture is are the same. If they're not it will return false and show a diagnostic message.</source>
          <target state="translated">Проверка здравого смысла заключается в том,что то,что Perl думает об архитектуре,и то,что Config думает об архитектуре,одинаково.Если это не так,то она вернет false и выдаст диагностическое сообщение.</target>
        </trans-unit>
        <trans-unit id="a5df5a5c29d978bd67d46cf69079761e359c23a8" translate="yes" xml:space="preserve">
          <source>A scalar reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb257f5c15cd87da91e7109e5621a0b92dd55a" translate="yes" xml:space="preserve">
          <source>A scalar represents a single value:</source>
          <target state="translated">Скаляр представляет собой единственное значение:</target>
        </trans-unit>
        <trans-unit id="63bf2744d770c46d6894e17a03796eb6868d8317" translate="yes" xml:space="preserve">
          <source>A scalar that is going to be passed to some extension</source>
          <target state="translated">Скаляр,который будет передан в какое-то расширение.</target>
        </trans-unit>
        <trans-unit id="b892a705ca325c138b52905f099e8858ffbdfac0" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed.</source>
          <target state="translated">Скалярное значение интерпретируется как FALSE в булевом смысле,если оно неопределено,нулевая строка или число 0 (или его строковый эквивалент,&quot;0&quot;),и TRUE,если это что-то другое.Булевский контекст-это просто специальный вид скалярного контекста,в котором никогда не выполняется преобразование в строку или число.</target>
        </trans-unit>
        <trans-unit id="751493f8cb7ec6843259111a93c03239b2cd2168" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt;, but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf273fc6dfd9742bd76d45138d207f0b0c7c11c" translate="yes" xml:space="preserve">
          <source>A scalar we got back from an extension</source>
          <target state="translated">Скаляр,который мы получили из пристройки</target>
        </trans-unit>
        <trans-unit id="7153eab5e3c20636ca530d5dc26c52e39ac43559" translate="yes" xml:space="preserve">
          <source>A scratchpad keeps SVs which are lexicals for the current unit and are targets for opcodes. A previous version of this document stated that one can deduce that an SV lives on a scratchpad by looking on its flags: lexicals have &lt;code&gt;SVs_PADMY&lt;/code&gt; set, and</source>
          <target state="translated">Блокнот хранит SV, которые являются лексическими для текущего модуля и являются целями для кодов операций. В предыдущей версии этого документа говорилось, что можно сделать вывод о том, что SV живет в блокноте, посмотрев на его флаги: в лексических &lt;code&gt;SVs_PADMY&lt;/code&gt; установлен SVs_PADMY , и</target>
        </trans-unit>
        <trans-unit id="9b4b51a187f878ac1e93c009ee393256c5f3fed7" translate="yes" xml:space="preserve">
          <source>A script called &quot;runperl.bat&quot; is available that can be copied to any filename (along with the .bat suffix). For example, if you call it &quot;foo.bat&quot;, it will run the file &quot;foo&quot; when it is executed. Since you can run batch files on Windows platforms simply by typing the name (without the extension), this effectively runs the file &quot;foo&quot;, when you type either &quot;foo&quot; or &quot;foo.bat&quot;. With this method, &quot;foo.bat&quot; can even be in a different location than the file &quot;foo&quot;, as long as &quot;foo&quot; is available somewhere on the PATH. If your scripts are on a filesystem that allows symbolic links, you can even avoid copying &quot;runperl.bat&quot;.</source>
          <target state="translated">Доступен скрипт под названием &quot;runperl.bat&quot;,который может быть скопирован в любое имя файла (вместе с суффиксом .bat).Например,если вы назовёте его &quot;foo.bat&quot;,то при его выполнении будет запущен файл &quot;foo&quot;.Так как вы можете запускать пакетные файлы на Windows платформах,просто набирая имя (без расширения),это эффективно запустит файл &quot;foo&quot;,когда вы наберете либо &quot;foo&quot;,либо &quot;foo.bat&quot;.С помощью этого метода,&quot;foo.bat&quot; может даже находиться в другом месте,чем файл &quot;foo&quot;,при условии,что &quot;foo&quot; доступен где-нибудь в PATH.Если ваши скрипты находятся в файловой системе,допускающей символические ссылки,вы можете даже избежать копирования &quot;runperl.bat&quot;.</target>
        </trans-unit>
        <trans-unit id="8a0dd42d0c5f72d1648c67ceada410b1cd803819" translate="yes" xml:space="preserve">
          <source>A script run is basically a sequence of characters, all from the same Unicode script (see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;), such as Latin or Greek. In most places a single word would never be written in multiple scripts, unless it is a spoofing attack. An infamous example, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e410531e148f9094643156d14e90843980c3dfe" translate="yes" xml:space="preserve">
          <source>A script that emulates the standard unix archive (aka library) utility. Under Watcom 10.6, ar is linked to wlib and provides the expected interface. With Watcom 9.5, a cover function is required. This one is fairly crude but has proved adequate for compiling perl.</source>
          <target state="translated">Скрипт,эмулирующий стандартную утилиту unix-архива (так называемую библиотеку).В Watcom 10.6,ar связан с wlib и предоставляет ожидаемый интерфейс.В Watcom 9.5 требуется функция обложки.Эта довольно грубая,но оказалась адекватной для компиляции perl.</target>
        </trans-unit>
        <trans-unit id="e8eda0c28ba2fe483ef84daa3f54b909c119dec0" translate="yes" xml:space="preserve">
          <source>A script that provides C preprocessing functionality. Configure can generate a similar cover, but it doesn't handle all the command-line options that perl throws at it. This might be reasonably placed in /usr/local/bin.</source>
          <target state="translated">Скрипт,обеспечивающий функциональность препроцессирования на C.Конфигурация может генерировать похожую обложку,но она не обрабатывает все опции командной строки,которые бросает в него perl.Это может быть разумно помещено в /usr/local/bin.</target>
        </trans-unit>
        <trans-unit id="f63efe767441f9b6cae7b2dee9e50e81364ad873" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="translated">Архив списка с возможностью поиска доступен по адресу &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt; . Также есть архив по адресу &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="752d32391bfcd52e9f67370c3e3b59a46e33094d" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;https://markmail.org/search/?q=perl5-porters&quot;&gt;https://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;https://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;https://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1598e0f0cd8f36f911067e3fef88a3cdc16b3aed" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt; &quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt; &quot; in perlsyn.</source>
          <target state="translated">Раздел начинается с названного заголовка или элемента. Например, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; Или &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; Оба ссылаются на раздел, который начинается с &quot; &lt;code&gt;=item $.&lt;/code&gt; &quot; В perlvar. И &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; и &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; оба ссылаются на раздел, который начинается с &quot; &lt;code&gt;=head2 For Loops&lt;/code&gt; &quot; в perlsyn.</target>
        </trans-unit>
        <trans-unit id="50daaeb1a2fab8aef823f07b1ef237ef7fd7c501" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt;&quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt;&quot; in perlsyn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd968f32a9ca757550679bcb38ba91ae56c38c6" translate="yes" xml:space="preserve">
          <source>A selection of any number of &lt;b&gt;elements&lt;/b&gt; from a &lt;b&gt;list&lt;/b&gt;, &lt;b&gt;array&lt;/b&gt;, or &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">Выбор любого количества &lt;b&gt;элементов&lt;/b&gt; из &lt;b&gt;списка&lt;/b&gt; , &lt;b&gt;массива&lt;/b&gt; или &lt;b&gt;хэша&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c8bb7e9a293c6c000ed25150f0f4d86b8b09ae48" translate="yes" xml:space="preserve">
          <source>A selection of general-utility hash subroutines</source>
          <target state="translated">Подборка общеполезных гашишных подпрограмм</target>
        </trans-unit>
        <trans-unit id="7f015133979033409d91eedccc2323e573bc6368" translate="yes" xml:space="preserve">
          <source>A selection of general-utility list subroutines</source>
          <target state="translated">Выбор подпрограмм общего списка полезности</target>
        </trans-unit>
        <trans-unit id="28d3d211918b04ba8766082d56a39fef4fdf3700" translate="yes" xml:space="preserve">
          <source>A selection of general-utility scalar subroutines</source>
          <target state="translated">Подборка скалярных подпрограмм общего назначения</target>
        </trans-unit>
        <trans-unit id="6c2a22b80753e149c4a3e936da6e37252cc4db3f" translate="yes" xml:space="preserve">
          <source>A selection of utility subroutines for subs and CODE references</source>
          <target state="translated">Выбор подпрограмм для подпрограмм и кодовых ссылок</target>
        </trans-unit>
        <trans-unit id="047fc7c9d2dc1ac28d49429eb7bc7a3322abc4af" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt; ) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , which gobble up everything else.</source>
          <target state="translated">Точка с запятой ( &lt;code&gt;;&lt;/code&gt; ) отделяет обязательные аргументы от необязательных аргументов. Он является избыточным перед &lt;code&gt;@&lt;/code&gt; или &lt;code&gt;%&lt;/code&gt; , который поглощает все остальное.</target>
        </trans-unit>
        <trans-unit id="fcc144c5cd365b46474f5e986e9bf1d79c5d34db" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt;) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, which gobble up everything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f511bb1ccbd67c6c6ca9d2e6f48560176d03c2b5" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;b&gt;bits&lt;/b&gt; that is actually being thought of as a sequence of bits, for once.</source>
          <target state="translated">Последовательность &lt;b&gt;битов,&lt;/b&gt; которая фактически рассматривается как последовательность битов, на этот раз.</target>
        </trans-unit>
        <trans-unit id="cae9f6dde987a755ec3121175496d8328940bd06" translate="yes" xml:space="preserve">
          <source>A sequence of characters such as &amp;ldquo;He said !@#*&amp;amp;%@#*?!&amp;rdquo;. A string does not have to be entirely printable.</source>
          <target state="translated">Последовательность символов, например &amp;laquo;Он сказал! @ # * &amp;amp;% @ # * ?!&amp;raquo;. Строка не обязательно должна быть полностью печатаемой.</target>
        </trans-unit>
        <trans-unit id="2d1e5cc5993ad4e16630359feaa4c2a48e6f7df3" translate="yes" xml:space="preserve">
          <source>A sequence of digits is an unsigned decimal literal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0733fdb6bad90c8e5cff763f33aac838dc3a41" translate="yes" xml:space="preserve">
          <source>A sequence of relational operators, such as &lt;code&gt;&quot;$x &amp;lt; $y &amp;lt;= $z&quot;&lt;/code&gt;, performs chained comparisons, in the manner described above in the section &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;Operator Precedence and Associativity&quot;&lt;/a&gt;. Beware that they do not chain with equality operators, which have lower precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8a71fa4ea97586fb33bedb544c35984db92bc7" translate="yes" xml:space="preserve">
          <source>A sequence of the above equality operators, such as &lt;code&gt;&quot;$x == $y == $z&quot;&lt;/code&gt;, performs chained comparisons, in the manner described above in the section &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;Operator Precedence and Associativity&quot;&lt;/a&gt;. Beware that they do not chain with relational operators, which have higher precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec7ee11f629dd8914f5fb3939fa45a8d0ac8f26" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt; , that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="translated">Последовательность, например &lt;code&gt;=head1&lt;/code&gt; , обозначающая начало раздела &lt;b&gt;модуля&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b626bb1acba7e95f123c1e8cb0f3ca8665a27861" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt;, that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615050343b7872b60001479c7e1e5357ce76b3e7" translate="yes" xml:space="preserve">
          <source>A series of &lt;b&gt;processes&lt;/b&gt; all in a row, linked by &lt;b&gt;pipes&lt;/b&gt;, where each passes its output stream to the next.</source>
          <target state="translated">Последовательность &lt;b&gt;процессов&lt;/b&gt; , связанных между собой &lt;b&gt;конвейерами&lt;/b&gt; , каждый из которых передает свой выходной поток следующему.</target>
        </trans-unit>
        <trans-unit id="5e7b6708245b79eaeed5d38bcac016afddbd6e09" translate="yes" xml:space="preserve">
          <source>A series of characters matches that series of characters in the target string, so the pattern &lt;code&gt;blurfl&lt;/code&gt; would match &quot;blurfl&quot; in the target string.</source>
          <target state="translated">Серия символов соответствует этой серии символов в целевой строке, поэтому шаблон &lt;code&gt;blurfl&lt;/code&gt; будет соответствовать &amp;laquo;blurfl&amp;raquo; в целевой строке.</target>
        </trans-unit>
        <trans-unit id="cb6d59d3792163250639b9090bf480c17ab2f55e" translate="yes" xml:space="preserve">
          <source>A set of &lt;b&gt;directories&lt;/b&gt; and &lt;b&gt;files&lt;/b&gt; residing on a partition of the disk. Sometimes known as a &amp;ldquo;partition&amp;rdquo;. You can change the file&amp;rsquo;s name or even move a file around from directory to directory within a filesystem without actually moving the file itself, at least under Unix.</source>
          <target state="translated">Набор &lt;b&gt;каталогов&lt;/b&gt; и &lt;b&gt;файлов,&lt;/b&gt; находящихся на разделе диска. Иногда называется &amp;laquo;перегородкой&amp;raquo;. Вы можете изменить имя файла или даже переместить файл из каталога в каталог в файловой системе, фактически не перемещая сам файл, по крайней мере, в Unix.</target>
        </trans-unit>
        <trans-unit id="a5ce6ae6f62d942a0f2702d5475445785e80396f" translate="yes" xml:space="preserve">
          <source>A set of criteria used to validate a particular piece of data if it has to adhere to particular rules.</source>
          <target state="translated">Набор критериев,используемых для подтверждения достоверности определенной части данных,если она должна придерживаться определенных правил.</target>
        </trans-unit>
        <trans-unit id="abcc0ff1d11111cc38f19c5047e331b6ce4f3ede" translate="yes" xml:space="preserve">
          <source>A set of distribution prerequisites by phase and type</source>
          <target state="translated">Набор предварительных условий распределения по фазам и типам</target>
        </trans-unit>
        <trans-unit id="2054435ebeb82c104e8cc6baf030893f06d8bca6" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt; , which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt; -like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt; , which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; , and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="translated">Набор макросов делает доступ к полям более простым и последовательным. К ним относятся &lt;code&gt;OP()&lt;/code&gt; , который используется для определения типа структуры, &lt;code&gt;regnode&lt;/code&gt; ; &lt;code&gt;NEXT_OFF()&lt;/code&gt; , который является смещением к следующему узлу (подробнее об этом позже); &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; и эквиваленты для чтения и установки аргументов; и &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; и &lt;code&gt;OPERAND()&lt;/code&gt; для управления строками и типами подшипников regop.</target>
        </trans-unit>
        <trans-unit id="405ee0a4d5617474f5f68f2671ed8caabd78eb2a" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt;, which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt;-like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt;, which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt;, &lt;code&gt;ARG1()&lt;/code&gt;, &lt;code&gt;ARG2()&lt;/code&gt;, &lt;code&gt;ARG_SET()&lt;/code&gt;, and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt;, &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b89ed012267a41a30013b79a6117c49ce7fdacf" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; . Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="translated">Набор возможных значений вместе со всеми операциями, которые знают, как работать с этими значениями. Например, числовой тип данных имеет определенный набор чисел, с которыми вы можете работать, а также различные математические операции, которые вы можете выполнять с числами, но не будет иметь большого смысла, скажем, для строки, такой как &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; . Строки имеют свои собственные операции, такие как &lt;b&gt;конкатенация&lt;/b&gt; . Составные типы, состоящие из множества более мелких частей, обычно имеют операции по их составлению и разложению и, возможно, по их перегруппировке. &lt;b&gt;Объекты&lt;/b&gt; , моделирующие вещи в реальном мире, часто имеют операции, соответствующие реальной деятельности. Например, если вы моделируете лифт, у вашего объекта лифта может быть &lt;b&gt;метод &lt;/b&gt; &lt;code&gt;open_door&lt;/code&gt; .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="46aa5c9b6882b1651ea253eff267521cde51f269" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt;. Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af57cf3203f1cd3e2de0a1965dff9d274c21ca2b" translate="yes" xml:space="preserve">
          <source>A set of related data values in a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;stream&lt;/b&gt;, often associated with a unique &lt;b&gt;key&lt;/b&gt; field. In Unix, often commensurate with a &lt;b&gt;line&lt;/b&gt;, or a blank-line&amp;ndash;terminated set of lines (a &amp;ldquo;paragraph&amp;rdquo;). Each line of the</source>
          <target state="translated">Набор связанных значений данных в &lt;b&gt;файле&lt;/b&gt; или &lt;b&gt;потоке&lt;/b&gt; , часто связанных с уникальным &lt;b&gt;ключевым&lt;/b&gt; полем. В Unix, часто соразмерно &lt;b&gt;строке&lt;/b&gt; или завершающемуся пустой строкой набору строк (&amp;laquo;абзацу&amp;raquo;). Каждая строка</target>
        </trans-unit>
        <trans-unit id="1e3ce769bdcb624305623c0e39fad86b6550d415" translate="yes" xml:space="preserve">
          <source>A set of users of which you are a member. In some operating systems (like Unix), you can give certain file access permissions to other members of your group.</source>
          <target state="translated">Набор пользователей,членом которого вы являетесь.В некоторых операционных системах (например,Unix)Вы можете дать определенные права доступа к файлам другим членам Вашей группы.</target>
        </trans-unit>
        <trans-unit id="a3f080c404572d6a66e864a2fec8d37666d88fa5" translate="yes" xml:space="preserve">
          <source>A set of version requirements for a CPAN dist</source>
          <target state="translated">Набор требований к версии для дистрибутива CPAN</target>
        </trans-unit>
        <trans-unit id="a023ae4922155fc45ad5e15036082f2112e5376d" translate="yes" xml:space="preserve">
          <source>A seven-bit safe (non-eight-bit) encoding, which is useful if the transport or storage is not eight-bit safe. Defined by RFC 2152.</source>
          <target state="translated">Семиразрядное безопасное (не восьмиразрядное)кодирование,которое полезно,если транспортировка или хранение не является восьмиразрядным.Определяется RFC 2152.</target>
        </trans-unit>
        <trans-unit id="a600cb53b0fe3c2106640728c33066b8be46fd29" translate="yes" xml:space="preserve">
          <source>A short description of the function of the op.</source>
          <target state="translated">Краткое описание функции операции.</target>
        </trans-unit>
        <trans-unit id="d96648e3b3628e3e472e306b3dd3028622349739" translate="yes" xml:space="preserve">
          <source>A short description of your module, what it does, why someone would use it and its limitations. CPAN automatically pulls your README file out of the archive and makes it available to CPAN users, it is the first thing they will read to decide if your module is right for them.</source>
          <target state="translated">Краткое описание вашего модуля,что он делает,зачем кому-то его использовать и его ограничения.CPAN автоматически вытаскивает ваш README файл из архива и делает его доступным для пользователей CPAN,это первое,что они прочтут,чтобы решить,подходит ли им ваш модуль.</target>
        </trans-unit>
        <trans-unit id="3eb927617c6b6dee09c1f05661af50c2789df3ce" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7054451d8531a19f5986333d608566f0e421b059" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">Краткое название вашей работы. Это будет включено в некоторых сообщениях об ошибках, а также будет возвращено в &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; по &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; модуль, так что он появится на выходе модуля как &lt;a href=&quot;b/concise&quot;&gt;B :: лаконичным&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="659172f97956f35000461e8175c3ae20d404aec4" translate="yes" xml:space="preserve">
          <source>A short usage summary for programs and functions. This section is mandatory for section 3 pages. For Perl module documentation, it's usually convenient to have the contents of this section be a verbatim block showing some (brief) examples of typical ways the module is used.</source>
          <target state="translated">Краткий обзор использования программ и функций.Этот раздел является обязательным для заполнения на 3-х страницах.Для документации по модулю Perl,как правило,удобно,чтобы содержимое этого раздела представляло собой стенографический блок,показывающий некоторые (краткие)примеры типичных способов использования модуля.</target>
        </trans-unit>
        <trans-unit id="ecd576fa5b368299ace3b5dd153caef33335850b" translate="yes" xml:space="preserve">
          <source>A shortcut for $token-&amp;gt;tagname(...)</source>
          <target state="translated">Ярлык для $ token-&amp;gt; tagname (...)</target>
        </trans-unit>
        <trans-unit id="889d9060f1528398717f26dcafe44f09ac88a287" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;binf(). Useful because Perl does not always handle bareword &lt;code&gt;inf&lt;/code&gt; properly.</source>
          <target state="translated">Ярлык для возврата Math :: BigInt-&amp;gt; binf (). Полезно, потому что Perl не всегда правильно обрабатывает голые слова &lt;code&gt;inf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c597d44b686300cfd664e15765135328081ac79a" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;bnan(). Useful because Perl does not always handle bareword &lt;code&gt;NaN&lt;/code&gt; properly.</source>
          <target state="translated">Ярлык для возврата Math :: BigInt-&amp;gt; bnan (). Полезно, потому что Perl не всегда правильно обрабатывает пустое слово &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="588514bdb3ad44f23f4111f5dfe923f166cc27ed" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;a href=&quot;perlop#Equality-Operators&quot;&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/a&gt; to see if two references refer to the same thing. (But you should usually use &lt;a href=&quot;perlop#Equality-Operators&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; instead because it's much faster.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2bf7bb028dd860429a797ea74f61d6f6006cc5" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;code&gt;eq&lt;/code&gt; to see if two references refer to the same thing. (But you should usually use &lt;code&gt;==&lt;/code&gt; instead because it's much faster.)</source>
          <target state="translated">Побочным эффектом этого представления является то, что вы можете использовать &lt;code&gt;eq&lt;/code&gt; , чтобы увидеть, относятся ли две ссылки к одному и тому же. (Но вместо этого обычно следует использовать &lt;code&gt;==&lt;/code&gt; , потому что это намного быстрее.)</target>
        </trans-unit>
        <trans-unit id="521c212b6a17d7bb672fae4188d350c73713a7f4" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="translated">Сигил, за которым следует единственный символ, соответствующий &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; , например &lt;code&gt;$!&lt;/code&gt; или &lt;code&gt;%+&lt;/code&gt; , за исключением того, что символ &lt;code&gt;&quot;{&quot;&lt;/code&gt; не работает.</target>
        </trans-unit>
        <trans-unit id="78b33a149b8ec79d1db1e7ff3c6da388ca1d2f6f" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ab0e2e7434b80376db123861053e1dd6f58146" translate="yes" xml:space="preserve">
          <source>A sigil, followed by a caret and any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96dcc4bc70d20a77f933afc7e767e66a7d6afd1e" translate="yes" xml:space="preserve">
          <source>A sigil, followed by any single character in the range &lt;code&gt;[\xA1-\xAC\xAE-\xFF]&lt;/code&gt; when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;. (Under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, the normal identifier rules given earlier in this section apply.) Use of non-graphic characters (the C1 controls, the NO-BREAK SPACE, and the SOFT HYPHEN) has been disallowed since v5.26.0. The use of the other characters is unwise, as these are all reserved to have special meaning to Perl, and none of them currently do have special meaning, though this could change without notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc8d7ea546cfbfc32e7048bc99953161b5c5af3" translate="yes" xml:space="preserve">
          <source>A sigil, followed by either a caret and a single POSIX uppercase letter, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; , or a sigil followed by a literal non-space, non-&lt;code&gt;NUL&lt;/code&gt; control character matching the &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; property. Due to a historical oddity, if not running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the 128 characters in the &lt;code&gt;[0x80-0xff]&lt;/code&gt; range are considered to be controls, and may also be used in length-one variables. However, the use of non-graphical characters is deprecated as of v5.22, and support for them will be removed in a future version of perl. ASCII space characters and &lt;code&gt;NUL&lt;/code&gt; already aren't allowed, so this means that a single-character variable name with that name being any other C0 control &lt;code&gt;[0x01-0x1F]&lt;/code&gt; , or &lt;code&gt;DEL&lt;/code&gt; will generate a deprecated warning. Already, under &lt;code&gt;&quot;use
utf8&quot;&lt;/code&gt; , non-ASCII characters must match &lt;code&gt;Perl_XIDS&lt;/code&gt; . As of v5.22, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; C1 controls &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE, and SOFT HYPHEN (&lt;code&gt;SHY&lt;/code&gt; )) generate a deprecated warning.</source>
          <target state="translated">Сигил, за которым следует либо каретка и одна заглавная буква POSIX, например &lt;code&gt;$^V&lt;/code&gt; или &lt;code&gt;$^W&lt;/code&gt; , либо сигил, за которым следует буквальный &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; управляющий символ, отличный от &lt;code&gt;NUL&lt;/code&gt; , соответствующий свойству \ p {POSIX_Cntrl} . Из-за исторической странности, если он не работает с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , 128 символов в диапазоне &lt;code&gt;[0x80-0xff]&lt;/code&gt; считаются элементами управления и могут также использоваться в переменных длины один. Однако использование неграфических символов не рекомендуется с v5.22, и их поддержка будет удалена в будущей версии perl. Пробелы ASCII и &lt;code&gt;NUL&lt;/code&gt; уже не разрешены, поэтому это означает, что односимвольное имя переменной с этим именем является любым другим &lt;code&gt;[0x01-0x1F]&lt;/code&gt; управления C0 [0x01-0x1F] , или &lt;code&gt;DEL&lt;/code&gt; будет генерировать устаревшее предупреждение. Уже в разделе &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; символы, отличные от ASCII, должны соответствовать &lt;code&gt;Perl_XIDS&lt;/code&gt; . Начиная с v5.22, когда элементы управления C1 &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE и SOFT HYPHEN ( &lt;code&gt;SHY&lt;/code&gt; )) не находятся под &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; , генерируют устаревшее предупреждение.</target>
        </trans-unit>
        <trans-unit id="25c7b41e2f3083fca5663c24cdf9d0f7721da4bb" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; , like &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; , or &lt;code&gt;$10000&lt;/code&gt; .</source>
          <target state="translated">Сигил, за которым следуют только цифры, соответствующие &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; , например, &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; или &lt;code&gt;$10000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a882085b42cb0bab19f2ed527e7af342a0ee517" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt;, like &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, or &lt;code&gt;$10000&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3df970159f7cc9815aae935a27c2abc1cbc161b" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c803de64703554f9c3355b0bb0b711df0025cdae" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You will get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="translated">Знак 'NaN' используется для представления результата,когда входные аргументы не являются числами или в результате 0/0.'+inf' и '-inf' представляют плюс соответственно минус бесконечность.Вы получите '+inf' при делении положительного числа на 0,и '-inf' при делении любого отрицательного числа на 0.</target>
        </trans-unit>
        <trans-unit id="acfa2fff17c2c760f059166beff68ca97cf27024" translate="yes" xml:space="preserve">
          <source>A signature may be entirely empty, in which case all it does is check that the caller passed no arguments:</source>
          <target state="translated">Подпись может быть полностью пустой,и в этом случае все,что она делает,это проверяет,не передал ли вызывающий абонент аргументы:</target>
        </trans-unit>
        <trans-unit id="31a0e78fd112747fd282a616f307965e9e97ecc5" translate="yes" xml:space="preserve">
          <source>A signature parameter must start with '$', '@' or '%'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b7bfaadf566cb42bb060b59ab39877bdce37fb" translate="yes" xml:space="preserve">
          <source>A signed integer. This is cast to the required integer type when passed to C and converted to an IV when passed back to Perl.</source>
          <target state="translated">Подписанное целое число.Оно приводится к нужному целому типу при передаче в C и преобразуется в IV при передаче обратно в Perl.</target>
        </trans-unit>
        <trans-unit id="1575087c19c9eb3e9ca21e23f5fecff11363ecdb" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="translated">Целое число со знаком. Эта карта типов преобразует значение Perl в собственный целочисленный тип ( тип &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; на текущей платформе). При возврате значения в perl оно обрабатывается так же, как и для T_IV.</target>
        </trans-unit>
        <trans-unit id="f69f9b6922b305d309dd50acaf19b40451a94ff0" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;int&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6e260265e056207c62a15cda251b7b04ab7de2" translate="yes" xml:space="preserve">
          <source>A significant number of the bug reports we get turn out to be documented features in Perl. Make sure the issue you've run into isn't intentional by glancing through the documentation that comes with the Perl distribution.</source>
          <target state="translated">Значительное количество получаемых нами сообщений об ошибках оказывается документированными возможностями на Perl.Убедитесь,что проблема,с которой вы столкнулись,не является преднамеренной,просмотрев документацию,которая поставляется с дистрибутивом Perl.</target>
        </trans-unit>
        <trans-unit id="80837079263cda7d0c48b62c5a2b8e0aa29ed989" translate="yes" xml:space="preserve">
          <source>A similar but more subtle problem is illustrated with this code:</source>
          <target state="translated">Похожая,но более тонкая проблема проиллюстрирована этим кодом:</target>
        </trans-unit>
        <trans-unit id="81ab11bae0fce0f2612a231d95d1eecf127ccce2" translate="yes" xml:space="preserve">
          <source>A similar effect applies to</source>
          <target state="translated">Аналогичный эффект распространяется на</target>
        </trans-unit>
        <trans-unit id="a23425aa80f51fe5db313d5664fb7ac8f4d286d0" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, although you can use &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Аналогичная стратегия будет работать для расширения подстановочных знаков через &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; , хотя вместо этого вы можете использовать &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="676cee5371668926c1dabdcd2aa4d10e661b2ca7" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;glob&lt;/code&gt;, although you can use &lt;code&gt;readdir&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1349e3e7bc2ad99052d135eb76b4bea7da2dc2" translate="yes" xml:space="preserve">
          <source>A similar task is to find words consisting of two identical parts:</source>
          <target state="translated">Аналогичная задача-найти слова,состоящие из двух одинаковых частей:</target>
        </trans-unit>
        <trans-unit id="ee2213ceffd8c1f2a6f17c3aee8ab7cdf3d4092c" translate="yes" xml:space="preserve">
          <source>A similar trick involves the</source>
          <target state="translated">Подобный трюк включает в себя</target>
        </trans-unit>
        <trans-unit id="8848997a2920d88084bbf780cebe39466ec879ee" translate="yes" xml:space="preserve">
          <source>A simple API to convert seconds to other date values</source>
          <target state="translated">Простой API для преобразования секунд в другие значения даты.</target>
        </trans-unit>
        <trans-unit id="c123404763bd10d42cf8e7c2eaf59ecc97ce202f" translate="yes" xml:space="preserve">
          <source>A simple boolean indicating if the command executed without errors or not.</source>
          <target state="translated">Простой логический индикатор того,выполнена команда без ошибок или нет.</target>
        </trans-unit>
        <trans-unit id="5bd4089058361e948e8b28ab1128c297a0f82d9e" translate="yes" xml:space="preserve">
          <source>A simple call to &lt;code&gt;isnt()&lt;/code&gt; usually does not provide a strong test but there are cases when you cannot say much more about a value than that it is different from some other value:</source>
          <target state="translated">Простой вызов &lt;code&gt;isnt()&lt;/code&gt; обычно не обеспечивает надежной проверки, но бывают случаи, когда вы не можете сказать намного больше о значении, чем то, что оно отличается от другого значения:</target>
        </trans-unit>
        <trans-unit id="4fbcc760723f31ac561f9cef482138111eb6931b" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt; and &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or false if not both are installed.</source>
          <target state="translated">Простая процедура проверки, которая вернет true, если &lt;code&gt;Archive::Tar&lt;/code&gt; может распаковывать сжатые архивы на лету с &lt;code&gt;IO::Zlib&lt;/code&gt; и &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; или false, если не оба установлены.</target>
        </trans-unit>
        <trans-unit id="10951c632f33a4f0fc994717dc96bab5fd305add" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt;, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Xz&lt;/code&gt; or false if not both are installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc5b3faec4a3f9f01b28a9e7d12132d66ab6e1d" translate="yes" xml:space="preserve">
          <source>A simple listing of all the files in your distribution.</source>
          <target state="translated">Простой список всех файлов в вашем дистрибутиве.</target>
        </trans-unit>
        <trans-unit id="372959c464065982896bbbe2c2818eb6cad5f8a5" translate="yes" xml:space="preserve">
          <source>A simple mapping of the op type number to its type (like 'COP' or 'BINOP').</source>
          <target state="translated">Простое сопоставление номера типа операции с ее типом (например,'COP' или 'BINOP').</target>
        </trans-unit>
        <trans-unit id="d472680931a17874166dba160d7f69e6352eb56b" translate="yes" xml:space="preserve">
          <source>A simple read-only accessor simply gets the value of a single attribute:</source>
          <target state="translated">Простой аксессуар,доступный только для чтения,просто получает значение одного атрибута:</target>
        </trans-unit>
        <trans-unit id="681ff201b3498a43f7a62245e78650fd37d86b77" translate="yes" xml:space="preserve">
          <source>A simple scalar number</source>
          <target state="translated">Простое скалярное число</target>
        </trans-unit>
        <trans-unit id="1b93dcb8f21d326777ddc52bfa4bdd011dd04c4a" translate="yes" xml:space="preserve">
          <source>A simple scalar string</source>
          <target state="translated">Простая скалярная строка</target>
        </trans-unit>
        <trans-unit id="5776d9f23e070178afac4296b05b65fd1f748404" translate="yes" xml:space="preserve">
          <source>A simple scalar with an extra reference</source>
          <target state="translated">Простой скаляр с дополнительной ссылкой</target>
        </trans-unit>
        <trans-unit id="f593aa1a652c40c9b2c700bcf9bdc1dacfbe433a" translate="yes" xml:space="preserve">
          <source>A simple summary of the tests so far. True for pass, false for fail. This is a logical pass/fail, so todos are passes.</source>
          <target state="translated">Простое резюме пока что проведенных тестов.Правда на прохождение,правда на провал.Это логический проход/неудача,поэтому тодос-это проход.</target>
        </trans-unit>
        <trans-unit id="e9ed86741cb6e707485ef431b1b242bee25c8fe1" translate="yes" xml:space="preserve">
          <source>A simple, singular value; a number, &lt;b&gt;string&lt;/b&gt;, or &lt;b&gt;reference&lt;/b&gt;.</source>
          <target state="translated">Простое, единственное значение; число, &lt;b&gt;строка&lt;/b&gt; или &lt;b&gt;ссылка&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="41fbe0f5dde0b71cac36adde6b1e65c7f6388dac" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;/x&lt;/code&gt; tells the regular expression parser to ignore most whitespace that is neither backslashed nor within a bracketed character class. You can use this to break up your regular expression into more readable parts. Also, the &lt;code&gt;&quot;#&quot;&lt;/code&gt; character is treated as a metacharacter introducing a comment that runs up to the pattern's closing delimiter, or to the end of the current line if the pattern extends onto the next line. Hence, this is very much like an ordinary Perl code comment. (You can include the closing delimiter within the comment only if you precede it with a backslash, so be careful!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7d12449647b7d47425008bd7d9de56b3bffa22" translate="yes" xml:space="preserve">
          <source>A single character that represents the end of a line, with the ASCII value of 012 octal under Unix (but 015 on a Mac), and represented by &lt;code&gt;\n&lt;/code&gt; in Perl strings. For Windows machines writing text files, and for certain physical devices like terminals, the single newline gets automatically translated by your C library into a line feed and a carriage return, but normally, no translation is done.</source>
          <target state="translated">Одиночный символ, который представляет конец строки со значением ASCII в восьмеричном формате 012 в Unix (но 015 в Mac) и представлен как &lt;code&gt;\n&lt;/code&gt; в строках Perl. Для машин Windows, записывающих текстовые файлы, и для определенных физических устройств, таких как терминалы, одиночная новая строка автоматически переводится вашей библиотекой C в перевод строки и возврат каретки, но обычно перевод не выполняется.</target>
        </trans-unit>
        <trans-unit id="2a1618c928b45217b1ecfab89b72e2f9c62e981a" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt; . This will match strings like &amp;ldquo;&lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">Единая сущность с разными интерпретациями, как слон. Для компьютерного ученого это грамматика небольшого языка, в котором одни строки допустимы, а другие - нет. Для нормальных людей это шаблон, который можно использовать, чтобы найти то, что вы ищете, в зависимости от случая. Регулярные выражения Perl далеки от регулярных в теоретическом смысле, но при регулярном использовании они работают довольно хорошо. Вот регулярное выражение: &lt;code&gt;/Oh s.*t./&lt;/code&gt; . Это будет соответствовать таким строкам, как &amp;laquo; &lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;Oh sit!&lt;/code&gt; &amp;raquo;. См. Главу 5 &amp;laquo;Верблюд&amp;raquo; &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bd9d52f50401e07be14bc39be94bfc90b5fed1b7" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt;. This will match strings like &amp;ldquo;&lt;code&gt;Oh say can you see by the dawn's early light&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt;&amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c7b2b0b88a0fcb03de95938de74348bdc84aea" translate="yes" xml:space="preserve">
          <source>A single flag bit associated with this message, in a &lt;code&gt;SVuv&lt;/code&gt;. The bit corresponds to some bit in the &lt;code&gt;*errors&lt;/code&gt; return value, such as &lt;code&gt;UNICODE_GOT_SURROGATE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823574b7a9a841c68fa3382fefc5234c4a20c603" translate="yes" xml:space="preserve">
          <source>A single flag bit associated with this message, in a &lt;code&gt;SVuv&lt;/code&gt;. The bit corresponds to some bit in the &lt;code&gt;*errors&lt;/code&gt; return value, such as &lt;code&gt;UTF8_GOT_LONG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829152f3dcb1ed16bfc3e8ca36bfa63ebf05d7eb" translate="yes" xml:space="preserve">
          <source>A single hexadecimal number denoting a code point to include.</source>
          <target state="translated">Одно шестнадцатеричное число,обозначающее кодовую точку для включения.</target>
        </trans-unit>
        <trans-unit id="27a4bf6aaf65d7e6150de844a569f0f9a5f667a4" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="translated">Отдельный фрагмент числовых или строковых данных, который является частью более длинной &lt;b&gt;строки&lt;/b&gt; , &lt;b&gt;записи&lt;/b&gt; или &lt;b&gt;строки&lt;/b&gt; . Поля переменной ширины обычно разделяются &lt;b&gt;разделителями&lt;/b&gt; (поэтому используйте &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; для извлечения полей), в то время как поля фиксированной ширины обычно находятся в фиксированных позициях (поэтому используйте &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ). &lt;b&gt;Переменные экземпляра&lt;/b&gt; также известны как &amp;laquo;поля&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9c9a04c7fe7162d287f0a6bf5101410d1b801612" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;split&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;unpack&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff4db73bde7c1d7cfd3e2062dd1951912b9e366" translate="yes" xml:space="preserve">
          <source>A single symbol abbreviating the class of the OP.</source>
          <target state="translated">Один символ,сокращающий класс ОП.</target>
        </trans-unit>
        <trans-unit id="ed641668fea177eedad336e7089851d18b828e16" translate="yes" xml:space="preserve">
          <source>A single testing job.</source>
          <target state="translated">Одно тестирование.</target>
        </trans-unit>
        <trans-unit id="41bf4051bfbbef3d6c2986f2065087b05c2359b5" translate="yes" xml:space="preserve">
          <source>A single-quoted, literal string. A backslash represents a backslash unless followed by the delimiter or another backslash, in which case the delimiter or backslash is interpolated.</source>
          <target state="translated">Одноцитатная,буквальная строка.Обратная косая черта представляет собой обратную косую черту,если за ней не следует разделитель или другая обратная косая черта,в этом случае разделитель или обратная косая черта интерполированы.</target>
        </trans-unit>
        <trans-unit id="8add36465a616cf6d47e4a5aef01fb690927c1f3" translate="yes" xml:space="preserve">
          <source>A slice accesses several elements of a list, an array, or a hash simultaneously using a list of subscripts. It's more convenient than writing out the individual elements as a list of separate scalar values.</source>
          <target state="translated">Фрагмент обращается к нескольким элементам списка,массиву или хэшу одновременно,используя список подписчиков.Это удобнее,чем выписывать отдельные элементы в виде списка отдельных скалярных значений.</target>
        </trans-unit>
        <trans-unit id="7f8a4967d94ac75566470d147a5f123047048bbb" translate="yes" xml:space="preserve">
          <source>A slight modification also removes C++ comments, possibly spanning multiple lines using a continuation character:</source>
          <target state="translated">Небольшое изменение также удаляет комментарии на C++,возможно,охватывая несколько строк с использованием символа продолжения:</target>
        </trans-unit>
        <trans-unit id="e99cb7094afcbc76a76c4efa1f4eefdffe5bff51" translate="yes" xml:space="preserve">
          <source>A slightly larger piece of code will provide something on which a profiler can produce more extensive reporting statistics. This example uses the simplistic &lt;code&gt;wordmatch&lt;/code&gt; program which parses a given input file and spews out a short report on the contents.</source>
          <target state="translated">Немного более крупный фрагмент кода предоставит то, по чему профилировщик может производить более обширную статистику отчетов. В этом примере используется упрощенная программа &lt;code&gt;wordmatch&lt;/code&gt; которая анализирует заданный входной файл и выдает краткий отчет о его содержимом.</target>
        </trans-unit>
        <trans-unit id="03934c7f98da92e385e9ea42d12c3ed3bec3632f" translate="yes" xml:space="preserve">
          <source>A slurpy hash parameter may be nameless just like other kinds of parameter. It still insists that the number of arguments available to it be even, even though they're not being put into a variable.</source>
          <target state="translated">Хэш-параметр slurpy может быть безымянным,как и другие типы параметров.Он по-прежнему настаивает на том,чтобы количество доступных ему аргументов было равномерным,даже если их не помещают в переменную.</target>
        </trans-unit>
        <trans-unit id="30988eefa9eacb81270153c8608fad35b31b7f98" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may instead be a hash, in which case the arguments available to it are interpreted as alternating keys and values. There must be as many keys as values: if there is an odd argument then an exception will be thrown. Keys will be stringified, and if there are duplicates then the later instance takes precedence over the earlier, as with standard hash construction.</source>
          <target state="translated">Параметр slurpy вместо него может быть хэшем,в этом случае доступные ему аргументы интерпретируются как переменные ключи и значения.Ключей должно быть столько же,сколько и значений:если есть нечетный аргумент,то будет брошено исключение.Ключи будут строковаться,а если есть дубликаты,то последующий экземпляр будет иметь приоритет над предыдущим,как при стандартной конструкции хэша.</target>
        </trans-unit>
        <trans-unit id="7ae153b0845a4f9cd82e184d9134e9263fb0358d" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may not have a default value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d8ab783e8ae2210ac2fb7506feb3637ad91b4b" translate="yes" xml:space="preserve">
          <source>A slurpy parameter, either array or hash, must be the last thing in the signature. It may follow mandatory and optional positional parameters; it may also be the only thing in the signature. Slurpy parameters cannot have default values: if no arguments are supplied for them then you get an empty array or empty hash.</source>
          <target state="translated">Параметр slurpy,массив или хэш,должен быть последним в сигнатуре.Он может следовать обязательным и необязательным параметрам позиционирования;он также может быть единственным в сигнатуре.Параметры Slurpy не могут иметь значений по умолчанию:если для них нет аргументов,то получается пустой массив или пустой хэш.</target>
        </trans-unit>
        <trans-unit id="c7ed55a78ba712132c2ae6c86e583e8efc503821" translate="yes" xml:space="preserve">
          <source>A small example demonstrating SysV message queues:</source>
          <target state="translated">Небольшой пример,демонстрирующий очереди сообщений SysV:</target>
        </trans-unit>
        <trans-unit id="15bb640f66c323688300cc265de617018ed0c375" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&amp;gt; 1&lt;/code&gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0014acccc6b5556fca51e530830260283cc77d0" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="translated">Небольшой скрипт, который выявляет проблему, вероятно, поможет. Также было бы полезно, если бы этот сценарий запускался с дополнительными параметрами &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt;, переданными конструктору, а вывод отправлялся вместе с отчетом об ошибке. Если вы не можете включить небольшой сценарий, включите трассировку отладки из запуска вашей программы, которая действительно вызывает проблему.</target>
        </trans-unit>
        <trans-unit id="c165dd6d48bb6848a9c96904378fd915f9518c69" translate="yes" xml:space="preserve">
          <source>A small, simple, correct HTTP/1.1 client</source>
          <target state="translated">Маленький,простой,правильный клиент HTTP/1.1.</target>
        </trans-unit>
        <trans-unit id="27545b929364aeeb83be800c720a5090d4d35630" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; .</source>
          <target state="translated">Интеллектуальное сопоставление, в котором используется явный оператор &lt;code&gt;~~&lt;/code&gt; , например &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b57b94fbdb028a48b1bf7791227cc60c86bb4ce" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee7049b5826d72a2f103072d053d50784d7d0da" translate="yes" xml:space="preserve">
          <source>A sneaky &lt;code&gt;LC_COLLATE&lt;/code&gt; locale could result in the names of students with &quot;D&quot; grades appearing ahead of those with &quot;A&quot;s.</source>
          <target state="translated">Подлый &lt;code&gt;LC_COLLATE&lt;/code&gt; локали может привести к именам студентов с &amp;laquo;D&amp;raquo; классов , возникающих перед теми , с с &amp;laquo;А&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3fa57a01d182c489f4440aa3ceec23094b8bdecb" translate="yes" xml:space="preserve">
          <source>A solution to this and many similar issues is to use the &lt;code&gt;mem&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd3117b0bc435a9ddefeeeda5fe0b0754edfcc4" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt; . It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="translated">Решением этой проблемы является использование библиотеки, которая использует псевдотоки, чтобы ваша программа работала более разумно. Таким образом, вам не нужно контролировать исходный код программы, которую вы используете. Модуль &lt;code&gt;Expect&lt;/code&gt; от CPAN также решает подобные проблемы. Для этого модуля требуются два других модуля из CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; и &lt;code&gt;IO::Stty&lt;/code&gt; . Он устанавливает псевдотерминал для взаимодействия с программами, которые настаивают на взаимодействии с драйвером терминального устройства. Если ваша система поддерживается, это может быть вашим лучшим выбором.</target>
        </trans-unit>
        <trans-unit id="8b65901bcbb4cd6d842da55cf32921b07fcc8591" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt;. It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d33fafbade920ec9b14eb3241088b584cc3390" translate="yes" xml:space="preserve">
          <source>A somewhat misleadingly named synonym for &lt;code&gt;UNICODE_WARN_PERL_EXTENDED&lt;/code&gt; is retained for backward compatibility: &lt;code&gt;UNICODE_WARN_ABOVE_31_BIT&lt;/code&gt;. Similarly, &lt;code&gt;UNICODE_DISALLOW_ABOVE_31_BIT&lt;/code&gt; is usable instead of the more accurately named &lt;code&gt;UNICODE_DISALLOW_PERL_EXTENDED&lt;/code&gt;. The names are misleading because on EBCDIC platforms,these flags can apply to code points that actually do fit in 31 bits. The new names accurately describe the situation in all cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ba2a5e34ef24872cc78663b3c8e0fdb24a9d8" translate="yes" xml:space="preserve">
          <source>A somewhat misleadingly named synonym for &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; is retained for backward compatibility: &lt;code&gt;UTF8_WARN_ABOVE_31_BIT&lt;/code&gt;. Similarly, &lt;code&gt;UTF8_DISALLOW_ABOVE_31_BIT&lt;/code&gt; is usable instead of the more accurately named &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt;. The names are misleading because these flags can apply to code points that actually do fit in 31 bits. This happens on EBCDIC platforms, and sometimes when the &lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;overlong malformation&lt;/a&gt; is also present. The new names accurately describe the situation in all cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b80c1598a0b057abd1403fd2b9a7dc757cff1ce" translate="yes" xml:space="preserve">
          <source>A source filter is a special kind of Perl module that intercepts and modifies a source stream before it reaches the parser. A source filter changes our diagram like this:</source>
          <target state="translated">Исходный фильтр-это специальный вид модуля Perl,который перехватывает и изменяет исходный поток до того,как он достигнет синтаксического анализатора.Исходный фильтр изменяет нашу диаграмму следующим образом:</target>
        </trans-unit>
        <trans-unit id="8b0be58db42e648ec049b8d1ddee43ac5d107082" translate="yes" xml:space="preserve">
          <source>A space (or colon) separated list of PerlIO layers. If perl is built to use PerlIO system for IO (the default) these layers affect Perl's IO.</source>
          <target state="translated">Пробел (или двоеточие)разделенный список слоев PerlIO.Если Perl построен для использования PerlIO-системы для IO (по умолчанию),то эти слои влияют на IO Perl.</target>
        </trans-unit>
        <trans-unit id="0badf9ed68d3af0c4f3cd1c0a7af9f9020afc01b" translate="yes" xml:space="preserve">
          <source>A special &lt;b&gt;method&lt;/b&gt; that is called when an &lt;b&gt;object&lt;/b&gt; is thinking about &lt;b&gt;destroying&lt;/b&gt; itself. A Perl program&amp;rsquo;s &lt;code&gt;DESTROY&lt;/code&gt; method doesn&amp;rsquo;t do the actual destruction; Perl just &lt;b&gt;triggers&lt;/b&gt; the method in case the &lt;b&gt;class&lt;/b&gt; wants to do any associated cleanup.</source>
          <target state="translated">Специальный &lt;b&gt;метод,&lt;/b&gt; который вызывается, когда &lt;b&gt;объект&lt;/b&gt; думает о &lt;b&gt;самоуничтожении&lt;/b&gt; . Метод &lt;code&gt;DESTROY&lt;/code&gt; программы Perl не выполняет фактического уничтожения; Perl просто &lt;b&gt;запускает&lt;/b&gt; метод, если &lt;b&gt;класс&lt;/b&gt; хочет выполнить какую-либо связанную очистку.</target>
        </trans-unit>
        <trans-unit id="ef35c437c5c84fa1b46b5dc38d46f6fde11ec243" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="translated">Особый случай - если выражение является ссылкой на подпрограмму (либо в синтаксисе &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; , либо в синтаксисе &lt;code&gt;\&amp;amp;foo&lt;/code&gt; ). В этом случае он выполняется, и его значение (истина или ложь) определяет, пройден тест или нет. Например,</target>
        </trans-unit>
        <trans-unit id="9916746eced8e5680d9be3db4c1b0f01137572d1" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;sub {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4bdb3b56feee845f988c80b59a2de393b4d25c" translate="yes" xml:space="preserve">
          <source>A special entry &lt;code&gt;GetOptionsFromString&lt;/code&gt; can be used to parse options from an arbitrary string.</source>
          <target state="translated">Специальная запись &lt;code&gt;GetOptionsFromString&lt;/code&gt; может использоваться для анализа параметров из произвольной строки.</target>
        </trans-unit>
        <trans-unit id="f5f25c2de52c4c00b53b25ba03c614f087fa031c" translate="yes" xml:space="preserve">
          <source>A special file that contains other files. Some &lt;b&gt;operating systems&lt;/b&gt; call these &amp;ldquo;folders&amp;rdquo;, &amp;ldquo;drawers&amp;rdquo;, &amp;ldquo;catalogues&amp;rdquo;, or &amp;ldquo;catalogs&amp;rdquo;.</source>
          <target state="translated">Специальный файл, содержащий другие файлы. Некоторые &lt;b&gt;операционные системы&lt;/b&gt; называют эти &amp;laquo;папки&amp;raquo;, &amp;laquo;ящики&amp;raquo;, &amp;laquo;каталоги&amp;raquo; или &amp;laquo;каталоги&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9d4dee1bf51d9988b7b651c7e34b5ae56c3d23f3" translate="yes" xml:space="preserve">
          <source>A special form is the &lt;code&gt;(DEFINE)&lt;/code&gt; predicate, which never executes its yes-pattern directly, and does not allow a no-pattern. This allows one to define subpatterns which will be executed only by the recursion mechanism. This way, you can define a set of regular expression rules that can be bundled into any pattern you choose.</source>
          <target state="translated">Специальная форма - это предикат &lt;code&gt;(DEFINE)&lt;/code&gt; , который никогда не выполняет напрямую свой yes-шаблон и не допускает no-pattern. Это позволяет определять подшаблоны, которые будут выполняться только механизмом рекурсии. Таким образом, вы можете определить набор правил регулярных выражений, которые можно объединить в любой выбранный вами шаблон.</target>
        </trans-unit>
        <trans-unit id="098ae82dbb47389fd0f04911d56700422f9e1bbd" translate="yes" xml:space="preserve">
          <source>A special internal spot in which Perl keeps the information about the last &lt;b&gt;file&lt;/b&gt; on which you requested information.</source>
          <target state="translated">Специальное внутреннее место, в котором Perl хранит информацию о последнем &lt;b&gt;файле,&lt;/b&gt; по которому вы запрашивали информацию.</target>
        </trans-unit>
        <trans-unit id="79eddc4100fb4306d07fc838a90fb71a102a9485" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;module&lt;/b&gt; that does &lt;b&gt;preprocessing&lt;/b&gt; on your script just before it gets to the &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">Особый вид &lt;b&gt;модуля,&lt;/b&gt; который выполняет &lt;b&gt;предварительную обработку&lt;/b&gt; вашего скрипта непосредственно перед тем, как он попадет в &lt;b&gt;токенер&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="0c845e10d2c5e7d853c713ce339e272a56f03f5c" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;scalar context&lt;/b&gt; used in conditionals to decide whether the &lt;b&gt;scalar value&lt;/b&gt; returned by an expression is &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;. Does not evaluate as either a string or a number. See &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">Особый вид &lt;b&gt;скалярного контекста,&lt;/b&gt; используемый в условных выражениях, чтобы решить, является ли &lt;b&gt;скалярное значение,&lt;/b&gt; возвращаемое выражением, &lt;b&gt;истинным&lt;/b&gt; или &lt;b&gt;ложным&lt;/b&gt; . Не оценивается как строка или число. См. &lt;b&gt;Контекст&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="89b7b57b006b340679bccefff3860259f11cee5d" translate="yes" xml:space="preserve">
          <source>A special note about fetching files from an ftp uri:</source>
          <target state="translated">Специальная заметка о получении файлов из ftp uri:</target>
        </trans-unit>
        <trans-unit id="daa44f44af6529c7f53a78e2c82f295d89b6e71e" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a568b09a052a4fda0da31a9dd45e8de43daae28" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name. Well, actually it is an object that stringifies to the argument name.</source>
          <target state="translated">Специальная опция 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; может использоваться для обозначения подпрограммы для обработки аргументов, не являющихся опциями. Когда GetOptions () встречает аргумент, который не похож на параметр, он немедленно вызывает эту подпрограмму и передает ей один параметр: имя аргумента. На самом деле это объект, который преобразуется в имя аргумента.</target>
        </trans-unit>
        <trans-unit id="9bb864d2ebf5f6403ee2f29fbe30d0ca7cb3bbfc" translate="yes" xml:space="preserve">
          <source>A special program that runs on the bare machine and hides the gory details of managing &lt;b&gt;processes&lt;/b&gt; and &lt;b&gt;devices&lt;/b&gt;. Usually used in a looser sense to indicate a particular culture of programming. The loose sense can be used at varying levels of specificity. At one extreme, you might say that all versions of Unix and Unix-lookalikes are the same operating system (upsetting many people, especially lawyers and other advocates). At the other extreme, you could say this particular version of this particular vendor&amp;rsquo;s operating system is different from any other version of this or any other vendor&amp;rsquo;s operating system. Perl is much more portable across operating systems than many other languages. See also &lt;b&gt;architecture&lt;/b&gt; and &lt;b&gt;platform&lt;/b&gt;.</source>
          <target state="translated">Специальная программа, которая запускается на голой машине и скрывает кровавые подробности управления &lt;b&gt;процессами&lt;/b&gt; и &lt;b&gt;устройствами&lt;/b&gt; . Обычно используется в более широком смысле для обозначения определенной культуры программирования. Свободный смысл можно использовать на разных уровнях специфичности. С одной стороны, вы можете сказать, что все версии Unix и аналогичные Unix - это одна и та же операционная система (что расстроило многих людей, особенно юристов и других защитников). С другой стороны, вы могли бы сказать, что эта конкретная версия операционной системы конкретного поставщика отличается от любой другой версии операционной системы этого или любого другого поставщика. Perl гораздо более переносим между операционными системами, чем многие другие языки. См. Также &lt;b&gt;архитектуру&lt;/b&gt; и &lt;b&gt;платформу&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b03867324ba36517f3a9d0e823f68ebcc5db216b" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; through it.</source>
          <target state="translated">Специальная программная штуковина, которая отслеживает, где вы находитесь в том, что вы пытаетесь повторить. Цикл &lt;code&gt;foreach&lt;/code&gt; в Perl содержит итератор; так же как и хеш, позволяющий &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; пройти через него.</target>
        </trans-unit>
        <trans-unit id="ee10f3c342b9f05f366b2abdcd5237c7367d7d5d" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;each&lt;/code&gt; through it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2ae230ab87141b90e09da012ca49eb173d1f62" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Perl 6 version to show that Perl will stay Perl.</source>
          <target state="translated">Особая благодарность Damian Conway,который не только предложил важные изменения,но и нашел время,чтобы подсчитать количество перечисленных функций и сделать версию Perl 6,чтобы показать,что Perl останется Perl.</target>
        </trans-unit>
        <trans-unit id="ba47d8229178e976b4e17fac8c50f7480fa0cd1c" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Raku version to show that Perl will stay Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd3a98639e4de23b8ab5b1ce7e392825e327157" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number.</source>
          <target state="translated">Специальная маркерная строка,которая компилируется с номером текущей строки.</target>
        </trans-unit>
        <trans-unit id="44f4cd0691d6b1f249950031c94d5eba6a8b7ab3" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number. It can be altered by the mechanism described at &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a5128be0078d880657071bac7267720f138c1c" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; outside of a subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8db7e23c364c11a426f9d30c1e28cd4da6326e7" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">Специальный токен, который возвращает ссылку на текущую подпрограмму или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вне подпрограммы.</target>
        </trans-unit>
        <trans-unit id="d6eea162b97cdf5937cc80c12d97f68b73850c69" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">Специальный токен, который возвращает ссылку на текущую подпрограмму или &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вне подпрограммы.</target>
        </trans-unit>
        <trans-unit id="2c26f3ebdbb02dd6bf3cbae9d5ef0c2e36ca2b14" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs.</source>
          <target state="translated">Специальный маркер,возвращающий имя файла,в котором он находится.</target>
        </trans-unit>
        <trans-unit id="4d534cc3d24e8095df0fd43eb483a4f531a852ee" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs. It can be altered by the mechanism described at &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48496bf275cb62c80b11546a66125c1e011d6e73" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the package in which it occurs.</source>
          <target state="translated">Специальный токен,возвращающий имя пакета,в котором он находится.</target>
        </trans-unit>
        <trans-unit id="07395fd97ce6a28d8015ab2eaad3eae19ab86b6e" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;croak()&lt;/code&gt; for emitting the usage message for xsubs</source>
          <target state="translated">Специализированный вариант &lt;code&gt;croak()&lt;/code&gt; для отправки сообщения об использовании для xsubs</target>
        </trans-unit>
        <trans-unit id="bc379211e591381ed14a5306c8c0734c9a94f69f" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;&quot;newHVhv&quot;&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt;. &lt;code&gt;ohv&lt;/code&gt; must be a pointer to a hash (which may have &lt;code&gt;%^H&lt;/code&gt; magic, but should be generally non-magical), or &lt;code&gt;NULL&lt;/code&gt; (interpreted as an empty hash). The content of &lt;code&gt;ohv&lt;/code&gt; is copied to a new hash, which has the &lt;code&gt;%^H&lt;/code&gt;-specific magic added to it. A pointer to the new hash is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a1130f5dbd32f8addbfbf8cc52dc9647058465" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt; .</source>
          <target state="translated">Специализированная версия &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; для копирования &lt;code&gt;%^H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e58efa1c2b3f0ec95f611bcd359aa9037253ccf" translate="yes" xml:space="preserve">
          <source>A specification of how many spaces and digits and things to put somewhere so that whatever you&amp;rsquo;re printing comes out nice and pretty.</source>
          <target state="translated">Спецификация того, сколько пробелов, цифр и других вещей куда-то поместить, чтобы все, что вы печатаете, получилось красиво и красиво.</target>
        </trans-unit>
        <trans-unit id="ece2ff0c58aaa5372289e45e695e7991badd8557" translate="yes" xml:space="preserve">
          <source>A spoonerism of &amp;ldquo;creeping featurism&amp;rdquo;, noting the biological urge to add just one more feature to a program.</source>
          <target state="translated">Ложка &amp;laquo;ползучей черты характера&amp;raquo;, отмечая биологическое стремление добавить в программу еще одну функцию.</target>
        </trans-unit>
        <trans-unit id="d575cbf3544d0e35868eb03520f7ba9dff410b04" translate="yes" xml:space="preserve">
          <source>A spot in your program where you&amp;rsquo;ve told the debugger to stop &lt;b&gt;execution&lt;/b&gt; so you can poke around and see whether anything is wrong yet.</source>
          <target state="translated">Место в вашей программе, где вы приказали отладчику остановить &lt;b&gt;выполнение,&lt;/b&gt; чтобы вы могли покопаться и посмотреть, не все ли в порядке.</target>
        </trans-unit>
        <trans-unit id="c8d0045954f55c0ef11ccdf21fdc1fefc0f23ff1" translate="yes" xml:space="preserve">
          <source>A square-bracketed list of characters used in a &lt;b&gt;regular expression&lt;/b&gt; to indicate that any character of the set may occur at a given point. Loosely, any predefined set of characters so used.</source>
          <target state="translated">Список символов в квадратных скобках, используемых в &lt;b&gt;регулярном выражении,&lt;/b&gt; чтобы указать, что любой символ из набора может встречаться в данной точке. Условно так используется любой предопределенный набор символов.</target>
        </trans-unit>
        <trans-unit id="a4537030d9c45923983b601a7f64bbae6c4af141" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Mergesort is stable, quicksort is not. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="translated">Стабильная сортировка означает,что для записей,которые сравнивают равное,сохраняется исходный порядок входных данных.Сортировка по слияниям стабильна,по зыбу-нет.Стабильность будет иметь значение только в том случае,если элементы,которые сравнивают равные,могут быть различимы каким-либо другим образом.Это означает,что простые числовые и лексические сорта не выигрывают от стабильности,так как равные элементы неразличимы.Однако,при таком сравнении,как</target>
        </trans-unit>
        <trans-unit id="aaebd4ab6e5cf8a78012927baac4719189a65694" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc56d9c1394b0fa0321168c0b37750c90b88391" translate="yes" xml:space="preserve">
          <source>A standalone &lt;code&gt;=end&lt;/code&gt; command was found.</source>
          <target state="translated">Обнаружена автономная команда &lt;code&gt;=end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90d81dc6a3e1d8ac5702b6911f4d25957cbc4616" translate="yes" xml:space="preserve">
          <source>A standard C library for doing &lt;b&gt;buffered&lt;/b&gt; input and output to the &lt;b&gt;operating system&lt;/b&gt;. (The &amp;ldquo;standard&amp;rdquo; of standard I/O is at most marginally related to the &amp;ldquo;standard&amp;rdquo; of standard input and output.) In general, Perl relies on whatever implementation of standard I/O a given operating system supplies, so the buffering characteristics of a Perl program on one machine may not exactly match those on another machine. Normally this only influences efficiency, not semantics. If your standard I/O package is doing block buffering and you want it to &lt;b&gt;flush&lt;/b&gt; the buffer more often, just set the &lt;code&gt;$|&lt;/code&gt; variable to a true value.</source>
          <target state="translated">Стандартная библиотека C для &lt;b&gt;буферизованного&lt;/b&gt; ввода и вывода в &lt;b&gt;операционную систему&lt;/b&gt; . (&amp;laquo;Стандарт&amp;raquo; стандартного ввода-вывода в самой незначительной степени связан со &amp;laquo;стандартом&amp;raquo; стандартного ввода-вывода.) В общем, Perl полагается на любую реализацию стандартного ввода-вывода, предоставляемую данной операционной системой, поэтому характеристики буферизации программы Perl на одной машине могут не точно совпадать с программами на другой машине. Обычно это влияет только на эффективность, но не на семантику. Если ваш стандартный пакет ввода-вывода выполняет блочную буферизацию и вы хотите, чтобы он &lt;b&gt;очищал&lt;/b&gt; буфер чаще, просто установите &lt;code&gt;$|&lt;/code&gt; переменной до истинного значения.</target>
        </trans-unit>
        <trans-unit id="ffe116dcbea9e5d21815e3d329637659dd6eec04" translate="yes" xml:space="preserve">
          <source>A standard module whose practical hints and suggestions are received (and possibly ignored) at compile time. Pragmas are named in all lowercase.</source>
          <target state="translated">Стандартный модуль,практические советы и предложения которого поступают (и,возможно,игнорируются)во время компиляции.Прагмы называются во всех нижних регистрах.</target>
        </trans-unit>
        <trans-unit id="3042ccfccce8001b84bc5b8d8019cf025a6017d9" translate="yes" xml:space="preserve">
          <source>A standard, bundled release of a system of software. The default usage implies source code is included. If that is not the case, it will be called a &amp;ldquo;binary-only&amp;rdquo; distribution.</source>
          <target state="translated">Стандартный выпуск системы программного обеспечения в комплекте. Использование по умолчанию подразумевает, что исходный код включен. Если это не так, он будет называться &amp;laquo;только двоичным&amp;raquo; дистрибутивом.</target>
        </trans-unit>
        <trans-unit id="c6647b8f10e57534f902ddf1aa4bccf61236fd6c" translate="yes" xml:space="preserve">
          <source>A statement sequence may contain declarations of lexically-scoped variables, but apart from declaring a variable name, the declaration acts like an ordinary statement, and is elaborated within the sequence of statements as if it were an ordinary statement. That means it actually has both compile-time and run-time effects.</source>
          <target state="translated">Последовательность операторов может содержать объявления лексически осциллируемых переменных,но кроме объявления имени переменной,декларация действует как обычный оператор,и разрабатывается в рамках последовательности операторов,как если бы это был обычный оператор.Это означает,что на самом деле она имеет эффект как компиляции,так и выполнения.</target>
        </trans-unit>
        <trans-unit id="fa46e467d8cdc232f6a66d28e35057665324ee9f" translate="yes" xml:space="preserve">
          <source>A string (char *).</source>
          <target state="translated">Строка (char *).</target>
        </trans-unit>
        <trans-unit id="75e5df3441233543315a78a7205a2debb8ad739c" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">Строка &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; анализирует свое выражение как стандартный Perl. Поэтому ожидается, что десятичная точка будет точкой. Если для &lt;code&gt;LC_NUMERIC&lt;/code&gt; вместо этого используется запятая, синтаксический анализ будет запутанным, возможно, незаметно.</target>
        </trans-unit>
        <trans-unit id="e32ce4794e8e4c22eb37cafd0ff465a6583267c2" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9568afdc53a4a7f1711d767a18a8d9f968593e6" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt; tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">Строка, начинающаяся с &lt;code&gt;CLISYM_&lt;/code&gt; , сообщает Perl о необходимости обращаться к таблицам символов CLI, используя</target>
        </trans-unit>
        <trans-unit id="f111ed51d2b3bdc540d8eea8f3e95bb03014421d" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt;tells Perl to consult the CLI's symbol tables, using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73539349cf3164d1f6eed3ab55aa660f24e3b757" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;&quot;'&amp;gt; will be encoded numerically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb88c9d62f1cca49157633840f22b59a116a8ab" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">Строка, содержащая все символы, которые должны быть закодированы как объекты HTML, указанные с использованием синтаксиса класса символов регулярного выражения (то, что вы найдете в квадратных скобках в регулярных выражениях). Это значение будет передано в качестве второго аргумента функции &lt;code&gt;encode_entities&lt;/code&gt; &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt; . Если &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt; не установлен, то любые символы, кроме &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &quot;'&amp;gt;, будут кодироваться численно.</target>
        </trans-unit>
        <trans-unit id="2c6988b512688bb605e69e65500198db5054baa8" translate="yes" xml:space="preserve">
          <source>A string containing the text of a message to print</source>
          <target state="translated">Строка,содержащая текст сообщения для печати.</target>
        </trans-unit>
        <trans-unit id="bf5bf16fd07f45d581debfd5241308f05f5b876d" translate="yes" xml:space="preserve">
          <source>A string corresponding to the desired output file (or &quot;&amp;gt;&amp;amp;STDOUT&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot;), or a filehandle to write on. The default is to use standard output.</source>
          <target state="translated">Строка, соответствующая желаемому выходному файлу (или &quot;&amp;gt; &amp;amp; STDOUT&quot; или &quot;&amp;gt; &amp;amp; STDERR&quot;), или дескриптор файла для записи. По умолчанию используется стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="e81c48705eb13d4df1f22c2acd8523f46384c993" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt; ). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">Строка, заключенная в обратные кавычки (серьезные акценты), сначала подвергается интерполяции в двойные кавычки. Затем он интерпретируется как внешняя команда, и вывод этой команды - это значение строки обратного апострофа, как в оболочке. В скалярном контексте возвращается одна строка, состоящая из всего вывода. В контексте списка возвращается список значений, по одному на строку вывода. (Вы можете установить &lt;code&gt;$/&lt;/code&gt; для использования другого символа конца строки.) Команда выполняется каждый раз, когда вычисляется псевдолитерал. Значение статуса команды возвращается в &lt;code&gt;$?&lt;/code&gt; (см. &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; для интерпретации &lt;code&gt;$?&lt;/code&gt; ). В отличие от &lt;b&gt;csh&lt;/b&gt;, перевод возвращаемых данных не выполняется - новые строки остаются новыми строками. В отличие от любой другой оболочки, одинарные кавычки не скрывают имена переменных в команде от интерпретации. Чтобы передать в оболочку буквальный знак доллара, вам нужно скрыть его обратной косой чертой. Обобщенная форма обратных кавычек - &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; . (Поскольку обратные кавычки также всегда подвергаются расширению оболочки, см. &lt;a href=&quot;perlsec&quot;&gt;Perlsec&lt;/a&gt; для вопросов безопасности.)</target>
        </trans-unit>
        <trans-unit id="6a59c28b10f1e469c8f302761a4c4403491075e7" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt;). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;qx//&lt;/code&gt;, or you can call the &lt;a href=&quot;perlfunc#readpipe&quot;&gt;&quot;readpipe&quot; in perlfunc&lt;/a&gt; function. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8188c86cb7ff03c08e73a3bf26c2466b54d74c0a" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (but never shorter) than one encoded in UTF-8. Perl extends UTF-8 so that it can encode code points above the Unicode maximum of U+10FFFF. It extends UTF-EBCDIC as well, but due to the inherent limitations in UTF-EBCDIC, the maximum code point expressible is U+7FFF_FFFF, even if the word size is more than 32 bits.</source>
          <target state="translated">Строка в кодировке UTF-EBCDIC может быть длиннее (но никогда не короче),чем строка в кодировке UTF-8.Perl расширяет UTF-8 так,чтобы он мог кодировать точки кода выше максимума Unicode в U+10FFFF.Он также расширяет UTF-EBCDIC,но из-за ограничений,присущих UTF-EBCDIC,максимальная точка кода,которая может быть экспрессирована,равна U+7FFF_FFFFF,даже если размер слова больше 32 бит.</target>
        </trans-unit>
        <trans-unit id="914a74b444d9ba99a9fe1b62c1ecf5a7f252527d" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (very rarely shorter) than one encoded in UTF-8. Perl extends both UTF-8 and UTF-EBCDIC so that they can encode code points above the Unicode maximum of U+10FFFF. Both extensions are constructed to allow encoding of any code point that fits in a 64-bit word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4917965ca44eb0c4faae94a841c4f89027d6938" translate="yes" xml:space="preserve">
          <source>A string of alternative option starter characters may be passed as the first argument (or the first argument after a leading hash reference argument).</source>
          <target state="translated">В качестве первого аргумента (или первого аргумента после ведущего аргумента ссылки на хэш)может быть передана строка альтернативных начальных символов опции.</target>
        </trans-unit>
        <trans-unit id="88c258b6d0e7c9ac246c86ffd1bb6de9b44ef38f" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c47b9481cf147721b670360f462acc06f6b68e" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">Строка переносимых печатных символов. Это представление дайджеста в кодировке base64 с удаленным завершающим заполнением. Строка будет примерно на 30% длиннее двоичной версии. &lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt; расскажет вам больше об этой кодировке.</target>
        </trans-unit>
        <trans-unit id="1b085cd0478f87c6aa68ec36d4064dfac1577470" translate="yes" xml:space="preserve">
          <source>A string of zero or more characters from &lt;code&gt;&quot;achorst&quot;&lt;/code&gt; [see &lt;code&gt;attrLetsToBits&lt;/code&gt; for more information] which are converted to &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; bits to be set in the &lt;code&gt;$uFlags&lt;/code&gt; argument passed to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
