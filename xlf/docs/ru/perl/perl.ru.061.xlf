<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">В следующем примере показано, как использовать параметр &lt;code&gt;LimitOutput&lt;/code&gt; . Обратите внимание на использование двух вложенных циклов в этом случае. Внешний цикл считывает данные из источника ввода - STDIN, а внутренний цикл многократно вызывает &lt;code&gt;inflate&lt;/code&gt; до тех пор, пока &lt;code&gt;$input&lt;/code&gt; будет исчерпан, мы не получим ошибку или не будет достигнут конец потока. Следует помнить один момент: используя параметр &lt;code&gt;LimitOutput&lt;/code&gt; , вы также получаете набор &lt;code&gt;ConsumeInput&lt;/code&gt; - это значительно упрощает приведенный ниже код.</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">В следующем примере показан каждый входной параметр,обработанный с опозданием.</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">В следующих примерах будет использоваться следующий класс C++.</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">Следующий вариант связан с кодовым набором (так же известным как набор символов),который поддерживает ваш терминал.В общем,CPAN является англоязычной территорией,поэтому кодовая таблица не имеет большого значения,но некоторые CPAN имеют имена,которые находятся за пределами диапазона ASCII.Если ваш терминал поддерживает UTF-8,вы должны сказать &quot;нет&quot; следующему вопросу.Если он ожидает ISO-8859-1 (также известный как LATIN1),то вы должны сказать &quot;да&quot;.Если он не поддерживает ни то,ни другое,ваш ответ не имеет значения,потому что вы все равно не сможете прочитать имена некоторых авторов.Если вы ответите &quot;нет&quot;,имена будут выведены в UTF-8.</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">Следующий указатель для &lt;code&gt;BRANCH&lt;/code&gt; es интересен тем, что он указывает, куда должно идти выполнение, если ветвление завершится неудачей. При выполнении, если движок пытается перейти от ветки к &lt;code&gt;regnext&lt;/code&gt; , который не является ветвью, то движок будет знать, что весь набор ветвей потерпел неудачу.</target>
        </trans-unit>
        <trans-unit id="49d098f677fc7d28016366882913ea295f0ea710" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt;es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">Следующий шаг-интерполяция в полученном тексте,который теперь является разделительно-независимым.Случаев несколько.</target>
        </trans-unit>
        <trans-unit id="2e9d420a49c5570abf7ae9f3e075e9465afea859" translate="yes" xml:space="preserve">
          <source>The next step is the type-specific context processing; in this case &lt;code&gt;cx_popsub&lt;/code&gt;. In part, this looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b245543afec9985d508833acde280bdb2e09df89" translate="yes" xml:space="preserve">
          <source>The next step is to add some symlinks to system libraries. For example, the development software expect a library &lt;code&gt;libm.so&lt;/code&gt; that normally is a symlink to &lt;code&gt;libm.so.6&lt;/code&gt;. Synology only provides the latter and not the symlink.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e87f516f02471787ab2f018e28d7851e0ac5f9" translate="yes" xml:space="preserve">
          <source>The next step is to pop savestack entries: &lt;code&gt;CX_LEAVE_SCOPE(cx)&lt;/code&gt; is just defined as &lt;code&gt;LEAVE_SCOPE(cx-&amp;gt;blk_oldsaveix)&lt;/code&gt;. Note that during the popping, it's possible for perl to call destructors, call &lt;code&gt;STORE&lt;/code&gt; to undo localisations of tied vars, and so on. Any of these can die or call &lt;code&gt;exit()&lt;/code&gt;. In this case, &lt;code&gt;dounwind()&lt;/code&gt; will be called, and the current context stack frame will be re-processed. Thus it is vital that all steps in popping a context are done in such a way to support reentrancy. The other alternative, of decrementing &lt;code&gt;cxstack_ix&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">Следующий шаг-отправить патч в основную билетную систему Perl по электронной почте.</target>
        </trans-unit>
        <trans-unit id="c53212a853da747bb753ac0eb206bd02a60002ca" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">Следующая задача-разбить проблему на более мелкие проблемы,которые легко преобразуются в регеxp.</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">В следующий раз,когда вы захотите сделать заплатку,вы должны начать с последнего perl в первозданном виде.Проверьте,нет ли у вас локальных изменений или добавленных файлов на perl,которые вы хотите сохранить,затем запустите эти команды:</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">Хорошая часть о тестах todo,в отличие от простого комментирования блока тестов,это как иметь программный список todo.Вы знаете,сколько работы осталось сделать,вы знаете,какие есть ошибки,и сразу же узнаете,когда они будут исправлены.</target>
        </trans-unit>
        <trans-unit id="93f6c477375802df02f9578f889b424f60ac9928" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that it is like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">Для сборки достаточно nmake, поставляемого с Visual C ++. Visual C требует, чтобы определенные вещи были настроены в консоли, прежде чем Visual C успешно запустится. Чтобы консоль могла запускать компилятор C, вам необходимо заранее запустить файл &lt;code&gt;vcvars32.bat&lt;/code&gt; для компиляции для x86-32 и для x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; или &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . При типичной установке продукта компилятора Microsoft C эти командные файлы уже будут в вашем &lt;code&gt;PATH&lt;/code&gt; переменная среды, поэтому вы можете просто ввести их без абсолютного пути в консоль. Если вам нужно найти абсолютный путь к пакетному файлу, он обычно находится где-то вроде C: \ Program Files \ Microsoft Visual Studio \ VC98 \ Bin. В некоторых новых продуктах Micrsoft C (выпущенных после ~ 2004 г.) программа установки поместит ярлык в меню &amp;laquo;Пуск&amp;raquo; для запуска нового окна консоли с консолью, уже настроенной для вашей целевой архитектуры (x86-32 или x86-64 или IA64). . С более новыми компиляторами вы также можете использовать старые командные файлы, если захотите.</target>
        </trans-unit>
        <trans-unit id="74b0871cc8ecf5b8ec07f0886c93ea7f99f29900" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C++ requires that certain things be set up in the console before Visual C++ will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run &lt;code&gt;vcvarsall.bat x86&lt;/code&gt; to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat amd64&lt;/code&gt;. On a typical install of a Microsoft C++ compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">Nmake,которая поставляется с Платформой SDK,будет достаточно для создания Perl.Убедитесь,что вы собираете в одной из оболочек &quot;Build Environment&quot;,доступных после установки Комплекта SDK для платформы из меню &quot;Пуск&quot;.</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Тип узла: &lt;code&gt;section&lt;/code&gt; или &lt;code&gt;item&lt;/code&gt; . В качестве неофициального типа существует также &lt;code&gt;hyperlink&lt;/code&gt; , производная, например, от &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d0e0bd31f6a31a67e6263a3a5396fe920511c99" translate="yes" xml:space="preserve">
          <source>The non-ASCII characters below 256 can have various meanings, depending on various things. (See, most notably, &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) But usually the whole range can be referred to as ISO-8859-1. Often, the term &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to the characters in the range 128 through 255, or somethimes from 160 through 255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to refer to all 256 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6361a2e3097d12a5b1db2175b6f9b22e2b4e005e" translate="yes" xml:space="preserve">
          <source>The non-blocking behaviour is an extension of the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, unique to &lt;code&gt;IO::Socket::IP&lt;/code&gt;, because the former does not support multi-homed non-blocking connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">Неразрушающий модификатор &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; приводит к возврату результата подстановки вместо изменения &lt;code&gt;$_&lt;/code&gt; (или любой другой переменной, к которой подстановка была привязана с помощью &lt;code&gt;=~&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="33ea7bc6a1364954efde1784eb70e926a46ab789" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;s///r&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">Ненулевое число</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">Обычный Makefile.PL,который генерирует h2xs,не знает о каталоге mylib.Мы должны сказать ему,что есть подкаталог,и что мы будем генерировать в нем библиотеку.Добавим аргумент MYEXTLIB к вызову WriteMakefile,чтобы он выглядел так:</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">Обычное дело-позвонить:</target>
        </trans-unit>
        <trans-unit id="32723b8237682738b9e39db42e26b25a535a8b05" translate="yes" xml:space="preserve">
          <source>The normal return provided by &lt;code&gt;scalar(%hash)&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements). [ This paragraph needs review in light of changes in 5.25 ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">Обычное использование этого класса так и есть:</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">Обычный способ запустить программу Perl - сделать ее непосредственно исполняемой или передать имя исходного файла в качестве аргумента в командной строке. (Также возможна интерактивная среда Perl - см. &lt;a href=&quot;perldebug&quot;&gt;Perldebug,&lt;/a&gt; чтобы узнать, как это сделать.) При запуске Perl ищет вашу программу в одном из следующих мест:</target>
        </trans-unit>
        <trans-unit id="42b613b12f582e26d7e800d066ea1eb52e714a90" translate="yes" xml:space="preserve">
          <source>The not-a-number as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">Нотация все еще выглядит немного громоздкой,так что есть еще одна аббревиатура:</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">Представление о том, что пустой &lt;b&gt;производный класс&lt;/b&gt; должен вести себя точно так же, как его &lt;b&gt;базовый класс&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">Представление о том, что вы можете указать &lt;b&gt;объекту&lt;/b&gt; выполнить что-то общее, и объект будет интерпретировать команду по-разному в зависимости от ее типа. [&amp;lt;Греч. &amp;Pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, много форм.]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">Идея о том, что с полным набором простых инструментов, которые хорошо работают вместе, вы можете построить практически все, что захотите. Это нормально, если вы собираете трехколесный велосипед, но если вы собираете регургалатор comboflux с дефранизацией, вам действительно нужен собственный цех, в котором можно будет создавать специальные инструменты. Perl - это что-то вроде механического цеха.</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">Нулевой дескриптор файла &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; является особенным: его можно использовать для эмуляции поведения &lt;b&gt;sed&lt;/b&gt; и &lt;b&gt;awk&lt;/b&gt; , а также любой другой программы фильтрации Unix, которая принимает список имен файлов, делая то же самое для каждой строки ввода от всех из них. Входные данные из &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; поступают либо из стандартного ввода, либо из каждого файла, указанного в командной строке. Вот как это работает: при первом вычислении &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;code&gt;@ARGV&lt;/code&gt; массив @ARGV , и если он пуст, &lt;code&gt;$ARGV[0]&lt;/code&gt; устанавливается в &lt;code&gt;&quot;-&quot;&lt;/code&gt; , что при открытии дает стандартный ввод. Затем массив &lt;code&gt;@ARGV&lt;/code&gt; обрабатывается как список имен файлов. Петля</target>
        </trans-unit>
        <trans-unit id="2eb5648c665e9498b1d4e1c662b451796e069c6c" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">Нулевой список представлен фигурой ().Интерполяция его в списке не имеет никакого эффекта.Таким образом,функция ((),(),())эквивалентна функции ().Аналогично,интерполяция массива без элементов такая же,как если бы в этот момент не было интерполировано ни одного массива.</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">Время цикла нуля может быть кэшировано,ключом является количество циклов.Кэшированием можно управлять с помощью подобных вызовов:</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">Число 0, строки &lt;code&gt;'0'&lt;/code&gt; и &lt;code&gt;&quot;&quot;&lt;/code&gt; , пустой список &lt;code&gt;()&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в логическом контексте ложны. Все остальные значения верны. Отрицание истинной ценности &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; возвращает специальное ложное значение. При оценке в виде строки он обрабатывается как &lt;code&gt;&quot;&quot;&lt;/code&gt; , но как число он обрабатывается как 0. Большинство операторов Perl, возвращающих истину или ложь, ведут себя подобным образом.</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">Номер после Perl (т.е.5 после Perl 5)является основным выпуском perl-переводчика,а также версией языка.Каждая основная версия имеет существенные различия,которые не могут быть поддержаны более ранними версиями.</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">Номер для &quot;генерации&quot; тестового прогона.Первое поколение-1 (одно),а последующие-2,3 и т.д.</target>
        </trans-unit>
        <trans-unit id="2535d279c5200f7be07d31d15ce44068cdb20ffd" translate="yes" xml:space="preserve">
          <source>The number of &quot;hidden&quot; sectors for this partition. Actually this is the number of sectors found prior to this partition, that is, the starting offset [as found in &lt;code&gt;$uStartLow&lt;/code&gt; and &lt;code&gt;$ivStartHigh&lt;/code&gt;] divided by the number of bytes per sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a9d7413ce0d5ac2d4144491992bf44868224aa" translate="yes" xml:space="preserve">
          <source>The number of bytes in each sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">Количество параллельных заданий,с которыми будет работать эта форматура.</target>
        </trans-unit>
        <trans-unit id="36ffefa76cdb58a51fa74dc31caa513844b361e2" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after &lt;code&gt;av_fill()&lt;/code&gt; returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">Количество элементов в массиве будет &lt;code&gt;fill + 1&lt;/code&gt; после возврата av_fill (). Если ранее массив был короче, то добавляемые дополнительные элементы устанавливаются в NULL. Если массив был длиннее, то лишние элементы освобождаются. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; совпадает с &lt;code&gt;av_clear(av)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">Количество элементов в хэше можно получить,сделав это:</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">Количество строк,оставшихся на странице текущего выбранного выходного канала.</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">Количество строк, прочитанных до этой, плюс 1. Perl сохраняет отдельный номер строки для каждого исходного или входного файла, который он открывает. Номер строки текущего исходного файла представлен как &lt;code&gt;__LINE__&lt;/code&gt; . Текущий номер строки ввода (для файла, который был прочитан последним через &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) представлен символом &lt;code&gt;$.&lt;/code&gt; ( &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) переменная. Во многих сообщениях об ошибках указываются оба значения, если они доступны.</target>
        </trans-unit>
        <trans-unit id="2c32dc65a0983301d8b932b2ff7d13fbe8041de2" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt;. The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt;) variable. Many error messages report both values, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26ea7021e22061094b1160120712623c26587e" translate="yes" xml:space="preserve">
          <source>The number of retrieval pointers that RMS has to maintain (0 to 127255)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">Количество секунд,в течение которых программа выполнялась перед завершением,или 0,если таймаут не наступил.</target>
        </trans-unit>
        <trans-unit id="3f0ee453c0514a141454bf624811de74f7121fbc" translate="yes" xml:space="preserve">
          <source>The number of sectors in each track.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">Количество пробелов для отступа обычного текста и отступ по умолчанию для &lt;code&gt;=over&lt;/code&gt; блоками. По умолчанию 4.</target>
        </trans-unit>
        <trans-unit id="e68baf88a8ecb32bf1315047769f8d0e186bb5f6" translate="yes" xml:space="preserve">
          <source>The number of tests actually seen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">Количество тестов в вашем сценарии.Это означает все вызовы ok()и skip().</target>
        </trans-unit>
        <trans-unit id="7a3c79429902da3d2d3d81b8c529fe97388165ba" translate="yes" xml:space="preserve">
          <source>The number of tests that were planned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e2b7e50e91d743cd4a7b27aa45939dc1c6581f" translate="yes" xml:space="preserve">
          <source>The number of tests which failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">Количество тестов с директивами TODO.</target>
        </trans-unit>
        <trans-unit id="134bbf3c12ccdb3b17c2429c883dacdca5457a57" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">Количество ссылок на структуру. Когда оно падает до 0, регулярное выражение автоматически освобождается вызовом pregfree. Это должно быть установлено на 1 в программе &lt;a href=&quot;#comp&quot;&gt;компенсации&lt;/a&gt; каждого двигателя .</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">Количество неудачных тестов.</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">Количество пройденных тестов.</target>
        </trans-unit>
        <trans-unit id="1ea0b9d7d53aa08d0e622974bcb543d8e9e34567" translate="yes" xml:space="preserve">
          <source>The number of tracks in each cylinder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">Нумерация внутри каждой ветви будет как обычно,и любые группы,следующие за этой конструкцией,будут пронумерованы так,как если бы конструкция содержала только одну ветвь,которая является той,в которой находится больше всего захватывающих групп.</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Числа хранятся как объекты,и их внутренняя часть может измениться в любое время,особенно между математическими операциями.Объекты также могут принадлежать различным классам,таким как Math::BigInt или Math::BigFloat.Смешивание их вместе,даже при нормальных скалярах,не является экстраординарным,а нормальным и ожидаемым.</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Числа хранятся как объекты,и их внутренняя часть может измениться в любое время,особенно между математическими операциями.Объекты также могут принадлежать различным классам,таким как Math::BigInt или Math::BigInt::Lite.Смешивание их вместе,даже при нормальных скалярах,не является экстраординарным,а нормальным и ожидаемым.</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">Режим числовых разрешений, применяемый к каждому созданному каталогу (по умолчанию 0777), который должен быть изменен текущей &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; . Если каталог уже существует (и, следовательно, его не нужно создавать), разрешения не будут изменены.</target>
        </trans-unit>
        <trans-unit id="5dffd7d41fb958bc0c87e558861a514e1606e35f" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to &lt;code&gt;0777&lt;/code&gt;), to be modified by the current &lt;code&gt;umask&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">Числовое значение флагов подсказки COP,или пустая строка,если это не COP.</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">Числовое значение флагов ОП.</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">Числовое значение частных флагов ОП.</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">Числовое значение ТАРГА ОП.</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">Числовое значение типа ОП,в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="38a4063b54e70e2579ef41b45391d9edbcb80e9f" translate="yes" xml:space="preserve">
          <source>The object actually used is of the class &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt; which allows you to override bits of MakeMaker inside your Makefile.PL by declaring MY::foo() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">Объект повторно благословляется в подкласс &lt;code&gt;IO::Handle&lt;/code&gt; и становится дескриптором на считывающем конце канала. Если заданы &lt;code&gt;ARGS&lt;/code&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;ARGS&lt;/code&gt; передаются в exec.</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">Объект повторно благословляется в подкласс &lt;code&gt;IO::Handle&lt;/code&gt; и становится дескриптором на записывающем конце канала. Если заданы &lt;code&gt;ARGS&lt;/code&gt; , вызывается &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;ARGS&lt;/code&gt; передаются в exec.</target>
        </trans-unit>
        <trans-unit id="fc8e459a67162585ed649c073732c1f153656661" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960d4697beb3f7754f165a72fa86b9e206ef71bf" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">Объект или класс, для которого вызывается метод, передается как один из аргументов метода, а не как отдельное значение &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac2428a9234f597f267cadbd7f0f16da4708e348" translate="yes" xml:space="preserve">
          <source>The object oriented interface lets you configure your own encoding or decoding style, within the limits of supported formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">В этом разделе описывается объектно-ориентированный интерфейс к &lt;code&gt;Digest::MD5&lt;/code&gt; . После создания объекта &lt;code&gt;Digest::MD5&lt;/code&gt; вы добавите к нему данные и, наконец, запросите дайджест в подходящем формате. Один объект можно использовать для вычисления нескольких дайджестов.</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">Реестр объектов также используется для ремонта хэша полей после клонирования потока.Здесь обрабатывается весь объектный реестр.Для каждой найденной там ссылки,хэши полей,которые он использовал,посещаются и запись обновляется.</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">Реестр объектов отслеживает ссылки, которые использовались в качестве ключей хеширования полей. Ключи генерируются из ссылочного адреса, как в хэше поля (хотя реестр не является хешем поля). Каждое значение является слабой копией исходной ссылки, хранящейся в &lt;code&gt;SV&lt;/code&gt; , который сам по себе является магическим ( снова &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; ). Магическая структура содержит список (на самом деле еще один хеш) хешей полей, с которыми использовалась ссылка. Когда weakref становится устаревшим, магия активируется и использует список для удаления ссылки из всех хэшей полей, с которыми она использовалась. После этого запись удаляется из самого реестра объектов. Неявно это освобождает магическую структуру и хранилище, которое она использовала.</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">Объект, возвращаемый &lt;code&gt;builder()&lt;/code&gt; может измениться во время выполнения, поэтому вы должны вызывать &lt;code&gt;builder()&lt;/code&gt; внутри каждой функции, а не сохранять его в глобальном.</target>
        </trans-unit>
        <trans-unit id="0c2931896c0ae38a7dcf1ceb36dc3228043fb889" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce4a435aaab3b8ce3beeeab8876d2f9007b9517" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON number value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">Функция oct () обычно используется, когда, например, строку типа &lt;code&gt;644&lt;/code&gt; необходимо преобразовать в файловый режим. Хотя Perl автоматически преобразует строки в числа по мере необходимости, это автоматическое преобразование предполагает основание 10.</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">Официальные (многопоточные) сборки HP, поставляемые на DVD / CD с приложениями, доступны на &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; для обоих PA-RISC. и IPF (Семейство процессоров Itanium). Они построены с помощью компилятора HP ANSI-C. До 5.8.8 этим занимался ActiveState.</target>
        </trans-unit>
        <trans-unit id="94afd3df7a7936cd7021df875b7cc881f99b3a21" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at GitHub. Posting to the list and the bugtracker is not a right: all participants in discussion are expected to adhere to a standard of conduct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">Официальным форумом для разработки perl является список рассылки perl5-портеров,упомянутый выше,и его багтрекер на rt.perl.org.Ожидается,что все участники дискуссии там будут придерживаться стандарта поведения.</target>
        </trans-unit>
        <trans-unit id="206093c38ad914ff8435f60fe865bef14dbff945" translate="yes" xml:space="preserve">
          <source>The official home of this project on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">Официальное название VMS на момент написания статьи-OpenVMS.</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">Официальный сайт Berkeley DB является</target>
        </trans-unit>
        <trans-unit id="9ae89a7a7356b47202ed85668f00ace437b2ed69" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;. All versions of Berkeley DB are available there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b569f6bcadd4a6fd7badb484a162b25dd85b5b2" translate="yes" xml:space="preserve">
          <source>The offset from the start of the file in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba5881483f263a1268bc8d8cd7d41b8c76ce28" translate="yes" xml:space="preserve">
          <source>The old behavior is currently retained, warts and all, for backwards compatibility, but users are encouraged to change any code that tests &lt;code&gt;$!&lt;/code&gt; against &lt;code&gt;E*&lt;/code&gt; constants for Winsock errors to instead test &lt;code&gt;$^E&lt;/code&gt; against &lt;code&gt;WSAE*&lt;/code&gt; constants. After a suitable deprecation period, which started with Perl 5.24, the old behavior may be removed, leaving &lt;code&gt;$!&lt;/code&gt; unchanged after Winsock function calls, to avoid any possible confusion over which error variable to check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">Старое поведение немедленного кваканья можно восстановить, установив для &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; некоторое значение &lt;code&gt;FALSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">Старый стиль формата отображения, который может иметь значения &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; или &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , можно изменить с помощью параметра &lt;code&gt;&quot;style&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9569a2edc0d7e856dea14bff6ac690edcc52042" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt;, can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffd1da07401f04d08ba15b9c723b21da5d25d24" translate="yes" xml:space="preserve">
          <source>The old form of &lt;code&gt;gv_init_pvn()&lt;/code&gt;. It does not work with UTF-8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag will be passed to &lt;code&gt;gv_init_pvn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">Старая форма gv_init_pvn (). Он не работает со строками UTF8, так как не имеет параметра flags. Если установлен параметр &lt;code&gt;multi&lt;/code&gt; , флаг GV_ADDMULTI будет передан в gv_init_pvn ().</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">Старый дом для модульных тестов,не стоит ставить сюда ничего нового.Здесь все еще есть несколько кусочков,которые нужно перевезти.Может,вы могли бы их переместить? Спасибо!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">Старым разделителем пакетов была одинарная кавычка, но теперь предпочтительным разделителем является двойное двоеточие, отчасти потому, что он более читается для людей, а отчасти потому, что он более читается для макросов &lt;b&gt;emacs&lt;/b&gt; . Это также заставляет программистов на C ++ чувствовать, что они знают, что происходит, - в отличие от использования одинарной кавычки в качестве разделителя, который был нужен для того, чтобы программисты Ada чувствовали, что они знают, что происходит. Поскольку старомодный синтаксис все еще поддерживается для обратной совместимости, если вы попытаетесь использовать строку типа &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , вы получите доступ к &lt;code&gt;$owner::s&lt;/code&gt; ; то есть переменная $ s в &lt;code&gt;owner&lt;/code&gt; пакета , что, вероятно, не то, что вы имели в виду. Используйте фигурные скобки для устранения неоднозначности, например, &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="511ae26f8725e1c7736ec75894aed8905e42064b" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt;, you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt;; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt;, which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9379928fc066063abf44caaff061ee5071ad9c7" translate="yes" xml:space="preserve">
          <source>The old style indented the note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9dec9262d361c18938bccf6c6a18acfa10894f" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">Старые (и, возможно, устаревшие) библиотеки &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3a69ba409143423723e457fea838a29577af44" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">Старые библиотеки &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">Форма с одним аргументом add_bits () принимает в качестве аргумента строку $ bitstring из &quot;1&quot; и &quot;0&quot; символов. Это сокращение от &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b86570e54f795ca97d5fe14e7650da16943e0a5" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">Единственное соглашение по вызову параметров также работает.</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">Единственный пользователь (кроме суперпользователя), который имеет полный контроль над &lt;b&gt;файлом&lt;/b&gt; . Файл также может иметь &lt;b&gt;группу&lt;/b&gt; пользователей, которые могут осуществлять совместное владение, если это разрешено реальным владельцем. См. &lt;b&gt;Биты разрешений&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb6da0a473e0cefde4e91abce89bab9a6e1b78a" translate="yes" xml:space="preserve">
          <source>The one-shot interface allows you to force the creation of a zip64 zip file by including the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">Единственный абсолютно обязательный метод. Вызывается, когда слой помещается в стек. &lt;code&gt;mode&lt;/code&gt; аргумент может быть NULL , если это происходит после открытой. &lt;code&gt;arg&lt;/code&gt; будет не- &lt;code&gt;NULL&lt;/code&gt; , если строка аргумента была принята. В большинстве случаев это должно вызывать &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; для преобразования &lt;code&gt;mode&lt;/code&gt; в соответствующие флаги &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; в дополнение к любым действиям, предпринимаемым самим слоем. Если уровень не ожидает аргумента, ему не нужно ни сохранять переданный ему аргумент, ни предоставлять &lt;code&gt;Getarg()&lt;/code&gt; (возможно, &lt;code&gt;Perl_warn&lt;/code&gt; может указать, что аргумент был неожиданным ).</target>
        </trans-unit>
        <trans-unit id="90a79e3c54ca5ed09d00dcfacad6096dece33202" translate="yes" xml:space="preserve">
          <source>The only characters this accepts are the decimal digits '0'..'9'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">Единственные различия связаны с тем, что &lt;code&gt;string_vianame&lt;/code&gt; - это время выполнения, а &lt;code&gt;\N{}&lt;/code&gt; - время компиляции. Вы не можете интерполировать внутри &lt;code&gt;\N{}&lt;/code&gt; (поэтому &lt;code&gt;\N{$variable}&lt;/code&gt; не работает); а если имя входа неизвестно, &lt;code&gt;string_vianame&lt;/code&gt; возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; вместо синтаксической ошибки.</target>
        </trans-unit>
        <trans-unit id="77845b478b84dee4e594bd5bbec241147d4e6e80" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt;, (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">Единственным указанным флагом на этот раз был G_SCALAR. Это означает, что будет создан массив &lt;code&gt;@_&lt;/code&gt; и что значение, возвращаемое</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">Единственная интерполяция - это удаление &lt;code&gt;\&lt;/code&gt; из пар &lt;code&gt;\\&lt;/code&gt; . Поэтому &lt;code&gt;&quot;-&quot;&lt;/code&gt; в &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; трактуется буквально как дефис, и диапазон символов недоступен. &lt;code&gt;\1&lt;/code&gt; в замене &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; не работает как &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02eece87de941c6c62eda48e906abba6c3ece7c9" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt;. Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;tr'''&lt;/code&gt; and &lt;code&gt;y'''&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;s'''&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">Осталась только одна проблема-как загрузиться.</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">Единственный вид простых операторов - это выражение, оцениваемое на предмет его побочных эффектов. Каждый простой оператор должен заканчиваться точкой с запятой, если только это не последний оператор в блоке, и в этом случае точка с запятой не является обязательной. Но все равно ставьте точку с запятой, если блок занимает более одной строки, потому что в конечном итоге вы можете добавить еще одну строку. Обратите внимание, что есть такие операторы, как &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; , которые</target>
        </trans-unit>
        <trans-unit id="f705477ccbb186a38ab86005af82f68dd900e475" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;eval {}&lt;/code&gt;, &lt;code&gt;sub {}&lt;/code&gt;, and &lt;code&gt;do {}&lt;/code&gt; that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e309b7f80a25c25de4d7facad82c2d1078752823" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;&quot;Prior to Perl v5.22&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">Единственное законное использование этой прагмы - это почти наверняка только по одному на файл, в верхней части, с областью действия файла, поскольку файл, вероятно, будет записан только в одной кодировке. Дальнейшие ограничения применяются в &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Perl&lt;/a&gt; до v5.22 (см. До Perl v5.22 ).</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Единственная локаль для многобайтовых (или широких символов), которую Perl может поддерживать, - это UTF-8. Это связано со сложностью реализации, тем фактом, что высококачественные локали UTF-8 теперь публикуются для всех регионов мира ( &lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt; ), и что в противном случае вы можно использовать &lt;a href=&quot;encode&quot;&gt;кодирование&lt;/a&gt;модуль для перевода на / из вашей локали. Итак, вам придется сделать одну из этих вещей, если вы используете одну из этих локалей, например Big5 или Shift JIS. Для локалей UTF-8 в Perls (до версии 5.20), которые не имеют полной поддержки локали UTF-8, они могут работать достаточно хорошо (в зависимости от реализации вашей библиотеки C) просто потому, что и они, и Perl хранят символы, которые занимают несколько байтов одинаково. Однако некоторые, если не большинство, реализаций библиотеки C могут не обрабатывать символы в верхней половине диапазона Latin-1 (128&amp;ndash;255) должным образом в &lt;code&gt;LC_CTYPE&lt;/code&gt; . Чтобы узнать, относится ли символ к определенному типу в локали, Perl использует такие функции, как &lt;code&gt;isalnum()&lt;/code&gt; . Ваша библиотека C может не работать для локалей UTF-8 с этими функциями,вместо этого работает только с новыми широкими библиотечными функциями, такими как &lt;code&gt;iswalnum()&lt;/code&gt; , который Perl не использует. Эти многобайтовые языковые стандарты рассматриваются как однобайтовые языковые стандарты и будут иметь ограничения, описанные ниже. Начиная с Perl v5.22, появляется предупреждение, когда Perl обнаруживает многобайтовый языковой стандарт, который он не поддерживает полностью.</target>
        </trans-unit>
        <trans-unit id="18871d07c0f1be22042f9cbee3498004b8a18ce9" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; for ones that are already set-up, but from an earlier version; &lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt; for the most up-to-date, but you have to extract the POSIX information yourself), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt;. To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt;. Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt;, which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c17b3d145791de4c679a21722f34ee793cec0ff" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;&quot;charnames::string_vianame(name)&quot; in charnames&lt;/a&gt;, and &lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;&quot;namedseq()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Единственное несимвольное свойство, которое в настоящее время поддерживает Perl, - это именованные последовательности, в которых последовательности кодовых точек присваивается имя и обычно обрабатывается как единое целое. (Perl поддерживает их с помощью конструкции с двойными кавычками &lt;code&gt;\N{...}&lt;/code&gt; , &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame (name) в именах символов&lt;/a&gt; и &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq () в Unicode :: UCD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">Единственной несингл-байтовой поддержкой Perl является (начиная с версии 5.20)UTF-8.Это означает,что точки кода выше 255 рассматриваются как Юникод вне зависимости от того,какая локаль действует (так как UTF-8 подразумевает Юникод).</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">Единственное объективное преимущество использования &lt;code&gt;DirHandle&lt;/code&gt; состоит в том, что он позволяет избежать загрязнения пространства имен за счет создания глобусов для хранения дескрипторов каталогов.</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">Единственным ограничением является то,что вы должны предварительно объявить,сколько тестов вы планируете запустить.Это в случае,если что-то пойдет ужасно не так во время теста,и ваша тестовая программа прервется,или пропустит тест или что-то в этом роде.Вы делаете это так:</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">Единственное место, где предупреждение не появляется, хотя оно могло бы быть, - это если в результате оптимизации не выполняется попытка сопоставления всего шаблона. Например, Perl может выяснить, что для того, чтобы строка соответствовала определенному шаблону регулярного выражения, строка должна содержать подстроку &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Перед попыткой сопоставления Perl может поискать эту подстроку, и, если она не найдена, немедленно провалить сопоставление, фактически не пытаясь его выполнить; поэтому предупреждение не создается, даже если строка содержит указанную выше кодовую точку Unicode.</target>
        </trans-unit>
        <trans-unit id="2a1424cb465056db403b0376b90df7285a39a496" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f03961d151195642787106427ad37fb0df08a21" translate="yes" xml:space="preserve">
          <source>The only pragmas to be completely supported are: &lt;code&gt;use warnings&lt;/code&gt;, &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;use bytes&lt;/code&gt;, &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use feature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">Единственная цель этого шага-создать нужные каталоги и дать вам знать имена этих каталогов.Из вывода видно,что каталог для расширения имеет вид</target>
        </trans-unit>
        <trans-unit id="e4350c2629055827ad3a8b68cc619a2e785707ba" translate="yes" xml:space="preserve">
          <source>The only required argument is &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">Единственная требуемая часть-это первое поле,название модуля (например,Foo::Bar,т.е.</target>
        </trans-unit>
        <trans-unit id="18bf9d2d31226fde65cb844d15b4e9ac5dd2e6d9" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are &lt;code&gt;GV_SUPER&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">Единственными значимыми значениями для &lt;code&gt;flags&lt;/code&gt; являются GV_SUPER и SVf_UTF8.</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">Единственное,что следует отметить,так это то,что и в статическом,и в виртуальном методах имя метода не передается через стек-оно используется в качестве первого параметра,чтобы</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">Единственное, что вы должны помнить, это то, что подпрограмма &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a8286223f476561d867d00238ced07bc0080bf9" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Единственное, что вам нужно объявить в Perl, - это форматы отчетов и подпрограммы (а иногда даже не подпрограммы). Скалярная переменная хранит неопределенное значение ( &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) до тех пор, пока ей не будет присвоено определенное значение, отличное от &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . При использовании в качестве числа &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; обрабатывается как &lt;code&gt;0&lt;/code&gt; ; когда используется как строка, она рассматривается как пустая строка, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; и при использовании в качестве ссылки, которая не назначается, это рассматривается как ошибка. Если вы включите предупреждения, вы будете получать уведомление о неинициализированном значении всякий раз, когда вы рассматриваете &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; как строку или число. Ну, обычно. Логические контексты, например:</target>
        </trans-unit>
        <trans-unit id="8063526283668c78bfe80f0053d75f81f3e00c7f" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;undef&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;undef&lt;/code&gt;. When used as a number, &lt;code&gt;undef&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt;; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;undef&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">Единственный раз,когда ты абсолютно</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">Единственный способ изменить это - создать собственную подпрограмму для &lt;code&gt;'|'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6185c346e8349db594c7e55f3c51f34e33f48b" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">Единственный способ переопределить настройку лексических предупреждений - использовать флаги командной строки &lt;b&gt;-W&lt;/b&gt; или &lt;b&gt;-X&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea2eaf8e5a3a274ae0f1dbb910613954b91ee9b" translate="yes" xml:space="preserve">
          <source>The only way you will ever be allowed to rebase or modify the history of a pushed branch is to delete it and push it as a new branch under the same name. Please think carefully about doing this. It may be better to sequentially rename your branches so that it is easier for others working with you to cherry-pick their local changes onto the new version. (XXX: needs explanation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">Дерево опций связано двумя способами:можно представить,что через него проходят два &quot;маршрута&quot;,два порядка,в которых можно пройти по дереву.Во-первых,порядок разбора отражает то,как парсер понял код,а во-вторых,порядок выполнения говорит perl,в каком порядке выполнять операции.</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">Возвращается дерево операций, представляющее блок кода. Это всегда настоящая операция, а не нулевой указатель. Обычно это список &lt;code&gt;lineseq&lt;/code&gt; , включая &lt;code&gt;nextstate&lt;/code&gt; или аналогичные операции. Никакие операции по созданию какой-либо области времени выполнения не включаются в силу того, что она является блоком.</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">Возвращается дерево операций,представляющее выражение.Если необязательное выражение отсутствует,возвращается нулевой указатель,в противном случае указатель будет ненулевым.</target>
        </trans-unit>
        <trans-unit id="e036bcd0d780fe688c97dce4eafd340bcf362abb" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">Возвращается дерево операций, представляющее оператор. Это может быть нулевой указатель, если оператор имеет значение NULL, например, если на самом деле это определение подпрограммы (которое имеет побочные эффекты во время компиляции). Если не null, оператор будет напрямую реализовывать инструкцию, подходящую для передачи в &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; . Обычно он не будет включать &lt;code&gt;nextstate&lt;/code&gt; или эквивалентную операцию (кроме тех, которые встроены в область видимости, полностью содержащуюся внутри оператора).</target>
        </trans-unit>
        <trans-unit id="2254139a8dcdd28ca766e4d41d0739d872c7e21b" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">Возвращается дерево операций, представляющее оператор. Это может быть нулевой указатель, если оператор имеет значение NULL, например, если на самом деле это определение подпрограммы (которое имеет побочные эффекты во время компиляции). Если не null, это будет результатом вызова &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; , обычно включающего &lt;code&gt;nextstate&lt;/code&gt; или эквивалентную операцию.</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">Возвращается дерево операций, представляющее последовательность операторов. Это может быть нулевой указатель, если все операторы были нулевыми, например, если не было операторов или были только определения подпрограмм (которые имеют побочные эффекты во время компиляции). Если не null, это будет список &lt;code&gt;lineseq&lt;/code&gt; , обычно включающий &lt;code&gt;nextstate&lt;/code&gt; или эквивалентные операции.</target>
        </trans-unit>
        <trans-unit id="535ccca6a54b74bb28aa7a40bc1a8b66e55f76db" translate="yes" xml:space="preserve">
          <source>The op tree to unpack the arguments from the stack at runtime is returned. This op tree should appear at the beginning of the compiled function. The caller may wish to use &lt;a href=&quot;#op_append_list&quot;&gt;&quot;op_append_list&quot;&lt;/a&gt; to build their function body after it, or splice it together with the body before calling &lt;a href=&quot;#newATTRSUB&quot;&gt;&quot;newATTRSUB&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c6433e7899b6be9854e9907788616c4dfa0ff" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP flags abbreviations&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">Операционные флаги (например, &lt;b&gt;'sK / 2'&lt;/b&gt; ) описаны в ( &lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;Сокращения OP-флагов&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">Лицензия с открытым исходным кодом, которую Ларри Уолл создал для Perl, максимизирует полезность, доступность и модифицируемость Perl. Текущая версия - 2. ( &lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">Функция open2()запускает заданный $cmd и соединяет $chld_out для чтения и $chld_in для записи.Это то,что,по вашему мнению,должно работать,когда вы пытаетесь</target>
        </trans-unit>
        <trans-unit id="2904189d67cdca2709e7a78ebf9563187c0c5785" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given command and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">Операндом некоторых типов regop является буквальная строка; для других это переход к подпрограмме. В частности, операнд узла &lt;code&gt;BRANCH&lt;/code&gt; является первым регистром ветви.</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">Операционная система, драйверы устройств, библиотеки C и исполняющая система Perl - все сговорились, чтобы позволить программисту рассматривать один символ ( &lt;code&gt;\n&lt;/code&gt; ) как признак конца строки, независимо от внешнего представления. Во многих операционных системах собственное представление текстового файла совпадает с внутренним представлением, но на некоторых платформах внешнее представление &lt;code&gt;\n&lt;/code&gt; состоит из более чем одного символа.</target>
        </trans-unit>
        <trans-unit id="3f9b4af2476a3677a8d756957b80eb4422b5ccdb" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt;) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">Работа массива &lt;code&gt;%ENV&lt;/code&gt; зависит от перевода логического имени</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">Эксплуатация варианта bval заслуживает некоторого обсуждения.Вот определение bval на странице руководства по эксплуатации Berkeley DB 1.85 recno:</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">На работу этого метода также влияют записи &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; и &lt;code&gt;cc&lt;/code&gt; в &lt;code&gt;Config.pm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebf43357cdf326de3a784f122cc30174e4d696c9" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt;, &lt;code&gt;cccdlflags&lt;/code&gt;, &lt;code&gt;ccflags&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">На работу этого метода также влияют записи &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; и &lt;code&gt;ld&lt;/code&gt; в &lt;code&gt;Config.pm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9af43d4cfed7d96567a247c3d560f72f4c234173" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt;, &lt;code&gt;shrpenv&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">Операции,на которые оказывает влияние местность:</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">Оператор &lt;code&gt;not&lt;/code&gt; не является допустимым ключом для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . Однако если оператор &lt;code&gt;!&lt;/code&gt; перегружен, то для &lt;code&gt;not&lt;/code&gt; будет использоваться одна и та же реализация (поскольку два оператора отличаются только приоритетом).</target>
        </trans-unit>
        <trans-unit id="e62d966af3836010344e801b17dfde35cf80a445" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;use overload&lt;/code&gt;. However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">Оператор может быть назначен,если и 2-й,и 3-й аргументы являются юридическими значениями (это означает,что их можно назначить):</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">За именем операции, как в &lt;b&gt;'add [t1]'&lt;/b&gt; , может следовать информация, относящаяся к операции, в круглых или квадратных скобках (например, &lt;b&gt;'[t1]'&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a764821c24945c6b9d29fb8f23336e4895936b8" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;&quot;catdir&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">Противоположность &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da407a5a37cdd431c49815120665c0495df714be" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir%28%29&quot;&gt;&quot;catdir()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">Противоположность &lt;a href=&quot;#catdir()&quot;&gt;catdir ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">Противоположность &lt;a href=&quot;../spec#catdir&quot;&gt;catdir ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72e60997864c75a6b42c630a5cd3b7d0d96cb145" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">Противоположность &lt;code&gt;catdir()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2ff0fee10bb0851a17501763837139e03ed67c" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a36830f45796b87c226ab6318291313f5d62c75" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode&lt;/code&gt;: expects a JSON text and tries to parse it, returning the resulting simple scalar or reference. Croaks on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81bb459c3e1d2a0353a3947d9d6ef14ef3f4c25" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode_json&lt;/code&gt;: expects an UTF-8 (binary) string and tries to parse that as an UTF-8 encoded JSON text, returning the resulting reference. Croaks on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">Функции opset и opset_to_ops могут быть использованы для преобразования из списка операторов в опсет и</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">Используемое имя оптага не должно быть уже определено (define_optag перекроется,если оно уже определено).Имена оптагов являются глобальными для процесса perl,и определения оптагов не могут быть изменены или удалены после их определения.</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">Информация, относящаяся к оптимизатору, используется, чтобы избежать ввода (медленного) механизма регулярных выражений для строк, которые точно не будут соответствовать. Если &lt;code&gt;isall&lt;/code&gt; флаг isall , вызова механизма регулярных выражений можно избежать, даже если оптимизатор нашел подходящее место для совпадения.</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">Опция не принимает аргумент и может быть отменена, поставив перед ней префикс &amp;laquo;no&amp;raquo; или &amp;laquo;no-&amp;raquo;. Например, &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; разрешит &lt;code&gt;--foo&lt;/code&gt; (будет присвоено значение 1), а также &lt;code&gt;--nofoo&lt;/code&gt; и &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (будет присвоено значение 0). Если у опции есть псевдонимы, это относится и к псевдонимам.</target>
        </trans-unit>
        <trans-unit id="d9db329442e437205bd55b086c5b9e99baf5686d" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">Параметр не принимает аргументов и будет увеличиваться на 1 каждый раз, когда появляется в командной строке. Например, &lt;code&gt;&quot;more+&quot;&lt;/code&gt; при использовании с &lt;code&gt;--more --more --more&lt;/code&gt; увеличит значение в три раза, в результате чего получится значение 3 (при условии, что сначала оно было 0 или не определено).</target>
        </trans-unit>
        <trans-unit id="d8e253e20697ea76ff418e0292092a5b47f9f4f6" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt;, when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">Имя опции,как указано в функции GetOptions(),вызывает опцию</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">Имена опций,определенные ниже,не чувствительны к регистру и могут быть опционально префиксованы с помощью '-'.Таким образом,все нижеследующее является действительным</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">Опция требует аргумента данного типа.Поддерживаемые типы:</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">Дополнительный</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">Необязательный атрибут &lt;code&gt;rules&lt;/code&gt; указывает направление, в котором тесты должны выполняться параллельно, а какие - последовательно. Если структура данных правила не указана, используется структура данных по умолчанию, которая позволяет запускать каждый тест параллельно:</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">Необязательные аргументы считаются буквальными строками, если они не начинаются с &lt;code&gt;~&lt;/code&gt; или &lt;code&gt;!&lt;/code&gt; , и в этом случае они интерпретируются как регулярные выражения (возможно, с отрицанием).</target>
        </trans-unit>
        <trans-unit id="cf1d2e0ff9c2439cc3ca174e85a170cee0c435c9" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;, in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a457723dc3fc51f575186932ad8e9bfa084daea" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caed88218bf3ae5d8b6dcab0958f36fc2927ec02" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyuncompress&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131098ff902c48e8458d96c59269d22ab860e8b2" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bunzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6198111cc9801f305996de3eeaa06e0db91b4218" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c4c457d99260789b76c08eab24f06adc17d2c1" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;deflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1a96727af7ce5f83a4cb5ede379486da415347" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gunzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a1759e80fa595487da188a1ae20babdbb62651" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f90f77041e19f7f96b84e59406c9ba0fcd6ff0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;inflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34c4bd457be8b3eca1d1b50327dc8555ebf3e0c" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawdeflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3088b2b3f74fb962460f08bf6c521a6489c8dc" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564a4703e441e1aa249188b7a46aeee40f3cb3e0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;unzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bd6c00e2144ea2637c42a56845ca5419370d66" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;zip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ca67d9f48cf9586e57f2ed1e1217218181099d" translate="yes" xml:space="preserve">
          <source>The optional second parameter is ignored if it is larger than the actual length of the first parameter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">Перечисленные выше параметры настраивают части заголовка по умолчанию, но установка &lt;code&gt;html_header&lt;/code&gt; или &lt;code&gt;html_footer&lt;/code&gt; полностью переопределяет встроенный верхний или нижний колонтитул. Это может быть полезно, если вы хотите использовать теги шаблонов вместо буквальных верхних и нижних колонтитулов HTML или интегрируете преобразованные страницы POD в более крупный веб-сайт.</target>
        </trans-unit>
        <trans-unit id="01a4d13b9aa02b31aa3157b7bf6c6d232ea80269" translate="yes" xml:space="preserve">
          <source>The options listed in this section control how the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">Опции этого аргумента представляют собой список каталогов, в которых выполняется рекурсивный поиск, или файлов. (Обычно вы не указываете файлы, а просто каталоги.) Или вы можете просто указать пустой список, как в $ name2path; с &lt;code&gt;inc&lt;/code&gt; опцией inc , как и по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Optree разделяется между потоками. Это означает, что существует вероятность того, что optree переживет конкретный поток (и, следовательно, экземпляр интерпретатора), который его создал, поэтому истинные скаляры Perl не могут быть сохранены в optree. Вместо этого используется компактная форма, в которой могут храниться только целые числа (со знаком и без знака), строки или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - ссылки и значения с плавающей запятой преобразуются в строки . Если вам нужно сохранить несколько значений или сложных структур, вы должны сериализовать их, например, с помощью &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; . Удаление хеш-ключа из &lt;code&gt;%^H&lt;/code&gt; записывается, и, как всегда, его можно отличить от существования ключа со значением &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; с помощью &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="758267caaf6c4060844acf8b5ceecd9fefe29a51" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;undef&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;pack&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;undef&lt;/code&gt; with &lt;code&gt;exists&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">Порядок,в котором объекты уничтожаются во время глобального уничтожения перед выходом программы,непредсказуем.Это означает,что любые объекты,содержащиеся в вашем объекте,возможно,уже были уничтожены.Прежде чем вызывать метод на нем,необходимо проверить,определен ли содержащийся в нем объект:</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">Порядок,в котором этот тест проводился для данного результата тестового набора.</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">Порядок сортировки &lt;b&gt;символов&lt;/b&gt; . Это используется подпрограммами сравнения &lt;b&gt;строк&lt;/b&gt; , чтобы решить, например, где в этом глоссарии поместить &amp;laquo;последовательность сортировки&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="90461643a4b9bcbbb16f181372c5e7705b398666" translate="yes" xml:space="preserve">
          <source>The order of any groups including scripts is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">Порядок аргументов отличается от порядка,используемого функцией open2().</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">Порядок аргументов отличается от порядка,используемого функцией open3().</target>
        </trans-unit>
        <trans-unit id="c7058991786845d90ace9e46987253e3ce531354" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">Порядок следования тот же,что и для регулярного выражения,которое является результатом EXPR,или шаблона,содержащегося в группе захвата</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">Оригинальный интерфейс &lt;code&gt;MD5&lt;/code&gt; был написан Нилом Винтоном ( &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a967938ebcc10e8da7bfe2a06eaff58eb4186ec0" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">Оригинальная бумага Дилана</target>
        </trans-unit>
        <trans-unit id="50fea78ce2537fb78816d81a4d2374f6c7eff868" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">Исходный Pod :: Text содержал код для форматирования с помощью последовательностей termcap, хотя он не был включен по умолчанию, и заставить его вообще работать было проблематично. Эта перезапись даже не пытается это сделать, но ее подкласс делает. Найдите &lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">Исходная спецификация UTF-8 позволяла использовать до 6 байтов, чтобы разрешить кодирование чисел до &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl по-прежнему позволяет это делать и расширил это количество до 13 байтов для кодирования кодовых точек до того, что может поместиться в 64-битное слово. Однако Perl выдаст предупреждение, если вы выведете какой-либо из них как непереносимый; и в соответствии со строгими протоколами ввода UTF-8 они запрещены.</target>
        </trans-unit>
        <trans-unit id="00b0e9de1cd640deb40f9e9ac2ea76a7fdd363f8" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt;. Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden. In addition, it is now illegal to use a code point larger than what a signed integer variable on your system can hold. On 32-bit ASCII systems, this means &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; is the legal maximum (much higher on 64-bit systems).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">Оригинальная культура доопулистского Интернета и глубоко укоренившиеся убеждения автора Perl Ларри Уолла породили политику свободного и открытого распространения Perl.Perl поддерживается его пользователями.Ядро,стандартная библиотека Perl,дополнительные модули и документация,которую вы сейчас читаете,были написаны волонтерами.</target>
        </trans-unit>
        <trans-unit id="12a169f5e5252000915162d740c1f7fb51701fdf" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;, which does not return checker flags. When using a checker function returned by this function, it is only safe to call it with a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0e3050b313150315f2790edd37f73f93a916ca" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility. The effect of that flag setting is that the check function is guaranteed to get a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">Исходная форма &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt; , которая передает ему флаг &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; для обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">Исходным форматом мета-файлов CPAN был &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML,&lt;/a&gt; а соответствующий файл назывался</target>
        </trans-unit>
        <trans-unit id="12304d794d559e0c5fe4691017042f08f8d52e43" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0efcec67bc372bca64df41283c31757275dca6" translate="yes" xml:space="preserve">
          <source>The original impetus for &lt;code&gt;Perl_langinfo()&lt;/code&gt; was so that code that needs to find out the current currency symbol, floating point radix character, or digit grouping separator can use, on all systems, the simpler and more thread-friendly &lt;code&gt;nl_langinfo&lt;/code&gt; API instead of &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; which is a pain to make thread-friendly. For other fields returned by &lt;code&gt;localeconv&lt;/code&gt;, it is better to use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&lt;code&gt;POSIX::localeconv()&lt;/code&gt;&lt;/a&gt;, which is thread-friendly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">Первоначальной целью исходных фильтров было дать вам возможность зашифровать исходный текст программы для предотвращения случайного пиратства.Это не все,что они могут сделать,как вы скоро узнаете.Но сначала,основы.</target>
        </trans-unit>
        <trans-unit id="af210dcaae99ceb3aa829035af3557a9ff65ef3a" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">Исходная метка стека для XSUB. См. &lt;code&gt;dORIGMARK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">В исходном стиле в именах блоков (кроме &lt;code&gt;No_Block&lt;/code&gt; ) используются пробелы и дефисы , например:</target>
        </trans-unit>
        <trans-unit id="5c736b5ceaedaf0c5b862acefcb315ae2bd5b9ab" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt;), like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">Первоначальное название было</target>
        </trans-unit>
        <trans-unit id="07db5f54ef4c59c897a817d5ccebc37f60d9a5b6" translate="yes" xml:space="preserve">
          <source>The original true/false value of whatever was passed into the event (but reduced down to 1 or 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e60244f8f199981b052b42233461b69e602ecf3" translate="yes" xml:space="preserve">
          <source>The original usage can be accomplished by explicit (rather than this pragma's implicit) encoding using the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">Первоначальная версия B :: Terse была написана Малкольмом Битти, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. Эту оболочку написал Стивен МакКамант, &amp;lt;smcc@MIT.EDU&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">Оригинальная версия PA-RISC,HP больше не продает системы с этим чипом.</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">Оригинальная версия этой статьи первоначально появилась в журнале Perl Journal #10,и на нее распространяется авторское право 1998 The Perl Journal.Она появилась благодаря Джону Оруанту и &quot;Журналу Perl&quot;.Этот документ может распространяться на тех же условиях,что и сам Perl.</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">Оригинал был написан Энди Доэрти...</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">Другие константы &lt;code&gt;OA_*&lt;/code&gt; использовать не следует.</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">Другой &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; предназначены методы , которые будут вызываться только один раз за &lt;code&gt;$parser&lt;/code&gt; объекта; но &lt;code&gt;parse_lines&lt;/code&gt; можно вызывать столько раз для объекта &lt;code&gt;$parser&lt;/code&gt; сколько вы хотите, до тех пор, пока последний вызов (и только последний вызов) заканчивается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c95c0f77be936d4feacc6aa823fe8dfa8595f61" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;undef&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">Другие аргументы должны показаться вам знакомыми, если вы знаете &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6d6b16332403f12890e319d0cef347a3dc9b9bef" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">Другая большая проблема с &lt;code&gt;$^W&lt;/code&gt; - это то, как вы можете случайно изменить настройку предупреждения в неожиданных местах вашего кода. Например, при запуске приведенного ниже кода (без флага &lt;b&gt;-w&lt;/b&gt; ) второй вызов &lt;code&gt;doit&lt;/code&gt; вызовет предупреждение &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; , а первый - нет.</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">В других случаях требуются более сложные процедуры. Ниже я предполагаю, что текущая версия Perl - &lt;code&gt;5.8.2&lt;/code&gt; , поэтому исполняемые файлы названы соответственно.</target>
        </trans-unit>
        <trans-unit id="427a9edc8baf371e22d2821e2812db4f5b95659f" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt;, so the executables are named accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97290d4117a272682128f8d28555111afe13c240" translate="yes" xml:space="preserve">
          <source>The other common cause is for the characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">Другой аналог в столбце &amp;laquo;Full-range Unicode&amp;raquo; соответствует любым подходящим символам в полном наборе символов Unicode. Например, &lt;code&gt;\p{Alpha}&lt;/code&gt; соответствует не только алфавитным символам ASCII, но и любому символу во всем наборе символов Unicode, который считается алфавитным. Запись в столбце &amp;laquo;последовательность обратного слэша&amp;raquo; является (коротким) эквивалентом.</target>
        </trans-unit>
        <trans-unit id="f185e517dca4682b63e353adac3daa559be38725" translate="yes" xml:space="preserve">
          <source>The other form is called &quot;block eval&quot;. It is less general than string eval, but the code within the BLOCK is parsed only once (at the same time the code surrounding the &lt;code&gt;eval&lt;/code&gt; itself was parsed) and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first, while also providing the benefit of checking the code within BLOCK at compile time. BLOCK is parsed and compiled just once. Since errors are trapped, it often is used to check if a given feature is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">Другим хаком является восстановление FP-флагов после вызова dlopen().Это помогает против подобных повреждений,наносимых DLLs _DLLInitTerm()во время выполнения.В настоящее время нет возможности отключить эти взломы.</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">Другое-установка модуля во временное место.</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">Другое изменение заключается в том,что</target>
        </trans-unit>
        <trans-unit id="5eaa26235f36f66db1f5d49d6f66d3b1d7e346a6" translate="yes" xml:space="preserve">
          <source>The other one is &quot;Common&quot;. This consists of mostly punctuation, emoji, and characters used in mathematics and music, the ASCII digits &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;, and full-width forms of these digits. These characters can appear intermixed in text in many of the world's scripts. These also don't cause a script run to not match. But like other scripts, all digits in a run must come from the same set of 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">Другая причина, по которой использование переменной для хранения имени другой переменной является плохой идеей, заключается в том, что вопрос часто возникает из-за недостаточного понимания структур данных Perl, особенно хешей. Используя символические ссылки, вы просто используете хэш таблицы символов пакета (например, &lt;code&gt;%main::&lt;/code&gt; вместо пользовательского хеша. Решение состоит в том, чтобы вместо этого использовать свой собственный хеш или реальную ссылку.</target>
        </trans-unit>
        <trans-unit id="14e65562914f1eda6c3850757c3e36b8e4c292d5" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt;) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23447e512ad32c2037041f02596c75ecf1a5899" translate="yes" xml:space="preserve">
          <source>The other scalar-returning list reduction functions are all specialisations of this generic idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">На другую структуру указывает &lt;code&gt;pprivate&lt;/code&gt; структуры &lt;code&gt;regexp&lt;/code&gt; и она является дополнением к &lt;code&gt;intflags&lt;/code&gt; в той же структуре, которая считается свойством механизма регулярных выражений, который скомпилировал регулярное выражение;</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">Другие примитивы синхронизации,описанные ниже,могут страдать аналогичными проблемами.</target>
        </trans-unit>
        <trans-unit id="375bee995645e81f309660da902b757d6a8e656a" translate="yes" xml:space="preserve">
          <source>The other way works too, especially if you are sure that all your data are under the same encoding, or if compatibility with older versions of Perl is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a4f63ad2418ff7f127884608b4d5e8c00d7b27" translate="yes" xml:space="preserve">
          <source>The others shouldn't be used in a threaded application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Разделитель поля вывода для оператора печати. Если определено, это значение печатается между каждым из аргументов print. По умолчанию &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdf1adf4fd2953bb9b8993988459b89f053c2344" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">Выходной файл для печати. Если используются специальные имена &amp;laquo;-&amp;raquo; или &amp;laquo;&amp;gt; &amp;amp; 1&amp;raquo; или &amp;laquo;&amp;gt; &amp;amp; STDOUT&amp;raquo;, то используется стандартный вывод. Если используется &quot;&amp;gt; &amp;amp; 2&quot; или &quot;&amp;gt; &amp;amp; STDERR&quot;, используется стандартная ошибка.</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">Выходные файлы помещаются в иерархию, основанную на директории библиотеки Perl, зависящей от архитектуры. Вы можете указать другую иерархию с помощью ключа &lt;b&gt;-d&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c27fbec04d459297ba3b8649872110c7c0d3d15a" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;&quot;Configurable Options&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">Формат вывода регулируется несколькими параметрами, описанными в разделе &amp;laquo; &lt;a href=&quot;#Configurable-Options&quot;&gt;Настраиваемые параметры&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">Формат вывода &lt;a href=&quot;functions/write&quot;&gt;записи&lt;/a&gt; определяется более ранним объявлением формата ( &lt;a href=&quot;functions/format&quot;&gt;форматом&lt;/a&gt; ), поэтому то, зависит ли вывод от языкового стандарта, определяется тем, находится ли &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; в пределах области &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , а не от того, находится ли &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; является.</target>
        </trans-unit>
        <trans-unit id="c1530099f7317e5e8334f8069b6bb6b27df102d4" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;perlfunc#write&quot;&gt;write()&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;perlfunc#format&quot;&gt;&quot;format&quot; in perlfunc&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;format()&lt;/code&gt; is within the scope of a &lt;code&gt;use locale&lt;/code&gt;, not whether the &lt;code&gt;write()&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">Вывод из XSUB,который использует что-то вроде карты T_PTREF,которая не благословляет объект,может выглядеть что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">Выход из этого будет</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">Выход не используется.Если ты не знаешь,что такое пятно,не волнуйся об этом.</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">Строку вывода можно использовать как шаблон в вызове &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff265796f887227add453069160ce81043ae2ad9" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;unpack&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">Вывод &lt;code&gt;uname -a&lt;/code&gt; , если доступен, иначе имя хоста. Затем все это делается в нижнем регистре, а косая черта и одинарные кавычки удаляются.</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Разделитель выходной записи для оператора печати. Если определено, это значение печатается после последнего аргумента print. По умолчанию &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bed1b55192d15d86c0d4204e8c0dbb14dedd4354" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">На выходе показаны все группы.Самые крайние совпадения показываются первыми,а вложенные-позже:</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">Вывод показывает,что Перл нашел две основные группы:</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">Выходные данные показывают, что в блоке &lt;code&gt;OUTER&lt;/code&gt; значения &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;$2&lt;/code&gt; взяты из совпадения с &lt;code&gt;$outer&lt;/code&gt; . Внутри блока &lt;code&gt;INNER&lt;/code&gt; значения &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;$2&lt;/code&gt; взяты из совпадения с &lt;code&gt;$inner&lt;/code&gt; , но только до конца блока (то есть динамической области). После завершения блока &lt;code&gt;INNER&lt;/code&gt; значения &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;$2&lt;/code&gt; возвращаются к значениям для сопоставления с &lt;code&gt;$outer&lt;/code&gt; даже если мы не сделали другого сопоставления:</target>
        </trans-unit>
        <trans-unit id="3aeb115218152011de3493e1c2fea22949664e64" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt;. Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt;, but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">Выходные данные показывают, что подпрограмма constant (), которую мы тестируем, заменяется значением константы &lt;code&gt;DEBUG&lt;/code&gt; : ноль. Тестируемая линия была полностью оптимизирована, и вы не можете добиться гораздо большей эффективности, чем это.</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">Выходная строка будет возвращена.</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">Выходные строки для &lt;b&gt;Tputs&lt;/b&gt; кэшируются на &lt;b&gt;счетчик&lt;/b&gt; 1 для производительности. &lt;b&gt;Tgoto&lt;/b&gt; и &lt;b&gt;Tpad&lt;/b&gt; не &lt;b&gt;кешируют&lt;/b&gt; . &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; - это необработанные данные termcap, а &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; - это кэшированная версия.</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">Выходное значение со знаком должно быть либо положительным значением в диапазоне 1,2,...,OBJ2-1,либо таким же значением,вычитаемым OBJ2.Например,если входными аргументами являются объекты,представляющие числа 7 и 5,то метод должен либо возвращать объект,представляющий число 3 и знак &quot;+&quot;,так как (3*7)% 5=1 % 5,либо объект,представляющий число 2 и знак &quot;-&quot;,так как (-2*7)% 5=1 % 5.</target>
        </trans-unit>
        <trans-unit id="3b69a10a3a50934e50dc62235290b18744d8011f" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and a &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">Вывод,который вы получите при выполнении скрипта:</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">В целом, или стандартная дата, время между тем, когда &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; называли, и когда она заканчивается. Истекшее время включает время пользователя и системы, а также время, потраченное на ожидание других пользователей и процессов в системе. Неизбежно, что это наиболее приблизительный из приведенных измерений.</target>
        </trans-unit>
        <trans-unit id="9571b6fa38431ae0c0fee13dd1186fe4dbf0046f" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;time&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">Символ pTHX_в определении-это макрос,используемый Perl в потоке для предоставления дополнительного аргумента рутине,удерживающей указатель обратно на интерпретатор,выполняющий регенерацию.Таким образом,при многопоточности все рутины получают дополнительный аргумент.</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">Код пакета &lt;code&gt;A*&lt;/code&gt; поглощает все оставшиеся байты, а &lt;code&gt;$prio&lt;/code&gt; остается неопределенным! Прежде чем мы позволим разочарованию подорвать боевой дух: у Perl есть козырь, чтобы сделать этот трюк, чуть дальше в рукаве. Смотри:</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">Код пакета &lt;code&gt;w&lt;/code&gt; был добавлен для поддержки переносимой схемы кодирования двоичных данных, которая выходит далеко за рамки простых целых чисел. (Подробности можно найти на &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt; , проекте Scarab.) Сжатое целое число без знака BER ( двоичное кодированное представление) хранит базовые 128 цифр, начиная с самой старшей цифры, с как можно меньшим количеством цифр. Бит восемь (старший бит) устанавливается на каждый байт, кроме последнего. Для кодирования BER нет ограничений по размеру, но Perl не будет впадать в крайности.</target>
        </trans-unit>
        <trans-unit id="b79ab5606b336d2e61cfa7238de19673ec485cc8" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">Код пакета для обратного порядка байтов (старший байт по младшему адресу) равен &lt;code&gt;n&lt;/code&gt; для 16-битных и &lt;code&gt;N&lt;/code&gt; для 32-битных целых чисел. Вы используете эти коды, если знаете, что ваши данные поступают из совместимой архитектуры, но, как ни удивительно, вы также должны использовать эти коды пакетов, если вы обмениваетесь двоичными данными по сети с какой-либо системой, о которой вы почти ничего не знаете. Простая причина в том, что этот порядок был выбран в качестве</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">Код пакета перед &lt;code&gt;/&lt;/code&gt; может быть любым, подходящим для представления числа: все числовые двоичные коды пакетов и даже текстовые коды, такие как &lt;code&gt;A4&lt;/code&gt; или &lt;code&gt;Z*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65094bdd21f0a1919cd6838b37b6c0d3bbee3405" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">Формат пакета &lt;code&gt;A&lt;/code&gt; означает &amp;laquo;любой символ&amp;raquo;; если вы собираете &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; и у вас кончились вещи, которые нужно упаковать, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; заполнит остальное пространство.</target>
        </trans-unit>
        <trans-unit id="44495eb674e0583287f2264fa02ffed62c8c4074" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;pack&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;pack&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">Пакет содержит менеджер сеансов и менеджер кэша.Менеджер сеансов отслеживает,что было извлечено,собрано и установлено в текущем сеансе.Менеджер кэша отслеживает дисковое пространство,занятое процессами make,и удаляет лишнее пространство,используя простой механизм FIFO.</target>
        </trans-unit>
        <trans-unit id="f2c3c65c0d45b6b1fe4dfd7fdaf1376fd647a40b" translate="yes" xml:space="preserve">
          <source>The package from which the exceptional subroutine was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">Аргументом имени пакета обычно является имя класса,в котором была объявлена подпрограмма,но это может быть и имя производного класса (так как обработчики наследуются).</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">В названии пакета используется префикс &lt;code&gt;DBM_Filter::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">Пакет, представляющий дистрибутив. Например, &lt;code&gt;Test::More&lt;/code&gt; или &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . Он будет использоваться для получения информации о дистрибутиве, такой как &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt; , места установки в библиотеке Perl и где файлы XS будут искать по умолчанию (см. &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf847620b5ea5a28241ef80f16dce588c1976c67" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;&quot;DISTNAME&quot;&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;&quot;XS&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">Пакет, в который помещается магический объект qr // (как видно из &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ). Рекомендуется, чтобы движки изменили это имя на свое имя пакета для идентификации независимо от того, реализуют ли они методы для объекта.</target>
        </trans-unit>
        <trans-unit id="3eb8be4161caf31aed9851aac09981f2dc091cb7" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;ref qr//&lt;/code&gt;). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">Пакет, возвращаемый этим методом, также должен иметь внутренний пакет &lt;code&gt;Regexp&lt;/code&gt; в своем &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; всегда должно быть истинным, независимо от того, какой движок используется.</target>
        </trans-unit>
        <trans-unit id="890f0468ce1dfbaa3a848480f6a3e9f003f8a19f" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt;. &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">Переменная пакета &lt;code&gt;@EXPORT&lt;/code&gt; будет определять, какие символы будут экспортированы, когда вызывающий просто скажет &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - вы вряд ли когда-нибудь захотите что-нибудь туда помещать. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , с другой стороны, указывает, какие символы вы хотите экспортировать. Если вы действительно хотите экспортировать набор символов, используйте &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; и определите стандартный набор для экспорта - более подробную информацию см. В &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8ef2409327fe0b3b34e7e40584004dedfbd9fc" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;use Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt;, on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">Пакеты,относящиеся к различным реализациям,связанным с РБМ (</target>
        </trans-unit>
        <trans-unit id="02ef2277604c9b31476ae26defa7602571798335" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; and &lt;code&gt;_HIGH&lt;/code&gt; fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">Имена колодок в PADNAMELIST имеют свой PV,удерживающий имя переменной.Поля COP_SEQ_RANGE_LOW и _HIGH образуют диапазон (low+1...high inclusive)номеров cop_seq,для которых имя является действительным.При компиляции эти поля могут содержать специальное значение PERL_PADSEQ_INTRO для обозначения различных этапов:</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">Мягкая шнурка возвращена.</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">Документ &quot;Как сломать MD5 и другие хэш-функции&quot; Xiaoyun Wang и Hongbo Yu.</target>
        </trans-unit>
        <trans-unit id="9446a617fdf40553874ee589e7fc235690a0bb87" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">Абзацы, которые вы передаете &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap,&lt;/a&gt; не должны содержать встроенных символов новой строки. &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; не выравнивает строки (выравнивание вправо).</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">Параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; используется для управления местом назначения сжатых данных. Этот параметр может принимать одну из следующих форм.</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">Параметр &lt;code&gt;$output_filename_or_reference&lt;/code&gt; используется для управления местом назначения несжатых данных. Этот параметр может принимать одну из следующих форм.</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">Параметр &lt;code&gt;$text&lt;/code&gt; - это строка или блок текста, который нужно проанализировать на предмет внутренних последовательностей; а параметр &lt;code&gt;$line_num&lt;/code&gt; - это номер строки, соответствующий началу &lt;code&gt;$text&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">Параметр &lt;code&gt;extra_libs&lt;/code&gt; можно использовать для указания &lt;b&gt;дополнительных&lt;/b&gt; путей для поиска установленных модулей. Например</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">Параметр &lt;code&gt;type&lt;/code&gt; представляет собой перечисление , который определяет , какой из 3 -х методов интерфейса (DB_HASH, DB_BTREE или DB_RECNO) должен быть использован. В зависимости от того, какой из них фактически выбран, последний параметр,</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">Список параметров my()при желании может быть присвоен,что позволяет инициализировать переменные.(Если для конкретной переменной не задан инициализатор,она создается с неопределенным значением).Обычно это используется для именования входных параметров в подпрограмме.Примеры:</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">Значение параметра по умолчанию все равно будет вычислено,если соответствующий аргумент не указан,даже если значение нигде не будет храниться.Это в том случае,если оценка имеет важные побочные эффекты.Однако,оно будет вычисляться в контексте void,поэтому,если оно не имеет побочных эффектов и не является тривиальным,оно будет выдавать предупреждение,если включена категория предупреждения &quot;void&quot;.Если значение по умолчанию безымянного опционального параметра не важно,то оно может быть опущено точно так же,как и имя параметра:</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">Параметр &lt;code&gt;$input_filename_or_reference&lt;/code&gt; используется для определения источника сжатых данных.</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">Параметр &lt;code&gt;$input_filename_or_reference&lt;/code&gt; используется для определения источника несжатых данных.</target>
        </trans-unit>
        <trans-unit id="4cb5c66abe58beef181f4c5d5c5b7b8d0a8b5206" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the compressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a676729b0be9ab28de0e8dc42a59d230912658" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the uncompressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">Параметры,которые он принимает,таковы:</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">Параметры для &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; добавляются в начало пути поиска perl. Говоря</target>
        </trans-unit>
        <trans-unit id="735cc433a3b6580bd3067e26aea227e52cc434e6" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;use lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">Скобки о &lt;code&gt;XSLoader::load()&lt;/code&gt; аргументы необходимы , так как мы заменили &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; по &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , чтобы компилятор не знает , что функция &lt;code&gt;XSLoader::load()&lt;/code&gt; присутствует.</target>
        </trans-unit>
        <trans-unit id="0d68003766a6505369e854c0eee6d10a747bd253" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;use XSLoader&lt;/code&gt; by &lt;code&gt;require&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">Анализ выполняется почти так же, как и на этапе построения, за исключением того, что большинство подпрограмм замыкаются, чтобы изменить поле размера &lt;code&gt;RExC_size&lt;/code&gt; и больше ничего не делать.</target>
        </trans-unit>
        <trans-unit id="ce842c5dcf2b13fb8c9e8394fe72be9c8b2663ca" translate="yes" xml:space="preserve">
          <source>The parser is heavily inspired from the one in &lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils::ParseXS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">Синтаксическому анализатору благородно помогает лексер, который разбивает ваш ввод на токены и решает, какого типа является каждый токен: имя переменной, оператор, простое слово, подпрограмма, базовая функция и т. Д. Основной точкой входа в лексер является &lt;code&gt;yylex&lt;/code&gt; , и его и связанные с ним процедуры можно найти в</target>
        </trans-unit>
        <trans-unit id="22cd9c89b1bd366e42455f5006c44969bcb5bdee" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt;, and that and its associated routines can be found in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">Затем синтаксический анализатор видит следующий код:</target>
        </trans-unit>
        <trans-unit id="d30f0f58beb42ee5cf5d76db1412cac91e934bb2" translate="yes" xml:space="preserve">
          <source>The part of an Email address which follows the @ is not necessarily a hostname, it is a mail domain. To find the name of a host to connect for a mail domain you need to do a DNS MX lookup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">Часть адреса TCP или UDP-разъема,которая направляет пакеты в правильный процесс после нахождения нужной машины,что-то вроде расширения телефона,которое вы даете,когда вы достигаете оператора компании.Также результат преобразования кода для запуска на другой платформе,чем изначально предполагалось,или глагол,обозначающий это преобразование.</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">Конкретная копия Perl, которую вы пытаетесь использовать, не поддерживает указанный сигнал, используемый в вызове &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">Конкретная копия Perl, которую вы пытаетесь использовать, не была создана с использованием &lt;code&gt;useithreads&lt;/code&gt; конфигурации useithreads .</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">Конкретный макрос, который вы должны использовать, зависит от того, какую &lt;code&gt;sv_set*v&lt;/code&gt; вы вызвали первой. Это связано с тем, что каждая процедура &lt;code&gt;sv_set*v&lt;/code&gt; включает только бит для определенного типа устанавливаемых данных и отключает все остальные.</target>
        </trans-unit>
        <trans-unit id="9a1356c02587b997ee27ddf50eebcf831988fbcb" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#prop_aliases()&quot;&gt;Передаваемое&lt;/a&gt; свойство может быть указано как любой из синонимов, возвращаемых функцией prop_aliases () .</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">Уровень патча в данном пакете.Значение патч-уровня происходит от</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Путь, по &lt;code&gt;@INC&lt;/code&gt; Perl проходит через @INC . По умолчанию это поиск с двойной глубиной поиска, один раз ищет определенные методы, а &lt;code&gt;AUTOLOAD&lt;/code&gt; . Однако Perl позволяет вам настроить это с помощью &lt;code&gt;mro&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd87cb3c63ce818c0482394b6803650584202ed" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt;. By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt;. However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">Путь из УРИ,будет как минимум одним '/'.</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">Путь к файлу, из которого история (при условии, что используется бэкэнд Term :: ReadLine) будет считана при запуске отладчика и в который она будет сохранена при завершении работы (для сохранения между сеансами). По концепции &lt;code&gt;.bash_history&lt;/code&gt; файл .bash_history в Bash .</target>
        </trans-unit>
        <trans-unit id="b7867a311910479846a23412feb4307a4674c491" translate="yes" xml:space="preserve">
          <source>The path to the &lt;code&gt;git&lt;/code&gt; binary to use for the Git features. The default is &lt;code&gt;/usr/local/bin/git&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">Путь к файлу автоматически преобразуется в Unix-подобный эквивалент для использования в архиве, и, если в MacOS, время модификации файла конвертируется из эпохи MacOS в эпоху Unix. Таким образом, tar-архивы, созданные в MacOS с помощью &lt;b&gt;Archive :: Tar,&lt;/b&gt; можно читать как с помощью</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">Имя POD-файла для проверки синтаксиса (по умолчанию-стандартный вход).</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">Имя файла,содержащего документацию по подставке,для вывода в формате сообщения об использовании (по умолчанию-стандартный ввод).</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">Имя файла,из которого следует выбирать разделы документации по pod (по умолчанию-стандартный вход).</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">Шаблон начинается с класса, соответствующего подмножеству букв. Когда это совпадает, выражение типа &lt;code&gt;$count{'a'}++;&lt;/code&gt; выполняется, увеличивая счетчик букв. Затем &lt;code&gt;(*FAIL)&lt;/code&gt; выполняет то, что он говорит, и механизм регулярного выражения действует в соответствии с книгой: до тех пор, пока конец строки не достигнут, позиция продвигается вперед перед поиском другой гласной. Таким образом, совпадение или отсутствие совпадения не имеет значения, и механизм регулярных выражений продолжает работу до тех пор, пока не будет проверена вся строка. (Примечательно, что альтернативное решение, использующее что-то вроде</target>
        </trans-unit>
        <trans-unit id="a027102deb051cbffb2428b7b7a47e74a500b189" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">Сопоставление с образцом выполнено успешно, и определен &lt;code&gt;$1&lt;/code&gt; , хотя он не соответствует &quot;ничего&quot;. Это действительно ни с чем не подводило. Скорее, он соответствовал чему-то, длина которого оказалась нулевой. Все это очень откровенно и честно. Когда функция возвращает неопределенное значение, это признание того, что она не может дать вам честный ответ. Поэтому вы должны использовать &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; только тогда, когда сомневаетесь в целостности того, что вы пытаетесь сделать. В других случаях вам нужно простое сравнение с &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">Сопоставление с образцом выполнено успешно, и определен &lt;code&gt;$1&lt;/code&gt; , хотя он не соответствует &quot;ничего&quot;. Это действительно ни с чем не подводило. Скорее, он соответствовал чему-то, длина которого оказалась нулевой. Все это очень откровенно и честно. Когда функция возвращает неопределенное значение, это признание того, что она не может дать вам честный ответ. Поэтому вы должны использовать &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; только тогда, когда сомневаетесь в целостности того, что вы пытаетесь сделать. В других случаях вам нужно простое сравнение с &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">В шаблоне,совпадающем с мета-символами &quot;(&quot;,&quot;)&quot; и &quot;|&quot;,нет обратных слэшей впереди.</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">Операции сопоставления с образцом &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (также известные как &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ) при использовании без оператора &lt;code&gt;=~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86784bd21e39089878c5197cae9b26fe435b4866" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt; and &lt;code&gt;tr///&lt;/code&gt; (aka &lt;code&gt;y///&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">Модификаторы шаблонов:</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">Шаблон макро-вызовов такой:</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">Правда,шаблон,</target>
        </trans-unit>
        <trans-unit id="f373f7a0e4daf869b86fcbb5c4b5b4f2ee465c22" translate="yes" xml:space="preserve">
          <source>The pattern will be used as a Perl regular expression (as opposed to a simple grep regex).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Шаблоны, используемые при сопоставлении шаблонов Perl, эволюционировали от шаблонов, поставляемых в подпрограммах регулярных выражений Версии 8. (Подпрограммы являются производными (удаленно) от свободно распространяемой повторной реализации подпрограмм V8 Генри Спенсера.) См. Подробности в &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Регулярных выражениях Версии 8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e790c64d043de1336b86cfb89ee718b54cb057cd" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;&quot;PL_rpeepp&quot;&lt;/a&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8569c5379da2f4cde343faebf02e081c76fc9c06" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;&quot;PL_peepp&quot;&lt;/a&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">Оптимизатор глазка никогда не следует заменять полностью. Скорее добавьте к нему код, обернув существующий оптимизатор. Основной способ сделать это можно увидеть &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;на этапе компиляции 3: оптимизация глазка в perlguts&lt;/a&gt; . Если новый код желает работать с операциями по всей структуре подпрограммы, а не только на верхнем уровне, вероятно, будет удобнее обернуть &lt;a href=&quot;#PL_rpeepp&quot;&gt;ловушку PL_rpeepp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">Оптимизатор глазка никогда не следует заменять полностью. Скорее добавьте к нему код, обернув существующий оптимизатор. Основной способ сделать это можно увидеть &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;на этапе компиляции 3: оптимизация глазка в perlguts&lt;/a&gt; . Если новый код желает работать только с операциями на верхнем уровне подпрограммы, а не по всей структуре, вероятно, будет удобнее обернуть &lt;a href=&quot;#PL_peepp&quot;&gt;ловушку PL_peepp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">Данные по каждому экземпляру хранятся в памяти за пределами базовой PerlIOl-структуры,делая таким образом PerlIOl первым членом структуры слоя:</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">Данные по каждому экземпляру для конкретной рукоятки.</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">Накладные расходы на каждую запись ограничат максимальное количество записей,к которым вы можете получить доступ в каждом файле.Обратите внимание,что</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">Период &quot;...&quot; совпадает с любым символом,кроме &quot;\n&quot;.</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">Период '.' соответствует любому символу, кроме &quot;\ n&quot; (если не действует модификатор &lt;code&gt;//s&lt;/code&gt; , как описано ниже).</target>
        </trans-unit>
        <trans-unit id="bc11993ee6fae379fe2dbc40f494f74a38651177" translate="yes" xml:space="preserve">
          <source>The period &lt;code&gt;'.'&lt;/code&gt; matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (unless the modifier &lt;code&gt;/s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">Perl код в PerlIO.pm затем пытается найти слой,делая следующее</target>
        </trans-unit>
        <trans-unit id="634e60cc8e248b9b7ce51ac444bfec05dc82ef31" translate="yes" xml:space="preserve">
          <source>The perl command to use is determined by &lt;a href=&quot;#get_perl&quot;&gt;&quot;get_perl&quot;&lt;/a&gt;. The command generated is guaranteed to preserve:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">Ядро perl обертывает &lt;code&gt;setjmp()&lt;/code&gt; т. Д. В макросах &lt;code&gt;JMPENV_PUSH&lt;/code&gt; и &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . Основное правило исключений perl заключается в том , что &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (в отсутствие &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ) выполняют &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , а &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; внутри &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; выполняет &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c71858536e734e97d2970ba2f758d971d8a580" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt;. The basic rule of perl exceptions is that &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt; (in the absence of &lt;code&gt;eval&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt;, while &lt;code&gt;die&lt;/code&gt; within &lt;code&gt;eval&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdbc7e5dc74277662b153d8f95c93e631321b8b" translate="yes" xml:space="preserve">
          <source>The perl equivalent is &lt;code&gt;$sv = undef;&lt;/code&gt;. Note that it doesn't free any string buffer, unlike &lt;code&gt;undef $sv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">Исполняемый файл perl получается путем связывания</target>
        </trans-unit>
        <trans-unit id="1d8ff0cddfb59dc7ae9ad6feb4a5e65da142f6d6" translate="yes" xml:space="preserve">
          <source>The perl history contains one mistake which was not caught in the conversion: a merge was recorded in the history between blead and maint-5.10 where no merge actually occurred. Due to the nature of git, this is now impossible to fix in the public repository. You can remove this mis-merge locally by adding the following line to your &lt;code&gt;.git/info/grafts&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">Сообщение Perl выходит с &amp;laquo;Perl&amp;raquo; впереди. Блок &lt;code&gt;BEGIN&lt;/code&gt; работает во время компиляции, поэтому все ошибки и предупреждения компиляции также получают префикс Perl :.</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">Перл-источник находится в git-репозитории.Вы можете клонировать репозиторий следующей командой:</target>
        </trans-unit>
        <trans-unit id="c5f10541bc3ed7ff03899b584c515233e642fba7" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&quot;Calling Perl Routines from within C Programs&quot;&lt;/a&gt; for details on how to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">Функция perl tie связывает переменную с объектом, который реализует различные методы GET, SET и т. Д. Чтобы выполнить эквивалент функции perl tie из XSUB, вы должны имитировать это поведение. Приведенный ниже код выполняет необходимые шаги - сначала он создает новый хеш, а затем создает второй хеш, который он добавляет в класс, который будет реализовывать методы привязки. Наконец, он связывает два хеша вместе и возвращает ссылку на новый связанный хеш. Обратите внимание, что приведенный ниже код НЕ вызывает метод TIEHASH в классе MyTie - см. &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Вызов&lt;/a&gt; подпрограмм Perl из программ на языке C, чтобы узнать, как это сделать.</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">Видимое на Perl имя созданной подпрограммы XS, которая будет возвращать константы. По умолчанию - &lt;code&gt;constant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be6633f7068d6499b516b1dff2ff6cfb89ba5f0c" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">Список perl-mvs@perl.org предназначен для обсуждения вопросов переноса,а также вопросов общего использования для всех Perls EBCDIC.Отправьте тело сообщения &quot;subscribe perl-mvs&quot; на majordomo@perl.org.</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">Список рассылки perl5-changes получает копию каждого патча, который отправляется в ветви обслуживания и разработки репозитория perl. См. &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;Http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; для получения информации о подписке и архиве.</target>
        </trans-unit>
        <trans-unit id="7ba06e1bf85435dc89a1bc7a3e1228003027ef95" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">Список рассылки perl5-портеров (p5p)-это то место,где поддерживается и развивается стандартная рассылка Perl.Людей,которые поддерживают Perl,также называют &quot;Perl 5 Porters&quot;,&quot;p5p&quot; или просто &quot;porters&quot;.</target>
        </trans-unit>
        <trans-unit id="3a8b72ced5fe1018b53d36c163e0f112a1621d18" translate="yes" xml:space="preserve">
          <source>The perlXYZ.sis includes only the Perl DLL: to create an additional SIS file which includes some of the standard (pure) Perl libraries, issue the command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8239507ba48e88fe2cac6b5f08faa6b68602a3e2" translate="yes" xml:space="preserve">
          <source>The perlapp.sis (11 kB -&amp;gt; 16 kB) will be built in the symbian subdirectory, but a copy will also be made to the main directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">Программа perlbug задаст вам несколько вопросов о вашем электронном адресе и заплатке,которую вы отправляете.После того,как вы ответите на них,программа отправит патч по электронной почте.</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">В perldoc for utime также есть пример,который имеет тот же эффект,что и touch(1)на файлы,которые</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">Perlfaq включает в себя несколько документов,которые отвечают на наиболее часто задаваемые вопросы о программировании на Perl и Perl.Он разделен по темам на девять основных разделов,описанных в этом документе.</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">Perlfaq - это постоянно развивающийся документ. Последнюю версию читайте на &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; . Он также включен в стандартный дистрибутив Perl.</target>
        </trans-unit>
        <trans-unit id="f61ce2c3cec8ab2b0fa16fba7a8409cd6e94fd03" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;https://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">Спецификация perlpod для Verbatim абзаца гласит:&quot;Она должна быть воспроизведена точно...&quot;,что означает,что пробельные символы,которые вы использовали для отступов от ваших дословных блоков,будут сохранены в выводе.Это может быть раздражающе для таких выходов,как HTML,где этот пробел будет оставаться перед каждой строкой.Это прискорбный случай,когда синтаксис превращается в семантику.</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">В руководстве по Perl,которое поставляется вместе с Perl,есть много полезных советов.</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">Человек, которому &lt;b&gt;операционная система&lt;/b&gt; позволяет делать практически все. Обычно это ваш системный администратор или кто-то, выдающий себя за вашего системного администратора. В системах Unix пользователь &lt;b&gt;root&lt;/b&gt; . В системах Windows обычно используется администратор.</target>
        </trans-unit>
        <trans-unit id="4a687dacf6873e351f87d30c48226233e28a0761" translate="yes" xml:space="preserve">
          <source>The pinyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightPinyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">Модель трубопровода делит задачу на ряд шагов,и результаты одного шага передаются на обработку потока за другим.Каждый поток выполняет одну вещь с каждой единицей данных и передает результаты в следующий поток по очереди.</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">Утилита pl2pm запустит вас.</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">План (например,'1..5')должен начинаться или заканчиваться только в начале или в конце TAP-выхода.</target>
        </trans-unit>
        <trans-unit id="b8f929ee511ca422d9eb63d2f4f5d86c27217779" translate="yes" xml:space="preserve">
          <source>The plan event for the subtest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4326b3bc4ca816f9708e08eacb7250e5b64a4e86" translate="yes" xml:space="preserve">
          <source>The plugin system in the CPAN shell was introduced in version 2.07 and is still considered experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09a69221209bb270cc3034edeb1fb83d92c2242" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function so that &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">Смысл функции состоит в том, чтобы &amp;laquo;засеять&amp;raquo; функцию &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; , чтобы функция &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; могла генерировать другую последовательность каждый раз, когда вы запускаете свою программу. При вызове с параметром &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; использует его для начального числа; в противном случае он (полу) случайным образом выбирает семя. В любом случае, начиная с Perl 5.14, он возвращает начальное значение. Чтобы сигнализировать, что ваш код будет работать</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">Смысл функции состоит в том, чтобы &amp;laquo;засеять&amp;raquo; функцию &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; , чтобы функция &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; могла генерировать другую последовательность каждый раз, когда вы запускаете свою программу. При вызове с параметром &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; использует его для начального числа; в противном случае он (полу) случайным образом выбирает семя. В любом случае, начиная с Perl 5.14, он возвращает начальное значение. Чтобы сигнализировать, что ваш код будет работать</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">Указатель благословляется в класс,который является производным от имени типа указателя,но при этом все '*' в имени заменяется на 'Ptr'.</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;dsv&lt;/code&gt; указатель на PV dsv .</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">Следует отметить следующее</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">Полярная нотация (также известная как тригонометрическое представление)намного удобнее для выполнения умножений и делений комплексных чисел,в то время как картезианная нотация лучше подходит для сложений и вычитаний.Реальные числа находятся на</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">Полярный стиль пытается подчеркнуть такие аргументы,как</target>
        </trans-unit>
        <trans-unit id="69fec36a5f0f42b7b7ddc49268b5d8cea58e3639" translate="yes" xml:space="preserve">
          <source>The popular tool &lt;code&gt;sudo&lt;/code&gt; provides a controlled way for users to be able to run programs as other users. It sanitises the execution environment to some extent, and will avoid the &lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang race condition&lt;/a&gt;. If you don't have the safe version of set-id scripts, then &lt;code&gt;sudo&lt;/code&gt; may be a more convenient way of executing a script as another user than writing a C wrapper would be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">В качестве справочного порта использовался порт для Win32.</target>
        </trans-unit>
        <trans-unit id="e9a7460e24d0700d3e12dc5c76ead4d814126aa5" translate="yes" xml:space="preserve">
          <source>The port of Perl to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">Порт Perl на Mac OS был официально удален с версии Perl 5.12,хотя последний официальный производственный релиз MacPerl соответствовал версии Perl 5.6.В то время как Perl 5.10 включал в себя порт на Mac OS,ExtUtils::MakeMaker,основная часть инфраструктуры Perl по установке модулей,официально отказалась от поддержки Mac OS в апреле 2004 года.</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">Портье ценят время,которое вы потратили на то,чтобы сделать Перла лучше.Спасибо!</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">Часть расширения, предоставляемая кодом XS, может быть связана с остальной частью Perl любым из двух способов. В &lt;b&gt;статической&lt;/b&gt; конфигурации объектный код расширения напрямую связан с</target>
        </trans-unit>
        <trans-unit id="2605e3cd341c048b0037bbd123fa8ea2ca949be7" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">Позиция в файле FILEHANDLE остается неизменной. Вы можете вызвать &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;функцию seek&lt;/a&gt; перед записью в файл.</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">Притягательные формы (новые в Perl 5.10)предотвращают обратное движение:то,что совпадает с паттерном с притягательным квантификатором,не будет возвращено в обратное движение,даже если это приводит к неудаче всего совпадения.</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">Возможные категории: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , а категория псевдо &lt;code&gt;:characters&lt;/code&gt; (описанные ниже).</target>
        </trans-unit>
        <trans-unit id="b9cec0c735ea3bb0489e4ea0d12dfd9112e5e476" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt;, &lt;code&gt;:ctype&lt;/code&gt;, &lt;code&gt;:messages&lt;/code&gt;, &lt;code&gt;:monetary&lt;/code&gt;, &lt;code&gt;:numeric&lt;/code&gt;, &lt;code&gt;:time&lt;/code&gt;, and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fdb180b333447352b78de9f2313423642a41c9" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt;. See the documentation of your operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; syscall to see which values and flag bits are available. You may combine several flags using the &lt;code&gt;|&lt;/code&gt;-operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">Возможные значения и биты флагов параметра MODE зависят от системы; они доступны через стандартный модуль &lt;code&gt;Fcntl&lt;/code&gt; . См. Документацию по вашей операционной системе</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">Возможно предполагаемый текст ссылки; то есть, если не было реального текста ссылки, то это текст, который мы выведем вместо него. (Например, для &amp;laquo;L &amp;lt;Getopt :: Std&amp;gt;&amp;raquo; предполагаемый текст ссылки будет &amp;laquo;Getopt :: Std&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">Практика говорить: &amp;laquo;Если бы мне пришлось делать это все заново, я бы сделал это по-другому&amp;raquo;, а затем фактически возвращался и делал все по-другому. С математической точки зрения, это возвращение после неудачной рекурсии на дереве возможностей. Perl откатывает назад, когда пытается сопоставить шаблоны с &lt;b&gt;регулярным выражением&lt;/b&gt; , и его предыдущие попытки не увенчались успехом. См. Раздел &amp;laquo;Маленький паровозик, который / не может (не)&amp;raquo; в главе 5 Camel &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">Практика сдвига алфавита одним или несколькими символами для шифрования насчитывает тысячи лет и была подробно описана Гаем Юлием Цезарем в его тексте &lt;b&gt;Галльских войн&lt;/b&gt; . Один сдвиг в алфавитном порядке иногда называют вращением, и величина сдвига указывается в виде числа $ n после строки &quot;rot&quot; или &quot;rot $ n&quot;. Rot0 и rot26 обозначают идентификационные карты на английской версии латинского алфавита из 26 букв. Rot13 обладает тем интересным свойством, что чередующиеся последующие вызовы являются тождественными отображениями (таким образом, rot13 является собственным нетривиальным обратным в группе из 26 поворотов алфавита). Следовательно, следующий кодировщик и декодер rot13 будет работать на платформах ASCII и EBCDIC:</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">Прагма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; составляет &lt;code&gt;$?&lt;/code&gt; отражать фактический статус выхода VMS вместо эмуляции по умолчанию статуса POSIX, описанной выше. Эта прагма также отключает преобразование ненулевых значений в SS $ _ABORT при установке &lt;code&gt;$?&lt;/code&gt; в блоке END (но ноль все равно будет преобразован в SS $ _NORMAL).</target>
        </trans-unit>
        <trans-unit id="91d3ea3fbae8cd7072d27f773df4ade3db8e3a56" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">Прагма была для каждого скрипта, а не для каждого блока лексической. Имеет значение только последняя &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; или &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; , и это влияет &lt;b&gt;на весь сценарий&lt;/b&gt; . Тем &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; менее, прагма no encoding поддерживалась, и &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; могло появляться столько раз, сколько вы хотите в данном сценарии (хотя только последний был эффективным).</target>
        </trans-unit>
        <trans-unit id="9e7b1da1b87c8f47d3de1bab74d0b204e260e393" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;use encoding&lt;/code&gt; or &lt;code&gt;no encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;no encoding&lt;/code&gt; pragma was supported and &lt;code&gt;use encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">Псевдокомментарии &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;BIGINT&lt;/a&gt; и &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; также могут быть интересны тем , что они решают autoupgrading / Откат вопрос, по крайней мере , частично.</target>
        </trans-unit>
        <trans-unit id="76569ddba56c9f99056592d21ac1b2ff490f26ec" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">Преамбула,добавляемая к каждому выходному файлу,довольно многословна,и большая ее часть необходима только при наличии не-ASCII символов.В идеале было бы неплохо,если бы все эти определения выводились только при необходимости,возможно,на лету,так как используются символы.</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">Код преамбулы класса выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">Предпочтение обработчика &lt;b&gt;регулярных выражений&lt;/b&gt; совпадать с крайним левым вхождением &lt;b&gt;шаблона с&lt;/b&gt; учетом позиции, в которой будет происходить совпадение, предпочтение самого длинного совпадения (при условии использования &lt;b&gt;жадного&lt;/b&gt; квантификатора). См. Главу 5 &amp;laquo;Верблюд&amp;raquo; &amp;laquo;Сопоставление с образцом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">Предпочтительный способ сделать это - объявить план при &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5006ab06a26ab8e5eca93c03d0291151f3f3136d" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;use Test::More&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">Префикс, указанный в &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; будет использоваться с числовым суффиксом, если имя для значения не определено.</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">Наличие слова &quot;FATAL&quot; в списке категорий приведет к тому,что предупреждения в этих категориях превратятся в фатальные ошибки в этом лексическом диапазоне.</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">Предыдущие задания в точности эквивалентны</target>
        </trans-unit>
        <trans-unit id="131e26e34a6a280e8d155fa06c2fe106438c82bd" translate="yes" xml:space="preserve">
          <source>The previous behavior of putting the errors (converted to POSIX-style &lt;code&gt;E*&lt;/code&gt; error codes since Perl 5.20.0) into &lt;code&gt;$!&lt;/code&gt; was buggy due to the non-equivalence of like-named Winsock and POSIX error constants, a relationship between which has unfortunately been established in one way or another since Perl 5.8.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">Предыдущий пример не был особенно полезен.Чтобы сделать его более общим,мы будем использовать контекстные данные и позволим произвольные</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">Предыдущий абзац дословно применим к привязанному хеш-доступу с использованием &lt;code&gt;hv_store&lt;/code&gt; и &lt;code&gt;hv_store_ent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">Предыдущий раздел (введенный командой a &lt;code&gt;=head&lt;/code&gt; ) не содержит текста. Обычно это указывает на то, что чего-то не хватает. Примечание: A &lt;code&gt;=head1&lt;/code&gt; , за которым сразу следует &lt;code&gt;=head2&lt;/code&gt; , не вызывает это предупреждение.</target>
        </trans-unit>
        <trans-unit id="b2d4d760a41ac2c4684274cd24041bdb5438342a" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any valid content. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">Предыдущий созданный шаг</target>
        </trans-unit>
        <trans-unit id="d900c388659851ed663901ca396af85f982c5cba" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&quot;LD_LIBRARY_PATH&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">Основная причина сообщения &amp;laquo;dlopen: stub interception failed&amp;raquo; заключается в том, что переменная среды LD_LIBRARY_PATH включает каталог, который является символической ссылкой на / usr / lib (например, / lib). См. &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; выше.</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">Основная цель этого модуля - предоставить доступ для потоковой записи к zip-файлам и буферам. Это не универсальный файловый архиватор. Если это то, что вам нужно, посмотрите &lt;code&gt;Archive::Zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7109b8aae18759607febf6d98f672f7929c0c0ad" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; or &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3562a709266ee6938735493658a732dcdd3f50d6" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5865d60bf4675397309adf39254a9c20e60ce62" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaddbe76e40b85855bdb3acd3e478586223f423" translate="yes" xml:space="preserve">
          <source>The primary reference for gzip files is RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc24d550b4fe8851d0897e687949d42067e8b5a9" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172150eb79f9c57ed50477a5e17aef4d85de5065" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcb3725358ae123bceedddb8d71ef7119024583" translate="yes" xml:space="preserve">
          <source>The primary site for bzip2 is &lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">Основной сайт для gzip является</target>
        </trans-unit>
        <trans-unit id="e859dd2ba7bc9bbaa39a1807494221205b0a4770" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is &lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">Основной сайт для</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">Основным сайтом для программы bzip2 является</target>
        </trans-unit>
        <trans-unit id="6d5111f3cd60b1576c60bc8b7e186e70a9cf368f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is &lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">Основное значение касательной дуги y/x</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">Принцип заключается в том, что количество найденных объектов влияет на то, как объект отображается. Если поиск находит один элемент, результат отображается с помощью довольно подробного метода &lt;code&gt;as_string&lt;/code&gt; , но если найдено более одного объекта, каждый объект отображается с помощью &lt;code&gt;as_glimpse&lt;/code&gt; метода as_glimpse .</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">Оператор print () не добавляет разделители полей и записей, если вы не установили &lt;code&gt;$,&lt;/code&gt; и &lt;code&gt;$\&lt;/code&gt; . Вы можете установить $ OFS и $ ORS, если используете английский модуль.</target>
        </trans-unit>
        <trans-unit id="2da7e391c9fd1ea8ee0cde415f9757d6cf29bace" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt;. You can set $OFS and $ORS if you're using the English module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38b92f2492beff5f39d922c93e2a6ed6bba00e9" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;_installed_file_for_module&lt;/code&gt; method may be replaced with other methods for locating a module in &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">Кэш частных данных будет владеть ссылкой на private_sv, почти так же, как &lt;code&gt;hv_store()&lt;/code&gt; получает право владения ссылкой на значение, которое вы ему передаете.</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">Хеш-ключи закрытого объекта, такие как &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; не могут быть изменены, но могут быть добавлены дополнительные ключи, такие как &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22731711df90de28382d892b4f249e651429dc6f" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660e221c9f99f43f8d3110d11068349758eb697d" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; can restore it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">Частная переменная используется для сохранения текущего состояния локали, так что требуемый соответствующий вызов &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; может восстановить его.</target>
        </trans-unit>
        <trans-unit id="2ca51914e8f8318dafeffce74323b676d587ba34" translate="yes" xml:space="preserve">
          <source>The private_use feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">Проблема может быть дополнительно рассмотрена в примерно эквивалентной программе на языке С:</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">Проблема возникает, когда вы берете свои числа из чего-то, что Perl считает строкой, например, аргумента командной строки в &lt;code&gt;@ARGV&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c1b07cc8bfa77fdc4b2aa2cb8ca8cba9947e03f" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">Проблема возникает,когда,например,у вас есть строка,которая не помечена как UTF-8,и содержит последовательность байтов,которая может быть UTF-8-особенно при объединении строк без UTF-8 и UTF-8.</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">Проблема существует потому, что анонимная подпрограмма, назначенная &lt;code&gt;__ANON__&lt;/code&gt; &lt;code&gt;*Foo::foo&lt;/code&gt; будет отображаться в стеке вызовов как вызываемая __ANON__, а не &lt;code&gt;foo&lt;/code&gt; , как вы могли ожидать. Поскольку &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; использует &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; для поиска имени метода, в котором он был вызван, в этом случае он завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="f6e3278fa9663415debfd4e39d0b068a1659902a" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;next::method&lt;/code&gt; uses &lt;code&gt;caller&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">Проблема здесь в том, что Uid_t может быть не только не &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; -wide, но и беззнаковым, и в этом случае большие uid будут печататься как отрицательные значения.</target>
        </trans-unit>
        <trans-unit id="27a99efdaf6b6471f2df947f1f817dd0e909810c" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;int&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">Проблема здесь в том, что и группа с именем &lt;code&gt;a&lt;/code&gt; , и группа с именем &lt;code&gt;b&lt;/code&gt; являются псевдонимами для группы, принадлежащей к &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b18408c3bf47516e5c9af25c6047a1bd86154733" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">Проблема в том,что Perl имеет предупреждения как о времени компиляции,так и о времени выполнения.Чтобы отключить предупреждения во время компиляции,необходимо переписать код таким образом:</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">Проблема в том, что и &lt;code&gt;rp&lt;/code&gt; , и &lt;code&gt;dp&lt;/code&gt; являются указателями на одно и то же место в памяти! В C вам нужно не забыть выполнить malloc () себе новую память. В Perl вместо этого вы захотите использовать конструктор массива &lt;code&gt;[]&lt;/code&gt; или конструктор хеша &lt;code&gt;{}&lt;/code&gt; . Вот правильный способ сделать предыдущие фрагменты сломанного кода:</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">Проблема в том,что grep строит список возврата независимо от контекста.Это означает,что вы заставляете Perl пойти на проблему построения списка,который вы просто выбрасываете.Если список большой,вы тратите и время,и место.Если вы хотите провести итерацию по списку,то используйте для этого цикл.</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">Проблема в том,что ни один из этих примеров не является надежным:они зависят от командного интерпретатора.В Unix первые два часто работают.В DOS вполне возможно,что ни один из них не работает.Если бы 4DOS была командной оболочкой,вам,вероятно,повезло бы так:</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">Проблема в том,что все это не является надежным:это зависит от команды,и вполне возможно,что ни то,ни другое не работает.Если</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">Проблема в том, что этот код всегда будет анализироваться и выполняться, даже если уровень отладки, установленный в файле конфигурации ведения журнала, равен нулю. Как только подпрограмма debug () была введена и внутренняя переменная &lt;code&gt;$debug&lt;/code&gt; , например, была подтверждена равной нулю, отправленное сообщение будет отброшено, и программа продолжит работу. Однако в приведенном примере хэш &lt;code&gt;\%INC&lt;/code&gt; уже был сброшен, а строка сообщения построена, и всю эту работу можно обойти с помощью переменной отладки на уровне оператора, например:</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">Проблема в том,что этот код</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">Проблема в том,что эти двойные кавычки форсируют строковуюфикацию-когерсирование чисел и ссылок в строки-даже если вы не хотите,чтобы они были строками.Подумайте об этом так:расширение в двойных кавычках используется для создания новых строк.Если у вас уже есть строка,зачем вам нужно больше?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">Проблема в том,что различные структуры,видимые через procfs,используют off_t,и если вы компилируете с поддержкой больших файлов,то это изменение от 32 бит до 64 бит.Таким образом,то,что вы получаете от procfs,не совпадает со структурами на perl,что приводит к мусору.Обратитесь к proc(4)для дальнейшего обсуждения.</target>
        </trans-unit>
        <trans-unit id="36b3f29973dcb4084c4233c180d15ad0f5ad2090" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt;: one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">Проблема заключается во вложенных неопределенных квантификаторах. Есть много разных способов разбить строку длины n между &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;*&lt;/code&gt; : одно повторение с &lt;code&gt;b+&lt;/code&gt; длины n, два повторения с первым &lt;code&gt;b+&lt;/code&gt; длиной k и второе с длиной nk, m повторений, биты которых в сумме составляют длину n и т.д. На самом деле существует экспоненциальное количество способов разбить строку в зависимости от ее длины. Регулярному выражению может повезти, и оно может совпадать на ранней стадии процесса, но если совпадений нет, Perl попытается</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">Проблема обычно заключается в том,что командные интерпретаторы на этих системах имеют довольно разные представления о цитировании,нежели Unix-оболочки,под которыми создавались однослойные оболочки.На некоторых системах может потребоваться изменить одинарные кавычки на двойные,которые должны</target>
        </trans-unit>
        <trans-unit id="814a82003c2ef63857b1187789261eb0a14ef57b" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;$writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">Проблема в том, что буферизация действительно испортит вам день. Несмотря на то, что ваш дескриптор файла &lt;code&gt;Writer&lt;/code&gt; автоматически очищается, поэтому процесс на другом конце своевременно получает ваши данные, вы обычно не можете ничего сделать, чтобы заставить этот процесс передать вам свои данные таким же быстрым способом. В этом частном случае мы могли бы это сделать, потому что мы дали</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">Обе проблемы, связанные со сборкой мусора и безопасностью потоков, решаются функцией &lt;code&gt;register()&lt;/code&gt; . Он регистрирует объект вместе с любым количеством хешей. Реестр означает, что, когда объект умирает, запись в любом из хешей под ссылочным адресом этого объекта будет удалена. Это гарантирует сборку мусора в этих хэшах. Это также означает, что при клонировании потока записи объекта в зарегистрированных хэшах будут заменены обновленными записями, ключ которых является ссылочным адресом клонированного объекта. Таким образом, ассоциация объект-данные становится поточно-ориентированной.</target>
        </trans-unit>
        <trans-unit id="d49a5cf6f714984f5d4aa1ae27ae4adaa45ad30d" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt;. It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef2d934929be669275ad225ef041e450d29108" translate="yes" xml:space="preserve">
          <source>The procedure for doing this is roughly as follows (using the example of tonyc's smoke-me branch called win32stat):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9452ac7ff4d68965b2304a021a3f491d59cd9f05" translate="yes" xml:space="preserve">
          <source>The process ID in which the event was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">Номер процесса Perl,выполняемого этим скриптом.Хотя вы</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">Процесс преобразования строки в одну из четырех &lt;b&gt;casemaps&lt;/b&gt; Unicode ; в Perl это реализовано с помощью функций &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; и &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3ce77cc42e100f56e2fb73208b06058b72b962" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;fc&lt;/code&gt;, &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ucfirst&lt;/code&gt;, and &lt;code&gt;uc&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">Процесс определения того, какой метод следует использовать, называется &lt;b&gt;разрешением метода&lt;/b&gt; . Что делает Perl, так это сначала смотрит на класс объекта ( в данном случае &lt;code&gt;File::MP3&lt;/code&gt; ). Если этот класс определяет метод, то вызывается версия метода этого класса. В противном случае Perl просматривает каждый родительский класс по очереди. Для &lt;code&gt;File::MP3&lt;/code&gt; его единственным родительским элементом является &lt;code&gt;File&lt;/code&gt; . Если &lt;code&gt;File::MP3&lt;/code&gt; не определяет метод, а &lt;code&gt;File&lt;/code&gt; определяет , тогда Perl вызывает метод в &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d45b13e98be85d3a3cff56a4de1619efcb5c0e5" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt;, its only parent is &lt;code&gt;File&lt;/code&gt;. If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">Процесс приклеивания носа одной кошки к хвосту другой кошки. Тоже аналогичная операция на двух &lt;b&gt;строках&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">Процесс создания &lt;b&gt;строкового&lt;/b&gt; представления абстрактного объекта.</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">Процесс опробования одной альтернативы,проверки ее соответствия и перехода к следующей альтернативе,при этом возвращаясь в строку,откуда была опробована предыдущая альтернатива,если она не была опробована,называется</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">Процесс преобразования исходного кода в форму, пригодную для машинного использования. См. &lt;b&gt;Этап компиляции&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2c86388b6b25502da94ef398d94ba381de4e7acd" translate="yes" xml:space="preserve">
          <source>The program assumes prior understanding of the internal structure of a Zip file. You should have a copy of the Zip APPNOTE file at hand to help understand the output from this program (&lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">Программу можно заставить запустить,&quot;отмывая&quot; запятнанное значение через регулярное выражение:второй пример-который по-прежнему игнорирует информацию о локали-запускается,создавая файл с именем в командной строке,если это возможно.</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">Программа вылетает, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , вызывает &lt;code&gt;closelog&lt;/code&gt; , журнал окончен.</target>
        </trans-unit>
        <trans-unit id="acb249bf3e58472d9c05a98a3d9fd3a22a634ed9" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;die&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt;, the log is over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">Программа h2xs является отправной точкой для создания расширений.В последующих примерах мы увидим,как можно использовать h2xs для чтения заголовочных файлов и генерации шаблонов для подключения к C-программам.</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">Программа состоит из двух частей: строки 2-7 читают ввод и создают структуру данных, а строки 8-13 анализируют данные и распечатывают отчет. У нас будет хеш- &lt;code&gt;%table&lt;/code&gt; , ключи которой являются названиями стран, а значения - ссылками на массивы названий городов. Структура данных будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="467c57531a345de9ffd810bfeb5971919e96c865" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2-7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt;, whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">Программа представлена ​​массивом структур &lt;code&gt;regnode&lt;/code&gt; , одна или несколько из которых представляют один regop программы. Struct &lt;code&gt;regnode&lt;/code&gt; является самой маленькой структурой необходимо, и имеет структуру поля , которая совместно со всеми другими более крупными структурами.</target>
        </trans-unit>
        <trans-unit id="3ea55b0618cf1b22588d3366ef69169df7ae378e" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures. (Outside this document, the term &quot;regnode&quot; is sometimes used to mean &quot;regop&quot;, which could be confusing.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">Программа должна позаботиться о том,чтобы это произошло.</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">Программе потребовалось чуть более 17 секунд для запуска. Обратите внимание на разные значения &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; вывода, важно всегда использовать одно и то же и не путать, что означает каждое из них.</target>
        </trans-unit>
        <trans-unit id="453564270c1c0cd5131ab07331c35f9b9398730b" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;time&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">Программа остановится</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">Интерфейс программирования прост в использовании: он тот же, что и в модуле &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; CPAN . Итак, если ваши приложения в настоящее время используют &lt;a href=&quot;md5&quot;&gt;Digest :: MD5&lt;/a&gt; и вы предпочитаете более высокий уровень безопасности SHA, их просто преобразовать.</target>
        </trans-unit>
        <trans-unit id="7b1493356cb4a3eba009f1a11b50de871f482665" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;Digest::MD5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">Программы и документация в этом дистрибутиве распространяются в надежде,что они будут полезны,но без каких-либо гарантий;даже без подразумеваемой гарантии товарного состояния или пригодности для конкретной цели.</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">Запрос оболочки cpan может содержать текущий номер команды для более легкого отслеживания сеанса или быть простой строкой.</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">Свойство нижнего регистра перед прописными буквами в EBCDIC переносится даже на страницы Latin 1 EBCDIC, такие как 0037 и 1047. Например, &quot;&amp;Euml;&quot; ( &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) стоит перед &quot;&amp;euml;&quot; ( &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235 ) на платформе ASCII, но последняя (83) предшествует первой (115) на платформе EBCDIC. (Проницательные читатели заметят, что заглавная версия &amp;laquo;&amp;szlig;&amp;raquo; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; - это просто &amp;laquo;SS&amp;raquo; и что заглавные версии &amp;laquo;&amp;raquo; (маленький &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) и &amp;laquo;&amp;micro;&amp;raquo; ( &lt;code&gt;MICRO SIGN&lt;/code&gt; ) не входят в 0..255, но в Unicode, в Perl с поддержкой Unicode).</target>
        </trans-unit>
        <trans-unit id="d068c61e1d2738a4b949032692f164ea749e79a4" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt;, 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt;, 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt;) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">Протокол (например, &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1d688930b159b0de8e063999fc12f1fc3e668a59" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">Протокол также определяет несколько стандартных &lt;b&gt;переводов&lt;/b&gt;которому файл может подвергнуться во время передачи. Это ASCII, EBCDIC, двоичные и байтовые. ASCII является типом по умолчанию и указывает, что отправитель файлов переводит концы строк в стандартное представление, которое получатель затем переводит обратно в их локальное представление. EBCDIC указывает, что передаваемый файл находится в формате EBCDIC. Двоичный формат (также известный как изображение) отправляет данные в виде непрерывного битового потока. Байтовый формат передает данные как байты, значения которых остаются неизменными независимо от различий в размере байтов между двумя машинами (теоретически - на практике вы должны использовать это, только если вы действительно знаете, что делаете). Этот класс не поддерживает форматы EBCDIC или байтов и по умолчанию будет использовать двоичный формат, если они будут выполнены.</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">Прототип CV для &quot;моей&quot; подлодки.</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">Атрибут прототипа и любые другие атрибуты идут после подписи.</target>
        </trans-unit>
        <trans-unit id="571effb91670d02136e12104ead995a6cc16a1c2" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, must come before the signature. The signature always immediately precedes the block of the subroutine's body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">Прототип из атрибута назначается подпрограмме сразу после прототипа из подпрограммы, что означает, что если оба объявлены одновременно, традиционно определенный прототип игнорируется. Другими словами, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; неотличим от &lt;code&gt;sub foo(@){}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e026f2d40529605b03137d9a9ed6ef4bb374c7" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">Предоставленный аргумент ДОЛЖЕН быть равен строке для передачи валидации.</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">Предоставленный аргумент ДОЛЖЕН совпадать с одним из элементов массива ref для прохождения проверки.Справка по массиву может содержать все вышеперечисленные значения.</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">Предоставленный аргумент ДОЛЖЕН совпадать с регулярным выражением для передачи валидации.</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">Предоставленная подпрограмма ДОЛЖНА возвращать true для того,чтобы проверка прошла,а аргумент был принят.</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">Функция псевдохеширования была экспериментальной функцией, представленной в более ранних версиях Perl и удаленной в 5.10.0. Псевдохеш - это ссылка на массив, доступ к которой можно получить с помощью именованных ключей, таких как хеш. Вы можете столкнуться с каким-то кодом в дикой природе, который его использует. Дополнительную информацию см. В прагме &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">Публичный API должен оставаться последовательным,т.е.если подкласс является перегрузочным дополнением,то подкласс должен использовать одно и то же имя,в данном случае badd().Причина этого заключается в том,что Math::BigInt оптимизирован для прямого вызова методов объекта.</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">Назначение макроса &lt;code&gt;SPAGAIN&lt;/code&gt; - обновить локальную копию указателя стека. Это необходимо, потому что возможно, что память, выделенная стеку Perl, была перераспределена во время</target>
        </trans-unit>
        <trans-unit id="211ca4f47d195354704ae118cbe1d64c1c871ea0" translate="yes" xml:space="preserve">
          <source>The purpose of the pragma is to alert users to the status of such a module by issuing a warning that encourages them to install the module from CPAN, so that a future upgrade to a perl which omits the module will not break their code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">Цель тестирования двоякая:во-первых,помочь разработчикам исправить любые проблемы в их коде,возникающие из-за отсутствия тестирования на других платформах;во-вторых,предоставить пользователям информацию о том,работает ли данный модуль на данной платформе.</target>
        </trans-unit>
        <trans-unit id="a5dd5b4e9fced711b08542f3e0ab81c18273f9bd" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to document what has been deprecated in Perl, and by which version the deprecated feature will disappear, or, for already removed features, when it was removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">Цель этого документа-показать вам,как вызывать подпрограммы Perl непосредственно из C,т.е.как писать</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">Цель этого модуля - предоставить широкий спектр утилит для тестирования. Различные способы сказать &amp;laquo;хорошо&amp;raquo; с лучшей диагностикой, возможностями пропустить тесты, протестировать будущие функции и сравнить сложные структуры данных. Хотя с помощью простой функции &lt;code&gt;ok()&lt;/code&gt; можно делать почти все , она не обеспечивает хороших результатов диагностики.</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">Назначение,область применения и целевые приложения вашего модуля</target>
        </trans-unit>
        <trans-unit id="cb81c6a18976d12ebe998a0a0b9af8a1bf213151" translate="yes" xml:space="preserve">
          <source>The pyramids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">Качество, которое заставляет прилагать большие усилия для снижения общих затрат энергии. Это заставляет вас писать трудосберегающие программы, которые другие сочтут полезными, а затем документировать то, что вы написали, чтобы вам не приходилось отвечать на так много вопросов по этому поводу. Отсюда первое великое достоинство программиста. Отсюда и эта книга. Смотрите также &lt;b&gt;нетерпеливость&lt;/b&gt; и &lt;b&gt;высокомерие&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">Вопрос об эквивалентности строк в Юникоде несколько усложняется:что вы имеете в виду под &quot;равным&quot;?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">Вопрос остается открытым,когда SV,которые являются</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">Вопрос,конечно,в том,зачем тебе делать что-то подобное? Зачем создавать семафор со стартовым счётом,который не является единичным,или зачем уменьшать или увеличивать его более чем на единицу? Ответ-доступность ресурсов.Многие ресурсы,для которых вы хотите управлять доступом,могут безопасно использоваться несколькими потоками одновременно.</target>
        </trans-unit>
        <trans-unit id="7e4709a385e818a7adc04721b36836ff38439abe" translate="yes" xml:space="preserve">
          <source>The quick answer is because they are easy to implement yourself. The long answer is that to write these in such a way that multiple platforms are supported correctly would just require too much code. Below are some examples how you can implement these yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">Быстрый и грязный метод хорошо работает только в том случае,если вы не планируете оставлять закомментированный код в исходных текстах.Если появится парсер Pod,ваш многострочный комментарий появится в переводе Pod.Лучше скрыть его и от парсеров Pod.</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">Самый быстрый и грязный способ закомментировать более одной строки Perl - окружить эти строки директивами Pod. Вы должны поместить эти директивы в начало строки и где-нибудь там, где Perl ожидает новый оператор (а не в середине таких операторов, как комментарии &lt;code&gt;#&lt;/code&gt; ). Вы заканчиваете комментарий с помощью &lt;code&gt;=cut&lt;/code&gt; , заканчивая раздел Pod:</target>
        </trans-unit>
        <trans-unit id="d90a105b257205ce48226d803e75858a07587fa6" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt;, ending the Pod section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">Коэффициент всегда является наибольшим целым числом,меньшим или равным реальному значению коэффициента двух операндов,а остаток (когда он ненулевой)всегда имеет тот же знак,что и второй операнд;так,например,</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">Случайные символы предоставляются программой File::Temp и гарантируют уникальность индивидуальной директории сборки каждого модуля.Это делает одновременный запуск CPAN.pm в параллельных процессах безопасным.</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">Оператор диапазона (в контексте списка)использует магический алгоритм автоинкремента,если операнды являются строками.Можно сказать</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">Оператор диапазона &lt;code&gt;..&lt;/code&gt; не может быть перегружен.</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">Оператор диапазона также работает со струнами,используя магическое автоинкрементирование,см.ниже.</target>
        </trans-unit>
        <trans-unit id="31d3e334c25d2382911ee65d3fae61de81e23584" translate="yes" xml:space="preserve">
          <source>The range operator in list context can make use of the magical auto-increment algorithm if both operands are strings, subject to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">Оператором диапазона является &quot;...&quot;,а не запятая.Оператор запятая работает как в C.</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">Оператор диапазона - это &lt;code&gt;...&lt;/code&gt; , а не запятая.</target>
        </trans-unit>
        <trans-unit id="6702b09bbe69f958fa5f9869c6ae81b0c789760d" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt;, rather than comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fb6d64bc39d2dbbf811ff985ded944bd6951e6" translate="yes" xml:space="preserve">
          <source>The rationale for inclusion in this module is that the function performs some work for which an XS implementation is essential because it cannot be implemented in Pure Perl, and which is sufficiently-widely used across CPAN that its popularity warrants inclusion in a core module, which this is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">Причина для требования этого состоит в том, чтобы не сломать старые программы, которые полагаются на то, как все работало до появления Unicode. Эти старые программы знали только о наборе символов ASCII и поэтому могли некорректно работать с дополнительными символами. Когда строка кодируется в UTF-8, Perl предполагает, что программа подготовлена ​​к работе с Unicode, но когда строка не работает, Perl предполагает, что нужен только ASCII, и поэтому те символы, которые не являются символами ASCII, не узнал, какими они будут в Юникоде. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 'unicode_strings' указывает Perl обрабатывать все символы как Unicode, независимо от того, закодирована ли строка в UTF-8 или нет, таким образом избегая проблемы.</target>
        </trans-unit>
        <trans-unit id="cd600fcbf1a6b70419da39d25dfcf62c3af89b3f" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062d7f6e6f9ffa42523f91b3b98af5b6e21dddc1" translate="yes" xml:space="preserve">
          <source>The raw floppy disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of the floppy disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the floppy disk or drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">Необработанное исходное содержимое L &amp;lt;...&amp;gt; до разделения текста на &amp;laquo;|&amp;raquo;, &amp;laquo;/&amp;raquo; и т. Д. И до раскрытия кодов E &amp;lt;...&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">Доступная только для чтения волшебная переменная &lt;code&gt;${^UNICODE}&lt;/code&gt; отражает числовое значение этого параметра. Эта переменная устанавливается при запуске Perl и после этого доступна только для чтения. Если вам нужны эффекты времени выполнения, используйте open () с тремя аргументами (см. &lt;a href=&quot;functions/open&quot;&gt;Open&lt;/a&gt; ), binmode () с двумя аргументами (см. &lt;a href=&quot;functions/binmode&quot;&gt;Binmode&lt;/a&gt; ) и прагму &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (см. &lt;a href=&quot;open&quot;&gt;Open&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7133d99787afc8bed88333155f330e0814f3badc" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;), and the &lt;code&gt;open&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">Настоящая гид этого процесса. Если вы работаете на машине, которая поддерживает членство в нескольких группах одновременно, выдает список групп, в которых вы &lt;code&gt;getgid()&lt;/code&gt; через пробел . Первое число - это число, возвращаемое функцией getgid () , а последующие - &lt;code&gt;getgroups()&lt;/code&gt; , одна из которых может быть таким же, как первое число.</target>
        </trans-unit>
        <trans-unit id="1b0d46bf2b89fe3b91282dbaf19dbfd7a631baf9" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">Реальный порядковый номер OP, как обычный номер, не скорректированный так, чтобы он соответствовал началу реальной программы. (Обычно это довольно большое число, потому что весь &lt;b&gt;B :: Concise&lt;/b&gt; компилируется раньше, чем ваша программа).</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">Время в реальном времени выполняется с использованием времени(2),поэтому гранулярность составляет всего одну секунду.</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">Реальный идентификатор этого процесса. Вы можете изменить как реальный uid, так и эффективный uid одновременно, используя &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Поскольку для изменения &lt;code&gt;$&amp;lt;&lt;/code&gt; требуется системный вызов, проверьте &lt;code&gt;$!&lt;/code&gt; после изменения попытаться обнаружить возможные ошибки.</target>
        </trans-unit>
        <trans-unit id="2ac048e62e66a7879f9411bea5e557339bb43fff" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">Реальная работа выполняется в стандартной типографской карте.</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">Причина существования &lt;code&gt;encode_language_tag&lt;/code&gt; заключается в том, что разные языковые теги могут представлять один и тот же язык; обычно это можно лечить с помощью &lt;code&gt;same_language_tag&lt;/code&gt; , но рассмотрим эту ситуацию:</target>
        </trans-unit>
        <trans-unit id="3ce46cd4af70310d3ca26a396ea6fdf7fb3672f3" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt;, but consider this situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">Причина,по которой я сказал &quot;в данном случае&quot;,в том.</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">Причина,по которой не проверяется возвращаемое значение из функции print(),заключается в буферизации трубы;физическая запись задерживается.Она не взорвется до закрытия,а взорвется с помощью SIGPIPE.Чтобы поймать его,можно использовать вот это:</target>
        </trans-unit>
        <trans-unit id="5243164bf937a2da41254af85f8953f57eda8b63" translate="yes" xml:space="preserve">
          <source>The reason for the bailout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ad92ed56d2b83c1783a3daf037c2fcef9e124" translate="yes" xml:space="preserve">
          <source>The reason for the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e74d3011543f0cacc6e865a92179ab3feabba8" translate="yes" xml:space="preserve">
          <source>The reason for the skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">Причина этого в том, что CPAN не знает зависимости всех модулей при запуске. Чтобы решить, какие дополнительные элементы нужно установить, он просто использует данные из файла META.yml или созданного файла Makefile. Необнаруженный недостающий элемент нарушает процесс. Но вполне может быть, что ваш Bundle устанавливает некоторые предварительные условия позже, чем какой-либо зависимый элемент, и, таким образом, ваша вторая попытка сможет решить все. Обратите внимание, что CPAN.pm заранее не знает дерево зависимостей и не может отсортировать очередь вещей для установки в топологически правильном порядке. Он отлично разрешается, &lt;b&gt;если&lt;/b&gt; все модули правильно объявляют предварительные условия с атрибутом PREREQ_PM для MakeMaker или &lt;code&gt;requires&lt;/code&gt; строфа Module :: Build. Для пакетов, которые не работают и вам нужно часто устанавливать, рекомендуется вручную отсортировать файл определения пакета.</target>
        </trans-unit>
        <trans-unit id="9dfe6b3d7e7af99fa8c5c069ac28ca23f9e16764" translate="yes" xml:space="preserve">
          <source>The reason for this is that the &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; operator will turn &quot;v1.0&quot; into the equivalent string &quot;1.000000&quot;. Forcing the outer version object to &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; form will display the mathematically equivalent &quot;v1.0.0&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">Причина такой непригодности заключается в том, что фундаментальное предположение Perl состоит в том, что символы, которые он заботится для синтаксического анализа и лексического анализа, одинаковы, независимо от того, находится ли текст в UTF-8. Например, Perl ожидает, что символ &lt;code&gt;&quot;[&quot;&lt;/code&gt; будет иметь одно и то же представление, независимо от того, закодирована ли строка, содержащая его (или текст программы), в кодировке UTF-8 или нет. Чтобы гарантировать это, Perl адаптирует UTF-EBCDIC к конкретной кодовой странице, так что все символы, которые он ожидает инвариантными для UTF-8, фактически инвариантны для UTF-8. Это означает, что текст, сгенерированный на компьютере с одной версией Perl UTF-EBCDIC, должен быть переведен, чтобы он был понятен компьютеру, на котором запущена другая.</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">Причина в том,что Encode::Guess угадывает кодировку методом проб и ошибок.Сначала он разбивает $data на строки и пытается декодировать строку для каждого подозреваемого.Он продолжает работать до тех пор,пока все кодировки,кроме одной,не будут удалены из списка подозреваемых.Серия ISO-8859 просто слишком успешна для большинства случаев (потому что она заполняет почти все кодовые пункты на \x00-\xff).</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">Причина в том,что переменная интерполяция и выражения кода вместе представляют собой риск безопасности.Эта комбинация опасна,так как многие программисты,пишущие поисковые системы,часто берут пользовательский ввод и подключают его непосредственно к регеxp:</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">Причина в том,что кодировка производителя обычно является сверхнормативным национальным стандартом,поэтому в большинстве случаев она становится слишком двусмысленной.</target>
        </trans-unit>
        <trans-unit id="76e332a13c138bbbc50c17d9967b9928970c16a2" translate="yes" xml:space="preserve">
          <source>The reason it isn't quite a drop-in replacement is actually an advantage. The only difference is that it returns &lt;code&gt;const char *&lt;/code&gt;, whereas plain &lt;code&gt;nl_langinfo()&lt;/code&gt; returns &lt;code&gt;char *&lt;/code&gt;, but you are (only by documentation) forbidden to write into the buffer. By declaring this &lt;code&gt;const&lt;/code&gt;, the compiler enforces this restriction, so if it is violated, you know at compilation time, rather than getting segfaults at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0f1d70e28ee48bb2440f0dfad9e2b39b29922f" translate="yes" xml:space="preserve">
          <source>The reason that &lt;code&gt;host $failed_ack_host&lt;/code&gt; did not receive a valid ACK. Useful to find out why when &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; returns a false value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">Причина,по которой не делается то,что вы хотите,заключается в том,что назначение такого именованного массива скаляру происходит в контексте скаляра,а это значит,что просто подсчитывается количество элементов в @tmp.</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">Причина,по которой хост $failed_ack_host не получил действительный ACK.Полезно,чтобы выяснить почему,когда функция ack($fail_ack_host)возвращает ложное значение.</target>
        </trans-unit>
        <trans-unit id="761e66631890fba3f96026c5ab632825150c6b23" translate="yes" xml:space="preserve">
          <source>The reason that using gettext runs into walls (as in the above second-person horror story) is that you're trying to use a string (or worse, a choice among a bunch of strings) to do what you really need a function for -- which is futile. Preforming (s)printf interpolation on the strings which you get back from gettext does allow you to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">Причина,по которой эта функция имеет &quot;_strictly&quot; в названии,заключается в том,что когда вы обрабатываете список Accept-Language согласно RFC,если вы интерпретируете RFC достаточно строго,то вы будете использовать implicate_supers_strictly,но для нормального использования (т.е.для здравого смысла,насколько я понимаю)вы будете использовать импликат_supers.</target>
        </trans-unit>
        <trans-unit id="00e0d83a9d5edf83f32ea0d0701c8b2f4b38f236" translate="yes" xml:space="preserve">
          <source>The reason this is considered to be only partially implemented is that Perl has &lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt;&lt;code&gt;qr/\b{lb}/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; that are conformant with &lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX#14 &quot;Unicode Line Breaking Algorithm&quot;&lt;/a&gt;. The regular expression construct provides default behavior, while the heavier-weight module provides customizable line breaking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">Причина,по которой это необходимо,заключается в том,что область стека Perl,в которой они находились,скорее всего,была перезаписана чем-то другим к моменту возвращения контроля времени из</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">Причина,по которой это не является поведением по умолчанию,заключается в том,что содержимое RFC 1951 может быть обнаружено только при попытке его распаковки.Этот процесс подвержен ошибкам и может привести к ложным срабатываниям.</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">Причина,по которой это не является поведением по умолчанию,заключается в том,что содержимое lzma_alone может быть обнаружено только при попытке его распаковки.Этот процесс подвержен ошибкам и может привести к ложным срабатываниям.</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">Причина, по которой это неверно, заключается в том, что к тому времени, когда вы начнете использовать указатель &lt;code&gt;rememberSub&lt;/code&gt; в &lt;code&gt;CallSavedSub1&lt;/code&gt; , он может все еще относиться или не ссылаться на подпрограмму Perl, которая была записана в &lt;code&gt;SaveSub1&lt;/code&gt; . Это особенно актуально для следующих случаев:</target>
        </trans-unit>
        <trans-unit id="e2bf2d952027d4fe995c4250ed0910c8a499fa98" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt;, it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt;. This is particularly true for these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">Причины наиболее важных пропущенных тестов:</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">Распознанные яркие атрибуты цвета фона (цвета от 8 до 15):</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">Распознаются обычные атрибуты цвета фона (цвета от 0 до 7):</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">Распознаются обычные атрибуты цвета переднего плана (цвета от 0 до 7):</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">Признанные опции функции new()следующие.Все опции принимают один аргумент.</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">В Tru64 рекомендуется использовать родной компилятор Си.Родной компилятор производит гораздо более быстрый код (разница в скорости заметна:несколько десятков процентов),а также более корректный:если вы рассматриваете возможность использования компилятора GNU C,то следует использовать как минимум выпуск 2.95.3,так как известно,что при компиляции Perl все старые релизы gcc производят код с ошибками.Одним из проявлений этой нарушенности является дампинг ядра теста lib/sdbm;другим является дампинг ядра многих op/regexp и op/pat,или ext/Storable тестов (точный шаблон отказов в зависимости от релиза GCC и флагов оптимизации).</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">Рекомендуемый порядок разделов в документации на модуль Perl:</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">Рекомендуемый способ сборки Perl для OS/400 PASE-это сборка исходного кода Perl 5 (редакция 5.8.1 или более поздняя)под AIX.</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">Функции red()и green()будут похожи.Для их создания мы назначим закрывающий шрифт имени функции,которую мы пытаемся собрать.</target>
        </trans-unit>
        <trans-unit id="f9a173256f222e6807faedf390f953793a1d344d" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; will be decremented at the end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">Счетчик ссылок &lt;code&gt;sv&lt;/code&gt; будет уменьшаться в конце</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">Счетчик ссылок для каждого указанного параметра &lt;code&gt;SV*&lt;/code&gt; уменьшается.</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">Счетчик ссылок в списке имен блокнотов.</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">Счетчик ссылок на название площадки.</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">Счетчик ссылок в ведомости.В настоящее время это всегда 1.</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ссылка с &lt;code&gt;$foo&lt;/code&gt; на &lt;code&gt;$bar&lt;/code&gt; была ослаблена. Когда переменная &lt;code&gt;$bar&lt;/code&gt; выходит за пределы области видимости, она будет собрана в мусор. В следующий раз, когда вы посмотрите на значение клавиши &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; , оно будет &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1de879124c2751ad3ecd4b63c57cecfe27d3f64" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">Ссылка действительно сброшена,и мы наконец-то видим,с чем имеем дело.Наша цитата была совершенно верной,но неправильной для наших целей,когда &quot;и канитель&quot; трактовалась как 2 отдельных слова,а не как фраза,таким образом,выкидывая равномерно парную хэш-структуру из равновесия.</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">Ссылки,которые вы получаете из правила 2,это те же самые ссылки,которые вы получаете из правила 1:</target>
        </trans-unit>
        <trans-unit id="4f2739050aee8d49851e25b790d128e1ca19fbde" translate="yes" xml:space="preserve">
          <source>The regex_sets feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c14a48971a0368f8bbf545f9e2905f7ac019ed5" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">Регулярное выражение имеет единственную группировку, которая рассматривает комбинации из 4 букв, затем комбинации из 3 букв и т. Д. И использует &lt;code&gt;\g1&lt;/code&gt; для поиска повтора. Хотя &lt;code&gt;$1&lt;/code&gt; и &lt;code&gt;\g1&lt;/code&gt; представляют одно и то же, следует соблюдать осторожность, чтобы использовать только совпадающие переменные &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">Регулярное выражение соответствует открытой круглой скобке, одной или нескольким копиям чередования и закрытой круглой скобке. Чередование двухстороннее: первая альтернатива &lt;code&gt;[^()]+&lt;/code&gt; соответствует подстроке без скобок, а вторая альтернатива &lt;code&gt;\([^()]*\)&lt;/code&gt; соответствует подстроке, разделенной скобками. Проблема с этим регулярным выражением заключается в том, что оно является патологическим: оно содержит вложенные неопределенные кванторы вида &lt;code&gt;(a+|b)+&lt;/code&gt; . В части 1 мы обсуждали, как вложенные квантификаторы, подобные этому, могут занять экспоненциально много времени для выполнения, если совпадение невозможно. Чтобы предотвратить экспоненциальный взрыв, нам нужно предотвратить бесполезный возврат в какой-то момент. Это можно сделать, включив внутренний квантификатор как независимое подвыражение:</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">Структура regexp содержит все данные,которые perl должен знать,чтобы корректно работать с регулярным выражением.Она включает данные об оптимизациях,которые perl может использовать для определения того,действительно ли следует использовать регекс-движок,а также различную другую контрольную информацию,необходимую для правильного выполнения шаблонов в различных контекстах,например,закреплен ли каким-либо образом шаблон,или какие флаги использовались во время компиляции,или содержит ли программа специальные конструкции,о которых perl должен знать.</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">Регулярное выражение без модификатора &lt;code&gt;//x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">Регопы определены в</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">Регрессивные тесты для каждого оператора живут в</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">Двигатель регулярного выражения может быть весомым орудием в руках.На длинных строках и сложных шаблонах ему может потребоваться много работы,чтобы найти совпадение,а еще больше-решить,что совпадение невозможно.Рассмотрим такую ситуацию,как следующая.</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">Регулярное выражение для выполнения.</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">Регулярное выражение, соответствующее сбалансированному тексту, использует две новые (для Perl 5.10) функции регулярного выражения. Они описаны в &lt;a href=&quot;perlre&quot;&gt;perlre,&lt;/a&gt; и этот пример представляет собой модифицированную версию той же документации.</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">Связанная &lt;code&gt;base&lt;/code&gt; прагма объединит поля из базовых классов и любые поля, объявленные с помощью прагмы &lt;code&gt;fields&lt;/code&gt; . Это позволяет наследованию полей работать правильно. Унаследованные поля можно переопределить, но при включении предупреждений будет выдано предупреждение.</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">Соответствующий фрагмент из &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86d45b748524cf3c3ed19b4942d99f6682b785f8" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">Остаток входной строки (т.е.символы после извлеченной строки).При отказе возвращается вся строка.</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">Остальные аргументы перечисляют файлы,которые должны быть включены в tar-файл.Все эти файлы должны существовать.Любые файлы,которые не существуют или не могут быть прочитаны,беззвучно игнорируются.</target>
        </trans-unit>
        <trans-unit id="f73744579f886d96e9ed158f08b1414dc3c821e4" translate="yes" xml:space="preserve">
          <source>The remaining fields specify the starting and ending cylinder and head of the range of tracks to be formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">Остальные функции сокращения списка являются специализацией этой общей идеи.</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">Остальные категории локалей в настоящее время не используются самим Perl. Но снова обратите внимание, что вещи, с которыми взаимодействует Perl, могут использовать их, включая расширения вне стандартного дистрибутива Perl, а также операционную систему и ее утилиты. Обратите особое внимание на то, что строковое значение &lt;code&gt;$!&lt;/code&gt; и сообщения об ошибках, выдаваемые внешними утилитами, могут быть изменены &lt;code&gt;LC_MESSAGES&lt;/code&gt; . Если вы хотите иметь переносимые коды ошибок, используйте &lt;code&gt;%!&lt;/code&gt; . См. &lt;a href=&quot;errno&quot;&gt;Эррно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c93d95569d58cc954c309a9c37710dcae16b378b" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt;. If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">Остальные три аргумента &lt;code&gt;autosplit&lt;/code&gt; управляют другими параметрами autosplitter.</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">Остальные преобразования (например, hex -&amp;gt; oct, bin -&amp;gt; hex и т. Д.) Оставлены в качестве упражнения для склонного читателя.</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">Счетчик повторов для &lt;code&gt;u&lt;/code&gt; интерпретируется как максимальное количество байтов для кодирования на строку вывода, при этом 0, 1 и 2 заменены на 45. Счетчик повторов не должен превышать 65.</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Репертуар символов, которые может представлять Perl, является расширенным набором символов, определенных Консорциумом Unicode. На большинстве платформ порядковые значения символа, возвращаемые &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; являются</target>
        </trans-unit>
        <trans-unit id="b4becab04b9eae1dfa2922434e872f92f0ca7ffd" translate="yes" xml:space="preserve">
          <source>The replacement UNIVERSAL::VERSION, when used as a function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">Генерируемый отчет имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">Затем отчет группируется по &lt;b&gt;Пакету&lt;/b&gt; каждой переменной, подпрограммы или формата с особым случаем &amp;laquo;(лексические)&amp;raquo;, означающим лексические переменные. Каждое имя &lt;b&gt;объекта&lt;/b&gt; (неявно определяемое содержащим его &lt;b&gt;пакетом&lt;/b&gt; ) включает в себя символ (ы) типа в начале, где это возможно. Лексические переменные легче отслеживать, и они даже включали информацию для разыменования, где это возможно.</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">Доклад с</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">Запрос был сочтен небольшим, поэтому возможность его перехвата зависит от способа компиляции perl. По умолчанию это невозможно. Однако, если он скомпилирован для этого, Perl может использовать содержимое &lt;code&gt;$^M&lt;/code&gt; как аварийный пул после die () с этим сообщением. В этом случае ошибка возможна.</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">Запросы не всегда доходят до операционной системы:именно здесь в игру вступает буферизация PerlIO.</target>
        </trans-unit>
        <trans-unit id="c2923a29c348a827f2ff3da1221b43b0a603bfa9" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">Функция &quot;Требование&quot; будет на самом деле искать &quot;</target>
        </trans-unit>
        <trans-unit id="437fdd0ce3dd49b0cb6d8dbfa1617238f6bfc689" translate="yes" xml:space="preserve">
          <source>The require function will look for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">Требуемая функция будет искать &quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">Обязательными аргументами во время &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; являются хэш, пакет и ссылка на функцию &lt;code&gt;FETCH&lt;/code&gt; ing. Необязательными аргументами являются произвольные скалярные данные $, ссылка на функцию &lt;code&gt;EXISTS&lt;/code&gt; и начальные значения хэша и кеша существования.</target>
        </trans-unit>
        <trans-unit id="72b681659bb57f7021407ce5fd3ac4d104c48565" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;tie&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt;ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">Требования и требования к декларациям зависимостей</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">Остальное-дубликат кода из MM_Unix.Следует перенести код компоновщика на свой собственный метод.</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">Остальное предназначено для внутреннего использования данного пакета.В частности,если TIEHASH переписан,он должен позвонить SUPER::TIEHASH.</target>
        </trans-unit>
        <trans-unit id="fe2906e8b2561874cbab3bd035dddc47777e922a" translate="yes" xml:space="preserve">
          <source>The rest of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">Остальной файл .pm содержит пример кода для предоставления документации по расширению.</target>
        </trans-unit>
        <trans-unit id="7c74ae28959473b4a69a8f31fe847650cadce3cf" translate="yes" xml:space="preserve">
          <source>The rest of the META.yml file is one big YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt;, whose keys are described here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">Остальная часть описания функции может быть снабжена отступом или скорректирована влево.В следующем примере показана функция с левосторонней регулировкой тела.В большинстве примеров в этом документе тело функции будет иметь отступы для лучшей читабельности.</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">Остальная часть этого раздела может нуждаться в обновлении, но мы не знаем, что в нем должно быть сказано. &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;Отправляйте&lt;/a&gt; комментарии по адресу perlbug@perl.org .</target>
        </trans-unit>
        <trans-unit id="b6c6c6a28aca9f64e81536b5041a7bd3a852dd99" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please submit comments to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5215ed25fc6b559f1f45b7ad436f4f9831272e" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01295182848e9dbbe34960bfb27f883cc4035bb" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">Ранее перезапуск был реализован с использованием &lt;code&gt;longjmp&lt;/code&gt; в &lt;code&gt;regatom()&lt;/code&gt; обратно к &lt;code&gt;setjmp&lt;/code&gt; в &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , но это оказалось проблематичным, поскольку последняя представляет собой большую функцию, содержащую множество автоматических переменных, которые плохо взаимодействуют с возникающим потоком управления &lt;code&gt;setjmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb3a75ceb2d2ee1d3bf90c88d2151a6541e047d" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">Ограничение для операции сравнения состоит в том, что даже если, например, &lt;code&gt;cmp&lt;/code&gt; должна возвращать благословенную ссылку, автоматически сгенерированная функция &lt;code&gt;lt&lt;/code&gt; будет выдавать только стандартное логическое значение, основанное на числовом значении результата &lt;code&gt;cmp&lt;/code&gt; . В частности, в этом случае требуется рабочее числовое преобразование (возможно, выраженное в терминах других преобразований).</target>
        </trans-unit>
        <trans-unit id="f937ca260b1eebc06f72a3641b2c030503e4317b" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt;. In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">Результат &lt;code&gt;$^R&lt;/code&gt; автоматически локализуется, поэтому он будет вести себя правильно при наличии возврата.</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;Regexp&lt;/code&gt; указывает, что аргумент является регулярным выражением, полученным из &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Результат &lt;code&gt;Regexp&lt;/code&gt; указывает, что аргумент является регулярным выражением, полученным из &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa60f0453236256bf9eae460e1101cb5ebaf3da0" translate="yes" xml:space="preserve">
          <source>The result has a dual nature: it is a NaN, but it also carries the integer inside it. The integer can be retrieved with &lt;a href=&quot;#getpayload&quot;&gt;&quot;getpayload&quot;&lt;/a&gt;. Note, though, that the payload is not propagated, not even on copies, and definitely not in arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">Результат возвращается в виде двух аргументов.Если модульный мультипликативный обратный аргумент не существует,то оба аргумента неопределенны.В противном случае аргументами являются число (объект)и его знак (&quot;+&quot; или &quot;-&quot;).</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">В результате содержимое 17-й строки файла будет заменено на &quot;Вишневый пирог&quot;;символ новой строки отделит 17-ю строку от 18-й.Это означает,что данный код ничего не сделает:</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">В результате получается символ Юникода или последовательность символов,заданная параметрами</target>
        </trans-unit>
        <trans-unit id="f066226510a6a63558092d6e0a75383b46653b7b" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом будет символ, указанный в шестнадцатеричном числе в фигурных скобках. См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="7238c8e2e1333323c2dd62857b981306a7706e6a" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом является символ, заданный шестнадцатеричным числом в диапазоне от 0x00 до 0xFF. См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="d86f6bbcc0ec2a19c70956057e4d3cc4063fc333" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом будет символ, указанный восьмеричным числом в фигурных скобках. См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="2ca77b886ca2262e5c2630425a0b7e07037d32d3" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">Результатом является символ, заданный трехзначным восьмеричным числом в диапазоне от 000 до 777 (но лучше не использовать выше 077, см. Следующий абзац). См. &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; ниже, чтобы узнать, какой персонаж.</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">Результат такой же, как у &lt;code&gt;xhdr&lt;/code&gt; , за исключением того, что он будет ограничен заголовками, текст заголовка которых соответствует &lt;code&gt;PATTERN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">Результат может быть использован в качестве подмаскировки в матче:</target>
        </trans-unit>
        <trans-unit id="aea5a1ac74300d067b63729d12ad0881314aa59c" translate="yes" xml:space="preserve">
          <source>The result of each test is captured in a hash. These hashes are the same as the hashes returned by Test::Builder-&amp;gt;details but with a couple of extra fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">Результат оценки последнего успешного &lt;code&gt;(?{ code })&lt;/code&gt; утверждения регулярного выражения (см. &lt;a href=&quot;perlre&quot;&gt;Perlre&lt;/a&gt; ). Может быть написано на.</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">Результат great_circle_direction находится в радиусах,ноль указывает на прямой север,pi или -pi прямой юг,pi/2 прямой запад,и -pi/2 прямой восток.</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">Результат md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)будет точно таким же,как и результат md5(&quot;abc&quot;).</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">Результат переполнения диапазона целых чисел не определен, потому что он не определен также в C. Другими словами, при использовании 32-битных целых чисел &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; не определено. Сдвиг на отрицательное количество бит также не определен.</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">Результатом этого сценария является в лучшем случае база данных,которая не содержит того,что вы ожидаете.В худшем случае база данных будет повреждена.</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">Возвращаемый результат будет одним из следующих:</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">Строка результата, содержащая интерполированный материал, испорчена, если действует форма &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;использования&lt;/a&gt; , включающая &lt;code&gt;LC_CTYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc181363eb40ff0bd863bde77567e9656e7a29d5" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">В результате получится массив из 3 элементов,каждый из которых будет содержать ссылку на массив,в котором будут храниться хэндлы,готовые к чтению,записи и имеющие исключения соответственно.При ошибке возвращается пустой список.</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">Результат будет в три раза больше, чем количество слоев: первый элемент будет именем, второй элемент - аргументами (неопределенные аргументы будут &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), третий элемент - флагами, четвертый элемент - снова именем, и так вперед.</target>
        </trans-unit>
        <trans-unit id="3e9d88696af53de04206c2554e1cd6a14550e72c" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;undef&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">В результирующем $subdir_cmd нет ни ведущей вкладки,ни следящей новой линии.Это облегчает встраивание в строку make.Например.</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">Полученная последовательность байтов наиболее удобна для проверки контрольной суммы. Не замедляйте работу своей программы с помощью цикла for, добавляющего значения &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; байтов этой строки - код &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; - это то, что нужно использовать для вычисления 8-битной суммы всех байтов, которая должна быть равна нулю:</target>
        </trans-unit>
        <trans-unit id="7e685873aa2576bcd6d048591b67cf99d300730d" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;ord&lt;/code&gt; values of this string's bytes - the &lt;code&gt;unpack&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">По умолчанию результирующий путь относителен,т.е.результирующий путь будет иметь ведущий двоеточие.</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">Получившаяся программа выглядит так:</target>
        </trans-unit>
        <trans-unit id="e4aa8c76073812eb40b9e292fb100c683926c76e" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;&quot;catpath&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Результаты можно передать в &lt;a href=&quot;#catpath&quot;&gt;catpath,&lt;/a&gt; чтобы вернуть путь, эквивалентный (обычно идентичный) исходному пути.</target>
        </trans-unit>
        <trans-unit id="156c1084cc95fa3e7b597345b8d09fde064a081b" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath%28%29&quot;&gt;&quot;catpath()&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Результаты можно передать в &lt;a href=&quot;#catpath()&quot;&gt;catpath (),&lt;/a&gt; чтобы вернуть путь, эквивалентный (обычно идентичный) исходному пути.</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Результаты можно передать в &lt;code&gt;catpath()&lt;/code&gt; чтобы вернуть путь, эквивалентный (обычно идентичный) исходному пути.</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">Результаты соответствуют правилам ASCII. Только символы &lt;code&gt;A-Z&lt;/code&gt; меняются на &lt;code&gt;a-z&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">Результаты создания новых записей таблицы символов непосредственно или изменения любых записей,которые еще не являются печатными шрифтами,не определены и могут изменяться между выпусками perl.</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">Результатом &lt;code&gt;VERSION&lt;/code&gt; будет фактически строковый объект версии, использующий скаляр пакета &lt;code&gt;$VERSION&lt;/code&gt; , который гарантированно эквивалентен, но может не быть в точности содержимым скаляра &lt;code&gt;$VERSION&lt;/code&gt; . Если вам нужно фактическое содержимое &lt;code&gt;$VERSION&lt;/code&gt; , используйте вместо этого &lt;code&gt;$CLASS::VERSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95e455ea284fe76f90c5b0d39ee105831c2e5eaa" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt;, use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">Список возврата сгенерированной функции Perl состоит из значения, возвращаемого функцией C (если XSUB не имеет типа возврата &lt;code&gt;void&lt;/code&gt; или не использовалось &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; ), за которым следуют все параметры &lt;code&gt;OUTLIST&lt;/code&gt; и &lt;code&gt;IN_OUTLIST&lt;/code&gt; (в порядке появления). При возврате из XSUB параметр &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perl будет изменен, чтобы значения были записаны функцией C.</target>
        </trans-unit>
        <trans-unit id="44655e68104aa5b50fd85988b88ae70262129b43" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71452936695d00a40f619faefe33e6d1a6ac20b" translate="yes" xml:space="preserve">
          <source>The return may be incorrect for those rare locales where the currency symbol replaces the radix character. Send email to &lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto:perlbug@perl.org&lt;/a&gt; if you have examples of it needing to work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0420f753fa3324f9eec48f35a50efc8cee6a049e" translate="yes" xml:space="preserve">
          <source>The return points to a per-thread static buffer, which is overwritten the next time &lt;code&gt;Perl_setlocale&lt;/code&gt; is called from the same thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">Возвращает истину, если аргумент удовлетворяет условию. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; не являются целыми числами и не являются ни нечетными, ни четными.</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">Возвращаемое значение (если определено) - объект Perl класса &lt;code&gt;PerlIO::Layer&lt;/code&gt; который создается кодом C в</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;LVALUE&lt;/code&gt; указывает ссылку на lvalue, которое не является переменной. Вы получаете это, взяв ссылку на вызовы функций, такие как &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;VSTRING&lt;/code&gt; возвращается, если ссылка указывает на &lt;a href=&quot;perldata#Version-Strings&quot;&gt;строку версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;LVALUE&lt;/code&gt; указывает ссылку на lvalue, которое не является переменной. Вы получаете это, взяв ссылку на вызовы функций, такие как &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;VSTRING&lt;/code&gt; возвращается, если ссылка указывает на &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;строку версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">Возвращаемое значение может быть &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; чтобы получить идентичную копию исходной ссылочной структуры. (Пожалуйста, примите во внимание последствия проверки кода из ненадежных источников для безопасности!)</target>
        </trans-unit>
        <trans-unit id="341077e987e38231c6848bd510801f6ac305a364" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;eval&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">Возвращаемое значение для &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; определяется реализацией; обратитесь к вашей странице руководства atan2 (3) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">Возвращаемое значение для &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; определяется реализацией; обратитесь к вашей странице руководства atan2 (3) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="3f7e47c80e390cbc99d4bd2d52e4ac31f1eae4a5" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;atan2(0,0)&lt;/code&gt; is implementation-defined; consult your &lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2(3)&lt;/a&gt; manpage for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">Возвращаемое значение - &lt;code&gt;true&lt;/code&gt; если это действительный прототип, и &lt;code&gt;false&lt;/code&gt; если это не так, независимо от того, было ли &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c3cd7efde35a3e831a5bdd29d0ed5265715cc55" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;warn&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">Возвращаемое значение похоже на POSIX (сдвинуто вверх на 8 бит), что дает место только для выдуманного значения, полученного из битов серьезности собственного 32-битного кода условия (если не переопределено с &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). Если собственный код условия имеет кодированное значение POSIX, значение POSIX будет декодировано для извлечения ожидаемого значения выхода. Подробнее см. &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? в perlvms&lt;/a&gt; . (VMS)</target>
        </trans-unit>
        <trans-unit id="38f16262d38a09b1b50bf9932e5e395bae210a67" translate="yes" xml:space="preserve">
          <source>The return value is a boolean: TRUE if the global locale at the time of call was in effect; and FALSE if a per-thread locale was in effect. This can be used by the caller that needs to restore things as-they-were to decide whether or not to call &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f3af5a62c5a74bbd990f1648eb2762ff5d0f59" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">Возвращаемое значение всегда является скаляром, строкой или числом. Для свойств, где есть синонимы для значений, синоним, возвращаемый этой функцией, является самой длинной и описательной формой, возвращаемой &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; при вызове в скалярном контексте. Конечно, вы можете вызвать &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; для результата, чтобы получить другие синонимы.</target>
        </trans-unit>
        <trans-unit id="897578330f8509b5163b4447af0b4daff044a33c" translate="yes" xml:space="preserve">
          <source>The return value is formatted according to OLE conventions, as groups of hex digits with surrounding braces. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">Возвращаемым значением является сам объект $ctx.</target>
        </trans-unit>
        <trans-unit id="437a2be9f2de32d0576eb59aa85a5731812472a7" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;. This is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">Возвращаемое значение - это статус выхода программы, возвращенный вызовом &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Чтобы получить фактическое значение выхода, сдвиньте вправо на восемь (см. Ниже). См. Также &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; . Это</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">Возвращаемое значение - это статус выхода программы, возвращенный вызовом &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Чтобы получить фактическое значение выхода, сдвиньте вправо на восемь (см. Ниже). См. Также &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; . Это</target>
        </trans-unit>
        <trans-unit id="28ff84250f55ab2bea98fda52eb0b62db0c2d4bd" translate="yes" xml:space="preserve">
          <source>The return value is the total length &lt;code&gt;src&lt;/code&gt; would be if the copy completely succeeded. If it is larger than &lt;code&gt;size&lt;/code&gt;, the excess was not copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db618f76ec023ae4b98dae939007dd3399a79764" translate="yes" xml:space="preserve">
          <source>The return value is the total length that &lt;code&gt;dst&lt;/code&gt; would have if &lt;code&gt;size&lt;/code&gt; is sufficiently large. Thus it is the initial length of &lt;code&gt;dst&lt;/code&gt; plus the length of &lt;code&gt;src&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is smaller than the return, the excess was not appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">Возвращаемым значением является сам обновленный объект.</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Возвращаемое значение может быть списком, содержащим ноль или более ссылок на массив, целого числа или &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f37d26524cdd675f6f08be05c61f9223fd0378a" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">Возвращаемое значение может быть ссылкой на массив с 1-й по 4-ю весами, как показано выше. Возвращаемое значение может быть целым числом в качестве основного веса, как показано ниже. Если возвращается &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , будет использоваться производный элемент сопоставления по умолчанию.</target>
        </trans-unit>
        <trans-unit id="68d7e0ec957990f452acfaa57c18c8410bd4dda3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;undef&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222fe952afa9c24172c89b0f769d4878a2ea7ad7" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;) is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a717c20899094357a3bea685885351b6040d8de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on pipes, fifos, and sockets usually returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (и &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (и &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;INLINED&lt;/code&gt; в этом примере всегда будет 54321, независимо от последующих изменений в $ x. Вы также можете поместить любой произвольный код внутрь подпрограммы, он будет выполнен немедленно, а его возвращаемое значение будет захвачено таким же образом.</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">Возвращаемое значение &lt;code&gt;survey&lt;/code&gt; - два хеша:</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">Возвращаемое значение Pod::Perldoc::GetOptsOO::getopts истинно,если нет ошибок,в противном случае это ложь.</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">Возвращаемое значение функции tell()для стандартных потоков,таких как STDIN,зависит от операционной системы:она может возвращать -1 или что-то еще.tell()на трубах,fifos и сокетах обычно возвращает -1.</target>
        </trans-unit>
        <trans-unit id="d4713d5655dc6e9b8c7a80e55df87e6a297b0b32" translate="yes" xml:space="preserve">
          <source>The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt;. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;. Effectively a successful &lt;code&gt;hv_store&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">Возвращаемое значение будет NULL, если операция завершилась неудачно или значение не нужно было фактически хранить в хэше (как в случае связанных хешей). В противном случае его можно будет разыменовать, чтобы получить исходный &lt;code&gt;SV*&lt;/code&gt; . Обратите внимание, что вызывающая сторона отвечает за соответствующее увеличение счетчика ссылок &lt;code&gt;val&lt;/code&gt; перед вызовом и уменьшение его, если функция вернула NULL. Фактически успешный hv_store становится владельцем одной ссылки на &lt;code&gt;val&lt;/code&gt; . Обычно это то, что вы хотите; вновь созданный SV имеет счетчик ссылок, равный единице, поэтому, если весь ваш код создает SV, а затем сохраняет их в хэше, hv_store будет владеть единственной ссылкой на новый SV, и вашему коду не нужно делать что-либо еще для прибраться. hv_store не реализован как вызов hv_store_ent и не создает временный SV для ключа, поэтому, если ваши данные ключа еще не находятся в форме SV, используйте hv_store вместо hv_store_ent.</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">Возвращаемое значение будет представлять собой список;первым значением будет состояние ошибки,за которым последуют имя хоста и имя службы.</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">Возвращаемое значение будет представлять собой список;первое значение-индикация ошибок,за которым следует список структур адресов (если ошибка не произошла).</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">Возвращаемое значение будет представлять собой ссылку на хэш,где ключами являются номера сообщений,и каждое значение содержит ссылку на массив,который содержит поля обзора этого сообщения.</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">Возвращаемое значение будет представлять собой ссылку на хэш,где ключами являются номера сообщений,и каждое значение содержит текст запрошенного заголовка этого сообщения.</target>
        </trans-unit>
        <trans-unit id="7ff5356b785d18cf62379ed63c212e5a8a9ffb9a" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">Возвращаемые значения более &quot;приготовлены&quot;, чем значения &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; . Например, значение свойства &lt;code&gt;&quot;uc&quot;&lt;/code&gt; - это фактическая строка, содержащая полное отображение в верхнем регистре входной кодовой точки. Вы должны пойти на дополнительные проблемы с &lt;code&gt;charinfo&lt;/code&gt; , чтобы получить это значение из его &lt;code&gt;upper&lt;/code&gt; хеш-элемента, когда полное отображение отличается от простого.</target>
        </trans-unit>
        <trans-unit id="a0c27b1b52fce6c8f2f090cdffac0089b776c9ec" translate="yes" xml:space="preserve">
          <source>The returned NaN is always a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e761cd70527853f3676a64d7d2be637d80127b77" translate="yes" xml:space="preserve">
          <source>The returned hash consists of 4 parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac925fdbc70f038b7d79d3f22cbbb8542015b931" translate="yes" xml:space="preserve">
          <source>The returned list will begin with the initial value for &lt;code&gt;$a&lt;/code&gt;, followed by each return value from the block in order. The final value of the result will be identical to what the &lt;code&gt;reduce&lt;/code&gt; function would have returned given the same block and list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">Возвращаемый объект будет действителен только до тех пор,пока продолжают существовать базовые операционные системы и SV.Не пытайтесь использовать объект после освобождения базовых структур.</target>
        </trans-unit>
        <trans-unit id="27c81be6b30926294699f4659627b6ffa79304d4" translate="yes" xml:space="preserve">
          <source>The returned script will be &lt;code&gt;SCX_Inherited&lt;/code&gt; iff all the code points in it are from the Inherited script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9c36a9cfb66d7244d884d86187f93dbed4c9d0" translate="yes" xml:space="preserve">
          <source>The returned value will have the characters that can't be decoded replaced by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">Возвращаемые значения являются копиями исходных ключей в хэше, поэтому их изменение не повлияет на исходный хеш. Сравните &lt;a href=&quot;#values&quot;&gt;значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3aac40383199a850fb451c54d0b1c983a804515" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">Возвращаемые значения являются копиями исходных ключей в хэше, поэтому их изменение не повлияет на исходный хеш. Сравните &lt;a href=&quot;values&quot;&gt;значения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">Возвращаемые значения свойств расширения Perl, таких как &lt;code&gt;Any&lt;/code&gt; и &lt;code&gt;Greek&lt;/code&gt; , несколько вводят в заблуждение. Значения могут быть &lt;code&gt;&quot;Y&quot;&lt;/code&gt; или &lt;code&gt;&quot;N&lt;/code&gt; &amp;raquo;. Все свойства Unicode являются двудольными, поэтому вы можете использовать &lt;code&gt;&quot;Y&quot;&lt;/code&gt; или &lt;code&gt;&quot;N&lt;/code&gt; &amp;raquo; в регулярном повторном выражении Perl для них, например &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; или &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; . Но расширения Perl не указаны таким образом, только как &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="0b00496e0ac48606a2b2f5ade4900470b3e5cc37" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot; in a Perl regular expression for these, like &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; or &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Редакция, версия и подрывная версия интерпретатора Perl, представленные как объект &lt;a href=&quot;version&quot;&gt;версии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Редакция,версия и подрыв Perl интерпретатора,представленная в виде десятичной дроби формы 5.XXXYYY,где XXX-версия/1e3 и YYY-подрывная версия/1e6.Например,Perl v5.10.1 будет &quot;5.010001&quot;.</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">Переписанная версия этого модуля (по сравнению с v0.01) медленнее при выполнении некоторых операций, таких как &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; и &lt;code&gt;numify()&lt;/code&gt; . Причина в том, что теперь он выполняет больше работы и обрабатывает гораздо больше дел. Время, затрачиваемое на эти операции, обычно достигается за счет других математических операций, поэтому код в среднем должен работать (намного) быстрее. Если нет, свяжитесь с автором.</target>
        </trans-unit>
        <trans-unit id="d648a5385a086d97fdf940828d9fd6d003974ab0" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt;. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">Правая колонка также предупредит вас,если объект недвижимости означает нечто отличное от того,что обычно можно ожидать.</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">Правая сторона, начиная со строки 5, аналогична тому, что мы только что видели: у нас есть &lt;code&gt;add&lt;/code&gt; op ( &lt;code&gt;pp_add&lt;/code&gt; также в</target>
        </trans-unit>
        <trans-unit id="a97b5a9d26a8152b03235a227c2f7630aad78c10" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt;, also in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">Правый операнд не оценивается, пока оператор находится в состоянии &amp;laquo;ложь&amp;raquo;, а левый операнд не оценивается, пока оператор находится в состоянии &amp;laquo;истина&amp;raquo;. Приоритет немного ниже, чем || и &amp;amp;&amp;amp;. Возвращаемое значение представляет собой либо пустую строку для false, либо порядковый номер (начинающийся с 1) для true. Порядковый номер сбрасывается для каждого обнаруженного диапазона. К последнему порядковому номеру в диапазоне добавлена строка &lt;code&gt;&quot;E0&quot;&lt;/code&gt; , которая не влияет на его числовое значение, но дает вам что-то для поиска, если вы хотите исключить конечную точку. Вы можете исключить начальную точку, дождавшись, пока порядковый номер не станет больше 1.</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">Крайний правый разделитель, начинающий текст аргумента с внутренней последовательностью (должен быть &quot;&amp;gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">Функция rmtree()предоставляет наследственному интерфейсу remove_tree()другую интерпретацию передаваемых аргументов.Поведение и возвращаемое значение функции в противном случае идентичны функции remove_tree().</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">Пример rot13 был тривиальным.Вот еще одна демонстрация,показывающая еще несколько возможностей.</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$myarray[$idx]&lt;/code&gt; эквивалент Perl - $ myarray [$ idx] .</target>
        </trans-unit>
        <trans-unit id="4b4a8606a49a46444c3a9ed277908732090e4141" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$key]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">Подпрограмма &lt;code&gt;regtail()&lt;/code&gt; вызывается как &lt;code&gt;reg()&lt;/code&gt; и &lt;code&gt;regbranch()&lt;/code&gt; чтобы правильно &amp;laquo;установить указатель хвоста&amp;raquo;. При выполнении и достижении конца ветки нам нужно перейти к узлу, следующему за скобками группировки. Однако при синтаксическом анализе мы не знаем, где будет конец, пока не дойдем до него, поэтому, когда мы это сделаем, мы должны вернуться и обновить смещения по мере необходимости. &lt;code&gt;regtail&lt;/code&gt; используется, чтобы сделать это проще.</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">Подпрограмма, обозначенная &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; вызывается, когда вот-вот возникнет фатальное исключение. Сообщение об ошибке передается как первый аргумент. При &lt;code&gt;__DIE__&lt;/code&gt; подпрограммы ловушки __DIE__ обработка исключения продолжается, как и в случае ее отсутствия, если сама процедура ловушки не завершается через &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , выход из цикла или &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;__DIE__&lt;/code&gt; обработчик явно отключается во время разговора, так что вы можете умереть от &lt;code&gt;__DIE__&lt;/code&gt; обработчика. Аналогично для &lt;code&gt;__WARN__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3747082bcec8b320b157ca0f6db8a2c2a773d76" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;goto &amp;amp;sub&lt;/code&gt;, a loop exit, or a &lt;code&gt;die()&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">Чаще всего используется процедура &lt;code&gt;call_sv&lt;/code&gt; . &lt;code&gt;SV*&lt;/code&gt; аргумент содержит либо имя подпрограммы Perl будет называться, или ссылка на подпрограмму. Второй аргумент состоит из флагов, которые управляют контекстом, в котором вызывается подпрограмма, независимо от того, передаются ли подпрограмме аргументы, как следует перехватывать ошибки и как обрабатывать возвращаемые значения.</target>
        </trans-unit>
        <trans-unit id="8b9d3fc2ab950a51903275842538b6aa8532b735" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt;. The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">В противном случае процедура возвращает &lt;b&gt;false&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">Подпрограмма возвращает &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; для проблем ввода-вывода или другой внутренней ошибки, в противном случае - истинное значение. Серьезные ошибки распространяются в качестве &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; исключений.</target>
        </trans-unit>
        <trans-unit id="274062f280eff9b69a72565df5a686a0a630e507" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;undef&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;die&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">Подпрограммы &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;reftype&lt;/code&gt; можно экспортировать.</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">Процедуры &lt;code&gt;make_path&lt;/code&gt; и &lt;code&gt;remove_tree&lt;/code&gt; которые &lt;b&gt;не&lt;/b&gt; экспортируются по умолчанию. Вы должны указать, какие из них хотите использовать.</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">Эти подпрограммы вызываются в порядке сравнения строк KEY.</target>
        </trans-unit>
        <trans-unit id="74358fa70816b0be14690b88380765bc85d1b11f" translate="yes" xml:space="preserve">
          <source>The routines provided are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">Правило,по которому Digest::SHA обрабатывает строку в Юникоде,легко сформулировать,но потенциально сбивает с толку:строка интерпретируется как последовательность значений байтов,где каждое значение байта равно порядковому значению (а именно кодовой точке)соответствующего ей символа Юникода.Таким образом,строка в Юникоде 'abc' имеет точно такое же дайджестовое значение,что и обычная строка 'abc'.</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">В правиле должен быть только один ключ верхнего уровня:либо 'par' для &quot;parallel&quot;,либо 'seq' для &quot;sequence&quot;.</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">Эмпирическое правило для портативного кода таково:Делайте все это на переносном Perl или используйте модуль (который может реализовать его внутри платформы с помощью кода,специфичного для конкретной платформы,но раскрывающего общий интерфейс).</target>
        </trans-unit>
        <trans-unit id="242ca7a8186e9298403d04b4bfd265a295183ebf" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;UTF-8&lt;/code&gt; unless you know what you're doing and unless you really benefit from using &lt;code&gt;UTF-16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">Более подробно структура данных правил описана в следующем разделе.</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">Правила,определяющие,что это такое,довольно просты:если символ,следующий за обратным слешем,является ASCII-знаком препинания (не словом)(то есть всем,что не является буквой,цифрой или подчеркиванием),то обратный слеш просто убирает любое особое значение следующего за ним символа.</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">Правила поведения,которые в отсутствие других указаний определяют,что должно произойти в первую очередь.Например,при отсутствии скобок,вы всегда делаете умножение перед сложением.</target>
        </trans-unit>
        <trans-unit id="ba784b5f42a3cdb9214cd0e95e0cb55e8afe477c" translate="yes" xml:space="preserve">
          <source>The rules used by &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt; apply to this construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903df1a17859e1fa3a6b96e5e64488aec405db63" translate="yes" xml:space="preserve">
          <source>The rules used for matching decimal digits are slightly stricter. Many scripts have their own sets of digits equivalent to the Western &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; ones. A few, such as Arabic, have more than one set. For a string to be considered a script run, all digits in it must come from the same set of ten, as determined by the first digit encountered. As an example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">Компонент времени выполнения должен иметь имя</target>
        </trans-unit>
        <trans-unit id="9ac33bbce70d7ec48c4fcab9365b96ff1ebc5597" translate="yes" xml:space="preserve">
          <source>The runtime phase refers not only to when the distribution's contents are installed, but also to its continued use. Any library that is a prerequisite for regular use of this distribution should be indicated here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">Тот же подход,что и в командной строке:</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">То же, что и для &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , но если отсутствующий оператор не может быть автоматически сгенерирован, то вместо выдачи сообщения об ошибке Perl может вернуться к тому, что он сделал бы для этого оператора, если бы не было директивы &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aff3ca408715d6ed9bbfe43d93b70be580afe993" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;undef&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;use overload&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7d5583bb4c7bf75d630d65c93bc37b198d69e0" translate="yes" xml:space="preserve">
          <source>The same caveats as the previous form apply: The non-graphic characters are no longer allowed with &quot;use utf8&quot;, it is unwise to use this form at all, and utf8ness makes a big difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">Эта же контрольная сумма может быть рассчитана и в стиле OO:</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">Тот же эффект,что и в примере выше,по-другому.В качестве аргумента coderef принимает псевдоним и возвращает каноническое имя при успехе или undef,если нет.Обратите внимание,что второй аргумент игнорируется,если он предоставлен.Используйте это с еще большей осторожностью,чем в регекс-версии.</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">То же самое относится к оцененным строкам, которые содержат подпрограммы или которые в настоящее время выполняются. Имя $ filename для строк &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ed выглядит так &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bfd670d25b13b1b3ec948c8f09f21523b3aecf7" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">Та же самая информация отображается в конце вывода команды</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">То же самое не относится к реализациям &lt;code&gt;++&lt;/code&gt; и &lt;code&gt;--&lt;/code&gt; : ожидается, что они изменят свои операнды. Соответствующая реализация &lt;code&gt;--&lt;/code&gt; может выглядеть как</target>
        </trans-unit>
        <trans-unit id="07cb6e84563964c1b3fb8a6ff37a2b4286b6b128" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;: these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">То же самое может произойти и с AIX 5.1 или другими уровнями ОС.В качестве примечания,Perl не может быть собран без установленных bos.adt.syscalls и bos.adt.libm</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">Одно и то же имя пакета может быть использовано несколько раз,что позволяет использовать несетевой код.Это полезно,если у вас более строгий принцип заказа,чем имена пакетов.</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">Те же проблемы возникают, если вы включите автоматическую UTF-8-ификацию ваших стандартных файловых дескрипторов, уровня &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; умолчанию и &lt;code&gt;@ARGV&lt;/code&gt; для локалей, отличных от ISO8859-1 и не-UTF-8 (с помощью командной строки &lt;b&gt;-C&lt;/b&gt; переключатель или &lt;code&gt;PERL_UNICODE&lt;/code&gt; среды PERL_UNICODE ; см. &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; ). Вещи читаются как UTF-8, что обычно подразумевает интерпретацию Unicode, но наличие языкового стандарта заставляет их интерпретировать их вместо этого. Например, кодовая точка 0xD7 во вводе Unicode, которая должна означать знак умножения, не будет интерпретироваться Perl таким образом в греческой локали. Это не является проблемой</target>
        </trans-unit>
        <trans-unit id="44e618a0d24868bdeb405a4592271ed0ce58faad" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">Те же проблемы возникают, если им передать объекты Math :: BigInt-&amp;gt; binf (). Поскольку перегрузка этих подпрограмм невозможна, это не может быть исправлено с помощью BigInt.</target>
        </trans-unit>
        <trans-unit id="7dc30b04b9083d2f8edd85ddb5597b7e64cf1167" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from Math::BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd308e84d4bbc13d1645c341d0f0d15e57ef77b4" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">Этот же шаблон обычно может быть использован и в распаковке().</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">Оба раза выполняются одни и те же тесты, но дополнительная информация предоставляется при запуске с &lt;code&gt;./perl harness&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">Пример программы:</target>
        </trans-unit>
        <trans-unit id="81ca6bed72a326bbf775e3304829aa324851950b" translate="yes" xml:space="preserve">
          <source>The save stack is used by perl to implement the &lt;code&gt;local&lt;/code&gt; keyword and other similar behaviours; any cleanup operations that need to be performed when leaving the current scope. Items pushed to this stack generally capture the current value of some internal variable or state, which will be restored when the scope is unwound due to leaving, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; or other reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">Скалярное &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; сохраняется в экземпляре SV с именем &lt;code&gt;PL_sv_undef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d200dc97f6deaa66b9415179bc13a97fa0cc3da" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;undef&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">Скаляр/контекст списка для подпрограмм и для правой стороны назначения определяется так,как если бы вызов подпрограмм был заменен скаляром.Например,рассмотрим:</target>
        </trans-unit>
        <trans-unit id="6c0b56c4841154473a184d3770a4651387051abe" translate="yes" xml:space="preserve">
          <source>The scalars for in-memory files are treated as octet strings: unless the file is being opened with truncation the scalar may not contain any code points over 0xFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">Вышеприведенная схема позволяет интерпретировать широкий диапазон дат,особенно при использовании 4-х значных лет.</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">Схема из uri (например,'file','http' и т.д.)</target>
        </trans-unit>
        <trans-unit id="73f8b37079fc67e2d535d7e2f263c71e4f89003f" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;package&lt;/code&gt; declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or file, whichever comes first (the same scope as the my(), our(), state(), and local() operators, and also the effect of the experimental &quot;reference aliasing,&quot; which may change), or until the next &lt;code&gt;package&lt;/code&gt; declaration. Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that, if unqualified, default to the main package instead of the current one as described below. A &lt;code&gt;package&lt;/code&gt; statement affects only dynamic global symbols, including subroutine names, and variables you've used local() on, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">Область, в которой используется &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; превратила категорию &lt;code&gt;void&lt;/code&gt; предупреждений в фатальную ошибку, поэтому программа немедленно завершает работу при обнаружении предупреждения.</target>
        </trans-unit>
        <trans-unit id="3dbfebc1570cc3ef48ec03f51a2706061f280881" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;length&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f56ab0ebe6cfd894b851115a602d7f9f59ed1f" translate="yes" xml:space="preserve">
          <source>The script exits with zero if it thinks that everything worked, or a positive number if it thinks that something failed. Note, however, that in some cases it has to divine a failure by the output of things it does not control. For now, the exit codes are vague:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">Сценарий сначала проверяет функцию класса &lt;code&gt;Name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">Скрипт доступен по &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;адресу https://gist.github.com/eqhmcow/5389877.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63775c5f58b6e8ca06f6c938a637be34887e3ffd" translate="yes" xml:space="preserve">
          <source>The script of a character is determined by the &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;), as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="496da3e22e1e3340caf097640e4353358048134f" translate="yes" xml:space="preserve">
          <source>The sdbm file format was designed for speed and convenience, not for portability or security. A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">Поисковая система сначала сопоставит &lt;code&gt;\D*&lt;/code&gt; с &quot;ABC&quot;. Затем он попытается сопоставить &lt;code&gt;(?!123)&lt;/code&gt; с &amp;laquo;123&amp;raquo;, но это не поможет . Но поскольку в регулярном выражении использовался квантификатор ( &lt;code&gt;\D*&lt;/code&gt; ), поисковая машина может выполнить обратный поиск и повторить поиск по-другому в надежде найти полное регулярное выражение.</target>
        </trans-unit>
        <trans-unit id="2dd6a24dc0c40439966d70dfb7faeebd4df837f5" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt;) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">Второе преимущество заключается в том, что встроенные модификаторы (за исключением &lt;code&gt;//p&lt;/code&gt; , который изменяет все регулярное выражение) влияют только на регулярное выражение внутри группы, в которой содержится встроенный модификатор. Таким образом, для локализации эффектов модификатора можно использовать группировку:</target>
        </trans-unit>
        <trans-unit id="344654afee619df186bd5aa49c470902771a22f7" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;/p&lt;/code&gt;, which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; и &lt;code&gt;type&lt;/code&gt; второго и третьего аргументов указывают, сколько структур данных указанного типа должно быть выделено. Аргумент &lt;code&gt;type&lt;/code&gt; передается &lt;code&gt;sizeof&lt;/code&gt; . Последний аргумент &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , следует использовать, если аргумент &lt;code&gt;pointer&lt;/code&gt; отличается от аргумента &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fea027e954f4ec8636256c0b94ce6f7f44ab6c0c" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt;. The final argument to &lt;code&gt;Newxc&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7128198e8ffe79d47674dc971b588a148d07fe" translate="yes" xml:space="preserve">
          <source>The second and third highest priorities are to look in the parent of the current directory and a directory called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">Второй аргумент ($eol)-это конечная строчная последовательность.Он необязателен и по умолчанию равен &quot;\n&quot;.Каждое вхождение &quot;\n&quot; заменяется этой строкой,а также используется для дополнительных &quot;мягких разрывов строк&quot;,чтобы гарантировать,что ни одна строка не заканчивается длиннее 76 символов.Для получения данных,пригодных для внешнего потребления,передайте их как &quot;\015\012&quot;.Строка &quot;\r\n&quot; дает на многих платформах,но не на всех.</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Второй аргумент может быть хеш-ссылкой с параметрами, которые идентичны аргументам, переданным в &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9356e806771df85496c708eb7a467795a26a60f" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;read()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">Второй аргумент - регулярное выражение. Это может быть ссылка на регулярное выражение (например, &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ) или (для лучшей совместимости со старыми perls) как строка, которая выглядит как регулярное выражение (альтернативные разделители в настоящее время не поддерживаются):</target>
        </trans-unit>
        <trans-unit id="851ff1e7afee5d9f26155a298af3215064fbafc8" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;qr//&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">Второй аргумент считается регексом,если это либо объект регекса,либо строка,которая выглядит как регекс.Регекс-объекты строятся с помощью оператора qr//в последних версиях perl.Строка считается регексом,если ее первый и последний символ-это &quot;/&quot;,или если первый символ-это &quot;m&quot;,а второй и последний символ-это один и тот же не алфавитно-цифровой символ без пробела.Эти регексы</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">Второй аргумент - это другой операнд, или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; в случае унарного оператора.</target>
        </trans-unit>
        <trans-unit id="e4f1fa234686b49496c4cac025cf1d9ea03f5c52" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;undef&lt;/code&gt; in the case of a unary operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f0c3f0ec389d3780a678c2cc02cdb14b452933" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can compress using &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;. If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">Второй аргумент используется для обозначения сжатия. Вы можете сжать с помощью &lt;code&gt;gzip&lt;/code&gt; или &lt;code&gt;bzip2&lt;/code&gt; . Если вы передаете цифру, предполагается, что это уровень сжатия &lt;code&gt;gzip&lt;/code&gt; (от 1 до 9), но использование констант предпочтительнее:</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">Второй аргумент можно считать необязательным,но он остается для обратной совместимости.Archive::Tar теперь смотрит на магию файла,чтобы определить,какой класс должен быть использован для открытия файла,и прозрачно делает правильную вещь.</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">Второй аргумент указывает на массив, содержащий &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; . Как только AV был создан, SV при желании можно уничтожить.</target>
        </trans-unit>
        <trans-unit id="51ba89f615646daa0a3b0a56db80558ec7c78c30" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt;'s. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8c79378da8449512fbe01727cd6ac969d7ae7c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;&quot;-|&quot;&lt;/code&gt;, makes it a read-pipe into a separate program, rather than an ordinary filehandle into a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">Второй вызов функции hex()предупредит о неподвижной константе.</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">Второй обратный вызов является необязательным, если обратный вызов зарегистрирован до вызова $ term-&amp;gt; readline.</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">Второй зарегистрированный обратный звонок-это обратный звонок для регистрации.Входная файловая ручка (часто STDIN,но не обязательно)будет передана.</target>
        </trans-unit>
        <trans-unit id="8a9a833fe2a8c9894ba16f1673e04b6df3b8c78c" translate="yes" xml:space="preserve">
          <source>The second case often turns out to have identical results to the first case, albeit only by accident.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2db73bb8959c9504bedfb024b1f19ea96655cb" translate="yes" xml:space="preserve">
          <source>The second class of portable ranges is invoked when one or both of the range's end points are expressed as &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">Вторая колонка-тип возврата,третья-имя.Следующие столбцы-аргументы.Первый столбец-это набор флагов:</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">Второй пример в синопсисе делает нечто эквивалентное этому:</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">Во втором примере печатаются записи с именами &lt;code&gt;foo&lt;/code&gt; , а также записи с именами, которые заканчиваются на &lt;code&gt;bar&lt;/code&gt; или короче 5 символов.</target>
        </trans-unit>
        <trans-unit id="ff08cd3ad532db8c5d5dd8a872abb6c4f322ba5e" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt;, and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt;, or are shorter than 5 chars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">Вторая точка выхода проверяет, остались ли какие-либо данные во входном буфере, &lt;code&gt;$input&lt;/code&gt; - помните, что опция &lt;code&gt;ConsumeInput&lt;/code&gt; автоматически включается при использовании &lt;code&gt;LimitOutput&lt;/code&gt; . Когда входной буфер исчерпан, внешний цикл может запуститься снова и перезаписать теперь пустой &lt;code&gt;$input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cea8aa29f5d1b03f7b0a4cb746f125b76bdff01" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">Вторая форма позволяет фильтру удерживать информацию о состоянии,используя,таким образом,закрытие:</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">Вторая форма настоятельно не рекомендуется,так как она нарушает способность подкласса повторно использовать конструктор родителя,но вы все равно можете столкнуться с ней в существующем коде.</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">Вторая форма ограничивает или расширяет выходную мощность с помощью глобуса оболочки,как в следующих примерах:</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">Вторая форма принимает в качестве аргумента строку ASCII,состоящую из символов &quot;0&quot; и &quot;1&quot;.Это эквивалентно</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">Вторая форма для удобства просто вызывает &lt;code&gt;new&lt;/code&gt; метод для своих аргументов перед немедленным сбросом объекта.</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">Второй дает данные о том,сколько клавиш находится на каждой глубине цепочки,и дает представление о том,сколько работы займет fetch *hit*.Производительность для обновления или удаления элемента в хэше эквивалентна этому случаю.</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">Второй -</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">Второй вопросительный знак &lt;code&gt;?&lt;/code&gt; для соответствия любому одиночному символу. Третий определяет конкретный набор символов.</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">Вторая,короче говоря,более читабельная.В частности,очевидно,что количество параметров,которые вы передаете этой фразе (два),это количество параметров,которые она</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">Второй метод как создает AV,так и изначально заполняет его SV:</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">Второй метод разделяет сгенерированный код на</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">Второй новый параметр отображения - &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , который может иметь значение true или false, значение по умолчанию - true. См. Предыдущий раздел, чтобы узнать, что это означает.</target>
        </trans-unit>
        <trans-unit id="a8d5bb3a74ae14b7cc834ba7cb47fc90749857de" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt;, which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">Второй вариант - явно указать Configure на обнаружение новой установки Berkeley DB, &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; правильные каталоги с -Dlocincpth = / some / include и &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;и&lt;/b&gt; перед запуском команды make test, установив для LD_LIBRARY_PATH значение</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">Второй параметр, &lt;code&gt;$mode&lt;/code&gt; , используется, чтобы указать, открыт ли файл для чтения или записи, а также, при необходимости, указать уровень сжатия и стратегию сжатия при записи. Формат параметра &lt;code&gt;$mode&lt;/code&gt; аналогичен параметру mode функции &lt;code&gt;fopen&lt;/code&gt; 'C' , поэтому &quot;rb&quot; используется для открытия для чтения, &quot;wb&quot; для записи и &quot;ab&quot; для добавления (запись в конце файл).</target>
        </trans-unit>
        <trans-unit id="40f3477c6f4b0d20844832da1b4bf48b8115879e" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt;, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt;, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3411b2ade45037b8736308e07cf74ad1d92df3ee" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;'^'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;'$'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">Второе регулярное выражение не соответствует, потому что &lt;code&gt;^&lt;/code&gt; ограничивает &lt;code&gt;keeper&lt;/code&gt; совпадением только в начале строки, но &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; имеет keeper, начиная с середины. Третье регулярное выражение совпадает, поскольку &lt;code&gt;$&lt;/code&gt; ограничивает &lt;code&gt;keeper&lt;/code&gt; совпадением только в конце строки.</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">Второй возвращенный товар и &lt;code&gt;$!&lt;/code&gt; может использоваться для проверки правильности ввода:</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">Второе предложение неверно. Фактически, bval по умолчанию будет иметь значение &lt;code&gt;&quot;\n&quot;&lt;/code&gt; тогда, когда параметр openinfo в dbopen равен NULL. Если вообще используется параметр openinfo, отличный от NULL, будет использоваться значение, которое находится в bval. Это означает, что вы всегда должны указывать bval при использовании любой из опций в параметре openinfo. Эта ошибка документации будет исправлена ​​в следующем выпуске Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">Вторая ситуация вызвана тем,что оценщик обращается к лексической подпрограмме,которая,например,вышла из-под контроля,</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">Вторая ситуация вызвана,например,оценочным доступом к переменной,которая вышла из-под контроля,</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">Второй стиль комплектации снимает это ограничение.Оно может быть включено:</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">Второе значение,которое должно быть подставлено в выходную строку (обычно это строка в возможностях адресации курсора)</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">Второй,более эффективный способ-использовать следующий шаблон для ваших Foo.xs:</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">Раздел (он же &amp;laquo;элемент&amp;raquo; в старых модулях perlpods) или &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , если его нет. Например, в &amp;laquo;L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&amp;raquo; &amp;laquo;ОПИСАНИЕ&amp;raquo; - это раздел. (Обратите внимание, что это не то же самое, что раздел справочной страницы, такой как &amp;laquo;5&amp;raquo; в &amp;laquo;man 5 crontab&amp;raquo;. &amp;laquo;Раздел Foo&amp;raquo; в смысле Pod означает часть текста, которая вводится заголовком или элементом с текстом &amp;laquo;Foo&amp;raquo;. &quot;.)</target>
        </trans-unit>
        <trans-unit id="cd89b9d74f7d870dca4a759e8ab8f51f0dc1f9b2" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;undef&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592a5f44132e9a3aa5e9a10cfa07afacf196746b" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;&quot;safe_level&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">Особое внимание уделяется аспекту безопасности создания временного файла, так что дескриптор файла и имя файла возвращаются вместе. Это помогает гарантировать, что состояние гонки не может возникнуть, если временный файл создается другим процессом между проверкой существования файла и его открытием. Дополнительные уровни безопасности предусмотрены для проверки, например, того, что бит закрепления установлен в каталогах, доступных для записи во всем мире. См. &lt;a href=&quot;#safe_level&quot;&gt;Safe_level&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">На первый взгляд эквивалентная конструкция в Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; сначала выполняет deref для $ aref, заставляя его использовать $ aref как ссылку на массив, а затем разыменовывает это и, наконец, сообщает вам</target>
        </trans-unit>
        <trans-unit id="5ae490ef8bae426993ed6639b51d33e36f67a5f8" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">Семантика интервальных таймеров для многопоточных программ зависит от системы, и некоторые системы могут поддерживать дополнительные интервальные таймеры. Например, не указано, какой поток получает сигналы. См. &lt;code&gt;setitimer()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">Смысл совпадения можно изменить, используя оператор &lt;code&gt;!~&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">Последовательность &lt;code&gt;\b&lt;/code&gt; является особенной внутри класса символов в квадратных скобках. Находясь за пределами класса символов, &lt;code&gt;\b&lt;/code&gt; является утверждением, указывающим на точку, которая не имеет ни двух символов слова, ни двух символов не слов с обеих сторон, внутри класса символов в квадратных скобках &lt;code&gt;\b&lt;/code&gt; соответствует символу возврата.</target>
        </trans-unit>
        <trans-unit id="2e682f0e9f09d4fac48ccdb6cb912af9bfeddf7f" translate="yes" xml:space="preserve">
          <source>The sequence can also be extended to negative index n using the re-arranged recurrence relation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">Номер последовательности следующей операционной.</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">Номер последовательности ОП,или дефис,если его нет.</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">Номер последовательности ОП.Обратите внимание,что это порядковый номер,генерируемый B::Кратко.</target>
        </trans-unit>
        <trans-unit id="a1e46d38c7dda11bf03f174aca8ec057ac38a288" translate="yes" xml:space="preserve">
          <source>The sequence number of this partition. Partitions are numbered starting as &lt;code&gt;1&lt;/code&gt; [with &quot;partition 0&quot; meaning the entire disk]. Sometimes this field may be &lt;code&gt;0&lt;/code&gt; and you'll have to infer the partition sequence number from how many partitions precede it on the disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">Последовательности &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; и &lt;code&gt;\x&lt;/code&gt; также являются специальными и имеют те же значения, что и делать вне класса символов в квадратных скобках.</target>
        </trans-unit>
        <trans-unit id="90a0a5f9a35ae3ea0a297068e4b1bab795815fcf" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899a56478deaf614d4bf9d04537d9557616e32cf" translate="yes" xml:space="preserve">
          <source>The serialized structure will include a &lt;code&gt;x_serialization_backend&lt;/code&gt; entry giving the package and version used to serialize. Any existing key in the given &lt;code&gt;$meta&lt;/code&gt; object will be clobbered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">Сериализующий крюк,вызванный на объект во время сериализации.Как и любой другой метод,он может быть наследуемым или определяться в самом классе.</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">Имя сервиса,поставляемое для getaddrinfo(),недоступно для типа сокета,указанного в $hints.</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">Сервисы, которые часть кода обещает предоставлять вечно, в отличие от его &lt;b&gt;реализации&lt;/b&gt; , которую он может свободно изменять, когда захочет.</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">Набор задается как список символов или как диапазон символов, где начало и конец диапазона разделены знаком минуса (или тире), или как любая комбинация списков и диапазонов. Прочерк также может быть включен в набор как символ, если он является началом или концом набора. Этот набор заключен в квадратные скобки. Закрывающая квадратная скобка &lt;code&gt;]&lt;/code&gt; может использоваться в наборе, если это первый символ в наборе.</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">Набор символов,которые считаются пробелами,-это те символы,которые Юникод называет &quot;Пробелом образца&quot;,а именно:</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">Функция setlocale</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">Установка атрибутов подпрограммы происходит во время компиляции. Атрибуты переменных в &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; объявлениях также применяются во время компиляции. Однако атрибуты &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; переменных применяются во время выполнения. Это означает, что вы должны</target>
        </trans-unit>
        <trans-unit id="229ecae54cd846eee20b1cbee543175ec9cd197e" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;our&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;my&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">Семь маршрутов:</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">Лист</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">Панцирь предлагает войти</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">В &lt;code&gt;test&lt;/code&gt; оболочки используются символы &amp;laquo;=&amp;raquo;, &amp;laquo;! =&amp;raquo;, &amp;laquo;&amp;lt;&amp;raquo; И т. Д. Для сравнения строк и &amp;laquo;-eq&amp;raquo;, &amp;laquo;-ne&amp;raquo;, &amp;laquo;-lt&amp;raquo; и т. Д. Для числовых сравнений. Это обратная Perl, который использует &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; для сравнения строк, а &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; И т.д. для цифровых сравнений.</target>
        </trans-unit>
        <trans-unit id="a4421a2ab5bd2e622c5d0a683eecbd4f08bbe24b" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">Короткий ответ состоит в том, что по умолчанию Perl сравнивает эквивалентность ( &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) только на основе кодовых точек символов. В приведенном выше случае ответ отрицательный (потому что 0x00C1! = 0x0041). Но иногда любые ЗАГЛАВНЫЕ БУКВЫ A следует считать равными, или даже A в любом случае.</target>
        </trans-unit>
        <trans-unit id="84602cf60297d60acdefd80efdd1c60462b73b9b" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">Короткий ответ заключается в том, что по умолчанию Perl сравнивает строки ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) только на основе кодовых точек символов. В приведенном выше случае ответ - &amp;laquo;после&amp;raquo;, поскольку &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d67ccb6666f81cda59931fcf7ad032ead024bc41" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">Короткое название общей категории</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">Короткая история</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">Коротко говоря, вам, вероятно, следует использовать только определенные для скаляров или функций, а не для агрегатов (массивов и хэшей). См. &lt;a href=&quot;functions/defined&quot;&gt;Определение&lt;/a&gt; Perl в версии 5.004 или более поздней для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="53f5dab7a291daa9043df504d583260ae569f535" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;perlfunc#defined&quot;&gt;&quot;defined&quot; in perlfunc&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">Знак &lt;code&gt;/^[+-]$/&lt;/code&gt; хранится отдельно. Строка &amp;laquo;NaN&amp;raquo; используется для представления результата, когда входные аргументы не являются числами, а также результата деления на ноль.</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">Знак '+','-','NaN','+inf' или '-inf' и хранится отдельно.Доступ к нему можно получить с помощью метода sign().</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">Знак '+','-','NaN','+inf' или '-inf'.</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">Знак '+','-','NaN','+inf' или '-inf'.Вы можете получить доступ к нему с помощью метода sign().</target>
        </trans-unit>
        <trans-unit id="11646904ceab245420048654e9bde4a41bb7ec59" translate="yes" xml:space="preserve">
          <source>The signal Exec signal mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104ebb4db613ce634a3b75383995774c2e797f04" translate="yes" xml:space="preserve">
          <source>The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d781ab42c79199084a9c305d1ab2ed6d80e787b" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code, but when using a signature, the signature is a parenthesised list that goes immediately before the block, after any name or attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">Подпись является частью тела подпрограммы.Обычно тело подпрограммы-это просто сплетенный блок кода.При использовании подписи подпись представляет собой заключенный в круглые скобки список,который идет сразу после имени подпрограммы.Подпись объявляет лексические переменные,которые находятся в области действия блока.При вызове подпрограмм сначала подпись получает управление.Она заполняет переменные сигнатуры из списка переданных аргументов.Если список аргументов не удовлетворяет требованиям сигнатуры,то она бросает исключение.Когда обработка сигнатуры завершена,управление передается блоку.</target>
        </trans-unit>
        <trans-unit id="8bf79dd34df166da1a0a362d8a7c14bc52139481" translate="yes" xml:space="preserve">
          <source>The signatures feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf9d6090863be01051258238bf3ef2c8b46c7c9" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched as-is by putting a backslash before it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">Значение каждого из них будет объяснено в остальной части урока,но пока важно только знать,что метахарактер может быть сопоставлен,поставив перед ним обратную косую черту:</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">Свойство с аналогичным названием &lt;code&gt;\p{Punct}&lt;/code&gt; соответствует несколько другому набору в диапазоне ASCII, а именно &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . То есть в нем отсутствуют девять символов &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . Это связано с тем, что Unicode разделяет то, что POSIX считает пунктуацией, на две категории: пунктуация и символы.</target>
        </trans-unit>
        <trans-unit id="8cd091ac264b3ba5cf264f4cd380086afff2aabf" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt;, matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt;. That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt;. This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">Простое правило: наследование не будет работать при автозагрузке не-методов. Простое исправление для старого кода: в любом модуле, который раньше зависел от наследования &lt;code&gt;AUTOLOAD&lt;/code&gt; для не-методов от базового класса с именем &lt;code&gt;BaseClass&lt;/code&gt; , выполните &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; во время запуска.</target>
        </trans-unit>
        <trans-unit id="145065cb1f22a69e2ed6682015cb7947554b75d7" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt;, execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5af89b6d15a00a979315dfddae0b5f323e4af12" translate="yes" xml:space="preserve">
          <source>The simple rule to remember, if you want to match a literal &lt;code&gt;{&lt;/code&gt; character (U+007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt;) in a regular expression pattern, is to escape each literal instance of it in some way. Generally easiest is to precede it with a backslash, like &lt;code&gt;\{&lt;/code&gt; or enclose it in square brackets (&lt;code&gt;[{]&lt;/code&gt;). If the pattern delimiters are also braces, any matching right brace (&lt;code&gt;}&lt;/code&gt;) should also be escaped to avoid confusing the parser, for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">Простая студийная реализация создает файлы</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">Самые простые XSUB состоят из 3 частей:описание возвращаемого значения,имя рутины XSUB и имена ее аргументов,а также описание типов или форматов аргументов.</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">Самый простой случай - целые числа. Они состоят из последовательности цифр с необязательным знаком спереди. Цифры, которые мы можем представить с помощью &lt;code&gt;\d+&lt;/code&gt; а знак можно сопоставить с помощью &lt;code&gt;[+-]&lt;/code&gt; . Таким образом, целочисленное регулярное выражение равно</target>
        </trans-unit>
        <trans-unit id="16ed7663dd31b0d719b95952e4dbcc002ac1e075" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt;. Thus the integer regexp is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ce4a00629ba2eb87550ae04e313683cd18e39d" translate="yes" xml:space="preserve">
          <source>The simplest format for a Version Range is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205579583087d3f83514fed292a979acc1fd2056" translate="yes" xml:space="preserve">
          <source>The simplest format for a version specification is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">Самый простой метод использует функцию &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; . Он может дополнять слева или справа пробелами и слева нулями, и это не приведет к усечению результата. Функция &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; может &lt;code&gt;$pad_len&lt;/code&gt; пробелами только строки справа, и она усекает результат до максимальной длины $ pad_len .</target>
        </trans-unit>
        <trans-unit id="60ef9faadf39e8b6092ce866661076ad7721c8c1" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;sprintf&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;pack&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">Самый простой регекс-это просто слово или,более широко,строка символов.Регекс,состоящий из слова,соответствует любой строке,содержащей это слово:</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">Самый простой регэкспресс-это просто слово или,более широко,строка символов.Регеxp,состоящий из слова,соответствует любой строке,содержащей это слово:</target>
        </trans-unit>
        <trans-unit id="0eaf5ad324e3121e2a83d8b08987e28055dbf879" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of just a word matches any string that contains that word:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">Простейший стиль комплектации может быть включен:</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">Простейшая двухуровневая структура данных для встраивания в Perl представляет собой массив массивов,иногда случайно называемый списком.Его довольно легко понять,и почти все,что здесь применимо,также будет применено позже к более прихотливым структурам данных.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
